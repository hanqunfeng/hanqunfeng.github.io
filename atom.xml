<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-07-02T12:27:08.083Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K8S 之 Pod</title>
    <link href="https://blog.hanqunfeng.com/2025/07/02/k8s-pod/"/>
    <id>https://blog.hanqunfeng.com/2025/07/02/k8s-pod/</id>
    <published>2025-07-02T14:30:05.000Z</published>
    <updated>2025-07-02T12:27:08.083Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">k8s Pod 介绍</a></p></li></ul><span id="more"></span><h2 id="Pod-介绍">Pod 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p></li><li class="lvl-2"><p>Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。</p></li><li class="lvl-2"><p>Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p></li><li class="lvl-2"><p>Kubernetes 集群中的 Pod 主要有两种用法：</p><ul class="lvl-2"><li class="lvl-4">运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li><li class="lvl-4">运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nLmg0X.png" alt=""></li></ul></li></ul><h2 id="Pod-管理">Pod 管理</h2><h3 id="Pod-创建">Pod 创建</h3><ul class="lvl-0"><li class="lvl-2"><p><code>run</code> 创建</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx</span><br><span class="line"><span class="comment"># 输出 yaml</span></span><br><span class="line">kubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml</span><br><span class="line"><span class="comment"># 通过 yaml 文件创建</span></span><br><span class="line">kubectl apply -f pod.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>pod.yaml</code> 文件说明</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                   <span class="comment"># 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                        <span class="comment"># 必填。资源类型：Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span>        <span class="comment"># ✅ 可省略。由 Kubernetes 系统自动填充</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span>                   <span class="comment"># ⚠️ 可省略，但建议保留。用于标识 Pod，可供 Service/Selector 匹配</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                    <span class="comment"># 必填。Pod 的名称，命名空间中唯一</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 必填。容器使用的镜像</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 必填。容器名称，在同一个 Pod 内必须唯一</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;                <span class="comment"># ✅ 可省略。未设置 CPU/内存请求或限制时可以不写</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span>        <span class="comment"># ⚠️ 可省略。默认就是 ClusterFirst，仅在自定义 DNS 设置时需要写</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span>          <span class="comment"># ⚠️ 可省略。Pod 默认策略是 Always，除非你是 Job 场景</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;                       <span class="comment"># ✅ 可省略。由 Kubernetes 控制器动态填充，不需要手动定义</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Pod 通常不是直接使用 <code>run</code> 创建的，而是使用工作负载资源创建的，如 Deployment, StatefulSet, DaemonSet。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Pod</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 生成 yaml 文件，不真的执行创建</span></span><br><span class="line">kubectl create deployment nginx --image=nginx --dry-run=client -o yaml &gt; deployment.yaml</span><br><span class="line"><span class="comment"># 通过 yaml 文件创建</span></span><br><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>deployment.yaml</code> 文件说明</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>                  <span class="comment"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>                     <span class="comment"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span>            <span class="comment"># ✅ 可省略，通常由系统自动填充</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                       <span class="comment"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                        <span class="comment"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class="line"><span class="attr">spec:</span>                                <span class="comment"># 配置项</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>                        <span class="comment"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class="line">  <span class="attr">selector:</span>                          <span class="comment"># 选择器，指定要管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>                     <span class="comment"># 标签选择器</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>                     <span class="comment"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;                       <span class="comment"># ✅ 可省略，表示使用默认的滚动更新策略</span></span><br><span class="line">  <span class="attr">template:</span>                          <span class="comment"># 模板，定义 Pod 的内容</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span>        <span class="comment"># ✅ 可省略，由系统自动填充</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>                   <span class="comment"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 容器的名称</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;                <span class="comment"># ✅ 可省略，表示未设置资源请求/限制</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;                           <span class="comment"># ✅ 可省略，状态信息由 Kubernetes 系统自动生成</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">yaml 文件中，出现了 <code>metadata.labels</code>,<code>spec.selector.matchLabels</code> 以及 <code>template.metadata.labels</code>，三者是什么关系？</li></ul><ol><li class="lvl-3">metadata.labels（Deployment 的标签）</li></ol><blockquote><p>给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系<br>常用于资源分组、查找（比如：kubectl get deploy -l app=nginx）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># 属于这个 Deployment 的“标签”，只是标识它自己</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>spec.selector.matchLabels（选择器）</p></li></ol><blockquote><p>指定 Deployment 要管理哪些 Pod<br>必须精确匹配 Pod 的标签<br>决定 Deployment 会不会“接管”某些 Pod</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>template.metadata.labels（模板中的 Pod 标签）</p></li></ol><blockquote><p>Pod 模板中定义的标签<br>Deployment 按这个模板创建 Pod<br>必须与 matchLabels 完全一致，否则会报错</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 的标签，必须与 selector 匹配！</span></span><br></pre></td></tr></table></figure><p>🔁 关系图示意：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Deployment</span></span><br><span class="line"><span class="string">│</span></span><br><span class="line"><span class="string">├─</span> <span class="string">metadata.labels</span>                <span class="string">←</span> <span class="string">Deployment</span> <span class="string">本身的标签（非关键）</span></span><br><span class="line"><span class="string">│</span></span><br><span class="line"><span class="string">├─</span> <span class="string">spec.selector.matchLabels</span> <span class="string">─┐</span></span><br><span class="line"><span class="string">│</span>                             <span class="string">│</span></span><br><span class="line"><span class="string">└─</span> <span class="string">spec.template.metadata.labels</span> <span class="string">←</span> <span class="string">必须匹配</span> <span class="string">selector，才能让</span> <span class="string">Pod</span> <span class="string">被</span> <span class="string">Deployment</span> <span class="string">管理</span></span><br></pre></td></tr></table></figure></div><h3 id="查看-Pod">查看 Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Pod，默认显示 default 命名空间下的 Pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment"># 查看 kube-system 命名空间下的 Pod</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"><span class="comment"># 查看所有命名空间下的 Pod</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line"><span class="comment"># -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 显示 Pod 的标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="comment"># 按 Pod 的标签进程查询</span></span><br><span class="line">kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class="line"><span class="comment"># 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示</span></span><br><span class="line">kubectl get pods -w</span><br><span class="line"><span class="comment">## 状态类型</span></span><br><span class="line">- Pending: Pod 尚未就绪</span><br><span class="line">- ContainerCreating: Pod 正在创建容器</span><br><span class="line">- Running: Pod 正在运行</span><br><span class="line">- Error: Pod 运行错误</span><br><span class="line">- Terminating: Pod 正在删除</span><br><span class="line">- Completed: Pod 执行完成</span><br></pre></td></tr></table></figure><h3 id="查看-Pod-详情">查看 Pod 详情</h3><ul class="lvl-0"><li class="lvl-2"><p>当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br><span class="line">kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程</span></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From               Message</span><br><span class="line">  ----    ------     ----       ----               -------</span><br><span class="line">  <span class="comment"># 被调度器分配到 k8s-worker2 节点</span></span><br><span class="line">  Normal  Scheduled  4s         default-scheduler  Successfully assigned default/nginx to k8s-worker2</span><br><span class="line">  <span class="comment"># 开始拉取镜像</span></span><br><span class="line">  Normal  Pulling    &lt;invalid&gt;  kubelet            Pulling image <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="comment"># 镜像拉取成功</span></span><br><span class="line">  Normal  Pulled     &lt;invalid&gt;  kubelet            Successfully pulled image <span class="string">&quot;nginx&quot;</span> <span class="keyword">in</span> 2.067s (2.067s including waiting). Image size: 72225394 bytes.</span><br><span class="line">  <span class="comment"># 开始创建容器</span></span><br><span class="line">  Normal  Created    &lt;invalid&gt;  kubelet            Created container: nginx</span><br><span class="line">  <span class="comment"># 容器启动成功</span></span><br><span class="line">  Normal  Started    &lt;invalid&gt;  kubelet            Started container nginx</span><br></pre></td></tr></table></figure><h3 id="进入容器">进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx  -- /bin/bash</span><br></pre></td></tr></table></figure><h3 id="删除-Pod">删除 Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt;</span><br><span class="line">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="查看-Pod-日志">查看 Pod 日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br><span class="line">kubectl logs pod/&lt;pod-name&gt;</span><br><span class="line">kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="访问-Pod">访问 Pod</h3><ul class="lvl-0"><li class="lvl-2"><p>我们刚刚创建了一个nginx的pod，该如何访问呢？</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取pod的ip</span></span><br><span class="line">$ k get pod -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   IP             NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx   1/1     Running   0          12m   10.244.126.8   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在任意节点上访问，nginx 默认端口是80</span></span><br><span class="line">$ curl 10.244.126.8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问</p></li></ul><h3 id="一个-Pod-运行多个容器">一个 Pod 运行多个容器</h3><ul class="lvl-0"><li class="lvl-2"><p>yaml 文件</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">multi-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行 pod</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f multi_pod.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看运行结果</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里看到，READY 里有两个，表示两个容器都运行成功</span></span><br><span class="line">$ kubectl get pods -owide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">multi-pod   2/2     Running   0          118s   10.244.194.81   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>访问nginx和tomcat</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问nginx，ngxin默认端口是80</span></span><br><span class="line">curl http://10.244.194.81</span><br><span class="line"><span class="comment"># 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常</span></span><br><span class="line">curl http://10.244.194.81:8080</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进入容器执行命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入nginx容器，-c 指定容器名称</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it multi-pod -c nginx -- /bin/bash</span><br><span class="line"><span class="comment">## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享资源</span></span><br><span class="line">curl http://localhost:8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入tomcat容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it multi-pod -c tomcat -- /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/&quot;&gt;k8s Pod 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Namespace</title>
    <link href="https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/"/>
    <id>https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/</id>
    <published>2025-07-02T13:30:05.000Z</published>
    <updated>2025-07-02T10:56:45.570Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/">k8s Namespace 介绍</a></p></li></ul><span id="more"></span><h2 id="命名空间-Namespace-介绍">命名空间(Namespace) 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。</p></li><li class="lvl-2"><p>基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。</p></li><li class="lvl-2"><p>Namespace 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。</p></li><li class="lvl-2"><p>避免使用前缀 <code>kube-</code> 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。</p></li><li class="lvl-2"><p>Kubernetes 启动时会创建四个初始 Namespace：</p></li></ul><table><thead><tr><th>名称空间名称</th><th>说明</th></tr></thead><tbody><tr><td><code>default</code></td><td>默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。</td></tr><tr><td><code>kube-node-lease</code></td><td>存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。</td></tr><tr><td><code>kube-public</code></td><td>所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。</td></tr><tr><td><code>kube-system</code></td><td>Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。</td></tr></tbody></table><h2 id="查看集群中的命名空间">查看集群中的命名空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namespace 可以简写为 ns</span></span><br><span class="line">kubectl get namespace</span><br><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure><h2 id="创建命名空间">创建命名空间</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>yaml 方式</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># API 版本，可以通过 kubectl api-resources | grep Namespace 获取</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span> <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>       <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;namespace-name&gt;</span> <span class="comment"># 命名空间名称</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过命令行直接生成yaml文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式</span></span><br><span class="line">kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><h2 id="删除命名空间">删除命名空间</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>yaml 方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><h2 id="设置名字空间偏好">设置名字空间偏好</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Pod</span></span><br><span class="line">kubectl config set-context --current --namespace=&lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看资源时指定命名空间">查看资源时指定命名空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n &lt;namespace-name&gt;</span><br><span class="line">kubectl get service -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间下的资源，-A, --all-namespaces</span></span><br><span class="line">kubectl get pod -A</span><br><span class="line">kubectl get service -A</span><br></pre></td></tr></table></figure><h2 id="并非所有对象都在名字空间中">并非所有对象都在名字空间中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位于名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>kubectl api-resources</code> 这个命令很有用，我们可以通过该命令获取所有资源的 <code>简写</code>，也可以获取资源的 <code>apiVersion</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources</span><br><span class="line">NAME: 资源名称</span><br><span class="line">SHORTNAMES: 简写</span><br><span class="line">APIVERSION: apiVersion</span><br><span class="line">NAMESPACED: 是否在名字空间中</span><br><span class="line">KIND: 资源类型</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-中关于-命名空间（namespace）与-DNS-的机制">Kubernetes 中关于 命名空间（namespace）与 DNS 的机制</h2><ul class="lvl-0"><li class="lvl-2"><p>Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。</p></li><li class="lvl-2"><p>命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。</p></li></ul><h3 id="举个例子说明服务-DNS-是怎么工作的">举个例子说明服务 DNS 是怎么工作的</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：你在两个命名空间中部署了两个 nginx 服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名空间 dev 中创建服务 nginx</span></span><br><span class="line">kubectl create ns dev</span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=2 -n dev</span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort -n dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名空间 prod 中也创建服务 nginx</span></span><br><span class="line">kubectl create ns prod</span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=2 -n prod</span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort -n prod</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 <code>nginx.dev.svc.cluster.local</code>，也就是 <code>&lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://nginx.prod.svc.cluster.local</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/&quot;&gt;k8s Namespace 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 sealos</title>
    <link href="https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/"/>
    <id>https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/</id>
    <published>2025-07-01T13:30:05.000Z</published>
    <updated>2025-07-02T03:14:34.095Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://sealos.run/docs/k8s/quick-start/deploy-kubernetes">sealos官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/labring/sealos">sealos Github</a></p></li></ul><span id="more"></span><h2 id="安装前设置-所有节点">安装前设置(所有节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>准备三台可以连接外网的主机，不要安装docker,k8s等，如已安装需先卸载</p></li><li class="lvl-2"><p>(推荐)升级系统内核，本文中非必须，升级内核方法参看 <a href="/2025/06/29/k8s-install-kubeadm/" title="Linux 安装 K8S 之 kubeadm">Linux 安装 K8S 之 kubeadm</a></p></li></ul><h3 id="每个集群节点应该有不同的主机名，主机名不要带下划线">每个集群节点应该有不同的主机名，主机名不要带下划线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加主机名映射: vi /etc/hosts</span></span><br><span class="line">10.211.55.12 k8s-m1</span><br><span class="line">10.211.55.13 k8s-w1</span><br><span class="line">10.211.55.14 k8s-w2</span><br></pre></td></tr></table></figure><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-sealos">安装 sealos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/labring/sealos/releases/download/v5.0.1/sealos_5.0.1_linux_amd64.rpm</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y sealos_5.0.1_linux_amd64.rpm</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 sealos 的自动补全</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(sealos completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="创建k8s集群-master">创建k8s集群(master)</h2><ul class="lvl-0"><li class="lvl-2"><p>创建集群: 使用sealos创建集群只需要一行命令，目前官网示例中的k8s版本为v1.29.9(小版本号越高越稳定)</p></li><li class="lvl-2"><p>可以在<a href="https://hub.docker.com">docker hub</a>上查询，或者使用 <a href="https://explore.ggcr.dev/">Registry Explorer</a> 查看如下镜像的所有版本，不建议使用太高的版本，有可能安装失败。</p></li><li class="lvl-2"><p>注意 sealos 与 kubernetes 的版本有对应关系，目前 <code>Sealos &gt;=v5.0.0</code> 对应的 <code>K8s &gt;=1.28</code>，具体可以从<a href="https://sealos.run/docs/k8s/quick-start/deploy-kubernetes">sealos官网</a>查询</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内可以在镜像前面加上 registry.cn-shanghai.aliyuncs.com/</span></span><br><span class="line"><span class="comment"># sealos 推荐的网络接口是 cilium</span></span><br><span class="line">$ sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="comment"># -masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span></span><br><span class="line"><span class="comment"># -nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span></span><br><span class="line"><span class="comment"># -p, --passwd: 指定 SSH 登录密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装成功会显示如下内容</span></span><br><span class="line">ℹ️  Using Cilium version 1.13.4</span><br><span class="line">🔮 Auto-detected cluster name: kubernetes</span><br><span class="line">🔮 Auto-detected datapath mode: tunnel</span><br><span class="line">🔮 Auto-detected kube-proxy has been installed</span><br><span class="line">2025-07-01T16:59:27 info succeeded <span class="keyword">in</span> creating a new cluster, enjoy it!</span><br><span class="line">2025-07-01T16:59:27 info</span><br><span class="line">      ___           ___           ___           ___       ___           ___</span><br><span class="line">     /\  \         /\  \         /\  \         /\__\     /\  \         /\  \</span><br><span class="line">    /::\  \       /::\  \       /::\  \       /:/  /    /::\  \       /::\  \</span><br><span class="line">   /:/\ \  \     /:/\:\  \     /:/\:\  \     /:/  /    /:/\:\  \     /:/\ \  \</span><br><span class="line">  _\:\~\ \  \   /::\~\:\  \   /::\~\:\  \   /:/  /    /:/  \:\  \   _\:\~\ \  \</span><br><span class="line"> /\ \:\ \ \__\ /:/\:\ \:\__\ /:/\:\ \:\__\ /:/__/    /:/__/ \:\__\ /\ \:\ \ \__\</span><br><span class="line"> \:\ \:\ \/__/ \:\~\:\ \/__/ \/__\:\/:/  / \:\  \    \:\  \ /:/  / \:\ \:\ \/__/</span><br><span class="line">  \:\ \:\__\    \:\ \:\__\        \::/  /   \:\  \    \:\  /:/  /   \:\ \:\__\</span><br><span class="line">   \:\/:/  /     \:\ \/__/        /:/  /     \:\  \    \:\/:/  /     \:\/:/  /</span><br><span class="line">    \::/  /       \:\__\         /:/  /       \:\__\    \::/  /       \::/  /</span><br><span class="line">     \/__/         \/__/         \/__/         \/__/     \/__/         \/__/</span><br><span class="line"></span><br><span class="line">                  Website: https://www.sealos.io/</span><br><span class="line">                  Address: github.com/labring/sealos</span><br><span class="line">                  Version: 5.0.1-2b74a1281</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建集群成功后，查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">$ kubectl version</span><br><span class="line">Client Version: v1.29.9</span><br><span class="line">Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3</span><br><span class="line">Server Version: v1.29.9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes -owide</span><br><span class="line">NAME     STATUS   ROLES           AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                            KERNEL-VERSION             CONTAINER-RUNTIME</span><br><span class="line">k8s-m1   Ready    control-plane   3m11s   v1.29.9   10.211.55.12   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line">k8s-w1   Ready    &lt;none&gt;          2m52s   v1.29.9   10.211.55.13   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line">k8s-w2   Ready    &lt;none&gt;          2m55s   v1.29.9   10.211.55.14   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看资源</span></span><br><span class="line">$ kubectl get all -A -owide</span><br><span class="line">NAMESPACE     NAME                                   READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   pod/cilium-bbbdl                       1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-cz47k                       1/1     Running   0          3m47s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-operator-6946ccbcc5-cxnn4   1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-vfc22                       1/1     Running   0          3m47s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/coredns-76f75df574-2ln5x           1/1     Running   0          3m54s   10.0.0.74      k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/coredns-76f75df574-plsds           1/1     Running   0          3m54s   10.0.0.146     k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/etcd-k8s-m1                        1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-apiserver-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-controller-manager-k8s-m1     1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-4xbzt                   1/1     Running   0          3m51s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-rjs8h                   1/1     Running   0          3m54s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-xv4fg                   1/1     Running   0          3m55s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-scheduler-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-sealos-lvscare-k8s-w1         1/1     Running   0          3m31s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-sealos-lvscare-k8s-w2         1/1     Running   0          3m34s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE     SELECTOR</span><br><span class="line">default       service/kubernetes    ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP                  4m8s    &lt;none&gt;</span><br><span class="line">kube-system   service/hubble-peer   ClusterIP   10.96.1.9    &lt;none&gt;        443/TCP                  3m47s   k8s-app=cilium</span><br><span class="line">kube-system   service/kube-dns      ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   4m7s    k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS     IMAGES                               SELECTOR</span><br><span class="line">kube-system   daemonset.apps/cilium       3         3         3       3            3           kubernetes.io/os=linux   3m47s   cilium-agent   quay.io/cilium/cilium:v1.13.4        k8s-app=cilium</span><br><span class="line">kube-system   daemonset.apps/kube-proxy   3         3         3       3            3           kubernetes.io/os=linux   4m7s    kube-proxy     registry.k8s.io/kube-proxy:v1.29.9   k8s-app=kube-proxy</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                              READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class="line">kube-system   deployment.apps/cilium-operator   1/1     1            1           3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator</span><br><span class="line">kube-system   deployment.apps/coredns           2/2     2            2           4m7s    coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                                         DESIRED   CURRENT   READY   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class="line">kube-system   replicaset.apps/cilium-operator-6946ccbcc5   1         1         1       3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator,pod-template-hash=6946ccbcc5</span><br><span class="line">kube-system   replicaset.apps/coredns-76f75df574           2         2         2       3m54s   coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns,pod-template-hash=76f75df574</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试：用K8S部署Nginx">测试：用K8S部署Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class="line">$ k get pods,svc -owide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-7854ff8877-wgfxc   1/1     Running   0          19s   10.0.1.204   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        44m   &lt;none&gt;</span><br><span class="line">service/nginx        NodePort    10.96.2.54   &lt;none&gt;        80:31044/TCP   5s    app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问任意nodeIP:31044</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除测试资源</span></span><br><span class="line"><span class="comment">## 删除deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="comment">## 删除service</span></span><br><span class="line">kubectl delete service nginx</span><br></pre></td></tr></table></figure><h2 id="sealos-命令">sealos 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>sealos 命令概览</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Cluster Management Commands:</span><br><span class="line">  apply         使用 Clusterfile 在 Kubernetes 集群中运行云镜像</span><br><span class="line">  cert          更新 Kubernetes API Server 的证书</span><br><span class="line">  run           轻松运行云原生应用，可用于已有或新建集群</span><br><span class="line">  reset         重置集群中的所有内容</span><br><span class="line">  status        查看 sealos 的状态</span><br><span class="line"></span><br><span class="line">Node Management Commands:</span><br><span class="line">  add           向集群中添加节点</span><br><span class="line">  delete        从集群中移除节点</span><br><span class="line"></span><br><span class="line">Remote Operation Commands:</span><br><span class="line">  <span class="built_in">exec</span>          在指定节点上执行 shell 命令或脚本</span><br><span class="line">  scp           将文件复制到指定节点的远程主机上</span><br><span class="line"></span><br><span class="line">Experimental Commands:</span><br><span class="line">  registry      与镜像仓库相关的实验性功能</span><br><span class="line"></span><br><span class="line">Container and Image Commands:</span><br><span class="line">  build         根据 Containerfile 或 Kubefile 构建镜像</span><br><span class="line">  create        创建集群但不执行命令，用于检查镜像</span><br><span class="line">  diff          查看对象文件系统的更改</span><br><span class="line">  inspect       检查容器或镜像的配置信息</span><br><span class="line">  images        列出本地存储中的镜像</span><br><span class="line">  load          从归档文件加载镜像</span><br><span class="line">  login         登录到容器镜像仓库</span><br><span class="line">  <span class="built_in">logout</span>        登出容器镜像仓库</span><br><span class="line">  manifest      操作 manifest 列表和镜像索引</span><br><span class="line">  merge         合并多个镜像为一个</span><br><span class="line">  pull          从指定位置拉取镜像</span><br><span class="line">  push          将镜像推送到指定目标</span><br><span class="line">  rmi           从本地删除一个或多个镜像</span><br><span class="line">  save          将镜像保存为归档文件</span><br><span class="line">  tag           为本地镜像添加额外的名称标签</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  completion    生成指定 shell 的自动补全脚本</span><br><span class="line">  docs          生成 API 参考文档</span><br><span class="line">  <span class="built_in">env</span>           输出 sealos 使用的所有环境变量信息</span><br><span class="line">  gen           生成包含默认设置的 Clusterfile</span><br><span class="line">  version       打印版本信息</span><br></pre></td></tr></table></figure><h3 id="集群管理-master节点执行命令">集群管理(master节点执行命令)</h3><ul class="lvl-0"><li class="lvl-2"><p>创建集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line">-masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span><br><span class="line">-nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span><br><span class="line">-p, --passwd: 指定 SSH 登录密码</span><br><span class="line">-u, --user: 登录用户名，默认为 root</span><br><span class="line">-i, --pk=<span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: 指定 SSH 密钥文件路径</span><br><span class="line">--port: 指定 SSH 端口，默认为 22</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Clusterfile 方式创建集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成集群配置文件，Clusterfile就是一个yaml文件，里面包含集群的配置信息</span></span><br><span class="line">sealos gen labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd] &gt; Clusterfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行配置文件</span></span><br><span class="line">sealos apply -f Clusterfile</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos status</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>清除K8s集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos reset</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>更新 Kubernetes API 服务器的证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos 创建的证书存放在 /etc/kubernetes/pki/ 下，默认证书有效期为 100 年</span></span><br><span class="line"><span class="comment"># 更新证书一般只会在添加新的访问ip或域名时才需要</span></span><br><span class="line">sealos cert --alt-names apiserver.cluster.local,10.211.55.12,127.0.0.1,localhost</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># --alt-names: 添加新的访问ip或域名，多个逗号分隔</span></span><br><span class="line"><span class="comment"># -c, --cluster=&#x27;default&#x27;: 要执行 exec 操作的集群的名称。默认为 default。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新证书后，你可以使用以下命令进行校验：</span></span><br><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure><blockquote><p>在执行此操作之前，你最好先备份旧的证书。<br>执行 sealos cert 命令后，会更新集群 API 服务器的证书，你无需手动重启 API 服务器，sealos会自动帮你重启服务。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>查看环境变量</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v 显示变量的说明</span></span><br><span class="line">sealos <span class="built_in">env</span> -v</span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line">SEALOS_PROMPT=enabled <span class="comment"># 是否启用终端中的交互提示功能。</span></span><br><span class="line">SEALOS_RUNTIME_ROOT=/root/.sealos <span class="comment"># Sealos 的运行时根目录，用于持久化运行相关的操作或配置。</span></span><br><span class="line">SEALOS_DATA_ROOT=/var/lib/sealos  <span class="comment"># 集群在远程节点上的根目录路径，用于存储集群相关的数据。</span></span><br><span class="line">BUILDAH_FORMAT=oci <span class="comment"># 镜像构建时使用的格式，`oci` 表示符合 OCI 镜像规范。</span></span><br><span class="line">BUILDAH_LOG_LEVEL= <span class="comment"># buildah 模块中使用的日志级别，可以是 &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;, 或 &quot;panic&quot;。</span></span><br><span class="line">CONTAINERS_STORAGE_CONF= <span class="comment"># 容器存储配置文件的路径，设置这个变量可以覆盖默认的配置位置。</span></span><br><span class="line">SEALOS_SYNC_WORKDIR=<span class="literal">true</span> <span class="comment"># 是否将运行时根目录（SEALOS_RUNTIME_ROOT）同步到所有 master 节点，作为备份用途。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群中执行命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos exec &quot;shell command or script&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在所有节点上执行命令</span></span><br><span class="line">sealos <span class="built_in">exec</span> <span class="string">&quot;cat /etc/hosts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class="line">sealos <span class="built_in">exec</span> <span class="string">&quot;cat /etc/hosts&quot;</span> --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群间拷贝文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos scp &quot;source file path&quot; &quot;destination file path&quot;</span></span><br><span class="line"><span class="comment"># 在所有节点上执行命令</span></span><br><span class="line">sealos scp ~/Clusterfile /tmp/Clusterfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class="line">sealos scp ~/Clusterfile /tmp/Clusterfile --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure><h3 id="节点管理-master节点执行命令">节点管理(master节点执行命令)</h3><ul class="lvl-0"><li class="lvl-2"><p>添加 master 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 master 节点后，总的 master 节点个数必须为奇数，否则会报错</span></span><br><span class="line">sealos add --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 worker 节点，多个都会分隔</span></span><br><span class="line">sealos add --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除 master 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 master 节点后，剩余的 master 节点个数必须为奇数，否则会报错</span></span><br><span class="line">sealos delete --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos delete --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure><h3 id="镜像管理">镜像管理</h3><ul class="lvl-0"><li class="lvl-2"><p>查看所有镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sealos images</span><br><span class="line">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">docker.io/labring/kubernetes                               v1.29.9    bca192f35556   2 months ago    669 MB</span><br><span class="line">docker.io/labring/cilium                                   v1.13.4    71aa52ad0a11   23 months ago   483 MB</span><br><span class="line">docker.io/labring/helm                                     v3.9.4     3376f6822067   2 years ago     46.4 MB</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos rmi [image_id] | [image_name]</span></span><br><span class="line">sealos rmi docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>拉取镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos pull docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录镜像仓库，建议登录仓库，这样可以提高拉取镜像的次数，避免拉取镜像失败</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker.io 官方dockerhub镜像仓库</span></span><br><span class="line">sealos login docker.io -u [username] -p [password]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为镜像打tag</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos tag docker.io/labring/kubernetes:v1.29.9 docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>推送镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos push docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看镜像详情</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos inspect [image_id] | [image_name]</span></span><br><span class="line">sealos inspect docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登出镜像仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登出指定的仓库</span></span><br><span class="line">sealos <span class="built_in">logout</span> docker.io</span><br><span class="line"><span class="comment"># 登出所有仓库</span></span><br><span class="line">sealos <span class="built_in">logout</span> --all</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过 Dockerfile 构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与 docker build 类似，构建好的镜像会增加前缀 localhost/</span></span><br><span class="line">sealos build -t myapp:v1.0.0 -f Dockerfile .</span><br></pre></td></tr></table></figure><h3 id="容器管理">容器管理</h3><ul class="lvl-0"><li class="lvl-2"><p>查看所有容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看容器详情</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos inspect [container_id] | [container_name]</span></span><br><span class="line">sealos inspect bca192f35556</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://sealos.run/docs/k8s/quick-start/deploy-kubernetes&quot;&gt;sealos官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/labring/sealos&quot;&gt;sealos Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 kubeadm</title>
    <link href="https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/"/>
    <id>https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/</id>
    <published>2025-06-29T14:30:05.000Z</published>
    <updated>2025-07-02T10:00:31.252Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/">使用 kubeadm 引导集群</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/">kubeadm 命令指南</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/">用 kubeadm 进行管理</a></p></li></ul><span id="more"></span><h2 id="安装前设置-所有节点">安装前设置(所有节点)</h2><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-docker-可选">安装 <code>docker</code>(可选)</h3><ul class="lvl-0"><li class="lvl-2"><p>k8s 使用<code>docker</code>作为容器运行时才需要安装，安装方法参见 <a href="/2025/05/20/docker-install/" title="Linux 安装 Docker">Linux 安装 Docker</a></p></li></ul><h3 id="创建用户">创建用户</h3><ul class="lvl-0"><li class="lvl-2"><p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建用户</span></span><br><span class="line">$ <span class="built_in">sudo</span> useradd -m -s /bin/bash centos</span><br><span class="line"><span class="comment"># 2.添加到docker用户组</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker centos</span><br><span class="line"><span class="comment"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG wheel centos</span><br><span class="line"><span class="comment">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class="line"><span class="comment"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class="line">$ su - centos</span><br></pre></td></tr></table></figure><h3 id="升级内核">升级内核</h3><ul class="lvl-0"><li class="lvl-2"><p>由 kubeadm 创建的 Kubernetes 集群依赖于使用内核特性的相关软件。</p></li><li class="lvl-3"><p>Kubernetes 集群的节点对于使用 Linux 内核版本要求参加<a href="https://kubernetes.io/zh-cn/docs/reference/node/kernel-version-requirements/">Linux 内核版本要求</a></p></li><li class="lvl-3"><p>kubeadm 项目支持 LTS 内核。参阅 <a href="https://www.kernel.org/category/releases.html">LTS 内核列表</a>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前内核版本，可以看到当前内核版本为 4.18.0</span></span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">4.18.0-553.el8_10.x86_64</span><br><span class="line"><span class="comment">#查看 yum 中可升级的内核版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list kernel --showduplicates</span><br><span class="line"><span class="comment">#如果list中有需要的版本可以直接执行 update 升级，多数是没有的，所以要按以下步骤操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入ELRepo软件仓库的公共秘钥</span></span><br><span class="line">$ <span class="built_in">sudo</span> rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#Centos7系统安装ELRepo</span></span><br><span class="line"><span class="comment"># $sudo yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span></span><br><span class="line"><span class="comment">#Centos8系统安装ELRepo</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ELRepo提供的内核版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#kernel-lt：表示longterm，即长期支持的内核，当前lt内核版本为 5.4.295</span></span><br><span class="line"><span class="comment">#kernel-ml：表示mainline，即当前主线的内核，当前ml内核版本为 6.15.4，笔者测试安装该版本内核最后创建集群时会失败</span></span><br><span class="line"><span class="comment">#安装lt内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum --enablerepo=elrepo-kernel install kernel-lt.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已安装的内核版本，可以看到 刚刚安装的 5.4.295 内核版本的两个文件</span></span><br><span class="line">$ <span class="built_in">ls</span> -lh /boot/vmlinuz-* /boot/initramfs-* | grep <span class="string">&quot;5.4&quot;</span></span><br><span class="line">-rw-------  1 root root  29M 6月  29 17:15 /boot/initramfs-5.4.295-1.el8.elrepo.x86_64.img</span><br><span class="line">-rwxr-xr-x  1 root root 9.5M 6月  28 01:21 /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可以使用的内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --info=ALL | grep ^kernel</span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64&quot;</span></span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-4.18.0-553.el8_10.x86_64&quot;</span></span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-0-rescue-88f75739047993488aacc30b9cd25ca0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认内核，默认情况下，系统会自动将新安装的内核设置为默认启动内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --default-kernel</span><br><span class="line">/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有自动启用，则通过该命令设置默认内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --set-default /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ <span class="built_in">sudo</span> reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启登录后验证内核版本</span></span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">5.4.295-1.el8.elrepo.x86_64</span><br></pre></td></tr></table></figure><h3 id="将-SELinux-设置为-permissive-模式（相当于将其禁用）">将 SELinux 设置为 permissive 模式（相当于将其禁用）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> setenforce 0</span><br><span class="line">$ <span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><h3 id="禁用Firewalld">禁用Firewalld</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了方便，这里可以禁用 firewalld</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop firewalld</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h4 id="不关-Firewalld-应该开放哪些端口？-实测还是会遇到各种各样的问题">不关 Firewalld 应该开放哪些端口？(实测还是会遇到各种各样的问题)</h4><ul class="lvl-0"><li class="lvl-2"><p>Master 节点需要开放的端口</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>6443</strong></td><td>TCP</td><td>kube-apiserver，用于 kubectl 与集群通信</td></tr><tr><td><strong>2379-2380</strong></td><td>TCP</td><td>etcd 集群通信（仅在你自己部署 etcd 时）</td></tr><tr><td><strong>10250</strong></td><td>TCP</td><td>kubelet 监听端口，供 apiserver 与节点通信</td></tr><tr><td><strong>10259</strong></td><td>TCP</td><td>kube-scheduler</td></tr><tr><td><strong>10257</strong></td><td>TCP</td><td>kube-controller-manager</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Worker 节点需要开放的端口</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>10250</strong></td><td>TCP</td><td>kubelet 与 apiserver 通信</td></tr><tr><td><strong>30000-32767</strong></td><td>TCP</td><td>NodePort 服务默认端口范围</td></tr><tr><td><strong>10255</strong></td><td>TCP</td><td>kubelet 只读端口（默认关闭，可不开放）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你使用的是 Calico 网络插件</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>179</strong></td><td>TCP</td><td>BGP 通信端口，用于 Calico 节点间路由（若使用 BGP 模式）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你使用的是 Flannel（VXLAN 模式）</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>8472</strong></td><td>UDP</td><td>VXLAN 数据通信</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Ingress 控制器（比如 NGINX Ingress）</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>80</strong> / <strong>443</strong></td><td>TCP</td><td>提供 HTTP/HTTPS 服务访问（Ingress 服务）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例命令：使用 firewall-cmd 开放端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 firewalld</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start firewalld</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：开放常用端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=6443/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=2379-2380/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10250/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10259/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10257/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=30000-32767/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=179/tcp       <span class="comment"># 如果用 Calico</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=8472/udp      <span class="comment"># 如果用 Flannel</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=80/tcp        <span class="comment"># Ingress</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=443/tcp       <span class="comment"># Ingress</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 Calico 的封装协议 IPIP ,允许 IPIP 协议（协议号 4）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p 4 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 Calico 使用 VXLAN 模式，则需要开放 4789 端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class="line"><span class="comment"># Calico Typha 网络</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=5473/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calico WireGuard（IPv4 和 IPv6）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=51820/udp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=51821/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开放的端口</span></span><br><span class="line">$ <span class="built_in">sudo</span> firewall-cmd --list-ports</span><br><span class="line">80/tcp 179/tcp 443/tcp 2377/tcp 2379-2380/tcp 6443/tcp 7946/tcp 10250/tcp 10257/tcp 10259/tcp 30000-32767/tcp 4789/udp 7946/udp 8472/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开放的直接规则</span></span><br><span class="line">$ <span class="built_in">sudo</span> firewall-cmd --direct --get-all-rules</span><br><span class="line">ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="关闭swap">关闭swap</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapoff -a</span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="加载内核模块">加载内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br></pre></td></tr></table></figure><h3 id="设置内核参数">设置内核参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/kubernetes.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br></pre></td></tr></table></figure><h3 id="安装containerd">安装containerd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="built_in">sudo</span> yum config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="built_in">sudo</span> yum install -y containerd.io</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/containerd</span><br><span class="line"><span class="built_in">sudo</span> containerd config default | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Systemd为cgroup driver</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now containerd</span><br></pre></td></tr></table></figure><h3 id="安装cri-dockerd-可选">安装cri-dockerd(可选)</h3><ul class="lvl-0"><li class="lvl-2"><p>如果使用 containerd，则不需要安装 cri-dockerd</p></li><li class="lvl-2"><p>Kubernetes 1.24+ 默认移除了 dockershim，所以你必须安装 cri-dockerd 才能继续使用 Docker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并安装 cri-dockerd RPM，目前最新版是 0.3.19，fc35: Fedora 35 构建，适配 RHEL/CentOS 8 系统的 glibc 和 libstdc++</span></span><br><span class="line">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.19/cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class="line"><span class="comment"># 安装时报错：cri-dockerd-0.3.19-3.fc35.x86_64.rpm 依赖 GLIBC ≥ 2.32 和 2.34，但 CentOS 8 系统只提供 GLIBC 2.28。</span></span><br><span class="line">$ <span class="built_in">sudo</span> dnf install -y ./cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新下载一个兼容的版本即可，这里选择：cri-dockerd-0.3.14-3.el8.x86_64.rpm</span></span><br><span class="line">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.14/cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class="line">$ <span class="built_in">sudo</span> dnf install -y ./cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载服务</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="comment"># 加入开机启动并立刻启动</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now cri-docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的 kubeadm 命令 都要加上 --cri-socket unix:///var/run/cri-dockerd.sock</span></span><br></pre></td></tr></table></figure><h3 id="安装-kubelet-kubeadm-kubectl">安装 kubelet, kubeadm, kubectl</h3><ul class="lvl-0"><li class="lvl-2"><p>添加 Kubernetes YUM 源，k8s 的版本从<a href="https://kubernetes.io/zh-cn/docs/home/supported-doc-versions/">官网</a>获取</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理yum缓存并重新建立缓存</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum clean all &amp;&amp; <span class="built_in">sudo</span> yum makecache</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 kubelet, kubeadm, kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm有什么版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates  kubeadm</span><br><span class="line"><span class="comment"># 不指定版本默认那种最新版</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用kubelet</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器运行时为containerd，这里通过 crictl 指定容器运行时为 containerd</span></span><br><span class="line"><span class="comment"># 配置文件：/etc/crictl.yaml</span></span><br><span class="line">$ <span class="built_in">sudo</span> crictl config runtime-endpoint /run/containerd/containerd.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">$ kubeadm version</span><br><span class="line">$ kubelet --version</span><br><span class="line">$ kubectl version --client</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">$ kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="创建集群-master节点">创建集群(master节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>master节点: [hostname: k8s-master, IP: 10.211.55.11]</p></li><li class="lvl-2"><p>初始化master节点的控制面板，容器运行时基于 <code>containerd</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubeadm init --help可以查看命令的具体参数用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在master节点执行初始化（node节点不用执行）</span></span><br><span class="line"><span class="comment"># --apiserver-advertise-address  指定apiserver的IP，即master节点的IP</span></span><br><span class="line"><span class="comment"># --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers 设置镜像仓库为国内镜像仓库</span></span><br><span class="line"><span class="comment"># --kubernetes-version  设置k8s的版本，跟kubeadm版本一致</span></span><br><span class="line"><span class="comment"># --service-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class="line"><span class="comment"># --pod-network-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class="line"><span class="comment"># --cri-socket unix:///var/run/cri-dockerd.sock  设置cri使用cri-dockerd</span></span><br><span class="line"><span class="comment"># --ignore-preflight-errors=all  忽略所有预检错误（Preflight Errors）。这会跳过对系统状态的某些检查，例如是否启用了 swap、CPU 核心数、系统配置等。不推荐用于生产，只用于调试或测试环境。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.211.55.11 \</span><br><span class="line">--kubernetes-version v1.33.2 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"><span class="comment">## 安装成功会打印如下信息</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ k get cs</span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE   ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   ok</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为当前用户授予连接集群的权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装网络插件：<a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">k8s支持的网络插件</a>，</p></li><li class="lvl-2"><p><a href="https://www.tigera.io/project-calico/">calico官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/projectcalico/calico">calico GitHub</a>]</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装calico前查看pod，-A 查看所有命名空间</span></span><br><span class="line">$ kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                          READY   STATUS    RESTARTS      AGE</span><br><span class="line">kube-system   coredns-674b8bbfcf-8xllc      0/1     Pending   0             116m</span><br><span class="line">kube-system   coredns-674b8bbfcf-w2sxz      0/1     Pending   0             116m</span><br><span class="line">kube-system   etcd-k8s                      1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-apiserver-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-controller-manager-k8s   1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-proxy-94zqw              1/1     Running   1 (74m ago)   116m</span><br><span class="line">kube-system   kube-scheduler-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载yaml文件，目前最新版为 v3.30.2</span></span><br><span class="line">$ curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">$ kubectl apply -f calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装calico后查看pod，在安装 Calico 之前 CoreDNS 是 Pending 状态，现在已经变成 Running</span></span><br><span class="line"><span class="comment"># -o wide: 显示pod的详细信息</span></span><br><span class="line">$ kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS      AGE     IP             NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   calico-kube-controllers-7bfdc5b57c-9qv9m   1/1     Running   0             6m23s   10.244.77.1    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-m7wc5                          1/1     Running   0             6m23s   10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-8xllc                   1/1     Running   0             123m    10.244.77.3    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-w2sxz                   1/1     Running   0             123m    10.244.77.2    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-k8s                                   1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-k8s                1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-94zqw                           1/1     Running   1 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><blockquote><p>calica 安装后可能出现不正常的情况，比如 <code>calico-node-xxx</code> 的pod始终无法正常运行，此时可以尝试重新安装 calica</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 calico</span></span><br><span class="line">$ kubectl delete -f calico.yaml</span><br><span class="line"><span class="comment">#如果是重装calico，需要先清除旧的配置</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/cni/net.d/</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/calico</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新安装 calico</span></span><br><span class="line">$ kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><h2 id="添加节点-worker节点">添加节点(worker节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>worker节点: [hostname: k8s-worker1, IP: 10.211.55.15]</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在待加入的节点上执行如下命令，如果忘记token，则使用下文的命令重新获取</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING SystemVerification]: cgroups v1 support is <span class="keyword">in</span> maintenance mode, please migrate to cgroups v2</span><br><span class="line">[preflight] Reading configuration from the <span class="string">&quot;kubeadm-config&quot;</span> ConfigMap <span class="keyword">in</span> namespace <span class="string">&quot;kube-system&quot;</span>...</span><br><span class="line">[preflight] Use <span class="string">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">&quot;/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span></span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-check] Waiting <span class="keyword">for</span> a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s</span><br><span class="line">[kubelet-check] The kubelet is healthy after 1.004135788s</span><br><span class="line">[kubelet-start] Waiting <span class="keyword">for</span> the kubelet to perform the TLS Bootstrap</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node <span class="built_in">join</span> the cluster.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果上面的令牌忘记了，或者新的 worker 节点加入，在 master 上执行下面的命令，生成新的令牌</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm token create --print-join-command</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token 5o3p2i.gj95aopph0xbrcig --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 master 节点上查看新创建的资源，默认情况下 work 节点不支持管理 k8s</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME          STATUS     ROLES           AGE     VERSION</span><br><span class="line">k8s           Ready      control-plane   3h33m   v1.33.2</span><br><span class="line">k8s-worker1   Ready      &lt;none&gt;          115s    v1.33.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod list</span></span><br><span class="line">$ kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   0          37m     10.244.235.193   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-7pbbq                          1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-w47qq                          1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-2tvld                   1/1     Running   0          37m     10.244.235.195   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-h6kx7                   1/1     Running   0          37m     10.244.235.194   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-k8s-master                            1/1     Running   2          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-k8s-master                  1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-k8s-master         1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-nkbns                           1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-plqw8                           1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-k8s-master                  1/1     Running   4          38m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使 work 节点支持管理 k8s(可选)：远程管理</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 master 节点中的 ~/.kube/config 复制到 work 节点的 ~/.kube/config 即可</span></span><br><span class="line"><span class="comment"># 在 master 节点执行</span></span><br><span class="line">scp ~/.kube/config k8s-work1:/tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 work 节点执行</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.kube</span><br><span class="line"><span class="built_in">mv</span> /tmp/config ~/.kube/config</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除work节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker节点上执行如下命令</span></span><br><span class="line"><span class="comment">## 在移除节点之前，请重置 kubeadm 安装的状态</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm reset</span><br><span class="line"><span class="comment">## 重置过程不会重置或清除 iptables 规则或 IPVS 表。如果你希望重置 iptables，则必须手动进行</span></span><br><span class="line">$ iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line"></span><br><span class="line"><span class="comment"># master 节点上删除节点</span></span><br><span class="line">$ kubectl delete node k8s-worker1</span><br></pre></td></tr></table></figure><h2 id="测试：用K8S部署Nginx">测试：用K8S部署Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class="line">$ kubectl get pod,svc -o wide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-5869d7778c-95z74   1/1     Running   0          19m   10.244.194.65   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        61m   &lt;none&gt;</span><br><span class="line">service/nginx        NodePort    10.96.48.156   &lt;none&gt;        80:30291/TCP   14m   app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问任意nodeIP:30291</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除测试资源</span></span><br><span class="line"><span class="comment">## 删除deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="comment">## 删除service</span></span><br><span class="line">kubectl delete service nginx</span><br></pre></td></tr></table></figure><h2 id="通过-kubeadm-卸载-Kubernetes">通过 kubeadm 卸载 Kubernetes</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 kubelet 相关组件,删除 /etc/kubernetes 配置,清除证书、状态目录等,取消 iptables 规则,清除容器运行时中的 Pod、镜像信息等</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm reset</span><br><span class="line"><span class="comment"># 虽然 kubeadm reset 已经会清除大部分内容，但以下文件和配置可能依然存在，建议一并手动清理</span></span><br><span class="line"><span class="comment">## 删除 kubeconfig 文件（本地 kubectl 配置）</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="comment">## 清理 etcd 数据（如你启用了本地 etcd）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/etcd</span><br><span class="line"><span class="comment">## 清理 CNI 网络配置和状态</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/cni/net.d</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/cni/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/kubelet/*</span><br><span class="line"><span class="comment"># 清理 Calico</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/calico</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 iptables</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -t mangle -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -t mangle -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -P INPUT ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -P FORWARD ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -P OUTPUT ACCEPT</span><br></pre></td></tr></table></figure><h2 id="停止和禁用-kubelet-服务">停止和禁用 kubelet 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop kubelet</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> kubelet</span><br></pre></td></tr></table></figure><h2 id="升级-kubeadm-集群">升级 kubeadm 集群</h2><ul class="lvl-0"><li class="lvl-2"><p>将 kubeadm 创建的 Kubernetes 集群从 1.32.x 版本 升级到 1.33.x 版本以及从 1.33.x 升级到 1.33.y（其中 y &gt; x），略过次版本号的升级是 不被支持的。</p></li></ul><h3 id="升级步骤">升级步骤</h3><h4 id="升级-master-节点">升级 master 节点</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">升级 master 节点</a></p></li><li class="lvl-2"><p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p></li><li class="lvl-2"><p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubeadm 可以升级的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class="line"><span class="comment"># 查看升级后的版本</span></span><br><span class="line">kubeadm version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证升级计划: 此命令检查你的集群是否可被升级，并取回你要升级的目标版本。 命令也会显示一个包含组件配置版本状态的表格。</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade plan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级 master 节点: 这一步会升级 kube-apiserver、controller-manager、scheduler 等静态 Pod。</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade apply v1.33.3</span><br><span class="line"><span class="comment">## 一旦该命令结束，你应该会看到：</span></span><br><span class="line"> [upgrade/successful] SUCCESS! Your cluster was upgraded to <span class="string">&quot;v1.33.3&quot;</span>. Enjoy!</span><br><span class="line"></span><br><span class="line"> [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets <span class="keyword">if</span> you haven<span class="string">&#x27;t already done so.</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>手动升级你的 CNI 驱动插件，比如 Calico</p></li><li class="lvl-2"><p>升级 kubelet 和 kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的版本</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class="line"><span class="comment"># 重启 kubelet</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure><h4 id="升级-worker-节点">升级 worker 节点</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/upgrading-linux-nodes/">升级 worker 节点</a></p></li><li class="lvl-2"><p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p></li><li class="lvl-2"><p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubeadm 可以升级的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class="line"><span class="comment"># 查看升级后的版本</span></span><br><span class="line">$ kubeadm version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>腾空节点：如果有多个 worker 节点，可以选择先腾空节点。如果只有一个 worker 节点，则不需要。</p></li></ul><blockquote><p>drain 是为了在升级期间 避免该节点上正在运行的业务容器受到影响</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在控制平面节点上执行此命令</span></span><br><span class="line"><span class="comment"># 将 &lt;node-to-drain&gt; 替换为你正腾空的节点的名称</span></span><br><span class="line">$ kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>升级 node 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade node</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>升级 kubelet 和 kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class="line"><span class="comment"># 重启 kubelet</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line">$ <span class="built_in">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果前面对节点做了 腾空节点 操作，则需要取消对节点的保护，将节点标记为可调度，让节点重新上线</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在控制平面节点上执行此命令</span></span><br><span class="line"><span class="comment"># 将 &lt;node-to-uncordon&gt; 替换为你的节点名称</span></span><br><span class="line">$ kubectl uncordon &lt;node-to-uncordon&gt;</span><br></pre></td></tr></table></figure><h2 id="更新证书">更新证书</h2><ul class="lvl-0"><li class="lvl-2"><p>kubeadm 创建的证书存放在 <code>/etc/kubernetes/pki/</code> 下，默认客户端证书有效期为 1 年</p></li><li class="lvl-2"><p>可以通过如下命令查看证书信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看证书到期时间</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm certs check-expiration</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line"><span class="comment">## 可以看到 客户端 的证书的过期时间，默认值为 1 年</span></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">apiserver                  Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">apiserver-etcd-client      Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">controller-manager.conf    Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">etcd-healthcheck-client    Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">etcd-server                Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Jun 29, 2026 14:41 UTC   363d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">super-admin.conf           Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根证书默认有效期为 10 年</span></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Jun 27, 2035 14:41 UTC   9y              no</span><br><span class="line">etcd-ca                 Jun 27, 2035 14:41 UTC   9y              no</span><br><span class="line">front-proxy-ca          Jun 27, 2035 14:41 UTC   9y              no</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>更新客户端证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新前备份</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rf /etc/kubernetes/ /etc/kubernetes.bak</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rf /var/lib/etcd/ /var/lib/etcd.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以更新单个客户端证书</span></span><br><span class="line"><span class="comment"># sudo kubeadm certs renew admin.conf</span></span><br><span class="line"><span class="comment"># sudo kubeadm certs renew apiserver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级全部客户端证书，也只能续期1年</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm certs renew all</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[renew] Reading configuration from the <span class="string">&quot;kubeadm-config&quot;</span> ConfigMap <span class="keyword">in</span> namespace <span class="string">&quot;kube-system&quot;</span>...</span><br><span class="line">[renew] Use <span class="string">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class="line"></span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the admin to use and <span class="keyword">for</span> kubeadm itself renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving the Kubernetes API renewed</span><br><span class="line">certificate the apiserver uses to access etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the API server to connect to kubelet renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the controller manager to use renewed</span><br><span class="line">certificate <span class="keyword">for</span> liveness probes to healthcheck etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> etcd nodes to communicate with each other renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the front proxy client renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the scheduler manager to use renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the super-admin renewed</span><br><span class="line"></span><br><span class="line">Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据输出提示重启 kube-apiserver, kube-controller-manager, kube-scheduler 和 etcd</span></span><br><span class="line"><span class="comment"># 这几个组件是通过pod 启动的，可以通过 kubectl get pod -n kube-system 查看</span></span><br><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS        AGE</span><br><span class="line">calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">calico-node-7pbbq                          1/1     Running   3 (5h36m ago)   41h</span><br><span class="line">calico-node-v4hzr                          1/1     Running   2 (5h37m ago)   19h</span><br><span class="line">calico-node-w47qq                          1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">coredns-674b8bbfcf-2tvld                   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">coredns-674b8bbfcf-h6kx7                   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">etcd-k8s-master                            1/1     Running   5 (5h37m ago)   41h</span><br><span class="line">kube-apiserver-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class="line">kube-controller-manager-k8s-master         1/1     Running   7 (5h37m ago)   41h</span><br><span class="line">kube-proxy-nkbns                           1/1     Running   3 (5h36m ago)   41h</span><br><span class="line">kube-proxy-plqw8                           1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">kube-proxy-sbgh6                           1/1     Running   2 (5h37m ago)   19h</span><br><span class="line">kube-scheduler-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的pod就会自动重启</span></span><br><span class="line">kubectl delete pod -n kube-system kube-apiserver-k8s-master kube-controller-manager-k8s-master  kube-scheduler-k8s-master etcd-k8s-master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启成功后再次查看证书信息，就会看到更新后的到期时间为1年</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm certs check-expiration</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-节点组件">Kubernetes 节点组件</h2><table><thead><tr><th>角色</th><th>组件名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Master Node</strong></td><td><code>kube-apiserver</code></td><td>Kubernetes 的 API 请求入口，处理所有 REST 请求，协调各组件。</td></tr><tr><td></td><td><code>kube-scheduler</code></td><td>调度器，决定将 Pod 调度到哪个合适的 Node。</td></tr><tr><td></td><td><code>kube-controller-manager</code></td><td>包含多个控制器（如 NodeController、ReplicationController、DeploymentController 等），用于控制和调整集群状态。</td></tr><tr><td></td><td><code>etcd</code></td><td>分布式 KV 存储系统，存储 Kubernetes 所有状态数据。只有 API Server 能直接访问。</td></tr><tr><td><strong>Worker Node</strong></td><td><code>kubelet</code></td><td>负责与 Master 通信，执行其下发的 Pod 管理任务，控制容器生命周期。</td></tr><tr><td></td><td><code>kube-proxy</code></td><td>负责维护 Node 上的网络规则，支持服务负载均衡和网络通信。</td></tr><tr><td></td><td><code>container runtime</code></td><td>容器运行时，比如 Docker、containerd、CRI-O，负责实际运行容器。</td></tr></tbody></table><h2 id="crictl-命令">crictl 命令</h2><ul class="lvl-0"><li class="lvl-2"><p><code>crictl</code> 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。</p></li><li class="lvl-2"><p><code>crictl</code> 命令的使用方式比较类似<code>docker</code>命令</p></li></ul><table><thead><tr><th>操作</th><th><code>docker</code> 命令</th><th><code>crictl</code> 命令</th><th>说明</th></tr></thead><tbody><tr><td>查看正在运行的容器</td><td><code>docker ps</code></td><td><code>crictl ps</code></td><td></td></tr><tr><td>查看所有容器（包括已停止）</td><td><code>docker ps -a</code></td><td><code>crictl ps -a</code></td><td></td></tr><tr><td>查看镜像</td><td><code>docker images</code></td><td><code>crictl images</code></td><td></td></tr><tr><td>查看容器日志</td><td><code>docker logs &lt;container_id&gt;</code></td><td><code>crictl logs &lt;container_id&gt;</code></td><td></td></tr><tr><td>进入容器交互</td><td><code>docker exec -it &lt;id&gt; sh</code></td><td><code>crictl exec -it &lt;id&gt; sh</code></td><td></td></tr><tr><td>查看容器详细信息</td><td><code>docker inspect &lt;container_id&gt;</code></td><td><code>crictl inspect &lt;container_id&gt;</code></td><td></td></tr><tr><td>查看 Pod 详细信息</td><td>❌（不支持）</td><td><code>crictl inspectp &lt;pod_id&gt;</code></td><td>K8s 专属</td></tr><tr><td>删除容器</td><td><code>docker rm &lt;container_id&gt;</code></td><td><code>crictl rm &lt;container_id&gt;</code></td><td></td></tr><tr><td>删除镜像</td><td><code>docker rmi &lt;image_id&gt;</code></td><td><code>crictl rmi &lt;image_id&gt;</code></td><td></td></tr><tr><td>拉取镜像</td><td><code>docker pull nginx</code></td><td><code>crictl pull nginx</code></td><td></td></tr><tr><td>运行容器（非 K8s 场景）</td><td><code>docker run -it nginx</code></td><td>❌（不支持）</td><td><code>crictl</code> 不运行容器，仅调试现有容器</td></tr><tr><td>列出容器运行时信息</td><td><code>docker info</code></td><td><code>crictl info</code></td><td></td></tr><tr><td>查看容器运行状态</td><td><code>docker stats</code></td><td><code>crictl stats</code></td><td>简要版</td></tr><tr><td>设置配置文件</td><td><code>~/.docker/config.json</code></td><td><code>/etc/crictl.yaml</code></td><td>如设置 endpoint</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/&quot;&gt;使用 kubeadm 引导集群&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/&quot;&gt;kubeadm 命令指南&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/&quot;&gt;用 kubeadm 进行管理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 minikube</title>
    <link href="https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/"/>
    <id>https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/</id>
    <published>2025-06-28T13:30:05.000Z</published>
    <updated>2025-06-30T05:56:30.873Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://minikube.sigs.k8s.io/docs/">minikube官网</a></p></li></ul><span id="more"></span><h2 id="安装前设置">安装前设置</h2><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-docker">安装 <code>docker</code></h3><ul class="lvl-0"><li class="lvl-2"><p>安装方法参见 <a href="/2025/05/20/docker-install/" title="Linux 安装 Docker">Linux 安装 Docker</a></p></li></ul><h3 id="创建用户">创建用户</h3><ul class="lvl-0"><li class="lvl-2"><p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建用户</span></span><br><span class="line">$ <span class="built_in">sudo</span> useradd -m -s /bin/bash centos</span><br><span class="line"><span class="comment"># 2.添加到docker用户组</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker centos</span><br><span class="line"><span class="comment"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG wheel centos</span><br><span class="line"><span class="comment">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class="line"><span class="comment"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class="line">$ su - centos</span><br></pre></td></tr></table></figure><h3 id="安装-kubectl">安装 <code>kubectl</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载 kubectl</span></span><br><span class="line">$ curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.验证下载(可选)</span></span><br><span class="line">$ curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat kubectl.sha256)</span>  kubectl&quot;</span> | <span class="built_in">sha256sum</span> --check</span><br><span class="line"><span class="comment">## 验证通过输出</span></span><br><span class="line">kubectl: 成功</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装 kubectl</span></span><br><span class="line">$ <span class="built_in">sudo</span> install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看安装的版本</span></span><br><span class="line">$ kubectl version --client</span><br><span class="line">Client Version: v1.33.2</span><br><span class="line">Kustomize Version: v5.6.0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">$ kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="使用-minikube-创建-K8S-集群">使用 minikube 创建 K8S 集群</h2><ul class="lvl-0"><li class="lvl-2"><p>该工具只适合在本机进行开发和测试时使用，其原理是在本机的docker环境中创建一个<code>minikube</code>容器作为<code>k8s</code>的节点机。</p></li></ul><h3 id="安装-minikube">安装 minikube</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Fx86-64%2Fstable%2Fbinary+download">minikube安装说明</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载</span></span><br><span class="line">$ curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64</span><br><span class="line"><span class="comment"># 2.安装</span></span><br><span class="line">$ <span class="built_in">sudo</span> install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; <span class="built_in">rm</span> minikube-linux-amd64</span><br><span class="line"><span class="comment"># 3.验证</span></span><br><span class="line">$ minikube version</span><br><span class="line"><span class="comment"># 4.查看帮助</span></span><br><span class="line">$ minikube --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="创建集群">创建集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群，注意不能使用 root 用户，要求该用户具有 docker 权限，并且具有sudo权限，否则会报错</span></span><br><span class="line"><span class="comment"># 系统内存至少 4G，以保证稳定性</span></span><br><span class="line"><span class="comment"># 默认使用docker驱动 --driver=docker，minikube 支持的驱动：https://minikube.sigs.k8s.io/docs/drivers/</span></span><br><span class="line">$ minikube start</span><br><span class="line">😄  Rocky 8.10 (amd64) 上的 minikube v1.36.0</span><br><span class="line">✨  根据现有的配置文件使用 docker 驱动程序</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube&quot;</span> primary control-plane</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">    &gt; index.docker.io/kicbase/sta...:  502.26 MiB / 502.26 MiB  100.00% 27.50 M</span><br><span class="line">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.47, but successfully downloaded docker.io/kicbase/stable:v0.0.47@sha256:6ed579c9292b4370177b7ef3c42cc4b4a6dcd0735a1814916cbc22c8bf38412b as a fallback image</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">    ▪ 正在生成证书和密钥...</span><br><span class="line">    ▪ 正在启动控制平面...</span><br><span class="line">    ▪ 配置 RBAC 规则 ...</span><br><span class="line">🔗  配置 bridge CNI (Container Networking Interface) ...</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">    ▪ 正在使用镜像 gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">🌟  启用插件： default-storageclass, storage-provisioner</span><br><span class="line">🏄  完成！kubectl 现在已配置，默认使用<span class="string">&quot;minikube&quot;</span>集群和<span class="string">&quot;default&quot;</span>命名空间</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Minikube 允许你创建多个独立的 Kubernetes 集群，每个 profile 是一个单独的 minikube 实例，互不干扰。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 是 --profile 的缩写，表示 指定使用哪个 Minikube 集群（Profile）,默认 profile 名是 minikube</span></span><br><span class="line">minikube start -p dev</span><br><span class="line">minikube start -p <span class="built_in">test</span></span><br><span class="line">minikube start -p prod</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME       STATUS   ROLES           AGE   VERSION</span><br><span class="line">minikube   Ready    control-plane   27s   v1.33.1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看本机容器，k8s 集群就在这个容器中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                   CREATED          STATUS          PORTS                                                                                                                                  NAMES</span><br><span class="line">4e7eaad73934   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   47 minutes ago   Up 47 minutes   127.0.0.1:32772-&gt;22/tcp, 127.0.0.1:32771-&gt;2376/tcp, 127.0.0.1:32770-&gt;5000/tcp, 127.0.0.1:32769-&gt;8443/tcp, 127.0.0.1:32768-&gt;32443/tcp   minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该容器中的docker容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it minikube docker ps</span><br><span class="line">CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">c25bcc3cb76c   1cf5f116067c                 <span class="string">&quot;/coredns -conf /etc…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_coredns_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class="line">a22714ccfce2   b79c189b052c                 <span class="string">&quot;/usr/local/bin/kube…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-proxy_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class="line">a368d902aef9   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class="line">973caed86b2c   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class="line">9db7567143a2   6e38f40d628d                 <span class="string">&quot;/storage-provisioner&quot;</span>   2 minutes ago   Up 2 minutes             k8s_storage-provisioner_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class="line">ba39fe88ad59   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class="line">ef0733df95b4   ef43894fa110                 <span class="string">&quot;kube-controller-man…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-controller-manager_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class="line">852828a600d5   c6ab243b29f8                 <span class="string">&quot;kube-apiserver --ad…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-apiserver_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class="line">97efb54702cd   499038711c08                 <span class="string">&quot;etcd --advertise-cl…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_etcd_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br><span class="line">a3dd2c2817f1   398c985c0d95                 <span class="string">&quot;kube-scheduler --au…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-scheduler_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class="line">927ebc63cf80   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class="line">744d4c6e3571   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class="line">4ae6bdc25908   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class="line">dff641d8672a   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-3"><p>配置你的终端，让 Docker CLI 指向 minikube 内部的 Docker 守护进程（就是通过 docker 远程连接的方式）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker远程的环境变量，我们可以将其配置到宿主机的环境变量中</span></span><br><span class="line">$ minikube docker-env</span><br><span class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">&quot;tcp://192.168.49.2:2376&quot;</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">&quot;/home/centos/.minikube/certs&quot;</span></span><br><span class="line"><span class="built_in">export</span> MINIKUBE_ACTIVE_DOCKERD=<span class="string">&quot;minikube&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To point your shell to minikube&#x27;s docker-daemon, run:</span></span><br><span class="line"><span class="comment"># eval $(minikube -p minikube docker-env)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时配置宿主机环境变量，此时我们再执行docker命令，就会使用minikube的docker-daemon</span></span><br><span class="line">$ <span class="built_in">eval</span> $(minikube -p minikube docker-env)</span><br><span class="line"><span class="comment"># 取消临时配置,-u 是 --unset 的缩写</span></span><br><span class="line">$ <span class="built_in">eval</span> $(minikube -p minikube docker-env -u)</span><br></pre></td></tr></table></figure><h3 id="minikube-命令">minikube 命令</h3><ul class="lvl-0"><li class="lvl-2"><p>登录到 minikube 环境（用于调试）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际上就是进入minikube容器的shell</span></span><br><span class="line">$ minikube ssh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行 kubectl 命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看支持的命令</span></span><br><span class="line">$ minikube kubectl -- --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 运行 kubectl 命令，这里注意 minikube kubectl -- 前面有空格</span></span><br><span class="line">$ minikube kubectl -- get pods --namespace kube-system</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-674b8bbfcf-8jrx4           1/1     Running   0          45m</span><br><span class="line">etcd-minikube                      1/1     Running   0          45m</span><br><span class="line">kube-apiserver-minikube            1/1     Running   0          45m</span><br><span class="line">kube-controller-manager-minikube   1/1     Running   0          45m</span><br><span class="line">kube-proxy-5dkt4                   1/1     Running   0          45m</span><br><span class="line">kube-scheduler-minikube            1/1     Running   0          45m</span><br><span class="line">storage-provisioner                1/1     Running   0          45m</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>node节点管理</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个worker节点，此时就是又启动了一个minikube容器</span></span><br><span class="line">$ minikube node add</span><br><span class="line">😄  将节点 m02 作为 [worker] 添加到集群 minikube</span><br><span class="line">❗  在没有任何 CNI 的情况下创建集群，向其中添加节点可能会导致网络中断。</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube-m02&quot;</span> worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">🏄  已成功将 m02 添加到 minikube！</span><br><span class="line"></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                   CREATED             STATUS             PORTS                                                                                                                                  NAMES</span><br><span class="line">ce5431e994c3   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   24 minutes ago      Up 24 minutes      127.0.0.1:32792-&gt;22/tcp, 127.0.0.1:32791-&gt;2376/tcp, 127.0.0.1:32790-&gt;5000/tcp, 127.0.0.1:32789-&gt;8443/tcp, 127.0.0.1:32788-&gt;32443/tcp   minikube-m02</span><br><span class="line">2739aa21a085   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   About an hour ago   Up About an hour   127.0.0.1:32777-&gt;22/tcp, 127.0.0.1:32776-&gt;2376/tcp, 127.0.0.1:32775-&gt;5000/tcp, 127.0.0.1:32774-&gt;8443/tcp, 127.0.0.1:32773-&gt;32443/tcp   minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME           STATUS   ROLES           AGE   VERSION</span><br><span class="line">minikube       Ready    control-plane   55m   v1.33.1</span><br><span class="line">minikube-m02   Ready    &lt;none&gt;          70s   v1.33.1</span><br><span class="line"></span><br><span class="line">$ minikube node list</span><br><span class="line">minikube        192.168.49.2</span><br><span class="line">minikube-m02    192.168.49.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止节点</span></span><br><span class="line">$ minikube node stop minikube-m02</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube-m02&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class="line">🛑  成功停止节点 minikube-m02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">$ minikube node start minikube-m02</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube-m02&quot;</span> worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">🔄  正在为<span class="string">&quot;minikube-m02&quot;</span>重启现有的 docker container ...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">🌟  启用插件：</span><br><span class="line">😄  成功启动节点 minikube-m02！</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点</span></span><br><span class="line">$ minikube node delete minikube-m02</span><br><span class="line">🔥  正在从集群 minikube 中删除节点 minikube-m02</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube-m02&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class="line">🔥  正在删除 docker 中的“minikube-m02”…</span><br><span class="line">💀  节点 minikube-m02 已成功删除。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>停止集群: 此时只是停止容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ minikube stop</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube”…</span><br><span class="line">🛑  1 个节点已停止</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除集群: 删除容器及其配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ minikube delete</span><br><span class="line">🔥  正在删除 docker 中的“minikube”…</span><br><span class="line">🔥  正在删除容器 <span class="string">&quot;minikube&quot;</span> ...</span><br><span class="line">🔥  正在移除 /home/centos/.minikube/machines/minikube…</span><br><span class="line">💀  已删除所有关于 <span class="string">&quot;minikube&quot;</span> 集群的痕迹。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>具体的使用方法参考<a href="https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/">https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://minikube.sigs.k8s.io/docs/&quot;&gt;minikube官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 Config 与  Secret</title>
    <link href="https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/"/>
    <id>https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/</id>
    <published>2025-06-12T14:30:05.000Z</published>
    <updated>2025-06-12T03:19:18.357Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 中的 Config 与  Secret</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p></li></ul><span id="more"></span><h2 id="Config-简介">Config 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Docker Swarm 中，Config 是一种用于管理配置资源的机制，允许你将配置文件与容器分离，便于在不同环境中重用和共享配置。</p></li><li class="lvl-2"><p>Config 和 Volume 都是 Docker 中用于管理数据的机制，但它们的设计目的和使用场景有显著不同：</p></li></ul><table><thead><tr><th>特性</th><th>Config</th><th>Volume</th></tr></thead><tbody><tr><td>用途</td><td>只能是文件，用于存储配置文件、只读数据</td><td>文件目录均可，存储应用数据、可读写数据</td></tr><tr><td>可变性</td><td>通常不可变（只读）</td><td>可变（读写）</td></tr><tr><td>生命周期</td><td>随服务部署更新</td><td>独立于容器生命周期</td></tr><tr><td>存储位置</td><td>存储在Docker管理的内存/文件系统</td><td>存储在主机文件系统或网络存储</td></tr><tr><td>Swarm支持</td><td>原生Swarm功能</td><td>通用功能</td></tr><tr><td>更新机制</td><td>更新需要重新部署服务</td><td>可动态更新</td></tr><tr><td>典型用例</td><td>配置文件、环境变量</td><td>数据库文件、日志、用户上传内容</td></tr></tbody></table><h3 id="Config-命令">Config 命令</h3><table><thead><tr><th>命令</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td><code>create</code></td><td>从文件或标准输入创建一个 config</td><td><code>docker config create my_config config.txt</code></td></tr><tr><td><code>inspect</code></td><td>显示一个或多个 config 的详细信息</td><td><code>docker config inspect my_config</code></td></tr><tr><td><code>ls</code></td><td>列出所有 configs</td><td><code>docker config ls</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 config</td><td><code>docker config rm my_config</code></td></tr></tbody></table><h4 id="docker-config-create-创建一个-config"><code>docker config create</code>:  创建一个 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中创建</span></span><br><span class="line">docker config create my_config my_config.json</span><br><span class="line"><span class="comment"># 从标准输入创建</span></span><br><span class="line"><span class="built_in">cat</span> my_config.json | docker config create my_config -</span><br></pre></td></tr></table></figure><h4 id="docker-config-inspect-查看-config-的信息"><code>docker config inspect</code>:  查看 config 的信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker config inspect my_config</span><br><span class="line"><span class="comment">## 输出，可以看到 Data 字段，用 base64 解码后，就是 config 的原始内容</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;q4257t5c2wq6uvvkm4g3hssae&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 3145</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my_config&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: <span class="string">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span> | <span class="built_in">base64</span> -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更易读</span></span><br><span class="line">docker config inspect --pretty my_config</span><br><span class="line">docker config inspect --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_config</span><br></pre></td></tr></table></figure><h4 id="docker-config-ls-列出所有-config"><code>docker config ls</code>:  列出所有 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker config <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#  只显示 ID</span></span><br><span class="line">docker config <span class="built_in">ls</span> -q</span><br></pre></td></tr></table></figure><h4 id="docker-config-rm-删除一个或多个-config"><code>docker config rm</code>:  删除一个或多个 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker config <span class="built_in">rm</span> my_config</span><br><span class="line"><span class="comment"># 删除多个</span></span><br><span class="line">docker config <span class="built_in">rm</span> my_config1 my_config2</span><br><span class="line"><span class="comment"># 删除所有 ，慎重使用</span></span><br><span class="line">docker config <span class="built_in">rm</span> $(docker config <span class="built_in">ls</span> -q)</span><br></pre></td></tr></table></figure><h3 id="Stack中使用Config">Stack中使用Config</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/configs/">Configs top-level elements</a></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configs:</span> <span class="comment">#  声明 config 列表</span></span><br><span class="line">  <span class="attr">nginx_config:</span>  <span class="comment">#  config 名称</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./nginx/nginx.conf</span> <span class="comment">#  config 文件</span></span><br><span class="line">  <span class="attr">my_config:</span> <span class="comment">#  使用外部 config，即 docker config create 创建的</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">configs:</span> <span class="comment"># 服务使用 config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">nginx_config</span> <span class="comment"># 指定 config 名称</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/etc/nginx/nginx.conf</span> <span class="comment"># 指定容器中配置文件存放位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_config</span>  <span class="comment">#  使用外部 config</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/app/config.json</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0444</span> <span class="comment">#  指定权限</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;1000&quot;</span> <span class="comment"># 指定用户</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;1000&quot;</span> <span class="comment"># 指定用户组</span></span><br></pre></td></tr></table></figure><h2 id="Secret-简介">Secret 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Secrets 是 Docker 专门为敏感数据设计的安全管理机制，用于安全地存储和传输密码、API密钥、TLS证书等敏感信息。</p></li><li class="lvl-2"><p>与 Configs 的主要区别</p></li></ul><table><thead><tr><th>特性</th><th>Secrets</th><th>Configs</th></tr></thead><tbody><tr><td>用途</td><td>敏感数据（密码、密钥等）</td><td>普通配置文件</td></tr><tr><td>存储</td><td>加密存储</td><td>明文存储</td></tr><tr><td>传输</td><td>加密传输</td><td>明文传输</td></tr><tr><td>访问</td><td>挂载为内存文件</td><td>常规文件挂载</td></tr><tr><td>权限</td><td>默认仅 root 可读（0440）</td><td>可自定义权限</td></tr></tbody></table><h3 id="Secret-命令">Secret 命令</h3><table><thead><tr><th>命令</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td><code>create</code></td><td>从文件或标准输入创建一个 secret</td><td><code>docker secret create my_secret secret.txt</code></td></tr><tr><td><code>inspect</code></td><td>显示一个或多个 secret 的详细信息</td><td><code>docker secret inspect my_secret</code></td></tr><tr><td><code>ls</code></td><td>列出所有 secrets</td><td><code>docker secret ls</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 secret</td><td><code>docker secret rm my_secret</code></td></tr></tbody></table><h4 id="docker-secret-create-创建一个-secret"><code>docker secret create</code>:  创建一个 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中创建</span></span><br><span class="line">docker secret create my_secret my_secret.txt</span><br><span class="line"><span class="comment"># 从标准输入创建</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;my_secret&quot;</span> | docker secret create my_secret -</span><br></pre></td></tr></table></figure><h4 id="docker-secret-inspect-查看-secret-的信息"><code>docker secret inspect</code>:  查看 secret 的信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker secret inspect my_secret</span><br><span class="line"><span class="comment">## 输出，可以看到 没有 data 字段，所以无法查看原始的内容</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;qlklskvxthp61i0nbvzvr6wuw&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 3144</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my_secret&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 输出更易读</span></span><br><span class="line">docker secret inspect --pretty my_secret</span><br><span class="line">docker secret inspect --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_secret</span><br></pre></td></tr></table></figure><h4 id="docker-secret-ls-列出所有的-secret"><code>docker secret ls</code>:  列出所有的 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker secret <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 列出所有的 secret 的 ID</span></span><br><span class="line">docker secret <span class="built_in">ls</span> -q</span><br><span class="line">docker secret <span class="built_in">ls</span> --filter name=my_secret</span><br></pre></td></tr></table></figure><h4 id="docker-secret-rm-删除-secret"><code>docker secret rm</code>:  删除 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker secret <span class="built_in">rm</span> my_secret</span><br><span class="line"><span class="comment"># 删除所有，慎重使用</span></span><br><span class="line">docker secret <span class="built_in">rm</span> $(docker secret <span class="built_in">ls</span> -q)</span><br></pre></td></tr></table></figure><h3 id="Stack中使用Secret">Stack中使用Secret</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/secrets/">Secrets top-level elements</a></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">    <span class="attr">secrets:</span> <span class="comment"># 关联secret，容器内关联路径为 /run/secrets/&lt;secret_name&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span> <span class="comment"># 声明 secret 列表</span></span><br><span class="line">  <span class="attr">db_root_password:</span> <span class="comment">#  secret 名称</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./mysql_root_password.txt</span> <span class="comment">#  secret 文件</span></span><br><span class="line">  <span class="attr">my_secret:</span> <span class="comment"># 生产环境建议使用预创建的secret</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>  <span class="comment"># 引用预先创建的secret</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优化: 使用非root用户，并隐藏 secret 文件</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&quot;mysql:mysql&quot;</span>  <span class="comment"># 关键点1：使用非root用户</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/.db_root_password</span>  <span class="comment"># 关键点2：隐藏文件</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">db_root_password</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">.db_root_password</span>  <span class="comment"># 隐藏文件名</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;999&quot;</span>  <span class="comment"># mysql用户ID</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;999&quot;</span>  <span class="comment"># mysql组ID</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0400</span>  <span class="comment"># 仅拥有者可读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_secret</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">.my_secret</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;999&quot;</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;999&quot;</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">db_root_password:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./mysql_root_password.txt</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 中的 Config 与  Secret&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/compose-file/&quot;&gt;Compose file reference&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 栈(Stack)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/"/>
    <id>https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/</id>
    <published>2025-06-11T14:30:05.000Z</published>
    <updated>2025-06-28T03:28:50.646Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 栈管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p></li></ul><span id="more"></span><h2 id="Stack简介">Stack简介</h2><ul class="lvl-0"><li class="lvl-2"><p>前面我们在Swarm中创建服务都是通过Service，每次创建一个，有没有类似<code>docker compose</code>的方式来创建多个服务呢？Docker Swarm为我们提供了Stack</p></li><li class="lvl-2"><p>在 Docker Swarm 中，Stack（栈） 是用来定义和部署一组相关服务的集合。你可以把它看成是一个应用的整体，由多个服务（service）、网络（network）、卷（volume）等组成。</p></li></ul><h2 id="Stack-通常用-Docker-Compose-文件（YAML-格式）-描述">Stack 通常用 Docker Compose 文件（YAML 格式） 描述</h2><ul class="lvl-0"><li class="lvl-2"><p>Stack 完全兼容 Docker Compose 文件，并可以在 compose 文件中声明副本集等与Service相关的配置项。</p></li><li class="lvl-2"><p>我用表格总结一下二者的差异，重点放在「Stack 支持的配置」上：</p></li></ul><table><thead><tr><th>配置项</th><th>Docker Compose (本地)</th><th>Docker Stack (Swarm 集群)</th><th>说明</th></tr></thead><tbody><tr><td><code>name</code></td><td>✅</td><td>❌</td><td>Stack 不支持 name  属性</td></tr><tr><td><code>build</code></td><td>✅</td><td>❌</td><td>Stack 不支持 build 属性，只能使用image</td></tr><tr><td><code>deploy</code></td><td>❌（部分支持，通常被忽略）</td><td>✅（核心支持）</td><td>Stack 支持用 <code>deploy</code> 定义副本数、资源限制、更新策略等</td></tr><tr><td><code>deploy.replicas</code></td><td>❌</td><td>✅</td><td>定义服务副本数</td></tr><tr><td><code>deploy.resources</code></td><td>❌</td><td>✅</td><td>定义 CPU、内存限制</td></tr><tr><td><code>deploy.placement</code></td><td>❌</td><td>✅</td><td>定义服务调度策略（在哪些节点上运行）</td></tr><tr><td><code>deploy.update_config</code></td><td>❌</td><td>✅</td><td>定义滚动更新的参数</td></tr><tr><td><code>deploy.restart_policy</code></td><td>❌</td><td>✅</td><td>定义重启策略</td></tr><tr><td><code>deploy.mode</code></td><td>❌</td><td>✅</td><td><code>replicated</code> 或 <code>global</code></td></tr><tr><td><code>depends_on</code></td><td>✅</td><td>🚫（被忽略）</td><td>Stack 不支持容器启动顺序控制</td></tr><tr><td><code>build</code></td><td>✅</td><td>🚫（被忽略）</td><td>Stack 不支持直接构建镜像，只能用已存在的镜像</td></tr><tr><td><code>network.external</code></td><td>✅</td><td>✅</td><td>都支持外部网络</td></tr><tr><td><code>volumes.external</code></td><td>✅</td><td>✅</td><td>都支持外部卷</td></tr><tr><td><code>configs</code></td><td>🚫</td><td>✅</td><td>Stack 支持 Config 对象，适合配置文件管理</td></tr><tr><td><code>secrets</code></td><td>🚫</td><td>✅</td><td>Stack 支持 Secrets，用于安全存储敏感信息</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>以<a href="https://docs.portainer.io/">Portainer:Docker可视化管理工具</a>的stack配置文件为例</p></li></ul><blockquote><p>Portainer 社区版 （CE）可让您在 Docker、Docker Swarm、Kubernetes 和 Azure ACI 中轻松构建和管理容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://downloads.portainer.io/ce-lts/portainer-agent-stack.yml -o portainer-agent-stack.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span> <span class="comment">#  docker-compose版本，新版的docker已经不需要配置版本号了</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">agent:</span>  <span class="comment"># agent服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/agent:lts</span> <span class="comment"># 镜像，不能使用 Dockerfile</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment"># 挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/docker/volumes:/var/lib/docker/volumes</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 挂载网络，必须是 overlay</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">agent_network</span></span><br><span class="line">    <span class="attr">deploy:</span>   <span class="comment"># 部署策略，service 特有属性</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span> <span class="comment"># 全局模式</span></span><br><span class="line">      <span class="attr">placement:</span> <span class="comment"># 部署条件</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.platform.os</span> <span class="string">==</span> <span class="string">linux</span>] <span class="comment">#  运行在linux节点</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">portainer:</span> <span class="comment">#  portainer服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/portainer-ce:lts</span> <span class="comment">#  镜像</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-H</span> <span class="string">tcp://tasks.agent:9001</span> <span class="string">--tlsskipverify</span> <span class="comment">#  启动参数</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9443:9443&quot;</span>  <span class="comment"># 浏览器访问 https://localhost:9443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#  挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">portainer_data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 挂载网络，与agent服务网络一致</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">agent_network</span></span><br><span class="line">    <span class="attr">deploy:</span> <span class="comment">#  部署配置</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span> <span class="comment"># 副本模式</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment">#  副本数量</span></span><br><span class="line">      <span class="attr">placement:</span> <span class="comment">#  部署条件</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>] <span class="comment">#  节点角色为manager</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#  网络声明</span></span><br><span class="line">  <span class="attr">agent_network:</span> <span class="comment">#  网络名称</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span> <span class="comment">#  网络驱动</span></span><br><span class="line">    <span class="attr">attachable:</span> <span class="literal">true</span> <span class="comment"># 允许容器加入</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#  挂载卷声明</span></span><br><span class="line">  <span class="attr">portainer_data:</span> <span class="comment">#  挂载卷名称</span></span><br></pre></td></tr></table></figure><h2 id="Stack-命令">Stack 命令</h2><table><thead><tr><th>子命令</th><th>中文说明</th><th>示例命令</th></tr></thead><tbody><tr><td><code>config</code></td><td>输出最终的配置文件（经过合并与变量替换后）</td><td><code>docker stack config -c docker-compose.yml</code></td></tr><tr><td><code>deploy</code></td><td>部署新 stack 或更新已有 stack</td><td><code>docker stack deploy -c docker-compose.yml mystack</code></td></tr><tr><td><code>ls</code></td><td>列出所有已部署的 stack</td><td><code>docker stack ls</code></td></tr><tr><td><code>ps</code></td><td>查看 stack 中的所有任务（即各个容器实例）</td><td><code>docker stack ps mystack</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 stack</td><td><code>docker stack rm mystack</code></td></tr><tr><td><code>services</code></td><td>列出某个 stack 中的所有服务</td><td><code>docker stack services mystack</code></td></tr></tbody></table><h3 id="docker-stack-config-输出最终的配置文件"><code>docker stack config</code>: 输出最终的配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此命令也可以用来验证compose文件格式是否正确，只保证格式正确，不保证逻辑正确</span></span><br><span class="line">docker stack config -c portainer-agent-stack.yml</span><br></pre></td></tr></table></figure><h3 id="docker-stack-deploy-部署-stack"><code>docker stack deploy</code>: 部署 stack</h3><ul class="lvl-0"><li class="lvl-3"><p><code>docker stack deploy</code> == <code>docker stack up</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c portainer-agent-stack.yml portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Creating network portainer_agent_network</span><br><span class="line">Creating service portainer_agent</span><br><span class="line">Creating service portainer_portainer</span><br></pre></td></tr></table></figure><h3 id="docker-stack-ls-列出所有-stack"><code>docker stack ls</code>: 列出所有 stack</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker stack ls</code> == <code>docker stack list</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，stack名称为portainer，其内部有两个服务，agent和portainer</span></span><br><span class="line">NAME        SERVICES</span><br><span class="line">portainer   2</span><br></pre></td></tr></table></figure><h3 id="docker-stack-services-查看服务"><code>docker stack services</code>:  查看服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker stack services portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class="line">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class="line">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等效</span></span><br><span class="line">docker service <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class="line">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class="line">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br></pre></td></tr></table></figure><h3 id="docker-stack-ps-列出-stack-下的所有服务实例"><code>docker stack ps</code>: 列出 stack 下的所有服务实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker stack ps portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 30 seconds ago</span><br><span class="line">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 59 seconds ago</span><br><span class="line">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 3 minutes ago</span><br><span class="line">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 35 seconds ago</span><br><span class="line">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 48 seconds ago</span><br><span class="line">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 2 minutes ago</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等效</span></span><br><span class="line">docker service ps portainer_agent portainer_portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 7 minutes ago</span><br><span class="line">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 8 minutes ago</span><br><span class="line">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 10 minutes ago</span><br><span class="line">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 7 minutes ago</span><br><span class="line">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 7 minutes ago</span><br><span class="line">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 10 minutes ago</span><br></pre></td></tr></table></figure><h3 id="docker-stack-rm-停止并删除-stack"><code>docker stack rm</code>: 停止并删除 stack</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker stack rm</code> == <code>docker stack remove</code> == <code>docker stack down</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> portainer</span><br></pre></td></tr></table></figure><h2 id="deploy-参数详解"><code>deploy</code> 参数详解</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-service:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span>  <span class="comment"># 指定副本数，仅在 mode: replicated 下有效。表示同时运行3个容器副本。</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span>  <span class="comment"># 服务运行模式，可选值：</span></span><br><span class="line">                        <span class="comment"># - replicated：通过 replicas 指定副本数量（默认）</span></span><br><span class="line">                        <span class="comment"># - global：每个节点运行一个副本，忽略 replicas 配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span>         <span class="comment"># 容器的“硬限制”，超过会被强制限制</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;1.0&#x27;</span>    <span class="comment"># 限制每个容器最多使用1个逻辑 CPU</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span>   <span class="comment"># 限制每个容器最多使用512MB内存</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">reservations:</span>   <span class="comment"># 容器的“软限制”，Swarm调度时预留资源参考值（不会强制限制）</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.25&#x27;</span>   <span class="comment"># 建议每个容器至少分配0.25个CPU</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span>   <span class="comment"># 建议每个容器至少分配128MB内存</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span>  <span class="comment"># 控制容器重启行为，可选值：</span></span><br><span class="line">                               <span class="comment"># - none：不重启</span></span><br><span class="line">                               <span class="comment"># - on-failure：失败时重启（非0退出码）</span></span><br><span class="line">                               <span class="comment"># - any：无论是否失败都重启</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span>              <span class="comment"># 重启前等待时间</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span>        <span class="comment"># 最多重启3次</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span>            <span class="comment"># 判断失败次数的时间窗口（60秒内最多失败3次）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span>           <span class="comment"># 指定容器调度到哪些节点上运行，可用条件有：</span></span><br><span class="line">                               <span class="comment"># - node.role == manager/worker</span></span><br><span class="line">                               <span class="comment"># - node.hostname == xxx</span></span><br><span class="line">                               <span class="comment"># - node.labels.xxx == yyy</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">worker</span>  <span class="comment"># 只调度到 worker 节点</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">preferences:</span>           <span class="comment"># 调度偏好（不是强约束）</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">spread:</span> <span class="string">node.labels.zone</span>  <span class="comment"># 将服务均匀地分布在 zone 标签不同的节点上</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">update_config:</span>           <span class="comment"># 控制服务滚动更新的行为</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span>         <span class="comment"># 每次最多并发更新2个容器</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span>             <span class="comment"># 每批更新之间等待10秒</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span>  <span class="comment"># 更新失败时的处理方式，可选值：</span></span><br><span class="line">                                  <span class="comment"># - pause：暂停更新（默认）</span></span><br><span class="line">                                  <span class="comment"># - continue：继续更新</span></span><br><span class="line">                                  <span class="comment"># - rollback：回滚到旧版本</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">stop-first</span>      <span class="comment"># 控制更新顺序，可选值：</span></span><br><span class="line">                               <span class="comment"># - stop-first（先停后启，默认）</span></span><br><span class="line">                               <span class="comment"># - start-first（先启后停，适用于无状态服务）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">rollback_config:</span>         <span class="comment"># 回滚时的行为，字段与 update_config 类似</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span>         <span class="comment"># 回滚时每次最多处理1个容器</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span>              <span class="comment"># 每批回滚之间等待5秒</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">pause</span>  <span class="comment"># 回滚失败时暂停</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">stop-first</span>      <span class="comment"># 回滚时先停再启</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 栈管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/compose-file/&quot;&gt;Compose file reference&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 网络(Overlay)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/"/>
    <id>https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/</id>
    <published>2025-06-11T13:30:05.000Z</published>
    <updated>2025-06-11T08:04:58.671Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 网络(Overlay)</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Overlay-简介">Overlay 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。</p></li><li class="lvl-2"><p>当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。</p></li><li class="lvl-2"><p>overlay 网络特点</p><ul class="lvl-2"><li class="lvl-4">跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。</li><li class="lvl-4">内置服务发现：容器之间可以通过服务名称直接通信。</li><li class="lvl-4">支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。</li><li class="lvl-4">自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。</li></ul></li></ul><h2 id="Swarm-中的-overlay-网络">Swarm 中的 overlay 网络</h2><ul class="lvl-0"><li class="lvl-2"><p>当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：<code>docker_gwbridge</code> ，一个是 overlay network：<code>ingress</code>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">6b7aadbbd180   bridge            bridge    <span class="built_in">local</span></span><br><span class="line">5ddadf5d0608   docker_gwbridge   bridge    <span class="built_in">local</span></span><br><span class="line">21c6f5b1bedd   host              host      <span class="built_in">local</span></span><br><span class="line">idx465x3jg68   ingress           overlay   swarm</span><br><span class="line">a770c5ad4b13   none              null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h3 id="docker-gwbridge"><code>docker_gwbridge</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查看 <code>docker_gwbridge</code> 详情，其网段为 <code>172.18.0.0/16</code>，网关为 <code>172.18.0.1</code>，内部有一个容器 <code>ingress-sbox</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker inspect docker_gwbridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;docker_gwbridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2025-06-08T07:29:52.119033035-04:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;gateway_ingress-sbox&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker_gwbridge&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>先来看这个网段 <code>172.18.0.0/16</code>，我们查看主机的网络和路由表，可以看到 <code>261: docker_gwbridge</code>，其IP地址为 <code>172.18.0.1</code>，所以这里我们就可以知道 <code>docker_gwbridge</code> 就是连接到<code>261: docker_gwbridge</code>这块网卡上的，另外当前还有一个<code>263: veth3176100@if262</code>虚拟网络接口也连接到<code>261: docker_gwbridge</code>上，通过路由表我们得知其最终连接到<code>2: enp0s5</code>上，也就是这台主机的网卡。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute</span><br><span class="line">       valid_lft 2591886sec preferred_lft 604686sec</span><br><span class="line">    inet6 fe80::21c:42ff:fe49:1282/64 scope <span class="built_in">link</span> noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:5c:31:<span class="built_in">cd</span>:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:5cff:fe31:cd30/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:feff:fee3:caf7/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::944b:c1ff:fed9:83c5/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看路由表</span></span><br><span class="line">route -n</span><br><span class="line"><span class="comment">## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.211.55.1     0.0.0.0         UG    100    0        0 enp0s5</span><br><span class="line">10.211.55.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s5</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker_gwbridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100</span></span><br><span class="line">brctl show docker_gwbridge</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker_gwbridge         8000.0242fee3caf7       no              veth3176100</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>按理说<code>263: veth3176100@if262</code>虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 <code>ingress-sbox</code>，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的<code>/var/run/docker/netns/</code>下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/run/docker/netns/</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线</span></span><br><span class="line">1-idx465x3jg  ingress_sbox</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：<code>262: eth1@if263</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=ingress_sbox ip a</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里还有一个网络接口 <code>259: eth0@if260</code>，它又是与谁对接的呢？别着急，我们接着往下看。</p></li></ul><h3 id="ingress"><code>ingress</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查看 <code>ingress</code> 详情，其网段为 <code>10.0.0.0/24</code>，网关为 <code>10.0.0.1</code>，内部有一个容器 <code>ingress-sbox</code>，另外其有一个<code>Peers</code>属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect ingress</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ingress&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;idx465x3jg682fmceumsio297&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2025-06-08T07:29:51.734714967-04:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;swarm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;overlay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;10.0.0.0/24&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;10.0.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ingress-endpoint&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:0a:00:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;10.0.0.2/24&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.overlay.vxlanid_list&quot;</span>: <span class="string">&quot;4096&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Peers&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;4969a4611607&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.10&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ae3756658a26&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.14&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;f12309731131&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.13&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;de5000b11067&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.12&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;377001904d63&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.11&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>我们还是先来看这个网关<code>10.0.0.1</code>，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从<code>/var/run/docker/netns</code>中查看一下，这里还有一个名称为 <code>1-idx465x3jg</code> 的网络命名空间，我们进去看看</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.1/24 brd 10.0.0.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 8a:d3:52:ac:7d:<span class="built_in">cd</span> brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在这里我们找到了<code>2: br0</code>，其IP地址为<code>10.0.0.1</code>，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 <code>260: veth0@if259</code>，这个就是与<code>ingress_sbox</code> 中<code>259: eth0@if260</code>对应的网络接口 ，另一个是 <code>258: vxlan0@if258</code>，其基于<code>vxlan</code>协议，负责集群跨主机通信。</p></li></ul><h3 id="overlay总结">overlay总结</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker_gwbridge</code>中的容器<code>ingress-sbox</code>，其有两块网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p></li><li class="lvl-2"><p>实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p></li><li class="lvl-2"><p>当请求到达宿主机时，会通过<code>enp0s5</code>转发到<code>docker_gwbridge</code>，然后先被转到<code>ingress-sbox</code>容器，然后再经过其转发到<code>br0</code>网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过<code>vxlan0</code>网络接口转发到其它节点进行查找，中间经过一系列的网络地址转换。</p></li></ul><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/9UVZzm.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>当你通过<code>docker network create --driver overlay my-network</code>创建一个overlay网络时，Docker会创建一个类似“ingress”的网络结构(新的<code>br0</code>)，如果不指定ip段，其ip段会从<code>10.0.1.0/24</code>开始，依次递增一个网段。但会共用<code>docker_gwbridge</code>。</p></li></ul><h2 id="查看overlay网络中的负载均衡">查看overlay网络中的负载均衡</h2><ul class="lvl-0"><li class="lvl-2"><p>启动一个service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name my-nginx --replicas 5 --publish 80:80 nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看<code>ingress_sbox</code>的<code>iptables</code>数据链中的 mangle 表</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle</span><br><span class="line"><span class="comment">## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 MARK <span class="built_in">set</span> 0x105</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.0.33            MARK <span class="built_in">set</span> 0x105</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过<code>ipvsadm</code>查看负载均衡信息</p></li></ul><blockquote><p>ipvsadm 是 Linux 下管理 IPVS（IP Virtual Server）负载均衡器的命令之一</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果没有ipvsadm，则安装</span></span><br><span class="line">dnf install ipvsadm -y</span><br><span class="line"><span class="comment"># 查看ipvs信息</span></span><br><span class="line">nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln</span><br><span class="line"><span class="comment"># -L：表示列出当前 IPVS 的规则和状态（List）。</span></span><br><span class="line"><span class="comment"># -n：表示以数字方式显示地址和端口，而不进行 DNS 解析或端口名解析（即：IP 和端口号以数字显示，更直观，也更快）。</span></span><br><span class="line"><span class="comment">## 输出，可以看到 FWM 261 rr，这里rr表示轮询</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">FWM  261 rr</span><br><span class="line">  -&gt; 10.0.0.34:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.35:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.36:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.37:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.38:0                  Masq    1      0          0</span><br><span class="line"><span class="comment">## 输出解释</span></span><br><span class="line"><span class="comment"># Prot: 协议（TCP/UDP）,这里是 FWM，表示Firewall Mark（防火墙标记）模式</span></span><br><span class="line"><span class="comment"># LocalAddress:Port: 本地地址和端口号，这里是 261 ，这是防火墙标记值（mark 值）,就是上面看到的那个16进制 0x105</span></span><br><span class="line"><span class="comment"># Scheduler: 调度算法，这里是 rr，表示轮询(round-robin)，调度算法还有 wrr（加权轮询）、lc（最少连接）等</span></span><br><span class="line"><span class="comment"># RemoteAddress:Port: 远程地址和端口号，这里是 10.0.0.34:0，表示负载均衡到的第一个节点，后面同理</span></span><br><span class="line"><span class="comment"># Forward: 转发策略，这里是 Masq，表示将负载均衡到的节点的IP地址转换成宿主机的IP地址，即 Masquerade（伪装）。转发方式（如：Masq、Tunnel、Direct Route）</span></span><br><span class="line"><span class="comment"># Weight: 权重，这里是 1，表示负载均衡到的节点的权重，默认为 1</span></span><br><span class="line"><span class="comment"># ActiveConn: 当前活动连接数，这里是 0</span></span><br><span class="line"><span class="comment"># InActConn: 当前不活动连接数（等待关闭的连接），这里是 0</span></span><br></pre></td></tr></table></figure><h2 id="VXLAN是什么？">VXLAN是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>VXLAN（Virtual Extensible LAN）是 Cisco 公司开发的一种虚拟局域网（VLAN）技术，它可以将多个 VLAN 逻辑分组，并使用单个物理网络进行管理。VXLAN 的主要作用是提高网络性能和扩展性。</p></li><li class="lvl-2"><p>它本质上是一种 网络封装协议（overlay protocol），用来在已有的 IP 网络之上，构建二层（L2）虚拟网络。</p></li></ul><h3 id="为什么需要-VXLAN？">为什么需要 VXLAN？</h3><ul class="lvl-0"><li class="lvl-2"><p>在传统数据中心或云计算中，经常有这样的需求：</p><ul class="lvl-2"><li class="lvl-6">跨不同物理网络或子网，部署在不同服务器上的虚拟机或容器，要能像在同一个二层网络里一样直接通信。</li><li class="lvl-6">VLAN（802.1Q）提供的二层隔离能力只有 12 bit VLAN ID（最多 4096 个 VLAN），在大型数据中心远远不够用。</li></ul></li><li class="lvl-2"><p>数据中心想要更好的弹性、跨区域部署、容器编排、大规模租户隔离。</p></li></ul><h3 id="VXLAN-核心原理">VXLAN 核心原理</h3><ul class="lvl-0"><li class="lvl-2"><p>VXLAN 通过封装的方式，把二层以太网帧包在 UDP 数据报里，在三层 IP 网络中传递。</p></li><li class="lvl-2"><p>封装格式大致是：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">| 外层IP头 (IP Header)    |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 外层UDP头 (UDP Header)  |</span><br><span class="line">+-------------------------+</span><br><span class="line">| VXLAN头 (VXLAN Header)  |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 内层二层帧 (Ethernet)   |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>外层 IP/UDP 用于三层传输</p></li><li class="lvl-2"><p>内层保留原本的二层以太网帧（如 MAC 地址）</p></li><li class="lvl-2"><p>VXLAN 头部里面包含了一个 VNI (VXLAN Network Identifier)：24 bit，可支持 1600万个虚拟网络</p></li><li class="lvl-2"><p>简单示意图</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VM1 (10.1.1.1) ——&gt; VTEP1 ——&gt; Underlay IP网络 ——&gt; VTEP2 ——&gt; VM2 (10.1.1.2)</span><br><span class="line"></span><br><span class="line">VTEP1 封装：</span><br><span class="line">  内层以太网帧  + VXLAN头 (VNI) + UDP + IP</span><br><span class="line"></span><br><span class="line">VTEP2 解封装：</span><br><span class="line">  去掉外层头部，还原原始二层帧</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 网络(Overlay)&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 服务(Service)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/"/>
    <id>https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/</id>
    <published>2025-06-10T13:30:05.000Z</published>
    <updated>2025-06-28T03:23:06.766Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 服务管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Service-与-Task">Service 与 Task</h2><h3 id="什么是-Service？">什么是 Service？</h3><ul class="lvl-0"><li class="lvl-2"><p>Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。</p></li><li class="lvl-2"><p>它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。</p></li><li class="lvl-2"><p>可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。</p></li></ul><h3 id="什么是-Task？">什么是 Task？</h3><ul class="lvl-0"><li class="lvl-2"><p>Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。</p></li><li class="lvl-2"><p>Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。</p></li><li class="lvl-2"><p>Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。</p></li><li class="lvl-2"><p>当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。</p></li><li class="lvl-2"><p>Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。</p></li></ul><h3 id="示例">示例</h3><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name nginx --replicas 3 nginx:latest</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。</p></li></ul><table><thead><tr><th>项目</th><th>Service</th><th>Task</th></tr></thead><tbody><tr><td>定义</td><td>用户定义的服务配置</td><td>服务配置生成的执行单元</td></tr><tr><td>数量关系</td><td>一个 Service 包含多个 Task</td><td>一个 Task 属于一个 Service</td></tr><tr><td>状态</td><td>描述“期望状态”</td><td>代表“实际状态”</td></tr><tr><td>生命周期</td><td>可以更新</td><td>不可变，更新意味着重新创建</td></tr><tr><td>管理者</td><td>由用户管理</td><td>完全由 Swarm 调度和管理</td></tr></tbody></table><h2 id="Service-相关命令">Service 相关命令</h2><table><thead><tr><th>命令</th><th>中文说明</th></tr></thead><tbody><tr><td>create</td><td>创建一个新的服务</td></tr><tr><td>inspect</td><td>显示一个或多个服务的详细信息</td></tr><tr><td>logs</td><td>获取服务或任务的日志</td></tr><tr><td>ls</td><td>列出所有服务</td></tr><tr><td>ps</td><td>列出一个或多个服务的任务（Task）</td></tr><tr><td>rm</td><td>删除一个或多个服务</td></tr><tr><td>rollback</td><td>回滚服务的配置更改</td></tr><tr><td>scale</td><td>扩缩一个或多个可复制服务的副本数量</td></tr><tr><td>update</td><td>更新服务配置</td></tr></tbody></table><h3 id="docker-service-create-创建服务"><code>docker service create</code>:  创建服务</h3><ul class="lvl-0"><li class="lvl-2"><p>常用参数说明</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例命令（含说明）</th></tr></thead><tbody><tr><td><code>--name</code></td><td>指定服务名称</td><td><code>docker service create --name my-web nginx</code><br>→ 创建一个名为 <code>my-web</code> 的 nginx 服务</td></tr><tr><td><code>--replicas</code></td><td>设置副本数量（仅适用于 replicated 模式）</td><td><code>docker service create --replicas 3 nginx</code><br>→ 启动 3 个 nginx 副本</td></tr><tr><td><code>--publish</code> 或 <code>-p</code></td><td>映射端口（格式如 <code>80:80</code>）</td><td><code>docker service create -p 8080:80 nginx</code><br>→ 将容器的 80 端口映射到主机 8080</td></tr><tr><td><code>--env</code> 或 <code>-e</code></td><td>设置环境变量</td><td><code>docker service create -e ENV=prod nginx</code><br>→ 设置环境变量 <code>ENV=prod</code></td></tr><tr><td><code>--mount</code></td><td>设置数据卷挂载</td><td><code>docker service create --mount type=bind,src=/data,target=/app nginx</code><br>→ 将主机的 <code>/data</code> 目录挂载到容器内 <code>/app</code></td></tr><tr><td><code>--constraint</code></td><td>设置部署约束（如指定节点）</td><td><code>docker service create --constraint 'node.labels.type == web' nginx</code><br>→ 仅部署在带标签 <code>type=web</code> 的节点上</td></tr><tr><td><code>--network</code></td><td>指定服务所属的网络（通常使用 overlay 网络）</td><td><code>docker service create --network my-net nginx</code><br>→ 将服务连接到自定义网络 <code>my-net</code></td></tr><tr><td><code>--detach</code> 或 <code>-d</code></td><td>后台运行服务（默认行为）</td><td><code>docker service create -d nginx</code><br>→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行</td></tr><tr><td><code>--limit-cpu</code> / <code>--limit-memory</code></td><td>设置资源限制</td><td><code>docker service create --limit-cpu 0.5 --limit-memory 256M nginx</code><br>→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存</td></tr><tr><td><code>--restart-condition</code></td><td>设置重启策略（如 on-failure、any、none）</td><td><code>docker service create --restart-condition on-failure nginx</code><br>→ 仅当容器失败时自动重启</td></tr><tr><td><code>--mode</code></td><td>指定服务运行模式，支持：<code>replicated</code>、<code>global</code>、<code>replicated-job</code>、<code>global-job</code></td><td><code>docker service create --mode global nginx</code><br>→ 在集群每个节点上运行一个 nginx 实例</td></tr></tbody></table><blockquote><p>cpu 与 内存限制</p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td><code>--limit-cpu 1.0</code></td><td>限制每个容器最多使用 1 核 CPU时间 , 1 CPU = 在每个调度周期中可占满 CPU 的全部时间份额(一个周期时间默认100ms)</td></tr><tr><td><code>--limit-cpu 0.5</code></td><td>限制每个容器最多使用 50% 的单核CPU时间</td></tr><tr><td><code>--limit-cpu 3.5</code></td><td>每个容器最多可以使用 3.5 核的 CPU 时间，由调度器决定分配。并不是限制成只能跑在一个核上，而是限制“总共使用不超过 3.5 核的时间片”。</td></tr><tr><td><code>--limit-memory 512M</code></td><td>限制每个容器最多使用指定内存（如 512M）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>服务运行模式（–mode）详解</p></li></ul><table><thead><tr><th>模式名称</th><th>说明</th><th>使用场景示例</th></tr></thead><tbody><tr><td><code>replicated</code></td><td>默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。</td><td>典型的 Web 服务，如 nginx、Node.js、Java 应用等</td></tr><tr><td><code>global</code></td><td>每个可用节点只部署一个任务实例，不需要用户指定副本数。</td><td>系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter）</td></tr><tr><td><code>replicated-job</code></td><td>在多个节点上<strong>按副本数</strong>运行一次性任务，任务完成后即退出。</td><td>数据处理、批处理任务，如转换文件或跑 ETL</td></tr><tr><td><code>global-job</code></td><td>在<strong>所有节点上各运行一次</strong>的短暂任务，执行完毕即退出。</td><td>初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等</td></tr></tbody></table><blockquote><p>job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。<br>replicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>服务重启策略（–restart-condition）详解</p></li></ul><table><thead><tr><th>值</th><th>含义说明</th></tr></thead><tbody><tr><td><code>none</code></td><td>不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。</td></tr><tr><td><code>on-failure</code></td><td><strong>仅在任务异常失败时</strong>（exit code 非 0）自动重启。常用于可能偶发失败的服务。</td></tr><tr><td><code>any</code>（默认）</td><td><strong>无论任务如何退出</strong>（包括正常退出或失败），都会尝试重启。适用于持续运行服务。</td></tr></tbody></table><blockquote><p>情景总结</p></blockquote><table><thead><tr><th>情景</th><th><code>none</code></th><th><code>on-failure</code></th><th><code>any</code></th></tr></thead><tbody><tr><td>服务运行时崩溃（exit code ≠ 0）</td><td>❌ 不重启</td><td>✅ 自动重启</td><td>✅ 自动重启</td></tr><tr><td>服务正常结束（exit code = 0）</td><td>❌ 不重启</td><td>❌ 不重启</td><td>✅ 自动重启</td></tr><tr><td>持续运行型服务（如 nginx）</td><td>❌ 不推荐</td><td>可用</td><td>✅ 推荐</td></tr><tr><td>一次性任务（如批处理、数据初始化）</td><td>✅ 推荐</td><td>可用</td><td>❌ 不推荐</td></tr></tbody></table><h4 id="docker-service-create-使用示例"><code>docker service create</code> 使用示例</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --publish 80:80 \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global</span></span><br><span class="line">docker service create --name log-agent --mode global fluentd</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name web-app \</span><br><span class="line">  --<span class="built_in">env</span> NODE_ENV=production \</span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/data,target=/app/data \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  node:18 node server.js</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷</span></span><br><span class="line">docker volume create db-data</span><br><span class="line"><span class="comment"># 创建服务</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name db \</span><br><span class="line">  --constraint <span class="string">&#x27;node.labels.role == db&#x27;</span> \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=db-data,target=/var/lib/mysql \</span><br><span class="line">  mysql:8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使用 on-failure 策略，仅在失败时自动重启</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name unstable-worker \</span><br><span class="line">  --restart-condition on-failure \</span><br><span class="line">  my-worker-image</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>指定网络，网络驱动类型为 overlay</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）</span></span><br><span class="line">docker network create --driver overlay my-overlay-net</span><br><span class="line"><span class="comment"># 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务并加入该网络</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name web-service \</span><br><span class="line">  --network my-overlay-net \</span><br><span class="line">  --replicas 5 \</span><br><span class="line">  nginx</span><br><span class="line">  <span class="comment"># --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">6b7aadbbd180   bridge            bridge    <span class="built_in">local</span></span><br><span class="line">5ddadf5d0608   docker_gwbridge   bridge    <span class="built_in">local</span></span><br><span class="line">21c6f5b1bedd   host              host      <span class="built_in">local</span></span><br><span class="line">idx465x3jg68   ingress           overlay   swarm</span><br><span class="line">a770c5ad4b13   none              null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。</li><li class="lvl-2">但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。</li><li class="lvl-2">默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。</li><li class="lvl-2">另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发<ul class="lvl-3"><li class="lvl-4">当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。</li><li class="lvl-4">节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。</li></ul></li></ul></div><h3 id="docker-service-ls-列出所有服务"><code>docker service ls</code>: 列出所有服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span></span><br><span class="line">ID             NAME       MODE         REPLICAS   IMAGE          PORTS</span><br><span class="line">dmnztimv3pb8   my-nginx   replicated   2/2        nginx:latest   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure><h3 id="docker-service-inspect-查看服务详情"><code>docker service inspect</code>: 查看服务详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-log-查看服务日志"><code>docker service log</code>: 查看服务日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定服务下所有任务的日志</span></span><br><span class="line">docker service logs my-nginx</span><br><span class="line"><span class="comment"># 查看指定任务的日志，指定任务ID，不支持任务名称</span></span><br><span class="line">docker service logs p4tats0f9npk</span><br><span class="line"><span class="comment"># 滚动查看日志</span></span><br><span class="line">docker service logs -f my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-ps-列出服务任务"><code>docker service ps</code>: 列出服务任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 13 minutes ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 15 minutes ago</span><br></pre></td></tr></table></figure><h3 id="docker-service-scale-扩容-缩容服务"><code>docker service scale</code>: 扩容/缩容服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个服务</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --publish 80:80 \</span><br><span class="line">  nginx</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 14 seconds ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 2 minutes ago</span><br><span class="line">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running 4 seconds ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩容到5个任务</span></span><br><span class="line">docker service scale my-nginx=5</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running about a minute ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 3 minutes ago</span><br><span class="line">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">ksbeflwg3mcj   my-nginx.4   nginx:latest   worker1    Running         Running less than a second ago</span><br><span class="line">iw4zlm56n1x8   my-nginx.5   nginx:latest   manager3   Running         Running less than a second ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩容到2个人任务</span></span><br><span class="line">docker service scale my-nginx=2</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE           ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 2 minutes ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 4 minutes ago</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用如下命令进行扩缩容</span></span><br><span class="line">docker service update --replicas=5 my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-update-更新服务"><code>docker service update</code>: 更新服务</h3><ul class="lvl-0"><li class="lvl-2"><p>支持的参数</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>--image</code></td><td>更新服务使用的镜像</td><td><code>--image nginx:1.25</code></td></tr><tr><td><code>--replicas</code></td><td>设置服务的副本数量（仅适用于 replicated 模式）</td><td><code>--replicas 5</code></td></tr><tr><td><code>--env-add</code></td><td>添加环境变量</td><td><code>--env-add DEBUG=true</code></td></tr><tr><td><code>--env-rm</code></td><td>移除环境变量</td><td><code>--env-rm OLD_VAR</code></td></tr><tr><td><code>--publish-add</code></td><td>添加端口映射</td><td><code>--publish-add published=8080,target=80</code></td></tr><tr><td><code>--publish-rm</code></td><td>移除端口映射</td><td><code>--publish-rm 80</code></td></tr><tr><td><code>--mount-add</code></td><td>添加挂载</td><td><code>--mount-add type=bind,src=/data,dst=/data</code></td></tr><tr><td><code>--mount-rm</code></td><td>移除挂载</td><td><code>--mount-rm /data</code></td></tr><tr><td><code>--constraint-add</code></td><td>添加部署约束</td><td><code>--constraint-add 'node.labels.zone==east'</code></td></tr><tr><td><code>--constraint-rm</code></td><td>移除部署约束</td><td><code>--constraint-rm 'node.labels.zone==east'</code></td></tr><tr><td><code>--limit-cpu</code></td><td>设置 CPU 限制</td><td><code>--limit-cpu 0.5</code></td></tr><tr><td><code>--limit-memory</code></td><td>设置内存限制</td><td><code>--limit-memory 256M</code></td></tr><tr><td><code>--restart-condition</code></td><td>设置重启策略（none、on-failure、any）</td><td><code>--restart-condition on-failure</code></td></tr><tr><td><code>--update-delay</code></td><td>设置任务更新之间的延迟</td><td><code>--update-delay 10s</code></td></tr><tr><td><code>--update-parallelism</code></td><td>设置并发更新任务的数量</td><td><code>--update-parallelism 2</code></td></tr><tr><td><code>--update-order</code></td><td>设置更新顺序（start-first 或 stop-first）</td><td><code>--update-order start-first</code></td></tr><tr><td><code>--update-failure-action</code></td><td>更新失败后的动作（pause、continue、rollback）</td><td><code>--update-failure-action rollback</code></td></tr><tr><td><code>--rollback</code></td><td>回滚到上一次成功配置</td><td><code>--rollback</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service update \</span><br><span class="line">  --image nginx:1.25 \</span><br><span class="line">  --replicas 4 \</span><br><span class="line">  --env-add ENV=prod \</span><br><span class="line">  --limit-memory 512M \</span><br><span class="line">  --limit-cpu 1.0 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  --update-failure-action rollback \</span><br><span class="line">  my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-rollback-回滚服务"><code>docker service rollback</code>: 回滚服务</h3><ul class="lvl-0"><li class="lvl-2"><p>会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker service rollback &lt;service_name&gt;</span></span><br><span class="line">docker service rollback my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-rm-删除服务"><code>docker service rm</code>: 删除服务</h3><ul class="lvl-0"><li class="lvl-2"><p>删除服务会停止服务并删除服务。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker service rm &lt;service_name&gt;</span></span><br><span class="line">docker service <span class="built_in">rm</span> my-nginx</span><br></pre></td></tr></table></figure><h2 id="经验技巧">经验技巧</h2><h3 id="如何让任务运行在指定的节点上？">如何让任务运行在指定的节点上？</h3><ul class="lvl-0"><li class="lvl-2"><p>创建服务时，可以使用 <code>--constraint</code> 参数指定节点的标签，使其运行在具有指定标签的节点上。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给结点加标签</span></span><br><span class="line">docker node update --label-add <span class="built_in">env</span>=prod worker1</span><br><span class="line"></span><br><span class="line"><span class="comment"># node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=prod</span></span><br><span class="line">docker service create \</span><br><span class="line">--name my-nginx \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--constraint <span class="string">&#x27;node.labels.env == prod&#x27;</span> \</span><br><span class="line">nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>只能运行在管理节点上</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name manager-only-service \</span><br><span class="line">  --constraint <span class="string">&#x27;node.role == manager&#x27;</span> \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Swarm 内置属性</p></li></ul><table><thead><tr><th>属性名</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>node.id</code></td><td><code>node.id == abcd1234</code></td><td>节点的唯一 ID（可用 <code>docker node ls</code> 查看）</td></tr><tr><td><code>node.hostname</code></td><td><code>node.hostname == manager-1</code></td><td>节点主机名</td></tr><tr><td><code>node.role</code></td><td><code>node.role == manager</code> 或 <code>node.role == worker</code></td><td>节点在 Swarm 中的角色（管理/工作）</td></tr><tr><td><code>engine.labels.*</code></td><td><code>engine.labels.disk == ssd</code></td><td>Docker 引擎级别的标签（需手动设置）</td></tr><tr><td><code>node.platform.os</code></td><td><code>node.platform.os == linux</code></td><td>节点操作系统类型</td></tr><tr><td><code>node.platform.arch</code></td><td><code>node.platform.arch == x86_64</code></td><td>节点架构类型（如 <code>arm64</code>, <code>x86_64</code>）</td></tr></tbody></table><h3 id="如何访问Service服务？">如何访问Service服务？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostname</span></span><br><span class="line">docker service create --name <span class="built_in">whoami</span> \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  traefik/whoami</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service服务运行在哪些节点上，看到这里只有 manager1\manager2\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器ID</span></span><br><span class="line">docker service ps <span class="built_in">whoami</span></span><br><span class="line">ID             NAME       IMAGE                   NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">u1elzp22hyvm   whoami.1   traefik/whoami:latest   manager2   Running         Running 2 minutes ago</span><br><span class="line">4cent1kfgghb   whoami.2   traefik/whoami:latest   worker2    Running         Running 17 seconds ago</span><br><span class="line">lu6u6j8ji0uq   whoami.3   traefik/whoami:latest   manager1   Running         Running 40 seconds ago</span><br><span class="line"><span class="comment"># 如果希望查询某个Service的所有容器的ID，可以执行如下命令</span></span><br><span class="line">docker service ps <span class="built_in">whoami</span> -q | xargs docker inspect --format <span class="string">&#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27;</span> | <span class="built_in">cut</span> -c 1-12</span><br><span class="line">a3fb63bde8e7</span><br><span class="line">a14e30a02987</span><br><span class="line">549610f3a1e9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 <code>curl 10.211.55.12</code>，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.211.55.12</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Hostname: a3fb63bde8e7   <span class="comment"># 容器ID</span></span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: ::1</span><br><span class="line">IP: 10.0.0.36            <span class="comment"># 容器IP，对接 br0</span></span><br><span class="line">IP: 172.18.0.4           <span class="comment"># 容器IP，对接 docker_gwbridge</span></span><br><span class="line">RemoteAddr: 10.0.0.6:52964</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 10.211.55.12</span><br><span class="line">User-Agent: curl/7.61.1</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。</p></li><li class="lvl-2"><p>可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># filename: docker_service_container</span></span><br><span class="line"><span class="comment"># 用法提示</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> &lt;SERVICE_NAME&gt;&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># service名称</span></span><br><span class="line">SERVCIE_NAME=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># 所属network,默认 ingress，这里要注意一下，如果是自定义的overlay网络，只能获取到当前主机上的容器IP</span></span><br><span class="line">NETWORK=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  NETWORK=$(docker service inspect <span class="variable">$SERVCIE_NAME</span> --format <span class="string">&#x27;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;.[0].NetworkID&#x27;</span> | sed <span class="string">&#x27;s/&quot;//g&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NETWORK=$&#123;2:-ingress&#125;</span></span><br><span class="line"></span><br><span class="line">d1=$(<span class="built_in">echo</span> -e <span class="string">&quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span> ;\</span><br><span class="line">docker service ps <span class="variable">$SERVCIE_NAME</span> --filter <span class="string">&quot;desired-state=running&quot;</span> -q | xargs docker inspect --format <span class="string">&#x27;&#123;&#123;.ServiceID&#125;&#125;    &#123;&#123;.ID&#125;&#125;    &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;    &#123;&#123;.NodeID&#125;&#125;&#x27;</span> \</span><br><span class="line">| awk <span class="string">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;$d1&quot;</span></span><br><span class="line"></span><br><span class="line">d2=$(docker service ps <span class="variable">$SERVCIE_NAME</span> --filter <span class="string">&quot;desired-state=running&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;$d2&quot;</span></span><br><span class="line"></span><br><span class="line">nn1=$(awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">NR==FNR &amp;&amp; FNR &gt; 1 &#123;</span></span><br><span class="line"><span class="string">  id = $1</span></span><br><span class="line"><span class="string">  name = $2</span></span><br><span class="line"><span class="string">  node = $4</span></span><br><span class="line"><span class="string">  desired = $5</span></span><br><span class="line"><span class="string">  # 拼接 CURRENT STATE（从第6列开始的所有字段）</span></span><br><span class="line"><span class="string">  current = &quot;&quot;</span></span><br><span class="line"><span class="string">  for (i=6; i&lt;=NF; i++) &#123;</span></span><br><span class="line"><span class="string">    current = current $i &quot; &quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  gsub(/ /, &quot;-&quot;, current)</span></span><br><span class="line"><span class="string">  current = substr(current, 1, length(current)-1)  # 去掉最后空格</span></span><br><span class="line"><span class="string">  info[id] = name &quot;\t&quot; node &quot;\t&quot; desired &quot;\t&quot; current</span></span><br><span class="line"><span class="string">  next</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">FNR==1 &#123;</span></span><br><span class="line"><span class="string">  print $0 &quot;\tTASK-NAME\tNODE\tDESIRED_STATE\tCURRENT_STATE&quot;</span></span><br><span class="line"><span class="string">  next</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  print $0 &quot;\t&quot; info[$2]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span> &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$d2</span>&quot;</span>) &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$d1</span>&quot;</span>) | <span class="built_in">tail</span> -n +2 | column -t)</span><br><span class="line"></span><br><span class="line">nn2=$(<span class="built_in">echo</span> <span class="string">&quot;CONTAINER-ID IP&quot;</span>;docker network inspect <span class="variable">$&#123;NETWORK&#125;</span> -f <span class="string">&#x27;&#123;&#123;range $id, $container := .Containers&#125;&#125;&#123;&#123;slice $id 0 12&#125;&#125; &#123;&#123;$container.Name&#125;&#125; &#123;&#123;$container.IPv4Address&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> | grep <span class="variable">$SERVCIE_NAME</span> | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&quot; &quot;$3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">NR==FNR &#123; ip[$1]=$2; next &#125;</span></span><br><span class="line"><span class="string">&#123; print $0, ip[$3] &#125;</span></span><br><span class="line"><span class="string">&#x27;</span> &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$nn2</span>&quot;</span>) &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$nn1</span>&quot;</span>) | column -t</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-swarm-service</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">docker-swarm-service <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">SERVICE-ID    TASK-ID       CONTAINER-ID  NODE-ID       TASK-NAME  NODE      DESIRED_STATE  CURRENT_STATE              IP</span><br><span class="line">snuhv0g2dm1q  czisrjrp8k2t  9e4ce349971c  kp2zerd28xgz  whoami.1   manager1  Running        Running-about-an-hour-ago  10.0.0.35/24</span><br><span class="line">snuhv0g2dm1q  tvbkwmnafedw  0d586021260d  kp2zerd28xgz  whoami.2   manager1  Running        Running-about-an-hour-ago  10.0.0.36/24</span><br><span class="line">snuhv0g2dm1q  815qp859a1f4  449d5e1a231d  kp2zerd28xgz  whoami.3   manager1  Running        Running-about-an-hour-ago  10.0.0.15/24</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 服务管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 节点(Node)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/"/>
    <id>https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/</id>
    <published>2025-06-09T13:30:05.000Z</published>
    <updated>2025-06-10T06:00:11.021Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 节点管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Docker-Swarm-简介">Docker Swarm 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。</p></li><li class="lvl-2"><p>从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。</p></li><li class="lvl-2"><p>Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。</p></li><li class="lvl-2"><p>Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/KwTed9.png" alt=""></p></li><li class="lvl-2"><p>以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比</p></li></ul><table><thead><tr><th>特性/功能</th><th>管理节点（Manager Node）</th><th>工作节点（Worker Node）</th></tr></thead><tbody><tr><td>角色</td><td>负责集群管理和决策</td><td>执行分配的服务任务</td></tr><tr><td>是否参与服务运行</td><td>可以运行服务任务，也可以只做管理（可配置）</td><td>仅运行服务任务，不参与管理决策</td></tr><tr><td>集群状态维护</td><td>维护整个 Swarm 的状态（使用 Raft 协议）</td><td>不维护集群状态</td></tr><tr><td>调度任务</td><td>决定将服务任务分配给哪个节点</td><td>不负责调度，只执行接收到的任务</td></tr><tr><td>管理命令处理</td><td>接收并处理 Swarm 管理命令（如创建服务、扩缩容等）</td><td>不处理管理命令</td></tr><tr><td>数据一致性</td><td>需要保持一致性（至少 3 个管理节点形成高可用）</td><td>不涉及一致性</td></tr><tr><td>资源要求</td><td>相对较高，需要承担管理和协调开销</td><td>相对较低，专注于运行容器</td></tr><tr><td>可用性要求</td><td>通常配置奇数个（3、5、7…）以保障高可用</td><td>可根据需要自由扩展或缩减</td></tr><tr><td>节点加入方式</td><td>通过 manager token 加入 Swarm</td><td>通过 worker token 加入 Swarm</td></tr><tr><td>故障影响</td><td>多个管理节点故障可能影响整个 Swarm 的控制能力</td><td>部分工作节点故障通常不会影响 Swarm 的管理能力</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。</p></li><li class="lvl-2"><p>worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。</p></li><li class="lvl-2"><p>默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。</p></li><li class="lvl-2"><p>manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。</p></li></ul><h2 id="搭建Swarm集群">搭建Swarm集群</h2><ul class="lvl-0"><li class="lvl-2"><p>本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。</p></li><li class="lvl-2"><p>其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。</p></li></ul><table><thead><tr><th>IP 地址</th><th>HostName</th><th>角色类型</th></tr></thead><tbody><tr><td>10.211.55.10</td><td>manager1</td><td>管理节点</td></tr><tr><td>10.211.55.11</td><td>manager2</td><td>管理节点</td></tr><tr><td>10.211.55.12</td><td>manager3</td><td>管理节点</td></tr><tr><td>10.211.55.13</td><td>worker1</td><td>工作节点</td></tr><tr><td>10.211.55.14</td><td>worker2</td><td>工作节点</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信：</p></li></ul><table><thead><tr><th>端口号</th><th>协议</th><th>用途说明</th></tr></thead><tbody><tr><td>2377</td><td>TCP</td><td>管理器节点之间通信（管理指令和加入集群）</td></tr><tr><td>7946</td><td>TCP/UDP</td><td>节点发现和通信（集群内部发现机制）</td></tr><tr><td>4789</td><td>UDP</td><td>覆盖网络流量（VXLAN，用于容器间网络）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 Swarm 管理节点通信端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=2377/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点发现（cluster communication）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=7946/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=7946/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay 网络流量（容器间通信）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>所有主机必须时间一致</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步系统时间</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart chronyd</span><br><span class="line">chronyc tracking</span><br><span class="line"><span class="comment"># 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）</span></span><br><span class="line"><span class="comment"># 设置时区为中国上海时间（CST）</span></span><br><span class="line"><span class="built_in">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># 查看时间和时区</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure><h3 id="创建集群">创建集群</h3><ul class="lvl-0"><li class="lvl-2"><p>在 manager1 节点上执行如下命令来创建一个新的swarm集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前docker的swarm模式是否开启</span></span><br><span class="line">docker info | grep <span class="string">&quot;Swarm&quot;</span></span><br><span class="line"><span class="comment">## 输出， inactive 表示没有开启swarm集群</span></span><br><span class="line"> Swarm: inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群初始化</span></span><br><span class="line"><span class="comment"># docker swarm init --advertise-addr &lt;MANAGER-IP&gt;</span></span><br><span class="line">docker swarm init --advertise-addr 10.211.55.10</span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="comment"># --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377</span></span><br><span class="line"><span class="comment"># 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leader</span></span><br><span class="line">Swarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.</span><br><span class="line"><span class="comment"># 将一个worker node加入集群请运行下面的命令</span></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line">    <span class="comment"># 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取</span></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br><span class="line"><span class="comment"># 添加一个manager node需要执行下面的命令获取 manager token</span></span><br><span class="line">To add a manager to this swarm, run <span class="string">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看当前docker的swarm模式是否开启</span></span><br><span class="line">docker info | grep Swarm</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"> Swarm: active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点</span></span><br><span class="line">docker info --format <span class="string">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">LocalNodeState: active         <span class="comment"># 节点状态</span></span><br><span class="line">NodeID: kp2zerd28xgz5mmglnje0jp22 <span class="comment"># 节点ID</span></span><br><span class="line">NodeAddr: 10.211.55.10           <span class="comment"># 节点IP</span></span><br><span class="line">RemoteManagers: [                <span class="comment"># 节点管理节点信息</span></span><br><span class="line">  - NodeID: kp2zerd28xgz5mmglnje0jp22 <span class="comment"># 节点管理节点ID</span></span><br><span class="line">    Addr: 10.211.55.10:2377       <span class="comment"># 节点管理节点地址</span></span><br><span class="line">Nodes: 1                          <span class="comment"># 节点数量</span></span><br><span class="line">Managers: 1                       <span class="comment"># 管理节点数量</span></span><br><span class="line">ControlAvailable: <span class="literal">true</span>            <span class="comment"># 是否有控制节点</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>安装 yq 工具</strong></em></p><ul class="lvl-1"><li class="lvl-2">yq 是 yaml 的命令行处理工具，具体参考<a href="https://github.com/mikefarah/yq">yq</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 yq 最新版本</span></span><br><span class="line">VERSION=v4.45.4</span><br><span class="line">ARCH=amd64</span><br><span class="line">wget https://github.com/mikefarah/yq/releases/download/<span class="variable">$&#123;VERSION&#125;</span>/yq_linux_<span class="variable">$&#123;ARCH&#125;</span> -O /usr/local/bin/yq</span><br><span class="line"><span class="comment"># 添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/yq</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">yq --version</span><br></pre></td></tr></table></figure></div><h3 id="添加-manager-节点">添加 manager 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>获取 manager 节点的 token</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">To add a manager to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将 manager2 和 manager3 加入 swarm 集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别在 manager2 和 manager3 上运行如下命令，</span></span><br><span class="line">docker swarm <span class="built_in">join</span> \</span><br><span class="line">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \</span><br><span class="line">10.211.55.10:2377</span><br><span class="line"><span class="comment">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><h3 id="添加-worker-节点">添加 worker 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>获取 worker 节点的 token</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将 worker1 和 worker2 加入 swarm 集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别在 worker1 和 worker2 上运行如下命令，</span></span><br><span class="line">docker swarm <span class="built_in">join</span> \</span><br><span class="line">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \</span><br><span class="line">10.211.55.10:2377</span><br><span class="line"><span class="comment">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><h3 id="查看集群状态">查看集群状态</h3><ul class="lvl-0"><li class="lvl-2"><p>在 manager1 上执行如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker info --format <span class="string">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">LocalNodeState: active</span><br><span class="line">NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class="line">NodeAddr: 10.211.55.10</span><br><span class="line">RemoteManagers:</span><br><span class="line">  - NodeID: oymi74epagdqeprah7s81tsa2</span><br><span class="line">    Addr: 10.211.55.11:2377</span><br><span class="line">  - NodeID: r7388xl84nczjtnf53pwh7hla</span><br><span class="line">    Addr: 10.211.55.12:2377</span><br><span class="line">  - NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class="line">    Addr: 10.211.55.10:2377</span><br><span class="line">Nodes: 5</span><br><span class="line">Managers: 3</span><br><span class="line">ControlAvailable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="查看集群内节点信息">查看集群内节点信息</h3><ul class="lvl-0"><li class="lvl-2"><p>在 任意 manager 节点上运行如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">lsxj50x8ftqw8etvz5y37xc5q     worker2    Ready     Active                          26.1.3</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段名</th><th>示例值</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>ID</strong></td><td><code>kp2zerd28xgz5mmglnje0jp22</code></td><td>节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符）</td></tr><tr><td><strong>HOSTNAME</strong></td><td><code>manager1</code></td><td>节点的主机名（即加入 swarm 集群时该节点的 <code>hostname</code>）</td></tr><tr><td><strong>STATUS</strong></td><td><code>Ready</code></td><td>节点的状态：<br>• <code>Ready</code>：节点正常运行中<br>• <code>Down</code>：节点离线或无法通信<br>• <code>Paused</code>：暂停<br>• <code>Drain</code>：排空，正在迁移任务</td></tr><tr><td><strong>AVAILABILITY</strong></td><td><code>Active</code></td><td>节点的可用性设置：<br>• <code>Active</code>：节点可以调度任务（默认）<br>• <code>Pause</code>：暂停调度新任务<br>• <code>Drain</code>：迁移任务并不再调度</td></tr><tr><td><strong>MANAGER STATUS</strong></td><td><code>Leader</code> / <code>Reachable</code> / 空</td><td>仅适用于管理节点：<br>• <code>Leader</code>：当前 swarm 的主节点（负责协调）<br>• <code>Reachable</code>：集群中可通信的管理节点<br>• 空：表示这是一个工作节点（非管理节点）</td></tr><tr><td><strong>ENGINE VERSION</strong></td><td><code>26.1.3</code></td><td>Docker 引擎的版本号（即该节点上运行的 Docker 版本）</td></tr></tbody></table><h2 id="docker-swarm集群管理"><code>docker swarm</code>集群管理</h2><table><thead><tr><th>命令</th><th>中文含义</th></tr></thead><tbody><tr><td><code>ca</code></td><td>显示和轮换 Swarm 的根证书（CA）</td></tr><tr><td><code>init</code></td><td>初始化一个新的 Swarm 集群</td></tr><tr><td><code>join</code></td><td>将当前节点加入到 Swarm 中，作为工作节点或管理节点</td></tr><tr><td><code>join-token</code></td><td>管理用于加入 Swarm 的令牌（查看或重新生成）</td></tr><tr><td><code>leave</code></td><td>当前节点离开 Swarm 集群</td></tr><tr><td><code>unlock</code></td><td>解锁被加密的 Swarm（用于恢复 Manager 节点）</td></tr><tr><td><code>unlock-key</code></td><td>管理 Swarm 的解锁密钥（查看、备份等）</td></tr><tr><td><code>update</code></td><td>更新 Swarm 集群的全局配置（如加密、日志等）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm init</code>: 初始化 Swarm 集群（只在首次创建时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 10.211.55.10</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm join-token</code>:  生成加入集群的令牌</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 worker 节点的令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"><span class="comment"># 生成 manager 节点的令牌</span></span><br><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm join</code>: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span> --token &lt;token&gt; 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm leave</code>: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker 节点离开集群</span></span><br><span class="line">docker swarm leave</span><br><span class="line"><span class="comment"># manager 节点必须先降级为 worker节点，或者加上 --force 强制离开</span></span><br><span class="line">docker swarm leave --force</span><br><span class="line"><span class="comment"># 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点</span></span><br><span class="line"><span class="comment"># 集群中至少需要一个Manager节点，否则无法运行服务</span></span><br><span class="line"><span class="comment"># 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 down</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">lsxj50x8ftqw8etvz5y37xc5q     worker2    Down      Active                          26.1.3</span><br><span class="line"><span class="comment"># 如需彻底删除需要运行</span></span><br><span class="line">docker node <span class="built_in">rm</span> worker2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm update</code>: 更新 Swarm 集群配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看</span></span><br><span class="line">docker swarm update --autolock=<span class="literal">true</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Swarm updated.</span><br><span class="line">To unlock a swarm manager after it restarts, run the `docker swarm unlock`</span><br><span class="line"><span class="built_in">command</span> and provide the following key:</span><br><span class="line"></span><br><span class="line">    SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4</span><br><span class="line"></span><br><span class="line">Please remember to store this key <span class="keyword">in</span> a password manager, since without it you</span><br><span class="line">will not be able to restart the manager.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swarm集群锁定</span></span><br><span class="line">docker swarm update --autolock=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm unlock-key</code>: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取Swarm集群的解锁密钥</span></span><br><span class="line">docker swarm unlock-key</span><br><span class="line"><span class="comment"># 轮换Swarm集群的解锁密钥</span></span><br><span class="line">docker swarm unlock-key --rotate</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm unlock</code>: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class="string">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class="line"><span class="comment"># 需要先解锁才可以运行节点管理命令</span></span><br><span class="line">docker swarm unlock</span><br><span class="line"><span class="comment">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class="line">Please enter unlock key:</span><br></pre></td></tr></table></figure><h2 id="docker-node节点管理"><code>docker node</code>节点管理</h2><ul class="lvl-0"><li class="lvl-2"><p>节点管理相关命令，只能在 管理节点 上执行</p></li></ul><table><thead><tr><th>命令</th><th>中文含义</th></tr></thead><tbody><tr><td><code>demote</code></td><td>将一个或多个管理节点降级为工作节点</td></tr><tr><td><code>inspect</code></td><td>显示一个或多个节点的详细信息</td></tr><tr><td><code>ls</code></td><td>列出 swarm 集群中的所有节点</td></tr><tr><td><code>promote</code></td><td>将一个或多个工作节点提升为管理节点</td></tr><tr><td><code>ps</code></td><td>查看一个或多个节点上正在运行的任务（默认当前节点）</td></tr><tr><td><code>rm</code></td><td>从 swarm 集群中移除一个或多个节点</td></tr><tr><td><code>update</code></td><td>更新节点的元数据（如标签、可用性等）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>docker node ls</code>: 列出 swarm 集群中的所有节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node inspect &lt;node_id&gt;/&lt;hostname&gt;</code>: 查看指定节点的详细信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node inspect --pretty manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;</code>: 更新节点的元数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置节点为不可用</span></span><br><span class="line">docker node update --availability drain manager1</span><br><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">docker node update --label-add foo=bar manager1</span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">docker node update --label-rm foo manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node demote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将管理节点降级为工作节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker note promote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将工作节点升级为管理节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node promote worker1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node rm &lt;node_id&gt;/&lt;hostname&gt;</code>: 从 swarm 集群中移除一个节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">rm</span> manager1</span><br></pre></td></tr></table></figure><h2 id="节点管理常见情况">节点管理常见情况</h2><h3 id="如何正确的删除一个节点">如何正确的删除一个节点</h3><ul class="lvl-0"><li class="lvl-2"><p>1.如果是 manager 节点，先将 manager 节点降级为 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.退出集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在要退出集群的节点上执行</span></span><br><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.删除节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">rm</span> manager1</span><br></pre></td></tr></table></figure><h3 id="节点被退群或删除后，其上运行的service会怎样？">节点被退群或删除后，其上运行的service会怎样？</h3><ul class="lvl-0"><li class="lvl-2"><p>用一个示例来说明，先在 manager1 节点上创建一个 service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  --replicas 10 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看service状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出结果，可以看到每个节点上都启动了2个nginx容器</span></span><br><span class="line">ID             NAME          IMAGE          NODE       DESIRED STATE   CURRENT STATE                ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">t9agioefr316   my-nginx.2    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">moitlj50nunh   my-nginx.3    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4    nginx:latest   manager1   Running         Running about a minute ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class="line">i6mieuodbrtg   my-nginx.6    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">2yohffzzsrrl   my-nginx.7    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class="line">f3lusxoflqn2   my-nginx.8    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">xovzfmzsjlet   my-nginx.9    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10   nginx:latest   manager1   Running         Running about a minute ago</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这时将 worker2 从集群中退群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在worker2节点执行</span></span><br><span class="line">docker swarm leave</span><br><span class="line"><span class="comment"># 在manager节点查看集群节点</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再次查看service状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment"># 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class="line">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class="line">t9agioefr316   my-nginx.2       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class="line">moitlj50nunh   my-nginx.3       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4       nginx:latest   manager1   Running         Running 6 minutes ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class="line">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2   Running         Running 43 seconds ago</span><br><span class="line">i6mieuodbrtg    \_ my-nginx.6   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class="line">2yohffzzsrrl   my-nginx.7       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class="line">34km8mzg3xat   my-nginx.8       nginx:latest   manager3   Running         Running 43 seconds ago</span><br><span class="line">f3lusxoflqn2    \_ my-nginx.8   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class="line">xovzfmzsjlet   my-nginx.9       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1   Running         Running 6 minutes ago</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果不退群直接删除节点呢？这次我们直接删除 worker1 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 worker1 节点</span></span><br><span class="line">docker node <span class="built_in">rm</span> worker1</span><br><span class="line"><span class="comment"># 输出，提示 worker1 节点不是 down 状态，不能删除</span></span><br><span class="line"><span class="comment"># Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着我们强制删除</span></span><br><span class="line">docker node <span class="built_in">rm</span> -f worker1</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 输出，可以看到worker1节点已经删除了</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看service状态</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME             IMAGE          NODE                        DESIRED STATE   CURRENT STATE                 ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class="line">t9agioefr316   my-nginx.2       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class="line">moitlj50nunh   my-nginx.3       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4       nginx:latest   manager1                    Running         Running 12 minutes ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class="line">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2                    Running         Running 6 minutes ago</span><br><span class="line">i6mieuodbrtg    \_ my-nginx.6   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class="line">3t4qvpvrzpg3   my-nginx.7       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class="line">2yohffzzsrrl    \_ my-nginx.7   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class="line">34km8mzg3xat   my-nginx.8       nginx:latest   manager3                    Running         Running 6 minutes ago</span><br><span class="line">f3lusxoflqn2    \_ my-nginx.8   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class="line">4w5zfpfye3t8   my-nginx.9       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class="line">xovzfmzsjlet    \_ my-nginx.9   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1                    Running         Running 12 minutes ago</span><br></pre></td></tr></table></figure><h3 id="节点被退群或删除后是否可以重新加入集群">节点被退群或删除后是否可以重新加入集群</h3><ul class="lvl-0"><li class="lvl-2"><p>节点被退群或删除后，可以通过 <code>docker swarm join</code> 命令重新加入集群</p></li><li class="lvl-2"><p>若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 <code>docker swarm leave</code> 命令退群后再加入集群</p></li></ul><h3 id="如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法">如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里重启一个manager节点的docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class="string">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class="line"><span class="comment"># 需要先解锁才可以运行节点管理命令</span></span><br><span class="line">docker swarm unlock</span><br><span class="line"><span class="comment">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class="line">Please enter unlock key:</span><br><span class="line"><span class="comment">## 如果忘记了密钥，可以在其它manager节点通过如下命令查看</span></span><br><span class="line">docker swarm unlock-key</span><br><span class="line"><span class="comment"># 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了</span></span><br></pre></td></tr></table></figure><h3 id="Swarm-集群锁定功能的作用及使用场景">Swarm 集群锁定功能的作用及使用场景</h3><ul class="lvl-0"><li class="lvl-2"><p>作用</p></li></ul><table><thead><tr><th>✅ 作用</th><th>📋 说明</th></tr></thead><tbody><tr><td>加密保护管理密钥</td><td>管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。</td></tr><tr><td>防止节点被非法重启后加入集群</td><td>如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>场景</p></li></ul><table><thead><tr><th>场景类型</th><th>具体描述</th></tr></thead><tbody><tr><td>✅ 适合场景</td><td>对安全性要求高的生产环境</td></tr><tr><td></td><td>部署在不可信或共享物理环境中</td></tr><tr><td></td><td>云服务器、数据中心有专人运维管理解锁过程</td></tr><tr><td></td><td>希望防止物理/远程入侵者恢复管理器角色的公司</td></tr><tr><td>❌ 不适合场景</td><td>需要自动化部署或重启的 CI/CD 系统</td></tr><tr><td></td><td>测试环境或开发集群</td></tr><tr><td></td><td>无人值守、要求高可用自动恢复的部署系统</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>总结</p></li></ul><table><thead><tr><th>项目</th><th>是否推荐</th></tr></thead><tbody><tr><td>安全性</td><td>✅ 强烈推荐启用（尤其在生产环境）</td></tr><tr><td>自动化</td><td>❌ 不推荐（增加人工干预步骤）</td></tr><tr><td>解锁方式</td><td>解锁命令 + unlock key</td></tr><tr><td>unlock key 丢失后果</td><td>可能需要重建 Swarm（除非提前备份）</td></tr></tbody></table><h3 id="docker-swarm-ca-是做什么用的？"><code>docker swarm ca</code> 是做什么用的？</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm ca</code> 命令是用来 <strong>管理 Swarm 集群中的根证书颁发机构（CA）</strong> 的工具。具体功能包括：</p></li></ul><table><thead><tr><th>子命令/参数</th><th>说明</th></tr></thead><tbody><tr><td><code>docker swarm ca</code></td><td>查看当前 Swarm 的根 CA 公钥（PEM 格式）</td></tr><tr><td><code>docker swarm ca --rotate</code></td><td>轮换根 CA，用于安全更新</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Swarm 中的证书是干什么用的？</p></li></ul><table><thead><tr><th>用途</th><th>说明</th></tr></thead><tbody><tr><td>✅ 节点身份验证</td><td>每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。</td></tr><tr><td>🔐 通信加密</td><td>节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。</td></tr><tr><td>🔄 自动轮换</td><td>Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/swarm/certificates</span><br><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── swarm-node.crt      <span class="comment"># 节点证书</span></span><br><span class="line">├── swarm-node.key      <span class="comment"># 节点密钥</span></span><br><span class="line">└── swarm-root-ca.crt   <span class="comment"># 根CA证书</span></span><br></pre></td></tr></table></figure><h3 id="只让-Manager-做管理，不运行服务">只让 Manager 做管理，不运行服务</h3><ul class="lvl-0"><li class="lvl-2"><p>节点的<code>AVAILABILITY</code>有三种：<code>active</code>、<code>pause</code>、<code>drain</code>。</p></li></ul><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>active</code></td><td>可调度，Swarm 可以在此节点上运行服务任务（默认）</td></tr><tr><td><code>pause</code></td><td>暂停调度，不会分配新任务，但保留已有任务</td></tr><tr><td><code>drain</code></td><td>排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 manager1 节点为“不可调度”，即 排空模式</span></span><br><span class="line">docker node update --availability drain manager1</span><br><span class="line"><span class="comment"># 查看节点状态</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，manager1 节点状态变为 排空</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Drain          Reachable        26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Leader           26.1.3</span><br><span class="line">xkww4853bbdgv7bv8771xibob     worker1    Ready     Active                          26.1.3</span><br><span class="line">hvzkh3ip5ef8gx973z1ywahbu     worker2    Ready     Active                          26.1.3</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。</span></span><br><span class="line">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class="line">23m03nj54mzo   my-nginx.1       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class="line">9xi83bnh4fus   my-nginx.2       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class="line">wos8tbk449lk   my-nginx.3       nginx:latest   manager2   Running         Running 28 seconds ago</span><br><span class="line">uosmuh6bvwm0    \_ my-nginx.3   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class="line">yeqhqc3f735y   my-nginx.4       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">g8rduix7s74v   my-nginx.5       nginx:latest   worker2    Running         Running less than a second ago</span><br><span class="line">wuxilgpv9f50    \_ my-nginx.5   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class="line">3bxtn9boit28   my-nginx.6       nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class="line">57kdggaf8sag   my-nginx.7       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">uugi506p74s8   my-nginx.8       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class="line">yifwpqjnts9l   my-nginx.9       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class="line">yv4p6su7aom5   my-nginx.10      nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复运行任务能力</span></span><br><span class="line">docker node update --availability active manager1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止接收新的任务但保留运行中的任务</span></span><br><span class="line">docker node update --availability pause manager1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 节点管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 Dockerfile 多平台构建</title>
    <link href="https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/"/>
    <id>https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/</id>
    <published>2025-06-06T13:30:05.000Z</published>
    <updated>2025-06-07T11:32:29.230Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/build/building/multi-platform/">Multi-platform builds</a></p></li></ul><span id="more"></span><h2 id="什么是Dockerfile-多平台构建？">什么是Dockerfile 多平台构建？</h2><ul class="lvl-0"><li class="lvl-2"><p>Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。</p></li><li class="lvl-2"><p>在没有安装 <code>docker-buildx-plugin</code> 的情况下，<code>docker build</code> 命令是不支持使用 <code>--platform</code> 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。</p></li><li class="lvl-2"><p>要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。</p></li><li class="lvl-2"><p><code>docker-buildx-plugin</code> 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 <code>docker build</code> 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。</p></li></ul><h2 id="安装-docker-buildx-plugin">安装 docker-buildx-plugin</h2><ul class="lvl-0"><li class="lvl-2"><p>随docker服务一起安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>单独安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install docker-buildx-plugin</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看版本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx version</span><br></pre></td></tr></table></figure><h2 id="docker-buildx-基本命令"><code>docker buildx</code> 基本命令</h2><ul class="lvl-0"><li class="lvl-2"><p>以下命令在后面的示例中都有使用</p></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker buildx create</code></td><td>创建一个新的构建器实例</td></tr><tr><td><code>docker buildx use</code></td><td>设置当前使用的构建器</td></tr><tr><td><code>docker buildx inspect</code></td><td>查看构建器状态和支持的平台</td></tr><tr><td><code>docker buildx build</code></td><td>构建镜像（增强版），等同于 <code>docker build</code></td></tr><tr><td><code>docker buildx ls</code></td><td>列出所有构建器</td></tr><tr><td><code>docker buildx rm</code></td><td>删除构建器</td></tr><tr><td><code>docker buildx du</code></td><td>查看构建器使用的磁盘空间</td></tr><tr><td><code>docker buildx prune</code></td><td>删除构建过程中产生的缓存</td></tr><tr><td><code>docker buildx version</code></td><td>查看 Docker Buildx 的版本信息</td></tr></tbody></table><h2 id="要让Docker支持多平台构建，需要满足以下几个条件：">要让Docker支持多平台构建，需要满足以下几个条件：</h2><ul class="lvl-0"><li class="lvl-2"><p>Linux内核开启多处理器架构支持</p></li><li class="lvl-2"><p>构建时使用基于<code>docker-container</code>驱动的Buildx实例</p></li><li class="lvl-2"><p>使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>–platform</code>参数</p></li></ul><h2 id="Linux内核开启多处理器架构支持">Linux内核开启多处理器架构支持</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">default          docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启多处理器架构支持</span></span><br><span class="line">docker run --privileged --<span class="built_in">rm</span> tonistiigi/binfmt --install all</span><br><span class="line"><span class="comment"># 这个镜像用完就可以删除了</span></span><br><span class="line">docker rmi tonistiigi/binfmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次列出所有构建器</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，此时可以看到PLATFORMS中有多个平台</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">default*         docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br></pre></td></tr></table></figure><h2 id="构建时使用基于docker-container驱动的Buildx实例">构建时使用基于<code>docker-container</code>驱动的Buildx实例</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。</p></li><li class="lvl-2"><p>多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前默认的构建器default</span></span><br><span class="line">docker buildx inspect default</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Name:          default</span><br><span class="line">Driver:        docker</span><br><span class="line">Last Activity: 2025-06-06 07:42:42 +0000 UTC</span><br><span class="line"></span><br><span class="line">Nodes:</span><br><span class="line">Name:             default</span><br><span class="line">Endpoint:         default</span><br><span class="line">Status:           running</span><br><span class="line">BuildKit version: v0.13.2</span><br><span class="line">Platforms:        linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line">Labels:</span><br><span class="line"> org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建基于 <code>docker-container</code> 驱动的Buildx实例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并切换到名为mybuilder的构建器实例</span></span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container</span><br><span class="line"><span class="comment"># 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了</span></span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Name:          mybuilder</span><br><span class="line">Driver:        docker-container</span><br><span class="line">……………………………………</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除</span></span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID   IMAGE                           COMMAND                   CREATED             STATUS                       PORTS                    NAMES</span><br><span class="line">0ab9cab9ec9b   moby/buildkit:buildx-stable-1   <span class="string">&quot;buildkitd --allow-i…&quot;</span>   About an hour ago   Up About an hour                                      buildx_buildkit_mybuilder0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>buildx_buildkit_xxx</code>这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为<code>moby/buildkit:buildx-stable-1</code>，容器会在执行<code>docker buildx build</code> 或 <code>docker buildx inspect --bootstrap</code> 时启动</p></li></ul><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>👷 执行构建任务</td><td>真正执行 <code>buildx build</code> 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等</td></tr><tr><td>📦 拉取镜像</td><td>拉取 <code>Dockerfile</code> 中的基础镜像</td></tr><tr><td>📤 上传/导出镜像</td><td>支持导出为 <code>docker image</code>, <code>tar</code>, 推送到远程 registry</td></tr><tr><td>🪣 管理缓存</td><td>管理构建缓存（中间镜像、层等）以加速后续构建</td></tr><tr><td>🌍 支持多平台</td><td>通过 QEMU 或交叉编译器支持跨平台（如构建 <code>arm64</code> 镜像）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在<code>/etc/docker/daemon.json</code>中配置了国内的镜像源也不行，这是因为<code>docker buildx</code> 使用的是 BuildKit，它的行为不同于传统的 <code>docker build</code></p></li></ul><table><thead><tr><th>特性</th><th><code>docker build</code>（传统）</th><th><code>docker buildx</code>（BuildKit）</th></tr></thead><tbody><tr><td>是否使用本地镜像缓存</td><td>✅ 是</td><td>⚠️ <strong>不是</strong></td></tr><tr><td>是否需要联网拉取元数据（即使镜像已存在）</td><td>否</td><td>是</td></tr><tr><td>构建网络隔离</td><td>不隔离</td><td>隔离构建，无法直接访问宿主镜像缓存</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>解决方法为构建器配置镜像源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 BuildKit 配置文件 buildkitd.toml</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; buildkitd.toml</span></span><br><span class="line"><span class="string">[registry.&quot;docker.io&quot;]</span></span><br><span class="line"><span class="string">  mirrors = [&quot;https://docker.1ms.run&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[worker.oci]</span></span><br><span class="line"><span class="string">  gc = true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 BuildKit 构建器，并指定配置文件</span></span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果存在同名的构建器，则删除它后再创建</span></span><br><span class="line">docker buildx <span class="built_in">rm</span> mybuilder</span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构建器列表</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">mybuilder*       docker-container</span><br><span class="line"> \_ mybuilder0    \_ unix:///var/run/docker.sock   running   v0.21.1    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line">default          docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要切换回默认的构建器，请执行以下命令</span></span><br><span class="line">docker buildx use default</span><br></pre></td></tr></table></figure><h2 id="使用docker-buildx-build命令构建镜像，构建命令必须指定-platform参数">使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>--platform</code>参数</h2><h3 id="示例一：单阶段构建">示例一：单阶段构建</h3><ul class="lvl-0"><li class="lvl-2"><p>我们依旧以一个springboot项目为例，其Dockerfile如下：</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像元信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;yourname@example.com&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>开始构建镜像，<code>docker buildx build == docker build</code>，构建多平台架构时需要使用<code>--platform</code>指定构建平台</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --platform inux/arm64 :构建arm64镜像</span></span><br><span class="line"><span class="comment"># -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest</span></span><br><span class="line"><span class="comment"># --load :构建后加载到本地</span></span><br><span class="line"><span class="comment"># . :当前目录查找Dockerfile文件</span></span><br><span class="line"><span class="comment"># -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称</span></span><br><span class="line">docker buildx build --platform linux/arm64 -t <span class="string">&quot;app.arm64&quot;</span> --load .</span><br><span class="line"><span class="comment">## 此时会遇到如下错误</span></span><br><span class="line">ERROR: failed to solve: openjdk:17-alpine: failed to resolve <span class="built_in">source</span> metadata <span class="keyword">for</span> docker.io/library/openjdk:17-alpine: no match <span class="keyword">for</span> platform <span class="keyword">in</span> manifest: not found</span><br><span class="line"><span class="comment">## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询镜像支持的平台，不过国内依旧是不支持</span></span><br><span class="line">docker buildx imagetools inspect nginx:latest |  grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment"># 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/nginx:latest |  grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">  Platform:    linux/386</span><br><span class="line">  Platform:    linux/amd64</span><br><span class="line">  Platform:    linux/arm64/v8</span><br><span class="line">  Platform:    linux/arm/v5</span><br><span class="line">  Platform:    linux/arm/v7</span><br><span class="line">  Platform:    linux/mips64le</span><br><span class="line">  Platform:    linux/ppc64le</span><br><span class="line">  Platform:    linux/s390x</span><br><span class="line">  Platform:    unknown/unknown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着我们查看openjdk:17-alpine这个镜像</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果，其确实不支持 linux/arm64</span></span><br><span class="line">  Platform:  linux/amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们换一个openjdk镜像试试</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果，可以看到这个镜像同时支持amd64和arm64架构</span></span><br><span class="line">  Platform:  linux/amd64</span><br><span class="line">  Platform:  linux/arm64/v8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用skopeo容器的方式进行查询</span></span><br><span class="line">docker run --<span class="built_in">rm</span> quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r <span class="string">&#x27;.manifests[].platform | &quot;\(.os)/\(.architecture)/\(.variant)&quot;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | sed <span class="string">&#x27;s/\/null//&#x27;</span></span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">linux/amd64</span><br><span class="line">linux/arm64/v8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>替换支持多架构的镜像后重新构建镜像就会成功</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/arm64 -t <span class="string">&quot;app.arm64&quot;</span> --load .</span><br><span class="line">docker buildx build --platform linux/amd64 -t <span class="string">&quot;app.amd64&quot;</span> --load .</span><br><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class="line">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class="line">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构建后镜像的架构</span></span><br><span class="line">docker inspect app.amd64 | jq <span class="string">&#x27;.[0].Architecture&#x27;</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以将构建后的镜像输出到本地目录</span></span><br><span class="line">docker buildx build --platform linux/amd64 -t <span class="string">&quot;app.amd64&quot;</span> --output <span class="built_in">type</span>=docker,dest=./app.amd64.tar .</span><br><span class="line"><span class="comment"># 然后再将镜像导入到本地镜像仓库中</span></span><br><span class="line">docker load -i app.amd64.tar</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--load</code>和 <code>--output</code>都不支持一个镜像多种架构，要构建像<code>openjdk:17-slim</code>这种支持多架构的镜像可以使用<code>--push</code>，一步就推送到远程仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。</span></span><br><span class="line"><span class="comment"># 这里以推送到 docker hub 为例</span></span><br><span class="line"><span class="comment"># 登录 docker hup</span></span><br><span class="line">docker login -u hanqunfeng</span><br><span class="line"><span class="comment"># 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构</span></span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push .</span><br></pre></td></tr></table></figure><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/WdmJx0.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>镜像拉取</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像</span></span><br><span class="line">docker pull --platform=linux/arm64 hanqunfeng/app:latest</span><br></pre></td></tr></table></figure><h3 id="示例二：多阶段构建">示例二：多阶段构建</h3><ul class="lvl-0"><li class="lvl-2"><p>要求每个阶段中的基础镜像都要支持多架构</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：获取代码</span></span><br><span class="line"><span class="keyword">FROM</span> alpine/git AS fetcher</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class="line"><span class="keyword">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class="line"><span class="keyword">ARG</span> GIT_BRANCH=master</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> -b <span class="variable">$&#123;GIT_BRANCH&#125;</span> <span class="variable">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：使用Maven环境进行构建</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.8</span>.<span class="number">4</span>-openjdk-<span class="number">17</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 从第一阶段复制代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=fetcher /workspace/application .</span></span><br><span class="line"><span class="comment"># 使用Maven清理并打包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三阶段：创建最终的运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="comment"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class="line"><span class="comment"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多平台镜像并发布到dockerhub</span></span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push .</span><br></pre></td></tr></table></figure><h2 id="如何将构建好的多个单平台镜像发布为一个多平台镜像">如何将构建好的多个单平台镜像发布为一个多平台镜像</h2><ul class="lvl-0"><li class="lvl-2"><p>如果你已经分别构建好单平台镜像，也可以用 <code>docker buildx imagetools create</code> 来合并</p></li><li class="lvl-2"><p>以上面创建的两个单平台镜像为例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class="line">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class="line">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定要推送单平台镜像到远程仓库，否则无法完成合并</span></span><br><span class="line">docker tag app.amd64 hanqunfeng/app:amd64</span><br><span class="line">docker push hanqunfeng/app:amd64</span><br><span class="line"></span><br><span class="line">docker tag app.arm64 hanqunfeng/app:arm64</span><br><span class="line">docker push hanqunfeng/app:arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并，创建多平台镜像指向（manifest list）</span></span><br><span class="line">docker buildx imagetools create \</span><br><span class="line">  --tag hanqunfeng/app:latest \</span><br><span class="line">   hanqunfeng/app:amd64 \</span><br><span class="line">   hanqunfeng/app:arm64</span><br></pre></td></tr></table></figure><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/5azhzj.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>如果不需要单平台镜像，可以在dockerhub上删除即可。</p></li></ul><h2 id="移除-BuildKit（Buildx）构建过程中产生的缓存数据">移除 BuildKit（Buildx）构建过程中产生的缓存数据</h2><ul class="lvl-0"><li class="lvl-2"><p>BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。</p></li><li class="lvl-2"><p>可以通过该命令查看缓存占用磁盘空间的大小</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx <span class="built_in">du</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker buildx prune</code> 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。</p></li><li class="lvl-2"><p>命令语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx prune [OPTIONS]</span><br></pre></td></tr></table></figure><table><thead><tr><th>OPTIONS</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code>, <code>--all</code></td><td><strong>包括内部/前端镜像</strong>。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。</td></tr><tr><td><code>--builder string</code></td><td>指定使用哪个 builder 实例（可通过 <code>docker buildx ls</code> 查看当前有哪些 builder）。</td></tr><tr><td><code>--filter filter</code></td><td>设定清理条件，例如：<code>until=24h</code> 表示只删除 24 小时前的缓存。</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td><strong>不提示确认，直接执行清理操作</strong>。常用于脚本中。</td></tr><tr><td><code>--keep-storage bytes</code></td><td>保留指定大小的缓存空间，其余删除（如：<code>--keep-storage 5GB</code>）。</td></tr><tr><td><code>--verbose</code></td><td>输出更详细的清理信息。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未使用的缓存，并跳过确认提示</span></span><br><span class="line">docker buildx prune -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只删除 24 小时前的缓存，保留 10GB 的缓存空间</span></span><br><span class="line">docker buildx prune --filter <span class="string">&quot;until=24h&quot;</span> --keep-storage 10GB</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/build/building/multi-platform/&quot;&gt;Multi-platform builds&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 之 远程连接</title>
    <link href="https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/"/>
    <id>https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/</id>
    <published>2025-06-05T13:30:05.000Z</published>
    <updated>2025-06-06T06:03:47.970Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍如何远程连接Docker</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li></ul><span id="more"></span><h2 id="远程连接Docker有如下三种方式">远程连接Docker有如下三种方式</h2><h3 id="方式一：开启-TCP（不带-TLS，仅用于内网调试）">方式一：开启 TCP（不带 TLS，仅用于内网调试）</h3><ul class="lvl-0"><li class="lvl-2"><p>在docker服务端编辑 <code>/etc/docker/daemon.json</code>，加上：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;unix:///var/run/docker.sock&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tcp://0.0.0.0:2375&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时通过<code>sudo systemctl restart docker</code>重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 <code>-H fd://</code>，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 <code>-H fd://</code> 意思是：“不用自己打开 socket，去 systemd 那里拿吧。”</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.service</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br><span class="line"><span class="comment"># 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到  -H fd://</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 另外可以在与 docker.service 同目录下找到  docker.socket 文件，可以看到如下内容</span></span><br><span class="line">ListenStream=/run/docker.sock <span class="comment"># /run 目录是被软连接到 /var/run/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock</span></span><br><span class="line"><span class="comment"># 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了</span></span><br><span class="line"><span class="comment"># 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 docker</span></span><br><span class="line"><span class="built_in">sudo</span> dockerd --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://`</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一: 去掉 `-H fd://` 参数</span></span><br><span class="line"><span class="built_in">sudo</span> vi /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，</span></span><br><span class="line"><span class="comment"># 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。</span></span><br><span class="line"><span class="comment"># Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启 docker daemon</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端测试连接</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://远程IP:2375 ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端加入环境变量后就不需要每次都加上 -H 参数了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh 就换成 ~/.zshrc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=tcp://远程IP:2375&quot;</span>  &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>❗不要开启无认证的 <code>tcp://0.0.0.0:2375</code> 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。</p></li><li class="lvl-2"><p>✅ 推荐方式是：</p><ul class="lvl-2"><li class="lvl-6">使用 <code>tcp://0.0.0.0:2376 + --tlsverify</code></li><li class="lvl-6">或通过 <code>ssh:// 隧道</code> 访问 Docker</li></ul></li></ul><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">通过上面的介绍你应该搞明白一件事，就是我们可以不用在 <code>/etc/docker/daemon.json</code> 中配置远程连接，而是通过 systemd 来配置，即在 <code>/usr/lib/systemd/system/docker.service</code> 或者 <code>/etc/systemd/system/docker.service.d/override.conf</code>中配置。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">那么问题来了：既然 systemd 就能搞定一切，那还要 <code>/etc/docker/daemon.json</code> 有什么用？答案是：可读性、可维护性、工具兼容性更强。</li></ul><table><thead><tr><th>项目</th><th><code>daemon.json</code></th><th><code>systemd ExecStart</code></th></tr></thead><tbody><tr><td>语法</td><td>JSON</td><td>Shell 命令行</td></tr><tr><td>适合设置</td><td>Hosts、日志、registry、镜像驱动等</td><td>启动命令、资源限制等</td></tr><tr><td>可读性</td><td>👍 结构化</td><td>👎 较长、容易出错</td></tr><tr><td>自动化支持</td><td>👍 工具友好</td><td>👎 需要 patch systemd</td></tr></tbody></table></div><h3 id="方式二：开启-TCP-TLS-安全访问（推荐用于公网）">方式二：开启 TCP + TLS 安全访问（推荐用于公网）</h3><ul class="lvl-0"><li class="lvl-2"><p>创建 TLS 证书，通过一个脚本实现，脚本名称 <code>generate-docker-certs.sh</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">SERVER_IP=166.189.9.114  <span class="comment"># 🚨 修改为你的 Docker 服务器 IP 或域名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建 CA...&quot;</span></span><br><span class="line">openssl genrsa -out ca-key.pem 4096</span><br><span class="line">openssl req -new -x509 -days 365 \</span><br><span class="line">  -key ca-key.pem -subj <span class="string">&quot;/CN=docker-ca&quot;</span> -out ca.pem</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建服务器私钥...&quot;</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建 OpenSSL 配置文件...&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extfile.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[req]</span></span><br><span class="line"><span class="string">distinguished_name = req_distinguished_name</span></span><br><span class="line"><span class="string">x509_extensions = v3_req</span></span><br><span class="line"><span class="string">prompt = no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[req_distinguished_name]</span></span><br><span class="line"><span class="string">CN = $&#123;SERVER_IP&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[v3_req]</span></span><br><span class="line"><span class="string">keyUsage = keyEncipherment, dataEncipherment</span></span><br><span class="line"><span class="string">extendedKeyUsage = serverAuth</span></span><br><span class="line"><span class="string">subjectAltName = @alt_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[alt_names]</span></span><br><span class="line"><span class="string">IP.1 = $&#123;SERVER_IP&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建服务器证书签名请求 (CSR)...&quot;</span></span><br><span class="line">openssl req -new -key server-key.pem \</span><br><span class="line">  -out server.csr -config extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 签发服务器证书...&quot;</span></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr \</span><br><span class="line">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">  -out server-cert.pem -extensions v3_req -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建客户端私钥...&quot;</span></span><br><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建客户端 CSR...&quot;</span></span><br><span class="line">openssl req -new -key key.pem -subj <span class="string">&quot;/CN=client&quot;</span> -out client.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 签发客户端证书...&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &gt; client-ext.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">extendedKeyUsage = clientAuth</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> client.csr \</span><br><span class="line">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">  -out cert.pem -extfile client-ext.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[✓] 所有证书生成完成！&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; 服务器证书: server-cert.pem, server-key.pem&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; 客户端证书: cert.pem, key.pem&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; CA根证书:   ca.pem&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>执行脚本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x generate-docker-certs.sh</span><br><span class="line">./generate-docker-certs.sh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将以下证书文件部署到docker服务端</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端：server-cert.pem, server-key.pem, ca.pem</span></span><br><span class="line"><span class="built_in">cp</span> server-cert.pem /etc/docker/server-cert.pem</span><br><span class="line"><span class="built_in">cp</span> server-key.pem /etc/docker/server-key.pem</span><br><span class="line"><span class="built_in">cp</span> ca.pem /etc/docker/ca.pem</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将以下证书文件部署到docker客户端</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cert.pem, key.pem, ca.pem</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在docker服务端编辑 <code>/etc/docker/daemon.json</code></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;unix:///var/run/docker.sock&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tcp://0.0.0.0:2376&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlsverify&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlscacert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/ca.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlscert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/server-cert.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlskey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/server-key.pem&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启 docker daemon</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端测试连接</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker \</span><br><span class="line">  --tlsverify \</span><br><span class="line">  --tlscacert=ca.pem \</span><br><span class="line">  --tlscert=cert.pem \</span><br><span class="line">  --tlskey=key.pem \</span><br><span class="line">  -H tcp://166.189.9.114:2376 \</span><br><span class="line">  ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="string"># 远程Docker IP和端口</span></span><br><span class="line"><span class="string">export DOCKER_HOST=tcp://166.189.9.114:2376</span></span><br><span class="line"><span class="string"># 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverify</span></span><br><span class="line"><span class="string">export DOCKER_TLS_VERIFY=1</span></span><br><span class="line"><span class="string"># 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pem</span></span><br><span class="line"><span class="string">export DOCKER_CERT_PATH=/path/to/certs</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="方式三：ssh-隧道访问">方式三：ssh:// 隧道访问</h3><ul class="lvl-0"><li class="lvl-2"><p>最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 <span class="string">&quot;docker ps&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>基于免密认证，如何配置免密登录可以参考 <a href="/2023/02/28/linux-command02-ssh/" title="Linux常用命令--ssh、scp与免密登录">Linux常用命令--ssh、scp与免密登录</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22</span></span><br><span class="line"><span class="comment"># 要求登录用户必须拥有docker的运行权限（加入 docker group）</span></span><br><span class="line">docker -H ssh://centos@166.189.9.114 ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>基于<code>config</code>配置(推荐)</p><ul class="lvl-2"><li class="lvl-6">这种方式的优点是可以配置证书和端口</li><li class="lvl-6">在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group）</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host mydocker</span><br><span class="line">HostName 166.189.9.114</span><br><span class="line">User centos</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile ~/.ssh/my_docker_key</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">测试</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H ssh://mydocker ps</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>添加环境变量避免每次都加上 <code>-H</code> 参数</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 基于免密认证</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=ssh://user@host&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment">## 或者基于config的方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=ssh://mydocker&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="docker-context-同时连接多个远程docker"><code>docker context</code>: 同时连接多个远程docker</h2><ul class="lvl-0"><li class="lvl-2"><p>上面介绍的三种方式，为了简化连接，都加上了<code>DOCKER_HOST</code>环境变量，但是<code>DOCKER_HOST</code>只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换<code>DOCKER_HOST</code>环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 <code>context</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP</span></span><br><span class="line">docker context create remote-tcp \</span><br><span class="line">    --docker <span class="string">&quot;host=tcp://166.189.9.114:2375&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP + TLS</span></span><br><span class="line">docker context create remote-tls \</span><br><span class="line">  --docker <span class="string">&quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh隧道</span></span><br><span class="line">docker context create remote-ssh --docker <span class="string">&quot;host=ssh://mydocker&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">docker context <span class="built_in">ls</span> <span class="comment"># 列出所有context</span></span><br><span class="line">docker context use remote-ssh <span class="comment"># 切换到指定的context</span></span><br><span class="line">docker ps <span class="comment"># 查看容器</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker context</code> 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如：</p><ul class="lvl-2"><li class="lvl-6">本地 Docker（默认）</li><li class="lvl-6">远程主机的 Docker（通过 SSH 或 TCP/TLS）</li><li class="lvl-6">Docker Desktop</li><li class="lvl-6">Docker Swarm 或 Kubernetes（部分支持）</li></ul></li><li class="lvl-2"><p>就像你用 <code>kubectl config use-context</code> 切换 Kubernetes 集群，<code>docker context</code> 也允许你在多个 Docker 后端之间切换，而无需反复设置 <code>DOCKER_HOST</code> 环境变量或写繁琐的 SSH 隧道命令。</p></li><li class="lvl-2"><p>常用命令一览</p></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker context ls</code></td><td>列出所有上下文</td></tr><tr><td><code>docker context use &lt;name&gt;</code></td><td>切换到指定 context</td></tr><tr><td><code>docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td><td>创建一个新的 context</td></tr><tr><td><code>docker context rm &lt;name&gt;</code></td><td>删除 context</td></tr><tr><td><code>docker context inspect &lt;name&gt;</code></td><td>查看 context 详情</td></tr><tr><td><code>docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td><td>更新 context 参数（Docker 24+ 支持）</td></tr><tr><td><code>docker context show</code></td><td>显示当前 context</td></tr><tr><td><code>docker context export &lt;name&gt; &lt;file.tar&gt;</code></td><td>导出 context 到tar文件</td></tr><tr><td><code>docker context import &lt;name&gt; &lt;file.tar&gt;</code></td><td>导入 context 从tar文件</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Docker endpoint config</p></li></ul><table><thead><tr><th>参数名</th><th>中文描述</th></tr></thead><tbody><tr><td><code>from</code></td><td>复制指定 context 名称 的 Docker 端点配置</td></tr><tr><td><code>host</code></td><td>要连接的 Docker 端点地址</td></tr><tr><td><code>ca</code></td><td>CA 签名的证书的路径</td></tr><tr><td><code>cert</code></td><td>TLS 证书文件的路径</td></tr><tr><td><code>key</code></td><td>TLS 密钥文件的路径</td></tr><tr><td><code>skip-tls-verify</code></td><td>跳过 TLS 证书验证（⚠️ 不建议用于生产环境）</td></tr></tbody></table><h2 id="三种远程连接-Docker-的方式及其优缺点总结">三种远程连接 Docker 的方式及其优缺点总结</h2><table><thead><tr><th>连接方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>1. SSH 方式 (<code>ssh://</code>)</strong></td><td>- 配置简单，无需额外开启 Docker TCP 端口和 TLS<br>- 安全性高，基于 SSH 加密和认证<br>- 不用开放额外端口，防火墙友好<br>- 易于用 SSH 代理和密钥管理</td><td>- 需要远程用户有 Docker 权限（如属于 <code>docker</code> 组）<br>- 连接速度可能受 SSH 连接影响<br>- 需要在本地安装并配置 SSH</td><td>开发环境、内网管理、小规模远程操作</td></tr><tr><td><strong>2. TCP + TLS 方式</strong></td><td>- 标准的远程 Docker API 访问<br>- 支持证书认证，安全性高<br>- 可以配置多个客户端和权限控制<br>- 适合自动化脚本、CI/CD 访问</td><td>- 配置较复杂，需要生成和管理 CA、服务器和客户端证书<br>- 需要开放 TCP 端口（如 2376），增加安全风险<br>- 证书配置错误容易导致连接失败</td><td>生产环境、自动化集成、需要高安全认证</td></tr><tr><td><strong>3. TCP 明文访问（无 TLS）</strong></td><td>- 配置最简单，只需监听 TCP 端口<br>- 方便快速测试和调试</td><td>- 极度不安全，数据明文传输<br>- 任何人都可访问 Docker API，极易被攻击<br>- 生产环境严重不建议使用</td><td>仅限局域网内测试或极简环境</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍如何远程连接Docker&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 docker compose</title>
    <link href="https://blog.hanqunfeng.com/2025/06/04/docker-compose/"/>
    <id>https://blog.hanqunfeng.com/2025/06/04/docker-compose/</id>
    <published>2025-06-04T13:30:05.000Z</published>
    <updated>2025-06-28T04:27:36.761Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 <code>docker compose</code> 的使用方法</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/compose/">docker compose</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p></li></ul><span id="more"></span><h2 id="docker-compose-是什么？"><code>docker compose</code> 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker Compose是一个用于定义和运行多容器应用程序的工具。</p></li><li class="lvl-2"><p>Compose简化了对整个应用程序堆栈的控制，便于在单个YAML配置文件中管理服务、网络和卷。然后，通过一个命令，您从配置文件中创建并启动所有服务。</p></li><li class="lvl-2"><p>Docker Compose 的优势：</p></li></ul><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>简化控制</td><td>Docker Compose 允许在单个 YAML 文件中定义和管理多容器应用程序，简化了服务编排与协调，使环境管理和复制更容易。</td></tr><tr><td>高效的协作</td><td>配置文件易于共享，促进开发人员、运营团队和其他利益相关者之间的协作，从而提升工作流程效率和问题解决速度。</td></tr><tr><td>快速应用程序开发</td><td>Compose 利用缓存重复使用未更改服务的容器，加快环境变更速度，提高开发效率。</td></tr><tr><td>跨环境的可移植性</td><td>支持在 Compose 文件中使用变量，使配置能根据不同环境或用户进行自定义，增强了可移植性。</td></tr><tr><td>广泛的社区和支持</td><td>拥有活跃的社区，提供丰富的资源、教程和技术支持，有助于持续改进与高效排障。</td></tr></tbody></table><h2 id="docker-compose-安装"><code>docker compose</code> 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>同docker一起安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装docker同时安装docker compose，这里 docker-compose-plugin 就是docker compose</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>单独安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若安装docker时没有安装 docker-compose-plugin ，则需要单独安装</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install docker-compose-plugin -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看版本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose version</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>直接下载docker-compose的命令文件</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`</span></span><br><span class="line"><span class="built_in">sudo</span> curl -L <span class="string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment"># Make the docker-compose command available</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment"># Check Docker Compose version</span></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure></div><h2 id="docker-compose-命令"><code>docker compose</code> 命令</h2><table><thead><tr><th>命令</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td>attach</td><td>连接到服务的运行中容器的标准输入、输出和错误流</td><td><code>docker compose attach web</code></td></tr><tr><td>build</td><td>构建或重新构建服务</td><td><code>docker compose build</code></td></tr><tr><td>config</td><td>解析并标准化 Compose 文件</td><td><code>docker compose config</code></td></tr><tr><td>cp</td><td>在服务容器与本地文件系统之间复制文件/文件夹</td><td><code>docker compose cp web:/app/file.txt ./file.txt</code></td></tr><tr><td>create</td><td>为服务创建容器，但不启动</td><td><code>docker compose create</code></td></tr><tr><td>down</td><td>停止并移除容器、网络等资源</td><td><code>docker compose down</code></td></tr><tr><td>events</td><td>实时接收容器事件</td><td><code>docker compose events</code></td></tr><tr><td>exec</td><td>在运行中的容器中执行命令</td><td><code>docker compose exec web ls /app</code></td></tr><tr><td>images</td><td>列出已创建容器所使用的镜像</td><td><code>docker compose images</code></td></tr><tr><td>kill</td><td>强制停止服务容器</td><td><code>docker compose kill</code></td></tr><tr><td>logs</td><td>查看服务容器的日志输出</td><td><code>docker compose logs</code></td></tr><tr><td>ls</td><td>列出当前运行的 Compose 项目</td><td><code>docker compose ls</code></td></tr><tr><td>pause</td><td>暂停服务容器</td><td><code>docker compose pause</code></td></tr><tr><td>port</td><td>显示某端口映射的公网地址</td><td><code>docker compose port web 80</code></td></tr><tr><td>ps</td><td>列出服务的容器</td><td><code>docker compose ps</code></td></tr><tr><td>pull</td><td>拉取服务使用的镜像</td><td><code>docker compose pull</code></td></tr><tr><td>push</td><td>推送服务镜像到仓库</td><td><code>docker compose push</code></td></tr><tr><td>restart</td><td>重启服务容器</td><td><code>docker compose restart</code></td></tr><tr><td>rm</td><td>移除已停止的服务容器</td><td><code>docker compose rm</code></td></tr><tr><td>run</td><td>在服务上运行一次性命令</td><td><code>docker compose run web echo Hello</code></td></tr><tr><td>scale</td><td>扩展服务实例数量</td><td><code>docker compose up --scale web=3</code></td></tr><tr><td>start</td><td>启动已存在但已停止的服务容器</td><td><code>docker compose start</code></td></tr><tr><td>stats</td><td>实时显示容器资源使用情况</td><td><code>docker compose stats</code></td></tr><tr><td>stop</td><td>停止运行中的服务容器</td><td><code>docker compose stop</code></td></tr><tr><td>top</td><td>显示容器内的运行进程</td><td><code>docker compose top</code></td></tr><tr><td>unpause</td><td>取消暂停服务容器</td><td><code>docker compose unpause</code></td></tr><tr><td>up</td><td>创建并启动服务容器</td><td><code>docker compose up</code></td></tr><tr><td>version</td><td>显示 Docker Compose 版本信息</td><td><code>docker compose version</code></td></tr><tr><td>wait</td><td>阻塞直到第一个服务容器停止</td><td><code>docker compose wait</code></td></tr><tr><td>watch</td><td>监听服务构建上下文变更并重新构建/刷新容器</td><td><code>docker compose watch</code></td></tr></tbody></table><h3 id="docker-compose-常用命令"><code>docker compose</code> 常用命令</h3><ul class="lvl-0"><li class="lvl-2"><p>启动与关闭</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动并运行，默认使用当前目录的 docker-compose.yml 文件</span></span><br><span class="line">docker compose up</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 指定compose文件</span></span><br><span class="line">docker compose -f docker-compose.yml up -d</span><br><span class="line"><span class="comment"># 启动时重建服务，当修改了 compose 文件时</span></span><br><span class="line">docker compose up --build</span><br><span class="line"><span class="comment"># 停止service</span></span><br><span class="line">docker compose stop</span><br><span class="line"><span class="comment"># 强制停止service，当 stop 命令无法停止时</span></span><br><span class="line">docker compose <span class="built_in">kill</span></span><br><span class="line"><span class="comment"># 重启service</span></span><br><span class="line">docker compose restart</span><br><span class="line"><span class="comment"># 删除service，-s 参数表示删除前先停止容器</span></span><br><span class="line">docker compose <span class="built_in">rm</span> -s</span><br><span class="line"><span class="comment"># 停止并删除service，同时删除网络，但不会删除卷</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>监控</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前运行的 Compose 项目</span></span><br><span class="line">docker compose <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 查看service状态，-a 显示所有service</span></span><br><span class="line">docker compose ps -a</span><br><span class="line"><span class="comment"># 解析并标准化 compose 文件，这个命令可以检查 docker-compose.yml 文件语法是否正确，但不保证逻辑正确</span></span><br><span class="line">docker compose config</span><br><span class="line"><span class="comment"># 查看使用的镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">docker compose top</span><br><span class="line"><span class="comment"># 查看service资源使用情况</span></span><br><span class="line">docker compose stats</span><br><span class="line"><span class="comment"># 查看service日志，-f 表示持续跟踪</span></span><br><span class="line">docker compose logs -f</span><br><span class="line"><span class="comment"># 查看指定service的日志</span></span><br><span class="line">docker compose logs -f service_name</span><br><span class="line"><span class="comment"># 进入指定的service容器</span></span><br><span class="line">docker compose <span class="built_in">exec</span> service_name bash</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>升级镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止所有service</span></span><br><span class="line">docker compose down</span><br><span class="line"><span class="comment"># 拉取最新镜像</span></span><br><span class="line">docker compose pull</span><br><span class="line"><span class="comment"># 启动service</span></span><br><span class="line">docker compose up -d --build</span><br></pre></td></tr></table></figure><h2 id="docker-compose-yml-的语法"><code>docker-compose.yml</code> 的语法</h2><ul class="lvl-0"><li class="lvl-2"><p>常用指令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span> <span class="comment"># 定义版本，表示当前使用的 docker compose 语法的版本，已过时 ，新版 Docker 会使用最新的 Compose Specification 自动解析</span></span><br><span class="line">name: <span class="string">&quot;project_name&quot;</span> <span class="comment">#  项目名，默认 docker-compose.yml 文件所在的目录名，不推荐设置</span></span><br><span class="line">services: <span class="comment"># 服务列表</span></span><br><span class="line">  servicename: <span class="comment"># 服务名字，只能包含小写字母、数字、下划线、中划线，必须以字母或数字开头</span></span><br><span class="line">    build: <span class="comment"># 基于Dockerfile构建目录，如果同时设置了 image 选项，则image指定的就是构建后的镜像名称</span></span><br><span class="line">    image: <span class="comment"># 镜像的名字，默认从远程仓库拉取，如果配置了 build 选项，则image指定的就是构建后的镜像名称</span></span><br><span class="line">    <span class="built_in">command</span>: <span class="comment"># 可选，如果设置，则会覆盖默认镜像里的 CMD 命令</span></span><br><span class="line">    environment: <span class="comment"># 可选，等价于 docker container run 里的 --env 选项设置环境变量</span></span><br><span class="line">    volumes: <span class="comment"># 可选，等价于 docker container run 里的 -v 选项 绑定数据卷</span></span><br><span class="line">    networks: <span class="comment"># 可选，等价于 docker container run 里的 --network 选项指定网络</span></span><br><span class="line">    ports: <span class="comment"># 可选，等价于 docker container run 里的 -p 选项指定端口映射</span></span><br><span class="line">    expose: <span class="comment"># 可选，指定容器暴露的端口</span></span><br><span class="line">    depends_on: <span class="comment"># 服务依赖的其它服务</span></span><br><span class="line">    env_file: <span class="comment"># 环境变量文件，生产环境更推荐这种方式</span></span><br><span class="line">  servicename2:</span><br><span class="line">    image:</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    networks:</span><br><span class="line">    ports:</span><br><span class="line">  servicename3:</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">volumes: <span class="comment"># 可选，等价于 docker volume create</span></span><br><span class="line">networks: <span class="comment"># 可选，等价于 docker network create</span></span><br></pre></td></tr></table></figure><h3 id="volumes">volumes</h3><ul class="lvl-0"><li class="lvl-2"><p>卷是由容器引擎实现的持久数据存储。Compose 为服务提供了一种中立的挂载卷的方式，并通过配置参数将卷分配给基础架构。顶级volumes声明允许您配置可在多个服务之间重复使用的命名卷。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/database</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 挂载卷映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/etc/data</span> <span class="comment"># 挂载到容器的/etc/data目录</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">backup:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">backup-service</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/backup/data</span> <span class="comment"># 一个卷可以被多个服务使用</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 存储卷配置</span></span><br><span class="line">  <span class="attr">db-data:</span>  <span class="comment"># 创建一个名为db-data的卷，实际的网络名称是 容器组名称_这里的名称</span></span><br></pre></td></tr></table></figure><h4 id="volumes-的属性">volumes 的属性</h4><ul class="lvl-0"><li class="lvl-2"><p>driver: 卷类型，默认为local，指定应使用哪个卷驱动程序。如果该驱动程序不可用，Compose 将返回错误并且不会部署该应用程序。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span> <span class="comment"># 声明一个名为db-data的卷</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span> <span class="comment"># 指定卷类型，这个是默认值，可以不配置</span></span><br><span class="line">  <span class="attr">db-data2:</span> <span class="comment"># 声明一个名为db-data2的卷，这是最简单的 volumes 配置</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>driver_opts: 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line">    <span class="attr">driver_opts:</span> <span class="comment"># 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">&quot;nfs&quot;</span> <span class="comment"># 卷类型，指定应使用哪个卷驱动程序，这里是nfs</span></span><br><span class="line">      <span class="attr">o:</span> <span class="string">&quot;addr=10.40.0.199,nolock,soft,rw&quot;</span> <span class="comment"># nfs参数，addr为nfs服务器地址，nolock为不锁定文件，soft为软链接，rw为读写权限</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">&quot;:/docker/example&quot;</span> <span class="comment"># nfs挂载路径</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>external: 卷是否为外部卷，默认为false</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span> <span class="comment"># true 表示不会创建，而是使用已存在的，即会去volumes中查找(docker volume ls) 容器组名称_da-data ，默认为false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>name: 卷的名称，默认为 容器组名称_声明的名称</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db-data</span> <span class="comment"># 创建一个名为db-data的卷，实际的卷名称就是 db-data，不会再加上容器组名称前缀</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span> <span class="comment"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>labels: 用于向卷添加元数据，可以添加任意的键值对</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">com.example.description:</span> <span class="string">&quot;Database volume&quot;</span></span><br><span class="line">      <span class="attr">com.example.department:</span> <span class="string">&quot;IT/Ops&quot;</span></span><br><span class="line">      <span class="attr">com.example.label-with-empty-value:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="networks">networks</h3><ul class="lvl-0"><li class="lvl-2"><p>网络使服务能够相互通信。默认情况下，Compose 会为您的应用设置单个网络。服务的每个容器都会加入默认网络，并且该网络上的其他容器都可以访问，并且可以通过服务名称发现。顶级networks元素允许您配置可在多个服务之间重复使用的命名网络。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">networks:</span>  <span class="comment">#  网络映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">front-tier</span> <span class="comment">#  加入front-tier网络</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">back-tier</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span>    <span class="comment"># 网络配置</span></span><br><span class="line">  <span class="attr">front-tier:</span> <span class="comment"># 创建一个名为front-tier的网络，实际的网络名称是 容器组名称_front-tier</span></span><br><span class="line">  <span class="attr">back-tier:</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果 Compose 文件未显式声明网络，Compose 将使用隐式default网络。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个例子实际上等同于：</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span> &#123;&#125;</span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="networks-的属性">networks 的属性</h4><ul class="lvl-0"><li class="lvl-2"><p>driver: 网络类型，默认为bridge</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>driver_opts: 网络类型参数，指定要传递给此网络驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">driver_opts:</span></span><br><span class="line">      <span class="attr">com.docker.network.bridge.host_binding_ipv4:</span> <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment"># 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地）</span></span><br></pre></td></tr></table></figure><blockquote><p>driver_opts 常见配置项（针对 bridge 网络驱动）</p></blockquote><table><thead><tr><th>选项键名（<code>driver_opts</code>）</th><th>说明</th></tr></thead><tbody><tr><td><code>com.docker.network.bridge.name</code></td><td>指定桥接网络的名称（默认是随机生成，如 <code>br-xxxxx</code>）</td></tr><tr><td><code>com.docker.network.bridge.enable_icc</code></td><td>是否允许容器之间的通信（<code>true</code> 或 <code>false</code>）</td></tr><tr><td><code>com.docker.network.bridge.enable_ip_masquerade</code></td><td>是否启用 IP 假冒（NAT，通常用于外网访问）</td></tr><tr><td><code>com.docker.network.bridge.host_binding_ipv4</code></td><td>设置容器端口绑定到主机的哪个 IP（如 <code>&quot;127.0.0.1&quot;</code>，绑定到本地）</td></tr><tr><td><code>com.docker.network.bridge.default_bridge</code></td><td>是否将该网络设置为默认 bridge 网络（<code>true</code> 或 <code>false</code>）</td></tr><tr><td><code>com.docker.network.driver.mtu</code></td><td>设置网络的最大传输单元（MTU，例如 <code>&quot;1500&quot;</code>）</td></tr><tr><td><code>com.docker.network.bridge.allow_non_default_bridge</code></td><td>是否允许容器加入非默认的 bridge 网络（较少使用）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>attachable: 如果为true，则允许将其它独立容器也加入到此网络。默认值为false。如果独立容器连接到此网络，它可以与同样连接到此网络的服务和其他独立容器进行通信。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">attachable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>external: true 表示不会创建新的网络，回去networks中查找（docker network ls），默认为false</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>name: 网络名称，不会再加上容器组名称前缀</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span> <span class="comment"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>labels: 用于向网络添加元数据，可以添加任意的键值对</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mynet1:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">com.example.description:</span> <span class="string">&quot;Financial transaction network&quot;</span></span><br><span class="line">      <span class="attr">com.example.department:</span> <span class="string">&quot;Finance&quot;</span></span><br><span class="line">      <span class="attr">com.example.label-with-empty-value:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>internal: 默认情况下，Compose 提供网络的外部连接。internal当设置为 时true，可让您创建与外部隔离的网络。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">internal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="services">services</h3><ul class="lvl-0"><li class="lvl-2"><p>服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展或替换。服务由一组容器支持，由平台根据复制要求和布局约束运行。由于服务由容器支持，因此它们由 Docker 镜像和一组运行时参数定义。服务中的所有容器都使用这些参数以相同的方式创建。</p></li><li class="lvl-2"><p>service 包含的属性非常多，具体请参考<a href="https://docs.docker.com/reference/compose-file/services/">services顶级元素</a>，这里只介绍比较常用的属性，</p></li><li class="lvl-2"><p>这里以<a href="https://docs.gitea.com/installation/install-with-docker">Gitea</a>的<code>docker-compose.yml</code>为例</p></li></ul><blockquote><p>Gitea 是一种轻松、自托管的一体化软件开发服务。它包括 Git 托管、代码审查、团队协作、包注册表和 CI/CD。它类似于 GitHub、Bitbucket 和 GitLab。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version: &#x27;3.8&#x27; # 配置文件版本，已过时，配置上会告警但不会报错</span></span><br><span class="line"><span class="comment"># name: gitea # 容器组名称，默认使用所在目录的名称，不推荐使用</span></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 网络配置</span></span><br><span class="line">  <span class="attr">gitea:</span> <span class="comment"># 创建一个名为gitea的网络，实际的网络名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span> <span class="comment"># 如果为true，则表示此网络不会由compose创建，而是使用已有的网络，默认为false</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span>  <span class="comment"># 网络类型，默认为bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 存储卷配置</span></span><br><span class="line">  <span class="attr">gitea:</span> <span class="comment"># 创建一个名为gitea的存储卷，实际的卷名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span> <span class="comment"># 存储卷类型，默认为local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 服务配置，这里可以定义一组容器</span></span><br><span class="line">  <span class="attr">server:</span> <span class="comment"># 定义一个名为server的服务，注意这个不是容器名称</span></span><br><span class="line">    <span class="comment"># build: . # 构建镜像，使用当前目录下的Dockerfile</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:latest</span> <span class="comment"># 镜像名称</span></span><br><span class="line">    <span class="comment"># container_name: gitea #  容器名称，默认为 “容器组名称-服务名称-索引”，不推荐配置，因为 水平扩展(--scale) 时,容器名称不能重复</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 定义环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1000</span> <span class="comment"># key=value</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_TYPE=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=db:3306</span> <span class="comment"># 这里配置的 db 就是 下面的服务名称，相同 network 下的服务名称，docker compose会自动解析为容器的ip地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASSWD=gitea</span></span><br><span class="line">    <span class="comment"># env_file: .gitea.env # 从 .gitea.env 文件读取环境变量，生产环境更推荐</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 容器启动时，自动重启</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 网络关联</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span> <span class="comment"># 网络名称，就是上面创建的gitea网络</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#  数据卷关联</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea:/data</span> <span class="comment"># volume映射，数据卷名称:/容器路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span> <span class="comment"># 路径映射，宿主机路径:/容器路径:读写权限</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span> <span class="comment"># 宿主机端口:容器端口</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="comment"># 启动依赖，就是依赖的服务启动后才能启动本服务</span></span><br><span class="line">      <span class="attr">db:</span> <span class="comment"># 启动db服务</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span> <span class="comment"># 服务通过健康检查，也可以配置为 service_started：服务启动，这个是默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span> <span class="comment"># 数据库服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8</span> <span class="comment"># 镜像</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=gitea</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 启动策略</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 网络映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span> <span class="comment"># 映射到gitea网络</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 卷映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql:/var/lib/mysql</span> <span class="comment"># 宿主机路径:/容器路径，这里宿主机支持相对路径</span></span><br><span class="line">    <span class="attr">healthcheck:</span> <span class="comment"># 健康检查</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;mysql -u root -pgitea&quot;</span>, <span class="string">&quot;-e &#x27;SELECT 1;&#x27;&quot;</span>] <span class="comment"># 执行命令，如果返回0，则健康检查通过，这里不支持上面的环境变量，test只支持  CMD-SHELL 和 CMD</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span> <span class="comment"># 健康检查间隔</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span> <span class="comment"># 健康检查超时时间</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 健康检查重试次数</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>build</code>: 构建镜像</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span> <span class="comment"># Dockerfile的目录，“.” 表示使用当前目录下的Dockerfile</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span> <span class="comment"># 镜像名称，如果有build，则该名称就是build后的镜像名称，如果没有build，则就会从远程仓库拉取</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./webapp</span> <span class="comment"># Dockerfile的目录，默认是当前目录</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span> <span class="comment"># 构建镜像的Dockerfile名称，默认是Dockerfile</span></span><br><span class="line">      <span class="attr">platforms:</span> <span class="comment"># 构建镜像的架构</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">linux/amd64</span> <span class="comment"># 构建镜像的架构，默认是当前架构</span></span><br><span class="line">      <span class="attr">args:</span> <span class="comment"># 构建镜像的参数</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">FOO=bar</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 构建镜像的标签</span></span><br><span class="line">        <span class="attr">com.example.description:</span> <span class="string">&quot;Accounting webapp&quot;</span></span><br><span class="line">        <span class="attr">com.example.department:</span> <span class="string">&quot;Finance&quot;</span></span><br><span class="line">        <span class="attr">com.example.label-with-empty-value:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>command</code>: 覆盖容器映像声明的默认命令</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>entrypoint</code>: 声明服务容器的默认入口点，这覆盖了服务Dockerfile中的ENTRYPOINT指令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">entrypoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">php</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">memory_limit=-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vendor/bin/phpunit</span></span><br><span class="line">      <span class="comment"># 如果值为null，则使用图像的默认入口点。 entrypoint: null</span></span><br><span class="line">      <span class="comment"># 如果值是 []（空列表）或 &#x27;&#x27;（空字符串），图像声明的默认入口点被忽略，或者换句话说，被覆盖为空。 entrypoint: []</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>depends_on</code>: 服务启动依赖，就是依赖的服务启动后才能启动本服务</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span> <span class="comment"># 短语法</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">db:</span>  <span class="comment"># 长语法</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span> <span class="comment"># 满足的条件</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="literal">true</span>      <span class="comment"># 当设置为true，Compose在更新依赖服务后重新启动此服务。</span></span><br><span class="line">      <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_started</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## condition：设置依赖性被视为满足的条件</span></span><br><span class="line"><span class="comment">#   service_started：相当于之前描述的简短语法</span></span><br><span class="line"><span class="comment">#   service_healthy：指定在启动依赖服务之前，依赖预期为“健康”（如healthcheck所示）。</span></span><br><span class="line"><span class="comment">#   service_completed_successfully：指定在启动依赖服务之前，依赖项预计将运行到成功完成。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>environment</code>: 定义环境变量</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FOO=bar</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">BAZ=qux</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">FOO:</span> <span class="string">bar</span></span><br><span class="line">      <span class="attr">BAZ:</span> <span class="string">qux</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>env_file</code>: 用于指定一个或多个包含要传递到容器的环境变量的文件。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./a.env</span> <span class="comment"># 列表中的文件是从上到下处理的。对于两个环境文件中指定的相同变量，列表中最后一个文件的值是有效的。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./b.env</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">./default.env</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span> <span class="comment"># default</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">./override.env</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">false</span> <span class="comment"># 当required设置为false且.env文件缺失时，Compose会忽略</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>restart</code>: 定义平台在容器终止时适用的策略</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&quot;no&quot;</span>            <span class="comment"># 默认重启策略。在任何情况下，它都不会重新启动容器。</span></span><br><span class="line">    <span class="comment"># restart: always        # 策略总是重新启动容器，直到它被移除。</span></span><br><span class="line">    <span class="comment"># restart: on-failure    # 如果退出代码表明错误，策略将重新启动容器。</span></span><br><span class="line">    <span class="comment"># restart: on-failure:3  # 如果退出代码表明错误，策略将重新启动容器。但仅尝试重启3次。</span></span><br><span class="line">    <span class="comment"># restart: unless-stopped # 无论退出代码如何，策略都会重新启动容器，但当服务停止或删除时，策略会停止重新启动。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>healthcheck</code>: 健康检查。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/webapp</span></span><br><span class="line">    <span class="attr">healthcheck:</span>  <span class="comment"># 健康检查</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>] <span class="comment"># 监控检查时执行的命令</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1m30s</span> <span class="comment"># 健康检查的间隔，默认值为 30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span>    <span class="comment">#  健康检查的超时时间，默认值为 30s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span>      <span class="comment"># 健康检查的尝试次数，默认值为 3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span> <span class="comment"># 启动宽限期：在此期间，失败不会计入重试次数（仅用于判断服务是否启动完毕）</span></span><br><span class="line">      <span class="attr">start_interval:</span> <span class="string">5s</span> <span class="comment"># 启动宽限期内检查的频率，本示例为在前 40 秒内每 5 秒检查一次</span></span><br></pre></td></tr></table></figure><blockquote><p>test定义Compose运行的命令来检查容器运行状况。它可以是字符串，也可以是列表。如果是列表，第一个项目必须是NONE、CMD或CMD-SHELL。如果它是一个字符串，它等同于指定CMD-SHELL后跟该字符串。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line"><span class="comment"># 使用CMD-SHELL运行配置为字符串的命令，使用容器的默认外壳（Linux的/bin/sh）。以下两种形式是等价的</span></span><br><span class="line"><span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;curl -f http://localhost || exit 1&quot;</span>]</span><br><span class="line"><span class="attr">test:</span> <span class="string">curl</span> <span class="string">-f</span> <span class="string">https://localhost</span> <span class="string">||</span> <span class="string">exit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>test 中的 CMD 和 CMD-SHELL 是两种不同的执行方式，它们的主要区别在于：</p></blockquote><table><thead><tr><th>项目</th><th><code>CMD</code></th><th><code>CMD-SHELL</code></th></tr></thead><tbody><tr><td>✅ <strong>用途</strong></td><td>直接执行命令（不通过 shell）</td><td>通过 shell（如 <code>/bin/sh -c</code>）执行命令</td></tr><tr><td>🧾 <strong>写法格式</strong></td><td><code>[&quot;CMD&quot;, &quot;executable&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</code></td><td><code>[&quot;CMD-SHELL&quot;, &quot;command string&quot;]</code></td></tr><tr><td>🔧 <strong>是否使用 shell</strong></td><td>否</td><td>是</td></tr><tr><td>🧠 <strong>是否支持 shell 语法</strong></td><td>❌ 否<br>（不能使用 <code>&amp;&amp;</code>、 <code>||</code>、<code>\$VAR</code> 等）</td><td>✅ 是<br>（支持管道、重定向、变量、命令组合）</td></tr><tr><td>🛡️ <strong>安全性/可移植性</strong></td><td>✅ 更安全，执行更明确</td><td>⚠ 依赖容器中存在 shell（如 <code>/bin/sh</code>）</td></tr><tr><td>⚙️ <strong>执行效率</strong></td><td>✅ 稍快，因无需 shell 解析</td><td>⚠ 稍慢，需通过 shell 启动</td></tr><tr><td>📦 <strong>推荐使用场景</strong></td><td>- 简单健康检查命令<br>- 安全环境<br>- 精简镜像</td><td>- 需要使用逻辑控制（<code>||</code>, <code>&amp;&amp;</code>）<br>- 复杂检查逻辑</td></tr><tr><td>📌 <strong>示例</strong></td><td><code>[&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</code></td><td><code>[&quot;CMD-SHELL&quot;, &quot;curl -f http\://localhost || exit 1&quot;]</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>volumes</code>: 挂载数据卷。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 长语法格式</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/backend</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">volume</span>   <span class="comment"># 安装类型。可以是是volume、bind、tmpfs、image、npipe、cluster</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">db-data</span> <span class="comment"># 挂载的源、绑定挂载的主机上的路径、映像挂载的Docker映像引用或顶层volumes键中定义的卷名称。不适用于tmpfs支架。</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/data</span> <span class="comment"># 容器中装载卷的路径。</span></span><br><span class="line">        <span class="attr">volume:</span>  <span class="comment"># 配置其他卷选项</span></span><br><span class="line">          <span class="attr">nocopy:</span> <span class="literal">true</span> <span class="comment"># 在创建卷时禁用从容器复制数据的标志，默认值为false。</span></span><br><span class="line">          <span class="attr">subpath:</span> <span class="string">sub</span> <span class="comment"># 挂载卷的子目录。即 db-data/sub</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">bind</span> <span class="comment"># bind 表示挂载主机上的路径</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">/var/run/postgres/postgres.sock</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/var/run/postgres/postgres.sock</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 声明数据卷</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短语法格式</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example/backend</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/data</span> <span class="comment"># 这种语法不支持 subpath 和 nocopy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>networks</code>: 配置网络。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span>  <span class="comment"># 配置网络</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">some-network</span> <span class="comment"># 关联网络</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 声明网络</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>cpu 和 内存限制</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    <span class="attr">mem_limit:</span> <span class="string">1g</span>           <span class="comment"># 限制最多使用1GB内存</span></span><br><span class="line">    <span class="attr">mem_reservation:</span> <span class="string">512m</span>   <span class="comment"># 建议预留512MB内存</span></span><br><span class="line">    <span class="attr">cpus:</span> <span class="number">2.0</span>               <span class="comment"># 限制最多使用2个CPU核</span></span><br><span class="line">    <span class="attr">cpu_shares:</span> <span class="number">1024</span>        <span class="comment"># 默认值，表示标准优先级</span></span><br><span class="line">    <span class="attr">cpu_quota:</span> <span class="number">100000</span>       <span class="comment"># 每 100ms 容器最多可运行 100ms（=1核）, 与 cpus 不能同时设置</span></span><br><span class="line">    <span class="attr">cpu_period:</span> <span class="number">100000</span>      <span class="comment"># 调度周期为100ms, 与 cpus 不能同时设置</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>cpus</code></td><td>float</td><td>限制容器最多使用多少 CPU（逻辑核数）；例如 <code>0.5</code> = 一半 CPU</td></tr><tr><td><code>mem_limit</code></td><td>string</td><td>容器最大内存限制，支持单位：<code>b</code>、<code>k</code>、<code>m</code>、<code>g</code>（如 <code>256m</code>, <code>1g</code>）</td></tr><tr><td><code>mem_reservation</code></td><td>string</td><td>容器启动时预留的内存，超过这个值不被限制（仅提示调度器）</td></tr><tr><td><code>cpu_shares</code></td><td>int</td><td>CPU 权重（默认 1024），用于多个容器抢占 CPU 的优先级（仅在竞争时生效）</td></tr><tr><td><code>cpu_quota</code></td><td>int</td><td>每个周期内允许使用的 CPU 时间（单位：微秒）, 与 cpus 不能同时设置</td></tr><tr><td><code>cpu_period</code></td><td>int</td><td>CPU 调度周期（单位：微秒，默认 <code>100000</code>）, 与 cpus 不能同时设置</td></tr></tbody></table><blockquote><p>查看容器的 cpu 和 内存配置情况</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取容器的 cpu_quota 和 cpu_period</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .HostConfig.CpuQuota&#125;&#125; &#123;&#123;json .HostConfig.CpuPeriod&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class="line"><span class="comment"># 获取容器的 memory_limit</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .HostConfig.Memory&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class="line"><span class="comment"># 获取容器的 cpu_shares</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .HostConfig.CpuShares&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class="line"><span class="comment"># 获取容器的 cpus</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .HostConfig.NanoCpus&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合为一个json输出</span></span><br><span class="line">docker inspect &lt;container_id&gt; | jq <span class="string">&#x27;.[0].HostConfig | &#123;</span></span><br><span class="line"><span class="string">  cpus: (.NanoCpus / 1000000000),</span></span><br><span class="line"><span class="string">  cpu_shares: .CpuShares,</span></span><br><span class="line"><span class="string">  mem_limit: (.Memory / 1024 / 1024 | tostring + &quot; MB&quot;),</span></span><br><span class="line"><span class="string">  mem_reservation: (.MemoryReservation / 1024 / 1024 | tostring + &quot; MB&quot;),</span></span><br><span class="line"><span class="string">  cpu_quota: .CpuQuota,</span></span><br><span class="line"><span class="string">  cpu_period: .CpuPeriod</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="docker-run-转-docker-compose"><code>docker run</code> 转 <code>docker compose</code></h2><ul class="lvl-0"><li class="lvl-2"><p>在线工具：<a href="https://www.composerize.com/">composerize</a></p></li><li class="lvl-2"><p>本地安装：<a href="https://github.com/composerize/composerize">composerize</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令，npm安装：https://nodejs.org/zh-cn/download</span></span><br><span class="line">npm install composerize -g</span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line">composerize docker run -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro --restart always --log-opt max-size=1g nginx</span><br><span class="line"><span class="comment">##  转换结果</span></span><br><span class="line">name: &lt;your project name&gt;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/run/docker.sock:/tmp/docker.sock:ro</span><br><span class="line">    restart: always</span><br><span class="line">    logging:</span><br><span class="line">      options:</span><br><span class="line">        max-size: 1g</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><h2 id="docker-compose-编排管理工具-Dockge"><code>docker compose</code> 编排管理工具 <code>Dockge</code></h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://dockge.kuma.pet">Dockge</a> 是一个开源轻量级「Docker Compose 管理器」，它提供了一个漂亮、响应迅速的 Web 界面，专门面向使用 <code>docker compose</code> 的用户。</p></li></ul><table><thead><tr><th>功能模块</th><th>主要描述</th></tr></thead><tbody><tr><td><strong>Compose 堆栈全生命周期管理</strong></td><td>可以创建、编辑、启动、停止、重启、删除基于 <code>compose.yaml</code> 文件的 Docker 堆栈</td></tr><tr><td><strong>交互式 Compose 编辑器 + Web 终端</strong></td><td>实时编辑 YAML 并查看输出，还可以直接在浏览器中操作终端</td></tr><tr><td><strong>将 <code>docker run …</code> 命令转换为 Compose 文件</strong></td><td>快速生成 <code>compose.yaml</code>，便于版本控制和结构管理</td></tr><tr><td><strong>实时操作反馈</strong></td><td>镜像拉取、堆栈启动/停止等操作均可实时查看进度</td></tr><tr><td><strong>多主机代理支持（≥1.4.0）</strong></td><td>能在单一 UI 中管理多个 Docker 主机</td></tr><tr><td><strong>高兼容性 &amp; 安全设计</strong></td><td>Compose 文件保存在本地，不会被系统托管，便于使用 CLI 或其他工具管理</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create directories that store your stacks and store Dockge&#x27;s stack</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/stacks /opt/dockge</span><br><span class="line"><span class="built_in">cd</span> /opt/dockge</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download your compose.yaml</span></span><br><span class="line">curl <span class="string">&quot;https://dockge.kuma.pet/compose.yaml?port=5001&amp;stacksPath=%2Fopt%2Fstacks&quot;</span> --output compose.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the Server</span></span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问 http://localhost:5001</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 &lt;code&gt;docker compose&lt;/code&gt; 的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;docker compose&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/compose-file/&quot;&gt;Compose file reference&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 网络(Network)</title>
    <link href="https://blog.hanqunfeng.com/2025/05/28/docker-command-network/"/>
    <id>https://blog.hanqunfeng.com/2025/05/28/docker-command-network/</id>
    <published>2025-05-28T13:40:05.000Z</published>
    <updated>2025-05-29T09:58:22.618Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 网络管理 相关命令</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li></ul><span id="more"></span><h2 id="什么是Network-网络">什么是Network(网络)?</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Docker 中，<strong>网络（Network）</strong> 是容器之间通信、容器与外部通信的重要机制。Docker 提供了一套灵活的网络模型，使得你可以自由配置容器的网络环境以适配不同场景。</p></li><li class="lvl-2"><p>安装docker时，会自动在宿主机上安装一个 <code>docker0</code> 网络设备，它是一个网桥设备，用于 Docker 各容器及宿主机的网络通信。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看宿主机网卡信息，可以找到docker0</span></span><br><span class="line">$ ip addr</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 0a:6b:88:11:66:39 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.250.0.205/24 brd 10.250.0.255 scope global dynamic noprefixroute eth0</span><br><span class="line">       valid_lft 3076sec preferred_lft 3076sec</span><br><span class="line">    inet6 fe80::86b:88ff:fe11:6639/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:d6:d5:09:b1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:d6ff:fed5:9b1/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line">eth0 宿主机的ip地址是 10.250.0.205</span><br><span class="line">docker0 本身的ip地址是 172.17.0.1</span><br><span class="line">docker0 的子网掩码是 255.255.0.0</span><br><span class="line">docker0 的广播地址是 172.17.255.255</span><br><span class="line">docker0 可以为容器分配的ip地址范围是 172.17.0.2-172.17.255.254，总计65534个ip地址</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>既然docker0是一个网桥设备，我们可以通过如下命令来查看网桥的详细信息：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">brctl show</span><br><span class="line">bridge name    bridge <span class="built_in">id</span>      STP enabled    interfaces</span><br><span class="line">docker0    8000.0242d6d509b1        no</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动docker服务后，docker就为我们自动创建了三个网络，可以通过如下命令查看</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">4182e112bf34   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">958daf8a8a0d   host      host      <span class="built_in">local</span></span><br><span class="line">4674a17c6617   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里<code>NAME</code>为<code>bridge</code>的网络就是与<code>docker0</code>设备相对应的网络，其也是docker<code>默认</code>的网络，如果创建的容器没有指定网络，那么容器就会加入这个 <code>bridge</code> 网络。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  启动一个容器，没有指定网络</span></span><br><span class="line">docker run -itd --name ap1 alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时在宿主机上查看网卡信息，会看到多出一个设备</span></span><br><span class="line">ip addr</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">10: vethc0e0cc3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether c6:0d:02:c8:<span class="built_in">df</span>:a4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::c40d:2ff:fec8:dfa4/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器的网卡信息</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ap1 ip addr</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment">## 此时聪明的你已经发现了：宿主机的网卡与容器的网卡是成对出现的，并且基于序号进行关联</span></span><br><span class="line">宿主机: 10 : veth c0e0cc3 @ <span class="keyword">if</span> 9  <span class="comment"># 序号 10 与 容器后缀的 10 匹配，veth 是虚拟网卡，c0e0cc3 是随机字符串，if 是 interface</span></span><br><span class="line">容器:    9 : eth0         @ <span class="keyword">if</span> 10 <span class="comment"># 序号 9 与宿主机的后缀 9 匹配，eth0 是容器的网卡，if 是 interface</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看宿主机的网桥信息</span></span><br><span class="line">brctl show</span><br><span class="line"><span class="comment">## 输出结果，可以在 interfaces 中看到 vethc0e0cc3，说明 vethc0e0cc3 已经加入到网桥中</span></span><br><span class="line">bridge name  bridge <span class="built_in">id</span>      STP enabled  interfaces</span><br><span class="line">docker0   8000.0242d6d509b1      no  vethc0e0cc3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络中的容器信息，这里 jq 是 json 格式化，可以通过 dnf install jq -y 安装</span></span><br><span class="line">docker network inspect bridge --format <span class="string">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ap1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.2/16&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器的 IP 地址</span></span><br><span class="line">docker <span class="built_in">exec</span> ap1 hostname -i</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相同网络设备下的容器可以通过 IP 地址通信</span></span><br><span class="line"><span class="comment"># 我们再创建一个容器，并查看能否正常通信</span></span><br><span class="line">docker run -itd --name ap2 alpine</span><br><span class="line">docker <span class="built_in">exec</span> -it ap2 ping 172.17.0.2</span><br><span class="line"><span class="comment">## 输出结果，说明可以通过IP地址通信</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: <span class="built_in">seq</span>=0 ttl=64 time=0.137 ms</span><br><span class="line">64 bytes from 172.17.0.2: <span class="built_in">seq</span>=1 ttl=64 time=0.084 ms</span><br><span class="line">64 bytes from 172.17.0.2: <span class="built_in">seq</span>=2 ttl=64 time=0.081 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络中的容器</span></span><br><span class="line">docker network inspect bridge --format <span class="string">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;9d3ed5be1916b14ec9befe3649c08cc9de247c595de248600f8ef8d0fc16c5cb&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ap2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;35615a7ec10842401ad8c40187c792555b5089551a8eca39ddff6734aeba549e&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.3/16&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ap1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.2/16&quot;</span>,</span><br><span class="line">    <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否可以通过容器名称访问</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ap2 ping ap1</span><br><span class="line"><span class="comment">## 输出，不可以通过容器名称访问</span></span><br><span class="line">ping: bad address <span class="string">&#x27;ap1&#x27;</span></span><br><span class="line"><span class="comment">## 如果希望通过容器名称访问，我们可以通过 docker network create 创建一个新的网络</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>如果没有安装 brctl，可以通过如下方式安装</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos7:</span></span><br><span class="line">yum install bridge-utils -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># centos8: 不支持yum源安装，需要手动编译安装</span></span><br><span class="line"><span class="comment"># 下载源码安装，目前最新版本为1.7.1</span></span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.gz</span><br><span class="line">tar -zxvf bridge-utils-1.7.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bridge-utils-1.7.1</span><br><span class="line"><span class="comment"># 需要先安装编译所需的工具和依赖</span></span><br><span class="line">dnf install autoconf automake libtool make -y</span><br><span class="line"><span class="comment"># 因为源码目录中没有 configure 文件（但有 configure.ac），所以需要先运行如下命令生成 configure 文件</span></span><br><span class="line">autoreconf -i</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 编译 且 安装</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 添加到环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/usr/local/sbin&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">brctl --version</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">bridge-utils, 1.7</span><br></pre></td></tr></table></figure></div><ul class="lvl-0"><li class="lvl-2"><p>Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/wjWiNA.png" alt=""></p></li><li class="lvl-2"><p>docker0负责给连接其上的容器分配ip地址，并且是每个容器的默认网关。当容器需要访问外网时，会通过docker0转到宿主机的eth0上，所以只要宿主机可以访问外网，那么容器也可以访问外网。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看宿主机的路由表</span></span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.250.0.1      0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">10.250.0.0      0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ap1容器的路由表</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it ap1 route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Docker Container 的 bridge 桥接模式可以参考下图<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/32fupw.png" alt=""></p></li></ul><h2 id="docker-network-相关命令"><code>docker network</code> 相关命令</h2><table><thead><tr><th>命令</th><th>功能说明</th><th>示例</th><th>示例输出（简略）</th></tr></thead><tbody><tr><td><code>docker network ls</code></td><td>列出所有 Docker 网络</td><td><code>docker network ls</code></td><td><code>bridge</code>, <code>host</code>, <code>none</code> 等网络名称</td></tr><tr><td><code>docker network inspect &lt;网络名&gt;</code></td><td>查看指定网络的详细信息（如 IP 范围、连接容器等）</td><td><code>docker network inspect bridge</code></td><td>显示 JSON，含子网、网关、容器等信息</td></tr><tr><td><code>docker network create &lt;网络名&gt;</code></td><td>创建自定义网络（默认桥接）</td><td><code>docker network create my-net</code></td><td><code>my-net</code> 网络 ID</td></tr><tr><td><code>docker network rm &lt;网络名&gt;</code></td><td>删除网络（不能有容器连接）</td><td><code>docker network rm my-net</code></td><td>成功删除无提示，失败会有错误信息</td></tr><tr><td><code>docker network connect &lt;网络名&gt; &lt;容器名&gt;</code></td><td>将一个容器连接到指定网络</td><td><code>docker network connect my-net my-container</code></td><td>无输出，容器连接成功</td></tr><tr><td><code>docker network disconnect &lt;网络名&gt; &lt;容器名&gt;</code></td><td>将容器从网络中断开连接</td><td><code>docker network disconnect my-net my-container</code></td><td>无输出，断开成功</td></tr><tr><td><code>docker network prune</code></td><td>删除所有未使用的网络（慎用）</td><td><code>docker network prune</code></td><td>会提示是否确认，清理未使用网络</td></tr></tbody></table><h3 id="docker-network-create-创建网络"><code>docker network create</code> : 创建网络</h3><ul class="lvl-0"><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create [OPTIONS] NETWORK_NAME</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>常用参数说明表</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>--driver</code> 或 <code>-d</code></td><td>指定网络驱动类型，如 <code>bridge</code>, <code>overlay</code>, <code>macvlan</code>, <code>host</code>, <code>none</code></td><td><code>--driver bridge</code></td></tr><tr><td><code>--subnet</code></td><td>指定子网地址范围（CIDR）</td><td><code>--subnet 192.168.100.0/24</code></td></tr><tr><td><code>--gateway</code></td><td>指定网关 IP 地址</td><td><code>--gateway 192.168.100.1</code></td></tr><tr><td><code>--ip-range</code></td><td>指定可分配的 IP 范围</td><td><code>--ip-range 192.168.100.0/25</code></td></tr><tr><td><code>--aux-address</code></td><td>保留某些 IP 地址不被分配</td><td><code>--aux-address=&quot;reserved=192.168.100.254&quot;</code></td></tr><tr><td><code>--internal</code></td><td>创建一个内部网络（不能访问外部）</td><td><code>--internal</code></td></tr><tr><td><code>--attachable</code></td><td>创建可供单独容器连接的网络（Swarm 中）</td><td><code>--attachable</code></td></tr><tr><td><code>--label</code></td><td>添加标签</td><td><code>--label env=dev</code></td></tr><tr><td><code>--opt</code></td><td>提供自定义驱动选项</td><td><code>--opt encrypted=true</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>--driver</code> 或 <code>-d</code> : 常见的 Docker 网络驱动类型</p></li></ul><table><thead><tr><th>类型</th><th>含义</th><th>是否支持端口映射</th><th>特点与应用场景</th></tr></thead><tbody><tr><td><code>bridge</code>（默认）</td><td>默认的桥接网络，容器通过虚拟网桥连接，共享宿主机的网络接口。</td><td>✅ 是</td><td>默认模式，适用于单主机部署、多个容器需要互通的场景。可映射端口对外访问。</td></tr><tr><td><code>host</code></td><td>容器与宿主机共用网络命名空间，容器直接使用宿主机的 IP 和端口。</td><td>❌ 否</td><td>无网络隔离，性能高，适用于高性能、低延迟场景（如游戏服务器）。</td></tr><tr><td><code>none</code></td><td>容器没有网络接口，完全隔离。</td><td>❌ 否</td><td>用于安全性或测试网络不可达场景。</td></tr><tr><td><code>macvlan</code></td><td>为容器分配独立 MAC 和 IP，容器像物理主机一样出现在局域网中。</td><td>✅ 是（少见）</td><td>适用于容器必须直接暴露在物理网络中的场景（如 DHCP 服务、ARP 广播）。</td></tr><tr><td><code>ipvlan</code>（高级）</td><td>类似 macvlan，但不使用虚拟 MAC 地址。</td><td>✅ 是（少见）</td><td>高级网络方案，适用于对网络拓扑精细控制的场景。</td></tr><tr><td><code>overlay</code></td><td>用于多主机之间容器通信，需要 Docker Swarm 支持。</td><td>✅ 是（Swarm）</td><td>跨主机部署服务的必要手段，适合容器编排平台（如 Swarm、Kubernetes）。</td></tr></tbody></table><blockquote><p>前面我们说过，Docker会自动创建三个网络，即：bridge、host、none。对于单台宿主机的场景，绝大多数情况下我们都只会使用bridge网络。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为my-network的网络</span></span><br><span class="line">$ docker network create my-network</span><br><span class="line"><span class="comment"># 等同于，因为默认的网络驱动为bridge</span></span><br><span class="line">$ docker network create --driver bridge my-network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络，可以看到新建的网络的驱动为bridge</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> -f name=my-network</span><br><span class="line">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class="line">c2dbe1686790   my-network   bridge    <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宿主机的网桥信息</span></span><br><span class="line">$ brctl show</span><br><span class="line"><span class="comment">## 输出，可以看到此时有一个网桥设备 br-c2dbe1686790，br: bridge，c2dbe1686790：network id</span></span><br><span class="line">bridge name      bridge <span class="built_in">id</span>          STP enabled    interfaces</span><br><span class="line">br-c2dbe1686790      8000.02425be81fae          no</span><br><span class="line">docker0      8000.0242d6d509b1          no    vethc0e0cc3</span><br><span class="line">            vethf4b7577</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宿主机的网卡</span></span><br><span class="line">$ ip addr</span><br><span class="line"><span class="comment">## 输出，br-c2dbe1686790 网卡名称，其IP网段为 172.18.0.1/16</span></span><br><span class="line">13: br-c2dbe1686790: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:5b:e8:1f:ae brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-c2dbe1686790</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动两个容器并添加到my-network网络中</span></span><br><span class="line">$ docker run -itd --network my-network --name a1 alpine</span><br><span class="line">$ docker run -itd --network my-network --name a2 alpine</span><br><span class="line"></span><br><span class="line">$ ip addr</span><br><span class="line"><span class="comment">## 输出,可以看到两个容器都添加到了my-network网络中</span></span><br><span class="line">bridge name      bridge <span class="built_in">id</span>        STP enabled    interfaces</span><br><span class="line">br-c2dbe16867908000.02425be81fae    no    veth094946c</span><br><span class="line">            vetha2ba68a</span><br><span class="line">docker0        8000.0242d6d509b1    no    vethc0e0cc3</span><br><span class="line">            vethf4b7577</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连通性，可以看到 a1可以ping通 a2，反过来 a2也可以ping通 a1</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it a1 ping a2</span><br><span class="line">PING a2 (172.18.0.4): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.4: <span class="built_in">seq</span>=0 ttl=64 time=2.127 ms</span><br><span class="line">64 bytes from 172.18.0.4: <span class="built_in">seq</span>=1 ttl=64 time=0.119 ms</span><br><span class="line"></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND     CREATED         STATUS         PORTS     NAMES</span><br><span class="line">e0fb0614591e   alpine    <span class="string">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a2</span><br><span class="line">fc6e9477d2b7   alpine    <span class="string">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a1</span><br><span class="line">9d3ed5be1916   alpine    <span class="string">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap2</span><br><span class="line">c2436a1d750c   alpine    <span class="string">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap1</span><br><span class="line"><span class="comment"># 不同网络中的容器之间不能相互ping通</span></span><br><span class="line"><span class="comment">## 通过容器名称无法ping通</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it a1 ping ap1</span><br><span class="line">ping: bad address <span class="string">&#x27;ap1&#x27;</span></span><br><span class="line"><span class="comment">## 通过ap1容器IP也无法ping通，这就实现了不同网络中的网络隔离</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it a1 ping 172.17.0.2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果创建网络时没有指定子网，则从<code>docker0</code>的<code>172.17.0.0/16</code>往后排，比如我们上面创建的<code>my-network</code>，其子网就是<code>172.18.0.0/16</code>，如下命令创建一个bridge网络，并指定子网、网关等信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">  --driver bridge \</span><br><span class="line">  --subnet 192.168.50.0/24 \</span><br><span class="line">  --gateway 192.168.50.1 \</span><br><span class="line">  my-custom-net</span><br></pre></td></tr></table></figure><h4 id="bridge-总结"><code>bridge</code> 总结</h4><ul class="lvl-0"><li class="lvl-2"><p>默认创建的 <code>docker0</code> 网络，是一个桥接网络，在 docker network 中的名称为 <code>bridge</code>，该网络下的容器可以通过IP地址相互访问，但不能通过容器名称访问</p></li><li class="lvl-2"><p>通过<code>docker network create &lt;网络名称&gt;</code>创建的网络也是一个桥接网络，在这个网络下，容器可以通过IP地址相互访问，也能通过容器名称访问。</p></li></ul><h3 id="docker-network-ls-列出所有网络"><code>docker network ls</code> : 列出所有网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有网络</span></span><br><span class="line">$ docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 输出指定的信息</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Name&#125;&#125;\t&#123;&#123;.Scope&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment"># 输出json格式</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> --format <span class="string">&quot;json&quot;</span></span><br><span class="line"><span class="comment"># 过滤</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> -f <span class="string">&quot;driver=bridge&quot;</span></span><br><span class="line"><span class="comment"># 不截断输出</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> --no-trunc</span><br><span class="line"><span class="comment"># 只显示network id</span></span><br><span class="line">$ docker network <span class="built_in">ls</span> -q</span><br></pre></td></tr></table></figure><h3 id="docker-network-inspect-查看网络详情"><code>docker network inspect</code> : 查看网络详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看名称为bridge网络详情</span></span><br><span class="line">$ docker network inspect bridge</span><br><span class="line"><span class="comment"># 查看当前网络下有哪些容器</span></span><br><span class="line">$ docker network inspect bridge --format <span class="string">&quot;&#123;&#123;.Containers&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment"># 输出json格式</span></span><br><span class="line">$ docker network inspect bridge --format <span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-network-prune-清理没用的网络"><code>docker network prune</code> : 清理没用的网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未使用的网络</span></span><br><span class="line">$ docker network prune</span><br><span class="line"><span class="comment"># 删除所有未使用的网络，无需确认</span></span><br><span class="line">$ docker network prune -f</span><br><span class="line"><span class="comment"># 清理24小时内未使用的网络</span></span><br><span class="line">$ docker network prune --filter <span class="string">&quot;until=24h&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-network-rm-删除网络"><code>docker network rm</code> : 删除网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的网络</span></span><br><span class="line">$ docker network <span class="built_in">rm</span> &lt;network-name&gt;</span><br><span class="line"><span class="comment"># 删除所有网络</span></span><br><span class="line">$ docker network <span class="built_in">rm</span> $(docker network <span class="built_in">ls</span> -q)</span><br><span class="line"><span class="comment"># 删除所有bridge网络，这里要注意，docker默认创建的3个网络是删除不掉的</span></span><br><span class="line">$ docker network <span class="built_in">rm</span> $(docker network <span class="built_in">ls</span> -q -f driver=bridge)</span><br></pre></td></tr></table></figure><h3 id="docker-network-connect-将容器连接到网络"><code>docker network connect</code> : 将容器连接到网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器连接到网络，如果容器启动时忘记连接网络，这里可以手动添加</span></span><br><span class="line">$ docker network connect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-network-disconnect-将容器从网络断开"><code>docker network disconnect</code> : 将容器从网络断开</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network disconnect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure><h2 id="本文总结">本文总结</h2><ul class="lvl-0"><li class="lvl-2"><p>容器与网络是多对多的关系，即一个网络可以有多个容器，一个容器也可以连接到多个网络。</p></li><li class="lvl-2"><p>docker0 是 docker 默认创建的网络，不指定网络的情况下所有容器都连接到 docker0 网络。</p></li><li class="lvl-2"><p>docker0 是 bridge 网络，该网络中的容器之间可以通过 IP 互相访问，但不能通过容器名称访问。</p></li><li class="lvl-2"><p>自建的 bridge 网络中的容器可以通过容器名称（或容器ID，但不常用）访问。</p></li><li class="lvl-2"><p>不同的 bridge 网络中的容器不能互相访问。</p></li></ul><h2 id="link-vs-network"><code>--link</code> vs <code>--network</code></h2><table><thead><tr><th>项目</th><th><code>--link</code></th><th><code>--network</code></th></tr></thead><tbody><tr><td>功能</td><td>将一个容器链接到另一个容器，并设置环境变量和主机名映射</td><td>将容器加入到一个自定义网络中，实现灵活、隔离的网络通信</td></tr><tr><td>是否推荐</td><td>❌ 不推荐（已废弃）</td><td>✅ 推荐使用</td></tr><tr><td>网络隔离</td><td>基于默认 <code>bridge</code> 网络，隔离性差</td><td>可以创建自定义网络（bridge、overlay 等），隔离性强</td></tr><tr><td>可扩展性</td><td>只适用于已运行的容器，连接固定</td><td>支持多个容器，灵活组合和动态扩展</td></tr><tr><td>DNS 支持</td><td>仅设置环境变量，不支持自动 DNS</td><td>自定义网络中支持容器名称作为 DNS 名称</td></tr><tr><td>生命周期</td><td>一方容器关闭，另一方仍保存过时链接</td><td>网络存在即可，容器生命周期不互相影响</td></tr><tr><td>安全性</td><td>所有容器共享 bridge，容易相互访问</td><td>自定义网络间默认隔离，安全性更好</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 网络管理 相关命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 数据卷(Volume)</title>
    <link href="https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/"/>
    <id>https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/</id>
    <published>2025-05-28T13:30:05.000Z</published>
    <updated>2025-05-29T09:27:21.992Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 数据卷管理 相关命令</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li></ul><span id="more"></span><h2 id="什么是Volume-数据卷">什么是Volume(数据卷)?</h2><ul class="lvl-0"><li class="lvl-2"><p>Volume 是由 Docker 管理的特殊目录，位于宿主机文件系统中(<code>/var/lib/docker/volumes/</code>)，用于存储和共享容器的数据。</p></li><li class="lvl-2"><p>当容器被删除后，容器内的文件系统也会一起删除，但挂载在 Volume 中的数据不会丢失，可供多个容器共享。</p></li><li class="lvl-2"><p>Volume 的特点</p></li></ul><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>数据持久化</td><td>即使容器删除，数据仍保留在卷中</td></tr><tr><td>多容器共享访问</td><td>多个容器可以挂载同一个卷，实现数据共享</td></tr><tr><td>不依赖容器路径</td><td>卷与容器生命周期解耦，支持灵活的容器重建和升级</td></tr><tr><td>管理简便</td><td>可用 <code>docker volume</code> 命令进行查看、创建、删除等操作</td></tr><tr><td>安全隔离</td><td>Docker 管理的路径比绑定挂载更安全</td></tr></tbody></table><h2 id="docker-volume-相关命令"><code>docker volume</code> 相关命令</h2><table><thead><tr><th>命令</th><th>作用说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker volume create</code></td><td>创建一个新的卷，名称可选（不指定会自动生成）</td><td><code>docker volume create myvolume</code></td></tr><tr><td><code>docker volume ls</code></td><td>列出所有已存在的卷</td><td><code>docker volume ls</code></td></tr><tr><td><code>docker volume inspect &lt;name&gt;</code></td><td>查看指定卷的详细信息，包括挂载点、驱动等</td><td><code>docker volume inspect myvolume</code></td></tr><tr><td><code>docker volume rm &lt;name&gt;</code></td><td>删除一个卷（前提是没有容器正在使用该卷）</td><td><code>docker volume rm myvolume</code></td></tr><tr><td><code>docker volume prune</code></td><td>删除所有未被使用的卷（会有确认提示）</td><td><code>docker volume prune</code></td></tr></tbody></table><h3 id="docker-volume-create-创建一个新的卷"><code>docker volume create</code> : 创建一个新的卷</h3><ul class="lvl-0"><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [OPTIONS] [VOLUME]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数详解</p></li></ul><table><thead><tr><th>选项</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>-d, --driver string</code></td><td>指定卷驱动程序，默认是 <code>local</code>（本地存储）</td><td><code>-d local</code> 或 第三方驱动名称(需要安装第三方插件)</td></tr><tr><td><code>--label list</code></td><td>给卷添加标签（元数据），可用于分类、过滤</td><td><code>--label env=prod</code></td></tr><tr><td><code>-o, --opt map</code></td><td>设置驱动的特定选项，格式为 <code>key=value</code>，多个选项可重复使用</td><td><code>-o type=tmpfs -o device=tmpfs</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个默认卷（local 驱动）</span></span><br><span class="line">docker volume create myvolume</span><br><span class="line"><span class="comment"># 也可以在启动容器的时候创建默认数据卷，如下命令，若 myvolume 卷不存在，则会自动创建</span></span><br><span class="line">docker run -d -v myvolume:/data nginx</span><br><span class="line">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=myvolume,target=/data nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个带有标签的卷</span></span><br><span class="line">docker volume create --label <span class="built_in">env</span>=dev --label team=backend myvolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建匿名卷（不指定名称）</span></span><br><span class="line">docker volume create</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tmpfs 类型卷（只存于内存中，不落盘）,适用于高速读写但不需要持久化的数据</span></span><br><span class="line">docker volume create \</span><br><span class="line">  -d <span class="built_in">local</span> \            <span class="comment"># 指定驱动程序为 local</span></span><br><span class="line">  -o <span class="built_in">type</span>=tmpfs \       <span class="comment"># 指定底层文件系统类型为 tmpfs（内存文件系统）</span></span><br><span class="line">  -o device=tmpfs \     <span class="comment"># 设置挂载设备为 tmpfs，用于与 type=tmpfs 配合</span></span><br><span class="line">  -o o=size=100m \      <span class="comment"># 设置 tmpfs 的最大容量为 100MB</span></span><br><span class="line">  mytmpfs               <span class="comment"># 卷的名称，可通过 docker volume ls 查看</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个自定义驱动的卷（如 nfs）</span></span><br><span class="line">docker volume create \</span><br><span class="line">  -d <span class="built_in">local</span> \                    <span class="comment"># 默认驱动程序为 local</span></span><br><span class="line">  -o <span class="built_in">type</span>=nfs \                 <span class="comment"># 底层文件系统类型为 nfs</span></span><br><span class="line">  -o o=addr=192.168.1.100,rw \  <span class="comment"># 设置 nfs 的地址和读写权限，若只读为 ro</span></span><br><span class="line">  -o device=:/path/to/share \   <span class="comment"># 挂载设备为 nfs，格式为：nfs://192.168.1.100:/path/to/share</span></span><br><span class="line">  mynfs                         <span class="comment"># 卷的名称，可通过 docker volume ls 查看</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建的数据卷会保存在 <code>/var/lib/docker/volumes/</code> 目录下，比如我们创建了一个卷 myvolume，那么该卷会保存在 <code>/var/lib/docker/volumes/myvolume/_data</code> 目录下</p></li></ul><h3 id="docker-volume-ls-列出所有已存在的卷"><code>docker volume ls</code> : 列出所有已存在的卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 列出所有卷的ID</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -q</span><br><span class="line"><span class="comment"># 列出指定驱动的卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -f driver=<span class="built_in">local</span></span><br><span class="line"><span class="comment"># 列出指定标签的卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -f label=<span class="built_in">env</span>=dev</span><br><span class="line"><span class="comment"># 列出所有未使用的卷，包括匿名卷和命名卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="docker-volume-inspect-name-查看指定卷的详细信息"><code>docker volume inspect &lt;name&gt;</code> : 查看指定卷的详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出指定卷的详细信息</span></span><br><span class="line">docker volume inspect myvolume</span><br><span class="line"><span class="comment"># 列出指定卷的详细信息，并使用json格式输出</span></span><br><span class="line">docker volume inspect -f json myvolume</span><br><span class="line"><span class="comment"># 列出指定卷的挂载点</span></span><br><span class="line">docker volume inspect myvolume --format <span class="string">&quot;&#123;&#123;.Mountpoint&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-volume-prune-删除所有未被容器使用的卷"><code>docker volume prune</code> : 删除所有未被容器使用的卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未被使用的匿名数据卷，会提示确认</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="comment"># 删除所有未被使用的数据卷，会提示确认</span></span><br><span class="line">docker volume prune -a</span><br><span class="line"><span class="comment"># 删除所有未被使用的卷，无需确认立刻删除</span></span><br><span class="line">docker volume prune -a -f</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>匿名卷 vs 命名卷</p><ul class="lvl-2"><li class="lvl-4">匿名卷：没有名称，只在 <code>docker run -v /container/path</code> 时自动创建；</li><li class="lvl-4">命名卷：有名称，例如 <code>docker run -v mydata:/container/path</code>；</li></ul></li></ul><h3 id="docker-volume-rm-name-删除数据卷"><code>docker volume rm &lt;name&gt;</code> : 删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> myvolume</span><br><span class="line"><span class="comment"># 删除所有数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> $(docker volume <span class="built_in">ls</span> -q)</span><br><span class="line"><span class="comment"># 删除所有未使用的数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> $(docker volume <span class="built_in">ls</span> -qf dangling=<span class="literal">true</span>)</span><br><span class="line"><span class="comment"># 删除所有未使用的数据卷，无需确认</span></span><br><span class="line">docker volume <span class="built_in">rm</span> $(docker volume <span class="built_in">ls</span> -qf dangling=<span class="literal">true</span>) -f</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 数据卷管理 相关命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 容器(Container)</title>
    <link href="https://blog.hanqunfeng.com/2025/05/27/docker-command-container/"/>
    <id>https://blog.hanqunfeng.com/2025/05/27/docker-command-container/</id>
    <published>2025-05-27T13:30:05.000Z</published>
    <updated>2025-05-29T09:02:17.040Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 容器管理 相关命令</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li></ul><span id="more"></span><h2 id="容器的生命周期">容器的生命周期</h2><ul class="lvl-0"><li class="lvl-2"><p>容器可能处于以下几种状态：</p><ul class="lvl-2"><li class="lvl-5">初建（created）</li><li class="lvl-5">运行（running）</li><li class="lvl-5">暂停（paused）</li><li class="lvl-5">停止（stopped）</li><li class="lvl-5">删除（deleted）</li></ul></li><li class="lvl-2"><p>各生命周期之间的转换关系如图所示：<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/19n9NJ.png" alt=""></p></li></ul><table><thead><tr><th>命令/情况</th><th>说明</th><th>容器状态变更</th></tr></thead><tbody><tr><td><code>docker create</code></td><td>创建容器后，不立即启动运行，容器进入初建状态</td><td>初建状态</td></tr><tr><td><code>docker run</code></td><td>创建容器，并立即启动运行，进入运行状态</td><td>初建 → 运行</td></tr><tr><td><code>docker start</code></td><td>启动已创建的容器，容器转为运行状态</td><td>停止 → 运行</td></tr><tr><td><code>docker stop</code></td><td>停止正在运行的容器，容器转入停止状态</td><td>运行 → 停止</td></tr><tr><td><code>docker kill</code></td><td>强制终止容器，相当于“断电”，容易丢失数据，不建议轻易使用</td><td>运行 → 停止（非正常）</td></tr><tr><td><code>docker restart</code></td><td>重启容器，容器重新进入运行状态</td><td>运行 → 停止 → 运行</td></tr><tr><td><code>docker pause</code></td><td>暂停容器内所有进程，容器进入暂停状态</td><td>运行 → 暂停</td></tr><tr><td><code>docker unpause</code></td><td>取消暂停状态，容器恢复运行</td><td>暂停 → 运行</td></tr><tr><td><code>docker rm</code></td><td>删除容器，容器转入删除状态</td><td>任意 → 删除</td></tr><tr><td>Killed by out-of-memory (OOM)</td><td>宿主机内存耗尽，容器被系统终止，此为非计划终止；建议杀死内存占用最高的容器</td><td>运行 → 停止（异常）</td></tr><tr><td>Container process exited</td><td>容器进程异常终止后，进入“是否重启”判断流程：是则执行 <code>start</code> 进入运行；否则保持停止状态</td><td>异常 → 停止或运行</td></tr></tbody></table><h2 id="docker-container-容器管理"><code>docker container</code> : 容器管理</h2><ul class="lvl-0"><li class="lvl-2"><p><code>docker container --help</code></p></li></ul><table><thead><tr><th>命令</th><th>说明</th><th>别名</th></tr></thead><tbody><tr><td>attach</td><td>将本地的标准输入、输出和错误流附加到一个正在运行的容器上</td><td>docker attach</td></tr><tr><td>commit</td><td>根据容器的更改创建一个新的镜像</td><td>docker commit</td></tr><tr><td>cp</td><td>在容器和本地文件系统之间复制文件/文件夹</td><td>docker cp</td></tr><tr><td>create</td><td>创建一个新的容器</td><td>docker create</td></tr><tr><td>diff</td><td>检查容器文件系统上的文件或目录的更改</td><td>docker diff</td></tr><tr><td>exec</td><td>在正在运行的容器中执行命令</td><td>docker exec</td></tr><tr><td>export</td><td>将容器的文件系统导出为 tar 归档文件</td><td>docker export</td></tr><tr><td>inspect</td><td>显示一个或多个容器的详细信息</td><td>可以使用 <code>docker inspect</code></td></tr><tr><td>kill</td><td>终止一个或多个正在运行的容器</td><td>docker kill</td></tr><tr><td>logs</td><td>获取容器的日志</td><td>docker logs</td></tr><tr><td>ls</td><td>列出容器</td><td>docker ps</td></tr><tr><td>pause</td><td>暂停一个或多个容器内的所有进程</td><td>docker pause</td></tr><tr><td>port</td><td>列出容器的端口映射或特定的端口映射</td><td>docker port</td></tr><tr><td>prune</td><td>删除所有已停止的容器</td><td></td></tr><tr><td>rename</td><td>重命名一个容器</td><td>docker rename</td></tr><tr><td>restart</td><td>重启一个或多个容器</td><td>docker restart</td></tr><tr><td>rm</td><td>删除一个或多个容器</td><td>docker rm</td></tr><tr><td>run</td><td>根据镜像创建并运行一个新容器</td><td>docker run</td></tr><tr><td>start</td><td>启动一个或多个已停止的容器</td><td>docker start</td></tr><tr><td>stats</td><td>实时显示容器资源使用统计信息</td><td>docker stats</td></tr><tr><td>stop</td><td>停止一个或多个正在运行的容器</td><td>docker stop</td></tr><tr><td>top</td><td>显示容器中运行的进程</td><td>docker top</td></tr><tr><td>unpause</td><td>取消暂停一个或多个容器内的所有进程</td><td>docker unpause</td></tr><tr><td>update</td><td>更新一个或多个容器的配置</td><td>docker update</td></tr><tr><td>wait</td><td>阻塞直到一个或多个容器停止，然后打印其退出代码</td><td>docker wait</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>运行 <code>docker container COMMAND --help</code> 可获取某个命令的更多信息。</p></li></ul><h3 id="docker-create-创建容器，但不启动"><code>docker create</code> : 创建容器，但不启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker create \</span><br><span class="line">    --name my-container \ <span class="comment"># 容器名</span></span><br><span class="line">    -e MY_ENV_VAR=my-value \ <span class="comment"># 设置环境变量</span></span><br><span class="line">    -p 80:80 \ <span class="comment"># 映射端口，格式：宿主机端口:容器端口</span></span><br><span class="line">    -v /path/to/my/dir:/path/in/container \ <span class="comment"># 映射目录，格式：宿主机目录:容器目录，都必须是绝对路径</span></span><br><span class="line">    --restart always \ <span class="comment"># 设置重启策略</span></span><br><span class="line">    nginx:latest \ <span class="comment"># 镜像名，镜像不存在时会自动下载</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker create</code> 与 <code>docker run</code> 的参数基本一致，具体查看下面 <code>docker run</code> 中的介绍。</p></li></ul><h3 id="docker-start-启动一个容器"><code>docker start</code> : 启动一个容器</h3><ul class="lvl-0"><li class="lvl-2"><p>启动一个容器，容器必须已经创建，并且处于停止状态。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法：docker start &lt;container_id|container_name&gt;</span></span><br><span class="line">$ docker start my-container</span><br></pre></td></tr></table></figure><h3 id="docker-run-创建并启动一个容器"><code>docker run</code> : 创建并启动一个容器</h3><ul class="lvl-0"><li class="lvl-2"><p>相当于<code>docker create</code> + <code>docker start</code></p></li><li class="lvl-2"><p>常用参数说明</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--detach</code></td><td>后台运行容器（即“守护态”），<code>run</code>独有</td><td><code>docker run -d nginx</code></td></tr><tr><td><code>-it</code></td><td>交互式运行容器并分配终端（常用于调试）</td><td><code>docker run -it ubuntu bash</code></td></tr><tr><td><code>--name</code></td><td>指定容器名称</td><td><code>docker run --name my-nginx nginx</code></td></tr><tr><td><code>--rm</code></td><td>容器退出时自动删除</td><td><code>docker run --rm ubuntu</code></td></tr><tr><td><code>-p</code>, <code>--publish</code></td><td>端口映射（宿主机:容器）</td><td><code>docker run -p 8080:80 nginx</code></td></tr><tr><td><code>-P</code>, <code>--publish-all</code></td><td>自动随机映射容器内部所有暴露端口到宿主机端口</td><td><code>docker run -P nginx</code></td></tr><tr><td><code>-v</code>, <code>--volume</code></td><td>挂载卷（宿主机目录:容器目录）</td><td><code>docker run -v /data:/app/data myapp</code></td></tr><tr><td><code>--mount</code></td><td>更灵活的挂载方式（推荐新项目使用）</td><td><code>docker run --mount type=bind,source=/host,target=/container nginx</code></td></tr><tr><td><code>--env</code>, <code>-e</code></td><td>设置环境变量</td><td><code>docker run -e ENV=prod myapp</code></td></tr><tr><td><code>--env-file</code></td><td>从文件中加载多个环境变量</td><td><code>docker run --env-file .env myapp</code></td></tr><tr><td><code>--network</code></td><td>设置容器使用的网络模式</td><td><code>docker run --network host myapp</code></td></tr><tr><td><code>--restart</code></td><td>设置容器的自动重启策略</td><td><code>docker run --restart=always myapp</code></td></tr><tr><td><code>--privileged</code></td><td>给予容器更多的权限（如访问 host 设备）</td><td><code>docker run --privileged myapp</code></td></tr><tr><td><code>--entrypoint</code></td><td>覆盖镜像默认的 ENTRYPOINT</td><td><code>docker run --entrypoint /bin/bash myapp</code></td></tr><tr><td><code>-u</code>, <code>--user</code></td><td>指定容器内运行的用户（格式：UID 或 UID:GID）</td><td><code>docker run --user 1000:1000 myapp</code></td></tr><tr><td><code>-c</code>, <code>--cpu-shares</code></td><td>设置 CPU 权重（相对值）</td><td><code>docker run --cpu-shares=512 myapp</code></td></tr><tr><td><code>-m</code>, <code>--memory</code></td><td>限制容器最大内存（如 <code>512m</code>, <code>1g</code>）</td><td><code>docker run --memory=512m myapp</code></td></tr><tr><td><code>-h</code>,<code> --hostname</code></td><td>设置容器主机名</td><td><code>docker run -h myhost myapp</code></td></tr><tr><td><code>--link</code>(更推荐使用 <code>--network</code>)</td><td>创建链接到其他容器</td><td><code>docker run --link myapp:app myapp2</code></td></tr><tr><td><code>--cpus</code></td><td>限制容器使用的CPU核数</td><td><code>docker run --cpus=&quot;1.5&quot;</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>-p</code>, <code>--publish</code> 端口映射</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p [主机IP:]主机端口:容器端口[/协议]</span><br></pre></td></tr></table></figure><table><thead><tr><th>示例</th><th>含义说明</th></tr></thead><tbody><tr><td><code>-p 8080:80</code></td><td>将主机的 8080 端口映射到容器的 80 端口（默认 TCP）</td></tr><tr><td><code>-p 127.0.0.1:8080:80</code></td><td>仅将主机本地 IP（127.0.0.1）的 8080 映射到容器的 80 端口（外部无法访问）</td></tr><tr><td><code>-p 8080:80/tcp</code></td><td>显式指定协议为 TCP（等同于不加 <code>/tcp</code>）</td></tr><tr><td><code>-p 8080:80/udp</code></td><td>映射 UDP 协议端口（如 DNS 服务等）</td></tr><tr><td><code>-p 8080</code></td><td>宿主机随机端口映射到容器的8080端口</td></tr><tr><td><code>-p 3000-3006:4000-4006</code></td><td><strong>范围映射</strong>，不能映射非对称范围（如 3000-3006:4000-4006），只能一一对应</td></tr><tr><td>多个 <code>-p</code></td><td>可以多次使用 <code>-p</code>，映射多个端口。例如：<code>-p 80:80 -p 443:443</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>-v, --volume</code> 数据卷映射</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &lt;本地路径&gt;:&lt;容器路径&gt;[:权限]</span><br><span class="line">  <span class="comment"># &lt;本地路径&gt;主机上的路径（绝对路径，或命名卷），目录不存在会自动创建</span></span><br><span class="line">  <span class="comment"># &lt;容器路径&gt;容器内的路径，目录不存在会自动创建</span></span><br><span class="line">  <span class="comment"># [:权限]可选：ro（只读） 或 rw（读写，默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 挂载本地目录到容器</span></span><br><span class="line">docker run -v /data:/app/data myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载为只读</span></span><br><span class="line">docker run -v /data:/app/data:ro myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载多个数据卷</span></span><br><span class="line">docker run -v /data1:/app/data1 -v /data2:/app/data2 myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命名卷</span></span><br><span class="line">docker volume create mydata</span><br><span class="line">docker run -v mydata:/app/data myapp</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--mount</code> 挂载卷</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --mount 是 Docker 推荐使用的 现代挂载方式，功能和 -v（或 --volume）类似，但语法更清晰、结构更规范，适用于卷（volume）、绑定挂载（bind）和临时挂载（tmpfs）。</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=&lt;类型&gt;,<span class="built_in">source</span>=&lt;主机路径或卷名&gt;,target=&lt;容器路径&gt;[,<span class="built_in">readonly</span>]</span><br></pre></td></tr></table></figure><blockquote><p>三种挂载类型对比</p></blockquote><table><thead><tr><th>类型 (<code>type</code>)</th><th>用途</th><th>示例 <code>source</code></th></tr></thead><tbody><tr><td><code>volume</code></td><td>使用 Docker 管理的卷</td><td>卷名，如 <code>mydata</code></td></tr><tr><td><code>bind</code></td><td>挂载宿主机的实际路径</td><td>绝对路径，如 <code>/home/user/app/config</code></td></tr><tr><td><code>tmpfs</code></td><td>挂载内存中的临时文件系统</td><td>无需指定 <code>source</code></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命名卷挂载（推荐方式）,这里 --target 指定容器内的挂载点，也可以替换为 --destination</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=mydata,target=/app/data myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地路径挂载（绑定挂载）,source指定的本地路径必须存在</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/home/user/app/config,target=/app/config myapp</span><br><span class="line"><span class="comment"># 只读挂载，readonly 可以简写为 ro</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/home/user/app/config,target=/app/config,<span class="built_in">readonly</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内存中的临时文件系统挂载，数据不会持久化，只存储在容器运行时的内存中</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=tmpfs,target=/app/tmpfs myapp</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--link</code> 容器间链接</p></li></ul><blockquote><p>用于在容器之间建立连接，使一个容器可以通过另一个容器的名称访问其网络信息（如 IP、环境变量等）。<br>注意：<code>--link</code> 已被弃用，建议使用 <code>--network</code> 来实现容器间链接。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">link</span> &lt;目标容器名&gt;:&lt;别名&gt; &lt;其他参数&gt; &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 示例</span></span><br><span class="line"><span class="comment"># 场景：一个 web 容器想要连接另一个运行中的 db 容器</span></span><br><span class="line"><span class="comment"># 先启动数据库容器</span></span><br><span class="line">docker run -d --name db mysql</span><br><span class="line"><span class="comment"># 启动 web 容器并连接到 db 容器</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --name web --<span class="built_in">link</span> db:mydb ubuntu bash</span><br><span class="line"><span class="comment"># 在 web 容器中，现在你可以用 mydb 来访问 db 容器，但反过来 db 容器无法访问 web 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> web ping mydb</span><br><span class="line"></span><br><span class="line"><span class="comment">## 改用 --network 实现</span></span><br><span class="line">docker network create mynet</span><br><span class="line">docker run -d --name db --network mynet mysql</span><br><span class="line">docker run -it --<span class="built_in">rm</span> --name web --network mynet ubuntu bash</span><br><span class="line">docker <span class="built_in">exec</span> web ping db</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--network</code> 网络模式类型</p></li></ul><table><thead><tr><th>类型</th><th>含义</th><th>特点/适用场景</th><th>是否允许端口映射</th></tr></thead><tbody><tr><td><code>bridge</code></td><td>默认网络类型（用户自定义或 Docker 默认桥接网络）</td><td>容器通过虚拟网桥连接，可相互通信；适用于单主机部署</td><td>✅ 是</td></tr><tr><td><code>host</code></td><td>容器与宿主机共享网络栈</td><td>没有网络隔离，容器使用宿主机的 IP 和端口，性能高，适合对网络要求高的服务</td><td>❌ 否</td></tr><tr><td><code>none</code></td><td>容器没有网络接口</td><td>完全隔离；适用于需要完全控制网络的场景或测试网络不可达性</td><td>❌ 否</td></tr><tr><td><code>&lt;user-defined&gt;</code></td><td>用户自定义的网络名称，通过 <code>docker network create</code> 创建</td><td>支持容器名称互解析（DNS），适合多容器通信场景，如 Docker Compose</td><td>✅ 是</td></tr><tr><td><code>container:&lt;name|id&gt;</code></td><td>与另一个容器共享网络命名空间</td><td>两个容器共享 IP 和端口，适用于主-辅容器模式，如 sidecar 容器共享主容器网络</td><td>❌ 否</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认 bridge 网络</span></span><br><span class="line">docker run -p 8080:80 --network bridge --name my-nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与宿主机共享网络，不能使用-p</span></span><br><span class="line">docker run --network host nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用任何网络，不能使用-p</span></span><br><span class="line">docker run --network none nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用已创建的自定义网络，相同网络命名空间下的容器，可以通过容器 名称或ID 互相访问</span></span><br><span class="line">docker network create nginx_net</span><br><span class="line">docker run -p 8080:80 --network nginx_net nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与另一个容器共享网络命名空间，不能使用-p，并且此时新启动的容器占用的端口不能与要连接的容器端口一致，否则将启动失败</span></span><br><span class="line">docker run --network container:my-nginx busybox</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--restart</code> 重启策略</p></li></ul><table><thead><tr><th>策略</th><th>含义</th></tr></thead><tbody><tr><td><code>no</code>（默认）</td><td>容器退出后不会自动重启</td></tr><tr><td><code>always</code></td><td>无论退出状态码如何，容器总是自动重启</td></tr><tr><td><code>unless-stopped</code></td><td>容器总是自动重启，除非用户手动停止它</td></tr><tr><td><code>on-failure[:N]</code></td><td>仅在容器非 0 状态码退出时自动重启（可选设置最大重启次数 N）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器非正常退出时自动重启</span></span><br><span class="line">docker run --restart on-failure my-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多重启 5 次</span></span><br><span class="line">docker run --restart on-failure:5 my-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是重启（即使你重启 Docker 服务后）</span></span><br><span class="line">docker run --restart always my-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除非手动停止，否则一直重启</span></span><br><span class="line">docker run --restart unless-stopped my-app</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--cpu-shares</code> : 设置容器的 CPU 相对权重，即在 CPU 资源竞争时的相对优先级，默认值为 1024。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器1，权重 1024（默认）</span></span><br><span class="line">docker run -d --name c1 --cpu-shares 1024 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器2，权重 512（优先级低）</span></span><br><span class="line">docker run -d --name c2 --cpu-shares 512 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 说明：</span></span><br><span class="line">  <span class="comment"># c1的权重1024，c2的权重512,不是绝对限制，而是分配比例</span></span><br><span class="line">  <span class="comment"># 该权重表示容器在 CPU 竞争下，权重越高则优先级越高，会尽可能使用 CPU 资源。</span></span><br><span class="line">  <span class="comment"># 如果这两个容器都运行在 CPU 忙碌的环境下(只有在 多容器共享 CPU 且竞争资源 的情况下才生效)：</span></span><br><span class="line">    <span class="comment"># c1 将获得大约 2/3 的 CPU 时间</span></span><br><span class="line">    <span class="comment"># c2 将获得大约 1/3 的 CPU 时间</span></span><br><span class="line">  <span class="comment"># 如果系统 CPU 空闲，所有容器都可以使用 100% 的 CPU。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker run</code> 示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个nginx 容器</span></span><br><span class="line">docker run -d -p 80:80 --name nginx nginx</span><br><span class="line"><span class="comment"># 替换nginx镜像默认的启动命令，nginx 镜像默认启动 nginx 服务，此命令会改为执行 nginx -v 显示版本号</span></span><br><span class="line">docker run --name test_nginx --entrypoint <span class="string">&quot;&quot;</span> nginx nginx -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本或命令，这里添加 --rm 参数，表示运行结束后自动删除容器，这里是安装 ping 命令</span></span><br><span class="line">docker run --<span class="built_in">rm</span> ubuntu bash -c <span class="string">&quot;apt update &amp;&amp; apt install -y iputils-ping&quot;</span></span><br><span class="line"><span class="comment"># 交互式执行 shell 命令，执行命令后会进入容器的shell</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 这样也可以，因为 ubuntu 的默认启动命令是 /bin/bash</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it ubuntu</span><br><span class="line"><span class="comment"># 转到后台运行</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -itd ubuntu</span><br></pre></td></tr></table></figure><h3 id="docker-stop-停止容器，容器优雅退出"><code>docker stop</code> : 停止容器，容器优雅退出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止容器，通过容器名称</span></span><br><span class="line">docker stop test_nginx</span><br><span class="line"><span class="comment"># 停止容器，通过容器ID</span></span><br><span class="line">docker stop 5d7c0c5d5c0c</span><br><span class="line"><span class="comment"># 停止所有正在运行的容器</span></span><br><span class="line">docker stop $(docker ps -q)</span><br><span class="line"><span class="comment"># 等待5秒后强制关闭</span></span><br><span class="line">docker stop -t 5 test_nginx</span><br></pre></td></tr></table></figure><h3 id="docker-kill-强制停止容器"><code>docker kill</code> : 强制停止容器</h3><ul class="lvl-0"><li class="lvl-2"><p>当容器完全卡死、挂起、不响应 <code>stop</code> 命令时使用</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> test_nginx</span><br><span class="line">docker <span class="built_in">kill</span> 5d7c0c5d5c0c</span><br><span class="line">docker <span class="built_in">kill</span> $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="docker-restart-重启容器"><code>docker restart</code> : 重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart test_nginx</span><br><span class="line">docker restart 5d7c0c5d5c0c</span><br><span class="line">docker restart $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="docker-pause-暂停容器"><code>docker pause</code> : 暂停容器</h3><ul class="lvl-0"><li class="lvl-2"><p>暂停后宿主机将不再为容器分配CPU时间片，但内存依然有效，你可以理解为此时为容器保存了快照</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pause test_nginx</span><br><span class="line">docker pause 5d7c0c5d5c0c</span><br><span class="line">docker pause $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="docker-unpause-恢复容器"><code>docker unpause</code> : 恢复容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker unpause test_nginx</span><br><span class="line">docker unpause 5d7c0c5d5c0c</span><br><span class="line">docker unpause $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="docker-ps-查看容器列表"><code>docker ps</code> : 查看容器列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 显示所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 显示所有正在运行的容器的ID</span></span><br><span class="line">docker ps -q</span><br><span class="line"><span class="comment"># 不截断输出，此时 COMMAND 列会显示完整的命令</span></span><br><span class="line">docker ps -notrunc</span><br><span class="line"><span class="comment"># 显示最近创建的5条容器</span></span><br><span class="line">docker ps -n 5</span><br><span class="line"><span class="comment"># 过滤器，显示状态为exited的容器</span></span><br><span class="line">docker ps -a --filter <span class="string">&quot;status=exited&quot;</span></span><br><span class="line"><span class="comment"># 指定模板，只显示 ID 和 Names</span></span><br><span class="line">docker ps --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-inspect-查看容器信息"><code>docker inspect</code> : 查看容器信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器信息</span></span><br><span class="line">docker inspect &lt;container_id&gt;</span><br><span class="line"><span class="comment"># 获取容器名称</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器镜像</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器状态，前面的 json 表示输出为 json 格式</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .State&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器内存限制</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器label</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的网络信息</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .NetworkSettings&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-logs-获取容器日志"><code>docker logs</code> : 获取容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取容器日志</span></span><br><span class="line">docker logs &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器实时日志</span></span><br><span class="line">docker logs -f &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器最新的 10 行日志</span></span><br><span class="line">docker logs -n 10 &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的带时间戳的日志</span></span><br><span class="line">docker logs -t &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的日志，从 1 小时前开始</span></span><br><span class="line">docker logs --since 1h &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的日志，直到 1 小时前</span></span><br><span class="line">docker logs --<span class="keyword">until</span> 1h &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的详细日志</span></span><br><span class="line">docker logs --details &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 获取容器的日志，从 2 小时前开始，直到 1 小时前</span></span><br><span class="line">docker logs --since 2h --<span class="keyword">until</span> 1h &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-exec-在已经运行的容器中执行命令"><code>docker exec</code> : 在已经运行的容器中执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在已经运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> &lt;container_id | container_name&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment"># 进入容器shell</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_id | container_name&gt; bash</span><br></pre></td></tr></table></figure><h3 id="docker-rename-重命名容器"><code>docker rename</code> : 重命名容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename &lt;old_container_name&gt; &lt;new_container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-cp-容器与宿主机间复制文件"><code>docker cp</code> : 容器与宿主机间复制文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宿主机 -&gt; 容器</span></span><br><span class="line"><span class="comment"># docker cp &lt;host_path&gt; &lt;container_id | container_name&gt;:&lt;container_path&gt;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./docker-command-container.md nginx:/tmp</span><br><span class="line"><span class="comment"># 容器 -&gt; 宿主机</span></span><br><span class="line"><span class="comment"># docker cp &lt;container_id | container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;</span></span><br><span class="line">docker <span class="built_in">cp</span> nginx:/tmp/docker-command-container.md ./</span><br></pre></td></tr></table></figure><h3 id="docker-rm-删除容器"><code>docker rm</code> : 删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="docker-container-prune-删除所有停止的容器"><code>docker container prune</code> : 删除所有停止的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h3 id="docker-update-更新容器配置"><code>docker update</code> : 更新容器配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新指定容器的CPU核数和内存大小</span></span><br><span class="line">docker update --cpus=2 --memory=2g &lt;container_id | container_name&gt;</span><br><span class="line"><span class="comment"># 更新指定容器自动重启</span></span><br><span class="line">docker update --restart=always &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>并不是所有的配置都支持更新，update 命令只支持如下配置，基本上也就只能调一下cpu和内存，以及自动重启策略，所以制作容器时一定要做好规划。</p></li></ul><table><thead><tr><th>参数名</th><th>说明</th><th>示例值</th></tr></thead><tbody><tr><td><code>--blkio-weight</code></td><td>设置 Block IO 的相对权重，范围是 10 到 1000，设置为 0 表示禁用（默认值为 0）</td><td><code>--blkio-weight=500</code></td></tr><tr><td><code>--cpu-period</code></td><td>设置 CPU CFS（完全公平调度器）的周期限制（单位：微秒）</td><td><code>--cpu-period=100000</code></td></tr><tr><td><code>--cpu-quota</code></td><td>设置 CPU CFS 的配额限制（单位：微秒）</td><td><code>--cpu-quota=50000</code></td></tr><tr><td><code>--cpu-rt-period</code></td><td>设置实时 CPU 的调度周期（单位：微秒）</td><td><code>--cpu-rt-period=1000000</code></td></tr><tr><td><code>--cpu-rt-runtime</code></td><td>设置实时 CPU 的运行时间限制（单位：微秒）</td><td><code>--cpu-rt-runtime=950000</code></td></tr><tr><td><code>-c</code>, <code>--cpu-shares</code></td><td>设置 CPU 共享权重，默认值为 1024</td><td><code>--cpu-shares=512</code></td></tr><tr><td><code>--cpus</code></td><td>限制容器使用的 CPU 数量（支持小数）</td><td><code>--cpus=1.5</code></td></tr><tr><td><code>--cpuset-cpus</code></td><td>指定容器可以在哪些 CPU 上运行（如 0-3、0,1）</td><td><code>--cpuset-cpus=&quot;0,1&quot;</code></td></tr><tr><td><code>--cpuset-mems</code></td><td>指定容器可以使用哪些内存节点（如 0-3、0,1），适用于 NUMA 系统</td><td><code>--cpuset-mems=&quot;0&quot;</code></td></tr><tr><td><code>-m</code>, <code>--memory</code></td><td>设置内存限制（例如 512m、2g）</td><td><code>--memory=1g</code></td></tr><tr><td><code>--memory-reservation</code></td><td>设置内存软限制（低于 <code>--memory</code> 的值时，允许系统在压力较小时回收）</td><td><code>--memory-reservation=512m</code></td></tr><tr><td><code>--memory-swap</code></td><td>设置 swap 限制（内存 + swap 总和），设为 -1 表示无限制</td><td><code>--memory-swap=2g</code></td></tr><tr><td><code>--pids-limit</code></td><td>设置容器的最大进程数量，设为 -1 表示无限制</td><td><code>--pids-limit=100</code></td></tr><tr><td><code>--restart</code></td><td>设置容器退出后的重启策略</td><td><code>--restart=always</code></td></tr></tbody></table><h3 id="docker-stats-显示容器的实时资源使用情况"><code>docker stats</code> : 显示容器的实时资源使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有容器的实时资源使用情况</span></span><br><span class="line">docker stats</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">CONTAINER ID   NAME         CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O     PIDS</span><br><span class="line">15caf520e3a5   nginx        0.00%     10.22MiB / 7.752GiB   0.13%     6.38kB / 2.61kB   0B / 28.7kB   13</span><br><span class="line">b680087420b8   dockge       0.01%     199.5MiB / 7.752GiB   2.51%     6.44kB / 1.48kB   94.8MB / 0B   24</span><br><span class="line">861dd9c1475f   remote-api   0.00%     4.188MiB / 7.752GiB   0.05%     2.77kB / 126B     3.31MB / 0B   1</span><br><span class="line"><span class="comment">### CONTAINER ID 与 NAME：容器 ID 与名称。</span></span><br><span class="line"><span class="comment">### CPU % 与 MEM %：容器使用的 CPU 和内存的百分比。</span></span><br><span class="line"><span class="comment">### MEM USAGE / LIMIT：容器正在使用的总内存，以及允许使用的内存总量。</span></span><br><span class="line"><span class="comment">### NET I/O：容器通过其网络接口发送和接收的数据量。</span></span><br><span class="line"><span class="comment">### BLOCK I/O：容器从主机上的块设备读取和写入的数据量。</span></span><br><span class="line"><span class="comment">### PIDs：容器创建的进程或线程数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有容器的资源使用情况，包括运行和停止的</span></span><br><span class="line">docker stats -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示当前状态就直接退出了，不再实时更新。</span></span><br><span class="line">docker stats --no-stream</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出模板，这里加不加 table 都可以</span></span><br><span class="line">docker stats --no-stream --format <span class="string">&quot;table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出json格式</span></span><br><span class="line">docker stats --no-stream --format json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器</span></span><br><span class="line">docker stats &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-top-查看正在运行的进程"><code>docker top</code> :  查看正在运行的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker top &lt;container_id | container_name&gt; [ps options]</span></span><br><span class="line">docker top nginx</span><br></pre></td></tr></table></figure><h3 id="docker-port-列出指定的容器的端口映射"><code>docker port</code> : 列出指定的容器的端口映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker port &lt;container_id | container_name&gt;</span></span><br><span class="line">$ docker port nginx</span><br><span class="line">80/tcp -&gt; 0.0.0.0:8081</span><br></pre></td></tr></table></figure><h3 id="docker-diff-列出容器运行时对文件系统的修改"><code>docker diff</code> : 列出容器运行时对文件系统的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker diff &lt;container_id | container_name&gt;</span></span><br><span class="line">$ docker diff nginx</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/demo.py</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">C /etc</span><br><span class="line">C /etc/nginx</span><br><span class="line">C /etc/nginx/conf.d</span><br><span class="line">C /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>前缀含义说明：</p></li></ul><table><thead><tr><th>标志</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>A</code></td><td><strong>Added（新增）</strong></td><td>文件或目录是容器运行后新增的</td></tr><tr><td><code>C</code></td><td><strong>Changed（修改）</strong></td><td>文件或目录是已有的，但内容或元数据（如权限、时间戳等）被修改了</td></tr><tr><td><code>D</code></td><td><strong>Deleted（删除）</strong></td><td>文件或目录是存在于原镜像中的，但在容器中被删除</td></tr></tbody></table><h3 id="docker-commit-从容器创建一个新的镜像"><code>docker commit</code> : 从容器创建一个新的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker commit &lt;container_id | container_name&gt; [image_name[:tag]]</span></span><br><span class="line">docker commit nginx nginx:v1.0</span><br></pre></td></tr></table></figure><h3 id="docker-export-导出容器内容为-tar-文件"><code>docker export</code> : 导出容器内容为 tar 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> nginx &gt; nginx.tar</span><br><span class="line">dcoker <span class="built_in">export</span> -o nginx.tar nginx</span><br><span class="line">docker <span class="built_in">export</span> nginx | gzip &gt; nginx.tar.gz</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Docker Export / Save / Commit 命令对比与导入方式一览表</p></li></ul><table><thead><tr><th>命令</th><th>操作对象</th><th>输出内容</th><th>是否包含历史层（镜像层）</th><th>是否保留元数据（标签、命令等）</th><th>典型用途</th><th>导入命令</th></tr></thead><tbody><tr><td><code>docker export</code></td><td><strong>容器</strong></td><td>容器的文件系统（tar 归档）</td><td>❌ 否</td><td>❌ 否</td><td>备份容器文件系统或迁移容器状态</td><td><code>docker import &lt;tar&gt; &lt;image:tag&gt;</code></td></tr><tr><td><code>docker save</code></td><td><strong>镜像</strong></td><td>镜像的完整内容（含所有层的 tar）</td><td>✅ 是</td><td>✅ 是</td><td>分发或备份镜像</td><td><code>docker load &lt; &lt;tar&gt;</code></td></tr><tr><td><code>docker commit</code></td><td><strong>容器</strong></td><td>创建一个新的镜像</td><td>✅ 是（但只一层）</td><td>✅ 是</td><td>将当前容器状态打包成新镜像</td><td>不适用（直接生成镜像）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 容器管理 相关命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 Dockerfile</title>
    <link href="https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/"/>
    <id>https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/</id>
    <published>2025-05-26T13:30:05.000Z</published>
    <updated>2025-06-12T06:02:38.760Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 Dockerfile 的使用方法</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile官方文档</a></p></li></ul><span id="more"></span><h2 id="Dockerfile-是什么？">Dockerfile 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker可以通过读取 <code>Dockerfile</code> 中的指令来自动构建镜像。</p></li><li class="lvl-2"><p><code>Dockerfile</code> 是一个文本文档，其中包含用户可以在命令行上调用以组装镜像的所有指令。</p></li><li class="lvl-2"><p>可以在Dockerfile中使用的指令：</p></li></ul><table><thead><tr><th>指令</th><th>中文描述</th></tr></thead><tbody><tr><td><strong>ADD</strong></td><td>将本地或远程的文件/目录添加到镜像中，支持自动解压 <code>.tar</code> 文件和使用 URL 下载远程资源。通常推荐使用 <code>COPY</code>，除非需要这些高级功能。</td></tr><tr><td><strong>ARG</strong></td><td>定义构建阶段使用的变量，可在 <code>docker build</code> 命令中通过 <code>--build-arg</code> 传入，变量仅在构建时有效，不会保留在最终镜像中。</td></tr><tr><td><strong>CMD</strong></td><td>指定容器默认执行的命令和参数，容器运行时若未指定命令，则使用该指令设置的命令。如果配置了多个<code>CMD</code>，则只有最后一个生效。和<code>ENTRYPOINT</code>共同使用时，作为传递给<code>ENTRYPOINT</code>的参数。可被 <code>docker run</code> 提供的命令覆盖。</td></tr><tr><td><strong>COPY</strong></td><td>将构建上下文中的文件或目录复制到镜像中。相比 <code>ADD</code> 更简单、安全，推荐优先使用。</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td>指定容器启动时的主命令，不容易被 <code>docker run</code> 中的命令覆盖。可与 <code>CMD</code> 配合使用，用于提供默认参数。</td></tr><tr><td><strong>ENV</strong></td><td>设置环境变量，变量将在构建和容器运行时均可使用。例如：配置应用参数或系统路径等。</td></tr><tr><td><strong>EXPOSE</strong></td><td>声明容器运行时将开放的端口，仅用于文档说明或与容器编排工具配合，不会自动进行端口映射。</td></tr><tr><td><strong>FROM</strong></td><td>指定基础镜像，是 Dockerfile 的起点。也可以用于多阶段构建，通过多次使用 <code>FROM</code> 指令创建多个构建阶段。</td></tr><tr><td><strong>HEALTHCHECK</strong></td><td>定义容器健康检查命令，用于定期检测容器内部服务的健康状态，可结合容器编排系统实现故障自动恢复。</td></tr><tr><td><strong>LABEL</strong></td><td>为镜像添加键值对形式的元数据，例如版本、维护者、用途说明等，方便镜像管理与自动化处理。</td></tr><tr><td><strong>MAINTAINER</strong></td><td>（已弃用）用于指定镜像维护者信息，推荐改用 <code>LABEL</code> 来设置作者信息。</td></tr><tr><td><strong>ONBUILD</strong></td><td>定义一个触发指令，当当前镜像作为基础镜像被其他 Dockerfile 使用时自动执行。常用于基础镜像的预设行为。</td></tr><tr><td><strong>RUN</strong></td><td>执行一条命令并提交结果作为新镜像层，常用于安装软件包、复制文件、设置权限等构建操作。</td></tr><tr><td><strong>SHELL</strong></td><td>更改 Dockerfile 中后续 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 等指令的默认 shell（如使用 <code>sh</code> 或 <code>powershell</code>）。</td></tr><tr><td><strong>STOPSIGNAL</strong></td><td>设置容器终止时发送的系统信号（如 <code>SIGTERM</code>），用于优雅关闭应用。</td></tr><tr><td><strong>USER</strong></td><td>设置执行后续命令时所使用的用户和用户组，增强容器的安全性，避免使用 root 权限。</td></tr><tr><td><strong>VOLUME</strong></td><td>定义容器内的挂载点，用于持久化数据或与宿主机/其他容器共享数据。运行容器时可指定挂载路径。</td></tr><tr><td><strong>WORKDIR</strong></td><td>设置工作目录，相当于执行 <code>cd</code>，用于简化后续命令中的路径。若目录不存在则自动创建。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>构建阶段指令：FROM, ARG, ENV, COPY, ADD, RUN, WORKDIR, LABEL, USER, SHELL, ONBUILD</p></li><li class="lvl-2"><p>启动配置指令：CMD, ENTRYPOINT, HEALTHCHECK, EXPOSE, VOLUME, STOPSIGNAL</p></li></ul><h2 id="Dockerfile-指令介绍">Dockerfile 指令介绍</h2><h3 id="FROM">FROM</h3><ul class="lvl-0"><li class="lvl-2"><p>FROM 指令用于指定基础镜像（base image），是每一个 Dockerfile 中必须的第一条指令。所有后续指令都是基于这个基础镜像构建的。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;stage-name&gt;]</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;image&gt;：镜像名称（可以是本地已有的，也可以是从 Docker Hub 或其他镜像仓库拉取的）</span></span><br><span class="line"><span class="comment">#   [:&lt;tag&gt;]：镜像标签（可选，默认是 latest）</span></span><br><span class="line"><span class="comment">#   [AS &lt;stage-name&gt;]：为该构建阶段指定名称，用于多阶段构建</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用最新版本的镜像（默认标签是 latest）</span></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="comment"># 使用指定的标签</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">16.13</span>.<span class="number">2</span>-alpine</span><br><span class="line"><span class="comment"># 使用私有镜像仓库</span></span><br><span class="line"><span class="keyword">FROM</span> private.registry.com/my-image:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用多阶段构建</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.20</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp /usr/local/bin/myapp</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;myapp&quot;</span>]</span></span><br><span class="line"><span class="comment">## 这里用了两个阶段：</span></span><br><span class="line"><span class="comment">###   builder 阶段用来编译应用；</span></span><br><span class="line"><span class="comment">###   alpine 阶段用来打包最终镜像，只包含编译好的二进制文件，减少体积。</span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR">WORKDIR</h3><ul class="lvl-0"><li class="lvl-2"><p>WORKDIR 指定了工作目录，即后续所有指令（如 RUN、CMD、ENTRYPOINT、COPY、ADD 等）所运行的当前路径（working directory）。</p></li><li class="lvl-2"><p>如果目录不存在，Docker 会自动创建它。</p></li><li class="lvl-2"><p>每个 WORKDIR 都会创建一层镜像（layer），所以不要重复设置无意义的路径。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;path&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;path&gt;：要切换的工作目录，可以是绝对路径或相对路径。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置绝对路径</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续设置多个工作目录（逐层嵌套）</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /var</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> www</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> html</span></span><br><span class="line"><span class="comment"># 等同于:</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /var/www/html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免在 RUN cd some_dir 后继续执行依赖路径的命令，因为 Docker 每一条指令都是新的 shell 实例，cd 不会跨指令保留，应该改用 WORKDIR。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> some_dir  <span class="comment"># 错误</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> some_dir <span class="comment"># 正确</span></span></span><br></pre></td></tr></table></figure><h3 id="ARG">ARG</h3><ul class="lvl-0"><li class="lvl-2"><p>ARG 用于在 构建镜像时（build-time）传入参数。这些参数只在 构建阶段有效，不会出现在最终镜像中，也不会在容器运行时被保留。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default_value&gt;]</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;name&gt;：参数名称</span></span><br><span class="line"><span class="comment">#   [=&lt;default_value&gt;]：参数的默认值，如果未传入参数，则使用默认值，如果为设置default_value，则构建镜像时必须传递参数，--build-arg</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个参数，在构建镜像时必须传入参数，--build-arg APP_ENV=development</span></span><br><span class="line"><span class="keyword">ARG</span> APP_ENV</span><br><span class="line"><span class="comment"># 带默认值的 ARG</span></span><br><span class="line"><span class="keyword">ARG</span> APP_ENV=development</span><br><span class="line"><span class="comment"># 使用参数</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;当前环境：<span class="variable">$&#123;APP_ENV&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 FROM 一起用（从 Docker 17.05 起）</span></span><br><span class="line"><span class="keyword">ARG</span> BASE=ubuntu</span><br><span class="line"><span class="keyword">FROM</span> $&#123;BASE&#125;:<span class="number">22.04</span></span><br></pre></td></tr></table></figure><h3 id="ENV">ENV</h3><ul class="lvl-0"><li class="lvl-2"><p>ENV 指令用于在镜像构建过程中定义环境变量（Environment Variables）。这些变量可以在之后的构建步骤（比如 RUN、CMD 等）中使用，也会在容器运行时生效。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种语法</span></span><br><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;key&gt;：环境变量的名称</span></span><br><span class="line"><span class="comment">#   &lt;value&gt;：环境变量的值</span></span><br><span class="line"><span class="comment"># 如果定义多个变量，推荐使用 key=value 的形式。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> APP_ENV=production</span><br><span class="line"><span class="comment"># 定义多个变量</span></span><br><span class="line"><span class="keyword">ENV</span> APP_PORT=<span class="number">8080</span> NODE_ENV=production</span><br><span class="line"><span class="comment"># 使用多行格式（提高可读性）</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/usr/local/bin:$&#123;PATH&#125;&quot;</span> \</span><br><span class="line">    LANG=<span class="string">&quot;en_US.UTF-8&quot;</span> \</span><br><span class="line">    TZ=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="comment"># 也可以分开定义</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/usr/local/bin:$PATH&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>注意：ENV 指令定义的环境变量在构建阶段和运行阶段都会生效，但运行阶段会覆盖构建阶段定义的变量。</p></li></ul><h3 id="LABEL">LABEL</h3><ul class="lvl-0"><li class="lvl-2"><p>LABEL 用于为镜像添加元数据标签，以 <code>key=value</code> 的形式存在。这些标签可以是作者信息、版本描述、用途说明、构建时间等。</p></li><li class="lvl-2"><p>旧的 <code>MAINTAINER</code> 指令现在已被废弃，推荐使用 <code>LABEL</code> 来代替。</p></li><li class="lvl-2"><p>每个 LABEL 都会创建一层镜像（layer），推荐一次设置多个。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt;...]</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;key&gt;：标签的键</span></span><br><span class="line"><span class="comment">#   &lt;value&gt;：标签的值</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个标签</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;yourname@example.com&quot;</span></span></span><br><span class="line"><span class="comment"># 换行格式（推荐）,以下标签符合 OCI（Open Container Initiative） 镜像规范</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.title=<span class="string">&quot;MyApp&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.description=<span class="string">&quot;演示项目&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.version=<span class="string">&quot;1.0.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.opencontainers.image.authors=<span class="string">&quot;zhangsan@example.com&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="USER">USER</h3><ul class="lvl-0"><li class="lvl-2"><p>USER 指令用于指定后续指令（如 RUN、CMD、ENTRYPOINT、COPY 等）以哪个用户身份来执行。</p></li><li class="lvl-2"><p>默认情况下，Docker 容器中的命令以 root 用户运行，这虽然灵活但不安全。使用 USER 可以让我们切换到普通用户，从而提升容器的安全性，防止潜在的权限滥用。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;user&gt;：用户名或 UID</span></span><br><span class="line"><span class="comment">#   [:&lt;group&gt;]：可选，用户组名或 GID</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置用户</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br><span class="line"><span class="comment"># 设置用户组</span></span><br><span class="line"><span class="keyword">USER</span> appuser:appgroup</span><br><span class="line"><span class="comment"># 使用 UID 和 GID</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span>:<span class="number">1000</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果基础镜像中没有你想要的用户，需要在 Dockerfile 中手动创建</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户和组</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r appgroup &amp;&amp; useradd -r -g appgroup appuser</span></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br></pre></td></tr></table></figure><h3 id="ADD">ADD</h3><ul class="lvl-0"><li class="lvl-2"><p>ADD 用于将本地文件或目录、远程文件（URL） 或 压缩包 复制到镜像中的指定位置。</p></li><li class="lvl-2"><p>它的功能类似于 COPY，但比 COPY 多几个功能（解压、拉取远程文件等）。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;src&gt;：要复制的文件或目录，可以是本地文件、远程 URL、压缩包等</span></span><br><span class="line"><span class="comment">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从本地文件复制</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app.jar /app.jar</span></span><br><span class="line"><span class="comment"># 复制多个</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app1.jar app2.jar /app/</span></span><br><span class="line"><span class="comment"># 通配符</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> static-assets/*.html /app/public/</span></span><br><span class="line"><span class="comment"># 从远程 URL 复制</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/app.jar /app.jar</span></span><br><span class="line"><span class="comment"># 从压缩包中复制</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> static-assets.tar.gz /app/public/</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>最佳实践是优先使用 COPY，只有在需要 ADD 的额外功能时才使用它。</p></li></ul><h3 id="COPY">COPY</h3><ul class="lvl-0"><li class="lvl-2"><p>COPY 指令用于将主机上的文件或目录复制到镜像的文件系统中。它是构建镜像过程中最常用的数据引入方式之一。</p></li><li class="lvl-2"><p>与 ADD 类似，但功能更简单、明确、安全</p></li><li class="lvl-2"><p>推荐优先使用 COPY，除非你确实需要 ADD 提供的自动解压或远程下载功能。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;src&gt;：要复制的文件或目录</span></span><br><span class="line"><span class="comment">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制单个文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.jar /app.jar</span></span><br><span class="line"><span class="comment"># 复制多个文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app1.jar app2.jar /app/</span></span><br><span class="line"><span class="comment"># 复制目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> static-assets/ /app/public/</span></span><br><span class="line"><span class="comment"># 通配符</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> static-assets/*.html /app/public/</span></span><br><span class="line"><span class="comment"># 设置目标文件属主属组</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=appuser:appgroup app.jar /app.jar</span></span><br></pre></td></tr></table></figure><h3 id="RUN">RUN</h3><ul class="lvl-0"><li class="lvl-2"><p>RUN 指令用于在镜像构建阶段执行命令，结果会被打包进镜像层中。</p></li><li class="lvl-2"><p>它可以用于安装依赖、编译代码、运行命令等。</p></li><li class="lvl-2"><p>每一条 RUN 指令会创建一层镜像（layer）,合并多个命令成一条 RUN，可以减少镜像层数（例如使用 &amp;&amp; 串联）。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种格式：实际运行的是：/bin/sh -c &quot;&lt;命令字符串&gt;&quot;</span></span><br><span class="line">RUN &lt;命令字符串&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种格式</span></span><br><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>, ...]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令字符串</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class="line"><span class="comment"># 构建多个命令(用 &amp;&amp; 串联)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y python3 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件参数</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;curl https://example.com/app.jar &gt; app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="CMD">CMD</h3><ul class="lvl-0"><li class="lvl-2"><p>CMD 用于指定容器启动时默认执行的命令及其参数。</p></li><li class="lvl-2"><p>如果用户在运行容器时没有手动指定其他命令，Docker 就会使用 CMD 提供的内容。</p></li><li class="lvl-2"><p>它可以定义多个，但只有最后一个会被使用。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Shell 形式（字符串）</span></span><br><span class="line">CMD <span class="built_in">command</span> param1 param2</span><br><span class="line"><span class="comment"># 等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exec 形式（数组）</span></span><br><span class="line">CMD [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单 shell 命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello from container&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exec 形式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为 ENTRYPOINT 的参数</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--host=0.0.0.0&quot;</span>, <span class="string">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>用户可以覆盖 CMD：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;myapp&gt; npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT">ENTRYPOINT</h3><ul class="lvl-0"><li class="lvl-2"><p>ENTRYPOINT 定义容器启动时执行的主命令，相比 CMD，它不容易被覆盖，更适合制作“专用型”容器（如 nginx、python 脚本等）。</p></li><li class="lvl-2"><p>你可以把 ENTRYPOINT 理解为容器的“主程序”，而 CMD 是为它提供的默认“命令行参数”。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Shell 形式（字符串）</span></span><br><span class="line">ENTRYPOINT <span class="built_in">command</span> param1 param2</span><br><span class="line"><span class="comment">#  等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exec 形式（数组）</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单 shell 命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello from container&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exec 形式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合 CMD 使用</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--host=0.0.0.0&quot;</span>, <span class="string">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="EXPOSE">EXPOSE</h3><ul class="lvl-0"><li class="lvl-2"><p>EXPOSE 用于声明容器将会监听的端口，让使用该镜像的人知道应该对外开放哪些端口。</p></li><li class="lvl-2"><p>⚠️ 注意：EXPOSE 并不会真的开放端口，只是“声明”这个容器监听了这些端口。</p></li><li class="lvl-2"><p>要让端口真正暴露出来，还需要在运行容器时加上 <code>-p</code> 或 <code>--publish</code> 参数。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment">#   &lt;port&gt;：端口号，可以是单个端口号，也可以是范围（如 8080-8085）</span></span><br><span class="line"><span class="comment">#   &lt;protocol&gt;：协议，可以是 tcp 或 udp，默认为 tcp</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span>/udp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span>-<span class="number">8085</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span> <span class="number">8081</span> <span class="number">8082</span> <span class="number">8083</span> <span class="number">8084</span> <span class="number">8085</span></span><br></pre></td></tr></table></figure><h3 id="VOLUME">VOLUME</h3><ul class="lvl-0"><li class="lvl-2"><p>VOLUME 指令用于声明一个或多个容器中的挂载点（mount point），用于持久化数据或与宿主机/其他容器共享数据。</p></li><li class="lvl-2"><p>语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">&quot;/path/in/container&quot;</span>, ...]</span><br><span class="line"><span class="comment"># 路径必须是容器内部的绝对路径</span></span><br><span class="line"><span class="comment"># 可以一次声明一个，也可以是多个。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个挂载点</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /app/public</span></span><br><span class="line"><span class="comment"># 声明多个挂载点</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/public&quot;</span>, <span class="string">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>当容器运行时，可以将镜像中声明的挂载点映射到宿主机上，从而实现持久化数据。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /host/path:/app/public myimage</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果你没有手动绑定挂载，Docker 会自动创建一个匿名卷，卷的内容默认保存在宿主机的 <code>/var/lib/docker/volumes</code> 下。</p></li></ul><h3 id="HEALTHCHECK">HEALTHCHECK</h3><ul class="lvl-0"><li class="lvl-2"><p>HEALTHCHECK 用来定义容器运行时的健康检查命令，定期检测容器内服务的状态，帮助编排工具（Docker Swarm、Kubernetes 等）判断容器是否健康。</p></li><li class="lvl-2"><p>如果健康检查失败，Docker 会将容器标记为 unhealthy，便于自动重启或替换。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK &lt;options&gt; CMD &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># &lt;options&gt;：可选项，用于设置健康检查的选项，如超时时间、重试次数等。</span></span><br><span class="line"><span class="comment"># &lt;command&gt;：健康检查命令，可以是任何有效的 shell 命令。</span></span><br><span class="line">            <span class="comment"># 必须返回退出码:</span></span><br><span class="line">              <span class="comment"># 0 表示健康</span></span><br><span class="line">              <span class="comment"># 1 表示不健康</span></span><br><span class="line">              <span class="comment"># 2 表示未知</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可选参数（OPTIONS）</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>--interval=DURATION</code></td><td>两次健康检查之间的时间间隔</td><td>30s</td></tr><tr><td><code>--timeout=DURATION</code></td><td>单次检测命令的超时时间</td><td>30s</td></tr><tr><td><code>--start-period=DURATION</code></td><td>容器启动后，开始健康检查前的等待时间</td><td>0s</td></tr><tr><td><code>--retries=N</code></td><td>连续失败几次后判定容器不健康</td><td>3</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 curl 检测 Web 服务是否响应</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s --retries=3 CMD curl -f http://localhost:8080/health || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行容器后，可以用命令查看健康状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果镜像中有健康检查，可以查看容器状态（STATUS）</span></span><br><span class="line">docker ps</span><br><span class="line">  <span class="comment"># STATUS 列会显示：</span></span><br><span class="line">  <span class="comment">#   healthy</span></span><br><span class="line">  <span class="comment">#   unhealthy</span></span><br><span class="line">  <span class="comment">#   starting（启动中）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看更详细的信息</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure><h3 id="SHELL">SHELL</h3><ul class="lvl-0"><li class="lvl-2"><p>SHELL 指令用来自定义后续 RUN、CMD 和 ENTRYPOINT 指令所使用的默认 shell 程序和参数。</p></li><li class="lvl-2"><p>默认情况下：</p><ul class="lvl-2"><li class="lvl-4">在 Linux 镜像中，Docker 使用 /bin/sh -c</li><li class="lvl-4">在 Windows 镜像中，使用 cmd /S /C</li></ul></li><li class="lvl-2"><p>使用 SHELL，你可以替换为其他 shell，如 Bash、PowerShell、zsh 等。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 bash</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多次切换</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello from Bash&quot;</span> <span class="comment"># 在 Bash 中执行</span></span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Now back to sh&quot;</span> <span class="comment">#  在 sh 中执行</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-Command&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="STOPSIGNAL">STOPSIGNAL</h3><ul class="lvl-0"><li class="lvl-2"><p>STOPSIGNAL 指定当容器收到 <code>docker stop</code> 命令时，发送给容器主进程的信号类型。</p></li><li class="lvl-2"><p>默认情况下，Docker 会向容器的主进程发送 <code>SIGTERM</code> 信号，让它有机会优雅地退出（在超时时未退出则发 <code>SIGKILL</code> 强制终止）。</p></li><li class="lvl-2"><p>默认情况，大多数程序（如 nginx），不需要设置（默认 SIGTERM）</p></li><li class="lvl-2"><p>但有些程序可能需要使用不同的信号，比如 SIGINT、SIGHUP，这时你可以通过 STOPSIGNAL 来修改。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL &lt;signal&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 其中 &lt;signal&gt; 可以是：</span></span><br><span class="line"><span class="comment">#   信号名称，例如：SIGTERM、SIGKILL、SIGINT、SIGHUP</span></span><br><span class="line"><span class="comment">#   或信号编号，例如：15（等价于 SIGTERM）</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是默认行为，不写也一样。</span></span><br><span class="line"><span class="keyword">STOPSIGNAL</span> SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为 SIGINT</span></span><br><span class="line"><span class="keyword">STOPSIGNAL</span> SIGINT</span><br></pre></td></tr></table></figure><h3 id="ONBUILD">ONBUILD</h3><ul class="lvl-0"><li class="lvl-2"><p>ONBUILD 用于定义延迟执行的构建指令，即这些命令不会在当前 Dockerfile 构建时执行，而是在 以当前镜像为基础的子镜像中构建时触发执行。</p></li><li class="lvl-2"><p>它的典型用途是：构建一个“通用基础镜像”，让使用者在自己的 Dockerfile 中 FROM 它时自动继承一些操作（比如 COPY、RUN 等）。</p></li><li class="lvl-2"><p>ONBUILD 是一种设计模式，方便基础镜像作者预先定义“未来子镜像构建时一定要执行的步骤”，而不是在基础镜像中“硬编码”那些步骤。</p></li><li class="lvl-2"><p>语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;INSTRUCTION&gt;</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># &lt;INSTRUCTION&gt;：必须是一个合法的 Dockerfile 指令，如 RUN、COPY、ADD、CMD 等（但不能是 FROM, ONBUILD, HEALTHCHECK 等）。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像中使用 ONBUILD</span></span><br><span class="line"><span class="comment"># 文件：Dockerfile.base</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建基础镜像</span></span><br><span class="line">docker build -t my-node-base -f Dockerfile.base .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用基础镜像构建子镜像</span></span><br><span class="line"><span class="comment"># 文件：Dockerfile（子镜像）</span></span><br><span class="line"><span class="keyword">FROM</span> my-node-base</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;index.js&quot;</span>]</span></span><br><span class="line"><span class="comment"># 构建子镜像时，等于自动插入了：</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ONBUILD 是一种“构建钩子”机制</p><ul class="lvl-2"><li class="lvl-4">ONBUILD 可以理解成“钩子”或“触发器”：<ul class="lvl-4"><li class="lvl-6">在基础镜像构建时不执行</li><li class="lvl-6">但当某人以这个基础镜像为起点写自己的 Dockerfile，并构建时，这些 ONBUILD 里的指令自动插入执行</li></ul></li><li class="lvl-4">这样：<ul class="lvl-4"><li class="lvl-6">基础镜像只负责定义环境（node、npm版本、系统依赖等），保持轻量</li><li class="lvl-6">下游项目可以不用写重复的代码复制和安装指令，自动继承基础镜像预定义的构建步骤</li><li class="lvl-6">代码复制和依赖安装在下游镜像构建时执行，使用自己的上下文（也就是项目代码）</li></ul></li></ul></li><li class="lvl-2"><p><code>ONBUILD</code> 总结</p></li></ul><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>⏱ 延迟执行</td><td>构建基础镜像时不会执行，在子镜像构建时触发</td></tr><tr><td>✅ 支持指令</td><td>例如 <code>RUN</code>, <code>COPY</code>, <code>ADD</code>, <code>CMD</code>, <code>WORKDIR</code>, <code>ENV</code> 等</td></tr><tr><td>❌ 不支持</td><td><code>FROM</code>, <code>ONBUILD</code>, <code>HEALTHCHECK</code>, <code>SHELL</code>, <code>STOPSIGNAL</code></td></tr><tr><td>👎 不推荐滥用</td><td>会隐藏构建行为，降低可维护性</td></tr><tr><td>✅ 推荐场景</td><td>团队共享模板、构建“标准开发镜像”</td></tr></tbody></table><h2 id="Dockerfile-哪些-指令-会创建新的层">Dockerfile 哪些 指令 会创建新的层</h2><ul class="lvl-0"><li class="lvl-2"><p>当 Dockerfile 中创建新层的指令内容发生变化时，使用 <code>--no-cache</code> 选项可以确保这些变更被正确应用。</p></li></ul><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>ADD</td><td>从 <src> 复制文件并自动解压（如果是一个 tar 文件）到容器的 <dest> 路径。</td></tr><tr><td>COPY</td><td>从 <src> 复制文件到容器的 <dest> 路径，不会自动解压。</td></tr><tr><td>RUN</td><td>执行任意命令并在容器中做出更改。每条 RUN 指令都会创建一个新的层。</td></tr><tr><td>ENV</td><td>设置环境变量。每一行 ENV 指令都会创建一个新的层。</td></tr><tr><td>WORKDIR</td><td>设置工作目录。每一行 WORKDIR 指令都会创建一个新的层。</td></tr><tr><td>VOLUME</td><td>创建一个挂载点。每一行 VOLUME 指令都会创建一个新的层。</td></tr><tr><td>LABEL</td><td>添加元数据标签。每一行 LABEL 指令都会创建一个新的层。</td></tr></tbody></table><h2 id="Dockerfile-示例-Spring-Boot-应用">Dockerfile 示例: Spring Boot 应用</h2><ul class="lvl-0"><li class="lvl-2"><p>目录结构</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">springbootweb/</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── target/</span><br><span class="line">│   └── app.jar</span><br><span class="line">├── <span class="type">static</span>-assets.tar.gz</span><br><span class="line">└── ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Dockerfile: 注意 Dockerfile 中所有关键字都要求大写</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像元信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;yourname@example.com&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 RUN：安装 curl（用于容器健康检查或调试）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压静态资源到容器中（ADD 可以自动解压 tar.gz）</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> static-assets.tar.gz /app/public/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器健康检查：访问 actuator 健康端点</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=30s --<span class="built_in">timeout</span>=5s --retries=3 \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/app/actuator/health || <span class="built_in">exit</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器终止时优雅关闭（Java 推荐 SIGTERM）</span></span><br><span class="line"><span class="keyword">STOPSIGNAL</span> SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像时用 --build-arg 指定构建参数，如果需要多个，就配置多个 --build-arg</span></span><br><span class="line">docker build --build-arg JAR_FILE=target/app.jar -t springbootweb:latest .</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name springbootweb \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -e JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx1024m&quot;</span> \</span><br><span class="line">  -v /home/centos/logs/app/:/app/logs \</span><br><span class="line">  springbootweb:latest</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-示例-多阶段构建">Dockerfile 示例: 多阶段构建</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：获取代码</span></span><br><span class="line"><span class="keyword">FROM</span> alpine/git AS fetcher</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class="line"><span class="keyword">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class="line"><span class="keyword">ARG</span> GIT_BRANCH=master</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> -b <span class="variable">$&#123;GIT_BRANCH&#125;</span> <span class="variable">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：使用Maven环境进行构建</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.8</span>.<span class="number">4</span>-openjdk-<span class="number">17</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 从第一阶段复制代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=fetcher /workspace/application .</span></span><br><span class="line"><span class="comment"># 使用Maven清理并打包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三阶段：创建最终的运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="comment"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class="line"><span class="comment"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建</span></span><br><span class="line">docker build --no-cache -t app:latest .</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name app \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -e JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx1024m&quot;</span> \</span><br><span class="line">  -v /home/centos/logs/app/:/app/logs \</span><br><span class="line">  app:latest</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-语法检测">Dockerfile 语法检测</h2><ul class="lvl-0"><li class="lvl-2"><p>在线检查：<a href="https://hadolint.github.io/hadolint/">Dockerfile Linter</a></p></li><li class="lvl-2"><p>本地检查：<a href="https://github.com/hadolint/hadolint">Haskell Dockerfile Linter</a>，可以安装命令，也可以通过docker运行</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/hadolint</span><br><span class="line">hadolint --version</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">hadolint Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 运行</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -i hadolint/hadolint &lt; Dockerfile</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 Dockerfile 的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 镜像(Image)</title>
    <link href="https://blog.hanqunfeng.com/2025/05/22/docker-command-image/"/>
    <id>https://blog.hanqunfeng.com/2025/05/22/docker-command-image/</id>
    <published>2025-05-22T13:30:05.000Z</published>
    <updated>2025-06-12T06:57:51.843Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 镜像管理 相关命令</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/#application-programming-interfaces-apis">Application programming interfaces (APIs)</a></p></li></ul><span id="more"></span><h2 id="docker-search-搜索镜像"><code>docker search</code> : 搜索镜像</h2><ul class="lvl-0"><li class="lvl-2"><p>推荐在<a href="https://hub.docker.com/">dockerhub</a>上搜索镜像，以获取更详细的镜像信息。</p></li><li class="lvl-2"><p>国内也可以通过<a href="https://1ms.run/">毫秒镜像</a>,<a href="https://dockers.xuanyuan.me">轩辕 Docker 镜像搜索</a>来搜索镜像。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker search --<span class="built_in">help</span></span><br><span class="line">用法:  docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">在 Docker Hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">  -f, --filter filter   根据提供的条件过滤输出，常见的过滤条件包括：stars（星级）、is-official（是否为官方镜像）</span><br><span class="line">      --format string   使用 Go 模板美化输出，不太常用</span><br><span class="line">      --<span class="built_in">limit</span> int       搜索结果的最大数量</span><br><span class="line">      --no-trunc        不截断输出内容，显示完整信息（默认输出中某些字段如描述可能被截断）</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索名称中包含 nginx 的镜像</span></span><br><span class="line">$ docker search nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索名称中包含 nginx 且星级不少于 100 的镜像。</span></span><br><span class="line">$ docker search -f stars=100 nginx</span><br><span class="line"><span class="comment"># 搜索官方镜像</span></span><br><span class="line">$ docker search -f is-official=<span class="literal">true</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 nginx，按照指定模板格式化输出</span></span><br><span class="line">$ docker search nginx --format <span class="string">&quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125; stars:  &#123;&#123;.Description&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索nginx镜像，并限制5个结果</span></span><br><span class="line">$ docker search nginx --<span class="built_in">limit</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合使用多个选项</span></span><br><span class="line">$ docker search -f stars=100 --<span class="built_in">limit</span> 5 --no-trunc nginx</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong><code>docker search</code> 命令报错的解决方法</strong></em></p><ul class="lvl-1"><li class="lvl-2">目前国内使用<code>docker search</code>时会出现<code>Error response from daemon: Get &quot;https://index.docker.io/v1/search?q=nginx&amp;n=25&quot;: dial tcp 210.56.51.193:443: i/o timeout</code>的错误，即便我们配置了国内的镜像源，这个错误还是会存在。</li><li class="lvl-2">即便为宿主机和docker都配置上DNS也依然会报错。</li><li class="lvl-2">不过可以通过第三方镜像仓库进行查询，比如在查询的镜像名称前加上 <code>docker.1ms.run/</code>，比如查询<code>nginx</code>镜像，则输入<code>docker search docker.1ms.run/nginx</code>，这里要注意并不是所有的第三方镜像仓库都支持查询。</li><li class="lvl-2">可以编写一个脚本<code>docker_search</code>，查询镜像并输出结果，如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> &gt; docker_search</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">QUERY=<span class="variable">$&#123;1&#125;</span>     <span class="comment"># 查询关键词，这里要注意，第一个参数必须是查询关键词</span></span><br><span class="line"><span class="comment"># 获取除第一个参数外的所有参数</span></span><br><span class="line">ARGS=<span class="variable">$&#123;@:2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;查询镜像：docker search docker.1ms.run/<span class="variable">$QUERY</span> <span class="variable">$ARGS</span>&quot;</span></span><br><span class="line">docker search docker.1ms.run/<span class="variable">$QUERY</span> <span class="variable">$ARGS</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x docker_search</span><br><span class="line"><span class="comment"># 将其移动到 /usr/local/bin/</span></span><br><span class="line"><span class="built_in">mv</span> docker_search /usr/local/bin/docker_search</span><br><span class="line"><span class="comment"># 如果/usr/local/bin/没有在PATH中，请添加到环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/usr/local/sbin&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker_search redis -f stars=100 --<span class="built_in">limit</span> 5 --no-trunc</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">NAME                DESCRIPTION                                                                                       STARS     OFFICIAL</span><br><span class="line">redis               Redis is the world’s fastest data platform <span class="keyword">for</span> caching, vector search, and NoSQL databases.      13315     [OK]</span><br><span class="line">redis/redis-stack   redis-stack installs a Redis server with additional database capabilities and the RedisInsight.   149</span><br><span class="line">bitnami/redis       Bitnami container image <span class="keyword">for</span> Redis</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">基于url搜索，支持分页，但不能支持其它search参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> &gt; docker_search_by_url</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数处理</span></span><br><span class="line">QUERY=<span class="variable">$&#123;1:-nginx&#125;</span>     <span class="comment"># 默认查询关键词</span></span><br><span class="line">N=<span class="variable">$&#123;2:-25&#125;</span>            <span class="comment"># 默认每页条数</span></span><br><span class="line">PAGE=<span class="variable">$&#123;3:-1&#125;</span>          <span class="comment"># 默认页码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像源列表：依次尝试访问这些域名，这里要注意，并不是所有的镜像源都支持搜索功能</span></span><br><span class="line">REGISTRIES=(</span><br><span class="line">  <span class="string">&quot;docker.1ms.run&quot;</span></span><br><span class="line">  <span class="string">&quot;register.librax.org&quot;</span></span><br><span class="line">  <span class="comment"># 你可以继续添加备用域名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化成功标志</span></span><br><span class="line">WORKING_URL=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历域名，找到第一个可访问的</span></span><br><span class="line"><span class="keyword">for</span> REG <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;REGISTRIES[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  TEST_URL=<span class="string">&quot;https://<span class="variable">$&#123;REG&#125;</span>/v1/search?q=test&amp;n=1&quot;</span></span><br><span class="line">  <span class="keyword">if</span> curl -s --connect-timeout 2 <span class="string">&quot;<span class="variable">$TEST_URL</span>&quot;</span> | grep -q <span class="string">&#x27;&quot;results&quot;&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">    WORKING_URL=<span class="string">&quot;https://<span class="variable">$&#123;REG&#125;</span>/v1/search?q=<span class="variable">$&#123;QUERY&#125;</span>&amp;n=<span class="variable">$&#123;N&#125;</span>&amp;page=<span class="variable">$&#123;PAGE&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果都失败，退出</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$WORKING_URL</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;❌ 无法连接任何镜像源，请检查网络或备用域名设置。&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求数据并格式化输出</span></span><br><span class="line">curl -s <span class="string">&quot;<span class="variable">$WORKING_URL</span>&quot;</span> \</span><br><span class="line">| jq -r <span class="string">&#x27;[&quot;NAME&quot;,&quot;STARS&quot;,&quot;OFFICIAL&quot;,&quot;DESCRIPTION&quot;],</span></span><br><span class="line"><span class="string">         (.results[] |</span></span><br><span class="line"><span class="string">         [.name,</span></span><br><span class="line"><span class="string">          (.star_count|tostring),</span></span><br><span class="line"><span class="string">          (if .is_official then &quot;[OK]&quot; else &quot;&quot; end),</span></span><br><span class="line"><span class="string">          .description])</span></span><br><span class="line"><span class="string">         | @tsv&#x27;</span> \</span><br><span class="line">| column -t -s $<span class="string">&#x27;\t&#x27;</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div><h2 id="docker-image-镜像管理"><code>docker image</code> : 镜像管理</h2><ul class="lvl-0"><li class="lvl-2"><p><code>docker image --help</code></p></li></ul><table><thead><tr><th>命令</th><th>说明</th><th>别名(简写)</th></tr></thead><tbody><tr><td>build</td><td>从 Dockerfile 构建一个镜像</td><td>docker build</td></tr><tr><td>history</td><td>显示镜像的历史记录</td><td>docker history</td></tr><tr><td>import</td><td>从 tar 包导入内容以创建文件系统镜像</td><td>docker import</td></tr><tr><td>inspect</td><td>显示一个或多个镜像的详细信息</td><td>可以使用 <code>docker inspect</code></td></tr><tr><td>load</td><td>从 tar 归档或标准输入中加载镜像</td><td>docker load</td></tr><tr><td>ls</td><td>列出镜像</td><td>docker images</td></tr><tr><td>prune</td><td>移除未使用的镜像</td><td></td></tr><tr><td>pull</td><td>从镜像仓库下载镜像</td><td>docker pull</td></tr><tr><td>push</td><td>上传镜像到镜像仓库</td><td>docker push</td></tr><tr><td>rm</td><td>移除一个或多个镜像</td><td>docker rmi</td></tr><tr><td>save</td><td>将一个或多个镜像保存为 tar 归档（默认输出到标准输出）</td><td>docker save</td></tr><tr><td>tag</td><td>创建一个标签 TARGET_IMAGE 指向 SOURCE_IMAGE</td><td>docker tag</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>运行 <code>docker image COMMAND --help</code> 可获取某个命令的更多信息。</p></li></ul><h3 id="docker-pull-拉取镜像"><code>docker pull</code> : 拉取镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image pull</code> == <code>docker pull</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式，不加tag默认拉取 :latest</span></span><br><span class="line">$ docker pull &lt;image_name&gt;[:&lt;tag&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取nginx镜像，默认拉取最新版本：latest，nginx是官方镜像，完整名称实际上是 library/nginx</span></span><br><span class="line">$ docker pull nginx  ==  docker pull library/nginx  ==  docker pull nginx:latest</span><br><span class="line"><span class="comment"># 拉取指定tag的镜像</span></span><br><span class="line">$ docker pull nginx:1.28.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取非官方镜像，用户上传的</span></span><br><span class="line">$ docker pull hanqunfeng/alpine-jre8-slim:1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取指定平台的镜像，如果不指定 --platform 参数，默认会拉取与你当前 Docker 客户端运行平台匹配的镜像，通过 docker version 查看</span></span><br><span class="line">$ docker pull --platform=linux/amd64 nginx:latest</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 <a href="/2025/05/20/docker-install/" title="Linux 安装 Docker">Linux 安装 Docker</a> 中介绍了如配置国内的镜像加速源来加快镜像的拉取，但是国内镜像源不稳定，随时都有可能不可用，而且每次重新配置镜像源还需要重启Docker，可以编写一个脚本来完成<code>pull</code>，这样每次更新镜像源时只需要修改脚本，而不需要重启Docker了。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本名称：docker_pull</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法检查</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> &lt;镜像名&gt;，例如：docker_pull redis, docker_pull nginx --platform=linux/arm64&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始镜像名称，例如 nginx 或 someuser/image，要求第一个参数必须是镜像名称</span></span><br><span class="line">ORIGINAL_IMAGE_NAME=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取除第一个参数外的所有参数</span></span><br><span class="line">ARGS=<span class="variable">$&#123;@:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像源列表，修改镜像源时只需要修改该列表即可</span></span><br><span class="line">MIRROR_LIST=(</span><br><span class="line">  <span class="string">&quot;docker.1ms.run&quot;</span></span><br><span class="line">  <span class="string">&quot;docker.xuanyuan.me&quot;</span></span><br><span class="line">  <span class="string">&quot;docker.m.daocloud.io&quot;</span></span><br><span class="line">  <span class="string">&quot;docker.1panel.live&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果镜像名中不包含 &quot;/&quot;，加上 &quot;library/&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$ORIGINAL_IMAGE_NAME</span>&quot;</span> != *<span class="string">&quot;/&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">  IMAGE_NAME=<span class="string">&quot;library/<span class="variable">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  IMAGE_NAME=<span class="string">&quot;<span class="variable">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历镜像源</span></span><br><span class="line"><span class="keyword">for</span> MIRROR <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;MIRROR_LIST[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  FULL_IMAGE=<span class="string">&quot;<span class="variable">$MIRROR</span>/<span class="variable">$IMAGE_NAME</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;尝试从 <span class="variable">$FULL_IMAGE</span> <span class="variable">$ARGS</span> 拉取镜像...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;docker pull <span class="variable">$&#123;FULL_IMAGE&#125;</span> <span class="variable">$&#123;ARGS&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> docker pull <span class="variable">$&#123;FULL_IMAGE&#125;</span> <span class="variable">$&#123;ARGS&#125;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成功拉取镜像：<span class="variable">$FULL_IMAGE</span> <span class="variable">$ARGS</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将镜像重命名为去除镜像源前缀的版本</span></span><br><span class="line">    docker tag <span class="string">&quot;<span class="variable">$FULL_IMAGE</span>&quot;</span> <span class="string">&quot;<span class="variable">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;镜像重命名为：<span class="variable">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可选：删除带镜像源前缀的镜像</span></span><br><span class="line">    docker rmi <span class="string">&quot;<span class="variable">$FULL_IMAGE</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;从 <span class="variable">$MIRROR</span> 拉取失败，尝试下一个镜像源...&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有镜像源尝试失败，无法拉取镜像：<span class="variable">$ORIGINAL_IMAGE_NAME</span> <span class="variable">$ARGS</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>如何获取镜像tag</strong></em></p><ul class="lvl-1"><li class="lvl-2">docker 命令中没有提供直接获取镜像tag的命令，如果不想到<code>dockerhub</code>上查看，可以通过如下方式获取</li><li class="lvl-2">通过dockerhub的api接口获取(需要科学上网)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示tag名称，官方镜像替换 nginx，非官方镜像替换 libryary/nginx，page_size=5表示每页5条数据，page=1表示第一页（默认为1）</span></span><br><span class="line">curl -s <span class="string">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> | jq <span class="string">&#x27;.results[].name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 也可以使用如下url，两者效果相同</span></span><br><span class="line"><span class="comment">## https://hub.docker.com/v2/namespaces/&#123;namespace&#125;/repositories/&#123;repository&#125;/tags?page_size=5&amp;page=1</span></span><br><span class="line"><span class="comment">## 示例：https://hub.docker.com/v2/namespaces/library/repositories/nginx/tags?page_size=1&amp;page=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出json格式，并显示最后更新时间和镜像大小</span></span><br><span class="line">curl -s <span class="string">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> | jq <span class="string">&#x27;.results[] | &#123;name,last_updated,full_size&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出表格格式，并格式化输出</span></span><br><span class="line">curl -s <span class="string">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> \</span><br><span class="line">| jq -r <span class="string">&#x27;.results[] |</span></span><br><span class="line"><span class="string">  &quot;\(.name)\t\t\(.last_updated | sub(&quot;T&quot;; &quot; &quot;) | sub(&quot;\\..*&quot;; &quot;&quot;))\t\t\(((.full_size / 1024 / 1024 * 100 | round)/100) | tostring) MB&quot;&#x27;</span> \</span><br><span class="line">  | awk <span class="string">&#x27;&#123;printf &quot;%-30s %-20s %8.2f MB\n&quot;, $1, $2&quot; &quot;$3, $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">通过<a href="https://github.com/containers/skopeo">skopeo</a>工具获取</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用容器的方式(需要科学上网)</span></span><br><span class="line">docker run --<span class="built_in">rm</span> quay.io/skopeo/stable:latest inspect --override-os linux  docker://docker.io/nginx | jq <span class="string">&#x27;.RepoTags[]&#x27;</span></span><br><span class="line"><span class="comment"># 将`docker.io`替换为镜像源`docker.1ms.run`，不需要科学上网</span></span><br><span class="line">docker run --<span class="built_in">rm</span> quay.io/skopeo/stable:latest inspect --override-os linux  docker://docker.1ms.run/nginx | jq <span class="string">&#x27;.RepoTags[]&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">为了方便使用可以编写一个脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; docker_tags</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 用法提示</span></span><br><span class="line"><span class="string">if [ -z &quot;\$1&quot; ]; then</span></span><br><span class="line"><span class="string">  echo &quot;用法: \$0 &lt;镜像名称，例如 nginx 或 library/nginx&gt;&quot;</span></span><br><span class="line"><span class="string">  exit 1</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">IMAGE_NAME=\$1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用 skopeo 获取镜像信息并解析标签列表</span></span><br><span class="line"><span class="string">docker run --rm quay.io/skopeo/stable:latest \\</span></span><br><span class="line"><span class="string">  inspect --override-os linux docker://docker.1ms.run/\$IMAGE_NAME \\</span></span><br><span class="line"><span class="string">  | jq &#x27;.RepoTags[]&#x27;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">chmod</span> +x docker_tags</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">docker_tags nginx</span><br></pre></td></tr></table></figure></div><h3 id="docker-images-列出镜像"><code>docker images</code> : 列出镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image ls</code> == <code>docker images</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有镜像，不包括悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）</span></span><br><span class="line">$ docker images</span><br><span class="line"><span class="comment"># 列出所有镜像，包括悬空镜像</span></span><br><span class="line">$ docker images -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像，并显示镜像的摘要信息</span></span><br><span class="line">$ docker images --digests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像，并输出为json格式</span></span><br><span class="line">$ docker images --format json</span><br><span class="line"><span class="comment"># 只显示镜像名称和标签</span></span><br><span class="line">$ docker images --format <span class="string">&quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示镜像ID</span></span><br><span class="line">$ docker images -q</span><br></pre></td></tr></table></figure><h3 id="docker-inspect-查看镜像的详细信息"><code>docker inspect</code> : 查看镜像的详细信息</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image inspect</code> == <code>docker inspect</code></p></li><li class="lvl-2"><p>这里要注意，<code>docker inspect</code>如果基于名称查找会优先查找容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示镜像的详细信息，镜像名称</span></span><br><span class="line">$ docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示镜像的详细信息，镜像ID</span></span><br><span class="line">$ docker inspect 9f0c0d0a0f0f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示镜像的Labels信息，获取json中指定的字段</span></span><br><span class="line">$ docker image inspect --format=<span class="string">&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27;</span> nginx</span><br></pre></td></tr></table></figure><h3 id="docker-image-prune-删除未使用的镜像"><code>docker image prune</code> : 删除未使用的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）</span></span><br><span class="line">$ docker image prune</span><br><span class="line"><span class="comment"># 删除全部未使用镜像(未被任何一个容器引用)，包括悬空镜像</span></span><br><span class="line">$ docker image prune -a</span><br><span class="line"><span class="comment"># 不进行确认提示，直接执行</span></span><br><span class="line">$ docker image prune -f</span><br></pre></td></tr></table></figure><h3 id="docker-rmi-删除镜像"><code>docker rmi</code> : 删除镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image rm</code> == <code>docker rmi</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像，镜像名称</span></span><br><span class="line">$ docker rmi nginx</span><br><span class="line"><span class="comment"># 删除多个镜像，空格分隔</span></span><br><span class="line">$ docker rmi nginx mysql</span><br><span class="line"><span class="comment"># 删除镜像，镜像ID</span></span><br><span class="line">$ docker rmi 9f0c0d0a0f0f</span><br><span class="line"><span class="comment"># 强制删除镜像，当镜像被容器引用时，会报错，需要使用-f参数进行强制删除</span></span><br><span class="line">$ docker rmi -f nginx</span><br><span class="line"><span class="comment"># 删除全部镜像</span></span><br><span class="line">$ docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id="docker-history-查看镜像的构建历史"><code>docker history</code> : 查看镜像的构建历史</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image history</code> == <code>docker history</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br><span class="line"><span class="comment"># 查看镜像的历史记录，镜像名称</span></span><br><span class="line">$ docker <span class="built_in">history</span> nginx</span><br><span class="line"><span class="comment"># 查看镜像的历史记录，镜像ID</span></span><br><span class="line">$ docker <span class="built_in">history</span> 9f0c0d0a0f0f</span><br><span class="line"><span class="comment"># 显示完整的镜像历史记录，默认`CREATED BY`中的信息太长会被截断</span></span><br><span class="line">$ docker <span class="built_in">history</span> --no-trunc nginx</span><br><span class="line"><span class="comment"># 显示为json格式</span></span><br><span class="line">$ docker <span class="built_in">history</span> --format=json nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker history</code> 显示的是构建历史，会将每一个 Dockerfile 指令都算一层，而不是物理镜像层（layer）数量，若要查看镜像的物理层数，可以通过如下命令查看</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect --format <span class="string">&#x27;&#123;&#123; len .RootFS.Layers &#125;&#125;&#x27;</span> nginx</span><br></pre></td></tr></table></figure><h3 id="docker-tag-创建一个标签"><code>docker tag</code> : 创建一个标签</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image tag</code> == <code>docker tag</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line"><span class="comment"># 创建一个标签</span></span><br><span class="line">$ docker tag nginx:latest hanqunfeng/nginx:latest</span><br><span class="line"><span class="comment"># 查看镜像，可以看到两个镜像的 IMAGE ID 一致</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY         TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hanqunfeng/nginx   latest    be69f2940aaf   5 weeks ago   192MB</span><br><span class="line">nginx              latest    be69f2940aaf   5 weeks ago   192MB</span><br><span class="line"><span class="comment"># 此时若通过 IMAGE ID 删除镜像，会报错，提示被多个 REPOSITORY 关联，需要使用 -f 参数进行强制删除</span></span><br><span class="line">$ docker rmi be69f2940aaf</span><br><span class="line">Error response from daemon: conflict: unable to delete be69f2940aaf (must be forced) - image is referenced <span class="keyword">in</span> multiple repositories</span><br></pre></td></tr></table></figure><h3 id="docker-save-将镜像保存为-tar-归档"><code>docker save</code> : 将镜像保存为 tar 归档</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image save</code> == <code>docker save</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"><span class="comment"># 将镜像保存为 tar 归档，-o  指定输出文件，文件名称任意，甚至都不需要以 .tar 结尾</span></span><br><span class="line">$ docker save -o nginx.tar nginx</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker save nginx &gt; nginx.tar</span><br></pre></td></tr></table></figure><h3 id="docker-load-从-tar-归档中加载镜像"><code>docker load</code> : 从 tar 归档中加载镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image load</code> == <code>docker load</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker load [OPTIONS]</span><br><span class="line"><span class="comment"># 从 tar 归档中加载镜像，导出tar归档时的镜像名称就是加载后的镜像名称</span></span><br><span class="line">$ docker load -i nginx.tar</span><br><span class="line"><span class="comment"># -q 参数表示不显示进度条</span></span><br><span class="line">$ docker load -q -i nginx.tar</span><br></pre></td></tr></table></figure><h3 id="docker-import-从文件创建镜像"><code>docker import</code> : 从文件创建镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image import</code> == <code>docker import</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">$ docker import [OPTIONS] FILE|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line">file本地 tar 文件，例如 rootfs.tar</span><br><span class="line">URL    网络地址（http/https）</span><br><span class="line">-    从标准输入读取（比如通过管道）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出镜像名称与标签</span></span><br><span class="line">REPOSITORY[:TAG]导入后镜像的名称与标签</span><br><span class="line"></span><br><span class="line"><span class="comment"># OPTIONS</span></span><br><span class="line">--change在导入镜像时设置 Dockerfile 指令，如 CMD、ENV、EXPOSE 等</span><br><span class="line">--message, -m添加导入说明（commit message）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker import</code> 与  <code>docker load</code> 的区别</p></li></ul><table><thead><tr><th>命令</th><th>用途</th><th>格式</th><th>是否保留历史</th></tr></thead><tbody><tr><td><code>docker import</code></td><td>导入文件系统，创建镜像(由 <code>docker export</code> 生成)</td><td>纯文件系统 tar 包</td><td>❌ 不保留历史、标签等元数据</td></tr><tr><td><code>docker load</code></td><td>加载镜像（通常由 <code>docker save</code> 生成）</td><td>Docker 镜像 tar（含元数据）</td><td>✅ 保留 tag、层、历史等</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例: 从容器导出再导入</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个容器</span></span><br><span class="line">$ docker run -d -p 8080:80 --name nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出容器文件系统，此时 nginx 容器中的所有文件都保存在 my_nginx.tar 文件中</span></span><br><span class="line">$ docker <span class="built_in">export</span> -o my_nginx.tar nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文件系统，导入时指定 启动命令，因为 my_nginx.tar 只是文件，并不包含任何启动命令</span></span><br><span class="line">$ docker import --change=<span class="string">&#x27;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#x27;</span> my_nginx.tar nginx:my_tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像，镜像ID不一致</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY         TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx              my_tag    4ab42de31bac   4 seconds ago   191MB</span><br><span class="line">nginx              latest    be69f2940aaf   5 weeks ago     192MB</span><br></pre></td></tr></table></figure><h3 id="docker-build-从指定目录或URL中的-Dockerfile-构建-Docker-镜像"><code>docker build</code> : 从指定目录或URL中的 Dockerfile 构建 Docker 镜像</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image build</code> == <code>docker build</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">PATH  Dockerfile 所在的目录</span><br><span class="line">URL      Git 仓库的 URL</span><br><span class="line">-      从标准输入读取 Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像，-t: 指定镜像名称，.: 表示从当前目录查找Dockerfile，默认文件名称为 Dockerfile</span></span><br><span class="line">docker build -t myimage:latest .</span><br><span class="line"><span class="comment"># 构建镜像，-f: 指定 Dockerfile 的相对路径，.: 表示基于当前目录，实际的 Dockerfile 路径就是 ./path/MyDockerfile</span></span><br><span class="line">docker build -t myimage:latest -f path/MyDockerfile .</span><br><span class="line"><span class="comment"># 实际的 Dockerfile 路径就是 /usr/local/path/MyDockerfile</span></span><br><span class="line">docker build -t myimage:latest -f path/MyDockerfile /usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像，从 Git 仓库中构建，git 仓库的 Dockerfile 必须在根目录下</span></span><br><span class="line">docker build https://github.com/hanqunfeng/docker_test.git -t abc:1.0.0</span><br><span class="line"><span class="comment"># 构建镜像，从 Git 仓库中构建，指定 Dockerfile 的相对路径</span></span><br><span class="line">docker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git -t abc:1.0.1</span><br><span class="line"><span class="comment"># 构建镜像，从 Git 仓库中构建，指定分支或 tag</span></span><br><span class="line">docker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git#release -t abc:1.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建，但会非常慢，一般没有导致某一个层发生变化时不需要加上这个参数</span></span><br><span class="line">docker build --no-cache -t app:latest .</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker build</code>中还有一些重要的参数，以及<code>Dockerfile</code>文件该怎么编写，请参考<a href="/2025/05/26/docker-dockerfile/" title="Docker 命令 之 Dockerfile">Docker 命令 之 Dockerfile</a></p></li></ul><h3 id="docker-push-推送本地镜像到远程仓库"><code>docker push</code> : 推送本地镜像到远程仓库</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker image push</code> == <code>docker push</code></p></li><li class="lvl-2"><p>这里介绍如何将镜像推送到<code>docker hub</code>远程仓库</p></li><li class="lvl-2"><p>需要先在<a href="https://hub.docker.com/">docker hub</a>网站上创建一个账号，比如我的用户名是<code>hanqunfeng</code></p></li><li class="lvl-2"><p>然后就可以使用下面的命令将本地镜像推送到远程仓库了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地镜像</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY         TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx              latest    e573c6323878   18 hours ago   191MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对nginx镜像打tag,前缀必须与用户名一致</span></span><br><span class="line">$ docker tag nginx hanqunfeng/nginx:1.0.0</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY         TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hanqunfeng/nginx   1.0.0     be69f2940aaf   5 weeks ago    192MB</span><br><span class="line">nginx              latest    be69f2940aaf   5 weeks ago    192MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录 docker hup</span></span><br><span class="line">$ docker login -u hanqunfeng</span><br><span class="line"></span><br><span class="line">i Info → A Personal Access Token (PAT) can be used instead.</span><br><span class="line">          To create a PAT, visit https://app.docker.com/settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Password: <span class="comment"># 输入密码</span></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录同时输入密码</span></span><br><span class="line"><span class="comment"># docker login -u hanqunfeng -p 12345678</span></span><br><span class="line"><span class="comment"># 登录其它仓库</span></span><br><span class="line"><span class="comment"># docker login -u username -p password registry.orther.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到docker hub，此后就可以通过 docker pull hanqunfeng/nginx:1.0.0 获取了</span></span><br><span class="line">$ docker push hanqunfeng/nginx:1.0.0</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">未登录Docker Hub的情况下，运行<code>docker pull</code>会有拉取速率和数量上的限制，具体可以参看<a href="https://docs.docker.com/docker-hub/usage/">Docker Hub的使用和限制</a></li></ul></div>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 镜像管理 相关命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/#application-programming-interfaces-apis&quot;&gt;Application programming interfaces (APIs)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 Docker</title>
    <link href="https://blog.hanqunfeng.com/2025/05/20/docker-install/"/>
    <id>https://blog.hanqunfeng.com/2025/05/20/docker-install/</id>
    <published>2025-05-20T13:30:05.000Z</published>
    <updated>2025-06-29T05:04:42.878Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下的 Docker 安装方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p>windows、macos、ubuntu等桌面系统请安装 <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a>。</p></li><li class="lvl-2"><p>阿里云专有服务器参考：<a href="https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker">阿里云专有服务器如何安装Docker</a></p></li><li class="lvl-2"><p>腾讯云专有服务器参考：<a href="https://cloud.tencent.com/document/product/1207/45596">腾讯云专有服务器如何安装Docker</a></p></li><li class="lvl-2"><p>AWS专有服务器参考：<a href="/2025/05/19/docker-install-aws/" title="AWS专有服务器如何安装Docker">AWS专有服务器如何安装Docker</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/install/">安装Docker Engine</a></p></li></ul><span id="more"></span><h2 id="Docker-简介">Docker 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker 是一个开源的容器化平台，用于打包、分发和运行应用程序。它通过将应用程序及其依赖打包到一个“容器”中，确保应用在不同环境中始终能够一致运行。与传统的虚拟机相比，Docker 容器更轻量、启动更快、资源占用更少。</p></li><li class="lvl-2"><p>Docker 采用<code>客户端-服务器</code>架构，核心组件包括 <code>Docker Engine</code>（负责构建和运行容器）、<code>Dockerfile</code>（定义构建镜像的指令）、<code>镜像</code>（应用和依赖的只读模板）和<code>容器</code>（基于镜像运行的实例）。开发者可以通过 Docker Hub 共享或下载镜像，极大简化了部署流程。</p></li><li class="lvl-2"><p>总结来说，Docker 提高了开发效率，支持持续集成与部署（CI/CD），在微服务架构中尤为常用，是现代 DevOps 流程的重要工具。</p></li><li class="lvl-2"><p><a href="https://docs.docker.com/get-started/docker-overview/">Docker是什么？</a><br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nIdftv.png" alt=""></p></li></ul><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Docker 仓库（Registry）</td><td>Docker仓库用于存储Docker镜像。Docker Hub是一个任何人都可以使用的公共仓库，默认情况下，Docker在Docker Hub上查找图像。你也可以配置自己的私人仓库。<br>当您使用docker pull或docker run命令时，Docker会从您配置的仓库中提取所需的镜像。当您使用docker push命令时，Docker会将您的镜像推送到已配置的仓库中。</td></tr><tr><td>Docker 守护进程（Daemon）</td><td>监听Docker API请求，并管理Docker对象，如镜像、容器、网络和卷。守护程序还可以与其他守护程序通信来管理Docker服务。</td></tr><tr><td>Docker 客户端（Client）</td><td>Docker 客户端（docker）是许多用户与 Docker 交互的主要方式。当你使用如 docker run 这样的命令时，客户端会将这些命令发送给 dockerd（Docker 守护进程），由它来执行这些操作。<br>docker 命令是通过 Docker API 进行通信的。Docker 客户端可以与多个守护进程进行通信。</td></tr><tr><td>Docker 主机（Host）</td><td>运行 Docker 守护进程和容器的物理或虚拟机器。</td></tr><tr><td>Docker 镜像（Images）</td><td>创建容器的只读模板，包含运行应用所需的所有文件和配置。</td></tr><tr><td>Docker 容器（Container）</td><td>基于镜像运行的实例，是一个或多个应用的独立运行环境。</td></tr></tbody></table><h2 id="Docker-安装">Docker 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>全新安装前需要先卸载旧版本，卸载<code>docker</code>也可以按照如下方式操作</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Docker相关源</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /etc/yum.repos.d/docker*.repo</span><br><span class="line"><span class="comment"># 删除Docker相关软件包，dnf可能会报告您没有安装这些软件包。</span></span><br><span class="line"><span class="comment"># 卸载docker旧版本</span></span><br><span class="line"><span class="built_in">sudo</span> dnf -y remove \</span><br><span class="line">               docker \</span><br><span class="line">               docker-client \</span><br><span class="line">               docker-client-latest \</span><br><span class="line">               docker-common \</span><br><span class="line">               docker-latest \</span><br><span class="line">               docker-latest-logrotate \</span><br><span class="line">               docker-logrotate \</span><br><span class="line">               docker-engine</span><br><span class="line"><span class="comment"># 卸载docker新版本</span></span><br><span class="line"><span class="built_in">sudo</span> dnf -y remove \</span><br><span class="line">            docker-ce \</span><br><span class="line">            containerd.io \</span><br><span class="line">            docker-ce-rootless-extras \</span><br><span class="line">            docker-buildx-plugin \</span><br><span class="line">            docker-ce-cli \</span><br><span class="line">            docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Docker数据,镜像、容器、卷和网络</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br><span class="line"><span class="comment"># Docker执行状态文件的存储路径</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/run/docker</span><br><span class="line"><span class="comment"># 删除Docker配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/docker/</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>设置docker存储库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install dnf-plugins-core</span><br><span class="line"><span class="comment"># 海外，添加Docker的官方存储库</span></span><br><span class="line"><span class="built_in">sudo</span> dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 国内，添加阿里云的存储库</span></span><br><span class="line"><span class="built_in">sudo</span> dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 Docker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本，升级 docker 时也是执行如下命令</span></span><br><span class="line"><span class="built_in">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line"><span class="comment"># 先查看所有版本</span></span><br><span class="line"><span class="built_in">sudo</span> dnf list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">docker-ce.x86_64               3:26.1.3-1.el8                  docker-ce-stable</span><br><span class="line">docker-ce.x86_64               3:26.1.3-1.el8                  @docker-ce-stable</span><br><span class="line">docker-ce.x86_64               3:26.1.2-1.el8                  docker-ce-stable</span><br><span class="line">docker-ce.x86_64               3:26.1.1-1.el8                  docker-ce-stable</span><br><span class="line">docker-ce.x86_64               3:26.1.0-1.el8                  docker-ce-stable</span><br><span class="line">…………………………</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本，这里 VERSION_STRING 为版本号，例如 3:26.1.3-1.el8</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br><span class="line"><span class="comment">## 比如</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果只安装客户端用于连接远程 Docker 主机</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install docker-ce-cli docker-buildx-plugin docker-compose-plugin -y</span><br></pre></td></tr></table></figure><table><thead><tr><th>组件名称</th><th>是否必需（本地运行 Docker）</th><th>功能简介</th><th>备注</th></tr></thead><tbody><tr><td><code>docker-ce</code></td><td>✅ 是</td><td>Docker Engine 的核心，包括 <code>dockerd</code>（守护进程）和 <code>docker</code>（CLI）</td><td>完整安装 Docker 时包含此组件</td></tr><tr><td><code>docker-ce-cli</code></td><td>✅ 是（或单独用于远程控制）</td><td>Docker 命令行工具，如 <code>docker run</code>, <code>docker ps</code>, <code>docker build</code> 等</td><td>可以独立安装，只用于控制远程 Docker 主机</td></tr><tr><td><code>containerd.io</code></td><td>✅ 是（本地运行容器）</td><td>容器运行时，Docker 后端用于真正启动/管理容器</td><td>如果你只使用 Docker CLI，不运行本地容器则不需要</td></tr><tr><td><code>docker-buildx-plugin</code></td><td>❌ 否</td><td>提供 <code>docker buildx</code> 命令，支持高级构建特性（如跨平台、多阶段构建）</td><td>可选，适合高级构建需求</td></tr><tr><td><code>docker-compose-plugin</code></td><td>❌ 否</td><td>提供 <code>docker compose</code> 命令，用于编排多个服务</td><td>如果使用 Compose，则建议安装此插件</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>启动 Docker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Docker守护进程在系统启动时自动启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="comment"># 查看 docker daemon 日志，-f: 持续跟踪</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u docker -f</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加当前用户到docker组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加当前用户到docker组，这样当前用户就可以不需要使用sudo就能使用docker命令</span></span><br><span class="line"><span class="comment"># 当前用户是centos</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker centos</span><br><span class="line"><span class="comment"># 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组</span></span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>验证 Docker 安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version <span class="comment"># 查看 Docker version</span></span><br><span class="line"><span class="comment"># 显示 Docker 基本信息，包括版本信息，插件信息，镜像加速信息等等。</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 拉取hello-world镜像，此时国内会提示访问失败，需要添加国内镜像源</span></span><br><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加国内镜像源</p></li></ul><blockquote><p>目前国内大部分的Docker镜像源都关闭了，另外阿里云的Docker镜像源只允许在阿里云的机器上使用。<br>参考：<a href="https://blog.xuanyuan.me/archives/1154">Docker/DockerHub 国内镜像源/加速列表</a>,<a href="https://status.1panel.top/status/docker">国内 Docker 服务状态 &amp; 镜像加速监控</a><br>注意：国内镜像源的更新会比官网滞后，但只要不是获取最新版本基本上是够用的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">        &quot;https://docker.1ms.run&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://docker.xuanyuan.me&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过如下命令查看是否配置生效，查看 Registry Mirrors 中的配置</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 验证国内镜像源</span></span><br><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Docker命令自动补全，参考：<a href="https://docs.docker.com/engine/cli/completion/">官方文档</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装bash-completion</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install bash-completion -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自动补全到当前登录用户</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="string">if [ -f /etc/bash_completion ]; then</span></span><br><span class="line"><span class="string">    . /etc/bash_completion</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"><span class="comment"># 刷新bash</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自动补全文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.local/share/bash-completion/completions</span><br><span class="line">docker completion bash &gt; ~/.local/share/bash-completion/completions/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个新的bash</span></span><br><span class="line"><span class="built_in">exec</span> bash</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>快速清理docker中所有的无用资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未使用的镜像、容器、网络等</span></span><br><span class="line">docker system prune -a -f</span><br><span class="line"><span class="comment"># 删除所有未使用的镜像、容器、网络、数据卷等</span></span><br><span class="line">docker system prune -a -f --volumes</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>/var/lib/docker</code> 用于存储 Docker 运行时生成的数据，如镜像、容器、网络、卷、配置文件、日志等，其目录结构说明如下：</p></li></ul><table><thead><tr><th>目录名</th><th>作用说明</th></tr></thead><tbody><tr><td><code>buildkit/</code></td><td>存放 Docker BuildKit 构建缓存和状态信息；构建镜像时的中间文件和上下文会存于此，空间占用可能较大。</td></tr><tr><td><code>containers/</code></td><td>每个容器一个子目录，包含配置文件和运行日志（如 <code>container.log</code>），用于容器的运行状态记录和管理。</td></tr><tr><td><code>engine-id</code></td><td>存储 Docker 引擎的唯一 ID，Docker 安装时生成，常用于 swarm 节点识别。</td></tr><tr><td><code>image/</code></td><td>镜像的元数据（不含实际 layer 数据），组织镜像的结构、标签、驱动等信息。</td></tr><tr><td><code>network/</code></td><td>网络配置及状态信息，如默认 <code>bridge</code> 网络、自定义网络配置等。</td></tr><tr><td><code>overlay2/</code></td><td>镜像和容器实际的数据层（overlay2 是存储驱动），包含所有联合文件系统层，是 Docker 中最大的空间使用者。</td></tr><tr><td><code>plugins/</code></td><td>存放 Docker 插件（如网络、卷插件）的配置和数据，一般为空，除非使用了扩展插件。</td></tr><tr><td><code>runtimes/</code></td><td>支持的 OCI runtime 配置目录，如默认的 <code>runc</code>，也可能包含其他 runtime（如 <code>kata</code>, <code>gvisor</code>）。</td></tr><tr><td><code>swarm/</code></td><td>Docker swarm 模式下的集群元数据与节点状态，仅在初始化 swarm 后存在实际数据。</td></tr><tr><td><code>tmp/</code></td><td>Docker 的临时文件目录，如镜像下载缓存、挂载操作中的临时文件，通常可以清理但需小心。</td></tr><tr><td><code>volumes/</code></td><td>Docker 卷的数据目录，每个卷一个子目录，卷中的持久化数据实际存放于此。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>/var/lib/containerd</code> 是 Containerd 守护进程的默认数据存储目录。Containerd 是 Docker 和其他容器平台（如 Kubernetes）底层的 容器运行时（Container Runtime），负责拉取镜像、管理容器生命周期、挂载文件系统等操作。其目录结构说明如下：</p></li></ul><table><thead><tr><th>目录名</th><th>作用说明</th></tr></thead><tbody><tr><td><code>io.containerd.content.v1.content/</code></td><td>存储镜像 layer 的实际二进制内容（blob），遵循 OCI 镜像规范，是镜像和容器文件系统的数据来源。</td></tr><tr><td><code>io.containerd.metadata.v1.bolt/</code></td><td>使用 BoltDB 存储 containerd 的元数据（如镜像信息、容器状态、快照引用等），是 containerd 的核心元数据数据库。</td></tr><tr><td><code>io.containerd.runtime.v1.linux/</code></td><td>存储旧版（v1 API）运行时容器信息，目前已逐步被 <code>v2</code> 接口取代，仅在向后兼容场景中存在。</td></tr><tr><td><code>io.containerd.runtime.v2.task/</code></td><td>存储 v2 运行时接口下容器的运行时状态，如容器进程的 shim、PID、日志路径等，是容器实际运行时所依赖的。</td></tr><tr><td><code>io.containerd.snapshotter.v1.native/</code></td><td>使用 native 模式存储的容器快照（文件系统层），直接复制底层文件；性能较差，占用空间较大，主要用于测试或特定用途。</td></tr><tr><td><code>io.containerd.snapshotter.v1.overlayfs/</code></td><td>使用 overlayfs 模式存储容器的文件系统快照（镜像层和容器层）；这是生产环境默认的高效存储驱动。</td></tr><tr><td><code>tmpmounts/</code></td><td>临时挂载点目录，containerd 用于镜像解包、中间构建过程中的挂载操作，通常是构建或运行过程的临时数据。</td></tr></tbody></table><div class="tips"><p><em><strong>MacOS/Windows下无法查看<code>/var/lib/docker</code>的解决方法</strong></em></p><ul class="lvl-1"><li class="lvl-2">在 MacOS/Windows 上使用Docker时，是启动了一个虚拟机来运行docker的，由于其运行在虚拟机内部，直接查找<code>/var/lib/docker</code>路径是无效的。</li><li class="lvl-2">解决方法如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个临时容器，并进入其内部</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh</span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line">--it</span><br><span class="line">    交互式地运行容器,并分配一个伪终端</span><br><span class="line"></span><br><span class="line">--<span class="built_in">rm</span></span><br><span class="line">    退出容器时，自动删除容器</span><br><span class="line"></span><br><span class="line">--privileged</span><br><span class="line">    给容器特权权限，这意味着容器几乎拥有宿主机的所有能力，能访问 /dev、修改内核参数等。非常强大但也很危险。</span><br><span class="line"></span><br><span class="line">--pid=host</span><br><span class="line">    容器共享宿主机的进程命名空间（PID Namespace）。</span><br><span class="line">    这使得容器可以看到并访问宿主机的所有进程（包括 PID 1，即系统 init 进程）。</span><br><span class="line"></span><br><span class="line">debian</span><br><span class="line">    使用的基础镜像是 Debian，容器里运行的是这个系统。</span><br><span class="line"></span><br><span class="line">nsenter -t 1 -m -u -n -i sh</span><br><span class="line">    这是容器内部运行的命令，用来进入宿主机的命名空间：</span><br><span class="line">        nsenter：Linux 工具，用于进入其他进程的命名空间。</span><br><span class="line">        -t 1：指定目标进程的 PID 是 1（宿主机的 init 或 systemd）。</span><br><span class="line">        -m：进入目标进程的 Mount Namespace（文件系统挂载）。</span><br><span class="line">        -u：进入目标的 UTS Namespace（主机名等）。</span><br><span class="line">        -n：进入目标的 Network Namespace（网络）。</span><br><span class="line">        -i：进入目标的 IPC Namespace（进程间通信）。</span><br><span class="line">        sh：在这些命名空间中执行一个 shell。</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">这个命令启动一个基于 Debian 的容器，给它所有特权，让它能看到宿主机的进程，然后使用 nsenter 进入 PID 为 1 的所有命名空间（相当于进入宿主机的视角），最后启动一个 sh，你就在容器里 “变成了宿主机”。</li><li class="lvl-2">这样，你就可以在这个容器中查看<code>/var/lib/docker</code>目录了。</li></ul></div><h2 id="Docker-的-etc-docker-daemon-json-能配置哪些优化项">Docker 的 <code>/etc/docker/daemon.json</code> 能配置哪些优化项</h2><ul class="lvl-0"><li class="lvl-2"><p>镜像加速（国内常用）</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://你的加速地址&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>控制日志文件大小与数量，避免日志无限制增长导致磁盘打满。</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log-level&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;info&quot;</span><span class="punctuation">,</span> # log-level 配置为 debug、info、warn、error、fatal，默认为 info</span><br><span class="line">  <span class="attr">&quot;log-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-file&quot;</span><span class="punctuation">,</span> # log-driver 也可以配置为 journald、syslog、none 等。默认为 json-file</span><br><span class="line">  <span class="attr">&quot;log-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;max-size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100m&quot;</span><span class="punctuation">,</span>     #  日志文件大小</span><br><span class="line">    <span class="attr">&quot;max-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span>         #  日志文件数量</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>默认网桥网段配置（避免和宿主机网段冲突）</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;docker0&quot;</span><span class="punctuation">,</span>       # 设置默认网桥名称，默认docker0</span><br><span class="line">  <span class="attr">&quot;bip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.100.1/24&quot;</span><span class="punctuation">,</span>  #  默认<span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">16</span></span><br><span class="line">  <span class="attr">&quot;fixed-cidr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.100.0/24&quot;</span> # 设置容器IP地址段</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>默认 ulimit 限制提升</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;default-ulimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   # 默认ulimit限制</span><br><span class="line">    <span class="attr">&quot;nofile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nofile&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Hard&quot;</span><span class="punctuation">:</span> <span class="number">65535</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Soft&quot;</span><span class="punctuation">:</span> <span class="number">65535</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>并发连接优化</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;max-concurrent-downloads&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> # 并发下载数量</span><br><span class="line">  <span class="attr">&quot;max-concurrent-uploads&quot;</span><span class="punctuation">:</span> <span class="number">5</span>     # 并发上传数量</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>DNS配置（有些公司内网需要）</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;8.8.8.8&quot;</span><span class="punctuation">,</span> <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>私有仓库免认证配置 (不建议生产用)</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.example.com:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启Docker后恢复容器，建议还是使用容器的<code>restart</code>参数</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;live-restore&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  # 当设置为<span class="literal"><span class="keyword">true</span></span>时，Docker会在守护进程启动时尝试重启所有之前运行中的容器，默认为<span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下的 Docker 安装方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;windows、macos、ubuntu等桌面系统请安装 &lt;a href=&quot;https://www.docker.com/products/docker-desktop/&quot;&gt;Docker Desktop&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;阿里云专有服务器参考：&lt;a href=&quot;https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker&quot;&gt;阿里云专有服务器如何安装Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;腾讯云专有服务器参考：&lt;a href=&quot;https://cloud.tencent.com/document/product/1207/45596&quot;&gt;腾讯云专有服务器如何安装Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;AWS专有服务器参考：&lt;a href=&quot;/2025/05/19/docker-install-aws/&quot; title=&quot;AWS专有服务器如何安装Docker&quot;&gt;AWS专有服务器如何安装Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/&quot;&gt;安装Docker Engine&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>AWS专有服务器如何安装Docker</title>
    <link href="https://blog.hanqunfeng.com/2025/05/19/docker-install-aws/"/>
    <id>https://blog.hanqunfeng.com/2025/05/19/docker-install-aws/</id>
    <published>2025-05-19T13:30:05.000Z</published>
    <updated>2025-06-05T09:08:14.574Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍如何在 AWS 专有服务器上安装 Docker</p></li></ul><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Update and install Docker</span></span><br><span class="line"><span class="built_in">sudo</span> yum update -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Amazon Linux 2</span></span><br><span class="line"><span class="built_in">sudo</span> amazon-linux-extras install docker -y</span><br><span class="line"><span class="comment"># Amazon Linux 2023</span></span><br><span class="line"><span class="built_in">sudo</span> yum install docker -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`</span></span><br><span class="line"><span class="built_in">sudo</span> curl -L <span class="string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the docker-compose command available</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Docker service</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># Start the service</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="comment"># Add the current user to the docker group</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker ec2-user</span><br><span class="line"><span class="comment"># 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组</span></span><br><span class="line">newgrp docker</span><br><span class="line"><span class="comment"># Check Docker version</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment"># Test Docker</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍如何在 AWS 专有服务器上安装 Docker&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
</feed>
