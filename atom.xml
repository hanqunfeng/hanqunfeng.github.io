<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-12-21T09:34:40.943Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 扩展模块 -- RedisBloom</title>
    <link href="https://blog.hanqunfeng.com/2025/12/21/redis7-BloomFilter/"/>
    <id>https://blog.hanqunfeng.com/2025/12/21/redis7-BloomFilter/</id>
    <published>2025-12-21T13:30:05.000Z</published>
    <updated>2025-12-21T09:34:40.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模块 – RedisBloom 的使用方法</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">本文仅为学习原理，生产环境推荐使用 <a href="https://redisson.pro/docs/data-and-services/objects/#bloom-filter">Redisson的布隆过滤器</a> 吧。</li></ul><span id="more"></span><h2 id="RedisBloom-简介">RedisBloom 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。</p></li><li class="lvl-2"><p>它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。</p></li><li class="lvl-2"><p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p></li><li class="lvl-2"><p>Redis8+，RedisBloom 已经内置在 Redis 中，不需要单独安装。</p></li></ul><h3 id="RedisBloom-提供的核心数据结构">RedisBloom 提供的核心数据结构</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ Bloom Filter（布隆过滤器）</p><ul class="lvl-2"><li class="lvl-6">判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</li><li class="lvl-6"><a href="https://en.wikipedia.org/wiki/Bloom_filter">维基百科对 Bloom Filter 的描述</a></li><li class="lvl-6">对应Redis命令： <code>BF.xxx</code></li></ul></li><li class="lvl-2"><p>2️⃣ Cuckoo Filter（布谷鸟过滤器）</p><ul class="lvl-2"><li class="lvl-6">Bloom Filter 的增强版，支持 删除元素</li><li class="lvl-6">对应Redis命令： <code>CF.xxx</code></li></ul></li><li class="lvl-2"><p>3️⃣ Count-Min Sketch（CMS）</p><ul class="lvl-2"><li class="lvl-6">近似统计元素出现频率</li><li class="lvl-6">对应Redis命令： <code>CMS.xxx</code></li></ul></li><li class="lvl-2"><p>4️⃣ Top-K</p><ul class="lvl-2"><li class="lvl-6">统计访问频率最高的 K 个元素</li><li class="lvl-6">对应Redis命令： <code>TOPK.xxx</code></li></ul></li></ul><h2 id="安装-RedisBloom">安装 RedisBloom</h2><blockquote><p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisbloom.so</code>上传到国内服务器即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft/modules/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft/modules</span><br><span class="line"><span class="comment"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class="line"><span class="built_in">cd</span> RedisBloom</span><br><span class="line"><span class="comment"># 推荐切换到稳定的release版本</span></span><br><span class="line">git checkout v2.8.17</span><br><span class="line"><span class="comment"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并安装需要的依赖</span></span><br><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># readies version: 7fc8e62</span></span><br><span class="line">dnf install -q -y ca-certificates</span><br><span class="line">dnf install -q -y wget unzip</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8</span><br><span class="line">dnf install -q -y git jq</span><br><span class="line">dnf install -q -y <span class="built_in">which</span></span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --modern</span><br><span class="line">dnf install -q -y valgrind</span><br><span class="line">/usr/local/soft/modules/RedisBloom/sbin/get-fbinfer</span><br><span class="line">dnf install -q -y lcov</span><br><span class="line">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class="line">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr</span><br><span class="line">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r tests/flow/requirements.txt</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws</span><br><span class="line">/usr/bin/python3 -m pip install --disable-pip-version-check --user  pudb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...</span><br><span class="line"></span><br><span class="line">Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...</span><br><span class="line">-- The C compiler identification is GNU 11.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 11.5.0</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/gcc - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/g++ - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Setting build <span class="built_in">type</span> to <span class="string">&#x27;Release&#x27;</span> as none was specified.</span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c</span><br><span class="line"></span><br><span class="line">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...</span><br><span class="line">[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o</span><br><span class="line">[100%] Linking C static library libtdigest_static.a</span><br><span class="line">[100%] Built target tdigest_static</span><br><span class="line">Compiling deps/bloom/bloom.c...</span><br><span class="line">Compiling deps/murmur2/MurmurHash2.c...</span><br><span class="line">Compiling deps/rmutil/util.c...</span><br><span class="line">Compiling src/rebloom.c...</span><br><span class="line">Compiling src/sb.c...</span><br><span class="line">Compiling src/cf.c...</span><br><span class="line">Compiling src/rm_topk.c...</span><br><span class="line">Compiling src/rm_tdigest.c...</span><br><span class="line">Compiling src/topk.c...</span><br><span class="line">Compiling src/rm_cms.c...</span><br><span class="line">Compiling src/cms.c...</span><br><span class="line">Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so...</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong><code>./sbin/setup</code> 报错</strong></em></p><ul class="lvl-1"><li class="lvl-2">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，相当于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 错误信息</span></span><br><span class="line">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class="keyword">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class="line">Status code: 403 <span class="keyword">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class="line"></span><br><span class="line">In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:</span><br><span class="line">346      <span class="comment"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class="line">347      <span class="keyword">fi</span></span><br><span class="line">348</span><br><span class="line">349  &gt;&gt;&gt; install_raven</span><br><span class="line">350      install_remi</span><br><span class="line">351      <span class="comment"># install_centos_stream_repos</span></span><br><span class="line">352</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class="line"></span><br><span class="line">In /usr/local/soft/modules/RedisBloom/sbin/setup:</span><br><span class="line">16       python3 -m pip list</span><br><span class="line">17       <span class="keyword">fi</span></span><br><span class="line">18</span><br><span class="line">19   &gt;&gt;&gt; <span class="variable">$ROOT</span>/sbin/system-setup.py</span><br><span class="line">20       <span class="keyword">if</span> [[ <span class="variable">$VERBOSE</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">21       python3 -m pip list</span><br><span class="line">22       <span class="keyword">fi</span> 编译安装时报错</span><br><span class="line"></span><br><span class="line"><span class="comment">## 错误分析与解决方法</span></span><br><span class="line">问题原因：</span><br><span class="line">    你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。</span><br><span class="line">readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。</span><br><span class="line">    这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。</span><br><span class="line">    RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel</span><br><span class="line">    这个脚本用于：</span><br><span class="line">        安装 EPEL</span><br><span class="line">        安装 Raven Repo（EL9 特有）</span><br><span class="line">        安装 Remi Repo</span><br><span class="line">    但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。</span><br><span class="line">    你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm</span><br><span class="line">    说明你使用的可能是如下系统中的一个：</span><br><span class="line">        RHEL 9</span><br><span class="line">        Rocky Linux 9</span><br><span class="line">        AlmaLinux 9</span><br><span class="line">        CentOS Stream 9</span><br><span class="line"></span><br><span class="line">推荐解决方案:</span><br><span class="line">   直接修改 getepel 脚本，禁用 install_raven</span><br><span class="line">   vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可</span><br></pre></td></tr></table></figure></div><h2 id="Redis-启用模块">Redis 启用模块</h2><ul class="lvl-0"><li class="lvl-2"><p>将生成的 <a href="http://redisbloom.so">redisbloom.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 启用模块有三种方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class="line">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"><span class="comment"># 2.也可以通过如下方式加载模块</span></span><br><span class="line">redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"><span class="comment"># 3.不需要重启redis</span></span><br><span class="line">redis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure><table><thead><tr><th>加载方式</th><th>是否持久</th></tr></thead><tbody><tr><td><code>MODULE LOAD</code>（redis-cli）</td><td>❌ 仅当前进程</td></tr><tr><td>命令行 <code>redis-server --loadmodule</code></td><td>❌ 仅本次启动</td></tr><tr><td><code>redis.conf</code> 中 <code>loadmodule</code></td><td>✅ <strong>永久生效</strong> （推荐/生产）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>本文采用 <code>loadmodule</code> 加载模块</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class="line">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">redis-server redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录测试</span></span><br><span class="line">redis-cli --user admin --pass 123456</span><br><span class="line"><span class="comment"># 查看模块</span></span><br><span class="line">127.0.0.1:6379&gt; info Modules</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 20817</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure><h2 id="测试BF命令">测试BF命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个BloomFilter，错误率0.01，元素数量1000</span></span><br><span class="line">127.0.0.1:6379&gt; BF.RESERVE <span class="built_in">test</span> 0.01 1000</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line">MBbloom--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; BF.ADD <span class="built_in">test</span> user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD <span class="built_in">test</span> user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 批量添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; BF.MADD <span class="built_in">test</span> user3 user4 user5</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 返回Bloom过滤器的基数，即添加的元素数量(存在误差)</span></span><br><span class="line">127.0.0.1:6379&gt; BF.CARD <span class="built_in">test</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"><span class="comment"># 查询元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS <span class="built_in">test</span> user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS <span class="built_in">test</span> user6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 批量查询元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; BF.MEXISTS <span class="built_in">test</span> user1 user2 user6</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取信息</span></span><br><span class="line">127.0.0.1:6379&gt; BF.INFO <span class="built_in">test</span></span><br><span class="line"> 1) Capacity       <span class="comment"># 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter）</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 1000</span><br><span class="line"> 3) Size           <span class="comment"># 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1480</span><br><span class="line"> 5) Number of filters <span class="comment"># 当前 key 内部包含的 Bloom Filter 数量</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 7) Number of items inserted  <span class="comment"># 已调用 BF.ADD / BF.MADD 插入的元素总数</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 5</span><br><span class="line"> 9) Expansion rate     <span class="comment"># Bloom Filter 扩容时，新建子过滤器的容量增长倍率</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-集成">SpringBoot 集成</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisBloomService</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.bloomfilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于Redis Bloom插件的BloomFilter实现</span></span><br><span class="line"><span class="comment"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 不想安装插件也可以使用 Redission 的 BloomFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.ReturnType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisBloomService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisBloomService</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 BloomFilter，不能重复执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterName BloomFilter 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorRate  错误率，比如为0.01，即 1%</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity   容量，比如为1000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * errorRate 说明</span></span><br><span class="line"><span class="comment">     *  1% error rate requires 7 hash functions and 9.585 bits per item.</span></span><br><span class="line"><span class="comment">     *  0.1% error rate requires 10 hash functions and 14.378 bits per item.</span></span><br><span class="line"><span class="comment">     *  0.01% error rate requires 14 hash functions and 19.170 bits per item.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reserve</span><span class="params">(String filterName, <span class="type">double</span> errorRate, <span class="type">long</span> capacity)</span> &#123;</span><br><span class="line">        redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt;</span><br><span class="line">                connection.scriptingCommands().eval(</span><br><span class="line">                        (<span class="string">&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot;</span> + errorRate + <span class="string">&quot;, &quot;</span> + capacity + <span class="string">&quot;)&quot;</span>).getBytes(),</span><br><span class="line">                        ReturnType.STATUS,</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        filterName.getBytes()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String filterName, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 RedisModule 提供的 BF.ADD 命令</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class="line">                connection.scriptingCommands().eval(</span><br><span class="line">                        (<span class="string">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class="line">                        ReturnType.BOOLEAN,</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        filterName.getBytes(),</span><br><span class="line">                        value.getBytes()</span><br><span class="line">                )</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断元素是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(String filterName, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class="line">                connection.scriptingCommands().eval(</span><br><span class="line">                        (<span class="string">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class="line">                        ReturnType.BOOLEAN,</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        filterName.getBytes(),</span><br><span class="line">                        value.getBytes()</span><br><span class="line">                )</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">addBatch</span><span class="params">(String filterName, String... values)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="literal">null</span> || values.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 keys + args 数组</span></span><br><span class="line">        <span class="type">byte</span>[][] keysAndArgs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> + values.length][];</span><br><span class="line">        keysAndArgs[<span class="number">0</span>] = filterName.getBytes();  <span class="comment">// KEYS[1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            keysAndArgs[i + <span class="number">1</span>] = values[i].getBytes(); <span class="comment">// ARGV[1..n]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BF.MADD 命令</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class="line">                connection.scriptingCommands().eval(</span><br><span class="line">                        (<span class="string">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class="line">                        ReturnType.MULTI,</span><br><span class="line">                        <span class="number">1</span>,                <span class="comment">// numKeys</span></span><br><span class="line">                        keysAndArgs       <span class="comment">// KEYS + ARGV</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模块 – RedisBloom 的使用方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文仅为学习原理，生产环境推荐使用 &lt;a href=&quot;https://redisson.pro/docs/data-and-services/objects/#bloom-filter&quot;&gt;Redisson的布隆过滤器&lt;/a&gt; 吧。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Stream</title>
    <link href="https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/"/>
    <id>https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/</id>
    <published>2025-12-20T05:40:05.000Z</published>
    <updated>2025-12-20T08:35:36.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Stream 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Stream-核心详解">Stream 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的<code>消息队列</code>，底层用<code>基数树+链表</code>实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。</p></li><li class="lvl-2"><p>建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。</p></li><li class="lvl-2"><p>Stream 与传统的MQ 的对比</p></li></ul><table><thead><tr><th>对比维度</th><th>Redis Stream</th><th>RabbitMQ</th><th>Kafka</th></tr></thead><tbody><tr><td><strong>数据模型</strong></td><td>类似日志的有序 KV 消息流（ID → field/value）</td><td>队列（FIFO）</td><td>日志分区（Partitioned Append-Only Log）</td></tr><tr><td><strong>消息持久化</strong></td><td>可选持久化（AOF / RDB），默认内存优先</td><td>可持久化到磁盘</td><td>持久化到磁盘，顺序写入，效率高</td></tr><tr><td><strong>消息确认</strong></td><td>XACK 对单条消息确认，支持 Pending 消息管理</td><td>ACK / NACK</td><td>Offset 控制，Consumer 自行提交</td></tr><tr><td><strong>消费模式</strong></td><td>支持 Consumer Group，多消费者共享 Pending 消息</td><td>Queue 绑定 Consumer，多消费者抢占</td><td>Consumer Group，多消费者平行消费</td></tr><tr><td><strong>重复消费</strong></td><td>默认可能重复，需要应用端幂等</td><td>可通过 ACK/NACK 控制</td><td>默认可能重复，Consumer 需幂等处理</td></tr><tr><td><strong>消息顺序</strong></td><td>按 Stream ID 顺序，可保证分组内顺序</td><td>队列顺序保证</td><td>Partition 内顺序保证</td></tr><tr><td><strong>消息保留策略</strong></td><td>可配置 maxlen / minid，按时间或长度裁剪</td><td>队列长度 / TTL 控制</td><td>基于时间或大小保留（Retention Policy）</td></tr><tr><td><strong>延时/定时消费</strong></td><td>原生不支持延时队列，需要应用端处理</td><td>支持插件或 TTL</td><td>原生不支持，需要应用端处理或 Kafka Streams</td></tr><tr><td><strong>事务与原子操作</strong></td><td>事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项</td><td>原生事务支持（事务 / confirm 模式）</td><td>不支持事务，依赖幂等生产者</td></tr><tr><td><strong>性能</strong></td><td>内存级高吞吐，持久化会有开销</td><td>中等，受磁盘和网络限制</td><td>高吞吐，顺序写入磁盘效率极高</td></tr><tr><td><strong>典型使用场景</strong></td><td>事件日志、轻量 MQ、内部异步流水线</td><td>企业级消息、任务调度、RPC</td><td>大数据管道、日志收集、流处理</td></tr><tr><td><strong>多语言支持</strong></td><td>客户端支持多种语言（Java、Python、Go 等）</td><td>客户端丰富</td><td>客户端丰富</td></tr><tr><td><strong>易运维性</strong></td><td>单节点即可使用，但持久化需关注内存</td><td>集群较复杂，需要 RabbitMQ 集群</td><td>集群复杂度高，需要 ZooKeeper 或 KRaft</td></tr></tbody></table><h3 id="底层核心实现">底层核心实现</h3><ol><li class="lvl-3"><p>存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。</p></li><li class="lvl-3"><p>消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。</p></li><li class="lvl-3"><p>持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。</p></li><li class="lvl-3"><p>核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。</p></li></ol><h2 id="Stream-核心基础操作（必用）">Stream 核心基础操作（必用）</h2><h3 id="1-生产消息（XADD）：写入队列">1. 生产消息（XADD）：写入队列</h3><p>• 核心命令：<code>XADD key ID 字段1 值1 字段2 值2 ...</code>，ID 写*表示自动生成（生产首选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">XADD key</span><br><span class="line">     [NOMKSTREAM]</span><br><span class="line">     [MAXLEN | MINID [= | ~] threshold [LIMIT count]]</span><br><span class="line">     * | <span class="built_in">id</span></span><br><span class="line">     field value [field value ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream 名称</span></span><br><span class="line"><span class="comment"># NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败</span></span><br><span class="line"><span class="comment"># MAXLEN threshold —— 按长度裁剪</span></span><br><span class="line"><span class="comment">#   MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）</span></span><br><span class="line"><span class="comment">#   MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大</span></span><br><span class="line"><span class="comment">#   MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高</span></span><br><span class="line"><span class="comment"># LIMIT count —— 每次最多裁剪多少条</span></span><br><span class="line"><span class="comment">#   MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程</span></span><br><span class="line"><span class="comment"># MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）</span></span><br><span class="line"><span class="comment">#   MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略</span></span><br><span class="line"><span class="comment"># * | id —— 消息 ID</span></span><br><span class="line"><span class="comment">#   *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理</span></span><br><span class="line"><span class="comment">#   id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败</span></span><br><span class="line"><span class="comment"># field value —— 消息体（Payload）</span></span><br><span class="line"><span class="comment">#   至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改</span></span><br></pre></td></tr></table></figure><p>• 示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向订单队列写入1条消息，自动生成消息ID</span></span><br><span class="line">XADD order_stream * uid 1001 order_no ORD20251220 price 299</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">&quot;1766215406540-0&quot;</span> <span class="comment"># 消息ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留某个时间点之后的日志</span></span><br><span class="line">XADD <span class="built_in">log</span> MINID ~ 1689900000000-0 * level INFO msg <span class="string">&quot;startup&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-消费消息（2种核心模式）">2. 消费消息（2种核心模式）</h3><h4 id="（1）-独立消费（无消费组）：一对一消费，适合简单场景">（1） 独立消费（无消费组）：一对一消费，适合简单场景</h4><p>• XREAD：主动拉取消息，支持阻塞/非阻塞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XREAD</span><br><span class="line">  [COUNT count]</span><br><span class="line">  [BLOCK milliseconds]</span><br><span class="line">  STREAMS key [key ...]</span><br><span class="line">          <span class="built_in">id</span>  [<span class="built_in">id</span>  ...]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># COUNT count —— 单次最多读取多少条，是“上限”，不是保证值</span></span><br><span class="line"><span class="comment"># BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil</span></span><br><span class="line"><span class="comment">#   BLOCK 0: 无限阻塞，直到有新消息</span></span><br><span class="line"><span class="comment"># STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应</span></span><br><span class="line"><span class="comment"># id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身</span></span><br><span class="line"><span class="comment">#   普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0</span></span><br><span class="line"><span class="comment">#   $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $</span></span><br></pre></td></tr></table></figure><p>• 示例1（非阻塞）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从开头拉5条消息</span></span><br><span class="line">XREAD COUNT 5 STREAMS order_stream 0-0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;order_stream&quot;</span>          <span class="comment"># Stream名称</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1766215406540-0&quot;</span> <span class="comment"># 消息ID</span></span><br><span class="line">         2) 1) <span class="string">&quot;uid&quot;</span>          <span class="comment"># 消息体 键值对</span></span><br><span class="line">            2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">            3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">            4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">            5) <span class="string">&quot;price&quot;</span></span><br><span class="line">            6) <span class="string">&quot;299&quot;</span></span><br></pre></td></tr></table></figure><p>• 示例2（阻塞）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。</span></span><br><span class="line">XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $</span><br></pre></td></tr></table></figure><h4 id="（2）-消费组消费（XGROUP）：一对多消费，核心生产模式">（2） 消费组消费（XGROUP）：一对多消费，核心生产模式</h4><ul class="lvl-0"><li class="lvl-2"><p>Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。</p></li><li class="lvl-2"><ol><li class="lvl-5">先创建消费组<code>XGROUP CREATE</code></li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key group <span class="built_in">id</span>|$</span><br><span class="line">       [MKSTREAM]</span><br><span class="line">       [ENTRIESREAD entries-read]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key：Stream 名称，为指定的Stream创建消费组</span></span><br><span class="line"><span class="comment"># group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group</span></span><br><span class="line"><span class="comment"># id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。</span></span><br><span class="line"><span class="comment"># [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用</span></span><br><span class="line"><span class="comment"># [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建group1消费组，从最新订单消息开始消费</span></span><br><span class="line">XGROUP CREATE order_stream group1 $ MKSTREAM</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>消费者拉取消息<code>XREADGROUP</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer</span><br><span class="line">           [COUNT count]</span><br><span class="line">           [BLOCK milliseconds]</span><br><span class="line">           [NOACK]</span><br><span class="line">           STREAMS key [key ...]</span><br><span class="line">                   <span class="built_in">id</span>  [<span class="built_in">id</span>  ...]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># GROUP group consumer: 指定消费者组名：group，消费者名：consumer</span></span><br><span class="line"><span class="comment">#    同一个 group 下，不同 consumer 不会收到重复消息</span></span><br><span class="line"><span class="comment"># [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证</span></span><br><span class="line"><span class="comment"># [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒</span></span><br><span class="line"><span class="comment">#    BLOCK 0 → 永久阻塞</span></span><br><span class="line"><span class="comment"># [NOACK] —— 不进入 Pending（⚠️ 谨慎）</span></span><br><span class="line"><span class="comment">#    消息 不会进入 Pending，不需要 XACK，消费后即认为完成</span></span><br><span class="line"><span class="comment">#    风险：消费者崩溃 → 消息直接丢失，不可重投递</span></span><br><span class="line"><span class="comment"># STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致</span></span><br><span class="line"><span class="comment"># id [id ...] —— 决定“读什么”的关键</span></span><br><span class="line"><span class="comment">#    使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息</span></span><br><span class="line"><span class="comment">#    使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息</span></span><br><span class="line"><span class="comment">#    多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。</span></span><br><span class="line">XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;</span><br><span class="line"><span class="comment">## 此时在5秒内创建新的消息，就会有类似如下输出</span></span><br><span class="line">1) 1) <span class="string">&quot;order_stream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1766215642763-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;uid&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">            3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">            4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">            5) <span class="string">&quot;price&quot;</span></span><br><span class="line">            6) <span class="string">&quot;299&quot;</span></span><br><span class="line">(1.50s)</span><br></pre></td></tr></table></figure><h3 id="3-消息确认（XACK）">3. 消息确认（XACK）</h3><ul class="lvl-0"><li class="lvl-2"><p>消费完成后必须确认，否则会被标记为「未确认消息」</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XACK key 消费组名 消息ID1 消息ID2 ...。</span></span><br><span class="line">XACK key group <span class="built_in">id</span> [<span class="built_in">id</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记</span></span><br><span class="line">XACK order_stream group1 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure><h3 id="4-消息重试">4. 消息重试</h3><ul class="lvl-0"><li class="lvl-2"><p>未确认的消息，会被存入消费组的<code>「PEL（Pending Entries List）」</code>，可通过<code>XPENDING key 消费组名</code>查看，支持<code>XCLAIM</code>将<code>PEL</code>中的消息转移给其他消费者处理，避免单点故障导致消息堆积。</p></li><li class="lvl-2"><p>XPENDING：查看未被确认的消息情况</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">XPENDING key group</span><br><span class="line">        [[IDLE min-idle-time]</span><br><span class="line">         start end count</span><br><span class="line">         [consumer]]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream 名称，必须存在</span></span><br><span class="line"><span class="comment"># group: 消费者组名称，必须存在</span></span><br><span class="line"><span class="comment"># [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息</span></span><br><span class="line"><span class="comment">#    min-idle-time(空闲时间) = 从上次投递 / claim到现在</span></span><br><span class="line"><span class="comment"># start end —— ID 范围</span></span><br><span class="line"><span class="comment">#    -: 最小ID</span></span><br><span class="line"><span class="comment">#    +: 最大ID</span></span><br><span class="line"><span class="comment"># count —— 返回条数上限</span></span><br><span class="line"><span class="comment"># [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部</span></span><br><span class="line"><span class="comment"># 只返回 元数据，不返回消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1: 查看是否有消息积压</span></span><br><span class="line">XPENDING order_stream group1</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1      <span class="comment"># 积压消息数，未确认消息数量</span></span><br><span class="line">2) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># Pending 中最小 ID</span></span><br><span class="line">3) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># Pending 中最大 ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumerA&quot;</span> <span class="comment"># 按 consumer 统计的 Pending 数量</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条</span></span><br><span class="line">XPENDING order_stream group1 IDLE 60000 - + 10</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># 消息 ID</span></span><br><span class="line">   2) <span class="string">&quot;consumerA&quot;</span>       <span class="comment"># 当前持有该消息的 consumer</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 255581  <span class="comment"># idle 时间（毫秒）</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 2       <span class="comment"># delivery count（投递次数）,该消息至少被投递过 2 次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3: 只查看 consumerA 的 Pending，最多返回20条</span></span><br><span class="line">XPENDING order_stream group1 - + 20 consumerA</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>XCLAIM: 转移投递</p></li></ul><blockquote><p>将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。<br>一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">XCLAIM key group consumer min-idle-time <span class="built_in">id</span> [<span class="built_in">id</span> ...]</span><br><span class="line">       [IDLE ms]</span><br><span class="line">       [TIME unix-time-milliseconds]</span><br><span class="line">       [RETRYCOUNT count]</span><br><span class="line">       [FORCE]</span><br><span class="line">       [JUSTID]</span><br><span class="line">       [LASTID lastid]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream Key，必须存在</span></span><br><span class="line"><span class="comment"># group: 消费者组名称，必须存在</span></span><br><span class="line"><span class="comment"># consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer</span></span><br><span class="line"><span class="comment"># min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim</span></span><br><span class="line"><span class="comment"># id [id ...]: 指定要 claim 的消息 ID，ID必须存在</span></span><br><span class="line"><span class="comment"># [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态</span></span><br><span class="line"><span class="comment"># [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码</span></span><br><span class="line"><span class="comment"># [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”</span></span><br><span class="line"><span class="comment"># [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险</span></span><br><span class="line"><span class="comment"># [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销</span></span><br><span class="line"><span class="comment"># [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为</span></span><br><span class="line"><span class="comment">#    ⚠️ 高级特性，一般不建议业务代码使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"><span class="comment"># 1️⃣ 抢占 idle 超过 60s 的消息</span></span><br><span class="line">XCLAIM order_stream group1 consumerB 60000 1766215642763-0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;1766215642763-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;uid&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">      3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">      4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">      5) <span class="string">&quot;price&quot;</span></span><br><span class="line">      6) <span class="string">&quot;299&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2️⃣ 抢占并标记为第 3 次重试</span></span><br><span class="line">XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3</span><br><span class="line"><span class="comment"># 3️⃣ 只返回 ID（配合批处理）</span></span><br><span class="line">XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID</span><br></pre></td></tr></table></figure><h2 id="高级特性（生产必备）">高级特性（生产必备）</h2><ol><li class="lvl-3"><p>消息回溯与遍历</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）</span></span><br><span class="line">XRANGE key start end [COUNT count]</span><br><span class="line"><span class="comment"># XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）</span></span><br><span class="line">XREVRANGE key end start [COUNT count]</span><br><span class="line"><span class="comment"># 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。</span></span><br><span class="line">XRANGE order_stream 0-0 + COUNT 10</span><br><span class="line">XRANGE order_stream - + COUNT 10</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>队列信息查询</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查消息总数</span></span><br><span class="line">XLEN key</span><br><span class="line"><span class="comment"># 查Stream完整元数据（最新ID、消费组数量、消息总数等）</span></span><br><span class="line"></span><br><span class="line">XINFO STREAM key [FULL [COUNT count]]</span><br><span class="line"><span class="comment">## FULL: 完整模式</span></span><br><span class="line">    <span class="comment"># 👉 返回：</span></span><br><span class="line">    <span class="comment">#     Stream 元信息</span></span><br><span class="line">    <span class="comment">#     所有 Consumer Group</span></span><br><span class="line">    <span class="comment">#     每个 Group 的 Consumer</span></span><br><span class="line">    <span class="comment">#     Pending Entries List（PEL）</span></span><br><span class="line">    <span class="comment">#     部分历史 entries</span></span><br><span class="line">    <span class="comment"># ⚠️ 开销很大，慎用于生产环境。</span></span><br><span class="line"><span class="comment">## COUNT count（FULL 模式的限制参数）</span></span><br><span class="line">    <span class="comment">#   XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查所有消费组信息</span></span><br><span class="line">XINFO GROUPS key</span><br><span class="line"><span class="comment"># 查该组下所有消费者</span></span><br><span class="line">XINFO CONSUMERS key 消费组名</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>消费组管理</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除消费组</span></span><br><span class="line">XGROUP DESTROY key 消费组名</span><br><span class="line"><span class="comment"># 删除消费者</span></span><br><span class="line">XGROUP DELCONSUMER key 消费组名 消费者名</span><br><span class="line"><span class="comment"># 重置消费组起始ID</span></span><br><span class="line">XGROUP SETID key 消费组名 新ID</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。</p></li></ol><h2 id="生产环境核心痛点与解决方案">生产环境核心痛点与解决方案</h2><ol><li class="lvl-3"><p>消息丢失：3重保障</p><ul class="lvl-2"><li class="lvl-6">开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性）</li><li class="lvl-6">生产者写入后确认返回值（确保写入成功）</li><li class="lvl-6">消费者消费后必须<code>XACK</code>确认。</li></ul></li><li class="lvl-3"><p>消息堆积：2种处理</p><ul class="lvl-2"><li class="lvl-6">① 写入时用<code>MAXLEN</code>设置上限，淘汰旧消息；</li><li class="lvl-6">② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。</li></ul></li><li class="lvl-3"><p>重复消费</p><ul class="lvl-2"><li class="lvl-6">根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL）</li><li class="lvl-6">解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。</li></ul></li><li class="lvl-3"><p>阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。</p></li></ol><h2 id="典型应用场景">典型应用场景</h2><h3 id="分布式业务解耦（订单-库存-支付-物流解耦）">分布式业务解耦（订单-库存-支付-物流解耦）</h3><blockquote><p>核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。</p></blockquote><ol><li class="lvl-3"><p>生产者（订单服务）：写入订单完成消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）</span></span><br><span class="line">XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建3个独立消费组（库存/支付/物流）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库存消费组：从最新消息开始消费，队列不存在则自动创建</span></span><br><span class="line">XGROUP CREATE order_core_stream group_stock $ MKSTREAM</span><br><span class="line"><span class="comment"># 支付消费组</span></span><br><span class="line">XGROUP CREATE order_core_stream group_pay $ MKSTREAM</span><br><span class="line"><span class="comment"># 物流消费组</span></span><br><span class="line">XGROUP CREATE order_core_stream group_logistics $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>各消费组消费者拉取+确认消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒</span></span><br><span class="line">XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line"><span class="comment"># 库存处理完成后确认消息（替换为实际拉取到的消息ID）</span></span><br><span class="line">XACK order_core_stream group_stock 1734567890000-0 1734567890001-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付服务消费者（consumer_pay1）同理</span></span><br><span class="line">XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line">XACK order_core_stream group_pay 1734567890000-0 1734567890001-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物流服务消费者（consumer_log1）同理</span></span><br><span class="line">XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line">XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure><h3 id="异步任务处理（用户注册-邮件-短信-积分异步执行）">异步任务处理（用户注册-邮件/短信/积分异步执行）</h3><blockquote><p>核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。</p></blockquote><ol><li class="lvl-3"><p>生产者（注册服务）：用户注册成功后写入消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息</span></span><br><span class="line">XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建单个消费组（统一处理注册后续任务）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短信发送消费者（consumer_sms）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件发送消费者（consumer_email）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 积分发放消费者（consumer_score）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br></pre></td></tr></table></figure><h3 id="日志收集（系统实时日志-分析-告警）">日志收集（系统实时日志-分析/告警）</h3><blockquote><p>核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。</p></blockquote><ol><li class="lvl-3"><p>生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）</span></span><br><span class="line">XADD sys_log_stream * module order_service level ERROR content <span class="string">&quot;库存扣减失败，订单号ORD20251220001&quot;</span> log_time 1734567910</span><br><span class="line">XADD sys_log_stream * module pay_service level INFO content <span class="string">&quot;支付成功，uid1001，金额299&quot;</span> log_time 1734567912</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建2个消费组（日志分析+实时告警）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志</span></span><br><span class="line">XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM</span><br><span class="line"><span class="comment"># 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费</span></span><br><span class="line">XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>对应消费者拉取处理</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志分析消费者（批量拉取，非阻塞，适合离线处理）</span></span><br><span class="line">XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;</span><br><span class="line">XACK sys_log_stream group_log_analysis 批量消息ID...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）</span></span><br><span class="line">XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt;  <span class="comment"># BLOCK 0 永久阻塞，有消息立即返回</span></span><br><span class="line">XACK sys_log_stream group_log_alert 告警消息ID</span><br></pre></td></tr></table></figure><h3 id="限流削峰（秒杀场景-请求削峰填谷）">限流削峰（秒杀场景-请求削峰填谷）</h3><blockquote><p>核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。</p></blockquote><ol><li class="lvl-3"><p>生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中”</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）</span></span><br><span class="line">XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建消费组（单消费组+多消费者，控制总处理速率）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE seckill_stream group_seckill $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）</span></span><br><span class="line">XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;</span><br><span class="line"><span class="comment"># 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）</span></span><br><span class="line">XACK seckill_stream group_seckill 秒杀请求消息ID...</span><br></pre></td></tr></table></figure><blockquote><p>关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。</p></blockquote><h2 id="与其他-Redis-队列方案对比（核心优势）">与其他 Redis 队列方案对比（核心优势）</h2><p>• 对比 List<br>- List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列；<br>- Stream 支持多播+消费组+确认机制，适合复杂分布式场景。</p><table><thead><tr><th>对比项</th><th>Stream</th><th>List</th></tr></thead><tbody><tr><td>消费者组</td><td>✅</td><td>❌</td></tr><tr><td>ACK</td><td>✅</td><td>❌</td></tr><tr><td>重试</td><td>✅</td><td>❌</td></tr><tr><td>阻塞</td><td>✅</td><td>✅</td></tr><tr><td>顺序性</td><td>强</td><td>强</td></tr></tbody></table><p>• 对比 Pub/Sub<br>- Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息；<br>- Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。</p><h2 id="Stream-命令">Stream 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForStream()</code> 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里不一定要用 <code>StringRedisTemplate</code> 来操作 Stream，但是用 <code>StringRedisTemplate</code> 可以保证可读性。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>核心能力划分：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">消息写入（XADD）</span><br><span class="line">消息确认（XACK）</span><br><span class="line">消息读取（XRANGE / XREAD / XREADGROUP）</span><br><span class="line">Pending 消息管理（XPENDING / XCLAIM）</span><br><span class="line">消费者组管理（XGROUP）</span><br><span class="line">Stream 元信息（XINFO）</span><br><span class="line">Stream 裁剪与删除（XTRIM / XDEL）</span><br><span class="line">对象映射（MapRecord / ObjectRecord）</span><br></pre></td></tr></table></figure><h3 id="消息写入（XADD）">消息写入（XADD）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 基础写入</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>opsForStream().xxx()</code></th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>写入 Map</td><td><code>add(K key, Map&lt;HK,HV&gt;)</code></td><td><code>XADD key * field value</code></td><td>自动生成 ID</td></tr><tr><td>写入 Record</td><td><code>add(Record&lt;K, ?&gt; record)</code></td><td><code>XADD</code></td><td>支持 ObjectRecord</td></tr><tr><td>写入 MapRecord</td><td><code>add(MapRecord&lt;K,HK,HV&gt;)</code></td><td><code>XADD</code></td><td>Map 形式</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 带参数写入（推荐）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>写入 + 选项</td><td><code>add(record, XAddOptions)</code></td><td><code>XADD ...</code></td><td>支持 MAXLEN / NOMKSTREAM</td></tr><tr><td>Map + 选项</td><td><code>add(key, map, XAddOptions)</code></td><td><code>XADD</code></td><td>Redis ≥ 6</td></tr></tbody></table><h3 id="消息确认（XACK）">消息确认（XACK）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>确认消息</td><td><code>acknowledge(key, group, recordIds…)</code></td><td><code>XACK</code></td><td>标记已消费</td></tr><tr><td>Record 确认</td><td><code>acknowledge(group, record)</code></td><td><code>XACK</code></td><td>常用</td></tr></tbody></table><blockquote><p>⚠️ 只对 Consumer Group 生效</p></blockquote><h3 id="消息读取（无消费者组）">消息读取（无消费者组）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 按 Range 读取（历史数据）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>正序读取</td><td><code>range(key, range)</code></td><td><code>XRANGE</code></td></tr><tr><td>限制条数</td><td><code>range(key, range, limit)</code></td><td><code>XRANGE</code></td></tr><tr><td>反序读取</td><td><code>reverseRange(key, range)</code></td><td><code>XREVRANGE</code></td></tr><tr><td>反序 + limit</td><td><code>reverseRange(key, range, limit)</code></td><td><code>XREVRANGE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 实时读取（XREAD）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>读取</td><td><code>read(StreamOffset…)</code></td><td><code>XREAD</code></td><td>不支持 ACK</td></tr><tr><td>带参数</td><td><code>read(options, offsets…)</code></td><td><code>XREAD</code></td><td>BLOCK / COUNT</td></tr><tr><td>映射对象</td><td><code>read(Class&lt;T&gt;, …)</code></td><td><code>XREAD</code></td><td>自动反序列化</td></tr></tbody></table><h3 id="消费者组读取（XREADGROUP）">消费者组读取（XREADGROUP）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>组内读取</td><td><code>read(Consumer, offsets…)</code></td><td><code>XREADGROUP</code></td><td>MQ 核心</td></tr><tr><td>带参数</td><td><code>read(Consumer, options, offsets…)</code></td><td><code>XREADGROUP</code></td><td>BLOCK</td></tr><tr><td>映射对象</td><td><code>read(Class&lt;T&gt;, Consumer, …)</code></td><td><code>XREADGROUP</code></td><td>—</td></tr></tbody></table><h3 id="Pending-消息管理（XPENDING-XCLAIM）">Pending 消息管理（XPENDING / XCLAIM）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ Pending 查询</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>Pending 汇总</td><td><code>pending(key, group)</code></td><td><code>XPENDING</code></td></tr><tr><td>指定消费者</td><td><code>pending(key, consumer)</code></td><td><code>XPENDING</code></td></tr><tr><td>范围查询</td><td><code>pending(key, group, range, count)</code></td><td><code>XPENDING</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 消息重新分配（XCLAIM）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>重新分配</td><td><code>claim(key, group, newOwner, minIdle, ids…)</code></td><td><code>XCLAIM</code></td><td>超时接管</td></tr><tr><td>高级配置</td><td><code>claim(key, group, newOwner, XClaimOptions)</code></td><td><code>XCLAIM</code></td><td>force / retry</td></tr></tbody></table><h3 id="消费者组管理（XGROUP）">消费者组管理（XGROUP）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>创建组</td><td><code>createGroup(key, group)</code></td><td><code>XGROUP CREATE</code></td><td>从 <code>$</code> 开始</td></tr><tr><td>指定 offset</td><td><code>createGroup(key, offset, group)</code></td><td><code>XGROUP CREATE</code></td><td>常用 <code>0-0</code></td></tr><tr><td>删除消费者</td><td><code>deleteConsumer(key, consumer)</code></td><td><code>XGROUP DELCONSUMER</code></td><td></td></tr><tr><td>销毁组</td><td><code>destroyGroup(key, group)</code></td><td><code>XGROUP DESTROY</code></td><td></td></tr></tbody></table><h3 id="Stream-元信息（XINFO）">Stream 元信息（XINFO）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>Stream 信息</td><td><code>info(key)</code></td><td><code>XINFO STREAM</code></td></tr><tr><td>组信息</td><td><code>groups(key)</code></td><td><code>XINFO GROUPS</code></td></tr><tr><td>消费者信息</td><td><code>consumers(key, group)</code></td><td><code>XINFO CONSUMERS</code></td></tr></tbody></table><h3 id="Stream-删除-裁剪">Stream 删除 / 裁剪</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 删除消息</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>删除消息</td><td><code>delete(key, recordIds…)</code></td><td><code>XDEL</code></td></tr><tr><td>删除 Record</td><td><code>delete(record)</code></td><td><code>XDEL</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 裁剪 Stream（XTRIM）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>精确裁剪</td><td><code>trim(key, count)</code></td><td><code>XTRIM</code></td><td></td></tr><tr><td>近似裁剪</td><td><code>trim(key, count, true)</code></td><td><code>XTRIM ~</code></td><td>性能更好</td></tr></tbody></table><h3 id="对象映射能力（非常重要）">对象映射能力（非常重要）</h3><table><thead><tr><th>能力</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Map → Object</td><td><code>map(MapRecord, Class&lt;T&gt;)</code></td><td>自动反序列化</td></tr><tr><td>List 映射</td><td><code>map(List&lt;MapRecord&gt;, Class&lt;T&gt;)</code></td><td></td></tr><tr><td>HashMapper</td><td><code>getHashMapper(Class&lt;T&gt;)</code></td><td>自定义映射</td></tr><tr><td>反序列化</td><td><code>deserializeRecord(ByteRecord)</code></td><td>底层能力</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Stream 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Geo</title>
    <link href="https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/"/>
    <id>https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/</id>
    <published>2025-12-19T13:40:05.000Z</published>
    <updated>2025-12-20T05:57:13.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Geo 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Geo-核心详解">Geo 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Geo 是基于有序集合（<code>zset</code>） 实现的地理空间操作功能，底层用<code>geohash编码</code>存储<code>经纬度</code>，核心支持 6 个基础操作 + 2 个扩展操作，兼顾<code>精准存储</code>、<code>距离计算</code>、<code>范围筛选</code>等核心需求，直接对接实际场景（如附近门店、同城好友）。</p></li><li class="lvl-2"><p>有效经度(longitude)为 <code>-180 ~ 180</code>，有效纬度(latitude)为 <code>-85.05112878 ~ 85.05112878</code>。</p></li><li class="lvl-2"><p>Redis 内部实现中：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEO 数据 ≈ ZSET</span><br><span class="line">score = GeoHash（52 位bit ≈ 11 个字符）</span><br><span class="line">member = 实际成员名</span><br></pre></td></tr></table></figure><h2 id="Geohash-是什么">Geohash 是什么?</h2><ul class="lvl-0"><li class="lvl-2"><p>Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将「位置」映射为「可排序的值」</span><br><span class="line">相近的地理位置 → 前缀相同或接近</span><br><span class="line">便于 范围查询、邻近查询、索引存储</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>核心思想</p></li></ul><blockquote><p>不断对经纬度区间进行二分，并交叉编码<br>编码顺序：经度 → 纬度 → 经度 → 纬度 → …</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每一步：</span><br><span class="line">    1.取当前区间的中点</span><br><span class="line">    2.大于中点记为 1</span><br><span class="line">    3.小于中点记为 0</span><br><span class="line">    4.缩小区间，继续下一位</span><br><span class="line">最终得到一个 bit 序列。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 内部的 Geohash 字符 = <code>52bit</code>，即 经度 <code>26 bit</code>，纬度 <code>26 bit</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个字符 = 5 bit</span><br><span class="line">内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bit</span><br><span class="line"></span><br><span class="line">Redis 默认在输出字符串时：</span><br><span class="line">    会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0</span><br><span class="line">    因此最终得到 11 个 Base32 字符</span><br></pre></td></tr></table></figure><h3 id="Geohash-计算过程示例">Geohash 计算过程示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">longitude = 116.397128</span><br><span class="line">latitude  = 39.916527</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了简化计算过程，我们这里固定一个常用精度：</p><ul class="lvl-2"><li class="lvl-6">精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度）</li></ul></li><li class="lvl-2"><p>逐位计算（关键过程）<br>1️⃣ 经度 bit（13 位）</p></li></ul><table><thead><tr><th>位次</th><th>区间</th><th>mid</th><th>判断</th><th>bit</th></tr></thead><tbody><tr><td>1</td><td>[-180,180]</td><td>0</td><td>116 ≥ 0</td><td>1</td></tr><tr><td>2</td><td>[0,180]</td><td>90</td><td>116 ≥ 90</td><td>1</td></tr><tr><td>3</td><td>[90,180]</td><td>135</td><td>116 &lt; 135</td><td>0</td></tr><tr><td>4</td><td>[90,135]</td><td>112.5</td><td>116 ≥ 112.5</td><td>1</td></tr><tr><td>5</td><td>[112.5,135]</td><td>123.75</td><td>116 &lt; 123.75</td><td>0</td></tr><tr><td>6</td><td>[112.5,123.75]</td><td>118.125</td><td>116 &lt; 118.125</td><td>0</td></tr><tr><td>7</td><td>[112.5,118.125]</td><td>115.3125</td><td>116 ≥ 115.3125</td><td>1</td></tr><tr><td>8</td><td>[115.3125,118.125]</td><td>116.71875</td><td>116 &lt; 116.71875</td><td>0</td></tr><tr><td>9</td><td>[115.3125,116.71875]</td><td>116.015625</td><td>116 ≥ 116.015625</td><td>1</td></tr><tr><td>10</td><td>[116.015625,116.71875]</td><td>116.3671875</td><td>116 ≥ 116.3671875</td><td>1</td></tr><tr><td>11</td><td>[116.3671875,116.71875]</td><td>116.54296875</td><td>116 &lt; 116.54296875</td><td>0</td></tr><tr><td>12</td><td>[116.3671875,116.54296875]</td><td>116.455078125</td><td>116 &lt; 116.455078125</td><td>0</td></tr><tr><td>13</td><td>[116.3671875,116.455078125]</td><td>116.4111328125</td><td>116 &lt; 116.4111328125</td><td>0</td></tr></tbody></table><blockquote><p>经度 bit（13 位）：<code>1101001011000</code></p></blockquote><p>2️⃣ 纬度 bit（12 位）</p><table><thead><tr><th>位次</th><th>区间</th><th>mid</th><th>判断</th><th>bit</th></tr></thead><tbody><tr><td>1</td><td>[-90,90]</td><td>0</td><td>39 ≥ 0</td><td>1</td></tr><tr><td>2</td><td>[0,90]</td><td>45</td><td>39 &lt; 45</td><td>0</td></tr><tr><td>3</td><td>[0,45]</td><td>22.5</td><td>39 ≥ 22.5</td><td>1</td></tr><tr><td>4</td><td>[22.5,45]</td><td>33.75</td><td>39 ≥ 33.75</td><td>1</td></tr><tr><td>5</td><td>[33.75,45]</td><td>39.375</td><td>39 &lt; 39.375</td><td>0</td></tr><tr><td>6</td><td>[33.75,39.375]</td><td>36.5625</td><td>39 ≥ 36.5625</td><td>1</td></tr><tr><td>7</td><td>[36.5625,39.375]</td><td>37.96875</td><td>39 ≥ 37.96875</td><td>1</td></tr><tr><td>8</td><td>[37.96875,39.375]</td><td>38.671875</td><td>39 ≥ 38.671875</td><td>1</td></tr><tr><td>9</td><td>[38.671875,39.375]</td><td>39.0234375</td><td>39 &lt; 39.0234375</td><td>0</td></tr><tr><td>10</td><td>[38.671875,39.0234375]</td><td>38.84765625</td><td>39 ≥ 38.84765625</td><td>1</td></tr><tr><td>11</td><td>[38.84765625,39.0234375]</td><td>38.935546875</td><td>39 ≥ 38.935546875</td><td>1</td></tr><tr><td>12</td><td>[38.935546875,39.0234375]</td><td>38.9794921875</td><td>39 ≥ 38.9794921875</td><td>1</td></tr></tbody></table><blockquote><p>纬度 bit（12 位）：<code>101101110111</code></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>交叉合并（最终 bit 序列）</p></li></ul><blockquote><p>按规则：经度 → 纬度 → 经度 → 纬度 …</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经度: 1 1 0 1 0 0 1 0 1 1 0 0 0</span><br><span class="line">纬度: 1 0 1 1 0 1 1 1 0 1 1 1</span><br><span class="line"></span><br><span class="line">交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01</span><br><span class="line">合并为一行：1110011100011101101010101</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>每 5 bit → 1 个 Base32 字符</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从左到右，每 5 位一组：</span></span><br><span class="line">11100 | 11100 | 01110 | 11010 | 10101</span><br><span class="line"><span class="comment"># 转10进制</span></span><br><span class="line">28    | 28    | 14    | 26    | 21</span><br><span class="line"><span class="comment"># 转 Base32</span></span><br><span class="line">w     | w    | f    | u    | p</span><br><span class="line"><span class="comment"># 最终结果：</span></span><br><span class="line">wwfup</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）：</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Index:  0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Char :  0 1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">Index: 10 11 12 13 14 15 16 17 18 19</span><br><span class="line">Char :  b  c  d  e  f  g  h  j  k  m</span><br><span class="line"></span><br><span class="line">Index: 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">Char :  n  p  q  r  s  t  u  v  w  x</span><br><span class="line"></span><br><span class="line">Index: 30 31</span><br><span class="line">Char :  y  z</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">Geohash Base32 字符集 为什么缺少 <code>a, i, l, o</code><ul class="lvl-3"><li class="lvl-6">为了避免在视觉上引起数字混淆</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a 容易和 4 混淆</span><br><span class="line">i 容易和 1 混淆</span><br><span class="line">l 容易和 1 混淆</span><br><span class="line">o 容易和 0 混淆</span><br></pre></td></tr></table></figure><ul class="lvl-3"><li class="lvl-6">去掉 <code>a, i, l, o</code> 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度</li></ul></li></ul></div><h2 id="Geo-核心基础操作（必用）">Geo 核心基础操作（必用）</h2><h3 id="1-GEOADD：添加地理位置坐标（核心写入操作）">1. GEOADD：添加地理位置坐标（核心写入操作）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># NX：如果已存在，则不执行写入操作</span></span><br><span class="line"><span class="comment"># XX: 如果不存在，则执行写入操作，与 NX 互斥</span></span><br><span class="line"><span class="comment"># CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量</span></span><br><span class="line"><span class="comment"># longitude: 经度 (-180 ~ 180)</span></span><br><span class="line"><span class="comment"># latitude: 纬度 (-85.05112878 ~ 85.05112878)</span></span><br><span class="line"><span class="comment"># member: 成员名称，位置唯一标识（字符串）</span></span><br><span class="line"><span class="comment"># 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量</span></span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给shop集合加王府井、西单2个门店的经纬度</span></span><br><span class="line">GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。</p><h3 id="2-GEOPOS：获取指定成员的经纬度（精准查询坐标）">2. GEOPOS：获取指定成员的经纬度（精准查询坐标）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key [member [member ...]]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井的经纬度数组 [经度, 纬度]</span></span><br><span class="line">GEOPOS shop wangfujing</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。</p><h3 id="3-GEODIST：计算两个成员之间的距离（核心计算操作）">3. GEODIST：计算两个成员之间的距离（核心计算操作）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GEODIST key member1 member2 [M|KM|FT|MI]</span><br><span class="line"><span class="comment"># [M|KM|FT|MI] : 距离单位</span></span><br><span class="line"><span class="comment"># M : 米，默认</span></span><br><span class="line"><span class="comment"># KM : 千米</span></span><br><span class="line"><span class="comment"># FT : 英尺</span></span><br><span class="line"><span class="comment"># MI : 英里</span></span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井和西单之间的距离，单位为米</span></span><br><span class="line">GEODIST shop wangfujing xidan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">&quot;1468.0611&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算王府井到西单的距离，单位千米</span></span><br><span class="line">GEODIST shop wangfujing xidan km</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。</p><h3 id="4-GEOHASH：获取指定成员的geohash编码（底层编码查询）">4. GEOHASH：获取指定成员的geohash编码（底层编码查询）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH key [member [member ...]]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井的geohash字符串，共11位</span></span><br><span class="line">GEOHASH shop wangfujing</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) <span class="string">&quot;wx4g0f6f2u0&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。</p><h3 id="5-GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）">5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）</h3><ul class="lvl-0"><li class="lvl-2"><p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>◦ 语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># longitude: 经度</span></span><br><span class="line"><span class="comment"># latitude: 纬度</span></span><br><span class="line"><span class="comment"># radius: 半径</span></span><br><span class="line"><span class="comment"># M|KM|FT|MI: 单位</span></span><br><span class="line"><span class="comment">## 可选参数</span></span><br><span class="line"><span class="comment"># WITHCOORD: 返回经纬度</span></span><br><span class="line"><span class="comment"># WITHDIST: 带距离</span></span><br><span class="line"><span class="comment"># WITHHASH: 带geohash</span></span><br><span class="line"><span class="comment"># COUNT count: 限制返回数量</span></span><br><span class="line"><span class="comment"># ANY: 随机返回数量</span></span><br><span class="line"><span class="comment"># ASC/DESC: 按距离正/倒序</span></span><br><span class="line"><span class="comment"># STORE key: 存储结果到指定key</span></span><br><span class="line"><span class="comment"># STOREDIST key: 存储结果到指定key，结果为距离</span></span><br></pre></td></tr></table></figure><p>◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序）</p><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离</span></span><br><span class="line">GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.6463&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.8223&quot;</span></span><br></pre></td></tr></table></figure><h3 id="6-GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）">6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）</h3><ul class="lvl-0"><li class="lvl-2"><p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>◦ 语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class="line"><span class="comment"># 语法说明：</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># member: 已有成员名称</span></span><br><span class="line"><span class="comment"># radius: 半径</span></span><br><span class="line"><span class="comment"># M|KM|FT|MI: 单位</span></span><br><span class="line"><span class="comment">## 可选参数说明同 GEORADIUS</span></span><br></pre></td></tr></table></figure><p>◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令）<br>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井3km内的门店，按距离排序</span></span><br><span class="line">GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Geo-扩展操作（实战常用）">Geo 扩展操作（实战常用）</h2><h3 id="1-GEOSEARCH（Redis-6-2-新增，替代-GEORADIUS-GEORADIUSBYMEMBER）">1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER）</h3><p>◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class="line">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class="line">  [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure><p>◦ 语法1（按坐标中心）：<code>GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查天安门3km内的门店，按距离排序</span></span><br><span class="line">GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.6463&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885362016563</span><br><span class="line">   4) 1) <span class="string">&quot;116.39124959707260132&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90621776267477827&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.8223&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 语法2（按成员中心）：<code>GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井3km内的门店，按距离排序</span></span><br><span class="line">GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;1.4681&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885362016563</span><br><span class="line">   4) 1) <span class="string">&quot;116.39124959707260132&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90621776267477827&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 新增特性：支持 <code>BYBOX（按矩形范围查询）</code>，适配更多场景（如查询某片区内的门店）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店</span></span><br><span class="line"><span class="comment"># 西单距离王府井 1.4681 km，所以不在结果中</span></span><br><span class="line">GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-GEOSEARCHSTORE（Redis-6-2-新增）">2. GEOSEARCHSTORE（Redis 6.2+ 新增）</h3><p>◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序）<br>◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCHSTORE destination <span class="built_in">source</span></span><br><span class="line">  &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class="line">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class="line">  [ASC | DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把王府井3km内的门店，存到near_shop集合</span></span><br><span class="line">GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km</span><br></pre></td></tr></table></figure><h2 id="底层核心与实战注意事项">底层核心与实战注意事项</h2><ol><li class="lvl-3"><p>底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。</p></li><li class="lvl-3"><p>精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。</p></li><li class="lvl-3"><p>性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。</p></li><li class="lvl-3"><p>适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。</p></li></ol><h2 id="典型实战场景示例">典型实战场景示例</h2><ul class="lvl-0"><li class="lvl-2"><p>需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 批量添加餐饮坐标</span></span><br><span class="line">GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）</span></span><br><span class="line">GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除某餐饮</span></span><br><span class="line">ZREM restaurant aaa</span><br></pre></td></tr></table></figure><h2 id="Geo-命令">Geo 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForGeo()</code> 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Geo</p></blockquote><h3 id="写入-删除类操作">写入 / 删除类操作</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>添加单个坐标</td><td><code>add(K key, Point point, M member)</code></td><td><code>GEOADD key longitude latitude member</code></td><td>返回 <strong>新增成员数量</strong>（已存在则返回 0）</td></tr><tr><td>添加单个位置</td><td><code>add(K key, GeoLocation&lt;M&gt; location)</code></td><td><code>GEOADD key longitude latitude member</code></td><td><code>GeoLocation</code> 内部封装了 <code>Point + member</code></td></tr><tr><td>批量添加</td><td><code>add(K key, Map&lt;M, Point&gt; map)</code></td><td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td><td><strong>推荐</strong>，一次网络 IO</td></tr><tr><td>批量添加</td><td><code>add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations)</code></td><td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td><td>与 Map 方式等价</td></tr><tr><td>删除成员</td><td><code>remove(K key, M... members)</code></td><td><code>ZREM key member [member ...]</code></td><td>GEO 本质是 <strong>Sorted Set</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(longitude, latitude);</span><br><span class="line">redisTemplate.opsForGeo().add(key, point, member);</span><br><span class="line"></span><br><span class="line">RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= <span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(member, point);</span><br><span class="line">redisTemplate.opsForGeo().add(key, geoLocation);</span><br></pre></td></tr></table></figure><h3 id="距离-坐标-哈希查询">距离 / 坐标 / 哈希查询</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>两点距离</td><td><code>distance(K key, m1, m2)</code></td><td><code>GEODIST key m1 m2</code></td><td>默认单位米</td></tr><tr><td>指定单位距离</td><td><code>distance(K key, m1, m2, metric)</code></td><td><code>GEODIST key m1 m2 unit</code></td><td>m / km / mi / ft</td></tr><tr><td>获取 GeoHash</td><td><code>hash(K key, M... members)</code></td><td><code>GEOHASH key member</code></td><td>用于调试</td></tr><tr><td>获取坐标</td><td><code>position(K key, M... members)</code></td><td><code>GEOPOS key member</code></td><td>lon / lat</td></tr></tbody></table><h3 id="半径查询（旧接口，已不推荐）">半径查询（旧接口，已不推荐）</h3><blockquote><p>Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 基于坐标点</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>半径查询</td><td><code>radius(K key, Circle within)</code></td><td><code>GEORADIUS key lon lat radius</code></td></tr><tr><td>半径 + 参数</td><td><code>radius(K key, Circle within, args)</code></td><td><code>GEORADIUS</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 基于成员</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>半径查询</td><td><code>radius(K key, member, radius)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr><tr><td>指定单位</td><td><code>radius(K key, member, Distance)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr><tr><td>带参数</td><td><code>radius(K key, member, Distance, args)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr></tbody></table><h3 id="搜索查询（推荐使用-GEOSEARCH）">搜索查询（推荐使用 GEOSEARCH）</h3><blockquote><p>替代 GEORADIUS / GEORADIUSBYMEMBER</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 按圆形范围搜索</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>圆形搜索</td><td><code>search(K key, Circle within)</code></td><td><code>GEOSEARCH</code></td><td>新推荐接口</td></tr><tr><td>指定参考点</td><td><code>search(K key, GeoReference, Distance)</code></td><td><code>GEOSEARCH</code></td><td>FROMMEMBER / FROMLONLAT</td></tr><tr><td>带参数</td><td><code>search(K key, reference, radius, args)</code></td><td><code>GEOSEARCH</code></td><td>支持排序、limit</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 按矩形范围搜索</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>矩形搜索</td><td><code>search(K key, reference, BoundingBox)</code></td><td><code>GEOSEARCH</code></td></tr><tr><td>带参数</td><td><code>search(K key, reference, BoundingBox, args)</code></td><td><code>GEOSEARCH</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>通用搜索（底层能力）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>任意 GeoShape</td><td><code>search(K key, reference, GeoShape, args)</code></td><td><code>GEOSEARCH</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于给定的坐标搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String key, <span class="type">double</span> longitude, <span class="type">double</span> latitude, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="comment">// 中心点</span></span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(longitude, latitude);</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class="line">    <span class="comment">// 创建圆形</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(point, distance);</span><br><span class="line">    <span class="comment">// 创建地理参考</span></span><br><span class="line">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle);</span><br><span class="line">    <span class="comment">// 创建地理形状</span></span><br><span class="line">    <span class="type">GeoShape</span> <span class="variable">geoShape</span> <span class="operator">=</span> GeoShape.byRadius(distance);</span><br><span class="line">    <span class="comment">// 创建参数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class="line">            .includeCoordinates() <span class="comment">// 返回坐标</span></span><br><span class="line">            .includeDistance() <span class="comment">// 返回距离</span></span><br><span class="line">            .sortAscending() <span class="comment">// 排序</span></span><br><span class="line">            .limit(<span class="number">10</span>); <span class="comment">// 限制返回数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class="line">    <span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">        results.forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取成员名称</span></span><br><span class="line">            System.out.println(result.getContent().getName());</span><br><span class="line">            <span class="comment">// 获取坐标</span></span><br><span class="line">            System.out.println(result.getContent().getPoint());</span><br><span class="line">            <span class="comment">// 获取距离</span></span><br><span class="line">            System.out.println(result.getDistance());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于成员的坐标搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String key, String member, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class="line">    <span class="comment">// 创建地理参考</span></span><br><span class="line">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member);</span><br><span class="line">    <span class="comment">// 创建地理形状</span></span><br><span class="line">    <span class="type">GeoShape</span> <span class="variable">geoShape</span> <span class="operator">=</span> GeoShape.byRadius(distance);</span><br><span class="line">    <span class="comment">// 创建参数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class="line">            .includeCoordinates() <span class="comment">// 返回坐标</span></span><br><span class="line">            .includeDistance() <span class="comment">// 返回距离</span></span><br><span class="line">            .sortAscending() <span class="comment">// 排序</span></span><br><span class="line">            .limit(<span class="number">10</span>); <span class="comment">// 限制返回数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class="line">    <span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">        results.forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取成员名称</span></span><br><span class="line">            System.out.println(result.getContent().getName());</span><br><span class="line">            <span class="comment">// 获取坐标</span></span><br><span class="line">            System.out.println(result.getContent().getPoint());</span><br><span class="line">            <span class="comment">// 获取距离</span></span><br><span class="line">            System.out.println(result.getDistance());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="搜索并存储（GEOSEARCHSTORE）">搜索并存储（GEOSEARCHSTORE）</h3><blockquote><p>这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 圆形范围存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>搜索并存储</td><td><code>searchAndStore(K key, destKey, Circle)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>指定参考点</td><td><code>searchAndStore(K key, destKey, reference, radius)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>带参数</td><td><code>searchAndStore(K key, destKey, reference, radius, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 矩形范围存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>矩形存储</td><td><code>searchAndStore(K key, destKey, reference, BoundingBox)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>带参数</td><td><code>searchAndStore(K key, destKey, reference, BoundingBox, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>3️⃣ 通用 GeoShape 存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>通用存储</td><td><code>searchAndStore(K key, destKey, reference, GeoShape, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Geo 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Hyperloglog</title>
    <link href="https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/"/>
    <id>https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/</id>
    <published>2025-12-19T13:30:05.000Z</published>
    <updated>2025-12-20T05:57:19.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Hyperloglog 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Hyperloglog-核心详解">Hyperloglog 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 <code>12KB</code>）就能统计海量数据的基数，误差率仅 <code>0.81%</code>，无需存储全部数据本身。</p></li></ul><blockquote><p>基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展</p></li></ul><h2 id="核心使用方式（3个核心命令）">核心使用方式（3个核心命令）</h2><ul class="lvl-0"><li class="lvl-2"><p>HyperLogLog 命令极简，只有 3 个核心操作</p></li></ul><h3 id="PFADD">PFADD</h3><ul class="lvl-0"><li class="lvl-2"><p>向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD key [element [element ...]]</span><br></pre></td></tr></table></figure><h3 id="PFCOUNT">PFCOUNT</h3><ul class="lvl-0"><li class="lvl-2"><p>统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure><h3 id="PFMERGE">PFMERGE</h3><ul class="lvl-0"><li class="lvl-2"><p>将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey [sourcekey [sourcekey ...]]</span><br></pre></td></tr></table></figure><h2 id="实操示例">实操示例</h2><h3 id="示例1：单-key-基础统计（统计网站-UV）">示例1：单 key 基础统计（统计网站 UV）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 模拟3个访客访问，其中用户A重复访问</span></span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 统计当日UV（去重后是3，忽略重复的userA）</span></span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:20251218</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="示例2：-多-key-合并与汇总统计">示例2： 多 key 合并与汇总统计</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 分别统计12.17和12.18的UV</span></span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251217 userA userD</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合并两日UV到 uv:20251217_18</span></span><br><span class="line">127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）</span></span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:20251217_18</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h2 id="核心应用场景（精准落地场景）">核心应用场景（精准落地场景）</h2><ul class="lvl-0"><li class="lvl-2"><p>HyperLogLog 只关注 <strong>“去重数量”</strong>，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案：</p></li></ul><ol><li class="lvl-3"><p>网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。</p></li><li class="lvl-3"><p>业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。</p></li><li class="lvl-3"><p>海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。</p></li><li class="lvl-3"><p>跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。</p></li></ol><h2 id="关键注意事项（避坑重点）">关键注意事项（避坑重点）</h2><ol><li class="lvl-3"><p>不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。</p></li><li class="lvl-3"><p>误差不可避免，可控不影响大部分场景：固定误差率 <code>0.81%</code>，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。</p></li><li class="lvl-3"><p>内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 <code>12KB</code>，这是其核心优势，也是区别于 Set 的关键。</p></li><li class="lvl-3"><p>元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。</p></li><li class="lvl-3"><p>过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 <code>EXPIRE key seconds</code> 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。</p></li><li class="lvl-3"><p>PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。</p></li></ol><h2 id="与-Set-统计基数的对比（选型参考）">与 Set 统计基数的对比（选型参考）</h2><table><thead><tr><th>对比维度</th><th>HyperLogLog</th><th>Set</th></tr></thead><tbody><tr><td>数据结构类型</td><td>基数统计结构</td><td>无序集合</td></tr><tr><td>内存占用</td><td>固定约 <strong>12KB</strong>，与数据量无关</td><td>随元素数量线性增长，海量数据内存占用极高</td></tr><tr><td>统计结果精度</td><td><strong>非精准</strong>，标准误差约 <strong>0.81%</strong></td><td><strong>100% 精准</strong></td></tr><tr><td>是否支持获取具体元素</td><td>不支持</td><td>支持（如 <code>SMEMBERS</code>）</td></tr><tr><td>是否支持去重</td><td>支持（基数去重）</td><td>支持（元素级去重）</td></tr><tr><td>统计性能</td><td>极快（固定计算逻辑，O(1)）</td><td>数据量越大，统计与遍历成本越高</td></tr><tr><td>适合数据规模</td><td>超大规模（百万 / 千万 / 亿级）</td><td>中小规模集合</td></tr><tr><td>常见使用场景</td><td>UV / DAU 统计、独立 IP 数、访问用户数</td><td>好友列表、标签集合、关注列表</td></tr><tr><td>是否可做集合运算</td><td>不支持</td><td>支持（<code>SUNION</code> / <code>SINTER</code> / <code>SDIFF</code>）</td></tr><tr><td>是否可序列化/持久化</td><td>可（Redis 内部结构）</td><td>可</td></tr><tr><td>选型结论</td><td><strong>低成本 + 海量数据 + 可接受误差的基数统计</strong></td><td><strong>精准统计 + 需要元素明细的场景</strong></td></tr></tbody></table><h2 id="HyperLogLog-命令">HyperLogLog 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForHyperLogLog()</code> 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 HyperLogLog</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注 / 使用建议</th></tr></thead><tbody><tr><td>添加元素</td><td><code>Long add(K key, V... values)</code></td><td><code>PFADD key element [element ...]</code></td><td>返回 1 表示 HLL 结构发生变化</td></tr><tr><td>获取基数（去重数）</td><td><code>Long size(K... keys)</code></td><td><code>PFCOUNT key [key ...]</code></td><td>支持多 key 合并统计</td></tr><tr><td>合并 HLL</td><td><code>Long union(K destination, K... sourceKeys)</code></td><td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td><td>合并后写入 destkey</td></tr><tr><td>删除 HLL</td><td><code>void delete(K key)</code></td><td><code>DEL key</code></td><td>直接删除整个 HLL</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Hyperloglog 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Bitmap</title>
    <link href="https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/"/>
    <id>https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/</id>
    <published>2025-12-18T13:30:05.000Z</published>
    <updated>2025-12-20T05:57:24.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Bitmap 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Bitmap-核心详解">Bitmap 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展</p></li><li class="lvl-2"><p>String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值）</p></li></ul><h2 id="Bitmap-命令使用方式">Bitmap 命令使用方式</h2><ul class="lvl-0"><li class="lvl-2"><p>核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础</p></li></ul><h3 id="1-位设置：SETBIT-key-offset-value">1. 位设置：<code>SETBIT key offset value</code></h3><ul class="lvl-0"><li class="lvl-2"><p>给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容）</p></li><li class="lvl-2"><p>offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SETBIT bitkey 1 1 <span class="comment"># 实际的bit为 01000000</span></span><br><span class="line">SETBIT bitkey 10 1 <span class="comment"># 实际的bit为 0100000000100000</span></span><br><span class="line"><span class="comment"># 操作 String</span></span><br><span class="line">SET k1 v1 <span class="comment"># 实际的bit为 0111011000110001</span></span><br><span class="line">SETBIT k1 1 0 <span class="comment"># 实际bit为 0011011000110001</span></span><br><span class="line">GET k1 <span class="comment"># 输出 61</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bitmap 实际上是 string</span></span><br><span class="line">TYPE bitkey <span class="comment"># 输出 string</span></span><br></pre></td></tr></table></figure><h3 id="2-位查询：GETBIT-key-offset">2. 位查询：<code>GETBIT key offset</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查询指定偏移量的位值，不存在的 offset 默认返回 0</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GETBIT bitkey 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="3-位统计：BITCOUNT-key-start-end">3. 位统计：<code>BITCOUNT key [start end]</code></h3><ul class="lvl-0"><li class="lvl-2"><p>统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT bitkey</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">BITCOUNT bitkey 0 -1</span><br></pre></td></tr></table></figure><h3 id="4-位运算：BITOP-op-destkey-key1-key2">4. 位运算：<code>BITOP op destkey key1 key2...</code></h3><ul class="lvl-0"><li class="lvl-2"><p>对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将key1 与 key2 做按位与运算，结果存入 destkey</span></span><br><span class="line">BITOP AND destkey key1 key2</span><br></pre></td></tr></table></figure><h3 id="5-位查找：BITPOS-key-value-start-end">5. 位查找：<code>BITPOS key value [start end]</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查找第一个值为 0/1 的 bit 偏移量，快速定位目标位</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BITPOS bitkey 1</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">BITPOS bitkey 1 0 -1</span><br></pre></td></tr></table></figure><h3 id="6-BITFIELD-批量位操作">6. <code>BITFIELD</code> 批量位操作</h3><p>• BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。<br>• 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。<br>• BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class="line">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class="line">  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class="line">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class="line">  ...]]</span><br></pre></td></tr></table></figure><p>• 参数说明（核心部分）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><strong>key</strong></td><td>操作的 Redis 字符串键</td></tr><tr><td><strong>GET encoding offset</strong></td><td>从指定位偏移量读取一个整数</td></tr><tr><td><strong>SET encoding offset value</strong></td><td>在指定位置写入整数</td></tr><tr><td><strong>INCRBY encoding offset increment</strong></td><td>在指定位置对整数做增量操作</td></tr><tr><td><strong>OVERFLOW WRAP/SAT/FAIL</strong></td><td>配置随后的算数操作溢出行为</td></tr></tbody></table><p>• 数据类型（encoding）:用于指定整数的位宽和符号类型</p><table><thead><tr><th>前缀</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>u&lt;number&gt;</code></td><td>无符号整数（unsigned），占位 bits = number</td><td>u5 — 5 位无符号整数</td></tr><tr><td><code>i&lt;number&gt;</code></td><td>有符号整数（signed），占位 bits = number</td><td>i10 — 10 位有符号整数</td></tr></tbody></table><p>• 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。</p><table><thead><tr><th>策略</th><th>行为</th></tr></thead><tbody><tr><td><strong>WRAP</strong></td><td>环绕（默认）溢出按环形计数处理</td></tr><tr><td><strong>SAT</strong></td><td>饱和，在边界值保持最大/最小</td></tr><tr><td><strong>FAIL</strong></td><td>溢出时操作失败并返回错误</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。</span></span><br><span class="line">BITFIELD key OVERFLOW SAT INCRBY u4 0 1</span><br></pre></td></tr></table></figure><p>• 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="7-BITFIELD-RO-批量只读">7. <code>BITFIELD_RO</code> 批量只读</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 6.0 新增的只读版本，用于批量只读</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD_RO key [GET encoding offset [GET encoding offset ...]]</span><br></pre></td></tr></table></figure><h3 id="综合示例">综合示例</h3><ul class="lvl-0"><li class="lvl-2"><p>示例 1. 设置并读取简单整数</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET mykey <span class="string">&quot;&quot;</span> <span class="comment"># 此时mykey 的值是空字符串，长度为 0</span></span><br><span class="line"><span class="comment"># SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000</span></span><br><span class="line"><span class="comment"># GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7</span></span><br><span class="line">&gt; BITFIELD mykey SET u4 0 7 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 0 <span class="comment"># set命令的返回值，这里返回set前的值</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 7 <span class="comment"># get命令的返回值</span></span><br><span class="line"><span class="comment"># 设置有符号整数</span></span><br><span class="line">&gt; BITFIELD mykey SET i4 0 -2 GET i4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 7 <span class="comment"># 返回set前的值，之前是7，即 0111，set后变为 -2，即 1110</span></span><br><span class="line">2) (<span class="built_in">integer</span>) -2 <span class="comment"># get命令的返回值</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>负数的二进制表示</strong></em></p><ul class="lvl-1"><li class="lvl-2">以 -2 为例，先写出 +2 的二进制，以8位为例，就是 <code>00000010</code>，4位就是 <code>0010</code></li><li class="lvl-2">按位取反（得到反码），例如 <code>00000010</code>，按位取反就是 <code>11111101</code></li><li class="lvl-2">加 1（得到补码），<code>11111101</code> + 1，得到 <code>11111110</code>，这就是 -2 的二进制表示</li><li class="lvl-2">如果是4位，则 -2 就是 <code>1110</code></li></ul></div><ul class="lvl-0"><li class="lvl-2"><p>示例 2. 自增计数器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 counter 之前为空，则视为 0</span></span><br><span class="line"><span class="comment"># INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5</span></span><br><span class="line"><span class="comment"># GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值</span></span><br><span class="line">BITFIELD counter INCRBY u8 8 5 GET u8 8</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 5 <span class="comment"># INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例 3. 带溢出控制的操作</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OVERFLOW SAT: 设置溢出策略为 SAT（饱和）</span></span><br><span class="line"><span class="comment"># INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）</span></span><br><span class="line"><span class="comment"># GET u4 0：读取 4 位无符号整数，即15</span></span><br><span class="line">BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br><span class="line">2) (<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例 4. 批量多个操作</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数</span></span><br><span class="line"><span class="comment"># SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理</span></span><br><span class="line"><span class="comment"># 返回结果数组对应每个子命令顺序返回结果</span></span><br><span class="line">BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，所以这里返回0</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，所以这里返回0</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 0000000000110000</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 1 <span class="comment"># 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节</span></span><br></pre></td></tr></table></figure><h2 id="核心使用场景-实操举例（贴合开发实战）">核心使用场景 + 实操举例（贴合开发实战）</h2><ul class="lvl-0"><li class="lvl-2"><p>Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景</p></li></ul><h3 id="场景1：-用户签到-打卡（最经典场景）">场景1： 用户签到/打卡（最经典场景）</h3><p>• 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数<br>• 设计：key 格式 <code>user:sign:uid:202512</code>（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0<br>• 实操命令：</p><ol><li class="lvl-3"><p>12月1号签到：<code>SETBIT user:sign:uid:202512 0 1</code></p></li><li class="lvl-3"><p>查询12月1号是否签到：<code>GETBIT user:sign:uid:202512 0</code>（返回1=签到）</p></li><li class="lvl-3"><p>统计12月总签到次数：<code>BITCOUNT user:sign:uid:202512</code></p></li></ol><p>• 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。</p><h3 id="场景2：-日活-周活-月活（DAU-WAU-MAU）统计（高并发场景首选）">场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选）</h3><p>• 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计<br>• 设计：按日期建 Bitmap，key 格式 <code>active:user:20251217</code>（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1<br>• 实操命令：</p><ol><li class="lvl-3"><p>用户ID 10086 12月17日访问：<code>SETBIT active:user:20251217 10086 1</code></p></li><li class="lvl-3"><p>统计12月17日日活：<code>BITCOUNT active:user:20251217</code></p></li><li class="lvl-3"><p>统计12月15-17日周活（3天内活跃）：<code>BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p></li></ol><p>• 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。</p><h3 id="场景3：-功能开关-状态标记（多维度轻量标记）">场景3： 功能开关/状态标记（多维度轻量标记）</h3><p>• 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key<br>• 设计：1个key对应1个用户，key 格式 <code>user:status:10086</code>，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否<br>• 实操命令：</p><ol><li class="lvl-3"><p>给用户10086绑定手机：<code>SETBIT user:status:10086 0 1</code></p></li><li class="lvl-3"><p>开通会员：<code>SETBIT user:status:10086 1 1</code></p></li><li class="lvl-3"><p>查询是否是会员：<code>GETBIT user:status:10086 1</code></p></li></ol><p>• 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。</p><h3 id="场景4：-布隆过滤器底层实现（核心依赖Bitmap）">场景4： 布隆过滤器底层实现（核心依赖Bitmap）</h3><p>• 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判<br>• 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在<br>• 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。<br>• 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。</p><h2 id="注意事项（避坑关键）">注意事项（避坑关键）</h2><ol><li class="lvl-3"><p>offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩）</p></li><li class="lvl-3"><p>避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长</p></li><li class="lvl-3"><p>注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置</p></li></ol><h2 id="Bitmap-命令">Bitmap 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Bitmap</p></blockquote><h3 id="写操作（位修改）">写操作（位修改）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置指定偏移量的位</td><td><code>setBit(K key, long offset, boolean value)</code></td><td><code>SETBIT key offset value</code></td><td>返回旧值（0 / 1），offset 从 0 开始</td></tr></tbody></table><blockquote><p>offset 表示 第几位（bit），不是字节</p></blockquote><h3 id="读操作（位查询）">读操作（位查询）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定偏移量的位</td><td><code>getBit(K key, long offset)</code></td><td><code>GETBIT key offset</code></td><td>返回 0 / 1，不会修改数据</td></tr></tbody></table><h3 id="批量位操作（位字段-BitField）">批量位操作（位字段 BitField）</h3><ul class="lvl-0"><li class="lvl-2"><p>位字段读/写/自增</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>位字段操作（读/写/自增）</td><td><code>bitField(K key, BitFieldSubCommands subCommands)</code></td><td><code>BITFIELD key ...</code></td><td>原子执行多个子命令</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD limits</span><br><span class="line">    OVERFLOW SAT</span><br><span class="line">    SET u4 0 3</span><br><span class="line">    INCRBY u4 0 20</span><br><span class="line">    GET u4 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SET u4 0 3</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldSet</span> <span class="variable">bitFieldSet</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>), <span class="number">3</span>);</span><br><span class="line"><span class="comment">// OVERFLOW SAT INCRBY u4 0 20</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldIncrBy</span> <span class="variable">bitFieldIncrBy</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>), <span class="number">20</span>, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);</span><br><span class="line"><span class="comment">// GET u4 0</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldGet</span> <span class="variable">bitFieldGet</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果，每个子操作返回一个结果</span></span><br><span class="line">List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(<span class="string">&quot;limits&quot;</span>, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));</span><br></pre></td></tr></table></figure><h3 id="Bitmap-常用但-Spring-未直接封装的命令">Bitmap 常用但 Spring 未直接封装的命令</h3><ul class="lvl-0"><li class="lvl-2"><p>Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。</p></li></ul><table><thead><tr><th>Redis 命令</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><code>BITCOUNT key [start end]</code></td><td>统计 bit=1 的数量</td><td>常用于活跃用户统计</td></tr><tr><td><code>BITPOS key bit [start end]</code></td><td>查找第一个 0/1 的位置</td><td>常用于分配位</td></tr><tr><td><code>BITOP AND/OR/XOR/NOT</code></td><td>位运算</td><td>多 bitmap 计算</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.bitmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.CommonUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Range;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitmapUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITCOUNT key [start end]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 统计 bit=1 的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitCount</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitCount</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitCount(key.getBytes(), start, end)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITPOS key bit [start] [end]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * bit = false → 查找第一个 0</span></span><br><span class="line"><span class="comment">     * bit = true → 查找第一个 1</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 返回值是 bit 索引（不是 byte）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitPos</span><span class="params">(String key, <span class="type">boolean</span> bit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitPos(key.getBytes(), bit)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitPos</span><span class="params">(String key, <span class="type">boolean</span> bit, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITOP operation destKey key [key ...]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * operation: AND\OR\XOR\NOT</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 运算结果保存在 destKey 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitOp</span><span class="params">(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123;</span><br><span class="line">            <span class="type">byte</span>[][] keys = Arrays.stream(sourceKeys)</span><br><span class="line">                    .map(String::getBytes)</span><br><span class="line">                    .toArray(<span class="type">byte</span>[][]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> connection.stringCommands().bitOp(</span><br><span class="line">                    operation,</span><br><span class="line">                    destKey.getBytes(),</span><br><span class="line">                    keys</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Bitmap 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>一个基于 Redis 的可重入分布式锁的实现</title>
    <link href="https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/"/>
    <id>https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/</id>
    <published>2025-12-17T13:30:05.000Z</published>
    <updated>2025-12-21T08:18:02.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 一个基于 Redis 的可重入分布式锁的实现方案</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">本文仅为学习原理，生产环境推荐使用 <a href="https://redisson.pro/docs/data-and-services/locks-and-synchronizers/">Redisson 分布式锁</a> 吧。</li></ul><span id="more"></span><h2 id="设计目标与关键约束">设计目标与关键约束</h2><h3 id="设计目标">设计目标</h3><ul class="lvl-0"><li class="lvl-2"><p>互斥性：同一时间只有一个持有者</p></li><li class="lvl-2"><p>可重入：同一线程 / 请求可多次加锁</p></li><li class="lvl-2"><p>安全释放：只能释放自己持有的锁</p></li><li class="lvl-2"><p>自动过期：防止死锁</p></li><li class="lvl-2"><p>续期能力（Watch Dog）：业务时间不确定时依然安全</p></li><li class="lvl-2"><p>高性能：单 Redis Key，Lua 保证原子性</p></li></ul><h3 id="技术选型">技术选型</h3><ul class="lvl-0"><li class="lvl-2"><p>Spring Boot</p></li><li class="lvl-2"><p>Spring Data Redis（Lettuce）</p></li><li class="lvl-2"><p>Redis Lua Script</p></li></ul><blockquote><p>Redis 是唯一依赖组件：Redis<br>Spring Boot 作为运行框架：Spring Boot</p></blockquote><h3 id="锁的核心数据结构设计（关键）">锁的核心数据结构设计（关键）</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis Key 结构(String)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock:前缀</span></span><br><span class="line">lock:order:123</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Value 结构（Hash）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uuid:threadId&quot;</span> : 重入次数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同一线程重入 → count +1，不同线程 → 拒绝</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>使用<code>StringRedisTemplate</code>，因其序列化器是<code>StringRedisSerializer</code>，可以保证 Lua 脚本能够正常执行。</p></li></ul><blockquote><p>基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer</p></blockquote><h3 id="Lua-脚本（原子性保障）">Lua 脚本（原子性保障）</h3><ul class="lvl-0"><li class="lvl-2"><p>加锁脚本（支持可重入）</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">-- ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">-- ARGV[2] expireMillis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>解锁脚本（防误删）</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">-- ARGV[1] ownerId</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hdel&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> (redis.call(<span class="string">&#x27;hlen&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Java-实现（核心代码）">Java 实现（核心代码）</h2><ul class="lvl-0"><li class="lvl-2"><p>WatchDog，实现锁自动续期</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockWatchDog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WatchDog的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     * ARGV[2] expireMillis 过期时间</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 拥有者是当前线程就续期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WATCHDOG_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程足够（Redisson 也是）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span></span><br><span class="line">            Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                t.setName(<span class="string">&quot;redis-lock-watch-dog&quot;</span>);</span><br><span class="line">                t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个 lockKey 对应一个续期任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLockWatchDog</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动续期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey     Redis 锁 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ownerId     uuid:threadId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseMillis 锁过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startRenew</span><span class="params">(String lockKey, String ownerId, <span class="type">long</span> leaseMillis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止重复启动</span></span><br><span class="line">        <span class="keyword">if</span> (renewTasks.containsKey(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 间隔多久续期一次</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> leaseMillis / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                renew(lockKey, ownerId, leaseMillis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 生产环境建议接日志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        renewTasks.put(lockKey, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消续期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopRenew</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            future.cancel(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际续期逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renew</span><span class="params">(String lockKey, String ownerId, <span class="type">long</span> leaseMillis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId,</span><br><span class="line">                String.valueOf(leaseMillis)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="comment">// 锁已不属于当前线程，停止 Watch Dog</span></span><br><span class="line">            stopRenew(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用关闭时释放资源（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>锁接口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  尝试获取锁的最大等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * 不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * 只要获取到锁就返回，否则一直自旋获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>锁实现类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的key前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     * ARGV[2] expireMillis 过期时间</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.key 不存在时创建锁</span></span><br><span class="line"><span class="comment">     * 2.key 存在时判断锁的拥有者是否为当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNLOCK_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then</span></span><br><span class="line"><span class="string">                return 0</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)</span></span><br><span class="line"><span class="string">            if (count &gt; 0) then</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1])</span></span><br><span class="line"><span class="string">                if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then</span></span><br><span class="line"><span class="string">                    redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisLockWatchDog watchDog;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisReentrantLock</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        watchDog = <span class="keyword">new</span> <span class="title class_">RedisLockWatchDog</span>(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的 ownerId</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">ownerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expireMillis</span> <span class="operator">=</span> unit.toMillis(leaseTime);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(LOCK_SCRIPT, Boolean.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId(),</span><br><span class="line">                String.valueOf(expireMillis)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(success)) &#123;<span class="comment">//防止NullPointerException</span></span><br><span class="line">            <span class="comment">// 启动 Watch Dog（只有在 leaseTime 不确定时）</span></span><br><span class="line">            watchDog.startRenew(</span><br><span class="line">                    lockKey,</span><br><span class="line">                    ownerId(),</span><br><span class="line">                    expireMillis</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.currentTimeMillis() + unit.toMillis(waitTime);</span><br><span class="line">        <span class="comment">// 使用带条件的循环，避免重复赋值</span></span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() &lt; deadline) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class="line">                <span class="comment">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class="line">                <span class="comment">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class="line">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class="number">50</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用无限循环，语义更清晰</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class="line">                <span class="comment">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class="line">                <span class="comment">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class="line">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class="number">50</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line">        <span class="comment">// 先停续期</span></span><br><span class="line">        watchDog.stopRenew(lockKey);</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(UNLOCK_SCRIPT, Long.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>测试类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lock.RedisReentrantLock;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisReentrantLock redisReentrantLock;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试获取锁</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisReentrantLock.tryLock(lockKey, <span class="number">5</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">                doBusiness();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redisReentrantLock.unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisReentrantLock.lock(lockKey, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束执行业务逻辑&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    redisReentrantLock.unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试多线程同时获取锁</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">demoMultiThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 每个线程都尝试获取同一个锁</span></span><br><span class="line">                    <span class="keyword">if</span> (redisReentrantLock.tryLock(lockKey, <span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            successCount.incrementAndGet();</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 获取锁成功，开始执行业务&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 模拟业务执行时间</span></span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 业务执行完成&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            redisReentrantLock.unlock(lockKey);</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 获取锁失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取锁的线程数: &quot;</span> + successCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 一个基于 Redis 的可重入分布式锁的实现方案&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文仅为学习原理，生产环境推荐使用 &lt;a href=&quot;https://redisson.pro/docs/data-and-services/locks-and-synchronizers/&quot;&gt;Redisson 分布式锁&lt;/a&gt; 吧。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- ZSet</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/</id>
    <published>2025-12-16T13:40:05.000Z</published>
    <updated>2025-12-20T05:57:30.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis ZSet 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="ZSet-核心详解">ZSet 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; &#123; member -&gt; score &#125;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">member：唯一，不可重复（String，二进制安全）</span><br><span class="line">score：double 类型，用于排序</span><br><span class="line">集合按 score 从小到大 排序</span><br><span class="line">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ZSet = Set（去重） + 排序能力</p></li><li class="lvl-2"><p>ZSet 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素唯一</span><br><span class="line">天然有序</span><br><span class="line">支持范围查询</span><br><span class="line">支持排名（rank）</span><br><span class="line">支持按 score 增量更新</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p></li><li class="lvl-2"><p>ZSet 的应用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Zset集合操作实现新闻点击排行榜</span></span><br><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY hotNews:20251201 1 news1 <span class="comment"># 点击一次分数 +1</span></span><br><span class="line">2）展示当日点击排行前十</span><br><span class="line">ZREVRANGE hotNews:20251201 0 9 WITHSCORES <span class="comment"># 倒序</span></span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 <span class="comment"># 合并</span></span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZSet 适合 排序 + 查询</span><br><span class="line">score 设计要稳定、可扩展</span><br><span class="line">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class="line">大 ZSet 避免全量遍历</span><br><span class="line">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure><h2 id="ZSet-命令">ZSet 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForZSet()</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="基础写入-删除-计数">基础写入 / 删除 / 计数</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>添加元素（含 score）</td><td><code>Boolean add(K key, V value, double score)</code></td><td><code>ZADD key score member</code></td><td>新增返回 <code>true</code></td></tr><tr><td>添加元素（仅不存在时）</td><td><code>Boolean addIfAbsent(K key, V value, double score)</code></td><td><code>ZADD key NX score member</code></td><td>Redis ≥ 3.0</td></tr><tr><td>批量添加</td><td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key score member [score member ...]</code></td><td>返回新增数量</td></tr><tr><td>批量添加（仅不存在）</td><td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key NX ...</code></td><td>—</td></tr><tr><td>删除成员</td><td><code>Long remove(K key, Object... values)</code></td><td><code>ZREM key member [member ...]</code></td><td>返回删除数量</td></tr><tr><td>递增 score</td><td><code>Double incrementScore(K key, V value, double delta)</code></td><td><code>ZINCRBY key delta member</code></td><td>—</td></tr><tr><td>获取集合大小</td><td><code>Long size(K key)</code></td><td><code>ZCARD key</code></td><td>—</td></tr><tr><td>获取集合大小（同义）</td><td><code>Long zCard(K key)</code></td><td><code>ZCARD key</code></td><td>API 别名</td></tr></tbody></table><h3 id="随机访问">随机访问</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注</th></tr></thead><tbody><tr><td>随机获取成员</td><td><code>V randomMember(K key)</code></td><td><code>ZRANDMEMBER key</code></td><td>不返回 score</td></tr><tr><td>随机获取不重复成员</td><td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr><tr><td>随机获取成员及 score</td><td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td><td><code>ZRANDMEMBER key WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机获取不重复成员及 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key count WITHSCORES</code></td><td>—</td></tr><tr><td>随机获取可重复成员及 score</td><td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key -count WITHSCORES</code></td><td>—</td></tr></tbody></table><h3 id="排名-score-查询">排名 / score 查询</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取正序排名</td><td><code>Long rank(K key, Object o)</code></td><td><code>ZRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取倒序排名</td><td><code>Long reverseRank(K key, Object o)</code></td><td><code>ZREVRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取 score</td><td><code>Double score(K key, Object o)</code></td><td><code>ZSCORE key member</code></td><td>—</td></tr><tr><td>批量获取 score</td><td><code>List&lt;Double&gt; score(K key, Object... o)</code></td><td><code>ZMScore key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>score 区间计数</td><td><code>Long count(K key, double min, double max)</code></td><td><code>ZCOUNT key min max</code></td><td>—</td></tr></tbody></table><h3 id="区间查询（rank-score）">区间查询（rank / score）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>按 rank 查询</td><td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td><td><code>ZRANGE key start end</code></td><td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td></tr><tr><td>按 rank 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td><td><code>ZRANGE key start end WITHSCORES</code></td><td>—</td></tr><tr><td>按 score 查询</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max</code></td><td>—</td></tr><tr><td>按 score 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td><td>—</td></tr><tr><td>score 分页</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td><td>—</td></tr><tr><td>score 分页（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td><td>按 score 升序分页，返回 member + score</td></tr><tr><td>倒序 rank 查询</td><td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end</code></td><td>按 rank 倒序（高 → 低）</td></tr><tr><td>倒序 rank（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end WITHSCORES</code></td><td>倒序 rank，返回 score</td></tr><tr><td>倒序 score 查询</td><td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min</code></td><td>注意：<strong>max 在前，min 在后</strong></td></tr><tr><td>倒序 score（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td><td>倒序 score，返回 score</td></tr></tbody></table><h3 id="弹出元素（队列-TopN-场景）">弹出元素（队列 / TopN 场景）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td><td><code>ZPOPMIN key</code></td><td>—</td></tr><tr><td>批量弹出最小 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td><td><code>ZPOPMIN key count</code></td><td>—</td></tr><tr><td>阻塞弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td><td><code>BZPOPMIN key timeout</code></td><td>—</td></tr><tr><td>弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td><td><code>ZPOPMAX key</code></td><td>—</td></tr><tr><td>批量弹出最大 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td><td><code>ZPOPMAX key count</code></td><td>—</td></tr><tr><td>阻塞弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td><td><code>BZPOPMAX key timeout</code></td><td>—</td></tr></tbody></table><h3 id="区间删除">区间删除</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th></tr></thead><tbody><tr><td>按 rank 删除</td><td><code>Long removeRange(K key, long start, long end)</code></td><td><code>ZREMRANGEBYRANK key start end</code></td></tr><tr><td>按 score 删除</td><td><code>Long removeRangeByScore(K key, double min, double max)</code></td><td><code>ZREMRANGEBYSCORE key min max</code></td></tr><tr><td>按 lex 删除</td><td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td><td><code>ZREMRANGEBYLEX key min max</code></td></tr></tbody></table><h3 id="集合运算（ZSet-特有）">集合运算（ZSet 特有）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>差集</td><td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集</td><td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集</td><td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZINTERSTORE destination numkeys key [key ...]</code></td><td></td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td><td></td></tr></tbody></table><h3 id="Lex（字典序，仅-score-相同）">Lex（字典序，仅 score 相同）</h3><blockquote><p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>如果 score 不同，Redis 文档明确说明：结果不可预测</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>按 lex 查询</td><td><code>Set&lt;V&gt; rangeByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td><td>score 必须相同</td></tr><tr><td>倒序 lex 查询</td><td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td><td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td><td>—</td></tr><tr><td>lex 范围存储</td><td><code>Long rangeAndStoreByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td><td>Spring 封装</td></tr><tr><td>score 范围存储</td><td><code>Long rangeAndStoreByScore(...)</code></td><td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td><td>Spring 封装</td></tr></tbody></table><blockquote><p>Lex 范围写法规则</p></blockquote><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[a</code></td><td>≥ a（包含）</td></tr><tr><td><code>(a</code></td><td>&gt; a（不包含）</td></tr><tr><td><code>[z</code></td><td>≤ z</td></tr><tr><td><code>+</code></td><td>正无穷</td></tr><tr><td><code>-</code></td><td>负无穷</td></tr></tbody></table><blockquote><p>示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a ≤ member &lt; d</span></span><br><span class="line">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure><h3 id="遍历">遍历</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>游标扫描</td><td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td><td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>推荐替代全量查询</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis ZSet 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Set</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/</id>
    <published>2025-12-16T13:38:05.000Z</published>
    <updated>2025-12-20T05:57:35.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Set 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Set-核心详解">Set 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 是一个无序、不重复元素集合，本质上是：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Set&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素唯一（自动去重）</span><br><span class="line">无顺序（不保证插入顺序）</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Set 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动去重</span><br><span class="line">高效成员判断</span><br><span class="line">支持集合运算</span><br><span class="line">操作原子性强</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>Set 应用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微信抽奖小程序</span></span><br><span class="line">1）点击参与抽奖加入集合</span><br><span class="line">SADD key &#123;userlD&#125;</span><br><span class="line">2）查看参与抽奖所有用户</span><br><span class="line">SMEMBERS key</span><br><span class="line">3）抽取count名中奖者</span><br><span class="line">SRANDMEMBER key [count] / SPOP key [count]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微信微博点赞，收藏，标签</span></span><br><span class="line">1) 点赞</span><br><span class="line">SADD like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">2) 取消点赞</span><br><span class="line">SREM like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">3) 检查用户是否点过赞</span><br><span class="line">SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">4) 获取点赞的用户列表</span><br><span class="line">SMEMBERS like:&#123;消息ID&#125;</span><br><span class="line">5) 获取点赞用户数</span><br><span class="line">SCARD like:&#123;消息ID&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line"><span class="comment"># 交集：多个集合中同时存在的元素</span></span><br><span class="line">SINTER set1 set2 set3 -&gt; &#123; c &#125; <span class="comment"># 交集，共同关注 / 共同好友 / 共同兴趣</span></span><br><span class="line"><span class="comment"># 并集：存在于任意一个集合中的元素</span></span><br><span class="line">SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; <span class="comment"># 多来源合并后的用户全集</span></span><br><span class="line"><span class="comment"># 差集：只存在于第一个集合中的元素</span></span><br><span class="line">SDIFF set1 set2 set3 -&gt; &#123;a&#125; <span class="comment"># 差集，推荐好友</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set 适合 成员资格判断</span><br><span class="line">始终控制成员规模</span><br><span class="line">大 Set 遍历使用 SSCAN</span><br><span class="line">集合运算放在离线或低频场景</span><br><span class="line">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure><h2 id="Set-命令">Set 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForSet()</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="写操作（增-删-移动）">写操作（增 / 删 / 移动）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>向集合添加元素</td><td><code>add(K key, V... values)</code></td><td><code>SADD key member [member ...]</code></td><td>返回新增成员数量</td></tr></tbody></table><h3 id="移除-弹出成员">移除 / 弹出成员</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>从集合移除元素</td><td><code>remove(K key, Object... values)</code></td><td><code>SREM key member [member ...]</code></td><td>返回移除成员数量</td></tr><tr><td>随机弹出一个元素</td><td><code>pop(K key)</code></td><td><code>SPOP key</code></td><td>随机且删除</td></tr><tr><td>随机弹出多个元素</td><td><code>pop(K key, long count)</code></td><td><code>SPOP key count</code></td><td>Redis ≥ 3.2</td></tr></tbody></table><h3 id="成员移动（原子）">成员移动（原子）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>将成员移动到其他集合</td><td><code>move(K key, V value, K destKey)</code></td><td><code>SMOVE source dest member</code></td><td>原子操作</td></tr></tbody></table><h3 id="集合大小">集合大小</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取集合大小</td><td><code>size(K key)</code></td><td><code>SCARD key</code></td><td>—</td></tr></tbody></table><h3 id="成员存在性判断">成员存在性判断</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>判断是否是成员</td><td><code>isMember(K key, Object o)</code></td><td><code>SISMEMBER key member</code></td><td>—</td></tr><tr><td>批量判断成员是否存在</td><td><code>isMember(K key, Object... objects)</code></td><td><code>SMISMEMBER key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><h3 id="交集（Intersection）">交集（Intersection）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算交集</td><td><code>intersect(K key, K otherKey)</code></td><td><code>SINTER key key</code></td><td>O(N × M)</td></tr><tr><td>计算交集</td><td><code>intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>计算交集</td><td><code>intersect(Collection&lt;K&gt; keys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(K key, K otherKey, K destKey)</code></td><td><code>SINTERSTORE dest key key</code></td><td>返回结果数量</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="并集（Union）">并集（Union）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算并集</td><td><code>union(K key, K otherKey)</code></td><td><code>SUNION key key</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>union(Collection&lt;K&gt; keys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(K key, K otherKey, K destKey)</code></td><td><code>SUNIONSTORE dest key key</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="差集（Difference）">差集（Difference）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算差集</td><td><code>difference(K key, K otherKey)</code></td><td><code>SDIFF key key</code></td><td>key 顺序影响结果</td></tr><tr><td>计算差集</td><td><code>difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>计算差集</td><td><code>difference(Collection&lt;K&gt; keys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(K key, K otherKey, K destKey)</code></td><td><code>SDIFFSTORE dest key key</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="全量-随机读取">全量 / 随机读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取所有成员</td><td><code>members(K key)</code></td><td><code>SMEMBERS key</code></td><td>大集合慎用</td></tr><tr><td>随机获取一个成员</td><td><code>randomMember(K key)</code></td><td><code>SRANDMEMBER key</code></td><td>不删除</td></tr><tr><td>随机获取不重复成员</td><td><code>distinctRandomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>randomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr></tbody></table><h3 id="游标扫描（大集合推荐）">游标扫描（大集合推荐）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>游标扫描成员</td><td><code>scan(K key, ScanOptions options)</code></td><td><code>SSCAN key cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>SMEMBERS</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Set 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- List</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/</id>
    <published>2025-12-16T13:35:05.000Z</published>
    <updated>2025-12-20T05:57:39.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis List 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="List-核心详解">List 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis List 是一个有序字符串列表，本质上是:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; List&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素按插入顺序排列</span><br><span class="line">允许重复元素</span><br><span class="line">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>List 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有序</span><br><span class="line">可重复</span><br><span class="line">双端操作（Deque）</span><br><span class="line">支持阻塞读</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差</p></li><li class="lvl-2"><p>常用数据结构</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack(栈) = LPUSH + LPOP</span><br><span class="line">Queue(队列）= LPUSH + RPOP</span><br><span class="line">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>List 的使用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">视频列表、签到列表</span><br><span class="line">排队机</span><br><span class="line">简化版的MQ</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List 只用于 顺序消费</span><br><span class="line">始终限制 List 长度（LTRIM）</span><br><span class="line">避免中间插入、删除</span><br><span class="line">大 List 删除使用 UNLINK</span><br><span class="line">高可靠消息不要用 List</span><br></pre></td></tr></table></figure><h2 id="List-命令">List 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForList()</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="区间访问与整体控制">区间访问与整体控制</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定区间元素</td><td><code>range(K key, long start, long end)</code></td><td><code>LRANGE key start end</code></td><td><code>end = -1</code> 表示到末尾</td></tr><tr><td>裁剪 list，仅保留指定区间</td><td><code>trim(K key, long start, long end)</code></td><td><code>LTRIM key start end</code></td><td><strong>原地修改</strong></td></tr><tr><td>获取 list 长度</td><td><code>size(K key)</code></td><td><code>LLEN key</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>📌 使用建议</p><ul class="lvl-2"><li class="lvl-6"><code>LRANGE 0 -1</code> 等价全量读取，小 list 可用</li><li class="lvl-6">大 list 建议分页 + LRANGE</li></ul></li></ul><h3 id="左侧入队（Head）">左侧入队（Head）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧插入一个元素</td><td><code>leftPush(K key, V value)</code></td><td><code>LPUSH key value</code></td><td>返回插入后长度</td></tr><tr><td>左侧批量插入</td><td><code>leftPushAll(K key, V... values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>依次从左插入</td></tr><tr><td>左侧批量插入</td><td><code>leftPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时左侧插入</td><td><code>leftPushIfPresent(K key, V value)</code></td><td><code>LPUSHX key value</code></td><td>key 不存在不执行</td></tr><tr><td>在 pivot 左侧插入</td><td><code>leftPush(K key, V pivot, V value)</code></td><td><code>LINSERT key BEFORE pivot value</code></td><td>pivot 不存在返回 <code>-1</code></td></tr></tbody></table><h3 id="右侧入队（Tail）">右侧入队（Tail）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>右侧插入一个元素</td><td><code>rightPush(K key, V value)</code></td><td><code>RPUSH key value</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>rightPushAll(K key, V... values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>rightPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时右侧插入</td><td><code>rightPushIfPresent(K key, V value)</code></td><td><code>RPUSHX key value</code></td><td>—</td></tr><tr><td>在 pivot 右侧插入</td><td><code>rightPush(K key, V pivot, V value)</code></td><td><code>LINSERT key AFTER pivot value</code></td><td>pivot 不存在返回 <code>-1</code></td></tr></tbody></table><h3 id="非阻塞弹出">非阻塞弹出</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧弹出</td><td><code>leftPop(K key)</code></td><td><code>LPOP key</code></td><td>—</td></tr><tr><td>左侧批量弹出</td><td><code>leftPop(K key, long count)</code></td><td><code>LPOP key count</code></td><td>Redis ≥ 6.2</td></tr><tr><td>右侧弹出</td><td><code>rightPop(K key)</code></td><td><code>RPOP key</code></td><td>—</td></tr><tr><td>右侧批量弹出</td><td><code>rightPop(K key, long count)</code></td><td><code>RPOP key count</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><h3 id="阻塞弹出（Blocking-Queue）">阻塞弹出（Blocking Queue）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧阻塞弹出</td><td><code>leftPop(K key, timeout)</code></td><td><code>BLPOP key timeout</code></td><td>队列为空时阻塞</td></tr><tr><td>右侧阻塞弹出</td><td><code>rightPop(K key, timeout)</code></td><td><code>BRPOP key timeout</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>📌 典型场景：</p><ul class="lvl-2"><li class="lvl-6">消息队列 / 任务队列</li><li class="lvl-6">简单生产者-消费者模型</li></ul></li></ul><h3 id="原子移动">原子移动</h3><blockquote><p>Redis 6.2+ 新模型（统一、可读性更强）</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>原子移动（非阻塞）</td><td><code>move(sourceKey, from, destinationKey, to)</code></td><td><code>LMOVE source dest LEFT|RIGHT LEFT|RIGHT</code></td><td>Redis ≥ 6.2</td></tr><tr><td>原子移动（阻塞）</td><td><code>move(sourceKey, from, destinationKey, to, timeout)</code></td><td><code>BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>语义说明</p><ul class="lvl-2"><li class="lvl-6">从 sourceKey 的一端 POP</li><li class="lvl-6">向 destinationKey 的一端 PUSH</li><li class="lvl-6">整个过程 原子性保证</li></ul></li><li class="lvl-2"><p>命令参数说明：</p><ul class="lvl-2"><li class="lvl-6">source:源 List（从这里取一个元素）</li><li class="lvl-6">dest:目标 List（往这里放一个元素）</li><li class="lvl-6">第一个 LEFT/RIGHT:从 source 的哪一端弹出元素</li><li class="lvl-6">第二个 LEFT/RIGHT:从 dest 的哪一端插入元素</li><li class="lvl-6">timeout: 阻塞时间<ul class="lvl-4"><li class="lvl-10">当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。</li><li class="lvl-10">timeout = 0：无限期阻塞，直到有数据可用或连接断开</li></ul></li></ul></li></ul><blockquote><p>旧命令（即将废弃）</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>推荐替代</th></tr></thead><tbody><tr><td>右弹左插</td><td><code>rightPopAndLeftPush(...)</code></td><td><code>RPOPLPUSH</code></td><td><code>LMOVE</code></td></tr><tr><td>阻塞右弹左插</td><td><code>rightPopAndLeftPush(..., timeout)</code></td><td><code>BRPOPLPUSH</code></td><td><code>BLMOVE</code></td></tr></tbody></table><h3 id="随机访问与定位（O-N-）">随机访问与定位（O(N)）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取第一个元素</td><td><code>getFirst(K key)</code></td><td><code>LINDEX key 0</code></td><td>O(N)</td></tr><tr><td>获取最后一个元素</td><td><code>getLast(K key)</code></td><td><code>LINDEX key -1</code></td><td>O(N)</td></tr><tr><td>获取指定索引元素</td><td><code>index(K key, long index)</code></td><td><code>LINDEX key index</code></td><td>O(N)</td></tr></tbody></table><blockquote><p>⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取</p></blockquote><h3 id="搜索与删除">搜索与删除</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>删除指定值</td><td><code>remove(K key, long count, Object value)</code></td><td><code>LREM key count value</code></td><td>count &gt;0 从左，&lt;0 从右</td></tr><tr><td>获取首次出现位置</td><td><code>indexOf(K key, V value)</code></td><td><code>LPOS key value</code></td><td>Redis ≥ 6.0</td></tr><tr><td>获取最后出现位置</td><td><code>lastIndexOf(K key, V value)</code></td><td><code>LPOS key value RANK -1</code></td><td>Redis ≥ 6.0</td></tr></tbody></table><h3 id="List-的典型使用模式总结">List 的典型使用模式总结</h3><table><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>队列（FIFO）</td><td><code>RPUSH + LPOP</code></td></tr><tr><td>栈（LIFO）</td><td><code>LPUSH + LPOP</code></td></tr><tr><td>阻塞队列</td><td><code>BLPOP / BRPOP</code></td></tr><tr><td>可靠队列</td><td><code>LMOVE / BLMOVE</code></td></tr><tr><td>消息转移</td><td><code>LMOVE source dest</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis List 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Hash</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/</id>
    <published>2025-12-15T13:33:05.000Z</published>
    <updated>2025-12-20T05:57:45.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Hash 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Hash-核心详解">Hash 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Map&lt;String, String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">key：Redis 的键（只能是 String）</span><br><span class="line">field：Hash 内的字段名（String）</span><br><span class="line">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适合存储对象型数据</span><br><span class="line">支持 字段级别读写</span><br><span class="line">所有操作均为 原子性</span><br><span class="line">内存效率优于「String + JSON」</span><br><span class="line">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 的使用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象缓存</span></span><br><span class="line">HSET user:1 name zhangsan age 20</span><br><span class="line"><span class="comment"># 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为value</span></span><br><span class="line">HSET cart:userId commodity:1001 1 commodity:1002 5</span><br><span class="line"><span class="comment"># 分布式锁，一个命令搞不定，需要结合Lua脚本</span></span><br><span class="line">HINCRBY lock uuid:threadId 1 <span class="comment"># 创建锁 或 重入+1</span></span><br><span class="line">EXPIRE lock 30 <span class="comment"># 30 秒后自动释放锁</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash结构优缺点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">• 优点</span><br><span class="line">1）同类数据聚合存储，适合表达对象模型，便于管理与维护</span><br><span class="line">2）相比 string 操作消耗内存与 CPU 更小</span><br><span class="line">    a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销</span><br><span class="line">    b.Hash 过大时（BigHash）优势消失</span><br><span class="line">3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销</span><br><span class="line">• 缺点</span><br><span class="line">1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持</span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># user:1 这个 Hash 不会过期</span></span><br><span class="line">HSET user:1 name <span class="string">&quot;Tom&quot;</span> age 18</span><br><span class="line"><span class="comment"># HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class="line"><span class="comment"># 只有 name field 60 秒后自动删除</span></span><br><span class="line">HEXPIRE user:1 60 FIELDS 1 name</span><br><span class="line"><span class="comment"># 同时给多个 field 设置过期时间</span></span><br><span class="line">HEXPIRE user:1 60 FIELDS 2 name age</span><br><span class="line"><span class="comment"># 使用毫秒级过期（HPEXPIRE）</span></span><br><span class="line"><span class="comment"># HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class="line">HPEXPIRE user:1 60 FIELDS 2 name age</span><br><span class="line"><span class="comment"># 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class="line"><span class="comment"># HTTL key FIELDS numfields field [field ...]</span></span><br><span class="line">HTTL user:1 FIELDS 1 name</span><br><span class="line"><span class="comment"># 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class="line"><span class="comment"># HPTTL key FIELDS numfields field [field ...]</span></span><br><span class="line">HPTTL user:1 FIELDS 1 name</span><br><span class="line"><span class="comment"># 移出过期时间</span></span><br><span class="line"><span class="comment"># HPERSIST key FIELDS numfields field [field ...]</span></span><br><span class="line">HPERSIST user:1 FIELDS 1 name</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个 Hash = 一个对象</span><br><span class="line">field 数量建议 &lt; 100</span><br><span class="line">单 field value 建议 &lt; 1 KB</span><br><span class="line">大对象拆分为多个 Hash</span><br><span class="line">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure><h2 id="Hash-命令">Hash 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForHash()</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="写入-更新">写入 / 更新</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置单个 field-value</td><td><code>put(H key, HK hashKey, HV value)</code></td><td><code>HSET key field value</code></td><td>新增或覆盖</td></tr><tr><td>批量设置 field-value</td><td><code>putAll(H key, Map&lt;HK,HV&gt; m)</code></td><td><code>HSET key field value [field value ...]</code></td><td><code>HMSET</code> 已废弃</td></tr><tr><td>field 不存在时设置</td><td><code>putIfAbsent(H key, HK hashKey, HV value)</code></td><td><code>HSETNX key field value</code></td><td>原子操作</td></tr></tbody></table><h3 id="读取">读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定 field 的值</td><td><code>get(H key, Object hashKey)</code></td><td><code>HGET key field</code></td><td>不存在返回 <code>null</code></td></tr><tr><td>批量获取多个 field</td><td><code>multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HMGET key field [field ...]</code></td><td>不存在返回 <code>null</code></td></tr><tr><td>获取所有 value</td><td><code>values(H key)</code></td><td><code>HVALS key</code></td><td>O(N)</td></tr><tr><td>获取所有 field-value</td><td><code>entries(H key)</code></td><td><code>HGETALL key</code></td><td><strong>生产环境慎用</strong></td></tr></tbody></table><h3 id="删除-存在性判断">删除 / 存在性判断</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>删除一个或多个 field</td><td><code>delete(H key, Object... hashKeys)</code></td><td><code>HDEL key field [field ...]</code></td><td>返回删除数量</td></tr><tr><td>判断 field 是否存在</td><td><code>hasKey(H key, Object hashKey)</code></td><td><code>HEXISTS key field</code></td><td>—</td></tr></tbody></table><h3 id="计数与数值运算">计数与数值运算</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>field 整数自增</td><td><code>increment(H key, HK hashKey, long delta)</code></td><td><code>HINCRBY key field increment</code></td><td>value 必须是整数</td></tr><tr><td>field 浮点数自增</td><td><code>increment(H key, HK hashKey, double delta)</code></td><td><code>HINCRBYFLOAT key field increment</code></td><td>Redis ≥ 2.6</td></tr><tr><td>获取 field 对应 value 长度</td><td><code>lengthOfValue(H key, HK hashKey)</code></td><td><code>HSTRLEN key field</code></td><td>不存在返回 0</td></tr><tr><td>获取 hash 中 field 数量</td><td><code>size(H key)</code></td><td><code>HLEN key</code></td><td>—</td></tr></tbody></table><h3 id="随机访问（Random-Access）">随机访问（Random Access）</h3><ul class="lvl-0"><li class="lvl-2"><p>⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>随机返回一个 field</td><td><code>randomKey(H key)</code></td><td><code>HRANDFIELD key</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回一个 field-value</td><td><code>randomEntry(H key)</code></td><td><code>HRANDFIELD key WITHVALUES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回多个 field</td><td><code>randomKeys(H key, long count)</code></td><td><code>HRANDFIELD key count</code></td><td>count &lt; 0 可重复</td></tr><tr><td>随机返回多个 field-value</td><td><code>randomEntries(H key, long count)</code></td><td><code>HRANDFIELD key count WITHVALUES</code></td><td>—</td></tr></tbody></table><h3 id="遍历与扫描（推荐方式）">遍历与扫描（推荐方式）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取所有 field</td><td><code>keys(H key)</code></td><td><code>HKEYS key</code></td><td>O(N)，大 hash 慎用</td></tr><tr><td>游标扫描 hash</td><td><code>scan(H key, ScanOptions options)</code></td><td><code>HSCAN key cursor [MATCH] [COUNT]</code></td><td><strong>推荐替代 <code>HGETALL</code></strong></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-3"><p>📌 最佳实践</p><ul class="lvl-2"><li class="lvl-6">小 hash：HGETALL</li><li class="lvl-6">大 hash / 线上系统：HSCAN</li></ul></li></ul><h3 id="Hash-Field-级别过期（Redis-7-4-）">Hash Field 级别过期（Redis 7.4+）</h3><ul class="lvl-0"><li class="lvl-3"><p>Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强</p></li><li class="lvl-2"><p>设置过期</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>为指定 field 设置过期时间</td><td><code>expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE key seconds FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr><tr><td>为指定 field 设置过期时间点</td><td><code>expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr><tr><td>高级过期策略</td><td><code>expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE / HEXPIREAT</code></td><td>Spring 抽象封装</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>移除过期时间</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>移除指定 field 的过期时间</td><td><code>persist(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HPERSIST key FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Hash 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- String</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/</id>
    <published>2025-12-15T13:31:05.000Z</published>
    <updated>2025-12-20T05:57:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis String 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="String-核心详解">String 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。</p></li><li class="lvl-2"><p>Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。</p></li><li class="lvl-2"><p>Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等</p></li></ul><table><thead><tr><th>数据形式</th><th>示例</th></tr></thead><tbody><tr><td>普通字符串</td><td><code>&quot;hello redis&quot;</code></td></tr><tr><td>数字（整型/浮点）</td><td><code>&quot;100&quot;</code>, <code>&quot;3.14&quot;</code></td></tr><tr><td>JSON</td><td><code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125;</code></td></tr><tr><td>序列化对象</td><td>Java / JSON / ProtoBuf</td></tr><tr><td>Base64 / 二进制</td><td>图片、Token 等</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下</p></li></ul><table><thead><tr><th>分类</th><th>最大存储大小（MB）</th></tr></thead><tbody><tr><td>Key</td><td>&lt; 1k</td></tr><tr><td>Value</td><td>&lt; 1MB</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>String 数据类型的主要应用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单值缓存</span></span><br><span class="line">SET k1 v1</span><br><span class="line"><span class="comment"># 对象缓存</span></span><br><span class="line">SET user:1 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 分布式锁，为了保证可重入，现在更推荐使用 hash 类型</span></span><br><span class="line">SET lock uuid:threadId NX EX 10</span><br></pre></td></tr></table></figure><h2 id="Redis-String-的编码类型">Redis String 的编码类型</h2><blockquote><p>编码类型是针对 value 的编码方式</p></blockquote><table><thead><tr><th>编码类型</th><th>OBJECT ENCODING</th><th>触发条件</th><th>内部存储</th><th>是否可变</th><th>典型命令/场景</th><th>备注</th></tr></thead><tbody><tr><td>整数编码</td><td><code>int</code></td><td>value 是<strong>纯数字字符串</strong>且在 <code>[-2^63, 2^63-1]</code> 范围</td><td><code>long</code></td><td>❌</td><td><code>SET k 1</code>、<code>INCR k</code></td><td>最省内存、数值运算最快</td></tr><tr><td>嵌入式字符串</td><td><code>embstr</code></td><td><strong>字符串长度 ≤ 44 字节</strong>（Redis 7.x）且<strong>直接 SET</strong></td><td><code>redisObject + SDS</code> 一次性分配</td><td>⚠️（会升级）</td><td><code>SET k &quot;ok&quot;</code></td><td>不支持扩容</td></tr><tr><td>原始字符串</td><td><code>raw</code></td><td>字符串长度 &gt; 44 字节，或发生<strong>增量修改</strong></td><td><code>redisObject → SDS</code></td><td>✅</td><td><code>APPEND</code>、<code>SETRANGE</code></td><td>最通用</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>可以用命令查看指定key的 value 的编码类型</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJECT ENCODING key</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 123</span><br><span class="line">OBJECT ENCODING k1 <span class="comment"># int</span></span><br><span class="line">APPEND k1 <span class="string">&quot;4&quot;</span> <span class="comment"># 自动升级为 raw，这是因为 APPEND 会强制使用 raw，即使最终字符串长度 ≤ 44 字节</span></span><br><span class="line"></span><br><span class="line">SET k <span class="string">&quot;short&quot;</span></span><br><span class="line">OBJECT ENCODING k <span class="comment"># embstr</span></span><br><span class="line">APPEND k <span class="string">&quot;this-is-a-long-string&quot;</span> <span class="comment"># 自动升级为 raw</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis String 根据“值的形态 + 操作语义”在 int / embstr / raw 之间自动选择；</p></li><li class="lvl-2"><p>这种编码自适应机制，是 Redis 高性能与低内存占用的重要基础。</p></li></ul><h2 id="String-命令">String 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForValue()</code> 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="普通设置">普通设置</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置 key 的值</td><td><code>set(K key, V value)</code></td><td><code>SET key value</code></td><td>—</td></tr></tbody></table><h3 id="条件写入（NX-XX）">条件写入（NX / XX）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注</th></tr></thead><tbody><tr><td>key 不存在时设置</td><td><code>setIfAbsent(K key, V value)</code></td><td><code>SET key value NX</code></td><td>NX：key 不存在才设置</td></tr><tr><td>key 存在时设置</td><td><code>setIfPresent(K key, V value)</code></td><td><code>SET key value XX</code></td><td>XX：key 存在才设置</td></tr></tbody></table><h3 id="条件写入-过期时间">条件写入 + 过期时间</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注</th></tr></thead><tbody><tr><td>key 不存在时设置并指定过期时间</td><td><code>setIfAbsent(K key, V value, timeout, unit)</code></td><td><code>SET key value NX EX seconds</code></td><td>EX 秒 / PX 毫秒</td></tr><tr><td>key 存在时设置并指定过期时间</td><td><code>setIfPresent(K key, V value, timeout, unit)</code></td><td><code>SET key value XX EX seconds</code></td><td>—</td></tr></tbody></table><h3 id="直接设置并指定过期时间">直接设置并指定过期时间</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>设置值并指定过期时间</td><td><code>set(K key, V value, timeout, unit)</code></td><td><code>SETEX key seconds value</code> <strong>即将废弃</strong></td><td><strong>推荐</strong> → <code>SET key value EX seconds</code></td></tr></tbody></table><h3 id="保留-TTL-写入（KEEP-TTL）">保留 TTL 写入（KEEP_TTL）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置新值并保留原 TTL</td><td>无直接方法</td><td><code>SET key value KEEPTTL</code></td><td>Redis ≥ 6.0</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeepTtl</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class="line">            connection.stringCommands().set(</span><br><span class="line">                    Objects.requireNonNull(redisTemplate.getStringSerializer().serialize(key)),</span><br><span class="line">                    Objects.requireNonNull(((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer()).serialize(value)),</span><br><span class="line">                    Expiration.keepTtl(),</span><br><span class="line">                    RedisStringCommands.SetOption.UPSERT</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通读取">普通读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取 key 的值</td><td><code>get(K key)</code></td><td><code>GET key</code></td><td>—</td></tr></tbody></table><h3 id="读改写原子操作（GETEX-GETDEL）">读改写原子操作（GETEX / GETDEL）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取值并重置过期时间</td><td><code>getAndExpire(K key, timeout, unit)</code></td><td><code>GETEX key EX seconds</code></td><td>Redis ≥ 6.2<br>GET + EXPIRE（非原子）</td></tr><tr><td>获取 key 的当前值并移除过期时间</td><td><code>getAndPersist(K key)</code></td><td><code>GETEX key PERSIST</code></td><td>Redis ≥ 6.2<br>GET + PERSIST（非原子）</td></tr><tr><td>获取值并删除 key</td><td><code>getAndDelete(K key)</code></td><td><code>GETDEL key</code></td><td>Redis ≥ 6.2<br>GET + DEL（非原子）</td></tr><tr><td>获取旧值并设置新值</td><td><code>getAndSet(K key, V value)</code></td><td><code>GETSET key value</code> <strong>即将废弃</strong></td><td><strong>推荐</strong> → <code>SET key value GET</code></td></tr></tbody></table><h3 id="字符串区间读取">字符串区间读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取字符串指定区间</td><td><code>get(K key, start, end)</code></td><td><code>GETRANGE key start end</code></td><td>—</td></tr><tr><td>获取字符串长度</td><td><code>size(K key)</code></td><td><code>STRLEN key</code></td><td>—</td></tr></tbody></table><h3 id="数值运算（计数器场景）">数值运算（计数器场景）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>数值自增 1</td><td><code>increment(K key)</code></td><td><code>INCR key</code></td><td>value 必须是整数</td></tr><tr><td>数值增加指定值</td><td><code>increment(K key, delta)</code></td><td><code>INCRBY key increment</code></td><td>—</td></tr><tr><td>数值自减 1</td><td><code>decrement(K key)</code></td><td><code>DECR key</code></td><td>—</td></tr><tr><td>数值减少指定值</td><td><code>decrement(K key, delta)</code></td><td><code>DECRBY key decrement</code></td><td>—</td></tr></tbody></table><h3 id="批量写入-读取">批量写入 / 读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>批量设置 key-value</td><td><code>multiSet(map)</code></td><td><code>MSET key value ...</code></td><td>非原子</td></tr><tr><td>批量获取 key 的值</td><td><code>multiGet(keys)</code></td><td><code>MGET key ...</code></td><td>不存在返回 <code>null</code></td></tr></tbody></table><h3 id="批量条件写入（原子）">批量条件写入（原子）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>批量设置（仅当全部不存在）</td><td><code>multiSetIfAbsent(map)</code></td><td><code>MSETNX key value ...</code></td><td><strong>全成功 / 全失败</strong></td></tr></tbody></table><h3 id="字符串追加操作">字符串追加操作</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>追加字符串并返回新长度</td><td><code>append(K key, String value)</code></td><td><code>APPEND key value</code></td><td>key 不存在等价于 SET</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis String 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- 通用命令</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/</id>
    <published>2025-12-15T13:30:05.000Z</published>
    <updated>2025-12-17T02:40:19.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="通用命令">通用命令</h2><ul class="lvl-0"><li class="lvl-2"><p>针对所有数据类型均可使用给的方法和命令</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>redisTemplate.xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>复制 key 到新 key</td><td><code>Boolean copy(K source, K target, boolean replace)</code></td><td><code>COPY source target [REPLACE]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>判断 key 是否存在（单个）</td><td><code>Boolean hasKey(K key)</code></td><td><code>EXISTS key</code></td><td>CLI 返回存在数量</td></tr><tr><td>统计存在的 key 数量</td><td><code>Long countExistingKeys(Collection&lt;K&gt; keys)</code></td><td><code>EXISTS key [key ...]</code></td><td>返回存在 key 的数量</td></tr><tr><td>删除指定 key（同步）</td><td><code>Boolean delete(K key)</code></td><td><code>DEL key</code></td><td>返回是否删除成功</td></tr><tr><td>批量删除 key（同步）</td><td><code>Long delete(Collection&lt;K&gt; keys)</code></td><td><code>DEL key [key ...]</code></td><td>返回删除数量</td></tr><tr><td>删除 key（异步）</td><td><code>Boolean unlink(K key)</code></td><td><code>UNLINK key</code></td><td>非阻塞删除</td></tr><tr><td>批量删除 key（异步）</td><td><code>Long unlink(Collection&lt;K&gt; keys)</code></td><td><code>UNLINK key [key ...]</code></td><td>推荐大 key 使用</td></tr><tr><td>获取 key 的数据类型</td><td><code>DataType type(K key)</code></td><td><code>TYPE key</code></td><td>返回 string/hash/list/set/zset/none</td></tr><tr><td>按模式匹配 key（阻塞）</td><td><code>Set&lt;K&gt; keys(K pattern)</code></td><td><code>KEYS pattern</code></td><td><strong>生产环境不推荐</strong></td></tr><tr><td>游标方式扫描 key</td><td><code>Cursor&lt;K&gt; scan(ScanOptions options)</code></td><td><code>SCAN cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>KEYS</code></td></tr><tr><td>随机返回一个 key</td><td><code>K randomKey()</code></td><td><code>RANDOMKEY</code></td><td>可能返回 <code>null</code></td></tr><tr><td>重命名 key</td><td><code>void rename(K oldKey, K newKey)</code></td><td><code>RENAME oldKey newKey</code></td><td>覆盖目标 key</td></tr><tr><td>key 不存在时重命名</td><td><code>Boolean renameIfAbsent(K oldKey, K newKey)</code></td><td><code>RENAMENX oldKey newKey</code></td><td>原子操作</td></tr><tr><td>设置 key 过期时间</td><td><code>Boolean expire(K key, long timeout, TimeUnit unit)</code></td><td><code>PEXPIRE / EXPIRE</code></td><td>优先毫秒精度</td></tr><tr><td>设置 key 在指定时间过期</td><td><code>Boolean expireAt(K key, Date date)</code></td><td><code>PEXPIREAT / EXPIREAT</code></td><td>精度自动降级</td></tr><tr><td>设置过期策略（高级 API）</td><td><code>ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options)</code></td><td><code>EXPIRE / PEXPIRE / EXPIREAT</code></td><td>Spring 抽象封装</td></tr><tr><td>清除 key 的过期时间</td><td><code>Boolean persist(K key)</code></td><td><code>PERSIST key</code></td><td>变为永久 key</td></tr><tr><td>获取剩余 TTL（秒）</td><td><code>Long getExpire(K key)</code></td><td><code>TTL key</code></td><td><code>-1</code> 无 TTL，<code>-2</code> 不存在</td></tr><tr><td>获取剩余 TTL（指定单位）</td><td><code>Long getExpire(K key, TimeUnit unit)</code></td><td><code>PTTL / TTL</code></td><td>优先毫秒</td></tr><tr><td>将 key 移动到其他 DB</td><td><code>Boolean move(K key, int dbIndex)</code></td><td><code>MOVE key db</code></td><td>集群模式不可用</td></tr><tr><td>导出 key 的序列化值</td><td><code>byte[] dump(K key)</code></td><td><code>DUMP key</code></td><td>用于迁移</td></tr><tr><td>恢复 key</td><td><code>void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace)</code></td><td><code>RESTORE key ttl value [REPLACE]</code></td><td>与 <code>DUMP</code> 配合</td></tr><tr><td>排序并返回结果</td><td><code>List&lt;V&gt; sort(SortQuery&lt;K&gt; query)</code></td><td><code>SORT key</code></td><td>阻塞操作</td></tr><tr><td>排序并指定返回类型</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer)</code></td><td><code>SORT key</code></td><td>结果反序列化</td></tr><tr><td>排序并映射结果</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper)</code></td><td><code>SORT key</code></td><td>Spring 封装</td></tr><tr><td>排序并映射（高级）</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper)</code></td><td><code>SORT key</code></td><td>批量映射</td></tr><tr><td>排序并存储结果</td><td><code>Long sort(SortQuery&lt;K&gt; query, K storeKey)</code></td><td><code>SORT key STORE destination</code></td><td>返回结果条数</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>生产环境慎用的命令</p></li></ul><table><thead><tr><th>命令</th><th>原因</th><th>推荐</th></tr></thead><tbody><tr><td><code>KEYS</code></td><td>阻塞、O(N)</td><td><code>SCAN</code></td></tr><tr><td><code>SORT</code></td><td>阻塞、消耗 CPU</td><td>业务侧排序</td></tr><tr><td><code>DEL</code></td><td>阻塞、消耗 CPU</td><td><code>UNLINK</code></td></tr></tbody></table><h2 id="避免BigKey">避免BigKey</h2><ul class="lvl-0"><li class="lvl-2"><p>BigKey 的危害并不在“占内存”，而在操作成本是 O(N)。</p></li><li class="lvl-2"><p>Redis 是单线程执行命令，比如 <code>HGETALL</code>、<code>DEL</code>等，运行期间会占用CPU，阻塞 Redis 主线程，直接表现为 RT 飙升 / QPS 下降。</p></li><li class="lvl-2"><p>另外BigKey还会导致如下问题：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大 Key 返回值过大 → 网络 IO 抖动</span><br><span class="line">主从复制同步 BigKey → 从库延迟</span><br><span class="line">RDB / AOF 重写 → Fork 时间变长</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>BigKey 的阈值</p></li></ul><table><thead><tr><th>数据类型</th><th>元素数量阈值（经验值）</th></tr></thead><tbody><tr><td>String</td><td>≥ 10,000 byte</td></tr><tr><td>Hash</td><td>≥ 10,000 field</td></tr><tr><td>List</td><td>≥ 10,000 item</td></tr><tr><td>Set</td><td>≥ 10,000 member</td></tr><tr><td>ZSet</td><td>≥ 10,000 member</td></tr></tbody></table><blockquote><p>在生产环境中，5,000 就已经需要警惕。<br>建议在数据量达到一定阈值时，考虑拆分。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>Reids官方给出了判断BigKey的命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BigKey-的处理方式">BigKey 的处理方式</h3><h4 id="避免执行占用CPU的操作">避免执行占用CPU的操作</h4><ul class="lvl-0"><li class="lvl-2"><p>比如 <code>HGETALL</code>、<code>DEL</code>、<code>Keys *</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只读取一部分字段</span></span><br><span class="line">HGETALL user:1001 --&gt; HMGET user:1001 name age email</span><br><span class="line"><span class="comment"># 异步清除</span></span><br><span class="line">DEL key --&gt; UNLINK key</span><br><span class="line"><span class="comment"># 避免 KEYS 改用 SCAN</span></span><br><span class="line">keys pattern --&gt; scan cursor match pattern count 1000</span><br><span class="line"><span class="comment"># 避免读取全部数据，而是应该指定读取范围</span></span><br><span class="line">LRANGE key 0 -1 --&gt; LRANGE key 0 999</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>业务侧排序，避免使用<code>SORT</code></p></li></ul><h4 id="设计上避免BigKey">设计上避免BigKey</h4><ul class="lvl-0"><li class="lvl-2"><p>拆分数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误设计：</span></span><br><span class="line">user:all_profiles -&gt; 超大 JSON</span><br><span class="line"><span class="comment"># 正确设计：</span></span><br><span class="line">user:1001:profile</span><br><span class="line">user:1002:profile</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 分桶（Shard）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 hash(id) % N 分散</span></span><br><span class="line">order:2025:0</span><br><span class="line">order:2025:1</span><br><span class="line">order:2025:2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis SCAN 命令详解：作用、用法与最佳实践</title>
    <link href="https://blog.hanqunfeng.com/2025/12/10/redis7-scan/"/>
    <id>https://blog.hanqunfeng.com/2025/12/10/redis7-scan/</id>
    <published>2025-12-10T13:30:05.000Z</published>
    <updated>2025-12-10T09:16:12.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。</li><li class="lvl-2">Redis 提供了两种思路：使用 <code>KEYS pattern</code> 或使用游标式遍历命令 <code>SCAN</code>。</li><li class="lvl-2"><code>KEYS pattern</code> 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用<code>KEYS pattern</code>等危险命令。</li><li class="lvl-2">所以Redis官方强烈推荐 <code>SCAN</code> 方式，其是最安全、最可控的遍历方法。</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="SCAN-的核心作用">SCAN 的核心作用</h2><ul class="lvl-0"><li class="lvl-2"><p>SCAN 的主要功能是<strong>基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key</strong>。</p></li><li class="lvl-2"><p>它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。</p></li><li class="lvl-2"><p>SCAN 的设计目标包括：</p><ul class="lvl-2"><li class="lvl-5">避免阻塞 Redis 主线程</li><li class="lvl-5">分批、渐进扫描大规模 key 集合</li><li class="lvl-5">灵活配合模式匹配（MATCH）</li><li class="lvl-5">控制每次返回 key 的数量（COUNT）</li><li class="lvl-5">在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描</li></ul></li><li class="lvl-2"><p>SCAN 命令是完整游标遍历族的一部分，还包括：</p><ul class="lvl-2"><li class="lvl-5"><code>HSCAN</code>：遍历哈希表 field/value</li><li class="lvl-5"><code>SSCAN</code>：遍历 set 元素</li><li class="lvl-5"><code>ZSCAN</code>：遍历有序集合</li></ul></li><li class="lvl-2"><p>为了完成后面的示例演示，这里准备一个测试数据批量生产脚本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本名称：import_unified_data.sh</span></span><br><span class="line"><span class="comment"># 运行方法：sh $0 &lt;type&gt; [count]</span></span><br><span class="line"><span class="comment"># &lt;type&gt;: string, hash, list, set, 或 zset</span></span><br><span class="line"><span class="comment"># [count]: 导入的数据量 (可选，默认为 100)</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 参数校验与配置 ---</span></span><br><span class="line"></span><br><span class="line">SUPPORTED_TYPES=<span class="string">&quot;string hash list set zset&quot;</span></span><br><span class="line"><span class="comment"># 定义每个集合/列表/有序集合要添加的成员数量</span></span><br><span class="line">MEMBERS_PER_KEY=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否提供了类型参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ 错误：请指定导入类型。&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;支持的类型: <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: sh <span class="variable">$0</span> &lt;type&gt; [count]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取类型参数 (第一个参数)</span></span><br><span class="line">DATA_TYPE=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据量参数 (第二个参数)，不存在则默认为 1000</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ge 2 ]; <span class="keyword">then</span></span><br><span class="line">    DATA_COUNT=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    DATA_COUNT=100</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查类型是否有效</span></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="string">&quot; <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$&#123;DATA_TYPE&#125;</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ 错误：不支持的类型 &#x27;<span class="variable">$DATA_TYPE</span>&#x27;。&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;支持的类型: <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 连接配置</span></span><br><span class="line">REDIS_HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">REDIS_PORT=<span class="string">&quot;6379&quot;</span></span><br><span class="line">REDIS_PASSWORD=<span class="string">&quot;password&quot;</span> <span class="comment"># 替换为你的实际密码或留空</span></span><br><span class="line">KEY_PREFIX=<span class="string">&quot;test_data&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># --- 2. 命令生成主逻辑 ---</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ 正在生成 <span class="variable">$&#123;DATA_COUNT&#125;</span> 条 Redis [<span class="variable">$&#123;DATA_TYPE&#125;</span>] 命令...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 RESP 命令流</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le <span class="variable">$DATA_COUNT</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$DATA_TYPE</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment"># --- String 类型导入 (SET key value) ---</span></span><br><span class="line">        string)</span><br><span class="line">            KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:string:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            VALUE=<span class="string">&quot;value_of_<span class="variable">$&#123;i&#125;</span>_<span class="subst">$(date +%s%N)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># SET 命令 RESP 协议: *3 (SET, key, value)</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$3\r\nSET\r\n\$<span class="variable">$&#123;#KEY&#125;</span>\r\n<span class="variable">$&#123;KEY&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE&#125;</span>\r\n<span class="variable">$&#123;VALUE&#125;</span>\r\n&quot;</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Hash 类型导入 (HSET key field1 value1 field2 value2) ---</span></span><br><span class="line">        <span class="built_in">hash</span>)</span><br><span class="line">            HASH_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:hash:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            FIELD1=<span class="string">&quot;name&quot;</span></span><br><span class="line">            VALUE1=<span class="string">&quot;User_Name_<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            FIELD2=<span class="string">&quot;age&quot;</span></span><br><span class="line">            VALUE2=$(( (i % <span class="number">50</span>) + <span class="number">20</span> ))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2)</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;*6\r\n\$4\r\nHSET\r\n\$<span class="variable">$&#123;#HASH_KEY&#125;</span>\r\n<span class="variable">$&#123;HASH_KEY&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\$<span class="variable">$&#123;#FIELD1&#125;</span>\r\n<span class="variable">$&#123;FIELD1&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE1&#125;</span>\r\n<span class="variable">$&#123;VALUE1&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\$<span class="variable">$&#123;#FIELD2&#125;</span>\r\n<span class="variable">$&#123;FIELD2&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE2&#125;</span>\r\n<span class="variable">$&#123;VALUE2&#125;</span>\r\n&quot;</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- List 类型导入 (LPUSH key value) ---</span></span><br><span class="line">        list)</span><br><span class="line">            LIST_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:list:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                VALUE=<span class="string">&quot;list_element_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line">                <span class="comment"># LPUSH 命令 RESP 协议: *3 (LPUSH, key, value)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$5\r\nLPUSH\r\n\$<span class="variable">$&#123;#LIST_KEY&#125;</span>\r\n<span class="variable">$&#123;LIST_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE&#125;</span>\r\n<span class="variable">$&#123;VALUE&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Set 类型导入 (SADD key member) ---</span></span><br><span class="line">        <span class="built_in">set</span>)</span><br><span class="line">            SET_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:set:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                MEMBER=<span class="string">&quot;set_member_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line">                <span class="comment"># SADD 命令 RESP 协议: *3 (SADD, key, member)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$4\r\nSADD\r\n\$<span class="variable">$&#123;#SET_KEY&#125;</span>\r\n<span class="variable">$&#123;SET_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#MEMBER&#125;</span>\r\n<span class="variable">$&#123;MEMBER&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Sorted Set 类型导入 (ZADD key score member) ---</span></span><br><span class="line">        zset)</span><br><span class="line">            ZSET_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:zset:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                SCORE=<span class="string">&quot;<span class="variable">$&#123;i&#125;</span><span class="variable">$&#123;j&#125;</span>&quot;</span> <span class="comment"># 生成唯一分数：例如 key 1 的分数是 11, 12...</span></span><br><span class="line">                MEMBER=<span class="string">&quot;zset_member_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># ZADD 命令 RESP 协议: *4 (ZADD, key, score, member)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*4\r\n\$4\r\nZADD\r\n\$<span class="variable">$&#123;#ZSET_KEY&#125;</span>\r\n<span class="variable">$&#123;ZSET_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#SCORE&#125;</span>\r\n<span class="variable">$&#123;SCORE&#125;</span>\r\n\$<span class="variable">$&#123;#MEMBER&#125;</span>\r\n<span class="variable">$&#123;MEMBER&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    i=$((i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span> | (</span><br><span class="line">    <span class="comment"># ----------------------------------------</span></span><br><span class="line">    <span class="comment"># --- 3. 管道导入到 Redis ---</span></span><br><span class="line">    <span class="comment"># ----------------------------------------</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;📤 正在通过 redis-cli --pipe 导入数据...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建 redis-cli 命令</span></span><br><span class="line">    REDIS_CLI_CMD=<span class="string">&quot;redis-cli -h <span class="variable">$&#123;REDIS_HOST&#125;</span> -p <span class="variable">$&#123;REDIS_PORT&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果设置了密码，则添加 -a 参数</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        REDIS_CLI_CMD=<span class="string">&quot;<span class="variable">$&#123;REDIS_CLI_CMD&#125;</span> -a <span class="variable">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行导入</span></span><br><span class="line">    <span class="variable">$&#123;REDIS_CLI_CMD&#125;</span> --pipe</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查命令是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;✅ 数据导入成功！共导入 <span class="variable">$&#123;DATA_COUNT&#125;</span> 条 [<span class="variable">$&#123;DATA_TYPE&#125;</span>] 记录。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="SCAN-的基本用法">SCAN 的基本用法</h2><ul class="lvl-0"><li class="lvl-2"><p>SCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class="built_in">type</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数解释：</p></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>cursor</td><td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td></tr><tr><td>MATCH pattern</td><td>使用通配符匹配 key（可选）</td></tr><tr><td>COUNT count</td><td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td></tr><tr><td>TYPE type</td><td>匹配的 key 类型（可选）</td></tr></tbody></table><h3 id="示例：">示例：</h3><ul class="lvl-0"><li class="lvl-2"><p>为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh import_unified_data.sh string 100</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取所有 key：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 游标初始值为0</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">&quot;88&quot;</span>  <span class="comment"># 游标</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line"><span class="comment"># 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key</span></span><br><span class="line"><span class="comment">## 扫描结果中：</span></span><br><span class="line"><span class="comment"># 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束</span></span><br><span class="line"><span class="comment"># 第二个元素是匹配的 key列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着上面给出的游标，继续扫描：</span></span><br><span class="line">127.0.0.1:6379&gt; scan 88</span><br><span class="line">1) <span class="string">&quot;92&quot;</span>  <span class="comment"># 不为0就表示还有更多的 key 可以继续扫描</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line">……………………………………</span><br><span class="line">127.0.0.1:6379&gt; scan 87</span><br><span class="line">1) <span class="string">&quot;0&quot;</span> <span class="comment"># 扫描结束 游标为0</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:68&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:79&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:41&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">控制每次获取的 key 数量</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 count 20</span><br><span class="line">1) <span class="string">&quot;92&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">   12) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">   13) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">   14) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">   15) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">   16) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">   17) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">   18) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">   19) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   20) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   21) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line"><span class="comment"># 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。</span></span><br><span class="line"><span class="comment"># 本示例就返回了21条，比 count 还多了 1 条</span></span><br><span class="line"><span class="comment"># 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">扫描以 test_data:string 开头的 key</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match test_data:string*</span><br><span class="line">1) <span class="string">&quot;88&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="4"><li class="lvl-5">扫描以 test_data:string 开头的 key，并返回 30 条</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match test_data:string* count 30</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">   12) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">   13) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">   14) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">   15) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">   16) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">   17) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">   18) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">   19) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   20) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   21) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line">   22) <span class="string">&quot;test_data:string:48&quot;</span></span><br><span class="line">   23) <span class="string">&quot;test_data:string:74&quot;</span></span><br><span class="line">   24) <span class="string">&quot;test_data:string:67&quot;</span></span><br><span class="line">   25) <span class="string">&quot;test_data:string:26&quot;</span></span><br><span class="line">   26) <span class="string">&quot;test_data:string:60&quot;</span></span><br><span class="line">   27) <span class="string">&quot;test_data:string:36&quot;</span></span><br><span class="line">   28) <span class="string">&quot;test_data:string:49&quot;</span></span><br><span class="line">   29) <span class="string">&quot;test_data:string:3&quot;</span></span><br><span class="line">   30) <span class="string">&quot;test_data:string:44&quot;</span></span><br><span class="line">   31) <span class="string">&quot;test_data:string:68&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个</span></span><br><span class="line"><span class="comment"># 也有可能比 count 少，甚至为 0 个</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="5"><li class="lvl-5">扫描以 h_key 开头的 key，并返回 30 条</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先插入一条记录</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> h_key:1 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个</span></span><br><span class="line"><span class="comment"># 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回</span></span><br><span class="line"><span class="comment"># 并且此时返回的游标也不为0，说明我们还需要继续扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整的扫描过程如下：</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)  <span class="comment"># empty array 也不能说明一定没有</span></span><br><span class="line">127.0.0.1:6379&gt; scan 124 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;9&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line">127.0.0.1:6379&gt; scan 9 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;43&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;h_key:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 43 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;0&quot;</span>      <span class="comment"># 只有游标为0时才算扫描结束</span></span><br><span class="line">2) (empty array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line">127.0.0.1:6379&gt; scan 124 match h_key* count 60</span><br><span class="line">1) <span class="string">&quot;75&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;h_key:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 75 match h_key* count 60</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) (empty array)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="6"><li class="lvl-5">扫描指定类型的key</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> string</span><br><span class="line">1) <span class="string">&quot;88&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持的类型有：</span></span><br><span class="line"><span class="comment"># string list set zset hash stream</span></span><br><span class="line"><span class="comment"># 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。</span></span><br><span class="line"><span class="comment"># 例如，ZSET 和 GEOHASH 都是 zset 类型。</span></span><br><span class="line">127.0.0.1:6379&gt; GEOADD geokey 0 0 value</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> geokey</span><br><span class="line">zset</span><br><span class="line">127.0.0.1:6379&gt; ZADD zkey 1000 value</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SCAN 0 TYPE zset count 1000</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;zkey&quot;</span></span><br><span class="line">   2) <span class="string">&quot;geokey&quot;</span></span><br></pre></td></tr></table></figure><h2 id="HSCAN-的基本使用方法">HSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>HSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数解释：</p></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>key</td><td>键名</td></tr><tr><td>cursor</td><td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td></tr><tr><td>MATCH pattern</td><td>使用通配符匹配 key（可选）</td></tr><tr><td>COUNT count</td><td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td></tr><tr><td>NOVALUES</td><td>redis8+增加的属性，只返回key，不返回 value（可选）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>为了测试 HSCAN，我们先插入一些数据：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh import_unified_data.sh <span class="built_in">hash</span> 100</span><br></pre></td></tr></table></figure><h3 id="使用示例">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取所有 field 和 value：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> <span class="built_in">hash</span></span><br><span class="line">1) <span class="string">&quot;48&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:hash:42&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:hash:71&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:hash:54&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:hash:87&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:hash:96&quot;</span></span><br><span class="line">   6) <span class="string">&quot;test_data:hash:49&quot;</span></span><br><span class="line"><span class="comment"># 获取 test_data:hash:42 的所有 field 和 value</span></span><br><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;User_Name_42&quot;</span></span><br><span class="line">   3) <span class="string">&quot;age&quot;</span></span><br><span class="line">   4) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配 field：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 match age*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;age&quot;</span></span><br><span class="line">   2) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">模糊匹配 field，并返回 10 条数据：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 match *e* count 10</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;User_Name_42&quot;</span></span><br><span class="line">   3) <span class="string">&quot;age&quot;</span></span><br><span class="line">   4) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="4"><li class="lvl-5">不显示value(需要redis8+)</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 novalues</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure><h2 id="SSCAN-的基本使用方法">SSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>SSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="使用示例-2">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取指定key的所有元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;112&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:set:43&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:set:33&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:set:98&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:set:61&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:set:2&quot;</span></span><br><span class="line">   6) <span class="string">&quot;test_data:set:70&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_1&quot;</span></span><br><span class="line">   2) <span class="string">&quot;set_member_43_2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;set_member_43_3&quot;</span></span><br><span class="line">   4) <span class="string">&quot;set_member_43_4&quot;</span></span><br><span class="line">   5) <span class="string">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0 match *_3*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_3&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">返回 1 个元素: 实际上控制不住，大概率会返回所有元素</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0 count 1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_1&quot;</span></span><br><span class="line">   2) <span class="string">&quot;set_member_43_2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;set_member_43_3&quot;</span></span><br><span class="line">   4) <span class="string">&quot;set_member_43_4&quot;</span></span><br><span class="line">   5) <span class="string">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ZSCAN-的基本使用方法">ZSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>ZSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="使用示例-3">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取指定key的所有元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> zset</span><br><span class="line">1) <span class="string">&quot;112&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:zset:89&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:zset:81&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:zset:73&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:zset:79&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:zset:15&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zscan test_data:zset:89 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;zset_member_89_1&quot;</span></span><br><span class="line">    2) <span class="string">&quot;891&quot;</span></span><br><span class="line">    3) <span class="string">&quot;zset_member_89_2&quot;</span></span><br><span class="line">    4) <span class="string">&quot;892&quot;</span></span><br><span class="line">    5) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">    6) <span class="string">&quot;893&quot;</span></span><br><span class="line">    7) <span class="string">&quot;zset_member_89_4&quot;</span></span><br><span class="line">    8) <span class="string">&quot;894&quot;</span></span><br><span class="line">    9) <span class="string">&quot;zset_member_89_5&quot;</span></span><br><span class="line">   10) <span class="string">&quot;895&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;893&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">获取指定key的所有元素，并返回 1 个元素，同样控制不住</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zscan test_data:zset:89 0 count 1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;zset_member_89_1&quot;</span></span><br><span class="line">    2) <span class="string">&quot;891&quot;</span></span><br><span class="line">    3) <span class="string">&quot;zset_member_89_2&quot;</span></span><br><span class="line">    4) <span class="string">&quot;892&quot;</span></span><br><span class="line">    5) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">    6) <span class="string">&quot;893&quot;</span></span><br><span class="line">    7) <span class="string">&quot;zset_member_89_4&quot;</span></span><br><span class="line">    8) <span class="string">&quot;894&quot;</span></span><br><span class="line">    9) <span class="string">&quot;zset_member_89_5&quot;</span></span><br><span class="line">   10) <span class="string">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 提供了两种思路：使用 &lt;code&gt;KEYS pattern&lt;/code&gt; 或使用游标式遍历命令 &lt;code&gt;SCAN&lt;/code&gt;。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;code&gt;KEYS pattern&lt;/code&gt; 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用&lt;code&gt;KEYS pattern&lt;/code&gt;等危险命令。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;所以Redis官方强烈推荐 &lt;code&gt;SCAN&lt;/code&gt; 方式，其是最安全、最可控的遍历方法。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 新一代构建工具 mvnd</title>
    <link href="https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/"/>
    <id>https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/</id>
    <published>2025-12-07T14:30:05.000Z</published>
    <updated>2025-12-08T06:04:23.696Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Maven 新一代构建工具 mvnd</p></li><li class="lvl-2"><p><a href="https://github.com/apache/maven-mvnd">mvnd GitHub</a></p></li><li class="lvl-2"><p>本文安装的是 mvnd 1.0.3。</p></li></ul><span id="more"></span><h2 id="mvnd-简介">mvnd 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。</p></li><li class="lvl-2"><p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p></li></ul><h3 id="架构概述">架构概述</h3><ul class="lvl-0"><li class="lvl-2"><p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p></li><li class="lvl-2"><p>实际构建发生在一个长驻后台进程中，又名守护程序。</p></li><li class="lvl-2"><p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p></li><li class="lvl-2"><p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p></li><li class="lvl-2"><p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p></li><li class="lvl-2"><p>这种架构带来了以下优点：</p><ul class="lvl-2"><li class="lvl-6">不需要每次构建重新启动 JVM，大大节省时间。</li><li class="lvl-6">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li><li class="lvl-6">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li></ul></li><li class="lvl-2"><p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p></li></ul><h2 id="mvnd-安装">mvnd 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>mvnd 安装包下载地址：</p><ul class="lvl-2"><li class="lvl-6"><a href="https://github.com/apache/maven-mvnd/releases">mvnd Github Release</a></li><li class="lvl-6"><a href="https://maven.apache.org/download.cgi">maven 官网下载页</a></li></ul></li><li class="lvl-2"><p>本文以 macOS 为例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 mvnd 对应的安装包</span></span><br><span class="line">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class="line"><span class="built_in">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class="line"><span class="comment"># 添加 mvnd 到环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment"># 检查 mvnd 是否安装成功</span></span><br><span class="line">mvnd --version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p></li><li class="lvl-2"><p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$MVND_HOME</span>/conf/mvnd.properties <span class="variable">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p></li></ul><table><thead><tr><th>配置项</th><th>默认值</th><th>中文解释</th></tr></thead><tbody><tr><td><strong>mvnd.noBuffering</strong> <code>[*]</code></td><td>false</td><td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td></tr><tr><td><strong>mvnd.rollingWindowSize</strong></td><td>0</td><td>构建并行模块时，每个模块显示的日志行数</td></tr><tr><td><strong>mvnd.logPurgePeriod</strong></td><td>7d</td><td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td></tr><tr><td><strong>mvnd.noDaemon</strong></td><td>false</td><td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td></tr><tr><td><strong>mvnd.debug</strong></td><td>false</td><td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td></tr><tr><td><strong>mvnd.idleTimeout</strong></td><td>3 hours</td><td>守护进程在空闲多久后自动关闭</td></tr><tr><td><strong>mvnd.keepAlive</strong></td><td>100 ms</td><td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td></tr><tr><td><strong>mvnd.maxLostKeepAlive</strong></td><td>30</td><td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td></tr><tr><td><strong>mvnd.minThreads</strong></td><td>1</td><td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td></tr><tr><td><strong>mvnd.threads</strong> <code>[*]</code></td><td>未设置</td><td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td></tr><tr><td><strong>mvnd.builder</strong></td><td>smart</td><td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td></tr><tr><td><strong>mvnd.minHeapSize</strong></td><td>128M</td><td>守护进程 JVM 的最小堆内存</td></tr><tr><td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td><td>2G</td><td>守护进程 JVM 的最大堆内存</td></tr><tr><td><strong>mvnd.threadStackSize</strong></td><td>1M</td><td>守护进程线程栈大小</td></tr><tr><td><strong>mvnd.jvmArgs</strong></td><td>未设置</td><td>传递给 daemon 的额外 JVM 参数</td></tr><tr><td><strong>mvnd.enableAssertions</strong></td><td>false</td><td>是否为 daemon 启用 JVM 断言（-ea）</td></tr><tr><td><strong>mvnd.expirationCheckDelay</strong></td><td>10 seconds</td><td>守护进程检测自身是否需要过期的时间间隔</td></tr><tr><td><strong>mvnd.duplicateDaemonGracePeriod</strong></td><td>10 seconds</td><td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td></tr><tr><td><strong>mvnd.home</strong></td><td>自动设置</td><td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td></tr><tr><td><strong>java.home</strong></td><td>使用环境变量</td><td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td></tr><tr><td><strong>maven.settings</strong> <code>[*]</code></td><td>~/.m2/settings.xml</td><td>maven 的 settings.xml 路径</td></tr></tbody></table><h2 id="mvnd-使用">mvnd 使用</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行使用方式与 mvn 一样，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvnd clean install</span><br><span class="line">mvnd clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p></li><li class="lvl-2"><p>mvnd 还有些特殊用法，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class="line">mvnd --status</span><br><span class="line"><span class="comment"># 手动停止所有运行的守护进程</span></span><br><span class="line">mvnd --stop</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png" alt=""></p></li></ul><h2 id="mvnd-与-mvnw-的区别">mvnd 与 mvnw 的区别</h2><ul class="lvl-0"><li class="lvl-2"><p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class="line">mvnw： linux 脚本文件</span><br><span class="line">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p></li><li class="lvl-2"><p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p></li><li class="lvl-2"><p><code>mvnw</code>使用方式如下:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mvnw clean install</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p></li></ul><table><thead><tr><th>对比项</th><th>mvnd</th><th>mvnw（Maven Wrapper）</th></tr></thead><tbody><tr><td>是什么</td><td>一个「常驻的 Maven 守护进程」</td><td>一个「Maven 启动脚本」</td></tr><tr><td>是否常驻</td><td>✅ 是（daemon）</td><td>❌ 否（一次性）</td></tr><tr><td>是否下载 Maven</td><td>❌ 不下载，自己就是程序</td><td>✅ 会自动下载指定版本</td></tr><tr><td>主要目的</td><td>加速构建</td><td>保证版本一致</td></tr><tr><td>是否推荐在 CI</td><td>一般不建议</td><td>✅ 非常推荐</td></tr><tr><td>使用方式</td><td><code>mvnd clean install</code></td><td><code>./mvnw clean install</code></td></tr><tr><td>是否与项目绑定</td><td>❌ 全局使用</td><td>✅ 和项目绑定</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Maven 新一代构建工具 mvnd&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apache/maven-mvnd&quot;&gt;mvnd GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文安装的是 mvnd 1.0.3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="maven" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/maven/"/>
    
    <category term="mvnd" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/maven/mvnd/"/>
    
    
    <category term="mavne" scheme="https://blog.hanqunfeng.com/tags/mavne/"/>
    
    <category term="mvnd" scheme="https://blog.hanqunfeng.com/tags/mvnd/"/>
    
  </entry>
  
  <entry>
    <title>Redis 7 + ACL 简介</title>
    <link href="https://blog.hanqunfeng.com/2025/12/07/redis7-acl/"/>
    <id>https://blog.hanqunfeng.com/2025/12/07/redis7-acl/</id>
    <published>2025-12-07T13:30:05.000Z</published>
    <updated>2025-12-07T07:50:08.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">Redis 7 + ACL 简介</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="Redis-ACL-简介">Redis ACL 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p></li><li class="lvl-2"><p>ACL 可以控制的维度包括：</p><ul class="lvl-2"><li class="lvl-5">谁能登录（用户、密码）</li><li class="lvl-5">可以执行哪些命令</li><li class="lvl-5">可以访问哪些 key（按前缀 / 正则）</li><li class="lvl-5">可否通过网络访问</li><li class="lvl-5">是否启用 / 禁用某个用户</li></ul></li><li class="lvl-2"><p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p></li></ul><h2 id="Redis-ACL-的使用">Redis ACL 的使用</h2><ul class="lvl-0"><li class="lvl-2"><p>在 <code>redis.conf</code> 中添加如下内容：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 ACL 文件</span></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"><span class="comment"># 关闭 密码</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p></li></ul><h3 id="ACL-的配置方式">ACL 的配置方式</h3><h4 id="直接编辑-aclfile">直接编辑 aclfile</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置一个管理员</span></span><br><span class="line">user admin on ~* &amp;* +@all &gt;password</span><br><span class="line"><span class="comment"># 配置一个应用用户</span></span><br><span class="line">user appuser on  ~cache:* &amp;app:* +get +<span class="built_in">set</span> &gt;password</span><br><span class="line"><span class="comment"># 配置一个只读用户</span></span><br><span class="line">user <span class="built_in">readonly</span> on ~* -@all +@<span class="built_in">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p></li><li class="lvl-2"><p>格式说明</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user: 固定前缀</span><br><span class="line">username: 用户名</span><br><span class="line">on: 启用 off: 禁用</span><br><span class="line">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class="line">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class="line">+<span class="built_in">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class="built_in">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class="built_in">cat</span> 命令查看，以@开头，比如 @<span class="built_in">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class="line">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际上就是一个超级管理员权限</span></span><br><span class="line">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class="line"><span class="comment"># 如果设置了 requirepass 密码</span></span><br><span class="line">user default on sanitize-payload <span class="comment">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭默认用户，禁止匿名访问</span></span><br><span class="line">user default off</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接时直接登录, --pass == -a</span></span><br><span class="line">redis-cli --user username --pass password -h host -p port</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class="line"><span class="comment"># 本机登录</span></span><br><span class="line">redis-cli -u redis://admin:123456@</span><br><span class="line"><span class="comment"># 本机登录时端口不是默认的6379时</span></span><br><span class="line">redis-cli -u redis://admin:123456@:6380</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先连接后登录</span></span><br><span class="line">redis-cli -h host -p port</span><br><span class="line">&gt; auth username password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis ACL 规则中文说明</p></li></ul><table><thead><tr><th>规则 / 语法</th><th>中文说明</th></tr></thead><tbody><tr><td><code>on</code></td><td>启用用户：可以使用该用户进行认证登录</td></tr><tr><td><code>off</code></td><td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td></tr><tr><td><code>skip-sanitize-payload</code></td><td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td></tr><tr><td><code>sanitize-payload</code></td><td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td></tr><tr><td><code>+&lt;command&gt;</code></td><td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td></tr><tr><td><code>-&lt;command&gt;</code></td><td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td></tr><tr><td><code>+@&lt;category&gt;</code></td><td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td></tr><tr><td><code>@all</code></td><td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td></tr><tr><td><code>+&lt;command&gt;|first-arg</code></td><td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td></tr><tr><td><code>allcommands</code></td><td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td></tr><tr><td><code>nocommands</code></td><td><code>-@all</code> 的别名，禁止所有命令</td></tr><tr><td><code>~&lt;pattern&gt;</code></td><td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td></tr><tr><td><code>%R~&lt;pattern&gt;</code></td><td>添加<strong>允许读取</strong>的 key 模式</td></tr><tr><td><code>%W~&lt;pattern&gt;</code></td><td>添加<strong>允许写入</strong>的 key 模式</td></tr><tr><td><code>allkeys</code></td><td><code>~*</code> 的别名，允许所有 key</td></tr><tr><td><code>resetkeys</code></td><td>清空允许访问的 key 模式</td></tr><tr><td><code>&amp;&lt;pattern&gt;</code></td><td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td></tr><tr><td><code>allchannels</code></td><td><code>&amp;*</code> 的别名，允许所有 channel</td></tr><tr><td><code>resetchannels</code></td><td>清空 Pub/Sub channel 模式列表</td></tr><tr><td><code>&gt;&lt;password&gt;</code></td><td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td></tr><tr><td><code>&lt;&lt;password&gt;</code></td><td>移除指定密码</td></tr><tr><td><code>nopass</code></td><td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td></tr><tr><td><code>resetpass</code></td><td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td></tr><tr><td><code>reset</code></td><td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td></tr><tr><td><code>(&lt;options&gt;)</code></td><td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td></tr><tr><td><code>clearselectors</code></td><td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td></tr></tbody></table><h4 id="通过-ACL-命令">通过 ACL 命令</h4><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png" alt=""></p><h5 id="ACL-SETUSER">ACL SETUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>创建/修改用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 default 用户</span></span><br><span class="line">ACL SETUSER default off</span><br><span class="line"><span class="comment"># 创建一个管理员</span></span><br><span class="line">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class="line"><span class="comment"># 创建一个普通用户</span></span><br><span class="line">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class="built_in">set</span></span><br><span class="line"><span class="comment"># 创建一个只读用户</span></span><br><span class="line">ACL SETUSER <span class="built_in">readonly</span> on ~* -@all +@<span class="built_in">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p></li><li class="lvl-2"><p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">ACL SETUSER testuser on ~* -@all +@<span class="built_in">read</span> +ping  &gt;password</span><br><span class="line"><span class="comment"># 第二次执行，只添加新的权限</span></span><br><span class="line">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行后的结果</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure><h6 id="修改用户权限">修改用户权限</h6><ul class="lvl-0"><li class="lvl-2"><p>重置权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置所有权限</span></span><br><span class="line">ACL SETUSER testuser reset</span><br><span class="line"><span class="comment">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class="line"><span class="string">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>取消密码，但保留权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser nopass</span><br><span class="line"><span class="comment">## 运行结果：取消密码</span></span><br><span class="line"><span class="string">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>去除所有频道</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure><h5 id="ACL-LIST">ACL LIST</h5><ul class="lvl-0"><li class="lvl-2"><p>可以通过如下命令查看当前 Redis 中所有的用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACL LIST</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class="line">2) <span class="string">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class="line">3) <span class="string">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class="line">4) <span class="string">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user: 固定前缀</span><br><span class="line">username: 用户名</span><br><span class="line">on: 启用</span><br><span class="line">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class="line">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class="line">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class="line">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class="line">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class="line">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure><h5 id="ACL-LOAD">ACL LOAD</h5><ul class="lvl-0"><li class="lvl-2"><p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SAVE</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p></li></ul><h5 id="ACL-SAVE">ACL SAVE</h5><ul class="lvl-0"><li class="lvl-2"><p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL LOAD</span><br></pre></td></tr></table></figure><h5 id="ACL-USERS">ACL USERS</h5><ul class="lvl-0"><li class="lvl-2"><p>列出所有已创建的用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACL USERS</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;admin&quot;</span></span><br><span class="line">2) <span class="string">&quot;appuser&quot;</span></span><br><span class="line">3) <span class="string">&quot;default&quot;</span></span><br><span class="line">4) <span class="string">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure><h5 id="ACL-GETUSER">ACL GETUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>获取指定用户的权限信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER appuser</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;flags&quot;</span></span><br><span class="line"> 2) 1) <span class="string">&quot;on&quot;</span></span><br><span class="line">    2) <span class="string">&quot;sanitize-payload&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;passwords&quot;</span></span><br><span class="line"> 4) 1) <span class="string">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;commands&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;-@all +get +set&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;keys&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;~cache:*&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;channels&quot;</span></span><br><span class="line">10) <span class="string">&quot;&amp;app:*&quot;</span></span><br><span class="line">11) <span class="string">&quot;selectors&quot;</span></span><br><span class="line">12) (empty array)</span><br></pre></td></tr></table></figure><h6 id="selectors-选择器规则">selectors(选择器规则)</h6><ul class="lvl-0"><li class="lvl-2"><p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p></li><li class="lvl-2"><p>以前 = 一个用户一条规则</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根权限（全局规则）</span></span><br><span class="line">ACL SETUSER selectoruser on ~cache:* +get +<span class="built_in">set</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>现在 = 一个用户可以有多个“权限分身”</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择器规则</span></span><br><span class="line"><span class="comment"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class="line">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class="built_in">set</span>) &gt;123456</span><br><span class="line"><span class="comment">## 翻译后的结果</span></span><br><span class="line"><span class="string">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p></li></ul><h5 id="ACL-DELUSER">ACL DELUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>删除一个用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure><h5 id="ACL-WHOAMI">ACL WHOAMI</h5><ul class="lvl-0"><li class="lvl-2"><p>获取当前登录的用户名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL WHOAMI</span><br></pre></td></tr></table></figure><h5 id="ACL-CAT">ACL CAT</h5><ul class="lvl-0"><li class="lvl-2"><p>获取所有权限类别</p></li><li class="lvl-2"><p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p></li><li class="lvl-2"><p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有权限类别</span></span><br><span class="line">ACL CAT</span><br><span class="line"><span class="comment"># 获取指定类别中的命令列表</span></span><br><span class="line">ACL CAT 分类名称</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p></li></ul><h5 id="ACL-DRYRUN">ACL DRYRUN</h5><ul class="lvl-0"><li class="lvl-2"><p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p></li><li class="lvl-2"><p>Redis 7.0.0 新增。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class="line"><span class="string">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure><h5 id="ACL-LOG">ACL LOG</h5><ul class="lvl-0"><li class="lvl-2"><p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p></li><li class="lvl-2"><p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACL LOG          <span class="comment"># 查看默认最新的 ACL 日志条目</span></span><br><span class="line">ACL LOG RESET    <span class="comment"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>日志格式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">&quot;count&quot;</span> =&gt; 1</span><br><span class="line">   2) <span class="string">&quot;reason&quot;</span> =&gt; <span class="string">&quot;command&quot;</span></span><br><span class="line">   3) <span class="string">&quot;context&quot;</span> =&gt; <span class="string">&quot;toplevel&quot;</span></span><br><span class="line">   4) <span class="string">&quot;object&quot;</span> =&gt; <span class="string">&quot;acl|log&quot;</span></span><br><span class="line">   5) <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;selectoruser&quot;</span></span><br><span class="line">   6) <span class="string">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class="line">   7) <span class="string">&quot;client-info&quot;</span> =&gt; <span class="string">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class="line">   8) <span class="string">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class="line">   9) <span class="string">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class="line">   10) <span class="string">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>count</code></td><td>触发该日志的次数。比如同一事件触发 1 次就是 1</td></tr><tr><td><code>reason</code></td><td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td></tr><tr><td><code>context</code></td><td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td></tr><tr><td><code>object</code></td><td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td></tr><tr><td><code>username</code></td><td>触发事件的用户</td></tr><tr><td><code>age-seconds</code></td><td>事件距离当前的时间（秒），越大表示越久远</td></tr><tr><td><code>client-info</code></td><td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td></tr><tr><td><code>entry-id</code></td><td>日志条目 ID</td></tr><tr><td><code>timestamp-created</code></td><td>日志创建时间（毫秒）</td></tr><tr><td><code>timestamp-last-updated</code></td><td>日志最后更新时间（毫秒）</td></tr></tbody></table><h5 id="ACL-GENPASS">ACL GENPASS</h5><ul class="lvl-0"><li class="lvl-2"><p>生成一个随机的 ACL 密码</p></li><li class="lvl-2"><p>生成复杂密码的工具有很多，没必要用这玩意。</p></li><li class="lvl-2"><p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class="line">&gt; ACL GENPASS</span><br><span class="line"><span class="string">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class="line"><span class="comment"># 指定长度，32/4 = 8</span></span><br><span class="line">&gt; ACL GENPASS 32</span><br><span class="line"><span class="string">&quot;355ef3dd&quot;</span></span><br><span class="line"><span class="comment"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class="line">&gt; ACL GENPASS 5</span><br><span class="line"><span class="string">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 7 + ACL 简介&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
    <category term="redis cluster" scheme="https://blog.hanqunfeng.com/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</title>
    <link href="https://blog.hanqunfeng.com/2025/12/05/redis7-config/"/>
    <id>https://blog.hanqunfeng.com/2025/12/05/redis7-config/</id>
    <published>2025-12-05T13:30:05.000Z</published>
    <updated>2025-12-10T02:58:13.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">传统的非ACL版本，可以参考 <a href="/2022/09/09/redis5-config/" title="Redis单节点、主从、哨兵、集群构建方法">Redis单节点、主从、哨兵、集群构建方法</a></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="redis安装">redis安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载到指定目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft</span><br><span class="line">wget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft</span><br><span class="line">tar -zxvf redis-7.4.7.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="built_in">sudo</span> yum install gcc gcc-c++ -y</span><br><span class="line"><span class="built_in">cd</span> redis-7.4.7</span><br><span class="line"><span class="comment"># 编译，会将编译好的可执行文件放在src目录下</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> build_dir</span><br><span class="line">make install PREFIX=$(<span class="built_in">pwd</span>)/build_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件</span></span><br><span class="line"><span class="built_in">cp</span> redis.conf redis-6379.conf</span><br><span class="line">vim redis-6379.conf <span class="comment">#见下面的配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">redis-cli --version</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">redis-cli 7.4.7</span><br></pre></td></tr></table></figure><h2 id="单节点">单节点</h2><ul class="lvl-0"><li class="lvl-2"><p><code>redis-6379.conf</code> 的主要配置</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口，默认 6379</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动，默认 no</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yes: 当没有 bind / requirepass / ACL 时，只允许本机访问</span></span><br><span class="line"><span class="comment"># no: 允许任意访问</span></span><br><span class="line"><span class="comment"># 这里会启用ACL，所以设置为 yes，默认 yes</span></span><br><span class="line">protected-mode <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># 可以配置为，本机IP 内网IP 外网IP</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 10.250.0.103 18.163.188.20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照</span></span><br><span class="line"><span class="comment"># 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/soft/dir-redis7/6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no</span></span><br><span class="line"><span class="comment"># 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复</span></span><br><span class="line"><span class="comment"># 生成环境必须开启</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件名称，默认 appendonly.aof</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir</span></span><br><span class="line"><span class="comment"># redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：</span></span><br><span class="line"><span class="comment"># appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件</span></span><br><span class="line"><span class="comment"># appendonly.aof.N.incr.aof：记录每个写操作命令</span></span><br><span class="line"><span class="comment"># appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)</span></span><br><span class="line">appenddirname <span class="string">&quot;appendonlydir&quot;</span></span><br><span class="line"><span class="comment"># aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysec</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令</span></span><br><span class="line"><span class="comment"># 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb</span></span><br><span class="line"><span class="comment"># 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令</span></span><br><span class="line"><span class="comment"># 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb</span></span><br><span class="line"><span class="comment"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mb</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="comment"># aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes</span></span><br><span class="line"><span class="comment"># 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aof</span></span><br><span class="line">aof-use-rdb-preamble <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 防止 AOF 意外截断导致 Redis 起不来，默认 yes</span></span><br><span class="line">aof-load-truncated <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pid文件路径，默认 /var/run/redis_6379.pid</span></span><br><span class="line">pidfile <span class="string">&quot;redis_6379.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件名称，默认 &quot;&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定最大内存，单位bytes，这里设置4G</span></span><br><span class="line"><span class="comment"># 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降</span></span><br><span class="line">maxmemory 4294967296</span><br><span class="line"><span class="comment"># 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间</span></span><br><span class="line"><span class="comment"># volatile-lru: 只会淘汰「设置了过期时间」的 key</span></span><br><span class="line"><span class="comment"># allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的</span></span><br><span class="line"><span class="comment"># allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的</span></span><br><span class="line"><span class="comment"># noeviction: 不淘汰，默认</span></span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询日志</span></span><br><span class="line"><span class="comment"># 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录</span></span><br><span class="line">slowlog-max-len 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能优化</span></span><br><span class="line"><span class="comment"># Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了</span></span><br><span class="line">io-threads 4</span><br><span class="line"><span class="comment"># 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端</span></span><br><span class="line"><span class="comment"># 推荐&gt;=4核才开启，否则开了反而更慢</span></span><br><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着</span></span><br><span class="line">tcp-keepalive 60</span><br><span class="line"><span class="comment"># 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0</span></span><br><span class="line"><span class="comment"># 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放</span></span><br><span class="line"><span class="built_in">timeout</span> 0</span><br><span class="line"><span class="comment"># 最大客户端连接数，默认 10000</span></span><br><span class="line">maxclients 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令</span></span><br><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span></span><br><span class="line">rename-command FLUSHDB <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SHUTDOWN &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command KEYS &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SAVE &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command BGSAVE &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command DEBUG &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command EVAL &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SCRIPT &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。</span></span><br><span class="line">lazyfree-lazy-eviction <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。</span></span><br><span class="line">lazyfree-lazy-expire <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：</span></span><br><span class="line"><span class="comment">#    RENAME 替换旧 key 时删除旧 value</span></span><br><span class="line"><span class="comment">#    SET 操作覆盖旧值时删除旧 value</span></span><br><span class="line"><span class="comment">#    SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value</span></span><br><span class="line"><span class="comment">#    重写函数、脚本时删除旧对象</span></span><br><span class="line"><span class="comment"># 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。</span></span><br><span class="line">lazyfree-lazy-server-del <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。</span></span><br><span class="line"><span class="comment"># 此配置只影响副本不会影响主节点。</span></span><br><span class="line">replica-lazy-flush <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。</span></span><br><span class="line"><span class="comment"># 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。</span></span><br><span class="line"><span class="comment"># 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。</span></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"><span class="comment"># FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行</span></span><br><span class="line"><span class="comment"># 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。</span></span><br><span class="line">lazyfree-lazy-user-flush no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启 ACL 文件</span></span><br><span class="line">aclfile /usr/local/soft/redis-7.4.7/users.acl</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 7 支持的淘汰策略</p></li></ul><table><thead><tr><th>策略</th><th>是否只淘汰带 TTL 的 key</th><th>淘汰规则</th><th>说明</th></tr></thead><tbody><tr><td><strong>noeviction</strong></td><td>❌ 不淘汰</td><td>不删任何 key</td><td>内存满了直接返回错误（默认）</td></tr><tr><td><strong>allkeys-lru</strong></td><td>❌ 所有 key</td><td>最近最久未使用</td><td>✅ 最常用</td></tr><tr><td><strong>allkeys-lfu</strong></td><td>❌ 所有 key</td><td>访问频率最少</td><td>✅ 热点场景最好</td></tr><tr><td><strong>allkeys-random</strong></td><td>❌ 所有 key</td><td>随机删除</td><td>❌ 很少用</td></tr><tr><td><strong>volatile-lru</strong></td><td>✅ 只淘汰有 TTL 的</td><td>最近最久未使用</td><td>你之前用的</td></tr><tr><td><strong>volatile-lfu</strong></td><td>✅ 只淘汰有 TTL 的</td><td>访问频率最少</td><td>较少使用</td></tr><tr><td><strong>volatile-random</strong></td><td>✅ 只淘汰有 TTL 的</td><td>随机删除</td><td>很少用</td></tr><tr><td><strong>volatile-ttl</strong></td><td>✅ 只淘汰有 TTL 的</td><td>TTL 最小（马上过期的）</td><td>特殊场景用</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>users.acl</code> 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 <a href="/2025/12/07/redis7-acl/" title="Redis 7 + ACL 简介">Redis 7 + ACL 简介</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭默认用户，禁止匿名访问</span></span><br><span class="line">user default off</span><br><span class="line"><span class="comment"># 超级管理员</span></span><br><span class="line">user admin on ~* &amp;* +@all &gt;123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>redis 服务启动与关闭</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">redis-server redis-6379.conf</span><br><span class="line"><span class="comment"># 登录服务，本机访问可以省略 -h -p</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line"><span class="comment"># shutdown == shutdown save</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown</span><br><span class="line"><span class="comment"># 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave</span><br></pre></td></tr></table></figure><table><thead><tr><th>场景</th><th>推荐命令</th></tr></thead><tbody><tr><td>正常下线（生产）</td><td><code>shutdown nosave</code></td></tr><tr><td>已开 AOF</td><td><code>shutdown nosave</code></td></tr><tr><td>数据很大</td><td><code>shutdown nosave</code></td></tr><tr><td>单机调试</td><td><code>shutdown</code></td></tr><tr><td>确定要生成快照</td><td><code>shutdown save</code></td></tr><tr><td>强制杀死(redis卡死)</td><td><code>kill -9</code>（极端情况）</td></tr></tbody></table><h3 id="单节点优点">单节点优点</h3><ul class="lvl-0"><li class="lvl-2"><p>单机部署简单方便</p></li></ul><h3 id="单节点缺点">单节点缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>不保证数据的可靠性，不适用于数据可靠性要求高的场景</p></li><li class="lvl-2"><p>单点故障导致无法提供服务，或者硬盘损坏导致数据丢失</p></li><li class="lvl-2"><p>redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流</p></li></ul><h2 id="主从">主从</h2><ul class="lvl-0"><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master 10.250.0.235</span><br><span class="line">slave1 10.250.0.58</span><br><span class="line">slave2 10.250.0.36</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主从配置时，主节点不需要做任何修改</p></li><li class="lvl-2"><p>从节点配置文件增加同步主节点信息，其余配置与主节点相同</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号</span></span><br><span class="line">replicaof 10.250.0.235 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致</span></span><br><span class="line">replica-read-only <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class="line">masteruser admin</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时启动从节点<code>redis-server redis-6379.conf</code>，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步</p></li><li class="lvl-2"><p>主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点</p></li><li class="lvl-2"><p>主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点</p></li><li class="lvl-2"><p>从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式</p></li><li class="lvl-2"><p>此时登录master的redis并执行<code>info replication</code>命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master     <span class="comment"># 表示当前是从节点</span></span><br><span class="line">connected_slaves:1 <span class="comment"># 从节点数量</span></span><br><span class="line">slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 <span class="comment"># 从节点信息</span></span><br><span class="line">master_failover_state:no-failover <span class="comment"># 主节点切换状态，无</span></span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class="comment"># 主节点的复制ID</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:56  <span class="comment"># 主节点复制的偏移量</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1  <span class="comment"># 是否开启复制回放</span></span><br><span class="line">repl_backlog_size:1048576 <span class="comment"># 复制回放缓冲区大小</span></span><br><span class="line">repl_backlog_first_byte_offset:1 <span class="comment"># 复制回放缓冲区第一个字节的偏移量</span></span><br><span class="line">repl_backlog_histlen:56 <span class="comment"># 复制回放缓冲区历史长度</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时登录从节点的redis并执行<code>info replication</code>命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave               <span class="comment"># 表示当前是从节点</span></span><br><span class="line">master_host:10.250.0.235 <span class="comment"># 主节点的ip</span></span><br><span class="line">master_port:6379         <span class="comment"># 主节点的端口</span></span><br><span class="line">master_link_status:up    <span class="comment"># 主从节点连接状态，up 表示已经连接上主节点</span></span><br><span class="line">master_last_io_seconds_ago:6 <span class="comment"># 主从节点最后一次io操作时间</span></span><br><span class="line">master_sync_in_progress:0 <span class="comment"># 主从节点是否正在同步数据，0表示已完成</span></span><br><span class="line">slave_read_repl_offset:112 <span class="comment"># 从节点已经读取的复制偏移量</span></span><br><span class="line">slave_repl_offset:112   <span class="comment"># 从节点已经写入的复制偏移量</span></span><br><span class="line">slave_priority:100      <span class="comment"># 从节点的优先级</span></span><br><span class="line">slave_read_only:1       <span class="comment"># 从节点是否只读</span></span><br><span class="line">replica_announced:1     <span class="comment"># 从节点是否被其他节点所代理</span></span><br><span class="line">connected_slaves:0      <span class="comment"># 从节点所代理的从节点数量</span></span><br><span class="line">master_failover_state:no-failover <span class="comment"># 主节点的故障转移状态，no-failover表示没有进行故障转移</span></span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class="comment"># 主节点的复制ID</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:112  <span class="comment"># 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主从数据同步是否完成判断规则，在从节点上执行命令<code>info replication</code></p></li></ul><table><thead><tr><th>字段</th><th>正常值</th><th>说明</th></tr></thead><tbody><tr><td><code>role</code></td><td>slave</td><td>表示当前是从节点</td></tr><tr><td><code>master_link_status</code></td><td>up</td><td>表示已经连上主库</td></tr><tr><td><code>master_sync_in_progress</code></td><td>0</td><td>同步不在进行中 = 已完成</td></tr><tr><td><code>slave_read_repl_offset</code> ≈ <code>master_repl_offset</code></td><td>接近</td><td>说明数据已追上</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>参照上面的配置，再添加一个从节点后，在主节点执行命令 <code>info replication</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2  <span class="comment"># 从节点数量</span></span><br><span class="line">slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0</span><br><span class="line">slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0  <span class="comment"># 第二个从节点信息</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:4313</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:4313</span><br></pre></td></tr></table></figure><h3 id="主从优点">主从优点</h3><ul class="lvl-0"><li class="lvl-2"><p>对请求进行读写分离，提高处理效率</p></li><li class="lvl-2"><p>可以提供多个副本，提高数据安全性</p></li></ul><h3 id="主从缺点">主从缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p></li></ul><h2 id="哨兵">哨兵</h2><ul class="lvl-0"><li class="lvl-2"><p>创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵</p></li><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">master 10.250.0.235</span><br><span class="line">slave1 10.250.0.58</span><br><span class="line">slave2 10.250.0.36</span><br><span class="line">sentinel1 10.250.0.71</span><br><span class="line">sentinel2 10.250.0.131</span><br><span class="line">sentinel3 10.250.0.63</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别编辑各自的 <code>sentinel.conf</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir，需要提前创建好</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/soft/dir-redis7/sentinel</span><br><span class="line"></span><br><span class="line"><span class="comment"># pid文件路径</span></span><br><span class="line">pidfile redis-sentinel.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件名称</span></span><br><span class="line">logfile <span class="string">&quot;sentinel.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1</span></span><br><span class="line">sentinel monitor mymaster 10.250.0.235 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主观下线时间（5秒），默认30秒</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移超时时间 60秒，默认180秒</span></span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次允许多少个slave重新同步，默认就是 1</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># acl用户名和密码，这里为了方便也是用的管理员帐号</span></span><br><span class="line">sentinel auth-user mymaster admin</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动三个哨兵节点<code>redis-sentinel sentinel.conf</code>，此时登录哨兵节点<code>redis-cli -p 26379</code>，并执行<code>info Sentinel</code>命令，查看其是否正确识别了主从</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line">sentinel_masters:1      <span class="comment"># 哨兵集群中主从节点的数量</span></span><br><span class="line">sentinel_tilt:0         <span class="comment"># 是否处于 tilt 状态</span></span><br><span class="line">sentinel_tilt_since_seconds:-1 <span class="comment"># tilt 状态的开始时间</span></span><br><span class="line">sentinel_running_scripts:0 <span class="comment"># 正在运行的脚本数量</span></span><br><span class="line">sentinel_scripts_queue_length:0 <span class="comment"># 脚本队列长度</span></span><br><span class="line">sentinel_simulate_failure_flags:0 <span class="comment"># 模拟故障的标志</span></span><br><span class="line">master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 <span class="comment"># 主节点的地址，从节点数量和哨兵数量</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时查看<code>sentinel.conf</code>可以在文件最后看到从节点信息和其它的哨兵节点信息(<em><strong>但实测无法感知其它哨兵节点</strong></em>)，类似于</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">latency-tracking-info-percentiles 50 99 99.9  <span class="comment"># 延迟追踪信息百分比</span></span><br><span class="line">user default on nopass sanitize-payload ~* &amp;* +@all <span class="comment"># 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码</span></span><br><span class="line">sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 <span class="comment"># 本节点的id</span></span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line">sentinel current-epoch 0</span><br><span class="line"><span class="comment"># 一个从节点信息</span></span><br><span class="line">sentinel known-replica mymaster 10.250.0.58 6379</span><br><span class="line"><span class="comment"># 另一个从节点信息</span></span><br><span class="line">sentinel known-replica mymaster 10.250.0.36 6379</span><br><span class="line"><span class="comment"># 一个哨兵节点信息</span></span><br><span class="line">sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a</span><br><span class="line"><span class="comment"># 另一个哨兵节点信息</span></span><br><span class="line">sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看<code>info Sentinel</code>，就会发现master节点变成了从节点其中的一个了</p></li><li class="lvl-2"><p>此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">latency-tracking-info-percentiles 50 99 99.9</span><br><span class="line">replicaof 10.250.0.36 6379</span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class="line">masteruser admin</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>顺便说一下，关闭哨兵服务的命令如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 shutdown</span><br></pre></td></tr></table></figure><h3 id="哨兵优点">哨兵优点</h3><ul class="lvl-0"><li class="lvl-2"><p>主节点故障，可以自动在从节点中重新选主</p></li></ul><h3 id="哨兵缺点">哨兵缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载</p></li><li class="lvl-2"><p>从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离</p></li></ul><h2 id="集群">集群</h2><ul class="lvl-0"><li class="lvl-2"><p>搭建6个redis的集群，3主3从</p></li><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis1 10.250.0.235</span><br><span class="line">redis2 10.250.0.58</span><br><span class="line">redis3 10.250.0.36</span><br><span class="line">redis4 10.250.0.71</span><br><span class="line">redis5 10.250.0.131</span><br><span class="line">redis6 10.250.0.63</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ACL认证，所有节点都要配置</span></span><br><span class="line">masteruser <span class="string">&quot;admin&quot;</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群节点信息文件，这里最好和port对应上</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，</span></span><br><span class="line"><span class="comment"># 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置</span></span><br><span class="line"><span class="comment"># 开启这个配置可以预防集群脑裂问题，默认为3</span></span><br><span class="line">min-replicas-to-write 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能</span></span><br><span class="line"><span class="comment"># 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败</span></span><br><span class="line">cluster-require-full-coverage <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动6个redis服务</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(<em><strong>删除dir配置的目录中的所有文件即可</strong></em>)，然后在任意一个redis执行</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># --cluster create：创建集群</span></span><br><span class="line"><span class="comment"># --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点</span></span><br><span class="line"><span class="comment"># 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时会列出集群内主从和槽位的分配方案，输入<code>yes</code>即可</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 10.250.0.131:6379 to 10.250.0.235:6379</span><br><span class="line">Adding replica 10.250.0.63:6379 to 10.250.0.58:6379</span><br><span class="line">Adding replica 10.250.0.71:6379 to 10.250.0.36:6379</span><br><span class="line">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class="line">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class="line">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class="line">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class="line">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class="line">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span></span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)</span><br><span class="line">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class="line">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class="line">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class="line">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录集群并查询集群配置信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 表示以集群模式登录，-h 集群内任意ip</span></span><br><span class="line">redis-cli --user admin --pass 123456 -c -h 10.250.0.235</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster info</span><br><span class="line"><span class="comment"># 输出集群状态</span></span><br><span class="line">cluster_state:ok                                <span class="comment"># 集群整体状态：ok 表示集群当前可用、健康</span></span><br><span class="line">cluster_slots_assigned:16384                    <span class="comment"># 已分配的哈希槽数量（总槽数固定为 16384）</span></span><br><span class="line">cluster_slots_ok:16384                          <span class="comment"># 正常工作的槽数量（等于已分配槽，说明全部正常）</span></span><br><span class="line">cluster_slots_pfail:0                           <span class="comment"># 处于“疑似失败(pfail)”状态的槽数量</span></span><br><span class="line">cluster_slots_fail:0                            <span class="comment"># 被判定为失败(fail)的槽数量</span></span><br><span class="line">cluster_known_nodes:6                           <span class="comment"># 当前节点已知的集群节点总数（主节点 + 从节点）</span></span><br><span class="line">cluster_size:3                                  <span class="comment"># 主节点数量（3 主节点，典型的 3 主 3 从结构）</span></span><br><span class="line">cluster_current_epoch:6                         <span class="comment"># 集群当前的全局纪元（用于选举和配置同步）</span></span><br><span class="line">cluster_my_epoch:1                              <span class="comment"># 当前这个节点所在的纪元</span></span><br><span class="line">cluster_stats_messages_ping_sent:159           <span class="comment"># 当前节点已发送的 PING 消息数量（心跳）</span></span><br><span class="line">cluster_stats_messages_pong_sent:156           <span class="comment"># 当前节点已发送的 PONG 消息数量（心跳响应）</span></span><br><span class="line">cluster_stats_messages_sent:315                <span class="comment"># 当前节点发送的所有集群消息总数</span></span><br><span class="line">cluster_stats_messages_ping_received:151       <span class="comment"># 当前节点收到的 PING 消息数量</span></span><br><span class="line">cluster_stats_messages_pong_received:159       <span class="comment"># 当前节点收到的 PONG 消息数量</span></span><br><span class="line">cluster_stats_messages_meet_received:5         <span class="comment"># 当前节点收到的 MEET 消息数量（新节点加入发现）</span></span><br><span class="line">cluster_stats_messages_received:315            <span class="comment"># 当前节点收到的所有集群消息总数</span></span><br><span class="line">total_cluster_links_buffer_limit_exceeded:0    <span class="comment"># 因输出缓冲区超限被强制断开的集群连接数（0 = 正常）</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看节点列表</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment"># 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）</span></span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）</span></span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）</span></span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected</span><br><span class="line"><span class="comment"># 主节点（master），负责槽位 10923-16383（集群中第三段槽位）</span></span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383</span><br><span class="line"><span class="comment"># 主节点（master），负责槽位 5461-10922（集群中第二段槽位）</span></span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时查看<code>nodes-6379.conf</code>也会看到和上面一样的节点信息</p></li><li class="lvl-2"><p>此时关闭其中一个master节点，比如<code>10.250.0.36</code>，则其对应的slave节点<code>10.250.0.71</code>会切换为新的master节点，此时<code>10.250.0.36</code>的状态最终变为<code>fail</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383</span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected</span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected</span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected</span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再次启动<code>10.250.0.36</code>，其会变成<code>10.250.0.71</code>的slave节点</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383</span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected</span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected</span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected</span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>若此时还是希望 <code>10.250.0.36</code> 做为主节点，则需要先登录<code>10.250.0.36</code>，再执行如下命令</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要加 -c</span></span><br><span class="line">redis-cli -c --user admin --pass 123456 -h 10.250.0.36</span><br><span class="line">10.250.0.36:6379&gt; cluster failover <span class="comment"># 安全版（等待复制同步）</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER <span class="comment"># TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐)</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT=CRC16(key) mod 16384</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转重定位</span></span><br><span class="line">10.250.0.235:6379&gt; <span class="built_in">set</span> name zhangsan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">-&gt; Redirected to slot [5798] located at 10.250.0.58:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>关闭集群，6个redis分别关闭</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启集群，6个redis分别启动即可</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- <code>&#123;xxx&#125;</code>，其必须用<code>&#123;&#125;</code>括起来，<code>xxx</code>可以是任意字符串，计算slot时，只会根据<code>xxx</code>来计算hash值，这样就保证了所有key中包含<code>&#123;xxx&#125;</code>的key都会落到同一个slot，<code>&#123;xxx&#125;</code>可以放在key的任意位置</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; mset name1 lisi name2 wangwu</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don<span class="string">&#x27;t hash to the same slot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwu</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2</span></span><br><span class="line"><span class="string">-&gt; Redirected to slot [5474] located at 10.250.0.58:6379</span></span><br><span class="line"><span class="string">1) &quot;lisi&quot;</span></span><br><span class="line"><span class="string">2) &quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:<br>{…} 让多个 key 落在同一个 slot，支持跨 key 原子操作<br>只有 第一个匹配的 {…} 会被当做 tag<br>{} 不能嵌套<br>空标签 {} 是非法的<br>{abc} 和 {def} 就落不同 slot</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如何判断 key 落在哪个节点?</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster keyslot name1</span><br><span class="line"><span class="comment"># 输出的数值就表示 slot</span></span><br><span class="line">(<span class="built_in">integer</span>) 5461 <span class="comment"># slot值</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如何查看指定的slot中有多少个key?</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster countkeysinslot 5461</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 表示slot中key的个数，这里显示只有1个key</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源</p></li><li class="lvl-2"><p>集群通过<code>10000+port</code>这个端口号进行集群间通信，所以除了要开放<code>prot</code>这个端口，还要开放<code>10000+port</code>这个端口</p></li><li class="lvl-2"><p>有关redis集群及其水平扩展的进一步说明，可以参看<a href="/2018/12/27/redis-cluster/" title="Redis集群">Redis集群</a></p></li></ul><h3 id="集群优点">集群优点</h3><ul class="lvl-0"><li class="lvl-2"><p>无中心架构，集群内部自行维护数据的分片和主从的切换</p></li><li class="lvl-2"><p>数据分片存储，提供很高的访问效率</p></li><li class="lvl-2"><p>高可用性，可实现部分节点不可用时，集群仍可用</p></li><li class="lvl-2"><p>高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持</p></li></ul><h3 id="集群缺点">集群缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>数据通过异步复制，不保证数据的强一致性</p></li><li class="lvl-2"><p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0</p></li><li class="lvl-2"><p>不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作</p></li><li class="lvl-2"><p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点</p></li><li class="lvl-2"><p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能</p></li><li class="lvl-2"><p>不建议使用pipeline和multi-keys操作</p></li></ul><h3 id="redis-cli-的-Cluster-管理命令（用于管理-创建-调整集群）">redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群）</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>redis-cli --cluster create host1:port host2:port ...</code></td><td>创建 Redis Cluster 集群（自动分配 slots）</td><td><code>redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1</code></td></tr><tr><td><code>redis-cli --cluster check host:port</code></td><td>检查集群状态、健壮性</td><td><code>redis-cli --cluster check 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster info host:port</code></td><td>显示集群结构、节点、slots 分布</td><td><code>redis-cli --cluster info 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster fix host:port</code></td><td>修复 slots 移动、节点中断等异常状态</td><td><code>redis-cli --cluster fix 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster rebalance host:port</code></td><td>重新分布 slots（自动均衡负载）</td><td><code>redis-cli --cluster rebalance 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port</code></td><td>手动设置 rebalance 阈值；低于此阈值才会调整（百分比）</td><td><code>redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster add-node newHost:newPort existingHost:existingPort</code></td><td>将新节点加入集群</td><td><code>redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port</code></td><td>将新节点作为某主节点的 slave 加入</td><td><code>redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster del-node host:port node_id</code></td><td>从集群删除某节点（必须无 slots）</td><td><code>redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt;</code></td></tr><tr><td><code>redis-cli --cluster call host:port command ...</code></td><td>在所有节点上批量执行命令</td><td><code>redis-cli --cluster call 10.0.0.1:7000 PING</code></td></tr><tr><td><code>redis-cli --cluster help</code></td><td>显示 cluster 子命令帮助</td><td><code>redis-cli --cluster help</code></td></tr></tbody></table><h3 id="Redis-内置的-Cluster-操作命令">Redis 内置的 Cluster 操作命令</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CLUSTER INFO</code></td><td>查看集群状态、failover 状态、slot 分布统计</td><td><code>CLUSTER INFO</code></td></tr><tr><td><code>CLUSTER NODES</code></td><td>显示所有节点和角色（master/slave）</td><td><code>CLUSTER NODES</code></td></tr><tr><td><code>CLUSTER MYID</code></td><td>输出本节点 ID</td><td><code>CLUSTER MYID</code></td></tr><tr><td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td><td>将当前节点设置为某个 master 的 slave</td><td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td></tr><tr><td><code>CLUSTER FAILOVER</code></td><td>主动 failover（slave 升级为 master）</td><td>从节点执行：<code>CLUSTER FAILOVER</code></td></tr><tr><td><code>CLUSTER FAILOVER FORCE</code></td><td>不等待复制同步，立刻切主</td><td><code>CLUSTER FAILOVER FORCE</code></td></tr><tr><td><code>CLUSTER FAILOVER TAKEOVER</code></td><td>强制接管 slot（完全覆盖 master）（危险）</td><td><code>CLUSTER FAILOVER TAKEOVER</code></td></tr><tr><td><code>CLUSTER ADDSLOTS &lt;slot...&gt;</code></td><td>将 slots 分配给当前 master</td><td><code>CLUSTER ADDSLOTS 0 1 2</code></td></tr><tr><td><code>CLUSTER DELSLOTS &lt;slot...&gt;</code></td><td>从当前节点移除 slots</td><td><code>CLUSTER DELSLOTS 0 1 2</code></td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code></td><td>直接指定某个 slot 属于某个节点</td><td><code>CLUSTER SETSLOT 0 NODE &lt;id&gt;</code></td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt;</code></td><td>设定迁移 key 的源节点（用于 slot 迁移）</td><td>-</td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt;</code></td><td>设定迁移 key 的目标节点（用于 slot 迁移）</td><td>-</td></tr><tr><td><code>CLUSTER KEYSLOT key</code></td><td>返回 key 所属 slot</td><td><code>CLUSTER KEYSLOT mykey</code></td></tr><tr><td><code>CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt;</code></td><td>查看某节点的 fail 票数</td><td>-</td></tr><tr><td><code>CLUSTER RESET</code></td><td>删除节点全部集群信息（用来重置为 standalone）</td><td><code>CLUSTER RESET HARD</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 7 + ACL 单节点、主从、哨兵、集群构建方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;传统的非ACL版本，可以参考 &lt;a href=&quot;/2022/09/09/redis5-config/&quot; title=&quot;Redis单节点、主从、哨兵、集群构建方法&quot;&gt;Redis单节点、主从、哨兵、集群构建方法&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
    <category term="redis cluster" scheme="https://blog.hanqunfeng.com/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>brew -- 创建自己的 Formula</title>
    <link href="https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/"/>
    <id>https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/</id>
    <published>2025-12-02T13:55:05.000Z</published>
    <updated>2025-12-02T09:45:42.092Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %--><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://brew.sh">brew</a>是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如<code>git</code>、<code>node</code>、<code>python</code>等。</p></li><li class="lvl-2"><p>本文介绍如何在macos下创建自己的 Formula</p></li><li class="lvl-2"><p>本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。</p></li><li class="lvl-2"><p>关于 brew 的安装及使用可以参考 <a href="/2024/11/28/brew/" title="MacOS软件包管理器--brew">MacOS软件包管理器--brew</a></p></li></ul><span id="more"></span><h2 id="从一个简单示例开始">从一个简单示例开始</h2><ul class="lvl-0"><li class="lvl-2"><p>这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看<a href="https://github.com/hanqunfeng/color_echo/blob/main/bin/color_echo">color_echo</a>，这是一个用于终端打印彩色文本的命令。</p></li></ul><h3 id="创建一个Github仓库，用于存储-color-echo-命令">创建一个Github仓库，用于存储 color_echo 命令</h3><ul class="lvl-0"><li class="lvl-2"><p>创建一个Github仓库，用于存储 <code>color_echo</code> 命令文件，仓库名称: <code>hanqunfeng/color_echo</code></p></li><li class="lvl-2"><p>编写命令文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> color_echo_dir</span><br><span class="line"><span class="built_in">cd</span> color_echo_dir</span><br><span class="line"><span class="comment"># 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了</span></span><br><span class="line"><span class="comment"># 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到</span></span><br><span class="line">bin/color_echo</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>提交代码并打Tag</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 color_echo_dir 目录下初始化仓库</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/hanqunfeng/color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment"># 创建Tag</span></span><br><span class="line">git tag v1.0.0</span><br><span class="line"><span class="comment"># 推送Tag</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取tag的sha256值</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz</span><br><span class="line">shasum -a 256 v1.0.0.tar.gz</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d  v1.0.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="发布-color-echo">发布 color_echo</h3><blockquote><p><code>brew create</code> 命令已经失效，需要手工创建</p></blockquote><h4 id="创建-tap-仓库">创建 tap 仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">brew tap-new hanqunfeng/color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Warning: tap-new is a developer <span class="built_in">command</span>, so Homebrew<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">developer mode has been automatically turned on.      # 提示开发者模式已自动打开</span></span><br><span class="line"><span class="string">To turn developer mode off, run:</span></span><br><span class="line"><span class="string">  brew developer off  # 如后续需要关闭开发者模式可以运行该命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 初始化仓库</span></span><br><span class="line"><span class="string">Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/</span></span><br><span class="line"><span class="string">[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap</span></span><br><span class="line"><span class="string"> 3 files changed, 107 insertions(+)</span></span><br><span class="line"><span class="string"> create mode 100644 .github/workflows/publish.yml</span></span><br><span class="line"><span class="string"> create mode 100644 .github/workflows/tests.yml</span></span><br><span class="line"><span class="string"> create mode 100644 README.md</span></span><br><span class="line"><span class="string">==&gt; Created hanqunfeng/color_echo</span></span><br><span class="line"><span class="string">/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When a pull request making changes to a formula (or formulae) becomes green</span></span><br><span class="line"><span class="string">(all checks passed), then you can publish the built bottles.</span></span><br><span class="line"><span class="string">To do so, label your PR as `pr-pull` and the workflow will be triggered.</span></span><br></pre></td></tr></table></figure><h4 id="手写一个-Formula-文件">手写一个 Formula 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formula</span><br><span class="line"><span class="built_in">touch</span> color_echo.rb</span><br></pre></td></tr></table></figure><p>写入内容（模板）：模板格式后面会详细介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ColorEcho &lt; Formula</span><br><span class="line">  desc <span class="string">&quot;Print colorful text in terminal&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://github.com/hanqunfeng/color_echo&quot;</span></span><br><span class="line">  url <span class="string">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span></span><br><span class="line">  sha256 <span class="string">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span></span><br><span class="line">  license <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  def install</span><br><span class="line">    bin.install <span class="string">&quot;bin/color_echo&quot;</span></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span> <span class="keyword">do</span></span><br><span class="line">    system <span class="string">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class="string">&quot;--help&quot;</span></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="提交-Formula-文件到Github仓库">提交 Formula 文件到Github仓库</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个Github仓库，用于存储 Formula 文件: <code>hanqunfeng/homebrew-color_echo</code></p></li><li class="lvl-2"><p>添加 Formula 文件到仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> $(brew --repo hanqunfeng/color_echo)</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Add color_echo 1.0.0&quot;</span></span><br><span class="line">git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Enumerating objects: 11, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限<code>repo</code> 和 <code>workflow</code>，重新推送</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥</span></span><br><span class="line">git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Enumerating objects: 11, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">* [new branch]      main -&gt; main</span><br><span class="line">branch <span class="string">&#x27;main&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure><h4 id="安装-Formula">安装 Formula</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echo</span></span><br><span class="line">brew tap hanqunfeng/color_echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">brew search color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Formulae</span><br><span class="line">hanqunfeng/color_echo/color_echo              color-code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整包名搜索</span></span><br><span class="line">brew search hanqunfeng/color_echo/color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Formulae</span><br><span class="line">color_echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">brew install color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Fetching downloads <span class="keyword">for</span>: color_echo</span><br><span class="line">✔︎ Formula color_echo (1.0.0)                                   [Verifying     2.1KB/  2.1KB]</span><br><span class="line">==&gt; Installing color_echo from hanqunfeng/color_echo</span><br><span class="line">🍺  /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built <span class="keyword">in</span> 5 seconds</span><br><span class="line">==&gt; Running `brew cleanup color_echo`...</span><br><span class="line">Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.</span><br><span class="line">Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`).</span><br></pre></td></tr></table></figure><h4 id="测试-Formula">测试 Formula</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">color_echo --<span class="built_in">help</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">用法: color_echo [参数] 内容</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">  -c, --color &lt;color&gt;        设置前景色（文字颜色）</span><br><span class="line">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class="line"></span><br><span class="line">  -b, --<span class="built_in">bg</span> &lt;color&gt;           设置背景色</span><br><span class="line">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class="line"></span><br><span class="line">      --bold                 加粗字体</span><br><span class="line">      --underline            下划线</span><br><span class="line">      --italic               斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持）</span><br><span class="line"></span><br><span class="line">  -n                         不换行输出，兼容 <span class="built_in">echo</span> 的 -n 参数</span><br><span class="line"></span><br><span class="line">  -h, --<span class="built_in">help</span>                 显示帮助信息</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">  color_echo --color green <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  color_echo -c red -b yellow --bold <span class="string">&quot;Error Message&quot;</span></span><br><span class="line">  color_echo --underline <span class="string">&quot;This is underlined&quot;</span></span><br></pre></td></tr></table></figure><h2 id="formula-文件模板">formula 文件模板</h2><ul class="lvl-0"><li class="lvl-2"><p>Ruby语法，定义一个Formula的子类</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class 子类 &lt; 父类</span></span><br><span class="line">class ColorEcho &lt; Formula</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加属性</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc <span class="string">&quot;Print colorful text in terminal&quot;</span>  <span class="comment"># 描述</span></span><br><span class="line">homepage <span class="string">&quot;https://github.com/hanqunfeng/color_echo&quot;</span>  <span class="comment"># 项目地址</span></span><br><span class="line">url <span class="string">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span>  <span class="comment"># 下载地址，安装时会自动下载并解压</span></span><br><span class="line">sha256 <span class="string">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span>  <span class="comment"># sha256，校验v1.0.0.tar.gz</span></span><br><span class="line">license <span class="string">&quot;MIT&quot;</span>   <span class="comment"># 许可</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加安装方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def install  <span class="comment"># Homebrew 会执行的安装步骤，工作目录为解压后的文件目录</span></span><br><span class="line">  <span class="comment"># 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install</span></span><br><span class="line">  bin.install <span class="string">&quot;bin/color_echo&quot;</span> <span class="comment"># 将 bin/color_echo 安装到 /usr/local/bin/color_echo</span></span><br><span class="line">  <span class="comment"># 如果要指定安装后的命令名称，可以使用如下方式</span></span><br><span class="line">  <span class="comment"># bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果需要执行系统命令可以使用如下方式</span></span><br><span class="line">  <span class="comment"># system &quot;echo&quot;, &quot;hello world&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加测试方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> <span class="keyword">do</span>  <span class="comment"># Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码</span></span><br><span class="line">  <span class="comment"># system 指令用于执行系统命令，逗号分隔相当于空格</span></span><br><span class="line">  system <span class="string">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class="string">&quot;--help&quot;</span>  <span class="comment"># 相当于执行 color_echo --help</span></span><br><span class="line">  <span class="comment"># 断言测试</span></span><br><span class="line">  <span class="comment"># assert_equal &quot;2\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>#{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同</p></blockquote><table><thead><tr><th>系统 / 架构</th><th>实际路径示例</th></tr></thead><tbody><tr><td>Intel Mac</td><td><code>/usr/local/Cellar/color_echo/1.0.0/bin</code></td></tr><tr><td>Apple Silicon</td><td><code>/opt/homebrew/Cellar/color_echo/1.0.0/bin</code></td></tr><tr><td>Linuxbrew</td><td><code>/home/linuxbrew/.linuxbrew/Cellar/.../bin</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放在 def install 方法之前</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> <span class="comment"># 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; :build   <span class="comment"># 只在构建时需要</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; :<span class="built_in">test</span>    <span class="comment"># 测试时需要</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; [:build, :<span class="built_in">test</span>] <span class="comment"># 构建和测试都需要</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境约束</span></span><br><span class="line">depends_on macos: :sonoma          <span class="comment"># 仅 macOS Sonoma</span></span><br><span class="line">depends_on <span class="built_in">arch</span>: :x86_64           <span class="comment"># 仅 x86_64</span></span><br><span class="line">depends_on xcode: [<span class="string">&quot;9.3&quot;</span>, :build]  <span class="comment"># 仅当 Xcode≥9.3 且用于 build</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖第三方库中的命令要用完整包名</span></span><br><span class="line">depends_on <span class="string">&quot;hanqunfeng/color_echo/color_echo&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><ul class="lvl-0"><li class="lvl-2"><p>关于更多的 Formula 文件模板，可以参考：<a href="https://docs.brew.sh/Formula-Cookbook">https://docs.brew.sh/Formula-Cookbook</a></p></li><li class="lvl-2"><p>同时也可以通过 <code>brew edit xxx</code> 命令查看该 Formula 文件的内容进行学习</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

--&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://brew.sh&quot;&gt;brew&lt;/a&gt;是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如&lt;code&gt;git&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍如何在macos下创建自己的 Formula&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;关于 brew 的安装及使用可以参考 &lt;a href=&quot;/2024/11/28/brew/&quot; title=&quot;MacOS软件包管理器--brew&quot;&gt;MacOS软件包管理器--brew&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="macos" scheme="https://blog.hanqunfeng.com/categories/macos/"/>
    
    
    <category term="macos" scheme="https://blog.hanqunfeng.com/tags/macos/"/>
    
    <category term="brew" scheme="https://blog.hanqunfeng.com/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令--lsof</title>
    <link href="https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/"/>
    <id>https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/</id>
    <published>2025-11-26T13:30:05.000Z</published>
    <updated>2025-11-27T02:50:52.836Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote % --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 lsof 命令的使用方法</p></li><li class="lvl-2"><p>本文基于CentOS8。</p></li></ul><span id="more"></span><h2 id="lsof-是什么？">lsof 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>lsof = list open files</p></li><li class="lvl-2"><p>它用来查看：</p><ul class="lvl-2"><li class="lvl-4">当前系统中所有进程打开的文件</li><li class="lvl-4">包含普通文件、目录、socket、管道、网络连接、设备等</li></ul></li><li class="lvl-2"><p>在 Linux 中：“一切皆文件”</p></li><li class="lvl-2"><p>所以你可以用 lsof 查看：</p><ul class="lvl-2"><li class="lvl-4">谁在占用你的端口？</li><li class="lvl-4">哪个进程正在读/写某个文件？</li><li class="lvl-4">为什么文件删除了却还占磁盘？</li><li class="lvl-4">哪个文件被锁住？</li><li class="lvl-4">哪些程序在访问某个目录？</li></ul></li><li class="lvl-2"><p>CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lsof -y</span><br></pre></td></tr></table></figure><h2 id="lsof-的基本用法">lsof 的基本用法</h2><h3 id="查看被删除但仍被占用的文件">查看被删除但仍被占用的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了<code>rm</code>命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。</p></li><li class="lvl-2"><p>文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 中看不到</span><br><span class="line"><span class="built_in">du</span> 不会统计空间</span><br><span class="line">只有 lsof 能看到，这是典型的 “deleted but still open” 状态。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时可以通过如下命令查询哪些被删除的文件还被占用：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 link count 小于 1 的（deleted）文件</span></span><br><span class="line">lsof +L1</span><br><span class="line"><span class="comment"># 列出所有被删除的文件</span></span><br><span class="line">lsof | grep deleted</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果查询到这种文件，则需要停止进程，才能真正删除文件。</p></li></ul><div class="tips"><p><em><strong>记一次线上服务器磁盘空间告警问题排查</strong></em></p><ul class="lvl-1"><li class="lvl-2">监控系统告警磁盘空间小于15%，通过如下命令查看确实如此</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -hT</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Filesystem Type  Size Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda1 ext4  7.9G 3.3G 4.6G  42%  /</span><br><span class="line">tmpfs      tmpfs 2.0G 0    2.0G  0%   /dev/shm</span><br><span class="line">/dev/xvdf1 ext4  99G  80G  15G   85%  /usr/local/boss/logs</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">du</span> -sh /usr/local/boss/logs</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">2.3G    /usr/local/boss/logs</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsof +L1</span><br><span class="line"><span class="comment">## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄</span></span><br><span class="line">COMMAND    PID      USER    FD      TYPE    DEVICE  SIZE/OFF      NLINK   NODE    NAME</span><br><span class="line">java       1836     boss    1w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br><span class="line">java       1836     boss    2w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。</li></ul></div><h3 id="查端口被哪个进程占用">查端口被哪个进程占用</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出指定端口对应的进程</span></span><br><span class="line">lsof -i tcp:8080</span><br><span class="line"><span class="comment"># 协议可以省略</span></span><br><span class="line">lsof -i :8080</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:webcache (LISTEN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将服务名称替换为端口</span></span><br><span class="line">lsof -i :8080 -P</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:8080 (LISTEN)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看某个进程打开的所有文件">查看某个进程打开的所有文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE  SIZE/OFF       NODE NAME</span><br><span class="line">java    18548 boss  cwd    DIR      202,1      4096      35377 /home/boss</span><br><span class="line">java    18548 boss  rtd    DIR      202,1      4096          2 /</span><br><span class="line">java    18548 boss  mem    REG      202,1 106065056      60671 /usr/lib/locale/locale-archive</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>能看到这个进程：</p><ul class="lvl-2"><li class="lvl-4">打开的日志文件</li><li class="lvl-4">使用的 jar 文件</li><li class="lvl-4">使用的 socket</li><li class="lvl-4">使用的 config 文件</li></ul></li><li class="lvl-2"><p>输出结果字段说明</p></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>COMMAND</td><td>程序名（java）</td></tr><tr><td>PID</td><td>进程号（18548）</td></tr><tr><td>USER</td><td>运行用户（boss）</td></tr><tr><td>FD</td><td>文件描述符</td></tr><tr><td>TYPE</td><td>文件类型</td></tr><tr><td>DEVICE</td><td>所在磁盘分区 ID</td></tr><tr><td>SIZE/OFF</td><td>文件大小（字节）</td></tr><tr><td>NODE</td><td>inode 编号</td></tr><tr><td>NAME</td><td>文件名（或网络连接信息）</td></tr></tbody></table><h3 id="查看指定用户占用的文件">查看指定用户占用的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出用户 boss 所有进程打开的文件</span></span><br><span class="line">lsof -u &lt;USER&gt;</span><br></pre></td></tr></table></figure><h3 id="查看指定程序-COMMAND-打开的文件">查看指定程序(COMMAND)打开的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="查某个目录或文件正在被哪些进程占用">查某个目录或文件正在被哪些进程占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目录 +D</span></span><br><span class="line"><span class="comment"># 能显示所有正在访问该目录中文件的进程</span></span><br><span class="line">lsof +D /home/boss/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件</span></span><br><span class="line">lsof /home/boss/logs/access.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只列出 nginx 用户占用的文件目录中的哪些文件</span></span><br><span class="line"><span class="comment"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class="line">lsof -a -u nginx +D /usr/local/nginx/logs</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看网络连接">查看网络连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br><span class="line"><span class="comment"># 过滤协议</span></span><br><span class="line">lsof -i tcp</span><br><span class="line">lsof -i udp</span><br><span class="line"><span class="comment"># 过滤状态</span></span><br><span class="line">lsof -i -s tcp:listen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有监听端口，</span></span><br><span class="line"><span class="comment"># -i: 显示网络相关的文件</span></span><br><span class="line"><span class="comment"># -P: 显示端口(不加-P则显示的是服务名)</span></span><br><span class="line"><span class="comment"># -n: 不将 IP 映射成主机名（禁用 DNS 查询）</span></span><br><span class="line"><span class="comment"># -s: 过滤显示连接状态</span></span><br><span class="line">lsof -i -P -n -s tcp:listen</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">mongod     1782     root    5u  IPv4       8697      0t0  TCP *:27017 (LISTEN)</span><br><span class="line">java       1808     boss   36u  IPv6       9221      0t0  TCP *:8082 (LISTEN)</span><br><span class="line">java       1808     boss   39u  IPv6       9230      0t0  TCP 127.0.0.1:7093 (LISTEN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出用户 boss 的网络连接</span></span><br><span class="line"><span class="comment"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class="line">lsof -a -u boss -i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用参数详解">常用参数详解</h2><table><thead><tr><th>参数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>-i</code></td><td>查看网络相关文件/端口</td><td><code>lsof -i</code></td></tr><tr><td><code>-i :端口</code></td><td>查看指定端口</td><td><code>lsof -i :8080</code></td></tr><tr><td><code>-p PID</code></td><td>查看某个进程所有打开文件</td><td><code>lsof -p 1836</code></td></tr><tr><td><code>-u 用户名</code></td><td>查看某个用户进程的打开文件</td><td><code>lsof -u nginx</code></td></tr><tr><td><code>-c 进程名关键字</code></td><td>查看某个进程名相关的文件</td><td><code>lsof -c java</code></td></tr><tr><td><code>+D 目录</code></td><td>查看目录中所有被访问的文件</td><td><code>lsof +D /usr/local/netqin/boss/netqin/logs</code></td></tr><tr><td><code>+L1</code></td><td>查找已删除但仍被打开的文件</td><td><code>lsof +L1</code>（=查找“(deleted)”占盘问题）</td></tr><tr><td><code>-d FD</code></td><td>查看指定文件描述符</td><td><code>lsof -d 1 -p 1836</code>（看进程 stdout）</td></tr><tr><td><code>-n</code></td><td>不做 DNS 解析，提高速度</td><td><code>lsof -i -n</code></td></tr><tr><td><code>-P</code></td><td>显示端口号（不解析为服务名）</td><td><code>lsof -i -P</code></td></tr><tr><td><code>-s</code></td><td>按连接状态过滤（TCP/UDP）</td><td><code>lsof -i -sTCP:LISTEN</code></td></tr><tr><td><code>-r</code></td><td>持续输出（实时监控）</td><td><code>lsof -i -r 1</code>（每秒刷新网络连接）</td></tr><tr><td><code>-a</code></td><td>逻辑 AND，不加 -a 都是 逻辑 OR</td><td><code>lsof -u boss -i</code>（列出用户 boss 的网络连接）</td></tr></tbody></table><h2 id="lsof-文件-FD-字段详细解释">lsof 文件 FD 字段详细解释</h2><ul class="lvl-0"><li class="lvl-2"><p>FD（文件描述符）格式总规则：数字 + 标志位</p></li><li class="lvl-2"><p>lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。</p></li><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10r   → FD=10，<span class="built_in">read</span> only（只读）</span><br><span class="line">1w    → FD=1，write only（只写）</span><br><span class="line">36u   → FD=36，<span class="built_in">read</span>/write（可读可写）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>解释</p></li></ul><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><strong>数字（0、1、2、3、10、36…）</strong></td><td>文件描述符编号</td></tr><tr><td><strong>字母（r / w / u）</strong></td><td>访问模式：读/写/读写</td></tr></tbody></table><table><thead><tr><th>FD 编号</th><th>标准含义</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>stdin（标准输入）</td></tr><tr><td><strong>1</strong></td><td>stdout（标准输出）</td></tr><tr><td><strong>2</strong></td><td>stderr（标准错误输出）</td></tr><tr><td><strong>3</strong> 及以上</td><td>进程打开的普通文件、日志、socket、管道等</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>特殊 FD 类型（没有数字）</p></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>cwd</code></td><td>当前工作目录，说明进程在这个目录下运行</td></tr><tr><td><code>rtd</code></td><td>进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs</td></tr><tr><td><code>txt</code></td><td>可执行文件本体</td></tr><tr><td><code>mem</code></td><td>内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件</td></tr></tbody></table><h2 id="lsof-文件-TYPE-字段详细解释">lsof 文件 TYPE 字段详细解释</h2><table><thead><tr><th>文件类型</th><th>全称</th><th>含义</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>REG</strong></td><td>Regular file</td><td>普通文件</td><td>日志、配置、可执行程序等</td></tr><tr><td><strong>DIR</strong></td><td>Directory</td><td>目录</td><td>进程访问的目录，例如当前工作目录</td></tr><tr><td><strong>CHR</strong></td><td>Character special file</td><td>字符设备文件</td><td><code>/dev/null</code>、<code>/dev/tty</code>、串口、键盘等</td></tr><tr><td><strong>BLK</strong></td><td>Block special file</td><td>块设备文件</td><td><code>/dev/sda</code>、硬盘、分区等</td></tr><tr><td><strong>FIFO</strong></td><td>Named pipe</td><td>命名管道</td><td>Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信</td></tr><tr><td><strong>sock</strong></td><td>Socket</td><td>套接字（Unix 域 socket）</td><td><code>/var/run/docker.sock</code>、MySQL UNix socket</td></tr><tr><td><strong>IPv4</strong></td><td>IPv4 socket</td><td>IPv4 网络连接/监听</td><td><code>TCP *:80</code>、<code>UDP 127.0.0.1:53</code></td></tr><tr><td><strong>IPv6</strong></td><td>IPv6 socket</td><td>IPv6 网络连接/监听</td><td><code>TCP [::]:22</code></td></tr><tr><td><strong>unix</strong></td><td>Unix domain socket</td><td>本地进程通信</td><td><code>/run/systemd/journal/stdout</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 lsof 命令的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文基于CentOS8。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    <category term="linux常用命令" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux常用命令" scheme="https://blog.hanqunfeng.com/tags/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>什么是 UTC？一篇人人都能看懂的科普文章</title>
    <link href="https://blog.hanqunfeng.com/2025/11/20/utc/"/>
    <id>https://blog.hanqunfeng.com/2025/11/20/utc/</id>
    <published>2025-11-20T14:30:05.000Z</published>
    <updated>2025-11-20T08:36:36.524Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。</p></li></ul><span id="more"></span><h2 id="一、为什么世界需要统一时间？">一、为什么世界需要统一时间？</h2><p>早期，每个城市甚至每个乡镇都根据 <strong>太阳位置</strong>确定时间：</p><ul class="lvl-0"><li class="lvl-2"><p>太阳在头顶就是 12 点</p></li><li class="lvl-2"><p>不同地方经度不同，每地时间都不同</p></li></ul><p>这种方法在本地没问题，但到了 <strong>跨区域铁路、通信、航海、航空、互联网时代</strong>，问题巨大：</p><blockquote><p>两地时间不统一，火车、舰队、订单、通信都没法同步记录。</p></blockquote><p>因此世界需要：</p><ul class="lvl-0"><li class="lvl-2"><p>一个 <strong>全球统一、精确的标准时间</strong></p></li><li class="lvl-2"><p>所有人、所有系统都能对齐使用</p></li></ul><p>UTC 就是在这个背景下诞生的。</p><hr><h2 id="二、UTC-是什么？">二、UTC 是什么？</h2><p>UTC 的全称：</p><blockquote><p><strong>Coordinated Universal Time（协调世界时）</strong></p></blockquote><p>它是当今全球使用的 <strong>标准时间系统</strong>。</p><p>它的主要特点：</p><ul class="lvl-0"><li class="lvl-2"><p>不是某个国家的时间</p></li><li class="lvl-2"><p>是国际组织共同维护</p></li><li class="lvl-2"><p>全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准</p></li></ul><p>一句话：</p><blockquote><p><strong>UTC 是现代世界共同使用的“世界时间”。</strong></p></blockquote><hr><h2 id="三、UTC-和-GMT-的关系">三、UTC 和 GMT 的关系</h2><p>很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。</p><table><thead><tr><th>项目</th><th>GMT</th><th>UTC</th></tr></thead><tbody><tr><td>出现年代</td><td>19 世纪</td><td>1972 年</td></tr><tr><td>基准</td><td>地球自转（天文时间）</td><td>原子钟（更精确）</td></tr><tr><td>是否仍是标准</td><td>已被替代</td><td>当前唯一标准</td></tr></tbody></table><p>但在日常使用中：</p><blockquote><p><strong>UTC ≈ GMT（同为零时区）</strong></p></blockquote><p>所以：</p><ul class="lvl-0"><li class="lvl-2"><p>英国冬季使用 GMT（UTC+0）</p></li><li class="lvl-2"><p>技术系统使用 UTC（UTC+0）</p></li></ul><hr><h2 id="四、UTC-是如何确定的？">四、UTC 是如何确定的？</h2><p>UTC 并不是按太阳走，而是：</p><ul class="lvl-0"><li class="lvl-2"><p>由全世界 <strong>原子钟网络统一生成</strong></p></li><li class="lvl-2"><p>每秒误差小于 <strong>十亿分之一秒</strong></p></li><li class="lvl-2"><p>然后根据地球自转误差偶尔加“闰秒”</p></li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-12-31 23:59:60 UTC   ← 曾经加过闰秒</span><br></pre></td></tr></table></figure><p>这样：</p><ul class="lvl-0"><li class="lvl-2"><p>保证时间极其准确</p></li><li class="lvl-2"><p>又不会与地球真实昼夜偏离太多</p></li></ul><hr><h2 id="五、UTC-与时区">五、UTC 与时区</h2><p>UTC 是 0 时区。</p><p>所有时区都是 <strong>在 UTC 基础上加减偏移</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>北京时间：UTC + 8</p></li><li class="lvl-2"><p>纽约时间：UTC – 5（冬季）或 –4（夏令时）</p></li><li class="lvl-2"><p>日本时间：UTC + 9</p></li></ul><p>所以你常看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC+8 或 UTC-5</span><br></pre></td></tr></table></figure><p>表示该地区比 UTC 早或晚多少小时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC+8  &gt;  UTC+0  &gt;  UTC−5</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>换成生活语言：</p><ul class="lvl-2"><li class="lvl-4">UTC+8（例如北京时间）比 UTC 早 8 小时</li><li class="lvl-4">UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时</li></ul></li><li class="lvl-2"><p>举例：</p><ul class="lvl-2"><li class="lvl-4">UTC(即UTC+0) 时间是 12:00</li><li class="lvl-4">UTC+8 = 20:00（已经晚上）</li><li class="lvl-4">UTC−5 = 07:00（还在早上）</li></ul></li></ul><hr><h2 id="六、UTC-在计算机世界的重要性">六、UTC 在计算机世界的重要性</h2><p>几乎所有 IT 系统都推荐：</p><blockquote><p><strong>存储用 UTC，展示给用户再转换成当地时区。</strong></p></blockquote><p>原因很简单：</p><ul class="lvl-0"><li class="lvl-2"><p>全球一致，不会混乱</p></li><li class="lvl-2"><p>不受时区或夏令时影响</p></li><li class="lvl-2"><p>跨国系统日志可对齐分析</p></li></ul><p>你在日志里经常见到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025-11-20T08:30:00Z</span><br></pre></td></tr></table></figure><p>结尾的 <code>Z</code> 就表示：</p><blockquote><p><strong>这是 UTC 时间</strong></p></blockquote><hr><h2 id="七、UTC、GMT、CST-总结对比">七、UTC、GMT、CST 总结对比</h2><table><thead><tr><th>名称</th><th>全称</th><th>现在地位</th><th>是否标准</th></tr></thead><tbody><tr><td>UTC</td><td>Coordinated Universal Time</td><td>全球标准</td><td>✔</td></tr><tr><td>GMT</td><td>Greenwich Mean Time</td><td>被 UTC 替代</td><td>✖（历史含义）</td></tr><tr><td>CST</td><td>China Standard Time（中国）或 Central Standard Time（美国）</td><td>本地时区</td><td>不是世界统一基准</td></tr></tbody></table><p>注意：</p><blockquote><p>“CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。</p></blockquote><hr><h2 id="八、一句话总结">八、一句话总结</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>UTC 是现代全球统一的标准时间</strong></p></li><li class="lvl-2"><p><strong>所有时区都是相对于 UTC 偏移</strong></p></li><li class="lvl-2"><p><strong>计算机领域普遍使用 UTC 存储时间</strong></p></li><li class="lvl-2"><p><strong>GMT 是 UTC 的历史前身</strong></p></li><li class="lvl-2"><p><strong>北京时间 = UTC + 8</strong></p></li></ul><p>只要理解这几点，你已经掌握了世界时间体系的核心。</p>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="UTC" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/UTC/"/>
    
    
    <category term="UTC" scheme="https://blog.hanqunfeng.com/tags/UTC/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ ACL 2.0</title>
    <link href="https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/"/>
    <id>https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/</id>
    <published>2025-10-31T13:40:05.000Z</published>
    <updated>2025-10-31T15:11:43.114Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li><li class="lvl-2"><p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p></li></ul><span id="more"></span><h2 id="ACL-2-0-简介">ACL 2.0 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 <a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href="https://rocketmq.apache.org/zh/docs/bestPractice/03access">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p></li><li class="lvl-2"><p>在阿里云上找到一篇参考资料：<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a></p></li></ul><h2 id="配置步骤">配置步骤</h2><ul class="lvl-0"><li class="lvl-2"><p>本文在 <a href="/2025/10/23/rocketmq-01-install/" title="RocketMQ 的安装及使用">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p></li><li class="lvl-2"><p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker.conf</span></span><br><span class="line"><span class="comment"># 认证配置</span></span><br><span class="line">authenticationEnabled = <span class="literal">true</span></span><br><span class="line">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class="line">initAuthenticationUser = &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">innerClientAuthenticationCredentials = &#123;<span class="string">&quot;accessKey&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;secretKey&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class="line"><span class="comment"># 授权配置</span></span><br><span class="line">authorizationEnabled = <span class="literal">true</span></span><br><span class="line">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class="line">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数定义</th><th style="text-align:left">参数名称</th><th style="text-align:left">参数描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>authenticationEnabled</strong></td><td style="text-align:left">是否打开认证开关</td><td style="text-align:left">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td></tr><tr><td style="text-align:left"><strong>authenticationProvider</strong></td><td style="text-align:left">认证方式提供者</td><td style="text-align:left">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td></tr><tr><td style="text-align:left"><strong>initAuthenticationUser</strong></td><td style="text-align:left">系统初始化用户</td><td style="text-align:left">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>innerClientAuthenticationCredentials</strong></td><td style="text-align:left">组件间认证用户</td><td style="text-align:left">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>authenticationMetadataProvider</strong></td><td style="text-align:left">认证元数据提供者</td><td style="text-align:left">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td></tr><tr><td style="text-align:left"><strong>authenticationStrategy</strong></td><td style="text-align:left">认证策略</td><td style="text-align:left">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>重启启动所有 Broker</p></li></ul><h2 id="命令行管理用户">命令行管理用户</h2><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="用户管理">用户管理</h3><table><thead><tr><th style="text-align:left">接口定义</th><th style="text-align:left">接口名称</th><th style="text-align:left">接口参数</th></tr></thead><tbody><tr><td style="text-align:left"><strong>createUser</strong></td><td style="text-align:left">创建用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>updateUser</strong></td><td style="text-align:left">更新用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>deleteUser</strong></td><td style="text-align:left">删除用户</td><td style="text-align:left">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>getUser</strong></td><td style="text-align:left">查询用户详情</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>listUser</strong></td><td style="text-align:left">查询用户列表</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class="line"><span class="comment"># 创建用户，指定用户类型</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class="line"><span class="comment"># 更新用户</span></span><br><span class="line">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户详情</span></span><br><span class="line">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户列表</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询用户列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure><h3 id="权限管理">权限管理</h3><ul class="lvl-0"><li class="lvl-2"><p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p></li></ul><table><thead><tr><th style="text-align:left">命令名称</th><th style="text-align:left">操作定义</th><th style="text-align:left">命令参数及解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>createAcl</code></strong></td><td style="text-align:left">创建授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td></tr><tr><td style="text-align:left"><strong><code>updateAcl</code></strong></td><td style="text-align:left">更新授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td></tr><tr><td style="text-align:left"><strong><code>deleteAcl</code></strong></td><td style="text-align:left">删除授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td></tr><tr><td style="text-align:left"><strong><code>listAcl</code></strong></td><td style="text-align:left">查询授权列表</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td></tr><tr><td style="text-align:left"><strong><code>getAcl</code></strong></td><td style="text-align:left">查询授权详情</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建授权</span></span><br><span class="line">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class="line"><span class="comment"># 更新授权</span></span><br><span class="line">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class="line"><span class="comment"># 删除授权</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class="line"><span class="comment"># 删除授权，指定资源</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权列表</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询授权列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权详情</span></span><br><span class="line">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure><h2 id="Dashboard-配置">Dashboard 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h2 id="Proxy-配置">Proxy 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href="https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href="https://github.com/apache/rocketmq/tree/develop/example">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p></li><li class="lvl-2"><p>按照这篇文章<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;authenticationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;innerClientAuthenticationCredentials&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;accessKey\&quot;:\&quot;mqadmin\&quot;, \&quot;secretKey\&quot;:\&quot;1234567\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>异常信息如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.zcw159357.com/article/1/2025-03-15-0048.html">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enableAclRpcHookForClusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p></li><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.csdn.net/icebamboo2015/article/details/152118732">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p></li></ul><h2 id="后记">后记</h2><ul class="lvl-0"><li class="lvl-2"><p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ ACL 2.0 的使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
</feed>
