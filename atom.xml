<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-12-16T08:58:27.556Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 命令及数据类型 -- ZSet</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/</id>
    <published>2025-12-16T13:40:05.000Z</published>
    <updated>2025-12-16T08:58:27.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis ZSet 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="ZSet-数据类型">ZSet 数据类型</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; &#123; member -&gt; score &#125;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">member：唯一，不可重复（String，二进制安全）</span><br><span class="line">score：double 类型，用于排序</span><br><span class="line">集合按 score 从小到大 排序</span><br><span class="line">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ZSet = Set（去重） + 排序能力</p></li><li class="lvl-2"><p>ZSet 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素唯一</span><br><span class="line">天然有序</span><br><span class="line">支持范围查询</span><br><span class="line">支持排名（rank）</span><br><span class="line">支持按 score 增量更新</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p></li><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZSet 适合 排序 + 查询</span><br><span class="line">score 设计要稳定、可扩展</span><br><span class="line">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class="line">大 ZSet 避免全量遍历</span><br><span class="line">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li><li class="lvl-2"><p>基础写入 / 删除 / 计数</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>添加元素（含 score）</td><td><code>Boolean add(K key, V value, double score)</code></td><td><code>ZADD key score member</code></td><td>新增返回 <code>true</code></td></tr><tr><td>添加元素（仅不存在时）</td><td><code>Boolean addIfAbsent(K key, V value, double score)</code></td><td><code>ZADD key NX score member</code></td><td>Redis ≥ 3.0</td></tr><tr><td>批量添加</td><td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key score member [score member ...]</code></td><td>返回新增数量</td></tr><tr><td>批量添加（仅不存在）</td><td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key NX ...</code></td><td>—</td></tr><tr><td>删除成员</td><td><code>Long remove(K key, Object... values)</code></td><td><code>ZREM key member [member ...]</code></td><td>返回删除数量</td></tr><tr><td>递增 score</td><td><code>Double incrementScore(K key, V value, double delta)</code></td><td><code>ZINCRBY key delta member</code></td><td>—</td></tr><tr><td>获取集合大小</td><td><code>Long size(K key)</code></td><td><code>ZCARD key</code></td><td>—</td></tr><tr><td>获取集合大小（同义）</td><td><code>Long zCard(K key)</code></td><td><code>ZCARD key</code></td><td>API 别名</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>随机访问</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令</th><th>命令备注</th></tr></thead><tbody><tr><td>随机获取成员</td><td><code>V randomMember(K key)</code></td><td><code>ZRANDMEMBER key</code></td><td>不返回 score</td></tr><tr><td>随机获取不重复成员</td><td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr><tr><td>随机获取成员及 score</td><td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td><td><code>ZRANDMEMBER key WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机获取不重复成员及 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key count WITHSCORES</code></td><td>—</td></tr><tr><td>随机获取可重复成员及 score</td><td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key -count WITHSCORES</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>排名 / score 查询</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取正序排名</td><td><code>Long rank(K key, Object o)</code></td><td><code>ZRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取倒序排名</td><td><code>Long reverseRank(K key, Object o)</code></td><td><code>ZREVRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取 score</td><td><code>Double score(K key, Object o)</code></td><td><code>ZSCORE key member</code></td><td>—</td></tr><tr><td>批量获取 score</td><td><code>List&lt;Double&gt; score(K key, Object... o)</code></td><td><code>ZMScore key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>score 区间计数</td><td><code>Long count(K key, double min, double max)</code></td><td><code>ZCOUNT key min max</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>区间查询（rank / score）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>按 rank 查询</td><td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td><td><code>ZRANGE key start end</code></td><td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td></tr><tr><td>按 rank 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td><td><code>ZRANGE key start end WITHSCORES</code></td><td>—</td></tr><tr><td>按 score 查询</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max</code></td><td>—</td></tr><tr><td>按 score 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td><td>—</td></tr><tr><td>score 分页</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td><td>—</td></tr><tr><td>score 分页（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td><td>按 score 升序分页，返回 member + score</td></tr><tr><td>倒序 rank 查询</td><td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end</code></td><td>按 rank 倒序（高 → 低）</td></tr><tr><td>倒序 rank（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end WITHSCORES</code></td><td>倒序 rank，返回 score</td></tr><tr><td>倒序 score 查询</td><td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min</code></td><td>注意：<strong>max 在前，min 在后</strong></td></tr><tr><td>倒序 score（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td><td>倒序 score，返回 score</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>弹出元素（队列 / TopN 场景）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td><td><code>ZPOPMIN key</code></td><td>—</td></tr><tr><td>批量弹出最小 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td><td><code>ZPOPMIN key count</code></td><td>—</td></tr><tr><td>阻塞弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td><td><code>BZPOPMIN key timeout</code></td><td>—</td></tr><tr><td>弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td><td><code>ZPOPMAX key</code></td><td>—</td></tr><tr><td>批量弹出最大 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td><td><code>ZPOPMAX key count</code></td><td>—</td></tr><tr><td>阻塞弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td><td><code>BZPOPMAX key timeout</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>区间删除</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令（完整）</th></tr></thead><tbody><tr><td>按 rank 删除</td><td><code>Long removeRange(K key, long start, long end)</code></td><td><code>ZREMRANGEBYRANK key start end</code></td></tr><tr><td>按 score 删除</td><td><code>Long removeRangeByScore(K key, double min, double max)</code></td><td><code>ZREMRANGEBYSCORE key min max</code></td></tr><tr><td>按 lex 删除</td><td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td><td><code>ZREMRANGEBYLEX key min max</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>集合运算（ZSet 特有）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>差集</td><td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集</td><td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集</td><td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZINTERSTORE destination numkeys key [key ...]</code></td><td></td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td><td></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Lex（字典序，仅 score 相同）</p></li></ul><blockquote><p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>如果 score 不同，Redis 文档明确说明：结果不可预测</p></blockquote><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>按 lex 查询</td><td><code>Set&lt;V&gt; rangeByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td><td>score 必须相同</td></tr><tr><td>倒序 lex 查询</td><td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td><td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td><td>—</td></tr><tr><td>lex 范围存储</td><td><code>Long rangeAndStoreByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td><td>Spring 封装</td></tr><tr><td>score 范围存储</td><td><code>Long rangeAndStoreByScore(...)</code></td><td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td><td>Spring 封装</td></tr></tbody></table><blockquote><p>Lex 范围写法规则</p></blockquote><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[a</code></td><td>≥ a（包含）</td></tr><tr><td><code>(a</code></td><td>&gt; a（不包含）</td></tr><tr><td><code>[z</code></td><td>≤ z</td></tr><tr><td><code>+</code></td><td>正无穷</td></tr><tr><td><code>-</code></td><td>负无穷</td></tr></tbody></table><blockquote><p>示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a ≤ member &lt; d</span></span><br><span class="line">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>遍历</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForZSet().xxx()</code></th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>游标扫描</td><td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td><td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>推荐替代全量查询</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis ZSet 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Set</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/</id>
    <published>2025-12-16T13:38:05.000Z</published>
    <updated>2025-12-16T08:58:27.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Set 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Set-数据类型">Set 数据类型</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 是一个无序、不重复元素集合，本质上是：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Set&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素唯一（自动去重）</span><br><span class="line">无顺序（不保证插入顺序）</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Set 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动去重</span><br><span class="line">高效成员判断</span><br><span class="line">支持集合运算</span><br><span class="line">操作原子性强</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set 适合 成员资格判断</span><br><span class="line">始终控制成员规模</span><br><span class="line">大 Set 遍历使用 SSCAN</span><br><span class="line">集合运算放在离线或低频场景</span><br><span class="line">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForSet().xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>向集合添加元素</td><td><code>Long add(K key, V... values)</code></td><td><code>SADD key member [member ...]</code></td><td>返回新增成员数量</td></tr><tr><td>从集合移除元素</td><td><code>Long remove(K key, Object... values)</code></td><td><code>SREM key member [member ...]</code></td><td>返回移除成员数量</td></tr><tr><td>随机弹出一个元素</td><td><code>V pop(K key)</code></td><td><code>SPOP key</code></td><td>随机且删除</td></tr><tr><td>随机弹出多个元素</td><td><code>List&lt;V&gt; pop(K key, long count)</code></td><td><code>SPOP key count</code></td><td>Redis ≥ 3.2</td></tr><tr><td>将成员移动到其他集合</td><td><code>Boolean move(K key, V value, K destKey)</code></td><td><code>SMOVE source dest member</code></td><td>原子操作</td></tr><tr><td>获取集合大小</td><td><code>Long size(K key)</code></td><td><code>SCARD key</code></td><td>—</td></tr><tr><td>判断是否是成员</td><td><code>Boolean isMember(K key, Object o)</code></td><td><code>SISMEMBER key member</code></td><td>—</td></tr><tr><td>批量判断成员是否存在</td><td><code>Map&lt;Object, Boolean&gt; isMember(K key, Object... objects)</code></td><td><code>SMISMEMBER key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>计算交集</td><td><code>Set&lt;V&gt; intersect(K key, K otherKey)</code></td><td><code>SINTER key key</code></td><td>O(N × M)</td></tr><tr><td>计算交集</td><td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>计算交集</td><td><code>Set&lt;V&gt; intersect(Collection&lt;K&gt; keys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(K key, K otherKey, K destKey)</code></td><td><code>SINTERSTORE dest key key</code></td><td>返回结果数量</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>Set&lt;V&gt; union(K key, K otherKey)</code></td><td><code>SUNION key key</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>Set&lt;V&gt; union(Collection&lt;K&gt; keys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(K key, K otherKey, K destKey)</code></td><td><code>SUNIONSTORE dest key key</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>计算差集</td><td><code>Set&lt;V&gt; difference(K key, K otherKey)</code></td><td><code>SDIFF key key</code></td><td>key 顺序影响结果</td></tr><tr><td>计算差集</td><td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>计算差集</td><td><code>Set&lt;V&gt; difference(Collection&lt;K&gt; keys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(K key, K otherKey, K destKey)</code></td><td><code>SDIFFSTORE dest key key</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>获取所有成员</td><td><code>Set&lt;V&gt; members(K key)</code></td><td><code>SMEMBERS key</code></td><td>大集合慎用，推荐 <code>SSCAN key cursor [MATCH] [COUNT]</code></td></tr><tr><td>随机获取一个成员（不删除）</td><td><code>V randomMember(K key)</code></td><td><code>SRANDMEMBER key</code></td><td>—</td></tr><tr><td>随机获取不重复成员</td><td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr><tr><td>游标扫描成员</td><td><code>Cursor&lt;V&gt; scan(K key, ScanOptions options)</code></td><td><code>SSCAN key cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>SMEMBERS</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Set 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- List</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/</id>
    <published>2025-12-16T13:35:05.000Z</published>
    <updated>2025-12-16T08:58:15.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis List 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="List-数据类型">List 数据类型</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis List 是一个有序字符串列表，本质上是:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; List&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素按插入顺序排列</span><br><span class="line">允许重复元素</span><br><span class="line">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>List 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有序</span><br><span class="line">可重复</span><br><span class="line">双端操作（Deque）</span><br><span class="line">支持阻塞读</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List 只用于 顺序消费</span><br><span class="line">始终限制 List 长度（LTRIM）</span><br><span class="line">避免中间插入、删除</span><br><span class="line">大 List 删除使用 UNLINK</span><br><span class="line">高可靠消息不要用 List</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>redisTemplate.opsForList().xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>获取指定区间元素</td><td><code>List&lt;V&gt; range(K key, long start, long end)</code></td><td><code>LRANGE key start end</code></td><td>end = -1 表示到末尾</td></tr><tr><td>裁剪 list，仅保留指定区间</td><td><code>void trim(K key, long start, long end)</code></td><td><code>LTRIM key start end</code></td><td>原地修改</td></tr><tr><td>获取 list 长度</td><td><code>Long size(K key)</code></td><td><code>LLEN key</code></td><td>—</td></tr><tr><td>左侧插入一个元素</td><td><code>Long leftPush(K key, V value)</code></td><td><code>LPUSH key value</code></td><td>返回插入后长度</td></tr><tr><td>左侧批量插入</td><td><code>Long leftPushAll(K key, V... values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>依次从左插入</td></tr><tr><td>左侧批量插入</td><td><code>Long leftPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时左侧插入</td><td><code>Long leftPushIfPresent(K key, V value)</code></td><td><code>LPUSHX key value</code></td><td>key 不存在不执行</td></tr><tr><td>在 pivot 左侧插入</td><td><code>Long leftPush(K key, V pivot, V value)</code></td><td><code>LINSERT key BEFORE pivot value</code></td><td>pivot：List 中某一个已存在的元素值 <br>pivot 不存在返回 -1</td></tr><tr><td>右侧插入一个元素</td><td><code>Long rightPush(K key, V value)</code></td><td><code>RPUSH key value</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>Long rightPushAll(K key, V... values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>Long rightPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时右侧插入</td><td><code>Long rightPushIfPresent(K key, V value)</code></td><td><code>RPUSHX key value</code></td><td>—</td></tr><tr><td>在 pivot 右侧插入</td><td><code>Long rightPush(K key, V pivot, V value)</code></td><td><code>LINSERT key AFTER pivot value</code></td><td>pivot 不存在返回 -1</td></tr><tr><td>原子移动元素（非阻塞）</td><td><code>V move(sourceKey, from, destinationKey, to)</code></td><td><code>LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT</code></td><td>Redis ≥ 6.2<br>LMOVE 本质等价于以下两个操作的原子组合:<br>1. 从 source 的一端 POP 一个元素<br>2. 将该元素 PUSH 到 destination 的一端<br>参数说明：  <br> sourceKey:源 List（从这里取一个元素）<br>destinationKey:目标 List（往这里放一个元素）<br>第一个 LEFT/RIGHT:从 sourceKey 的哪一端弹出元素<br>第二个 LEFT/RIGHT:从 destinationKey 的哪一端插入元素</td></tr><tr><td>原子移动元素（阻塞）</td><td><code>V move(sourceKey, from, destinationKey, to, timeout)</code></td><td><code>BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout</code></td><td>Redis ≥ 6.2<br>timeout: 当 sourceKey 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。<br>timeout = 0：无限期阻塞，直到有数据可用或连接断开</td></tr><tr><td>设置指定索引的值</td><td><code>void set(K key, long index, V value)</code></td><td><code>LSET key index value</code></td><td>index 越界报错</td></tr><tr><td>删除指定值</td><td><code>Long remove(K key, long count, Object value)</code></td><td><code>LREM key count value</code></td><td>count &gt;0 从左，&lt;0 从右</td></tr><tr><td>获取第一个元素</td><td><code>V getFirst(K key)</code></td><td><code>LINDEX key 0</code></td><td>O(N)</td></tr><tr><td>获取最后一个元素</td><td><code>V getLast(K key)</code></td><td><code>LINDEX key -1</code></td><td>O(N)</td></tr><tr><td>获取指定索引元素</td><td><code>V index(K key, long index)</code></td><td><code>LINDEX key index</code></td><td>O(N)</td></tr><tr><td>获取首次出现位置</td><td><code>Long indexOf(K key, V value)</code></td><td><code>LPOS key value</code></td><td>Redis ≥ 6.0</td></tr><tr><td>获取最后出现位置</td><td><code>Long lastIndexOf(K key, V value)</code></td><td><code>LPOS key value RANK -1</code></td><td>Redis ≥ 6.0</td></tr><tr><td>左侧弹出</td><td><code>V leftPop(K key)</code></td><td><code>LPOP key</code></td><td>—</td></tr><tr><td>左侧批量弹出</td><td><code>List&lt;V&gt; leftPop(K key, long count)</code></td><td><code>LPOP key count</code></td><td>Redis ≥ 6.2</td></tr><tr><td>左侧阻塞弹出</td><td><code>V leftPop(K key, timeout)</code></td><td><code>BLPOP key timeout</code></td><td>阻塞操作</td></tr><tr><td>右侧弹出</td><td><code>V rightPop(K key)</code></td><td><code>RPOP key</code></td><td>—</td></tr><tr><td>右侧批量弹出</td><td><code>List&lt;V&gt; rightPop(K key, long count)</code></td><td><code>RPOP key count</code></td><td>Redis ≥ 6.2</td></tr><tr><td>右侧阻塞弹出</td><td><code>V rightPop(K key, timeout)</code></td><td><code>BRPOP key timeout</code></td><td>阻塞操作</td></tr><tr><td>右侧弹出并左侧插入</td><td><code>V rightPopAndLeftPush(sourceKey, destinationKey)</code></td><td><code>RPOPLPUSH source dest</code> <strong>已废弃</strong></td><td><strong>推荐</strong> <code>LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT</code></td></tr><tr><td>阻塞式右弹左插</td><td><code>V rightPopAndLeftPush(sourceKey, destinationKey, timeout)</code></td><td><code>BRPOPLPUSH source dest timeout</code><strong>已废弃</strong></td><td><strong>推荐</strong> <code>BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis List 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Hash</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/</id>
    <published>2025-12-15T13:33:05.000Z</published>
    <updated>2025-12-16T08:59:04.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Hash 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Hash-数据类型">Hash 数据类型</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Map&lt;String, String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">key：Redis 的键（只能是 String）</span><br><span class="line">field：Hash 内的字段名（String）</span><br><span class="line">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适合存储对象型数据</span><br><span class="line">支持 字段级别读写</span><br><span class="line">所有操作均为 原子性</span><br><span class="line">内存效率优于「String + JSON」</span><br><span class="line">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个 Hash = 一个对象</span><br><span class="line">field 数量建议 &lt; 100</span><br><span class="line">单 field value 建议 &lt; 1 KB</span><br><span class="line">大对象拆分为多个 Hash</span><br><span class="line">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><table><thead><tr><th>方法功能</th><th>方法<code>redisTemplate.opsForHash().xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>删除一个或多个 hash field</td><td><code>Long delete(H key, Object... hashKeys)</code></td><td><code>HDEL key field [field ...]</code></td><td>返回删除 field 数量</td></tr><tr><td>判断 hash field 是否存在</td><td><code>Boolean hasKey(H key, Object hashKey)</code></td><td><code>HEXISTS key field</code></td><td>—</td></tr><tr><td>获取指定 field 的值</td><td><code>HV get(H key, Object hashKey)</code></td><td><code>HGET key field</code></td><td>field 不存在返回 <code>null</code></td></tr><tr><td>批量获取多个 field 的值</td><td><code>List&lt;HV&gt; multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HMGET key field [field ...]</code></td><td>不存在的 field 返回 <code>null</code></td></tr><tr><td>hash field 整数自增</td><td><code>Long increment(H key, HK hashKey, long delta)</code></td><td><code>HINCRBY key field increment</code></td><td>value 必须是整数</td></tr><tr><td>hash field 浮点数自增</td><td><code>Double increment(H key, HK hashKey, double delta)</code></td><td><code>HINCRBYFLOAT key field increment</code></td><td>Redis ≥ 2.6</td></tr><tr><td>随机返回一个 field</td><td><code>HK randomKey(H key)</code></td><td><code>HRANDFIELD key</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回一个 field-value</td><td><code>Map.Entry&lt;HK,HV&gt; randomEntry(H key)</code></td><td><code>HRANDFIELD key WITHVALUES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回多个 field</td><td><code>List&lt;HK&gt; randomKeys(H key, long count)</code></td><td><code>HRANDFIELD key count</code></td><td>count &lt; 0 可重复</td></tr><tr><td>随机返回多个 field-value</td><td><code>Map&lt;HK,HV&gt; randomEntries(H key, long count)</code></td><td><code>HRANDFIELD key count WITHVALUES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>获取 hash 中所有 field</td><td><code>Set&lt;HK&gt; keys(H key)</code></td><td><code>HKEYS key</code></td><td>O(N)，大 hash 慎用</td></tr><tr><td>获取 field 对应 value 长度</td><td><code>Long lengthOfValue(H key, HK hashKey)</code></td><td><code>HSTRLEN key field</code></td><td>field 不存在返回 0</td></tr><tr><td>获取 hash 中 field 数量</td><td><code>Long size(H key)</code></td><td><code>HLEN key</code></td><td>—</td></tr><tr><td>批量设置 field-value</td><td><code>void putAll(H key, Map&lt;HK,HV&gt; m)</code></td><td><code>HMSET key field value [...]</code> <strong>已废弃</strong></td><td>Redis 4+ 实际映射为 <code>HSET</code></td></tr><tr><td>设置单个 field-value</td><td><code>void put(H key, HK hashKey, HV value)</code></td><td><code>HSET key field value</code></td><td>新增或覆盖</td></tr><tr><td>field 不存在时设置</td><td><code>Boolean putIfAbsent(H key, HK hashKey, HV value)</code></td><td><code>HSETNX key field value</code></td><td>原子操作</td></tr><tr><td>获取所有 value</td><td><code>List&lt;HV&gt; values(H key)</code></td><td><code>HVALS key</code></td><td>O(N)</td></tr><tr><td>获取所有 field-value</td><td><code>Map&lt;HK,HV&gt; entries(H key)</code></td><td><code>HGETALL key</code></td><td><strong>生产环境慎用</strong></td></tr><tr><td>游标扫描 hash</td><td><code>Cursor&lt;Map.Entry&lt;HK,HV&gt;&gt; scan(H key, ScanOptions options)</code></td><td><code>HSCAN key cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>HGETALL</code></td></tr><tr><td>为指定 field 设置过期时间</td><td><code>ExpireChanges&lt;HK&gt; expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE key seconds FIELDS n field [...]</code></td><td>Redis ≥ 7.0</td></tr><tr><td>为指定 field 设置过期时间点</td><td><code>ExpireChanges&lt;HK&gt; expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td><td>Redis ≥ 7.0</td></tr><tr><td>设置 field 过期策略（高级）</td><td><code>ExpireChanges&lt;HK&gt; expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE / HEXPIREAT</code></td><td>Spring 抽象封装</td></tr><tr><td>移除指定 field 的过期时间</td><td><code>ExpireChanges&lt;HK&gt; persist(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HPERSIST key FIELDS n field [...]</code></td><td>Redis ≥ 7.0</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Hash 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- String</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/</id>
    <published>2025-12-15T13:31:05.000Z</published>
    <updated>2025-12-16T08:49:08.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis String 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="String-数据类型">String 数据类型</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。</p></li><li class="lvl-2"><p>Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。</p></li><li class="lvl-2"><p>Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等</p></li></ul><table><thead><tr><th>数据形式</th><th>示例</th></tr></thead><tbody><tr><td>普通字符串</td><td><code>&quot;hello redis&quot;</code></td></tr><tr><td>数字（整型/浮点）</td><td><code>&quot;100&quot;</code>, <code>&quot;3.14&quot;</code></td></tr><tr><td>JSON</td><td><code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125;</code></td></tr><tr><td>序列化对象</td><td>Java / JSON / ProtoBuf</td></tr><tr><td>Base64 / 二进制</td><td>图片、Token 等</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下</p></li></ul><table><thead><tr><th>分类</th><th>最大存储大小（MB）</th></tr></thead><tbody><tr><td>Key</td><td>&lt; 1k</td></tr><tr><td>Value</td><td>&lt; 1MB</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>redisTemplate.opsForValue().xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>设置 key 的值</td><td><code>void set(K key, V value)</code></td><td><code>SET key value</code></td><td>—</td></tr><tr><td>key 不存在时设置</td><td><code>Boolean setIfAbsent(K key, V value)</code></td><td><code>SET key value NX</code></td><td>NX: 如果key 不存在则设置</td></tr><tr><td>key 不存在时设置并指定过期时间</td><td><code>Boolean setIfAbsent(K key, V value, long timeout, TimeUnit unit)</code></td><td><code>SET key value NX EX seconds</code></td><td>EX: 指定过期时间，单位为秒<br>PX: 指定过期时间，单位为毫秒</td></tr><tr><td>key 存在时设置</td><td><code>Boolean setIfPresent(K key, V value)</code></td><td><code>SET key value XX</code></td><td>XX: 如果key 存在则设置</td></tr><tr><td>key 存在时设置并指定过期时间</td><td><code>Boolean setIfPresent(K key, V value, long timeout, TimeUnit unit)</code></td><td><code>SET key value XX EX seconds</code></td><td>—</td></tr><tr><td>设置值并指定过期时间</td><td><code>void set(K key, V value, long timeout, TimeUnit unit)</code></td><td><code>SETEX key seconds value</code> <strong>即将作废</strong></td><td><strong>推荐</strong> → <code>SET key value EX seconds</code></td></tr><tr><td>获取 key 的值</td><td><code>V get(K key)</code></td><td><code>GET key</code></td><td>—</td></tr><tr><td>获取值并重置过期时间</td><td><code>V getAndExpire(K key, long timeout, TimeUnit unit)</code></td><td><code>GETEX key EX seconds</code></td><td>Redis ≥ 6.2</td></tr><tr><td>获取值并删除 key</td><td><code>V getAndDelete(K key)</code></td><td><code>GETDEL key</code></td><td>Redis ≥ 6.2</td></tr><tr><td>获取字符串指定区间</td><td><code>V get(K key, long start, long end)</code></td><td><code>GETRANGE key start end</code></td><td>—</td></tr><tr><td>获取字符串长度</td><td><code>Long size(K key)</code></td><td><code>STRLEN key</code></td><td>—</td></tr><tr><td>获取旧值并设置新值</td><td><code>V getAndSet(K key, V value)</code></td><td><code>GETSET key value</code> <strong>即将作废</strong></td><td><strong>推荐</strong> → <code>SET key value GET</code></td></tr><tr><td>获取 key 的当前值并移除过期时间</td><td><code>V getAndPersist(K key)</code></td><td><code>GETEX key PERSIST</code></td><td>Redis ≥ 6.2</td></tr><tr><td>数值自增 1</td><td><code>Long increment(K key)</code></td><td><code>INCR key</code></td><td>—</td></tr><tr><td>数值增加指定值</td><td><code>Long increment(K key, long delta)</code></td><td><code>INCRBY key increment</code></td><td>—</td></tr><tr><td>数值自减 1</td><td><code>Long decrement(K key)</code></td><td><code>DECR key</code></td><td>—</td></tr><tr><td>数值减少指定值</td><td><code>Long decrement(K key, long delta)</code></td><td><code>DECRBY key decrement</code></td><td>—</td></tr><tr><td>批量设置 key-value</td><td><code>void multiSet(Map&lt;K,V&gt; map)</code></td><td><code>MSET key value [key value ...]</code></td><td>—</td></tr><tr><td>批量获取 key 的值</td><td><code>List&lt;V&gt; multiGet(Collection&lt;K&gt; keys)</code></td><td><code>MGET key [key ...]</code></td><td>不存在的 key 返回 <code>null</code></td></tr><tr><td>同时设置多个 key-value（仅当全部不存在）</td><td><code>Boolean multiSetIfAbsent(Map&lt;K, V&gt; map)</code></td><td><code>MSETNX key value [key value ...]</code></td><td>原子操作：要么全部成功，要么全部失败</td></tr><tr><td>追加字符串并返回新长度</td><td><code>Integer append(K key, String value)</code></td><td><code>APPEND key value</code></td><td>—</td></tr><tr><td>为key设置新值，同时保留原来的过期时间</td><td><code>没有对应的方法</code></td><td><code>SET key value KEEPTTL</code></td><td>—</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis String 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- 通用命令</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/</id>
    <published>2025-12-15T13:30:05.000Z</published>
    <updated>2025-12-16T08:47:06.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="通用命令">通用命令</h2><ul class="lvl-0"><li class="lvl-2"><p>针对所有数据类型均可使用给的方法和命令</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>redisTemplate.xxx()</code></th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>复制 key 到新 key</td><td><code>Boolean copy(K source, K target, boolean replace)</code></td><td><code>COPY source target [REPLACE]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>判断 key 是否存在（单个）</td><td><code>Boolean hasKey(K key)</code></td><td><code>EXISTS key</code></td><td>CLI 返回存在数量</td></tr><tr><td>统计存在的 key 数量</td><td><code>Long countExistingKeys(Collection&lt;K&gt; keys)</code></td><td><code>EXISTS key [key ...]</code></td><td>返回存在 key 的数量</td></tr><tr><td>删除指定 key（同步）</td><td><code>Boolean delete(K key)</code></td><td><code>DEL key</code></td><td>返回是否删除成功</td></tr><tr><td>批量删除 key（同步）</td><td><code>Long delete(Collection&lt;K&gt; keys)</code></td><td><code>DEL key [key ...]</code></td><td>返回删除数量</td></tr><tr><td>删除 key（异步）</td><td><code>Boolean unlink(K key)</code></td><td><code>UNLINK key</code></td><td>非阻塞删除</td></tr><tr><td>批量删除 key（异步）</td><td><code>Long unlink(Collection&lt;K&gt; keys)</code></td><td><code>UNLINK key [key ...]</code></td><td>推荐大 key 使用</td></tr><tr><td>获取 key 的数据类型</td><td><code>DataType type(K key)</code></td><td><code>TYPE key</code></td><td>返回 string/hash/list/set/zset/none</td></tr><tr><td>按模式匹配 key（阻塞）</td><td><code>Set&lt;K&gt; keys(K pattern)</code></td><td><code>KEYS pattern</code></td><td><strong>生产环境不推荐</strong></td></tr><tr><td>游标方式扫描 key</td><td><code>Cursor&lt;K&gt; scan(ScanOptions options)</code></td><td><code>SCAN cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>KEYS</code></td></tr><tr><td>随机返回一个 key</td><td><code>K randomKey()</code></td><td><code>RANDOMKEY</code></td><td>可能返回 <code>null</code></td></tr><tr><td>重命名 key</td><td><code>void rename(K oldKey, K newKey)</code></td><td><code>RENAME oldKey newKey</code></td><td>覆盖目标 key</td></tr><tr><td>key 不存在时重命名</td><td><code>Boolean renameIfAbsent(K oldKey, K newKey)</code></td><td><code>RENAMENX oldKey newKey</code></td><td>原子操作</td></tr><tr><td>设置 key 过期时间</td><td><code>Boolean expire(K key, long timeout, TimeUnit unit)</code></td><td><code>PEXPIRE / EXPIRE</code></td><td>优先毫秒精度</td></tr><tr><td>设置 key 在指定时间过期</td><td><code>Boolean expireAt(K key, Date date)</code></td><td><code>PEXPIREAT / EXPIREAT</code></td><td>精度自动降级</td></tr><tr><td>设置过期策略（高级 API）</td><td><code>ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options)</code></td><td><code>EXPIRE / PEXPIRE / EXPIREAT</code></td><td>Spring 抽象封装</td></tr><tr><td>清除 key 的过期时间</td><td><code>Boolean persist(K key)</code></td><td><code>PERSIST key</code></td><td>变为永久 key</td></tr><tr><td>获取剩余 TTL（秒）</td><td><code>Long getExpire(K key)</code></td><td><code>TTL key</code></td><td><code>-1</code> 无 TTL，<code>-2</code> 不存在</td></tr><tr><td>获取剩余 TTL（指定单位）</td><td><code>Long getExpire(K key, TimeUnit unit)</code></td><td><code>PTTL / TTL</code></td><td>优先毫秒</td></tr><tr><td>将 key 移动到其他 DB</td><td><code>Boolean move(K key, int dbIndex)</code></td><td><code>MOVE key db</code></td><td>集群模式不可用</td></tr><tr><td>导出 key 的序列化值</td><td><code>byte[] dump(K key)</code></td><td><code>DUMP key</code></td><td>用于迁移</td></tr><tr><td>恢复 key</td><td><code>void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace)</code></td><td><code>RESTORE key ttl value [REPLACE]</code></td><td>与 <code>DUMP</code> 配合</td></tr><tr><td>排序并返回结果</td><td><code>List&lt;V&gt; sort(SortQuery&lt;K&gt; query)</code></td><td><code>SORT key</code></td><td>阻塞操作</td></tr><tr><td>排序并指定返回类型</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer)</code></td><td><code>SORT key</code></td><td>结果反序列化</td></tr><tr><td>排序并映射结果</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper)</code></td><td><code>SORT key</code></td><td>Spring 封装</td></tr><tr><td>排序并映射（高级）</td><td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper)</code></td><td><code>SORT key</code></td><td>批量映射</td></tr><tr><td>排序并存储结果</td><td><code>Long sort(SortQuery&lt;K&gt; query, K storeKey)</code></td><td><code>SORT key STORE destination</code></td><td>返回结果条数</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>生产环境慎用的命令</p></li></ul><table><thead><tr><th>命令</th><th>原因</th><th>推荐</th></tr></thead><tbody><tr><td><code>KEYS</code></td><td>阻塞、O(N)</td><td><code>SCAN</code></td></tr><tr><td><code>SORT</code></td><td>阻塞、消耗 CPU</td><td>业务侧排序</td></tr><tr><td><code>DEL</code></td><td>阻塞、消耗 CPU</td><td><code>UNLINK</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis SCAN 命令详解：作用、用法与最佳实践</title>
    <link href="https://blog.hanqunfeng.com/2025/12/10/redis7-scan/"/>
    <id>https://blog.hanqunfeng.com/2025/12/10/redis7-scan/</id>
    <published>2025-12-10T13:30:05.000Z</published>
    <updated>2025-12-10T09:16:12.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。</li><li class="lvl-2">Redis 提供了两种思路：使用 <code>KEYS pattern</code> 或使用游标式遍历命令 <code>SCAN</code>。</li><li class="lvl-2"><code>KEYS pattern</code> 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用<code>KEYS pattern</code>等危险命令。</li><li class="lvl-2">所以Redis官方强烈推荐 <code>SCAN</code> 方式，其是最安全、最可控的遍历方法。</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="SCAN-的核心作用">SCAN 的核心作用</h2><ul class="lvl-0"><li class="lvl-2"><p>SCAN 的主要功能是<strong>基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key</strong>。</p></li><li class="lvl-2"><p>它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。</p></li><li class="lvl-2"><p>SCAN 的设计目标包括：</p><ul class="lvl-2"><li class="lvl-5">避免阻塞 Redis 主线程</li><li class="lvl-5">分批、渐进扫描大规模 key 集合</li><li class="lvl-5">灵活配合模式匹配（MATCH）</li><li class="lvl-5">控制每次返回 key 的数量（COUNT）</li><li class="lvl-5">在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描</li></ul></li><li class="lvl-2"><p>SCAN 命令是完整游标遍历族的一部分，还包括：</p><ul class="lvl-2"><li class="lvl-5"><code>HSCAN</code>：遍历哈希表 field/value</li><li class="lvl-5"><code>SSCAN</code>：遍历 set 元素</li><li class="lvl-5"><code>ZSCAN</code>：遍历有序集合</li></ul></li><li class="lvl-2"><p>为了完成后面的示例演示，这里准备一个测试数据批量生产脚本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本名称：import_unified_data.sh</span></span><br><span class="line"><span class="comment"># 运行方法：sh $0 &lt;type&gt; [count]</span></span><br><span class="line"><span class="comment"># &lt;type&gt;: string, hash, list, set, 或 zset</span></span><br><span class="line"><span class="comment"># [count]: 导入的数据量 (可选，默认为 100)</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 参数校验与配置 ---</span></span><br><span class="line"></span><br><span class="line">SUPPORTED_TYPES=<span class="string">&quot;string hash list set zset&quot;</span></span><br><span class="line"><span class="comment"># 定义每个集合/列表/有序集合要添加的成员数量</span></span><br><span class="line">MEMBERS_PER_KEY=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否提供了类型参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ 错误：请指定导入类型。&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;支持的类型: <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: sh <span class="variable">$0</span> &lt;type&gt; [count]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取类型参数 (第一个参数)</span></span><br><span class="line">DATA_TYPE=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据量参数 (第二个参数)，不存在则默认为 1000</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ge 2 ]; <span class="keyword">then</span></span><br><span class="line">    DATA_COUNT=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    DATA_COUNT=100</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查类型是否有效</span></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="string">&quot; <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$&#123;DATA_TYPE&#125;</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ 错误：不支持的类型 &#x27;<span class="variable">$DATA_TYPE</span>&#x27;。&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;支持的类型: <span class="variable">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 连接配置</span></span><br><span class="line">REDIS_HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">REDIS_PORT=<span class="string">&quot;6379&quot;</span></span><br><span class="line">REDIS_PASSWORD=<span class="string">&quot;password&quot;</span> <span class="comment"># 替换为你的实际密码或留空</span></span><br><span class="line">KEY_PREFIX=<span class="string">&quot;test_data&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># --- 2. 命令生成主逻辑 ---</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ 正在生成 <span class="variable">$&#123;DATA_COUNT&#125;</span> 条 Redis [<span class="variable">$&#123;DATA_TYPE&#125;</span>] 命令...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 RESP 命令流</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le <span class="variable">$DATA_COUNT</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$DATA_TYPE</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment"># --- String 类型导入 (SET key value) ---</span></span><br><span class="line">        string)</span><br><span class="line">            KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:string:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            VALUE=<span class="string">&quot;value_of_<span class="variable">$&#123;i&#125;</span>_<span class="subst">$(date +%s%N)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># SET 命令 RESP 协议: *3 (SET, key, value)</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$3\r\nSET\r\n\$<span class="variable">$&#123;#KEY&#125;</span>\r\n<span class="variable">$&#123;KEY&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE&#125;</span>\r\n<span class="variable">$&#123;VALUE&#125;</span>\r\n&quot;</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Hash 类型导入 (HSET key field1 value1 field2 value2) ---</span></span><br><span class="line">        <span class="built_in">hash</span>)</span><br><span class="line">            HASH_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:hash:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            FIELD1=<span class="string">&quot;name&quot;</span></span><br><span class="line">            VALUE1=<span class="string">&quot;User_Name_<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            FIELD2=<span class="string">&quot;age&quot;</span></span><br><span class="line">            VALUE2=$(( (i % <span class="number">50</span>) + <span class="number">20</span> ))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2)</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;*6\r\n\$4\r\nHSET\r\n\$<span class="variable">$&#123;#HASH_KEY&#125;</span>\r\n<span class="variable">$&#123;HASH_KEY&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\$<span class="variable">$&#123;#FIELD1&#125;</span>\r\n<span class="variable">$&#123;FIELD1&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE1&#125;</span>\r\n<span class="variable">$&#123;VALUE1&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\$<span class="variable">$&#123;#FIELD2&#125;</span>\r\n<span class="variable">$&#123;FIELD2&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE2&#125;</span>\r\n<span class="variable">$&#123;VALUE2&#125;</span>\r\n&quot;</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- List 类型导入 (LPUSH key value) ---</span></span><br><span class="line">        list)</span><br><span class="line">            LIST_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:list:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                VALUE=<span class="string">&quot;list_element_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line">                <span class="comment"># LPUSH 命令 RESP 协议: *3 (LPUSH, key, value)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$5\r\nLPUSH\r\n\$<span class="variable">$&#123;#LIST_KEY&#125;</span>\r\n<span class="variable">$&#123;LIST_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#VALUE&#125;</span>\r\n<span class="variable">$&#123;VALUE&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Set 类型导入 (SADD key member) ---</span></span><br><span class="line">        <span class="built_in">set</span>)</span><br><span class="line">            SET_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:set:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                MEMBER=<span class="string">&quot;set_member_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line">                <span class="comment"># SADD 命令 RESP 协议: *3 (SADD, key, member)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*3\r\n\$4\r\nSADD\r\n\$<span class="variable">$&#123;#SET_KEY&#125;</span>\r\n<span class="variable">$&#123;SET_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#MEMBER&#125;</span>\r\n<span class="variable">$&#123;MEMBER&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- Sorted Set 类型导入 (ZADD key score member) ---</span></span><br><span class="line">        zset)</span><br><span class="line">            ZSET_KEY=<span class="string">&quot;<span class="variable">$&#123;KEY_PREFIX&#125;</span>:zset:<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 循环添加 5 个成员</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$MEMBERS_PER_KEY</span>); <span class="keyword">do</span></span><br><span class="line">                SCORE=<span class="string">&quot;<span class="variable">$&#123;i&#125;</span><span class="variable">$&#123;j&#125;</span>&quot;</span> <span class="comment"># 生成唯一分数：例如 key 1 的分数是 11, 12...</span></span><br><span class="line">                MEMBER=<span class="string">&quot;zset_member_<span class="variable">$&#123;i&#125;</span>_<span class="variable">$&#123;j&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># ZADD 命令 RESP 协议: *4 (ZADD, key, score, member)</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">&quot;*4\r\n\$4\r\nZADD\r\n\$<span class="variable">$&#123;#ZSET_KEY&#125;</span>\r\n<span class="variable">$&#123;ZSET_KEY&#125;</span>\r\n\$<span class="variable">$&#123;#SCORE&#125;</span>\r\n<span class="variable">$&#123;SCORE&#125;</span>\r\n\$<span class="variable">$&#123;#MEMBER&#125;</span>\r\n<span class="variable">$&#123;MEMBER&#125;</span>\r\n&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    i=$((i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span> | (</span><br><span class="line">    <span class="comment"># ----------------------------------------</span></span><br><span class="line">    <span class="comment"># --- 3. 管道导入到 Redis ---</span></span><br><span class="line">    <span class="comment"># ----------------------------------------</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;📤 正在通过 redis-cli --pipe 导入数据...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建 redis-cli 命令</span></span><br><span class="line">    REDIS_CLI_CMD=<span class="string">&quot;redis-cli -h <span class="variable">$&#123;REDIS_HOST&#125;</span> -p <span class="variable">$&#123;REDIS_PORT&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果设置了密码，则添加 -a 参数</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        REDIS_CLI_CMD=<span class="string">&quot;<span class="variable">$&#123;REDIS_CLI_CMD&#125;</span> -a <span class="variable">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行导入</span></span><br><span class="line">    <span class="variable">$&#123;REDIS_CLI_CMD&#125;</span> --pipe</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查命令是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;✅ 数据导入成功！共导入 <span class="variable">$&#123;DATA_COUNT&#125;</span> 条 [<span class="variable">$&#123;DATA_TYPE&#125;</span>] 记录。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="SCAN-的基本用法">SCAN 的基本用法</h2><ul class="lvl-0"><li class="lvl-2"><p>SCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class="built_in">type</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数解释：</p></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>cursor</td><td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td></tr><tr><td>MATCH pattern</td><td>使用通配符匹配 key（可选）</td></tr><tr><td>COUNT count</td><td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td></tr><tr><td>TYPE type</td><td>匹配的 key 类型（可选）</td></tr></tbody></table><h3 id="示例：">示例：</h3><ul class="lvl-0"><li class="lvl-2"><p>为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh import_unified_data.sh string 100</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取所有 key：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 游标初始值为0</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">&quot;88&quot;</span>  <span class="comment"># 游标</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line"><span class="comment"># 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key</span></span><br><span class="line"><span class="comment">## 扫描结果中：</span></span><br><span class="line"><span class="comment"># 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束</span></span><br><span class="line"><span class="comment"># 第二个元素是匹配的 key列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着上面给出的游标，继续扫描：</span></span><br><span class="line">127.0.0.1:6379&gt; scan 88</span><br><span class="line">1) <span class="string">&quot;92&quot;</span>  <span class="comment"># 不为0就表示还有更多的 key 可以继续扫描</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line">……………………………………</span><br><span class="line">127.0.0.1:6379&gt; scan 87</span><br><span class="line">1) <span class="string">&quot;0&quot;</span> <span class="comment"># 扫描结束 游标为0</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:68&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:79&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:41&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">控制每次获取的 key 数量</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 count 20</span><br><span class="line">1) <span class="string">&quot;92&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">   12) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">   13) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">   14) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">   15) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">   16) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">   17) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">   18) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">   19) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   20) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   21) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line"><span class="comment"># 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。</span></span><br><span class="line"><span class="comment"># 本示例就返回了21条，比 count 还多了 1 条</span></span><br><span class="line"><span class="comment"># 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">扫描以 test_data:string 开头的 key</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match test_data:string*</span><br><span class="line">1) <span class="string">&quot;88&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="4"><li class="lvl-5">扫描以 test_data:string 开头的 key，并返回 30 条</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match test_data:string* count 30</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line">   11) <span class="string">&quot;test_data:string:63&quot;</span></span><br><span class="line">   12) <span class="string">&quot;test_data:string:2&quot;</span></span><br><span class="line">   13) <span class="string">&quot;test_data:string:4&quot;</span></span><br><span class="line">   14) <span class="string">&quot;test_data:string:20&quot;</span></span><br><span class="line">   15) <span class="string">&quot;test_data:string:57&quot;</span></span><br><span class="line">   16) <span class="string">&quot;test_data:string:78&quot;</span></span><br><span class="line">   17) <span class="string">&quot;test_data:string:71&quot;</span></span><br><span class="line">   18) <span class="string">&quot;test_data:string:35&quot;</span></span><br><span class="line">   19) <span class="string">&quot;test_data:string:86&quot;</span></span><br><span class="line">   20) <span class="string">&quot;test_data:string:6&quot;</span></span><br><span class="line">   21) <span class="string">&quot;test_data:string:47&quot;</span></span><br><span class="line">   22) <span class="string">&quot;test_data:string:48&quot;</span></span><br><span class="line">   23) <span class="string">&quot;test_data:string:74&quot;</span></span><br><span class="line">   24) <span class="string">&quot;test_data:string:67&quot;</span></span><br><span class="line">   25) <span class="string">&quot;test_data:string:26&quot;</span></span><br><span class="line">   26) <span class="string">&quot;test_data:string:60&quot;</span></span><br><span class="line">   27) <span class="string">&quot;test_data:string:36&quot;</span></span><br><span class="line">   28) <span class="string">&quot;test_data:string:49&quot;</span></span><br><span class="line">   29) <span class="string">&quot;test_data:string:3&quot;</span></span><br><span class="line">   30) <span class="string">&quot;test_data:string:44&quot;</span></span><br><span class="line">   31) <span class="string">&quot;test_data:string:68&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个</span></span><br><span class="line"><span class="comment"># 也有可能比 count 少，甚至为 0 个</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="5"><li class="lvl-5">扫描以 h_key 开头的 key，并返回 30 条</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先插入一条记录</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> h_key:1 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个</span></span><br><span class="line"><span class="comment"># 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回</span></span><br><span class="line"><span class="comment"># 并且此时返回的游标也不为0，说明我们还需要继续扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整的扫描过程如下：</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)  <span class="comment"># empty array 也不能说明一定没有</span></span><br><span class="line">127.0.0.1:6379&gt; scan 124 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;9&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line">127.0.0.1:6379&gt; scan 9 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;43&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;h_key:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 43 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;0&quot;</span>      <span class="comment"># 只有游标为0时才算扫描结束</span></span><br><span class="line">2) (empty array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class="line">1) <span class="string">&quot;124&quot;</span></span><br><span class="line">2) (empty array)</span><br><span class="line">127.0.0.1:6379&gt; scan 124 match h_key* count 60</span><br><span class="line">1) <span class="string">&quot;75&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;h_key:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 75 match h_key* count 60</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) (empty array)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="6"><li class="lvl-5">扫描指定类型的key</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> string</span><br><span class="line">1) <span class="string">&quot;88&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;test_data:string:16&quot;</span></span><br><span class="line">    2) <span class="string">&quot;test_data:string:85&quot;</span></span><br><span class="line">    3) <span class="string">&quot;test_data:string:21&quot;</span></span><br><span class="line">    4) <span class="string">&quot;test_data:string:83&quot;</span></span><br><span class="line">    5) <span class="string">&quot;test_data:string:97&quot;</span></span><br><span class="line">    6) <span class="string">&quot;test_data:string:77&quot;</span></span><br><span class="line">    7) <span class="string">&quot;test_data:string:29&quot;</span></span><br><span class="line">    8) <span class="string">&quot;test_data:string:89&quot;</span></span><br><span class="line">    9) <span class="string">&quot;test_data:string:91&quot;</span></span><br><span class="line">   10) <span class="string">&quot;test_data:string:28&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持的类型有：</span></span><br><span class="line"><span class="comment"># string list set zset hash stream</span></span><br><span class="line"><span class="comment"># 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。</span></span><br><span class="line"><span class="comment"># 例如，ZSET 和 GEOHASH 都是 zset 类型。</span></span><br><span class="line">127.0.0.1:6379&gt; GEOADD geokey 0 0 value</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> geokey</span><br><span class="line">zset</span><br><span class="line">127.0.0.1:6379&gt; ZADD zkey 1000 value</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SCAN 0 TYPE zset count 1000</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;zkey&quot;</span></span><br><span class="line">   2) <span class="string">&quot;geokey&quot;</span></span><br></pre></td></tr></table></figure><h2 id="HSCAN-的基本使用方法">HSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>HSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数解释：</p></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>key</td><td>键名</td></tr><tr><td>cursor</td><td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td></tr><tr><td>MATCH pattern</td><td>使用通配符匹配 key（可选）</td></tr><tr><td>COUNT count</td><td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td></tr><tr><td>NOVALUES</td><td>redis8+增加的属性，只返回key，不返回 value（可选）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>为了测试 HSCAN，我们先插入一些数据：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh import_unified_data.sh <span class="built_in">hash</span> 100</span><br></pre></td></tr></table></figure><h3 id="使用示例">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取所有 field 和 value：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> <span class="built_in">hash</span></span><br><span class="line">1) <span class="string">&quot;48&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:hash:42&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:hash:71&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:hash:54&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:hash:87&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:hash:96&quot;</span></span><br><span class="line">   6) <span class="string">&quot;test_data:hash:49&quot;</span></span><br><span class="line"><span class="comment"># 获取 test_data:hash:42 的所有 field 和 value</span></span><br><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;User_Name_42&quot;</span></span><br><span class="line">   3) <span class="string">&quot;age&quot;</span></span><br><span class="line">   4) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配 field：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 match age*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;age&quot;</span></span><br><span class="line">   2) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">模糊匹配 field，并返回 10 条数据：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 match *e* count 10</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;User_Name_42&quot;</span></span><br><span class="line">   3) <span class="string">&quot;age&quot;</span></span><br><span class="line">   4) <span class="string">&quot;62&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="4"><li class="lvl-5">不显示value(需要redis8+)</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan test_data:<span class="built_in">hash</span>:42 0 novalues</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure><h2 id="SSCAN-的基本使用方法">SSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>SSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="使用示例-2">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取指定key的所有元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;112&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:set:43&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:set:33&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:set:98&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:set:61&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:set:2&quot;</span></span><br><span class="line">   6) <span class="string">&quot;test_data:set:70&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_1&quot;</span></span><br><span class="line">   2) <span class="string">&quot;set_member_43_2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;set_member_43_3&quot;</span></span><br><span class="line">   4) <span class="string">&quot;set_member_43_4&quot;</span></span><br><span class="line">   5) <span class="string">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0 match *_3*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_3&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">返回 1 个元素: 实际上控制不住，大概率会返回所有元素</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan test_data:<span class="built_in">set</span>:43 0 count 1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;set_member_43_1&quot;</span></span><br><span class="line">   2) <span class="string">&quot;set_member_43_2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;set_member_43_3&quot;</span></span><br><span class="line">   4) <span class="string">&quot;set_member_43_4&quot;</span></span><br><span class="line">   5) <span class="string">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ZSCAN-的基本使用方法">ZSCAN 的基本使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>ZSCAN 的基本语法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="使用示例-3">使用示例</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">获取指定key的所有元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 <span class="built_in">type</span> zset</span><br><span class="line">1) <span class="string">&quot;112&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;test_data:zset:89&quot;</span></span><br><span class="line">   2) <span class="string">&quot;test_data:zset:81&quot;</span></span><br><span class="line">   3) <span class="string">&quot;test_data:zset:73&quot;</span></span><br><span class="line">   4) <span class="string">&quot;test_data:zset:79&quot;</span></span><br><span class="line">   5) <span class="string">&quot;test_data:zset:15&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zscan test_data:zset:89 0</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;zset_member_89_1&quot;</span></span><br><span class="line">    2) <span class="string">&quot;891&quot;</span></span><br><span class="line">    3) <span class="string">&quot;zset_member_89_2&quot;</span></span><br><span class="line">    4) <span class="string">&quot;892&quot;</span></span><br><span class="line">    5) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">    6) <span class="string">&quot;893&quot;</span></span><br><span class="line">    7) <span class="string">&quot;zset_member_89_4&quot;</span></span><br><span class="line">    8) <span class="string">&quot;894&quot;</span></span><br><span class="line">    9) <span class="string">&quot;zset_member_89_5&quot;</span></span><br><span class="line">   10) <span class="string">&quot;895&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">模糊匹配元素：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;893&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="3"><li class="lvl-5">获取指定key的所有元素，并返回 1 个元素，同样控制不住</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zscan test_data:zset:89 0 count 1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;zset_member_89_1&quot;</span></span><br><span class="line">    2) <span class="string">&quot;891&quot;</span></span><br><span class="line">    3) <span class="string">&quot;zset_member_89_2&quot;</span></span><br><span class="line">    4) <span class="string">&quot;892&quot;</span></span><br><span class="line">    5) <span class="string">&quot;zset_member_89_3&quot;</span></span><br><span class="line">    6) <span class="string">&quot;893&quot;</span></span><br><span class="line">    7) <span class="string">&quot;zset_member_89_4&quot;</span></span><br><span class="line">    8) <span class="string">&quot;894&quot;</span></span><br><span class="line">    9) <span class="string">&quot;zset_member_89_5&quot;</span></span><br><span class="line">   10) <span class="string">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 提供了两种思路：使用 &lt;code&gt;KEYS pattern&lt;/code&gt; 或使用游标式遍历命令 &lt;code&gt;SCAN&lt;/code&gt;。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;code&gt;KEYS pattern&lt;/code&gt; 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用&lt;code&gt;KEYS pattern&lt;/code&gt;等危险命令。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;所以Redis官方强烈推荐 &lt;code&gt;SCAN&lt;/code&gt; 方式，其是最安全、最可控的遍历方法。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 新一代构建工具 mvnd</title>
    <link href="https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/"/>
    <id>https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/</id>
    <published>2025-12-07T14:30:05.000Z</published>
    <updated>2025-12-08T06:04:23.696Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Maven 新一代构建工具 mvnd</p></li><li class="lvl-2"><p><a href="https://github.com/apache/maven-mvnd">mvnd GitHub</a></p></li><li class="lvl-2"><p>本文安装的是 mvnd 1.0.3。</p></li></ul><span id="more"></span><h2 id="mvnd-简介">mvnd 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。</p></li><li class="lvl-2"><p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p></li></ul><h3 id="架构概述">架构概述</h3><ul class="lvl-0"><li class="lvl-2"><p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p></li><li class="lvl-2"><p>实际构建发生在一个长驻后台进程中，又名守护程序。</p></li><li class="lvl-2"><p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p></li><li class="lvl-2"><p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p></li><li class="lvl-2"><p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p></li><li class="lvl-2"><p>这种架构带来了以下优点：</p><ul class="lvl-2"><li class="lvl-6">不需要每次构建重新启动 JVM，大大节省时间。</li><li class="lvl-6">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li><li class="lvl-6">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li></ul></li><li class="lvl-2"><p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p></li></ul><h2 id="mvnd-安装">mvnd 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>mvnd 安装包下载地址：</p><ul class="lvl-2"><li class="lvl-6"><a href="https://github.com/apache/maven-mvnd/releases">mvnd Github Release</a></li><li class="lvl-6"><a href="https://maven.apache.org/download.cgi">maven 官网下载页</a></li></ul></li><li class="lvl-2"><p>本文以 macOS 为例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 mvnd 对应的安装包</span></span><br><span class="line">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class="line"><span class="built_in">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class="line"><span class="comment"># 添加 mvnd 到环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment"># 检查 mvnd 是否安装成功</span></span><br><span class="line">mvnd --version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p></li><li class="lvl-2"><p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$MVND_HOME</span>/conf/mvnd.properties <span class="variable">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p></li></ul><table><thead><tr><th>配置项</th><th>默认值</th><th>中文解释</th></tr></thead><tbody><tr><td><strong>mvnd.noBuffering</strong> <code>[*]</code></td><td>false</td><td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td></tr><tr><td><strong>mvnd.rollingWindowSize</strong></td><td>0</td><td>构建并行模块时，每个模块显示的日志行数</td></tr><tr><td><strong>mvnd.logPurgePeriod</strong></td><td>7d</td><td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td></tr><tr><td><strong>mvnd.noDaemon</strong></td><td>false</td><td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td></tr><tr><td><strong>mvnd.debug</strong></td><td>false</td><td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td></tr><tr><td><strong>mvnd.idleTimeout</strong></td><td>3 hours</td><td>守护进程在空闲多久后自动关闭</td></tr><tr><td><strong>mvnd.keepAlive</strong></td><td>100 ms</td><td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td></tr><tr><td><strong>mvnd.maxLostKeepAlive</strong></td><td>30</td><td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td></tr><tr><td><strong>mvnd.minThreads</strong></td><td>1</td><td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td></tr><tr><td><strong>mvnd.threads</strong> <code>[*]</code></td><td>未设置</td><td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td></tr><tr><td><strong>mvnd.builder</strong></td><td>smart</td><td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td></tr><tr><td><strong>mvnd.minHeapSize</strong></td><td>128M</td><td>守护进程 JVM 的最小堆内存</td></tr><tr><td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td><td>2G</td><td>守护进程 JVM 的最大堆内存</td></tr><tr><td><strong>mvnd.threadStackSize</strong></td><td>1M</td><td>守护进程线程栈大小</td></tr><tr><td><strong>mvnd.jvmArgs</strong></td><td>未设置</td><td>传递给 daemon 的额外 JVM 参数</td></tr><tr><td><strong>mvnd.enableAssertions</strong></td><td>false</td><td>是否为 daemon 启用 JVM 断言（-ea）</td></tr><tr><td><strong>mvnd.expirationCheckDelay</strong></td><td>10 seconds</td><td>守护进程检测自身是否需要过期的时间间隔</td></tr><tr><td><strong>mvnd.duplicateDaemonGracePeriod</strong></td><td>10 seconds</td><td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td></tr><tr><td><strong>mvnd.home</strong></td><td>自动设置</td><td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td></tr><tr><td><strong>java.home</strong></td><td>使用环境变量</td><td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td></tr><tr><td><strong>maven.settings</strong> <code>[*]</code></td><td>~/.m2/settings.xml</td><td>maven 的 settings.xml 路径</td></tr></tbody></table><h2 id="mvnd-使用">mvnd 使用</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行使用方式与 mvn 一样，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvnd clean install</span><br><span class="line">mvnd clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p></li><li class="lvl-2"><p>mvnd 还有些特殊用法，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class="line">mvnd --status</span><br><span class="line"><span class="comment"># 手动停止所有运行的守护进程</span></span><br><span class="line">mvnd --stop</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png" alt=""></p></li></ul><h2 id="mvnd-与-mvnw-的区别">mvnd 与 mvnw 的区别</h2><ul class="lvl-0"><li class="lvl-2"><p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class="line">mvnw： linux 脚本文件</span><br><span class="line">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p></li><li class="lvl-2"><p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p></li><li class="lvl-2"><p><code>mvnw</code>使用方式如下:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mvnw clean install</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p></li></ul><table><thead><tr><th>对比项</th><th>mvnd</th><th>mvnw（Maven Wrapper）</th></tr></thead><tbody><tr><td>是什么</td><td>一个「常驻的 Maven 守护进程」</td><td>一个「Maven 启动脚本」</td></tr><tr><td>是否常驻</td><td>✅ 是（daemon）</td><td>❌ 否（一次性）</td></tr><tr><td>是否下载 Maven</td><td>❌ 不下载，自己就是程序</td><td>✅ 会自动下载指定版本</td></tr><tr><td>主要目的</td><td>加速构建</td><td>保证版本一致</td></tr><tr><td>是否推荐在 CI</td><td>一般不建议</td><td>✅ 非常推荐</td></tr><tr><td>使用方式</td><td><code>mvnd clean install</code></td><td><code>./mvnw clean install</code></td></tr><tr><td>是否与项目绑定</td><td>❌ 全局使用</td><td>✅ 和项目绑定</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Maven 新一代构建工具 mvnd&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apache/maven-mvnd&quot;&gt;mvnd GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文安装的是 mvnd 1.0.3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="maven" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/maven/"/>
    
    <category term="mvnd" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/maven/mvnd/"/>
    
    
    <category term="mavne" scheme="https://blog.hanqunfeng.com/tags/mavne/"/>
    
    <category term="mvnd" scheme="https://blog.hanqunfeng.com/tags/mvnd/"/>
    
  </entry>
  
  <entry>
    <title>Redis 7 + ACL 简介</title>
    <link href="https://blog.hanqunfeng.com/2025/12/07/redis7-acl/"/>
    <id>https://blog.hanqunfeng.com/2025/12/07/redis7-acl/</id>
    <published>2025-12-07T13:30:05.000Z</published>
    <updated>2025-12-07T07:50:08.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">Redis 7 + ACL 简介</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="Redis-ACL-简介">Redis ACL 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p></li><li class="lvl-2"><p>ACL 可以控制的维度包括：</p><ul class="lvl-2"><li class="lvl-5">谁能登录（用户、密码）</li><li class="lvl-5">可以执行哪些命令</li><li class="lvl-5">可以访问哪些 key（按前缀 / 正则）</li><li class="lvl-5">可否通过网络访问</li><li class="lvl-5">是否启用 / 禁用某个用户</li></ul></li><li class="lvl-2"><p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p></li></ul><h2 id="Redis-ACL-的使用">Redis ACL 的使用</h2><ul class="lvl-0"><li class="lvl-2"><p>在 <code>redis.conf</code> 中添加如下内容：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 ACL 文件</span></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"><span class="comment"># 关闭 密码</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p></li></ul><h3 id="ACL-的配置方式">ACL 的配置方式</h3><h4 id="直接编辑-aclfile">直接编辑 aclfile</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置一个管理员</span></span><br><span class="line">user admin on ~* &amp;* +@all &gt;password</span><br><span class="line"><span class="comment"># 配置一个应用用户</span></span><br><span class="line">user appuser on  ~cache:* &amp;app:* +get +<span class="built_in">set</span> &gt;password</span><br><span class="line"><span class="comment"># 配置一个只读用户</span></span><br><span class="line">user <span class="built_in">readonly</span> on ~* -@all +@<span class="built_in">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p></li><li class="lvl-2"><p>格式说明</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user: 固定前缀</span><br><span class="line">username: 用户名</span><br><span class="line">on: 启用 off: 禁用</span><br><span class="line">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class="line">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class="line">+<span class="built_in">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class="built_in">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class="built_in">cat</span> 命令查看，以@开头，比如 @<span class="built_in">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class="line">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际上就是一个超级管理员权限</span></span><br><span class="line">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class="line"><span class="comment"># 如果设置了 requirepass 密码</span></span><br><span class="line">user default on sanitize-payload <span class="comment">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭默认用户，禁止匿名访问</span></span><br><span class="line">user default off</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接时直接登录, --pass == -a</span></span><br><span class="line">redis-cli --user username --pass password -h host -p port</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class="line"><span class="comment"># 本机登录</span></span><br><span class="line">redis-cli -u redis://admin:123456@</span><br><span class="line"><span class="comment"># 本机登录时端口不是默认的6379时</span></span><br><span class="line">redis-cli -u redis://admin:123456@:6380</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先连接后登录</span></span><br><span class="line">redis-cli -h host -p port</span><br><span class="line">&gt; auth username password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis ACL 规则中文说明</p></li></ul><table><thead><tr><th>规则 / 语法</th><th>中文说明</th></tr></thead><tbody><tr><td><code>on</code></td><td>启用用户：可以使用该用户进行认证登录</td></tr><tr><td><code>off</code></td><td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td></tr><tr><td><code>skip-sanitize-payload</code></td><td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td></tr><tr><td><code>sanitize-payload</code></td><td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td></tr><tr><td><code>+&lt;command&gt;</code></td><td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td></tr><tr><td><code>-&lt;command&gt;</code></td><td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td></tr><tr><td><code>+@&lt;category&gt;</code></td><td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td></tr><tr><td><code>@all</code></td><td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td></tr><tr><td><code>+&lt;command&gt;|first-arg</code></td><td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td></tr><tr><td><code>allcommands</code></td><td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td></tr><tr><td><code>nocommands</code></td><td><code>-@all</code> 的别名，禁止所有命令</td></tr><tr><td><code>~&lt;pattern&gt;</code></td><td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td></tr><tr><td><code>%R~&lt;pattern&gt;</code></td><td>添加<strong>允许读取</strong>的 key 模式</td></tr><tr><td><code>%W~&lt;pattern&gt;</code></td><td>添加<strong>允许写入</strong>的 key 模式</td></tr><tr><td><code>allkeys</code></td><td><code>~*</code> 的别名，允许所有 key</td></tr><tr><td><code>resetkeys</code></td><td>清空允许访问的 key 模式</td></tr><tr><td><code>&amp;&lt;pattern&gt;</code></td><td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td></tr><tr><td><code>allchannels</code></td><td><code>&amp;*</code> 的别名，允许所有 channel</td></tr><tr><td><code>resetchannels</code></td><td>清空 Pub/Sub channel 模式列表</td></tr><tr><td><code>&gt;&lt;password&gt;</code></td><td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td></tr><tr><td><code>&lt;&lt;password&gt;</code></td><td>移除指定密码</td></tr><tr><td><code>nopass</code></td><td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td></tr><tr><td><code>resetpass</code></td><td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td></tr><tr><td><code>reset</code></td><td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td></tr><tr><td><code>(&lt;options&gt;)</code></td><td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td></tr><tr><td><code>clearselectors</code></td><td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td></tr></tbody></table><h4 id="通过-ACL-命令">通过 ACL 命令</h4><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png" alt=""></p><h5 id="ACL-SETUSER">ACL SETUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>创建/修改用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 default 用户</span></span><br><span class="line">ACL SETUSER default off</span><br><span class="line"><span class="comment"># 创建一个管理员</span></span><br><span class="line">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class="line"><span class="comment"># 创建一个普通用户</span></span><br><span class="line">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class="built_in">set</span></span><br><span class="line"><span class="comment"># 创建一个只读用户</span></span><br><span class="line">ACL SETUSER <span class="built_in">readonly</span> on ~* -@all +@<span class="built_in">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p></li><li class="lvl-2"><p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">ACL SETUSER testuser on ~* -@all +@<span class="built_in">read</span> +ping  &gt;password</span><br><span class="line"><span class="comment"># 第二次执行，只添加新的权限</span></span><br><span class="line">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行后的结果</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure><h6 id="修改用户权限">修改用户权限</h6><ul class="lvl-0"><li class="lvl-2"><p>重置权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置所有权限</span></span><br><span class="line">ACL SETUSER testuser reset</span><br><span class="line"><span class="comment">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class="line"><span class="string">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>取消密码，但保留权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser nopass</span><br><span class="line"><span class="comment">## 运行结果：取消密码</span></span><br><span class="line"><span class="string">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>去除所有频道</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure><h5 id="ACL-LIST">ACL LIST</h5><ul class="lvl-0"><li class="lvl-2"><p>可以通过如下命令查看当前 Redis 中所有的用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACL LIST</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class="line">2) <span class="string">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class="line">3) <span class="string">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class="line">4) <span class="string">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user: 固定前缀</span><br><span class="line">username: 用户名</span><br><span class="line">on: 启用</span><br><span class="line">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class="line">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class="line">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class="line">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class="line">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class="line">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure><h5 id="ACL-LOAD">ACL LOAD</h5><ul class="lvl-0"><li class="lvl-2"><p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SAVE</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p></li></ul><h5 id="ACL-SAVE">ACL SAVE</h5><ul class="lvl-0"><li class="lvl-2"><p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL LOAD</span><br></pre></td></tr></table></figure><h5 id="ACL-USERS">ACL USERS</h5><ul class="lvl-0"><li class="lvl-2"><p>列出所有已创建的用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACL USERS</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;admin&quot;</span></span><br><span class="line">2) <span class="string">&quot;appuser&quot;</span></span><br><span class="line">3) <span class="string">&quot;default&quot;</span></span><br><span class="line">4) <span class="string">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure><h5 id="ACL-GETUSER">ACL GETUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>获取指定用户的权限信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER appuser</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) <span class="string">&quot;flags&quot;</span></span><br><span class="line"> 2) 1) <span class="string">&quot;on&quot;</span></span><br><span class="line">    2) <span class="string">&quot;sanitize-payload&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;passwords&quot;</span></span><br><span class="line"> 4) 1) <span class="string">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;commands&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;-@all +get +set&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;keys&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;~cache:*&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;channels&quot;</span></span><br><span class="line">10) <span class="string">&quot;&amp;app:*&quot;</span></span><br><span class="line">11) <span class="string">&quot;selectors&quot;</span></span><br><span class="line">12) (empty array)</span><br></pre></td></tr></table></figure><h6 id="selectors-选择器规则">selectors(选择器规则)</h6><ul class="lvl-0"><li class="lvl-2"><p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p></li><li class="lvl-2"><p>以前 = 一个用户一条规则</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根权限（全局规则）</span></span><br><span class="line">ACL SETUSER selectoruser on ~cache:* +get +<span class="built_in">set</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>现在 = 一个用户可以有多个“权限分身”</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择器规则</span></span><br><span class="line"><span class="comment"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class="line">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class="built_in">set</span>) &gt;123456</span><br><span class="line"><span class="comment">## 翻译后的结果</span></span><br><span class="line"><span class="string">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p></li></ul><h5 id="ACL-DELUSER">ACL DELUSER</h5><ul class="lvl-0"><li class="lvl-2"><p>删除一个用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure><h5 id="ACL-WHOAMI">ACL WHOAMI</h5><ul class="lvl-0"><li class="lvl-2"><p>获取当前登录的用户名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL WHOAMI</span><br></pre></td></tr></table></figure><h5 id="ACL-CAT">ACL CAT</h5><ul class="lvl-0"><li class="lvl-2"><p>获取所有权限类别</p></li><li class="lvl-2"><p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p></li><li class="lvl-2"><p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有权限类别</span></span><br><span class="line">ACL CAT</span><br><span class="line"><span class="comment"># 获取指定类别中的命令列表</span></span><br><span class="line">ACL CAT 分类名称</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p></li></ul><h5 id="ACL-DRYRUN">ACL DRYRUN</h5><ul class="lvl-0"><li class="lvl-2"><p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p></li><li class="lvl-2"><p>Redis 7.0.0 新增。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class="line"><span class="string">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure><h5 id="ACL-LOG">ACL LOG</h5><ul class="lvl-0"><li class="lvl-2"><p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p></li><li class="lvl-2"><p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACL LOG          <span class="comment"># 查看默认最新的 ACL 日志条目</span></span><br><span class="line">ACL LOG RESET    <span class="comment"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>日志格式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">&quot;count&quot;</span> =&gt; 1</span><br><span class="line">   2) <span class="string">&quot;reason&quot;</span> =&gt; <span class="string">&quot;command&quot;</span></span><br><span class="line">   3) <span class="string">&quot;context&quot;</span> =&gt; <span class="string">&quot;toplevel&quot;</span></span><br><span class="line">   4) <span class="string">&quot;object&quot;</span> =&gt; <span class="string">&quot;acl|log&quot;</span></span><br><span class="line">   5) <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;selectoruser&quot;</span></span><br><span class="line">   6) <span class="string">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class="line">   7) <span class="string">&quot;client-info&quot;</span> =&gt; <span class="string">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class="line">   8) <span class="string">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class="line">   9) <span class="string">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class="line">   10) <span class="string">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>count</code></td><td>触发该日志的次数。比如同一事件触发 1 次就是 1</td></tr><tr><td><code>reason</code></td><td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td></tr><tr><td><code>context</code></td><td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td></tr><tr><td><code>object</code></td><td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td></tr><tr><td><code>username</code></td><td>触发事件的用户</td></tr><tr><td><code>age-seconds</code></td><td>事件距离当前的时间（秒），越大表示越久远</td></tr><tr><td><code>client-info</code></td><td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td></tr><tr><td><code>entry-id</code></td><td>日志条目 ID</td></tr><tr><td><code>timestamp-created</code></td><td>日志创建时间（毫秒）</td></tr><tr><td><code>timestamp-last-updated</code></td><td>日志最后更新时间（毫秒）</td></tr></tbody></table><h5 id="ACL-GENPASS">ACL GENPASS</h5><ul class="lvl-0"><li class="lvl-2"><p>生成一个随机的 ACL 密码</p></li><li class="lvl-2"><p>生成复杂密码的工具有很多，没必要用这玩意。</p></li><li class="lvl-2"><p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class="line">&gt; ACL GENPASS</span><br><span class="line"><span class="string">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class="line"><span class="comment"># 指定长度，32/4 = 8</span></span><br><span class="line">&gt; ACL GENPASS 32</span><br><span class="line"><span class="string">&quot;355ef3dd&quot;</span></span><br><span class="line"><span class="comment"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class="line">&gt; ACL GENPASS 5</span><br><span class="line"><span class="string">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 7 + ACL 简介&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
    <category term="redis cluster" scheme="https://blog.hanqunfeng.com/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</title>
    <link href="https://blog.hanqunfeng.com/2025/12/05/redis7-config/"/>
    <id>https://blog.hanqunfeng.com/2025/12/05/redis7-config/</id>
    <published>2025-12-05T13:30:05.000Z</published>
    <updated>2025-12-10T02:58:13.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</li><li class="lvl-2">本文基于<code>redis-7.4.7</code></li><li class="lvl-2">传统的非ACL版本，可以参考 <a href="/2022/09/09/redis5-config/" title="Redis单节点、主从、哨兵、集群构建方法">Redis单节点、主从、哨兵、集群构建方法</a></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><span id="more"></span><h2 id="redis安装">redis安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载到指定目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft</span><br><span class="line">wget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft</span><br><span class="line">tar -zxvf redis-7.4.7.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="built_in">sudo</span> yum install gcc gcc-c++ -y</span><br><span class="line"><span class="built_in">cd</span> redis-7.4.7</span><br><span class="line"><span class="comment"># 编译，会将编译好的可执行文件放在src目录下</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> build_dir</span><br><span class="line">make install PREFIX=$(<span class="built_in">pwd</span>)/build_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件</span></span><br><span class="line"><span class="built_in">cp</span> redis.conf redis-6379.conf</span><br><span class="line">vim redis-6379.conf <span class="comment">#见下面的配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">redis-cli --version</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">redis-cli 7.4.7</span><br></pre></td></tr></table></figure><h2 id="单节点">单节点</h2><ul class="lvl-0"><li class="lvl-2"><p><code>redis-6379.conf</code> 的主要配置</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口，默认 6379</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动，默认 no</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yes: 当没有 bind / requirepass / ACL 时，只允许本机访问</span></span><br><span class="line"><span class="comment"># no: 允许任意访问</span></span><br><span class="line"><span class="comment"># 这里会启用ACL，所以设置为 yes，默认 yes</span></span><br><span class="line">protected-mode <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># 可以配置为，本机IP 内网IP 外网IP</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 10.250.0.103 18.163.188.20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照</span></span><br><span class="line"><span class="comment"># 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/soft/dir-redis7/6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no</span></span><br><span class="line"><span class="comment"># 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复</span></span><br><span class="line"><span class="comment"># 生成环境必须开启</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件名称，默认 appendonly.aof</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir</span></span><br><span class="line"><span class="comment"># redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：</span></span><br><span class="line"><span class="comment"># appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件</span></span><br><span class="line"><span class="comment"># appendonly.aof.N.incr.aof：记录每个写操作命令</span></span><br><span class="line"><span class="comment"># appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)</span></span><br><span class="line">appenddirname <span class="string">&quot;appendonlydir&quot;</span></span><br><span class="line"><span class="comment"># aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysec</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令</span></span><br><span class="line"><span class="comment"># 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb</span></span><br><span class="line"><span class="comment"># 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令</span></span><br><span class="line"><span class="comment"># 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb</span></span><br><span class="line"><span class="comment"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mb</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="comment"># aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes</span></span><br><span class="line"><span class="comment"># 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aof</span></span><br><span class="line">aof-use-rdb-preamble <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 防止 AOF 意外截断导致 Redis 起不来，默认 yes</span></span><br><span class="line">aof-load-truncated <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pid文件路径，默认 /var/run/redis_6379.pid</span></span><br><span class="line">pidfile <span class="string">&quot;redis_6379.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件名称，默认 &quot;&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定最大内存，单位bytes，这里设置4G</span></span><br><span class="line"><span class="comment"># 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降</span></span><br><span class="line">maxmemory 4294967296</span><br><span class="line"><span class="comment"># 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间</span></span><br><span class="line"><span class="comment"># volatile-lru: 只会淘汰「设置了过期时间」的 key</span></span><br><span class="line"><span class="comment"># allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的</span></span><br><span class="line"><span class="comment"># allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的</span></span><br><span class="line"><span class="comment"># noeviction: 不淘汰，默认</span></span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询日志</span></span><br><span class="line"><span class="comment"># 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录</span></span><br><span class="line">slowlog-max-len 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能优化</span></span><br><span class="line"><span class="comment"># Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了</span></span><br><span class="line">io-threads 4</span><br><span class="line"><span class="comment"># 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端</span></span><br><span class="line"><span class="comment"># 推荐&gt;=4核才开启，否则开了反而更慢</span></span><br><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着</span></span><br><span class="line">tcp-keepalive 60</span><br><span class="line"><span class="comment"># 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0</span></span><br><span class="line"><span class="comment"># 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放</span></span><br><span class="line"><span class="built_in">timeout</span> 0</span><br><span class="line"><span class="comment"># 最大客户端连接数，默认 10000</span></span><br><span class="line">maxclients 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令</span></span><br><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span></span><br><span class="line">rename-command FLUSHDB <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SHUTDOWN &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command KEYS &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SAVE &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command BGSAVE &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command DEBUG &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command EVAL &quot;&quot;</span></span><br><span class="line"><span class="comment"># rename-command SCRIPT &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。</span></span><br><span class="line">lazyfree-lazy-eviction <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。</span></span><br><span class="line">lazyfree-lazy-expire <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：</span></span><br><span class="line"><span class="comment">#    RENAME 替换旧 key 时删除旧 value</span></span><br><span class="line"><span class="comment">#    SET 操作覆盖旧值时删除旧 value</span></span><br><span class="line"><span class="comment">#    SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value</span></span><br><span class="line"><span class="comment">#    重写函数、脚本时删除旧对象</span></span><br><span class="line"><span class="comment"># 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。</span></span><br><span class="line">lazyfree-lazy-server-del <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。</span></span><br><span class="line"><span class="comment"># 此配置只影响副本不会影响主节点。</span></span><br><span class="line">replica-lazy-flush <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。</span></span><br><span class="line"><span class="comment"># 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。</span></span><br><span class="line"><span class="comment"># 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。</span></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"><span class="comment"># FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行</span></span><br><span class="line"><span class="comment"># 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。</span></span><br><span class="line">lazyfree-lazy-user-flush no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启 ACL 文件</span></span><br><span class="line">aclfile /usr/local/soft/redis-7.4.7/users.acl</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 7 支持的淘汰策略</p></li></ul><table><thead><tr><th>策略</th><th>是否只淘汰带 TTL 的 key</th><th>淘汰规则</th><th>说明</th></tr></thead><tbody><tr><td><strong>noeviction</strong></td><td>❌ 不淘汰</td><td>不删任何 key</td><td>内存满了直接返回错误（默认）</td></tr><tr><td><strong>allkeys-lru</strong></td><td>❌ 所有 key</td><td>最近最久未使用</td><td>✅ 最常用</td></tr><tr><td><strong>allkeys-lfu</strong></td><td>❌ 所有 key</td><td>访问频率最少</td><td>✅ 热点场景最好</td></tr><tr><td><strong>allkeys-random</strong></td><td>❌ 所有 key</td><td>随机删除</td><td>❌ 很少用</td></tr><tr><td><strong>volatile-lru</strong></td><td>✅ 只淘汰有 TTL 的</td><td>最近最久未使用</td><td>你之前用的</td></tr><tr><td><strong>volatile-lfu</strong></td><td>✅ 只淘汰有 TTL 的</td><td>访问频率最少</td><td>较少使用</td></tr><tr><td><strong>volatile-random</strong></td><td>✅ 只淘汰有 TTL 的</td><td>随机删除</td><td>很少用</td></tr><tr><td><strong>volatile-ttl</strong></td><td>✅ 只淘汰有 TTL 的</td><td>TTL 最小（马上过期的）</td><td>特殊场景用</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>users.acl</code> 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 <a href="/2025/12/07/redis7-acl/" title="Redis 7 + ACL 简介">Redis 7 + ACL 简介</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭默认用户，禁止匿名访问</span></span><br><span class="line">user default off</span><br><span class="line"><span class="comment"># 超级管理员</span></span><br><span class="line">user admin on ~* &amp;* +@all &gt;123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>redis 服务启动与关闭</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">redis-server redis-6379.conf</span><br><span class="line"><span class="comment"># 登录服务，本机访问可以省略 -h -p</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line"><span class="comment"># shutdown == shutdown save</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown</span><br><span class="line"><span class="comment"># 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以</span></span><br><span class="line">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave</span><br></pre></td></tr></table></figure><table><thead><tr><th>场景</th><th>推荐命令</th></tr></thead><tbody><tr><td>正常下线（生产）</td><td><code>shutdown nosave</code></td></tr><tr><td>已开 AOF</td><td><code>shutdown nosave</code></td></tr><tr><td>数据很大</td><td><code>shutdown nosave</code></td></tr><tr><td>单机调试</td><td><code>shutdown</code></td></tr><tr><td>确定要生成快照</td><td><code>shutdown save</code></td></tr><tr><td>强制杀死(redis卡死)</td><td><code>kill -9</code>（极端情况）</td></tr></tbody></table><h3 id="单节点优点">单节点优点</h3><ul class="lvl-0"><li class="lvl-2"><p>单机部署简单方便</p></li></ul><h3 id="单节点缺点">单节点缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>不保证数据的可靠性，不适用于数据可靠性要求高的场景</p></li><li class="lvl-2"><p>单点故障导致无法提供服务，或者硬盘损坏导致数据丢失</p></li><li class="lvl-2"><p>redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流</p></li></ul><h2 id="主从">主从</h2><ul class="lvl-0"><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master 10.250.0.235</span><br><span class="line">slave1 10.250.0.58</span><br><span class="line">slave2 10.250.0.36</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主从配置时，主节点不需要做任何修改</p></li><li class="lvl-2"><p>从节点配置文件增加同步主节点信息，其余配置与主节点相同</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号</span></span><br><span class="line">replicaof 10.250.0.235 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致</span></span><br><span class="line">replica-read-only <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class="line">masteruser admin</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时启动从节点<code>redis-server redis-6379.conf</code>，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步</p></li><li class="lvl-2"><p>主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点</p></li><li class="lvl-2"><p>主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点</p></li><li class="lvl-2"><p>从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式</p></li><li class="lvl-2"><p>此时登录master的redis并执行<code>info replication</code>命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master     <span class="comment"># 表示当前是从节点</span></span><br><span class="line">connected_slaves:1 <span class="comment"># 从节点数量</span></span><br><span class="line">slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 <span class="comment"># 从节点信息</span></span><br><span class="line">master_failover_state:no-failover <span class="comment"># 主节点切换状态，无</span></span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class="comment"># 主节点的复制ID</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:56  <span class="comment"># 主节点复制的偏移量</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1  <span class="comment"># 是否开启复制回放</span></span><br><span class="line">repl_backlog_size:1048576 <span class="comment"># 复制回放缓冲区大小</span></span><br><span class="line">repl_backlog_first_byte_offset:1 <span class="comment"># 复制回放缓冲区第一个字节的偏移量</span></span><br><span class="line">repl_backlog_histlen:56 <span class="comment"># 复制回放缓冲区历史长度</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时登录从节点的redis并执行<code>info replication</code>命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave               <span class="comment"># 表示当前是从节点</span></span><br><span class="line">master_host:10.250.0.235 <span class="comment"># 主节点的ip</span></span><br><span class="line">master_port:6379         <span class="comment"># 主节点的端口</span></span><br><span class="line">master_link_status:up    <span class="comment"># 主从节点连接状态，up 表示已经连接上主节点</span></span><br><span class="line">master_last_io_seconds_ago:6 <span class="comment"># 主从节点最后一次io操作时间</span></span><br><span class="line">master_sync_in_progress:0 <span class="comment"># 主从节点是否正在同步数据，0表示已完成</span></span><br><span class="line">slave_read_repl_offset:112 <span class="comment"># 从节点已经读取的复制偏移量</span></span><br><span class="line">slave_repl_offset:112   <span class="comment"># 从节点已经写入的复制偏移量</span></span><br><span class="line">slave_priority:100      <span class="comment"># 从节点的优先级</span></span><br><span class="line">slave_read_only:1       <span class="comment"># 从节点是否只读</span></span><br><span class="line">replica_announced:1     <span class="comment"># 从节点是否被其他节点所代理</span></span><br><span class="line">connected_slaves:0      <span class="comment"># 从节点所代理的从节点数量</span></span><br><span class="line">master_failover_state:no-failover <span class="comment"># 主节点的故障转移状态，no-failover表示没有进行故障转移</span></span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class="comment"># 主节点的复制ID</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:112  <span class="comment"># 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主从数据同步是否完成判断规则，在从节点上执行命令<code>info replication</code></p></li></ul><table><thead><tr><th>字段</th><th>正常值</th><th>说明</th></tr></thead><tbody><tr><td><code>role</code></td><td>slave</td><td>表示当前是从节点</td></tr><tr><td><code>master_link_status</code></td><td>up</td><td>表示已经连上主库</td></tr><tr><td><code>master_sync_in_progress</code></td><td>0</td><td>同步不在进行中 = 已完成</td></tr><tr><td><code>slave_read_repl_offset</code> ≈ <code>master_repl_offset</code></td><td>接近</td><td>说明数据已追上</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>参照上面的配置，再添加一个从节点后，在主节点执行命令 <code>info replication</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2  <span class="comment"># 从节点数量</span></span><br><span class="line">slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0</span><br><span class="line">slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0  <span class="comment"># 第二个从节点信息</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:4313</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:4313</span><br></pre></td></tr></table></figure><h3 id="主从优点">主从优点</h3><ul class="lvl-0"><li class="lvl-2"><p>对请求进行读写分离，提高处理效率</p></li><li class="lvl-2"><p>可以提供多个副本，提高数据安全性</p></li></ul><h3 id="主从缺点">主从缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p></li></ul><h2 id="哨兵">哨兵</h2><ul class="lvl-0"><li class="lvl-2"><p>创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵</p></li><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">master 10.250.0.235</span><br><span class="line">slave1 10.250.0.58</span><br><span class="line">slave2 10.250.0.36</span><br><span class="line">sentinel1 10.250.0.71</span><br><span class="line">sentinel2 10.250.0.131</span><br><span class="line">sentinel3 10.250.0.63</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别编辑各自的 <code>sentinel.conf</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir，需要提前创建好</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/soft/dir-redis7/sentinel</span><br><span class="line"></span><br><span class="line"><span class="comment"># pid文件路径</span></span><br><span class="line">pidfile redis-sentinel.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件名称</span></span><br><span class="line">logfile <span class="string">&quot;sentinel.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1</span></span><br><span class="line">sentinel monitor mymaster 10.250.0.235 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主观下线时间（5秒），默认30秒</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移超时时间 60秒，默认180秒</span></span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次允许多少个slave重新同步，默认就是 1</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># acl用户名和密码，这里为了方便也是用的管理员帐号</span></span><br><span class="line">sentinel auth-user mymaster admin</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动三个哨兵节点<code>redis-sentinel sentinel.conf</code>，此时登录哨兵节点<code>redis-cli -p 26379</code>，并执行<code>info Sentinel</code>命令，查看其是否正确识别了主从</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line">sentinel_masters:1      <span class="comment"># 哨兵集群中主从节点的数量</span></span><br><span class="line">sentinel_tilt:0         <span class="comment"># 是否处于 tilt 状态</span></span><br><span class="line">sentinel_tilt_since_seconds:-1 <span class="comment"># tilt 状态的开始时间</span></span><br><span class="line">sentinel_running_scripts:0 <span class="comment"># 正在运行的脚本数量</span></span><br><span class="line">sentinel_scripts_queue_length:0 <span class="comment"># 脚本队列长度</span></span><br><span class="line">sentinel_simulate_failure_flags:0 <span class="comment"># 模拟故障的标志</span></span><br><span class="line">master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 <span class="comment"># 主节点的地址，从节点数量和哨兵数量</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时查看<code>sentinel.conf</code>可以在文件最后看到从节点信息和其它的哨兵节点信息(<em><strong>但实测无法感知其它哨兵节点</strong></em>)，类似于</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">latency-tracking-info-percentiles 50 99 99.9  <span class="comment"># 延迟追踪信息百分比</span></span><br><span class="line">user default on nopass sanitize-payload ~* &amp;* +@all <span class="comment"># 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码</span></span><br><span class="line">sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 <span class="comment"># 本节点的id</span></span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line">sentinel current-epoch 0</span><br><span class="line"><span class="comment"># 一个从节点信息</span></span><br><span class="line">sentinel known-replica mymaster 10.250.0.58 6379</span><br><span class="line"><span class="comment"># 另一个从节点信息</span></span><br><span class="line">sentinel known-replica mymaster 10.250.0.36 6379</span><br><span class="line"><span class="comment"># 一个哨兵节点信息</span></span><br><span class="line">sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a</span><br><span class="line"><span class="comment"># 另一个哨兵节点信息</span></span><br><span class="line">sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看<code>info Sentinel</code>，就会发现master节点变成了从节点其中的一个了</p></li><li class="lvl-2"><p>此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">latency-tracking-info-percentiles 50 99 99.9</span><br><span class="line">replicaof 10.250.0.36 6379</span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class="line">masteruser admin</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>顺便说一下，关闭哨兵服务的命令如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 shutdown</span><br></pre></td></tr></table></figure><h3 id="哨兵优点">哨兵优点</h3><ul class="lvl-0"><li class="lvl-2"><p>主节点故障，可以自动在从节点中重新选主</p></li></ul><h3 id="哨兵缺点">哨兵缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载</p></li><li class="lvl-2"><p>从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离</p></li></ul><h2 id="集群">集群</h2><ul class="lvl-0"><li class="lvl-2"><p>搭建6个redis的集群，3主3从</p></li><li class="lvl-2"><p>规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis1 10.250.0.235</span><br><span class="line">redis2 10.250.0.58</span><br><span class="line">redis3 10.250.0.36</span><br><span class="line">redis4 10.250.0.71</span><br><span class="line">redis5 10.250.0.131</span><br><span class="line">redis6 10.250.0.63</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ACL认证，所有节点都要配置</span></span><br><span class="line">masteruser <span class="string">&quot;admin&quot;</span></span><br><span class="line">masterauth <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群节点信息文件，这里最好和port对应上</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，</span></span><br><span class="line"><span class="comment"># 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置</span></span><br><span class="line"><span class="comment"># 开启这个配置可以预防集群脑裂问题，默认为3</span></span><br><span class="line">min-replicas-to-write 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能</span></span><br><span class="line"><span class="comment"># 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败</span></span><br><span class="line">cluster-require-full-coverage <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动6个redis服务</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(<em><strong>删除dir配置的目录中的所有文件即可</strong></em>)，然后在任意一个redis执行</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># --cluster create：创建集群</span></span><br><span class="line"><span class="comment"># --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点</span></span><br><span class="line"><span class="comment"># 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时会列出集群内主从和槽位的分配方案，输入<code>yes</code>即可</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 10.250.0.131:6379 to 10.250.0.235:6379</span><br><span class="line">Adding replica 10.250.0.63:6379 to 10.250.0.58:6379</span><br><span class="line">Adding replica 10.250.0.71:6379 to 10.250.0.36:6379</span><br><span class="line">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class="line">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class="line">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class="line">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class="line">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class="line">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span></span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)</span><br><span class="line">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class="line">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class="line">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class="line">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录集群并查询集群配置信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 表示以集群模式登录，-h 集群内任意ip</span></span><br><span class="line">redis-cli --user admin --pass 123456 -c -h 10.250.0.235</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群信息</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster info</span><br><span class="line"><span class="comment"># 输出集群状态</span></span><br><span class="line">cluster_state:ok                                <span class="comment"># 集群整体状态：ok 表示集群当前可用、健康</span></span><br><span class="line">cluster_slots_assigned:16384                    <span class="comment"># 已分配的哈希槽数量（总槽数固定为 16384）</span></span><br><span class="line">cluster_slots_ok:16384                          <span class="comment"># 正常工作的槽数量（等于已分配槽，说明全部正常）</span></span><br><span class="line">cluster_slots_pfail:0                           <span class="comment"># 处于“疑似失败(pfail)”状态的槽数量</span></span><br><span class="line">cluster_slots_fail:0                            <span class="comment"># 被判定为失败(fail)的槽数量</span></span><br><span class="line">cluster_known_nodes:6                           <span class="comment"># 当前节点已知的集群节点总数（主节点 + 从节点）</span></span><br><span class="line">cluster_size:3                                  <span class="comment"># 主节点数量（3 主节点，典型的 3 主 3 从结构）</span></span><br><span class="line">cluster_current_epoch:6                         <span class="comment"># 集群当前的全局纪元（用于选举和配置同步）</span></span><br><span class="line">cluster_my_epoch:1                              <span class="comment"># 当前这个节点所在的纪元</span></span><br><span class="line">cluster_stats_messages_ping_sent:159           <span class="comment"># 当前节点已发送的 PING 消息数量（心跳）</span></span><br><span class="line">cluster_stats_messages_pong_sent:156           <span class="comment"># 当前节点已发送的 PONG 消息数量（心跳响应）</span></span><br><span class="line">cluster_stats_messages_sent:315                <span class="comment"># 当前节点发送的所有集群消息总数</span></span><br><span class="line">cluster_stats_messages_ping_received:151       <span class="comment"># 当前节点收到的 PING 消息数量</span></span><br><span class="line">cluster_stats_messages_pong_received:159       <span class="comment"># 当前节点收到的 PONG 消息数量</span></span><br><span class="line">cluster_stats_messages_meet_received:5         <span class="comment"># 当前节点收到的 MEET 消息数量（新节点加入发现）</span></span><br><span class="line">cluster_stats_messages_received:315            <span class="comment"># 当前节点收到的所有集群消息总数</span></span><br><span class="line">total_cluster_links_buffer_limit_exceeded:0    <span class="comment"># 因输出缓冲区超限被强制断开的集群连接数（0 = 正常）</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看节点列表</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment"># 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）</span></span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）</span></span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected</span><br><span class="line"><span class="comment"># 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）</span></span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected</span><br><span class="line"><span class="comment"># 主节点（master），负责槽位 10923-16383（集群中第三段槽位）</span></span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383</span><br><span class="line"><span class="comment"># 主节点（master），负责槽位 5461-10922（集群中第二段槽位）</span></span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时查看<code>nodes-6379.conf</code>也会看到和上面一样的节点信息</p></li><li class="lvl-2"><p>此时关闭其中一个master节点，比如<code>10.250.0.36</code>，则其对应的slave节点<code>10.250.0.71</code>会切换为新的master节点，此时<code>10.250.0.36</code>的状态最终变为<code>fail</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383</span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected</span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected</span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected</span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再次启动<code>10.250.0.36</code>，其会变成<code>10.250.0.71</code>的slave节点</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster nodes</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383</span><br><span class="line">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected</span><br><span class="line">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected</span><br><span class="line">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected</span><br><span class="line">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>若此时还是希望 <code>10.250.0.36</code> 做为主节点，则需要先登录<code>10.250.0.36</code>，再执行如下命令</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要加 -c</span></span><br><span class="line">redis-cli -c --user admin --pass 123456 -h 10.250.0.36</span><br><span class="line">10.250.0.36:6379&gt; cluster failover <span class="comment"># 安全版（等待复制同步）</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER <span class="comment"># TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐)</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT=CRC16(key) mod 16384</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转重定位</span></span><br><span class="line">10.250.0.235:6379&gt; <span class="built_in">set</span> name zhangsan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">-&gt; Redirected to slot [5798] located at 10.250.0.58:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>关闭集群，6个redis分别关闭</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启集群，6个redis分别启动即可</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- <code>&#123;xxx&#125;</code>，其必须用<code>&#123;&#125;</code>括起来，<code>xxx</code>可以是任意字符串，计算slot时，只会根据<code>xxx</code>来计算hash值，这样就保证了所有key中包含<code>&#123;xxx&#125;</code>的key都会落到同一个slot，<code>&#123;xxx&#125;</code>可以放在key的任意位置</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; mset name1 lisi name2 wangwu</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don<span class="string">&#x27;t hash to the same slot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwu</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2</span></span><br><span class="line"><span class="string">-&gt; Redirected to slot [5474] located at 10.250.0.58:6379</span></span><br><span class="line"><span class="string">1) &quot;lisi&quot;</span></span><br><span class="line"><span class="string">2) &quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:<br>{…} 让多个 key 落在同一个 slot，支持跨 key 原子操作<br>只有 第一个匹配的 {…} 会被当做 tag<br>{} 不能嵌套<br>空标签 {} 是非法的<br>{abc} 和 {def} 就落不同 slot</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如何判断 key 落在哪个节点?</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster keyslot name1</span><br><span class="line"><span class="comment"># 输出的数值就表示 slot</span></span><br><span class="line">(<span class="built_in">integer</span>) 5461 <span class="comment"># slot值</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如何查看指定的slot中有多少个key?</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.235:6379&gt; cluster countkeysinslot 5461</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 表示slot中key的个数，这里显示只有1个key</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源</p></li><li class="lvl-2"><p>集群通过<code>10000+port</code>这个端口号进行集群间通信，所以除了要开放<code>prot</code>这个端口，还要开放<code>10000+port</code>这个端口</p></li><li class="lvl-2"><p>有关redis集群及其水平扩展的进一步说明，可以参看<a href="/2018/12/27/redis-cluster/" title="Redis集群">Redis集群</a></p></li></ul><h3 id="集群优点">集群优点</h3><ul class="lvl-0"><li class="lvl-2"><p>无中心架构，集群内部自行维护数据的分片和主从的切换</p></li><li class="lvl-2"><p>数据分片存储，提供很高的访问效率</p></li><li class="lvl-2"><p>高可用性，可实现部分节点不可用时，集群仍可用</p></li><li class="lvl-2"><p>高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持</p></li></ul><h3 id="集群缺点">集群缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>数据通过异步复制，不保证数据的强一致性</p></li><li class="lvl-2"><p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0</p></li><li class="lvl-2"><p>不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作</p></li><li class="lvl-2"><p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点</p></li><li class="lvl-2"><p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能</p></li><li class="lvl-2"><p>不建议使用pipeline和multi-keys操作</p></li></ul><h3 id="redis-cli-的-Cluster-管理命令（用于管理-创建-调整集群）">redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群）</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>redis-cli --cluster create host1:port host2:port ...</code></td><td>创建 Redis Cluster 集群（自动分配 slots）</td><td><code>redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1</code></td></tr><tr><td><code>redis-cli --cluster check host:port</code></td><td>检查集群状态、健壮性</td><td><code>redis-cli --cluster check 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster info host:port</code></td><td>显示集群结构、节点、slots 分布</td><td><code>redis-cli --cluster info 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster fix host:port</code></td><td>修复 slots 移动、节点中断等异常状态</td><td><code>redis-cli --cluster fix 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster rebalance host:port</code></td><td>重新分布 slots（自动均衡负载）</td><td><code>redis-cli --cluster rebalance 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port</code></td><td>手动设置 rebalance 阈值；低于此阈值才会调整（百分比）</td><td><code>redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster add-node newHost:newPort existingHost:existingPort</code></td><td>将新节点加入集群</td><td><code>redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port</code></td><td>将新节点作为某主节点的 slave 加入</td><td><code>redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000</code></td></tr><tr><td><code>redis-cli --cluster del-node host:port node_id</code></td><td>从集群删除某节点（必须无 slots）</td><td><code>redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt;</code></td></tr><tr><td><code>redis-cli --cluster call host:port command ...</code></td><td>在所有节点上批量执行命令</td><td><code>redis-cli --cluster call 10.0.0.1:7000 PING</code></td></tr><tr><td><code>redis-cli --cluster help</code></td><td>显示 cluster 子命令帮助</td><td><code>redis-cli --cluster help</code></td></tr></tbody></table><h3 id="Redis-内置的-Cluster-操作命令">Redis 内置的 Cluster 操作命令</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CLUSTER INFO</code></td><td>查看集群状态、failover 状态、slot 分布统计</td><td><code>CLUSTER INFO</code></td></tr><tr><td><code>CLUSTER NODES</code></td><td>显示所有节点和角色（master/slave）</td><td><code>CLUSTER NODES</code></td></tr><tr><td><code>CLUSTER MYID</code></td><td>输出本节点 ID</td><td><code>CLUSTER MYID</code></td></tr><tr><td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td><td>将当前节点设置为某个 master 的 slave</td><td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td></tr><tr><td><code>CLUSTER FAILOVER</code></td><td>主动 failover（slave 升级为 master）</td><td>从节点执行：<code>CLUSTER FAILOVER</code></td></tr><tr><td><code>CLUSTER FAILOVER FORCE</code></td><td>不等待复制同步，立刻切主</td><td><code>CLUSTER FAILOVER FORCE</code></td></tr><tr><td><code>CLUSTER FAILOVER TAKEOVER</code></td><td>强制接管 slot（完全覆盖 master）（危险）</td><td><code>CLUSTER FAILOVER TAKEOVER</code></td></tr><tr><td><code>CLUSTER ADDSLOTS &lt;slot...&gt;</code></td><td>将 slots 分配给当前 master</td><td><code>CLUSTER ADDSLOTS 0 1 2</code></td></tr><tr><td><code>CLUSTER DELSLOTS &lt;slot...&gt;</code></td><td>从当前节点移除 slots</td><td><code>CLUSTER DELSLOTS 0 1 2</code></td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code></td><td>直接指定某个 slot 属于某个节点</td><td><code>CLUSTER SETSLOT 0 NODE &lt;id&gt;</code></td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt;</code></td><td>设定迁移 key 的源节点（用于 slot 迁移）</td><td>-</td></tr><tr><td><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt;</code></td><td>设定迁移 key 的目标节点（用于 slot 迁移）</td><td>-</td></tr><tr><td><code>CLUSTER KEYSLOT key</code></td><td>返回 key 所属 slot</td><td><code>CLUSTER KEYSLOT mykey</code></td></tr><tr><td><code>CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt;</code></td><td>查看某节点的 fail 票数</td><td>-</td></tr><tr><td><code>CLUSTER RESET</code></td><td>删除节点全部集群信息（用来重置为 standalone）</td><td><code>CLUSTER RESET HARD</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 7 + ACL 单节点、主从、哨兵、集群构建方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;传统的非ACL版本，可以参考 &lt;a href=&quot;/2022/09/09/redis5-config/&quot; title=&quot;Redis单节点、主从、哨兵、集群构建方法&quot;&gt;Redis单节点、主从、哨兵、集群构建方法&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
    <category term="redis cluster" scheme="https://blog.hanqunfeng.com/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>brew -- 创建自己的 Formula</title>
    <link href="https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/"/>
    <id>https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/</id>
    <published>2025-12-02T13:55:05.000Z</published>
    <updated>2025-12-02T09:45:42.092Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %--><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://brew.sh">brew</a>是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如<code>git</code>、<code>node</code>、<code>python</code>等。</p></li><li class="lvl-2"><p>本文介绍如何在macos下创建自己的 Formula</p></li><li class="lvl-2"><p>本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。</p></li><li class="lvl-2"><p>关于 brew 的安装及使用可以参考 <a href="/2024/11/28/brew/" title="MacOS软件包管理器--brew">MacOS软件包管理器--brew</a></p></li></ul><span id="more"></span><h2 id="从一个简单示例开始">从一个简单示例开始</h2><ul class="lvl-0"><li class="lvl-2"><p>这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看<a href="https://github.com/hanqunfeng/color_echo/blob/main/bin/color_echo">color_echo</a>，这是一个用于终端打印彩色文本的命令。</p></li></ul><h3 id="创建一个Github仓库，用于存储-color-echo-命令">创建一个Github仓库，用于存储 color_echo 命令</h3><ul class="lvl-0"><li class="lvl-2"><p>创建一个Github仓库，用于存储 <code>color_echo</code> 命令文件，仓库名称: <code>hanqunfeng/color_echo</code></p></li><li class="lvl-2"><p>编写命令文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> color_echo_dir</span><br><span class="line"><span class="built_in">cd</span> color_echo_dir</span><br><span class="line"><span class="comment"># 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了</span></span><br><span class="line"><span class="comment"># 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到</span></span><br><span class="line">bin/color_echo</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>提交代码并打Tag</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 color_echo_dir 目录下初始化仓库</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/hanqunfeng/color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment"># 创建Tag</span></span><br><span class="line">git tag v1.0.0</span><br><span class="line"><span class="comment"># 推送Tag</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取tag的sha256值</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz</span><br><span class="line">shasum -a 256 v1.0.0.tar.gz</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d  v1.0.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="发布-color-echo">发布 color_echo</h3><blockquote><p><code>brew create</code> 命令已经失效，需要手工创建</p></blockquote><h4 id="创建-tap-仓库">创建 tap 仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">brew tap-new hanqunfeng/color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Warning: tap-new is a developer <span class="built_in">command</span>, so Homebrew<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">developer mode has been automatically turned on.      # 提示开发者模式已自动打开</span></span><br><span class="line"><span class="string">To turn developer mode off, run:</span></span><br><span class="line"><span class="string">  brew developer off  # 如后续需要关闭开发者模式可以运行该命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 初始化仓库</span></span><br><span class="line"><span class="string">Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/</span></span><br><span class="line"><span class="string">[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap</span></span><br><span class="line"><span class="string"> 3 files changed, 107 insertions(+)</span></span><br><span class="line"><span class="string"> create mode 100644 .github/workflows/publish.yml</span></span><br><span class="line"><span class="string"> create mode 100644 .github/workflows/tests.yml</span></span><br><span class="line"><span class="string"> create mode 100644 README.md</span></span><br><span class="line"><span class="string">==&gt; Created hanqunfeng/color_echo</span></span><br><span class="line"><span class="string">/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When a pull request making changes to a formula (or formulae) becomes green</span></span><br><span class="line"><span class="string">(all checks passed), then you can publish the built bottles.</span></span><br><span class="line"><span class="string">To do so, label your PR as `pr-pull` and the workflow will be triggered.</span></span><br></pre></td></tr></table></figure><h4 id="手写一个-Formula-文件">手写一个 Formula 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formula</span><br><span class="line"><span class="built_in">touch</span> color_echo.rb</span><br></pre></td></tr></table></figure><p>写入内容（模板）：模板格式后面会详细介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ColorEcho &lt; Formula</span><br><span class="line">  desc <span class="string">&quot;Print colorful text in terminal&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://github.com/hanqunfeng/color_echo&quot;</span></span><br><span class="line">  url <span class="string">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span></span><br><span class="line">  sha256 <span class="string">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span></span><br><span class="line">  license <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  def install</span><br><span class="line">    bin.install <span class="string">&quot;bin/color_echo&quot;</span></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span> <span class="keyword">do</span></span><br><span class="line">    system <span class="string">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class="string">&quot;--help&quot;</span></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="提交-Formula-文件到Github仓库">提交 Formula 文件到Github仓库</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个Github仓库，用于存储 Formula 文件: <code>hanqunfeng/homebrew-color_echo</code></p></li><li class="lvl-2"><p>添加 Formula 文件到仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> $(brew --repo hanqunfeng/color_echo)</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Add color_echo 1.0.0&quot;</span></span><br><span class="line">git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Enumerating objects: 11, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限<code>repo</code> 和 <code>workflow</code>，重新推送</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥</span></span><br><span class="line">git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Enumerating objects: 11, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class="line">* [new branch]      main -&gt; main</span><br><span class="line">branch <span class="string">&#x27;main&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure><h4 id="安装-Formula">安装 Formula</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echo</span></span><br><span class="line">brew tap hanqunfeng/color_echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">brew search color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Formulae</span><br><span class="line">hanqunfeng/color_echo/color_echo              color-code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整包名搜索</span></span><br><span class="line">brew search hanqunfeng/color_echo/color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Formulae</span><br><span class="line">color_echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">brew install color_echo</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">==&gt; Fetching downloads <span class="keyword">for</span>: color_echo</span><br><span class="line">✔︎ Formula color_echo (1.0.0)                                   [Verifying     2.1KB/  2.1KB]</span><br><span class="line">==&gt; Installing color_echo from hanqunfeng/color_echo</span><br><span class="line">🍺  /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built <span class="keyword">in</span> 5 seconds</span><br><span class="line">==&gt; Running `brew cleanup color_echo`...</span><br><span class="line">Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.</span><br><span class="line">Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`).</span><br></pre></td></tr></table></figure><h4 id="测试-Formula">测试 Formula</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">color_echo --<span class="built_in">help</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">用法: color_echo [参数] 内容</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">  -c, --color &lt;color&gt;        设置前景色（文字颜色）</span><br><span class="line">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class="line"></span><br><span class="line">  -b, --<span class="built_in">bg</span> &lt;color&gt;           设置背景色</span><br><span class="line">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class="line"></span><br><span class="line">      --bold                 加粗字体</span><br><span class="line">      --underline            下划线</span><br><span class="line">      --italic               斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持）</span><br><span class="line"></span><br><span class="line">  -n                         不换行输出，兼容 <span class="built_in">echo</span> 的 -n 参数</span><br><span class="line"></span><br><span class="line">  -h, --<span class="built_in">help</span>                 显示帮助信息</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">  color_echo --color green <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  color_echo -c red -b yellow --bold <span class="string">&quot;Error Message&quot;</span></span><br><span class="line">  color_echo --underline <span class="string">&quot;This is underlined&quot;</span></span><br></pre></td></tr></table></figure><h2 id="formula-文件模板">formula 文件模板</h2><ul class="lvl-0"><li class="lvl-2"><p>Ruby语法，定义一个Formula的子类</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class 子类 &lt; 父类</span></span><br><span class="line">class ColorEcho &lt; Formula</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加属性</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc <span class="string">&quot;Print colorful text in terminal&quot;</span>  <span class="comment"># 描述</span></span><br><span class="line">homepage <span class="string">&quot;https://github.com/hanqunfeng/color_echo&quot;</span>  <span class="comment"># 项目地址</span></span><br><span class="line">url <span class="string">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span>  <span class="comment"># 下载地址，安装时会自动下载并解压</span></span><br><span class="line">sha256 <span class="string">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span>  <span class="comment"># sha256，校验v1.0.0.tar.gz</span></span><br><span class="line">license <span class="string">&quot;MIT&quot;</span>   <span class="comment"># 许可</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加安装方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def install  <span class="comment"># Homebrew 会执行的安装步骤，工作目录为解压后的文件目录</span></span><br><span class="line">  <span class="comment"># 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install</span></span><br><span class="line">  bin.install <span class="string">&quot;bin/color_echo&quot;</span> <span class="comment"># 将 bin/color_echo 安装到 /usr/local/bin/color_echo</span></span><br><span class="line">  <span class="comment"># 如果要指定安装后的命令名称，可以使用如下方式</span></span><br><span class="line">  <span class="comment"># bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果需要执行系统命令可以使用如下方式</span></span><br><span class="line">  <span class="comment"># system &quot;echo&quot;, &quot;hello world&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加测试方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> <span class="keyword">do</span>  <span class="comment"># Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码</span></span><br><span class="line">  <span class="comment"># system 指令用于执行系统命令，逗号分隔相当于空格</span></span><br><span class="line">  system <span class="string">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class="string">&quot;--help&quot;</span>  <span class="comment"># 相当于执行 color_echo --help</span></span><br><span class="line">  <span class="comment"># 断言测试</span></span><br><span class="line">  <span class="comment"># assert_equal &quot;2\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>#{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同</p></blockquote><table><thead><tr><th>系统 / 架构</th><th>实际路径示例</th></tr></thead><tbody><tr><td>Intel Mac</td><td><code>/usr/local/Cellar/color_echo/1.0.0/bin</code></td></tr><tr><td>Apple Silicon</td><td><code>/opt/homebrew/Cellar/color_echo/1.0.0/bin</code></td></tr><tr><td>Linuxbrew</td><td><code>/home/linuxbrew/.linuxbrew/Cellar/.../bin</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放在 def install 方法之前</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> <span class="comment"># 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; :build   <span class="comment"># 只在构建时需要</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; :<span class="built_in">test</span>    <span class="comment"># 测试时需要</span></span><br><span class="line">depends_on <span class="string">&quot;jq&quot;</span> =&gt; [:build, :<span class="built_in">test</span>] <span class="comment"># 构建和测试都需要</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境约束</span></span><br><span class="line">depends_on macos: :sonoma          <span class="comment"># 仅 macOS Sonoma</span></span><br><span class="line">depends_on <span class="built_in">arch</span>: :x86_64           <span class="comment"># 仅 x86_64</span></span><br><span class="line">depends_on xcode: [<span class="string">&quot;9.3&quot;</span>, :build]  <span class="comment"># 仅当 Xcode≥9.3 且用于 build</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖第三方库中的命令要用完整包名</span></span><br><span class="line">depends_on <span class="string">&quot;hanqunfeng/color_echo/color_echo&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><ul class="lvl-0"><li class="lvl-2"><p>关于更多的 Formula 文件模板，可以参考：<a href="https://docs.brew.sh/Formula-Cookbook">https://docs.brew.sh/Formula-Cookbook</a></p></li><li class="lvl-2"><p>同时也可以通过 <code>brew edit xxx</code> 命令查看该 Formula 文件的内容进行学习</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

--&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://brew.sh&quot;&gt;brew&lt;/a&gt;是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如&lt;code&gt;git&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍如何在macos下创建自己的 Formula&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;关于 brew 的安装及使用可以参考 &lt;a href=&quot;/2024/11/28/brew/&quot; title=&quot;MacOS软件包管理器--brew&quot;&gt;MacOS软件包管理器--brew&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="macos" scheme="https://blog.hanqunfeng.com/categories/macos/"/>
    
    
    <category term="macos" scheme="https://blog.hanqunfeng.com/tags/macos/"/>
    
    <category term="brew" scheme="https://blog.hanqunfeng.com/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令--lsof</title>
    <link href="https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/"/>
    <id>https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/</id>
    <published>2025-11-26T13:30:05.000Z</published>
    <updated>2025-11-27T02:50:52.836Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote % --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 lsof 命令的使用方法</p></li><li class="lvl-2"><p>本文基于CentOS8。</p></li></ul><span id="more"></span><h2 id="lsof-是什么？">lsof 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>lsof = list open files</p></li><li class="lvl-2"><p>它用来查看：</p><ul class="lvl-2"><li class="lvl-4">当前系统中所有进程打开的文件</li><li class="lvl-4">包含普通文件、目录、socket、管道、网络连接、设备等</li></ul></li><li class="lvl-2"><p>在 Linux 中：“一切皆文件”</p></li><li class="lvl-2"><p>所以你可以用 lsof 查看：</p><ul class="lvl-2"><li class="lvl-4">谁在占用你的端口？</li><li class="lvl-4">哪个进程正在读/写某个文件？</li><li class="lvl-4">为什么文件删除了却还占磁盘？</li><li class="lvl-4">哪个文件被锁住？</li><li class="lvl-4">哪些程序在访问某个目录？</li></ul></li><li class="lvl-2"><p>CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lsof -y</span><br></pre></td></tr></table></figure><h2 id="lsof-的基本用法">lsof 的基本用法</h2><h3 id="查看被删除但仍被占用的文件">查看被删除但仍被占用的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了<code>rm</code>命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。</p></li><li class="lvl-2"><p>文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 中看不到</span><br><span class="line"><span class="built_in">du</span> 不会统计空间</span><br><span class="line">只有 lsof 能看到，这是典型的 “deleted but still open” 状态。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时可以通过如下命令查询哪些被删除的文件还被占用：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 link count 小于 1 的（deleted）文件</span></span><br><span class="line">lsof +L1</span><br><span class="line"><span class="comment"># 列出所有被删除的文件</span></span><br><span class="line">lsof | grep deleted</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果查询到这种文件，则需要停止进程，才能真正删除文件。</p></li></ul><div class="tips"><p><em><strong>记一次线上服务器磁盘空间告警问题排查</strong></em></p><ul class="lvl-1"><li class="lvl-2">监控系统告警磁盘空间小于15%，通过如下命令查看确实如此</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -hT</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Filesystem Type  Size Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda1 ext4  7.9G 3.3G 4.6G  42%  /</span><br><span class="line">tmpfs      tmpfs 2.0G 0    2.0G  0%   /dev/shm</span><br><span class="line">/dev/xvdf1 ext4  99G  80G  15G   85%  /usr/local/boss/logs</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">du</span> -sh /usr/local/boss/logs</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">2.3G    /usr/local/boss/logs</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsof +L1</span><br><span class="line"><span class="comment">## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄</span></span><br><span class="line">COMMAND    PID      USER    FD      TYPE    DEVICE  SIZE/OFF      NLINK   NODE    NAME</span><br><span class="line">java       1836     boss    1w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br><span class="line">java       1836     boss    2w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。</li></ul></div><h3 id="查端口被哪个进程占用">查端口被哪个进程占用</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出指定端口对应的进程</span></span><br><span class="line">lsof -i tcp:8080</span><br><span class="line"><span class="comment"># 协议可以省略</span></span><br><span class="line">lsof -i :8080</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:webcache (LISTEN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将服务名称替换为端口</span></span><br><span class="line">lsof -i :8080 -P</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:8080 (LISTEN)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看某个进程打开的所有文件">查看某个进程打开的所有文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE     DEVICE  SIZE/OFF       NODE NAME</span><br><span class="line">java    18548 boss  cwd    DIR      202,1      4096      35377 /home/boss</span><br><span class="line">java    18548 boss  rtd    DIR      202,1      4096          2 /</span><br><span class="line">java    18548 boss  mem    REG      202,1 106065056      60671 /usr/lib/locale/locale-archive</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>能看到这个进程：</p><ul class="lvl-2"><li class="lvl-4">打开的日志文件</li><li class="lvl-4">使用的 jar 文件</li><li class="lvl-4">使用的 socket</li><li class="lvl-4">使用的 config 文件</li></ul></li><li class="lvl-2"><p>输出结果字段说明</p></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>COMMAND</td><td>程序名（java）</td></tr><tr><td>PID</td><td>进程号（18548）</td></tr><tr><td>USER</td><td>运行用户（boss）</td></tr><tr><td>FD</td><td>文件描述符</td></tr><tr><td>TYPE</td><td>文件类型</td></tr><tr><td>DEVICE</td><td>所在磁盘分区 ID</td></tr><tr><td>SIZE/OFF</td><td>文件大小（字节）</td></tr><tr><td>NODE</td><td>inode 编号</td></tr><tr><td>NAME</td><td>文件名（或网络连接信息）</td></tr></tbody></table><h3 id="查看指定用户占用的文件">查看指定用户占用的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出用户 boss 所有进程打开的文件</span></span><br><span class="line">lsof -u &lt;USER&gt;</span><br></pre></td></tr></table></figure><h3 id="查看指定程序-COMMAND-打开的文件">查看指定程序(COMMAND)打开的文件</h3><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令查询：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="查某个目录或文件正在被哪些进程占用">查某个目录或文件正在被哪些进程占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目录 +D</span></span><br><span class="line"><span class="comment"># 能显示所有正在访问该目录中文件的进程</span></span><br><span class="line">lsof +D /home/boss/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件</span></span><br><span class="line">lsof /home/boss/logs/access.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只列出 nginx 用户占用的文件目录中的哪些文件</span></span><br><span class="line"><span class="comment"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class="line">lsof -a -u nginx +D /usr/local/nginx/logs</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看网络连接">查看网络连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br><span class="line"><span class="comment"># 过滤协议</span></span><br><span class="line">lsof -i tcp</span><br><span class="line">lsof -i udp</span><br><span class="line"><span class="comment"># 过滤状态</span></span><br><span class="line">lsof -i -s tcp:listen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有监听端口，</span></span><br><span class="line"><span class="comment"># -i: 显示网络相关的文件</span></span><br><span class="line"><span class="comment"># -P: 显示端口(不加-P则显示的是服务名)</span></span><br><span class="line"><span class="comment"># -n: 不将 IP 映射成主机名（禁用 DNS 查询）</span></span><br><span class="line"><span class="comment"># -s: 过滤显示连接状态</span></span><br><span class="line">lsof -i -P -n -s tcp:listen</span><br><span class="line"><span class="comment">## 输出示例</span></span><br><span class="line">mongod     1782     root    5u  IPv4       8697      0t0  TCP *:27017 (LISTEN)</span><br><span class="line">java       1808     boss   36u  IPv6       9221      0t0  TCP *:8082 (LISTEN)</span><br><span class="line">java       1808     boss   39u  IPv6       9230      0t0  TCP 127.0.0.1:7093 (LISTEN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出用户 boss 的网络连接</span></span><br><span class="line"><span class="comment"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class="line">lsof -a -u boss -i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用参数详解">常用参数详解</h2><table><thead><tr><th>参数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>-i</code></td><td>查看网络相关文件/端口</td><td><code>lsof -i</code></td></tr><tr><td><code>-i :端口</code></td><td>查看指定端口</td><td><code>lsof -i :8080</code></td></tr><tr><td><code>-p PID</code></td><td>查看某个进程所有打开文件</td><td><code>lsof -p 1836</code></td></tr><tr><td><code>-u 用户名</code></td><td>查看某个用户进程的打开文件</td><td><code>lsof -u nginx</code></td></tr><tr><td><code>-c 进程名关键字</code></td><td>查看某个进程名相关的文件</td><td><code>lsof -c java</code></td></tr><tr><td><code>+D 目录</code></td><td>查看目录中所有被访问的文件</td><td><code>lsof +D /usr/local/netqin/boss/netqin/logs</code></td></tr><tr><td><code>+L1</code></td><td>查找已删除但仍被打开的文件</td><td><code>lsof +L1</code>（=查找“(deleted)”占盘问题）</td></tr><tr><td><code>-d FD</code></td><td>查看指定文件描述符</td><td><code>lsof -d 1 -p 1836</code>（看进程 stdout）</td></tr><tr><td><code>-n</code></td><td>不做 DNS 解析，提高速度</td><td><code>lsof -i -n</code></td></tr><tr><td><code>-P</code></td><td>显示端口号（不解析为服务名）</td><td><code>lsof -i -P</code></td></tr><tr><td><code>-s</code></td><td>按连接状态过滤（TCP/UDP）</td><td><code>lsof -i -sTCP:LISTEN</code></td></tr><tr><td><code>-r</code></td><td>持续输出（实时监控）</td><td><code>lsof -i -r 1</code>（每秒刷新网络连接）</td></tr><tr><td><code>-a</code></td><td>逻辑 AND，不加 -a 都是 逻辑 OR</td><td><code>lsof -u boss -i</code>（列出用户 boss 的网络连接）</td></tr></tbody></table><h2 id="lsof-文件-FD-字段详细解释">lsof 文件 FD 字段详细解释</h2><ul class="lvl-0"><li class="lvl-2"><p>FD（文件描述符）格式总规则：数字 + 标志位</p></li><li class="lvl-2"><p>lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。</p></li><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10r   → FD=10，<span class="built_in">read</span> only（只读）</span><br><span class="line">1w    → FD=1，write only（只写）</span><br><span class="line">36u   → FD=36，<span class="built_in">read</span>/write（可读可写）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>解释</p></li></ul><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><strong>数字（0、1、2、3、10、36…）</strong></td><td>文件描述符编号</td></tr><tr><td><strong>字母（r / w / u）</strong></td><td>访问模式：读/写/读写</td></tr></tbody></table><table><thead><tr><th>FD 编号</th><th>标准含义</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>stdin（标准输入）</td></tr><tr><td><strong>1</strong></td><td>stdout（标准输出）</td></tr><tr><td><strong>2</strong></td><td>stderr（标准错误输出）</td></tr><tr><td><strong>3</strong> 及以上</td><td>进程打开的普通文件、日志、socket、管道等</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>特殊 FD 类型（没有数字）</p></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>cwd</code></td><td>当前工作目录，说明进程在这个目录下运行</td></tr><tr><td><code>rtd</code></td><td>进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs</td></tr><tr><td><code>txt</code></td><td>可执行文件本体</td></tr><tr><td><code>mem</code></td><td>内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件</td></tr></tbody></table><h2 id="lsof-文件-TYPE-字段详细解释">lsof 文件 TYPE 字段详细解释</h2><table><thead><tr><th>文件类型</th><th>全称</th><th>含义</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>REG</strong></td><td>Regular file</td><td>普通文件</td><td>日志、配置、可执行程序等</td></tr><tr><td><strong>DIR</strong></td><td>Directory</td><td>目录</td><td>进程访问的目录，例如当前工作目录</td></tr><tr><td><strong>CHR</strong></td><td>Character special file</td><td>字符设备文件</td><td><code>/dev/null</code>、<code>/dev/tty</code>、串口、键盘等</td></tr><tr><td><strong>BLK</strong></td><td>Block special file</td><td>块设备文件</td><td><code>/dev/sda</code>、硬盘、分区等</td></tr><tr><td><strong>FIFO</strong></td><td>Named pipe</td><td>命名管道</td><td>Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信</td></tr><tr><td><strong>sock</strong></td><td>Socket</td><td>套接字（Unix 域 socket）</td><td><code>/var/run/docker.sock</code>、MySQL UNix socket</td></tr><tr><td><strong>IPv4</strong></td><td>IPv4 socket</td><td>IPv4 网络连接/监听</td><td><code>TCP *:80</code>、<code>UDP 127.0.0.1:53</code></td></tr><tr><td><strong>IPv6</strong></td><td>IPv6 socket</td><td>IPv6 网络连接/监听</td><td><code>TCP [::]:22</code></td></tr><tr><td><strong>unix</strong></td><td>Unix domain socket</td><td>本地进程通信</td><td><code>/run/systemd/journal/stdout</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 lsof 命令的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文基于CentOS8。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    <category term="linux常用命令" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux常用命令" scheme="https://blog.hanqunfeng.com/tags/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>什么是 UTC？一篇人人都能看懂的科普文章</title>
    <link href="https://blog.hanqunfeng.com/2025/11/20/utc/"/>
    <id>https://blog.hanqunfeng.com/2025/11/20/utc/</id>
    <published>2025-11-20T14:30:05.000Z</published>
    <updated>2025-11-20T08:36:36.524Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。</p></li></ul><span id="more"></span><h2 id="一、为什么世界需要统一时间？">一、为什么世界需要统一时间？</h2><p>早期，每个城市甚至每个乡镇都根据 <strong>太阳位置</strong>确定时间：</p><ul class="lvl-0"><li class="lvl-2"><p>太阳在头顶就是 12 点</p></li><li class="lvl-2"><p>不同地方经度不同，每地时间都不同</p></li></ul><p>这种方法在本地没问题，但到了 <strong>跨区域铁路、通信、航海、航空、互联网时代</strong>，问题巨大：</p><blockquote><p>两地时间不统一，火车、舰队、订单、通信都没法同步记录。</p></blockquote><p>因此世界需要：</p><ul class="lvl-0"><li class="lvl-2"><p>一个 <strong>全球统一、精确的标准时间</strong></p></li><li class="lvl-2"><p>所有人、所有系统都能对齐使用</p></li></ul><p>UTC 就是在这个背景下诞生的。</p><hr><h2 id="二、UTC-是什么？">二、UTC 是什么？</h2><p>UTC 的全称：</p><blockquote><p><strong>Coordinated Universal Time（协调世界时）</strong></p></blockquote><p>它是当今全球使用的 <strong>标准时间系统</strong>。</p><p>它的主要特点：</p><ul class="lvl-0"><li class="lvl-2"><p>不是某个国家的时间</p></li><li class="lvl-2"><p>是国际组织共同维护</p></li><li class="lvl-2"><p>全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准</p></li></ul><p>一句话：</p><blockquote><p><strong>UTC 是现代世界共同使用的“世界时间”。</strong></p></blockquote><hr><h2 id="三、UTC-和-GMT-的关系">三、UTC 和 GMT 的关系</h2><p>很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。</p><table><thead><tr><th>项目</th><th>GMT</th><th>UTC</th></tr></thead><tbody><tr><td>出现年代</td><td>19 世纪</td><td>1972 年</td></tr><tr><td>基准</td><td>地球自转（天文时间）</td><td>原子钟（更精确）</td></tr><tr><td>是否仍是标准</td><td>已被替代</td><td>当前唯一标准</td></tr></tbody></table><p>但在日常使用中：</p><blockquote><p><strong>UTC ≈ GMT（同为零时区）</strong></p></blockquote><p>所以：</p><ul class="lvl-0"><li class="lvl-2"><p>英国冬季使用 GMT（UTC+0）</p></li><li class="lvl-2"><p>技术系统使用 UTC（UTC+0）</p></li></ul><hr><h2 id="四、UTC-是如何确定的？">四、UTC 是如何确定的？</h2><p>UTC 并不是按太阳走，而是：</p><ul class="lvl-0"><li class="lvl-2"><p>由全世界 <strong>原子钟网络统一生成</strong></p></li><li class="lvl-2"><p>每秒误差小于 <strong>十亿分之一秒</strong></p></li><li class="lvl-2"><p>然后根据地球自转误差偶尔加“闰秒”</p></li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-12-31 23:59:60 UTC   ← 曾经加过闰秒</span><br></pre></td></tr></table></figure><p>这样：</p><ul class="lvl-0"><li class="lvl-2"><p>保证时间极其准确</p></li><li class="lvl-2"><p>又不会与地球真实昼夜偏离太多</p></li></ul><hr><h2 id="五、UTC-与时区">五、UTC 与时区</h2><p>UTC 是 0 时区。</p><p>所有时区都是 <strong>在 UTC 基础上加减偏移</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>北京时间：UTC + 8</p></li><li class="lvl-2"><p>纽约时间：UTC – 5（冬季）或 –4（夏令时）</p></li><li class="lvl-2"><p>日本时间：UTC + 9</p></li></ul><p>所以你常看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC+8 或 UTC-5</span><br></pre></td></tr></table></figure><p>表示该地区比 UTC 早或晚多少小时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC+8  &gt;  UTC+0  &gt;  UTC−5</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>换成生活语言：</p><ul class="lvl-2"><li class="lvl-4">UTC+8（例如北京时间）比 UTC 早 8 小时</li><li class="lvl-4">UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时</li></ul></li><li class="lvl-2"><p>举例：</p><ul class="lvl-2"><li class="lvl-4">UTC(即UTC+0) 时间是 12:00</li><li class="lvl-4">UTC+8 = 20:00（已经晚上）</li><li class="lvl-4">UTC−5 = 07:00（还在早上）</li></ul></li></ul><hr><h2 id="六、UTC-在计算机世界的重要性">六、UTC 在计算机世界的重要性</h2><p>几乎所有 IT 系统都推荐：</p><blockquote><p><strong>存储用 UTC，展示给用户再转换成当地时区。</strong></p></blockquote><p>原因很简单：</p><ul class="lvl-0"><li class="lvl-2"><p>全球一致，不会混乱</p></li><li class="lvl-2"><p>不受时区或夏令时影响</p></li><li class="lvl-2"><p>跨国系统日志可对齐分析</p></li></ul><p>你在日志里经常见到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025-11-20T08:30:00Z</span><br></pre></td></tr></table></figure><p>结尾的 <code>Z</code> 就表示：</p><blockquote><p><strong>这是 UTC 时间</strong></p></blockquote><hr><h2 id="七、UTC、GMT、CST-总结对比">七、UTC、GMT、CST 总结对比</h2><table><thead><tr><th>名称</th><th>全称</th><th>现在地位</th><th>是否标准</th></tr></thead><tbody><tr><td>UTC</td><td>Coordinated Universal Time</td><td>全球标准</td><td>✔</td></tr><tr><td>GMT</td><td>Greenwich Mean Time</td><td>被 UTC 替代</td><td>✖（历史含义）</td></tr><tr><td>CST</td><td>China Standard Time（中国）或 Central Standard Time（美国）</td><td>本地时区</td><td>不是世界统一基准</td></tr></tbody></table><p>注意：</p><blockquote><p>“CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。</p></blockquote><hr><h2 id="八、一句话总结">八、一句话总结</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>UTC 是现代全球统一的标准时间</strong></p></li><li class="lvl-2"><p><strong>所有时区都是相对于 UTC 偏移</strong></p></li><li class="lvl-2"><p><strong>计算机领域普遍使用 UTC 存储时间</strong></p></li><li class="lvl-2"><p><strong>GMT 是 UTC 的历史前身</strong></p></li><li class="lvl-2"><p><strong>北京时间 = UTC + 8</strong></p></li></ul><p>只要理解这几点，你已经掌握了世界时间体系的核心。</p>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="UTC" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/UTC/"/>
    
    
    <category term="UTC" scheme="https://blog.hanqunfeng.com/tags/UTC/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ ACL 2.0</title>
    <link href="https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/"/>
    <id>https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/</id>
    <published>2025-10-31T13:40:05.000Z</published>
    <updated>2025-10-31T15:11:43.114Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li><li class="lvl-2"><p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p></li></ul><span id="more"></span><h2 id="ACL-2-0-简介">ACL 2.0 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 <a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href="https://rocketmq.apache.org/zh/docs/bestPractice/03access">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p></li><li class="lvl-2"><p>在阿里云上找到一篇参考资料：<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a></p></li></ul><h2 id="配置步骤">配置步骤</h2><ul class="lvl-0"><li class="lvl-2"><p>本文在 <a href="/2025/10/23/rocketmq-01-install/" title="RocketMQ 的安装及使用">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p></li><li class="lvl-2"><p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker.conf</span></span><br><span class="line"><span class="comment"># 认证配置</span></span><br><span class="line">authenticationEnabled = <span class="literal">true</span></span><br><span class="line">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class="line">initAuthenticationUser = &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">innerClientAuthenticationCredentials = &#123;<span class="string">&quot;accessKey&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;secretKey&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class="line"><span class="comment"># 授权配置</span></span><br><span class="line">authorizationEnabled = <span class="literal">true</span></span><br><span class="line">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class="line">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数定义</th><th style="text-align:left">参数名称</th><th style="text-align:left">参数描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>authenticationEnabled</strong></td><td style="text-align:left">是否打开认证开关</td><td style="text-align:left">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td></tr><tr><td style="text-align:left"><strong>authenticationProvider</strong></td><td style="text-align:left">认证方式提供者</td><td style="text-align:left">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td></tr><tr><td style="text-align:left"><strong>initAuthenticationUser</strong></td><td style="text-align:left">系统初始化用户</td><td style="text-align:left">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>innerClientAuthenticationCredentials</strong></td><td style="text-align:left">组件间认证用户</td><td style="text-align:left">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>authenticationMetadataProvider</strong></td><td style="text-align:left">认证元数据提供者</td><td style="text-align:left">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td></tr><tr><td style="text-align:left"><strong>authenticationStrategy</strong></td><td style="text-align:left">认证策略</td><td style="text-align:left">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>重启启动所有 Broker</p></li></ul><h2 id="命令行管理用户">命令行管理用户</h2><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="用户管理">用户管理</h3><table><thead><tr><th style="text-align:left">接口定义</th><th style="text-align:left">接口名称</th><th style="text-align:left">接口参数</th></tr></thead><tbody><tr><td style="text-align:left"><strong>createUser</strong></td><td style="text-align:left">创建用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>updateUser</strong></td><td style="text-align:left">更新用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>deleteUser</strong></td><td style="text-align:left">删除用户</td><td style="text-align:left">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>getUser</strong></td><td style="text-align:left">查询用户详情</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>listUser</strong></td><td style="text-align:left">查询用户列表</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class="line"><span class="comment"># 创建用户，指定用户类型</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class="line"><span class="comment"># 更新用户</span></span><br><span class="line">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户详情</span></span><br><span class="line">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户列表</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询用户列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure><h3 id="权限管理">权限管理</h3><ul class="lvl-0"><li class="lvl-2"><p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p></li></ul><table><thead><tr><th style="text-align:left">命令名称</th><th style="text-align:left">操作定义</th><th style="text-align:left">命令参数及解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>createAcl</code></strong></td><td style="text-align:left">创建授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td></tr><tr><td style="text-align:left"><strong><code>updateAcl</code></strong></td><td style="text-align:left">更新授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td></tr><tr><td style="text-align:left"><strong><code>deleteAcl</code></strong></td><td style="text-align:left">删除授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td></tr><tr><td style="text-align:left"><strong><code>listAcl</code></strong></td><td style="text-align:left">查询授权列表</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td></tr><tr><td style="text-align:left"><strong><code>getAcl</code></strong></td><td style="text-align:left">查询授权详情</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建授权</span></span><br><span class="line">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class="line"><span class="comment"># 更新授权</span></span><br><span class="line">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class="line"><span class="comment"># 删除授权</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class="line"><span class="comment"># 删除授权，指定资源</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权列表</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询授权列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权详情</span></span><br><span class="line">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure><h2 id="Dashboard-配置">Dashboard 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h2 id="Proxy-配置">Proxy 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href="https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href="https://github.com/apache/rocketmq/tree/develop/example">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p></li><li class="lvl-2"><p>按照这篇文章<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;authenticationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;innerClientAuthenticationCredentials&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;accessKey\&quot;:\&quot;mqadmin\&quot;, \&quot;secretKey\&quot;:\&quot;1234567\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>异常信息如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.zcw159357.com/article/1/2025-03-15-0048.html">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enableAclRpcHookForClusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p></li><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.csdn.net/icebamboo2015/article/details/152118732">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p></li></ul><h2 id="后记">后记</h2><ul class="lvl-0"><li class="lvl-2"><p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ ACL 2.0 的使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ ACL 1.0</title>
    <link href="https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/"/>
    <id>https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/</id>
    <published>2025-10-29T13:40:05.000Z</published>
    <updated>2025-10-31T10:10:05.001Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ ACL 1.0 的使用方法。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li><li class="lvl-2"><p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p></li></ul><span id="more"></span><h2 id="ACL-1-0-简介">ACL 1.0 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。</p></li><li class="lvl-2"><p>一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。</p></li></ul><h2 id="ACL-1-0-使用方法">ACL 1.0 使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>本文在 <a href="/2025/10/23/rocketmq-01-install/" title="RocketMQ 的安装及使用">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 1.0。</p></li><li class="lvl-2"><p>首先需要在 Broker 节点开启 ACL 权限，在 <code>broker.conf</code> 文件中添加如下配置，并重启 Broker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclEnable=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>权限配置文件为 <code>conf/plain_acl.yml</code>，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1</span></span><br><span class="line"><span class="comment"># 白名单内的 IP 都可以访问，无需配置帐号</span></span><br><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局白名单外的IP,需要账号访问</span></span><br><span class="line"><span class="comment"># 账号配置，数组形式</span></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="comment"># 当前帐号的白名单</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">false</span>        <span class="comment"># 是否是管理员</span></span><br><span class="line">    <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span> <span class="comment"># 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class="line">    <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span>  <span class="comment"># 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class="line">    <span class="attr">topicPerms:</span>            <span class="comment"># 特定的 topic 权限</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicA=DENY</span>        <span class="comment"># topicName=perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicC=SUB</span></span><br><span class="line">    <span class="attr">groupPerms:</span>            <span class="comment"># 特定的 ConsumerGroup 权限</span></span><br><span class="line">      <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupA=DENY</span>        <span class="comment"># groupName=perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupB=PUB|SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">    <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">true</span>         <span class="comment"># 是否是管理员,true 表示管理员,管理员可以访问所有资源</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>权限定义</p></li></ul><table><thead><tr><th style="text-align:left">权限值</th><th style="text-align:left">含义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>DENY</strong></td><td style="text-align:left">拒绝</td><td style="text-align:left">禁止对该 Topic 的任何操作（无论是发送还是订阅）</td></tr><tr><td style="text-align:left"><strong>ANY</strong></td><td style="text-align:left">任意权限</td><td style="text-align:left">具有发布（PUB）和订阅（SUB）双重权限</td></tr><tr><td style="text-align:left"><strong>PUB</strong></td><td style="text-align:left">发送权限</td><td style="text-align:left">允许生产者向该 Topic 发送消息</td></tr><tr><td style="text-align:left"><strong>SUB</strong></td><td style="text-align:left">订阅权限</td><td style="text-align:left">允许消费者订阅并消费该 Topic 的消息</td></tr></tbody></table><div class="tips"><p><em><strong>defaultGroupPerm: SUB</strong></em></p><ul class="lvl-1"><li class="lvl-2">表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。</li></ul></div><h3 id="命令行配置-ACL">命令行配置 ACL</h3><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><blockquote><p>以下命令执行后会自动修改 <code>conf/plain_acl.yml</code> 文件</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>添加白名单</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin updateGlobalWhiteAddr \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -g 10.250.0.*,10.252.*.*,10.20.0.31</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一必填</td><td style="text-align:left">指定要更新白名单的 <strong>Broker 地址</strong></td><td style="text-align:left"><code>127.0.0.1:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一必填</td><td style="text-align:left">指定要更新白名单的 <strong>Cluster 名称</strong>，集群内所有 Broker 都会被更新</td><td style="text-align:left"><code>DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">要设置的全局白名单地址列表，支持通配符</td><td style="text-align:left"><code>&quot;10.10.103.*,192.168.0.*&quot;</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 ACL 配置文件路径（Broker 端对应的配置文件路径）</td><td style="text-align:left"><code>/home/rocketmq/conf/plain_acl.yml</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建管理员</span></span><br><span class="line">sh bin/mqadmin updateAclConfig \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -a mqadmin \</span><br><span class="line">    -s 1234567 \</span><br><span class="line">    -m <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建普通用户</span></span><br><span class="line">sh bin/mqadmin updateAclConfig \</span><br><span class="line">  -c DefaultCluster \</span><br><span class="line">  -a rocketmq_user \</span><br><span class="line">  -s 12345678 \</span><br><span class="line">  -i <span class="string">&quot;PUB|SUB&quot;</span> \</span><br><span class="line">  -u SUB \</span><br><span class="line">  -t <span class="string">&quot;topicA=PUB|SUB,topicB=DENY&quot;</span> \</span><br><span class="line">  -g <span class="string">&quot;groupA=SUB,groupB=DENY&quot;</span> \</span><br><span class="line">  -w <span class="string">&quot;192.168.0.*&quot;</span> \</span><br><span class="line">  -n 127.0.0.1:9876</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th><th></th></tr></thead><tbody><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">用户名（accessKey）</td><td style="text-align:left"><code>rocketmq_user</code></td><td></td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">密码（secretKey）</td><td style="text-align:left"><code>12345678</code></td><td></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标 Broker 地址</td><td style="text-align:left"><code>127.0.0.1:10911</code></td><td></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标集群名称，集群中所有 Broker 都会被更新</td><td style="text-align:left"><code>DefaultCluster</code></td><td></td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 Group 权限列表</td><td style="text-align:left"><code>groupA=SUB,groupB=DENY</code></td><td></td></tr><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 Topic 权限列表</td><td style="text-align:left">`topicA=PUB</td><td>SUB,topicB=DENY`</td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置默认 Group 权限</td><td style="text-align:left"><code>SUB</code></td><td></td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置默认 Topic 权限</td><td style="text-align:left"><code>DENY</code></td><td></td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置 IP 白名单</td><td style="text-align:left"><code>&quot;10.10.10.*,192.168.1.*&quot;</code></td><td></td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left">可选</td><td style="text-align:left">是否设置为管理员账号</td><td style="text-align:left"><code>true</code> 或 <code>false</code></td><td></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td><td></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>删除用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin deleteAccessConfig \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -a mqadmin</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">要删除的用户名（accessKey）</td><td style="text-align:left"><code>rocketmq_user</code></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标 Broker 地址</td><td style="text-align:left"><code>127.0.0.1:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标集群名称（删除整个集群上的该账号）</td><td style="text-align:left"><code>DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td></tr></tbody></table><h2 id="Dashboard-配置">Dashboard 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">1234567</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Proxy-配置">Proxy 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href="https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href="https://github.com/apache/rocketmq/tree/develop/example">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p></li></ul><h3 id="目前有两种没什么意义的解决方法：">目前有两种没什么意义的解决方法：</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin updateGlobalWhiteAddr \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -g 10.250.0.*</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">为 Proxy 开启 <code>enableAclRpcHookForClusterMode</code></li></ol><ul class="lvl-2"><li class="lvl-6">修改<code>conf/rmq-proxy.json</code>文件，添加<code>enableAclRpcHookForClusterMode</code>参数</li></ul>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enableAclRpcHookForClusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">修改<code>conf/tools.yml</code>文件，配置帐号信息：</li></ul>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">重新启动Proxy即可</li></ul></li><li class="lvl-2"><p>两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息</p></li><li class="lvl-2"><p>但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ ACL 1.0 的使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Admin Tool</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/</id>
    <published>2025-10-28T13:40:05.000Z</published>
    <updated>2025-10-31T08:54:49.101Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Admin Tool 的常用命令。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="RocketMQ-Admin-Tool-简介">RocketMQ Admin Tool 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool">RocketMQ Admin Tool</a> 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。</p></li></ul><h2 id="Topic-相关命令">Topic 相关命令</h2><ul class="lvl-0"><li class="lvl-2"><p>创建或更新 Topic</p></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全称</th><th style="text-align:left">说明</th><th style="text-align:left">可选值 / 格式</th><th style="text-align:left">是否必填</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">主题名称</td><td style="text-align:left">字符串</td><td style="text-align:left">✅ 必填</td><td style="text-align:left"><code>-t MyTopic</code></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerAddr</code></td><td style="text-align:left">指定创建 Topic 的 Broker 地址（与 <code>-c</code> 二选一）</td><td style="text-align:left"><code>ip:port</code></td><td style="text-align:left">✅ 必填（与 <code>-c</code> 二选一）</td><td style="text-align:left"><code>-b 192.168.1.10:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--clusterName</code></td><td style="text-align:left">指定创建 Topic 的集群名（与 <code>-b</code> 二选一）</td><td style="text-align:left">字符串</td><td style="text-align:left">✅ 必填（与 <code>-b</code> 二选一）</td><td style="text-align:left"><code>-c DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址列表</td><td style="text-align:left">多个地址用 <code>;</code> 分隔</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-n 192.168.1.1:9876;192.168.1.2:9876</code></td></tr><tr><td style="text-align:left"><code>-r</code></td><td style="text-align:left"><code>--readQueueNums</code></td><td style="text-align:left">读队列数量，默认为8，始终保持 r == w</td><td style="text-align:left">整数</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-r 4</code></td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left"><code>--writeQueueNums</code></td><td style="text-align:left">写队列数量，默认为8，始终保持 r == w</td><td style="text-align:left">整数</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-w 4</code></td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--perm</code></td><td style="text-align:left">Topic 权限，默认为6</td><td style="text-align:left">2：写（W）<br>4：读（R）<br>6：读写（RW）</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-p 6</code></td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--order</code></td><td style="text-align:left">是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO”</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-o false</code></td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left"><code>--unit</code></td><td style="text-align:left">是否为单元（Unit）Topic（用于多租户隔离）</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-u false</code></td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--hasUnitSub</code></td><td style="text-align:left">是否有 Unit 订阅</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-s false</code></td></tr><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left">额外属性设置，用 <code>+</code> 表示添加、<code>-</code> 表示删除</td><td style="text-align:left">例：<code>+a=b,+c=d,-e</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-a &quot;+message.type=NORMAL&quot;</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">无</td><td style="text-align:left">否</td><td style="text-align:left"><code>-h</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topic</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br><span class="line"><span class="comment"># 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建</span></span><br><span class="line">sh bin/mqadmin updateTopic  -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic</span><br><span class="line"><span class="comment"># 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMAL</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a <span class="string">&quot;+message.type=NORMAL&quot;</span></span><br><span class="line"><span class="comment"># 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a <span class="string">&quot;+message.type=FIFO&quot;</span></span><br><span class="line"><span class="comment"># 指定权限，默认为 6：读写</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看与删除 Topic</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有 Topic，此时只打印 topic 列表</span></span><br><span class="line">sh bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class="line"><span class="comment"># 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Group</span></span><br><span class="line">sh bin/mqadmin topicList -n 127.0.0.1:9876 -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Topic，删除指定集群下的指定Topic</span></span><br><span class="line">sh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>其它 Topic 命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Topic 路由信息</span></span><br><span class="line">sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerDatas&quot;</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerAddrs&quot;</span>:&#123;0:<span class="string">&quot;10.250.0.188:11011&quot;</span>,1:<span class="string">&quot;10.250.0.31:10911&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-b&quot;</span>,</span><br><span class="line"><span class="string">&quot;cluster&quot;</span>:<span class="string">&quot;DefaultCluster&quot;</span>,</span><br><span class="line"><span class="string">&quot;enableActingMaster&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerAddrs&quot;</span>:&#123;0:<span class="string">&quot;10.250.0.31:11011&quot;</span>,1:<span class="string">&quot;10.250.0.188:10911&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-a&quot;</span>,</span><br><span class="line"><span class="string">&quot;cluster&quot;</span>:<span class="string">&quot;DefaultCluster&quot;</span>,</span><br><span class="line"><span class="string">&quot;enableActingMaster&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;filterServerTable&quot;</span>:&#123;&#125;,</span><br><span class="line"><span class="string">&quot;queueDatas&quot;</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-b&quot;</span>,</span><br><span class="line"><span class="string">&quot;perm&quot;</span>:6,</span><br><span class="line"><span class="string">&quot;readQueueNums&quot;</span>:8,</span><br><span class="line"><span class="string">&quot;topicSysFlag&quot;</span>:0,</span><br><span class="line"><span class="string">&quot;writeQueueNums&quot;</span>:8</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-a&quot;</span>,</span><br><span class="line"><span class="string">&quot;perm&quot;</span>:6,</span><br><span class="line"><span class="string">&quot;readQueueNums&quot;</span>:8,</span><br><span class="line"><span class="string">&quot;topicSysFlag&quot;</span>:0,</span><br><span class="line"><span class="string">&quot;writeQueueNums&quot;</span>:8</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Topic 消息队列offset</span></span><br><span class="line">sh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Broker Name                      #QID  #Min Offset           #Max Offset             #Last Updated</span></span><br><span class="line">broker-a                          0     0                     3                       2025-10-27 03:08:43,112</span><br><span class="line">broker-a                          1     0                     4                       2025-10-27 06:13:21,968</span><br><span class="line">broker-a                          2     0                     2                       2025-10-27 06:13:34,685</span><br><span class="line">broker-a                          3     0                     2                       2025-10-26 05:44:17,222</span><br><span class="line">broker-a                          4     0                     1                       2025-10-26 05:44:45,513</span><br><span class="line">broker-a                          5     0                     1                       2025-10-26 06:13:10,541</span><br><span class="line">broker-a                          6     0                     2                       2025-10-26 02:58:34,393</span><br><span class="line">broker-a                          7     0                     1                       2025-10-25 12:42:41,189</span><br><span class="line">broker-b                          0     0                     1                       2025-10-25 14:01:24,836</span><br><span class="line">broker-b                          1     0                     2                       2025-10-26 06:14:24,411</span><br><span class="line">broker-b                          2     0                     0</span><br><span class="line">broker-b                          3     0                     0</span><br><span class="line">broker-b                          4     0                     0</span><br><span class="line">broker-b                          5     0                     1                       2025-10-25 12:30:57,672</span><br><span class="line">broker-b                          6     0                     1                       2025-10-26 06:19:47,051</span><br><span class="line">broker-b                          7     0                     1                       2025-10-26 06:14:49,216</span><br></pre></td></tr></table></figure><h2 id="集群相关命令">集群相关命令</h2><ul class="lvl-0"><li class="lvl-2"><p>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群信息</span></span><br><span class="line">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class="line">DefaultCluster          broker-a                0     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               2.60(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.03         0.3300          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-a                1     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  67.03         0.3200         <span class="literal">false</span></span><br><span class="line">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.80(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3200          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-b                1     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3300         <span class="literal">false</span></span><br><span class="line"><span class="comment">## Broker 统计信息</span></span><br><span class="line"><span class="comment">#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line"><span class="comment">#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)</span></span><br><span class="line"><span class="comment">#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)</span></span><br><span class="line"><span class="comment">#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计</span></span><br><span class="line"><span class="comment">#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好</span></span><br><span class="line"><span class="comment">#Hour: 表示 Broker 已运行的时长</span></span><br><span class="line"><span class="comment">#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%</span></span><br><span class="line"><span class="comment">#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群统计信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Cluster Name     #Broker Name                       #InTotalYest  #OutTotalYest  #InTotalToday #OutTotalToday</span></span><br><span class="line">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class="line">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class="line">DefaultCluster    broker-b                                      0            369              0              0</span><br><span class="line">DefaultCluster    broker-b                                      0              0              0              0</span><br><span class="line"><span class="comment">## Broker 统计信息</span></span><br><span class="line"><span class="comment">#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数</span></span><br><span class="line"><span class="comment">#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数</span></span><br><span class="line"><span class="comment">#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数</span></span><br><span class="line"><span class="comment">#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数</span></span><br></pre></td></tr></table></figure><h2 id="消息相关">消息相关</h2><h3 id="发送消息">发送消息</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">消息要发送的 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必须指定目标 Topic</td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--body</code></td><td style="text-align:left">消息体内容（UTF-8 字符串）</td><td style="text-align:center">✅</td><td style="text-align:left"><code>&quot;Hello RocketMQ&quot;</code></td><td style="text-align:left">实际消息内容</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">不指定则用默认配置</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--broker</code></td><td style="text-align:left">指定发送到哪个 broker</td><td style="text-align:center">❌</td><td style="text-align:left"><code>broker-a</code></td><td style="text-align:left">一般用于测试 Broker 状态</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--qid</code></td><td style="text-align:left">指定发送到的队列 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2</code></td><td style="text-align:left">一般不需要设置，RocketMQ 会自动选择</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--tags</code></td><td style="text-align:left">消息的标签（tag）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>testTag</code></td><td style="text-align:left">用于消息过滤</td></tr><tr><td style="text-align:left"><code>-k</code></td><td style="text-align:left"><code>--key</code></td><td style="text-align:left">消息的业务键（key）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>order123</code></td><td style="text-align:left">可用于追踪消息</td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left"><code>--msgTraceEnable</code></td><td style="text-align:left">是否开启消息轨迹</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">默认 <code>false</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令参数说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class="string">&quot;Hello RocketMQ&quot;</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Broker Name                      #QID  #Send Result            #MsgId</span></span><br><span class="line">broker-b                          2     SEND_OK                 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line"><span class="comment">## 输出解释</span></span><br><span class="line"><span class="comment">#Broker Name: Broker 名称</span></span><br><span class="line"><span class="comment">#QID: 队列 ID</span></span><br><span class="line"><span class="comment">#Send Result: 发送结果，SEND_OK 表示成功</span></span><br><span class="line"><span class="comment">#MsgId: 消息 ID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 tags、key</span></span><br><span class="line">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class="string">&quot;Hello RocketMQ&quot;</span> -c testTag -k order123</span><br></pre></td></tr></table></figure><h3 id="消费消息">消费消息</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">目标 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议填写以避免默认配置不生效</td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--consumerGroup</code></td><td style="text-align:left">消费组名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>TestGroup</code></td><td style="text-align:left">可指定消费组（影响消费位点）</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerName</code></td><td style="text-align:left">Broker 名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>broker-a</code></td><td style="text-align:left">指定从哪个 broker 拉取消息</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--queueId</code></td><td style="text-align:left">队列 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">默认从 0 号队列开始</td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--offset</code></td><td style="text-align:left">队列起始偏移量（offset）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">指定从哪个位置开始消费</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--MessageNumber</code></td><td style="text-align:left">消费消息数量</td><td style="text-align:center">❌</td><td style="text-align:left"><code>10</code></td><td style="text-align:left">默认通常为 1</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--beginTimestamp</code></td><td style="text-align:left">起始时间</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2025-10-28#10:00:00:000</code></td><td style="text-align:left">格式或时间戳均可</td></tr><tr><td style="text-align:left"><code>-e</code></td><td style="text-align:left"><code>--endTimestamp</code></td><td style="text-align:left">结束时间</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2025-10-28#12:00:00:000</code></td><td style="text-align:left">与 <code>-s</code> 一起使用</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令参数说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认从队列 0 开始消费，拉取全部消息</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic</span><br><span class="line"><span class="comment"># 拉取指定条数的消息，-c 指定拉取条数</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10</span><br><span class="line"><span class="comment"># 指定偏移量，此时必须同时指定 brokerName、queueId、offset</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3</span><br><span class="line"><span class="comment"># 指定消费者组</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup</span><br><span class="line"><span class="comment"># 指定时间范围</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000</span><br></pre></td></tr></table></figure><h4 id="消费结果">消费结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Consume ok</span><br><span class="line">MSGID: 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line">MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0,</span><br><span class="line">  bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362,</span><br><span class="line">  storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011,</span><br><span class="line">  msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881,</span><br><span class="line">  bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0,</span><br><span class="line">  toString()=Message&#123;topic=<span class="string">&#x27;TestTopic&#x27;</span>, flag=0,</span><br><span class="line">    properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000,</span><br><span class="line">      CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=<span class="literal">true</span>, TRACE_ON=<span class="literal">true</span>, MAX_OFFSET=1&#125;,</span><br><span class="line">    body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81],</span><br><span class="line">    transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]</span><br><span class="line">BODY: Hello RocketMQ</span><br><span class="line"></span><br><span class="line">MessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] <span class="built_in">print</span> msg finished. status=NO_NEW_MSG, offset=1</span><br><span class="line">The older -1 message of the 2 queue will be provided</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>📘 字段解析表格</p></li></ul><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">示例值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MSGID</strong></td><td style="text-align:left"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">消息唯一标识（客户端生成）</td></tr><tr><td style="text-align:left"><strong>brokerName</strong></td><td style="text-align:left"><code>broker-b</code></td><td style="text-align:left">消息存储在哪个 Broker 上</td></tr><tr><td style="text-align:left"><strong>queueId</strong></td><td style="text-align:left"><code>2</code></td><td style="text-align:left">存储的队列编号（TestTopic 有多个队列时的第 3 个）</td></tr><tr><td style="text-align:left"><strong>queueOffset</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">队列中的偏移量（从 0 开始）</td></tr><tr><td style="text-align:left"><strong>storeSize</strong></td><td style="text-align:left"><code>228</code></td><td style="text-align:left">消息在磁盘中的存储字节大小</td></tr><tr><td style="text-align:left"><strong>sysFlag</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">消息系统标志位（内部用途）</td></tr><tr><td style="text-align:left"><strong>bornTimestamp</strong></td><td style="text-align:left"><code>1761638706671</code></td><td style="text-align:left">消息在生产者端创建的时间（毫秒）</td></tr><tr><td style="text-align:left"><strong>bornHost</strong></td><td style="text-align:left"><code>/10.250.0.175:41362</code></td><td style="text-align:left">生产者客户端的 IP 和端口</td></tr><tr><td style="text-align:left"><strong>storeTimestamp</strong></td><td style="text-align:left"><code>1761638706691</code></td><td style="text-align:left">消息被 Broker 存储的时间（毫秒）</td></tr><tr><td style="text-align:left"><strong>storeHost</strong></td><td style="text-align:left"><code>/10.250.0.188:11011</code></td><td style="text-align:left">Broker 的存储节点地址</td></tr><tr><td style="text-align:left"><strong>msgId</strong></td><td style="text-align:left"><code>0AFA00BC00002B0300000000000CA1E9</code></td><td style="text-align:left">消息在 Broker 存储系统生成的唯一 ID</td></tr><tr><td style="text-align:left"><strong>commitLogOffset</strong></td><td style="text-align:left"><code>827881</code></td><td style="text-align:left">消息在 commitLog 文件中的偏移量</td></tr><tr><td style="text-align:left"><strong>bodyCRC</strong></td><td style="text-align:left"><code>1774740973</code></td><td style="text-align:left">消息体的 CRC 校验码（用于校验数据一致性）</td></tr><tr><td style="text-align:left"><strong>reconsumeTimes</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">被重新消费的次数（0 表示第一次消费）</td></tr><tr><td style="text-align:left"><strong>preparedTransactionOffset</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">如果是事务消息，这里会记录预提交偏移量；普通消息为 0</td></tr><tr><td style="text-align:left"><strong>topic</strong></td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">消息所属主题</td></tr><tr><td style="text-align:left"><strong>properties</strong></td><td style="text-align:left"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125;</code></td><td style="text-align:left">消息属性，包括系统属性与用户属性</td></tr><tr><td style="text-align:left"><strong>body</strong></td><td style="text-align:left"><code>[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81]</code></td><td style="text-align:left">消息体的字节数组</td></tr><tr><td style="text-align:left"><strong>BODY（解码后）</strong></td><td style="text-align:left"><code>Hello RocketMQ</code></td><td style="text-align:left">实际消息内容（UTF-8 字符串）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>⚙️ 消息状态说明</p></li></ul><table><thead><tr><th style="text-align:left">输出信息</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>Consume ok</code></td><td style="text-align:left">表示成功从 Broker 拉取消息</td></tr><tr><td style="text-align:left"><code>status=NO_NEW_MSG</code></td><td style="text-align:left">当前队列（queueId=2）中已经没有比 offset=1 更新的消息</td></tr><tr><td style="text-align:left"><code>offset=1</code></td><td style="text-align:left">当前队列消费到 offset=1（下次消费从此开始）</td></tr><tr><td style="text-align:left"><code>The older -1 message of the 2 queue will be provided</code></td><td style="text-align:left">这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息）</td></tr></tbody></table><h3 id="查询消息">查询消息</h3><h4 id="根据消息-ID-查询消息-queryMsgById">根据消息 ID 查询消息(queryMsgById)</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--msgId</code></td><td style="text-align:left">要查询的消息 ID</td><td style="text-align:center">✅</td><td style="text-align:left"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">必填，用于精确定位消息</td></tr><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">目标 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议明确指定</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--cluster</code></td><td style="text-align:left">集群名称或 LMQ 父 Topic</td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">在多集群场景下使用</td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--consumerGroup</code></td><td style="text-align:left">消费组名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>TestGroup</code></td><td style="text-align:left">当用于消费者关联查询时可指定</td></tr><tr><td style="text-align:left"><code>-d</code></td><td style="text-align:left"><code>--clientId</code></td><td style="text-align:left">消费者客户端 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>192.168.0.1@12345</code></td><td style="text-align:left">辅助定位消费实例</td></tr><tr><td style="text-align:left"><code>-f</code></td><td style="text-align:left"><code>--bodyFormat</code></td><td style="text-align:left">消息体输出格式</td><td style="text-align:center">❌</td><td style="text-align:left"><code>UTF-8</code> / <code>HEX</code> / <code>BASE64</code></td><td style="text-align:left">默认 UTF-8</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--sendMessage</code></td><td style="text-align:left">是否重新发送消息</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">调试时可使用</td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left"><code>--unitName</code></td><td style="text-align:left">单元名（多单元部署时使用）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>unit01</code></td><td style="text-align:left">一般场景可忽略</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">OffsetID:            0AFA00BC00002B0300000000000CA1E9</span><br><span class="line">Topic:               TestTopic</span><br><span class="line">Tags:                [null]</span><br><span class="line">Keys:                [null]</span><br><span class="line">Queue ID:            2</span><br><span class="line">Queue Offset:        0</span><br><span class="line">CommitLog Offset:    827881</span><br><span class="line">Reconsume Times:     0</span><br><span class="line">Born Timestamp:      2025-10-28 08:05:06,671</span><br><span class="line">Store Timestamp:     2025-10-28 08:05:06,691</span><br><span class="line">Born Host:           10.250.0.175:41362</span><br><span class="line">Store Host:          10.250.0.188:11011</span><br><span class="line">System Flag:         0</span><br><span class="line">Properties:          &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=<span class="literal">true</span>, TRACE_ON=<span class="literal">true</span>&#125;</span><br><span class="line">Message Body Path:   /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line">Message Body:        Hello RocketMQ</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>输出字段详解</p></li></ul><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>OffsetID</strong></td><td style="text-align:left">消息在 CommitLog 中的偏移标识（内部定位使用）</td><td style="text-align:left"><code>0AFA00BC00002B0300000000000CA1E9</code></td><td style="text-align:left">可用于 broker 内部追踪定位消息</td></tr><tr><td style="text-align:left"><strong>Topic</strong></td><td style="text-align:left">主题名称</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">消息所属的主题</td></tr><tr><td style="text-align:left"><strong>Tags</strong></td><td style="text-align:left">消息标签</td><td style="text-align:left"><code>[null]</code></td><td style="text-align:left">若生产消息时未设置 tag，则为 null</td></tr><tr><td style="text-align:left"><strong>Keys</strong></td><td style="text-align:left">消息键</td><td style="text-align:left"><code>[null]</code></td><td style="text-align:left">通常可用于业务层索引查询</td></tr><tr><td style="text-align:left"><strong>Queue ID</strong></td><td style="text-align:left">消息所在的队列编号</td><td style="text-align:left"><code>2</code></td><td style="text-align:left">对应 topic 的第 3 个队列（从 0 开始）</td></tr><tr><td style="text-align:left"><strong>Queue Offset</strong></td><td style="text-align:left">队列偏移量</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">表示是该队列的第一条消息</td></tr><tr><td style="text-align:left"><strong>CommitLog Offset</strong></td><td style="text-align:left">消息在 commitlog 文件中的偏移量</td><td style="text-align:left"><code>827881</code></td><td style="text-align:left">broker 存储层位置</td></tr><tr><td style="text-align:left"><strong>Reconsume Times</strong></td><td style="text-align:left">被重新消费的次数</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">表示未重试消费过</td></tr><tr><td style="text-align:left"><strong>Born Timestamp</strong></td><td style="text-align:left">消息生成时间</td><td style="text-align:left"><code>2025-10-28 08:05:06,671</code></td><td style="text-align:left">生产者发送消息的时间</td></tr><tr><td style="text-align:left"><strong>Store Timestamp</strong></td><td style="text-align:left">消息存储时间</td><td style="text-align:left"><code>2025-10-28 08:05:06,691</code></td><td style="text-align:left">broker 写入消息的时间（通常相差几毫秒）</td></tr><tr><td style="text-align:left"><strong>Born Host</strong></td><td style="text-align:left">生产者客户端 IP:端口</td><td style="text-align:left"><code>10.250.0.175:41362</code></td><td style="text-align:left">生产者所在机器</td></tr><tr><td style="text-align:left"><strong>Store Host</strong></td><td style="text-align:left">broker 存储该消息的地址</td><td style="text-align:left"><code>10.250.0.188:11011</code></td><td style="text-align:left">对应的 broker 服务端</td></tr><tr><td style="text-align:left"><strong>System Flag</strong></td><td style="text-align:left">系统标志位</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部使用（标识压缩/事务等）</td></tr><tr><td style="text-align:left"><strong>Properties</strong></td><td style="text-align:left">消息属性</td><td style="text-align:left"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;</code></td><td style="text-align:left">包含 RocketMQ 自动附加的元数据</td></tr><tr><td style="text-align:left"><strong>Message Body Path</strong></td><td style="text-align:left">消息体在本地保存的文件路径</td><td style="text-align:left"><code>/tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看</td></tr><tr><td style="text-align:left"><strong>Message Body</strong></td><td style="text-align:left">消息内容</td><td style="text-align:left"><code>Hello RocketMQ</code></td><td style="text-align:left">消息内容</td></tr></tbody></table><h4 id="根据消息-Key-查询消息-queryMsgByKey">根据消息 Key 查询消息(queryMsgByKey)</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">必填</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t, --topic</code></td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">要查询的主题名称</td></tr><tr><td style="text-align:left"><code>-k, --msgKey</code></td><td style="text-align:center">✅</td><td style="text-align:left"><code>order_10001</code></td><td style="text-align:left">发送消息时设置的业务 Key</td></tr><tr><td style="text-align:left"><code>-n, --namesrvAddr</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">NameServer 地址</td></tr><tr><td style="text-align:left"><code>-c, --cluster</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">指定集群名称（可选）</td></tr><tr><td style="text-align:left"><code>-b, --beginTimestamp</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>1730083200000</code></td><td style="text-align:left">查询起始时间戳（ms）</td></tr><tr><td style="text-align:left"><code>-e, --endTimestamp</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>1730173200000</code></td><td style="text-align:left">查询结束时间戳（ms）</td></tr><tr><td style="text-align:left"><code>-m, --maxNum</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>64</code></td><td style="text-align:left">返回的最大消息数，默认 64</td></tr><tr><td style="text-align:left"><code>-h, --help</code></td><td style="text-align:center">❌</td><td style="text-align:left">-</td><td style="text-align:left">打印帮助信息</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123</span><br><span class="line"><span class="comment">## 查询结果</span></span><br><span class="line"><span class="comment">#Message ID                                        #QID                                  #Offset</span></span><br><span class="line">0AFA00AFCF781EB44E468CC902A30000                      7                                        1</span><br></pre></td></tr></table></figure><h2 id="消费者">消费者</h2><h4 id="创建或更新消费者订阅组-updateSubGroup">创建或更新消费者订阅组(updateSubGroup)</h4><ul class="lvl-0"><li class="lvl-2"><p>消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如：</p><ul class="lvl-2"><li class="lvl-6">消费顺序（顺序/并发）</li><li class="lvl-6">广播模式</li><li class="lvl-6">消费使能</li><li class="lvl-6">消费重试策略</li><li class="lvl-6">延迟消费队列等</li></ul></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--groupName</code></td><td style="text-align:left">消费者组名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestConsumerGroup</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议明确指定</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerAddr</code></td><td style="text-align:left">指定 Broker 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>10.250.0.188:10911</code></td><td style="text-align:left">仅对单 Broker 更新</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--clusterName</code></td><td style="text-align:left">指定 Cluster 名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">对整个集群更新</td></tr><tr><td style="text-align:left"><code>-d</code></td><td style="text-align:left"><code>--consumeBroadcastEnable</code></td><td style="text-align:left">是否广播消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">true 表示广播，false 表示集群模式</td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--consumeMessageOrderly</code></td><td style="text-align:left">是否顺序消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">顺序消费只在同队列中生效</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--brokerId</code></td><td style="text-align:left">从哪个 Broker 获取订阅信息</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部用途，通常不用设置</td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left"><code>--consumeFromMinEnable</code></td><td style="text-align:left">是否从最小 offset 消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">新组首次消费时生效</td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--groupRetryPolicy</code></td><td style="text-align:left">消费组重试策略 JSON</td><td style="text-align:center">❌</td><td style="text-align:left"><code>&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;</code></td><td style="text-align:left">可以自定义重试间隔</td></tr><tr><td style="text-align:left"><code>-q</code></td><td style="text-align:left"><code>--retryQueueNums</code></td><td style="text-align:left">重试队列数量</td><td style="text-align:center">❌</td><td style="text-align:left"><code>1</code> ~ <code>16</code></td><td style="text-align:left">默认为 1</td></tr><tr><td style="text-align:left"><code>-r</code></td><td style="text-align:left"><code>--retryMaxTimes</code></td><td style="text-align:left">最大重试次数</td><td style="text-align:center">❌</td><td style="text-align:left"><code>16</code></td><td style="text-align:left">默认 16 次</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--consumeEnable</code></td><td style="text-align:left">是否使能消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">false 表示暂停消费</td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left"><code>--whichBrokerWhenConsumeSlowly</code></td><td style="text-align:left">慢消费选择 Broker ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部使用</td></tr><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left"><code>--notifyConsumerIdsChanged</code></td><td style="text-align:left">通知 ConsumerId 改变</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可触发消费者刷新订阅信息</td></tr><tr><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left">其他自定义属性</td><td style="text-align:center">❌</td><td style="text-align:left"><code>attr1=val1,attr2=val2</code></td><td style="text-align:left">可设置自定义配置</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助</td><td style="text-align:center">❌</td><td style="text-align:left">-</td><td style="text-align:left">显示命令帮助</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建普通消费者组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876</span><br><span class="line"><span class="comment"># 创建顺序消费组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建广播消费组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义属性的消费者组，这里配置了重试策略</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d <span class="literal">true</span> -o <span class="literal">true</span> -m <span class="literal">true</span> -p <span class="string">&#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27;</span> -q 1 -r 16 -s <span class="literal">true</span> -w 0 -a <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="删除消费者订阅组-deleteSubGroup">删除消费者订阅组(deleteSubGroup)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster</span><br></pre></td></tr></table></figure><h2 id="重要说明">重要说明</h2><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Admin Tool 的常用命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Proxy 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/</id>
    <published>2025-10-28T13:33:05.000Z</published>
    <updated>2025-10-30T06:45:46.620Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Proxy 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。</p></li><li class="lvl-2"><p>另外在源码 <code>rocketmq-all-5.3.2-source-release/proxy</code> 的启动类 <code>org.apache.rocketmq.proxy.ProxyStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.proxy.config.ProxyConfig</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th><th style="text-align:left">优化建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础信息</strong></td><td style="text-align:left"><code>rocketMQClusterName</code></td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">Broker 集群名称（Proxy 用于关联 RocketMQ 集群）</td><td style="text-align:left">若有多个集群，应唯一命名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>proxyClusterName</code></td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">Proxy 所属集群名称（与 brokerClusterName 可不同）</td><td style="text-align:left">✅建议独立命名，区分 Proxy 集群</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>proxyName</code></td><td style="text-align:left">主机名（例：<code>ip-10-250-0-175...</code>）</td><td style="text-align:left">Proxy 实例名称，用于唯一标识</td><td style="text-align:left">✅建议设置唯一名称</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>localServeAddr</code></td><td style="text-align:left">本地 IP</td><td style="text-align:left">Proxy 本地服务地址（Remoting 通信使用）</td><td style="text-align:left">✅建议显式指定 IP</td></tr><tr><td style="text-align:left"><strong>Namesrv</strong></td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left">多个地址（分号分隔）</td><td style="text-align:left">NameServer 地址，Proxy 通过它同步路由</td><td style="text-align:left">✅推荐配置为可访问的内网地址</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>namesrvDomain</code></td><td style="text-align:left">空</td><td style="text-align:left">NameServer 域名（可用于动态解析）</td><td style="text-align:left">可选，DNS 方式时使用</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>namesrvDomainSubgroup</code></td><td style="text-align:left">空</td><td style="text-align:left">子域分组（多集群域名发现用）</td><td style="text-align:left">一般可忽略</td></tr><tr><td style="text-align:left"><strong>TLS 配置</strong></td><td style="text-align:left"><code>tlsTestModeEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">测试模式下跳过验证（仅用于本地测试）</td><td style="text-align:left">❗生产应设为 false</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>tlsKeyPath</code></td><td style="text-align:left"><code>/conf/tls/rocketmq.key</code></td><td style="text-align:left">TLS 私钥路径</td><td style="text-align:left">✅根据证书路径调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>tlsCertPath</code></td><td style="text-align:left"><code>/conf/tls/rocketmq.crt</code></td><td style="text-align:left">TLS 证书路径</td><td style="text-align:left">✅根据证书路径调整</td></tr><tr><td style="text-align:left"><strong>gRPC 基础</strong></td><td style="text-align:left"><code>proxyMode</code></td><td style="text-align:left"><code>CLUSTER</code></td><td style="text-align:left">Proxy 模式：CLUSTER / LOCAL / REMOTING</td><td style="text-align:left">✅生产推荐 CLUSTER</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcServerPort</code></td><td style="text-align:left">8081</td><td style="text-align:left">gRPC 服务端监听端口</td><td style="text-align:left">若冲突可修改</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcShutdownTimeSeconds</code></td><td style="text-align:left">30</td><td style="text-align:left">优雅关闭等待时间</td><td style="text-align:left">可适当调大</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableGrpcEpoll</code></td><td style="text-align:left">false</td><td style="text-align:left">启用 Linux epoll I/O 模型</td><td style="text-align:left">✅Linux 建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcMaxInboundMessageSize</code></td><td style="text-align:left">136314880 (~130MB)</td><td style="text-align:left">最大入站消息大小</td><td style="text-align:left">根据消息大小调整</td></tr><tr><td style="text-align:left"><strong>消息限制</strong></td><td style="text-align:left"><code>maxMessageSize</code></td><td style="text-align:left">4194304 (4MB)</td><td style="text-align:left">最大消息体大小</td><td style="text-align:left">✅应与 Broker 一致</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableMessageBodyEmptyCheck</code></td><td style="text-align:left">true</td><td style="text-align:left">校验消息体是否为空</td><td style="text-align:left">保持默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxUserPropertySize</code></td><td style="text-align:left">16384 (16KB)</td><td style="text-align:left">用户属性最大长度</td><td style="text-align:left">根据业务复杂度调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>userPropertyMaxNum</code></td><td style="text-align:left">128</td><td style="text-align:left">单条消息最大属性数量</td><td style="text-align:left">可适当调低防止性能损耗</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxMessageGroupSize</code></td><td style="text-align:left">64</td><td style="text-align:left">最大消息组大小（批量 pop 使用）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>消息可见性与延迟</strong></td><td style="text-align:left"><code>defaultInvisibleTimeMills</code></td><td style="text-align:left">60000 (60s)</td><td style="text-align:left">pop 消息默认不可见时间</td><td style="text-align:left">✅高并发时可调低</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxInvisibleTimeMills</code></td><td style="text-align:left">43200000 (12h)</td><td style="text-align:left">最大不可见时长</td><td style="text-align:left">✅可根据业务降低</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxDelayTimeMills</code></td><td style="text-align:left">86400000 (1d)</td><td style="text-align:left">最大延迟时间</td><td style="text-align:left">与 Broker 保持一致</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useDelayLevel</code></td><td style="text-align:left">false</td><td style="text-align:left">是否使用延迟等级模式</td><td style="text-align:left">若 Broker 启用等级延迟则开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>messageDelayLevel</code></td><td style="text-align:left"><code>&quot;1s 5s 10s ... 2h&quot;</code></td><td style="text-align:left">延迟等级配置表</td><td style="text-align:left">✅需与 broker.conf 对齐</td></tr><tr><td style="text-align:left"><strong>线程池（gRPC 模块）</strong></td><td style="text-align:left"><code>grpcBossLoopNum</code></td><td style="text-align:left">1</td><td style="text-align:left">Netty boss 线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcWorkerLoopNum</code></td><td style="text-align:left">4</td><td style="text-align:left">gRPC worker 线程</td><td style="text-align:left">✅CPU&gt;4 时可调高至核数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcThreadPoolNums</code></td><td style="text-align:left">20</td><td style="text-align:left">gRPC 业务线程数</td><td style="text-align:left">✅建议 ≈ CPU 核数×2</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcThreadPoolQueueCapacity</code></td><td style="text-align:left">100000</td><td style="text-align:left">队列容量</td><td style="text-align:left">⚠️建议 ≤20000，防 OOM</td></tr><tr><td style="text-align:left"><strong>线程池（内部模块）</strong></td><td style="text-align:left"><code>producerProcessorThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">生产者处理线程</td><td style="text-align:left">✅可根据QPS调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>consumerProcessorThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">消费者处理线程</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>topicRouteServiceThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">路由服务线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>renewThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">自动续期线程</td><td style="text-align:left">高并发时可调大</td></tr><tr><td style="text-align:left"><strong>缓存配置</strong></td><td style="text-align:left"><code>topicRouteServiceCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">路由缓存有效期</td><td style="text-align:left">✅可适当调大</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>topicConfigCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">Topic 配置缓存有效期</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>subscriptionGroupConfigCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">订阅组缓存有效期</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>aclCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">ACL 缓存有效期</td><td style="text-align:left">✅同上</td></tr><tr><td style="text-align:left"><strong>事务与心跳</strong></td><td style="text-align:left"><code>transactionHeartbeatThreadPoolNums</code></td><td style="text-align:left">20</td><td style="text-align:left">事务心跳线程数</td><td style="text-align:left">✅根据事务量调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionHeartbeatPeriodSecond</code></td><td style="text-align:left">20</td><td style="text-align:left">事务心跳周期</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionDataExpireMillis</code></td><td style="text-align:left">30000</td><td style="text-align:left">事务数据过期时间</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>指标与监控</strong></td><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">DISABLE</td><td style="text-align:left">指标导出方式：DISABLE / PROM / GRPC / LOG</td><td style="text-align:left">✅建议启用 PROM</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">Prometheus 导出端口</td><td style="text-align:left">✅建议暴露监控</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsInDelta</code></td><td style="text-align:left">false</td><td style="text-align:left">是否按增量导出指标</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>Remoting 模式</strong></td><td style="text-align:left"><code>enableRemotingLocalProxyGrpc</code></td><td style="text-align:left">true</td><td style="text-align:left">启用本地 Proxy gRPC 转发</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>remotingListenPort</code></td><td style="text-align:left">8080</td><td style="text-align:left">Remoting 通信端口</td><td style="text-align:left">若冲突修改</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>sendLatencyEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">启用发送延迟探测（LoadBalance 优化）</td><td style="text-align:left">✅建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>startDetectorEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">启用启动探测功能</td><td style="text-align:left">可选，测试阶段使用</td></tr><tr><td style="text-align:left"><strong>可观测性</strong></td><td style="text-align:left"><code>traceOn</code></td><td style="text-align:left">false</td><td style="text-align:left">启用链路追踪</td><td style="text-align:left">✅建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enablePrintJstack</code></td><td style="text-align:left">true</td><td style="text-align:left">打印线程堆栈（用于诊断）</td><td style="text-align:left">✅可延长周期减少日志</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>综合优化建议</p></li></ul><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>性能调优</strong></td><td style="text-align:left">启用 <code>enableGrpcEpoll=true</code>；合理配置线程池（如减少队列长度）；设置合适的 <code>grpcThreadPoolNums</code>。</td></tr><tr><td style="text-align:left"><strong>可靠性</strong></td><td style="text-align:left">开启 <code>traceOn</code> 与 <code>sendLatencyEnable</code> 监控；使用 Prometheus 指标导出。</td></tr><tr><td style="text-align:left"><strong>安全性</strong></td><td style="text-align:left">禁用 <code>tlsTestModeEnable</code>，使用真实 TLS 证书。</td></tr><tr><td style="text-align:left"><strong>资源管理</strong></td><td style="text-align:left">限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。</td></tr><tr><td style="text-align:left"><strong>可维护性</strong></td><td style="text-align:left">使用独立的 <code>proxyClusterName</code>，并在配置文件 <code>rmq-proxy.json</code> 中明确各项端口和路径。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Proxy 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Controller 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/</id>
    <published>2025-10-28T13:32:05.000Z</published>
    <updated>2025-10-28T03:25:35.545Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Controller 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-Controller-配置项">查看 Controller 配置项</h2><ul class="lvl-0"><li class="lvl-2"><p>查看全部默认配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全部默认配置项</span></span><br><span class="line">sh bin/mqcontroller -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class="line">sh bin/mqcontroller -p -c conf/broker.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/controller</code> 的启动类 <code>org.apache.rocketmq.controller.ControllerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ControllerConfig</span> <span class="variable">controllerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControllerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">JraftConfig</span> <span class="variable">jraftConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JraftConfig</span>();</span><br><span class="line">controllerConfig.setJraftConfig(jraftConfig);</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">19876</span>);</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Controller 配置参数说明与优化建议</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础信息</strong></td><td style="text-align:left"><code>rocketmqHome</code></td><td style="text-align:left">/usr/local/soft/rocketmq/rocketmq5</td><td style="text-align:left">RocketMQ 根路径</td><td style="text-align:left">保持默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>configStorePath</code></td><td style="text-align:left">/root/controller/controller.properties</td><td style="text-align:left">Controller 配置文件路径</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/controller/controller.properties</code>，避免使用 <code>/root</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerType</code></td><td style="text-align:left">DLedger</td><td style="text-align:left">Controller 类型（DLedger / STANDALONE）</td><td style="text-align:left">✅ 建议使用 DLedger（高可用）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerStorePath</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Controller 元数据存储路径</td><td style="text-align:left">✅ 建议 <code>/data/rocketmq/controller/store</code></td></tr><tr><td style="text-align:left"><strong>DLedger 选举配置</strong></td><td style="text-align:left"><code>controllerDLegerGroup</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Controller 集群组名</td><td style="text-align:left">✅ 必填，例如：<code>controllerGroup01</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerDLegerPeers</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">集群节点列表，格式：<code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td><td style="text-align:left">✅ 必填（3 节点推荐）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerDLegerSelfId</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">当前节点 ID，如 <code>n0</code></td><td style="text-align:left">✅ 必填</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>mappedFileSize</code></td><td style="text-align:left">1073741824</td><td style="text-align:left">DLedger 存储文件大小 (1GB)</td><td style="text-align:left">可保持默认</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>electMasterMaxRetryCount</code></td><td style="text-align:left">3</td><td style="text-align:left">Master 选举最大重试次数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableElectUncleanMaster</code></td><td style="text-align:left">false</td><td style="text-align:left">是否允许选举非同步 Master</td><td style="text-align:left">✅ 建议保持 false（避免数据丢失）</td></tr><tr><td style="text-align:left"><strong>Broker 管理</strong></td><td style="text-align:left"><code>scanNotActiveBrokerInterval</code></td><td style="text-align:left">5000</td><td style="text-align:left">扫描不活跃 Broker 的间隔(ms)</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>scanInactiveMasterInterval</code></td><td style="text-align:left">5000</td><td style="text-align:left">检测失活 Master 间隔(ms)</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>notifyBrokerRoleChanged</code></td><td style="text-align:left">true</td><td style="text-align:left">是否通知 Broker 角色变更</td><td style="text-align:left">✅ 建议开启（保持同步）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>isProcessReadEvent</code></td><td style="text-align:left">false</td><td style="text-align:left">是否处理读事件</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>线程与性能</strong></td><td style="text-align:left"><code>controllerThreadPoolNums</code></td><td style="text-align:left">16</td><td style="text-align:left">控制线程池大小</td><td style="text-align:left">可调至 8–32 视规模而定</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerRequestThreadPoolQueueCapacity</code></td><td style="text-align:left">50000</td><td style="text-align:left">控制线程池队列容量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>Metrics 监控</strong></td><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">DISABLE</td><td style="text-align:left">指标输出方式（DISABLE / PROM / GRPC / LOG）</td><td style="text-align:left">✅ 建议设为 <code>PROM</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">Prometheus 端口</td><td style="text-align:left">✅ 若启用监控，可用默认 5557</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterHost</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Prometheus 绑定主机</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricLoggingExporterIntervalInMills</code></td><td style="text-align:left">10000</td><td style="text-align:left">日志输出指标间隔</td><td style="text-align:left">可调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsGrpcExporterTarget</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">gRPC 监控目标</td><td style="text-align:left">可忽略</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsInDelta</code></td><td style="text-align:left">false</td><td style="text-align:left">是否以增量输出指标</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>JRaft 配置（底层一致性协议）</strong></td><td style="text-align:left"><code>jRaftGroupId</code></td><td style="text-align:left">jRaft-Controller</td><td style="text-align:left">Raft 组名</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftServerId</code></td><td style="text-align:left">localhost:9880</td><td style="text-align:left">当前节点 ID</td><td style="text-align:left">✅ 修改为实际 IP，例如 <code>10.0.0.1:9880</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftInitConf</code></td><td style="text-align:left">localhost:9880,localhost:9881,localhost:9882</td><td style="text-align:left">集群配置</td><td style="text-align:left">✅ 修改为实际节点 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftControllerRPCAddr</code></td><td style="text-align:left">localhost:9770,localhost:9771,localhost:9772</td><td style="text-align:left">Controller RPC 地址</td><td style="text-align:left">✅ 修改为实际节点 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftElectionTimeoutMs</code></td><td style="text-align:left">1000</td><td style="text-align:left">选举超时（ms）</td><td style="text-align:left">默认即可（过低可能频繁选举）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftScanWaitTimeoutMs</code></td><td style="text-align:left">1000</td><td style="text-align:left">扫描等待超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftSnapshotIntervalSecs</code></td><td style="text-align:left">3600</td><td style="text-align:left">快照间隔时间（秒）</td><td style="text-align:left">✅ 可设为 600（10分钟）加快日志压缩</td></tr><tr><td style="text-align:left"><strong>网络配置</strong></td><td style="text-align:left"><code>bindAddress</code></td><td style="text-align:left">0.0.0.0</td><td style="text-align:left">绑定监听地址</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>listenPort</code></td><td style="text-align:left">19876</td><td style="text-align:left">Controller 服务端口</td><td style="text-align:left">✅ 确保未冲突</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverWorkerThreads</code></td><td style="text-align:left">8</td><td style="text-align:left">Netty 工作线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverSelectorThreads</code></td><td style="text-align:left">3</td><td style="text-align:left">Selector 线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverSocketBacklog</code></td><td style="text-align:left">1024</td><td style="text-align:left">Socket backlog 队列</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">false</td><td style="text-align:left">是否使用 Epoll</td><td style="text-align:left">✅ Linux 环境建议 true</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">false</td><td style="text-align:left">优雅停机</td><td style="text-align:left">✅ 建议 true</td></tr><tr><td style="text-align:left"><strong>客户端通信</strong></td><td style="text-align:left"><code>clientWorkerThreads</code></td><td style="text-align:left">4</td><td style="text-align:left">客户端工作线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clientAsyncSemaphoreValue</code></td><td style="text-align:left">65535</td><td style="text-align:left">异步请求信号量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clientCloseSocketIfTimeout</code></td><td style="text-align:left">true</td><td style="text-align:left">连接超时关闭</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>connectTimeoutMillis</code></td><td style="text-align:left">3000</td><td style="text-align:left">连接超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useTLS</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 TLS</td><td style="text-align:left">✅ 若生产环境有安全要求，建议启用</td></tr><tr><td style="text-align:left"><strong>其他</strong></td><td style="text-align:left"><code>configBlackList</code></td><td style="text-align:left">configBlackList;configStorePath</td><td style="text-align:left">配置黑名单项</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxReconnectIntervalTimeSeconds</code></td><td style="text-align:left">60</td><td style="text-align:left">最大重连间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableReconnectForGoAway</code></td><td style="text-align:left">true</td><td style="text-align:left">是否为 GOAWAY 连接启用重连</td><td style="text-align:left">默认即可</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">推荐值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>controllerType</code></td><td style="text-align:left">DLedger</td><td style="text-align:left">高可用模式</td></tr><tr><td style="text-align:left"><code>controllerDLegerGroup</code></td><td style="text-align:left">controllerGroup01</td><td style="text-align:left">集群分组名</td></tr><tr><td style="text-align:left"><code>controllerDLegerPeers</code></td><td style="text-align:left"><code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td><td style="text-align:left">三节点推荐</td></tr><tr><td style="text-align:left"><code>controllerDLegerSelfId</code></td><td style="text-align:left">n0 / n1 / n2</td><td style="text-align:left">对应节点 ID</td></tr><tr><td style="text-align:left"><code>enableElectUncleanMaster</code></td><td style="text-align:left">false</td><td style="text-align:left">防止脏主选举</td></tr><tr><td style="text-align:left"><code>notifyBrokerRoleChanged</code></td><td style="text-align:left">true</td><td style="text-align:left">保持集群一致性</td></tr><tr><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">PROM</td><td style="text-align:left">便于 Prometheus 监控</td></tr><tr><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">true</td><td style="text-align:left">Linux 性能优化</td></tr><tr><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">true</td><td style="text-align:left">优雅停机</td></tr><tr><td style="text-align:left"><code>controllerStorePath</code></td><td style="text-align:left">/data/rocketmq/controller/store</td><td style="text-align:left">避免使用 <code>/root</code></td></tr><tr><td style="text-align:left"><code>jRaftSnapshotIntervalSecs</code></td><td style="text-align:left">600</td><td style="text-align:left">提高快照频率</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Controller 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Broker 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/</id>
    <published>2025-10-28T13:31:05.000Z</published>
    <updated>2025-10-28T03:23:18.328Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Broker 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-Broker-配置项">查看 Broker 配置项</h2><ul class="lvl-0"><li class="lvl-2"><p>查看全部默认配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全部默认配置项</span></span><br><span class="line">sh bin/mqbroker -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class="line">sh bin/mqbroker -p -c conf/broker.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看重要的配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看重要的默认配置项</span></span><br><span class="line">sh bin/mqbroker -m</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的重要配置项</span></span><br><span class="line">sh bin/mqbroker -m -c conf/broker.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/broker</code> 的启动类 <code>org.apache.rocketmq.broker.BrokerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">BrokerConfig</span> <span class="variable">brokerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">MessageStoreConfig</span> <span class="variable">messageStoreConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageStoreConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">AuthConfig</span> <span class="variable">authConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthConfig</span>();</span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">10911</span>);</span><br><span class="line">messageStoreConfig.setHaListenPort(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker的全部配置项非常多，这里仅列出了重要的配置项。</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">参数说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础配置</strong></td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">NameServer 地址列表（多个用 <code>;</code> 分隔）</td><td style="text-align:left">✅ <strong>必须设置</strong>，否则 broker 无法注册到 nameserver。例：<code>namesrvAddr=10.250.0.10:9876;10.250.0.11:9876</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>listenPort</code></td><td style="text-align:left">6888</td><td style="text-align:left">Broker 监听客户端连接的端口</td><td style="text-align:left">✅ 建议保持默认或显式设置为 10911（经典端口）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>brokerIP1</code></td><td style="text-align:left">10.250.0.188</td><td style="text-align:left">Broker 对外通信 IP</td><td style="text-align:left">✅ 在多网卡环境务必指定公网/内网 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>recoverConcurrently</code></td><td style="text-align:left">false</td><td style="text-align:left">是否并发恢复 CommitLog</td><td style="text-align:left">默认即可（高安全性）</td></tr><tr><td style="text-align:left"><strong>Topic &amp; 订阅</strong></td><td style="text-align:left"><code>autoCreateTopicEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否允许自动创建 Topic</td><td style="text-align:left">✅ 生产建议设为 <strong>false</strong>，防止误创建</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>autoCreateSubscriptionGroup</code></td><td style="text-align:left">true</td><td style="text-align:left">是否自动创建订阅组</td><td style="text-align:left">✅ 同上，建议 <strong>false</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>msgTraceTopicName</code></td><td style="text-align:left">RMQ_SYS_TRACE_TOPIC</td><td style="text-align:left">消息轨迹主题名</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>traceTopicEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否开启消息轨迹功能</td><td style="text-align:left">✅ 建议设为 <strong>true</strong> 以便问题排查</td></tr><tr><td style="text-align:left"><strong>事务消息</strong></td><td style="text-align:left"><code>rejectTransactionMessage</code></td><td style="text-align:left">false</td><td style="text-align:left">是否拒绝事务消息</td><td style="text-align:left">若不使用事务可设为 true 减少负担</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionTimeOut</code></td><td style="text-align:left">6000</td><td style="text-align:left">事务超时时间（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionCheckMax</code></td><td style="text-align:left">15</td><td style="text-align:left">事务最大回查次数</td><td style="text-align:left">可调高（20）提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionCheckInterval</code></td><td style="text-align:left">30000</td><td style="text-align:left">事务回查间隔（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>访问控制</strong></td><td style="text-align:left"><code>aclEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 ACL 权限验证</td><td style="text-align:left">✅ 生产环境 <strong>必须 true</strong></td></tr><tr><td style="text-align:left"><strong>存储路径</strong></td><td style="text-align:left"><code>storePathRootDir</code></td><td style="text-align:left">/root/store</td><td style="text-align:left">消息存储根目录</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/store</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathCommitLog</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">CommitLog 存储路径</td><td style="text-align:left">若为空则使用上面的根目录</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathDLedgerCommitLog</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">DLedger 模式存储路径</td><td style="text-align:left">DLedger 模式才需要</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathEpochFile</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">epoch 文件路径</td><td style="text-align:left">Controller 模式使用</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathBrokerIdentity</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Broker 身份文件路径</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>disappearTimeAfterStart</code></td><td style="text-align:left">-1</td><td style="text-align:left">Broker 启动后失效等待时间</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storeType</code></td><td style="text-align:left">default</td><td style="text-align:left">存储类型（default / dledger）</td><td style="text-align:left">✅ 多副本部署建议 dledger</td></tr><tr><td style="text-align:left"><strong>刷盘与写入</strong></td><td style="text-align:left"><code>flushIntervalCommitLog</code></td><td style="text-align:left">500</td><td style="text-align:left">异步 flush 周期（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commitIntervalCommitLog</code></td><td style="text-align:left">200</td><td style="text-align:left">commit 间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>flushCommitLogTimed</code></td><td style="text-align:left">true</td><td style="text-align:left">是否定时 flush</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>文件清理</strong></td><td style="text-align:left"><code>deleteWhen</code></td><td style="text-align:left">04</td><td style="text-align:left">删除过期文件时间点</td><td style="text-align:left">每天凌晨 4 点</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>fileReservedTime</code></td><td style="text-align:left">72</td><td style="text-align:left">文件保留时间（小时）</td><td style="text-align:left">✅ 可改为 48 减少磁盘压力</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>deleteFileBatchMax</code></td><td style="text-align:left">10</td><td style="text-align:left">删除文件批量数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>消息访问性能</strong></td><td style="text-align:left"><code>maxTransferBytesOnMessageInMemory</code></td><td style="text-align:left">262144</td><td style="text-align:left">内存消息读取最大字节</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferCountOnMessageInMemory</code></td><td style="text-align:left">32</td><td style="text-align:left">内存消息读取最大条数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferBytesOnMessageInDisk</code></td><td style="text-align:left">65536</td><td style="text-align:left">磁盘消息读取最大字节</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferCountOnMessageInDisk</code></td><td style="text-align:left">8</td><td style="text-align:left">磁盘消息读取最大条数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>accessMessageInMemoryMaxRatio</code></td><td style="text-align:left">40</td><td style="text-align:left">内存访问比例阈值</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>索引管理</strong></td><td style="text-align:left"><code>messageIndexEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否启用消息索引</td><td style="text-align:left">✅ 建议开启（提高按 key 查询性能）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>messageIndexSafe</code></td><td style="text-align:left">false</td><td style="text-align:left">是否安全模式索引</td><td style="text-align:left">若磁盘可靠性差可设为 true</td></tr><tr><td style="text-align:left"><strong>主从复制</strong></td><td style="text-align:left"><code>haMasterAddress</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Master 地址（Slave 模式使用）</td><td style="text-align:left">仅从节点配置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>brokerRole</code></td><td style="text-align:left">ASYNC_MASTER</td><td style="text-align:left">Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE）</td><td style="text-align:left">✅ 主节点建议 SYNC_MASTER 提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>flushDiskType</code></td><td style="text-align:left">ASYNC_FLUSH</td><td style="text-align:left">刷盘策略（SYNC_FLUSH / ASYNC_FLUSH）</td><td style="text-align:left">✅ 高可靠建议 SYNC_FLUSH</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>cleanFileForciblyEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否强制清理文件</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transientStorePoolEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 transient pool（堆外内存）</td><td style="text-align:left">✅ 可设为 true 提升性能（需足够内存）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>dispatchFromSenderThread</code></td><td style="text-align:left">false</td><td style="text-align:left">是否由发送线程分发</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>wakeCommitWhenPutMessage</code></td><td style="text-align:left">true</td><td style="text-align:left">是否在消息写入时唤醒 commit</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>wakeFlushWhenPutMessage</code></td><td style="text-align:left">false</td><td style="text-align:left">是否写入后立即 flush</td><td style="text-align:left">✅ 对延迟敏感业务可设为 true</td></tr><tr><td style="text-align:left"><strong>消费进度清理</strong></td><td style="text-align:left"><code>enableCleanExpiredOffset</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 offset 清理</td><td style="text-align:left">默认 false</td></tr><tr><td style="text-align:left"><strong>副本参数</strong></td><td style="text-align:left"><code>totalReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">副本总数</td><td style="text-align:left">✅ 多节点建议设为 3</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>inSyncReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">同步副本数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>minInSyncReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">最小同步副本</td><td style="text-align:left">✅ 建议设为 2 提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>allAckInSyncStateSet</code></td><td style="text-align:left">false</td><td style="text-align:left">是否要求所有 ISR 确认</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableAutoInSyncReplicas</code></td><td style="text-align:left">false</td><td style="text-align:left">是否自动管理 ISR</td><td style="text-align:left">可保持默认</td></tr><tr><td style="text-align:left"><strong>HA 与流控</strong></td><td style="text-align:left"><code>haFlowControlEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否开启主从流控</td><td style="text-align:left">✅ 多副本建议 true</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">参数</th><th style="text-align:left">推荐值</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left">注册</td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left">必填</td><td style="text-align:left">Broker 必须向 NameServer 注册</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>aclEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">启用访问控制</td></tr><tr><td style="text-align:left">自动创建</td><td style="text-align:left"><code>autoCreateTopicEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">防止误创建 topic</td></tr><tr><td style="text-align:left">自动订阅</td><td style="text-align:left"><code>autoCreateSubscriptionGroup</code></td><td style="text-align:left">false</td><td style="text-align:left">防止误消费</td></tr><tr><td style="text-align:left">刷盘策略</td><td style="text-align:left"><code>flushDiskType</code></td><td style="text-align:left">SYNC_FLUSH</td><td style="text-align:left">保证可靠性</td></tr><tr><td style="text-align:left">主从</td><td style="text-align:left"><code>brokerRole</code></td><td style="text-align:left">SYNC_MASTER（主） / SLAVE（从）</td><td style="text-align:left">提升可用性</td></tr><tr><td style="text-align:left">存储路径</td><td style="text-align:left"><code>storePathRootDir</code></td><td style="text-align:left"><code>/data/rocketmq/store</code></td><td style="text-align:left">避免 <code>/root</code> 权限问题</td></tr><tr><td style="text-align:left">延迟优化</td><td style="text-align:left"><code>transientStorePoolEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">堆外内存加速写入</td></tr><tr><td style="text-align:left">清理</td><td style="text-align:left"><code>fileReservedTime</code></td><td style="text-align:left">48</td><td style="text-align:left">减少磁盘占用</td></tr><tr><td style="text-align:left">消息轨迹</td><td style="text-align:left"><code>traceTopicEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">便于追踪消息链路</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Broker 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ NameServer 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/</id>
    <published>2025-10-28T13:30:05.000Z</published>
    <updated>2025-10-28T03:19:35.144Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ NameServer 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-NameServer-配置项">查看 NameServer 配置项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认配置项</span></span><br><span class="line">sh bin/mqnamesrv -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项</span></span><br><span class="line">sh bin/mqnamesrv -p -c conf/namesvr.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/namesrv</code> 的启动类 <code>org.apache.rocketmq.namesrv.NamesrvStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ControllerConfig</span> <span class="variable">controllerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>NameServer 配置项说明与建议</p></li></ul><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">参数说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>rocketmqHome</strong></td><td style="text-align:left">/usr/local/soft/rocketmq/rocketmq5</td><td style="text-align:left">RocketMQ 安装目录</td><td style="text-align:left">不建议修改</td></tr><tr><td style="text-align:left"><strong>kvConfigPath</strong></td><td style="text-align:left">/root/namesrv/kvConfig.json</td><td style="text-align:left">KV 配置存储路径</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/namesrv/kvConfig.json</code> 更规范</td></tr><tr><td style="text-align:left"><strong>configStorePath</strong></td><td style="text-align:left">/root/namesrv/namesrv.properties</td><td style="text-align:left">NameServer 启动配置文件路径</td><td style="text-align:left">✅ 放在非 root 路径下 <code>/etc/rocketmq/namesrv.properties</code></td></tr><tr><td style="text-align:left"><strong>productEnvName</strong></td><td style="text-align:left">center</td><td style="text-align:left">产品环境名称标识</td><td style="text-align:left">可用于区分环境（dev/test/prod）</td></tr><tr><td style="text-align:left"><strong>clusterTest</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用集群测试模式</td><td style="text-align:left">默认 false，生产勿启用</td></tr><tr><td style="text-align:left"><strong>orderMessageEnable</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否开启顺序消息功能</td><td style="text-align:left">NameServer 一般无需开启</td></tr><tr><td style="text-align:left"><strong>returnOrderTopicConfigToBroker</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否返回顺序消息主题配置给 broker</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>clientRequestThreadPoolNums</strong></td><td style="text-align:left">8</td><td style="text-align:left">客户端请求线程数</td><td style="text-align:left">✅ 若 NameServer 负载高可增至 16~32</td></tr><tr><td style="text-align:left"><strong>defaultThreadPoolNums</strong></td><td style="text-align:left">16</td><td style="text-align:left">默认线程池线程数</td><td style="text-align:left">视 CPU 核心数调整</td></tr><tr><td style="text-align:left"><strong>clientRequestThreadPoolQueueCapacity</strong></td><td style="text-align:left">50000</td><td style="text-align:left">客户端请求队列长度</td><td style="text-align:left">✅ 高并发环境可调高至 100000</td></tr><tr><td style="text-align:left"><strong>defaultThreadPoolQueueCapacity</strong></td><td style="text-align:left">10000</td><td style="text-align:left">默认任务队列长度</td><td style="text-align:left">适度提高防止拒绝任务</td></tr><tr><td style="text-align:left"><strong>scanNotActiveBrokerInterval</strong></td><td style="text-align:left">5000</td><td style="text-align:left">扫描失效 Broker 的间隔（ms）</td><td style="text-align:left">默认 5s，可保持</td></tr><tr><td style="text-align:left"><strong>unRegisterBrokerQueueCapacity</strong></td><td style="text-align:left">3000</td><td style="text-align:left">Broker 注销队列容量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>supportActingMaster</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否支持 ActingMaster 功能</td><td style="text-align:left">✅ 若启用 controller 建议设为 true</td></tr><tr><td style="text-align:left"><strong>enableAllTopicList</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用所有主题列表接口</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>enableTopicList</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否允许主题列表查询</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>notifyMinBrokerIdChanged</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否通知最小 brokerId 变化</td><td style="text-align:left">一般无需开启</td></tr><tr><td style="text-align:left"><strong>enableControllerInNamesrv</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否在 NameServer 中启用 Controller 模块</td><td style="text-align:left">✅ 若部署简化集群可考虑 true（测试环境）</td></tr><tr><td style="text-align:left"><strong>needWaitForService</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否等待服务就绪再启动</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>waitSecondsForService</strong></td><td style="text-align:left">45</td><td style="text-align:left">启动等待时间</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>deleteTopicWithBrokerRegistration</strong></td><td style="text-align:left">false</td><td style="text-align:left">注册时是否删除 topic</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>configBlackList</strong></td><td style="text-align:left">configBlackList;configStorePath;kvConfigPath</td><td style="text-align:left">黑名单配置项</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>bindAddress</strong></td><td style="text-align:left">0.0.0.0</td><td style="text-align:left">绑定的监听地址</td><td style="text-align:left">✅ 生产环境建议绑定内网 IP</td></tr><tr><td style="text-align:left"><strong>listenPort</strong></td><td style="text-align:left">9876</td><td style="text-align:left">NameServer 监听端口</td><td style="text-align:left">✅ 可通过防火墙限制外部访问</td></tr><tr><td style="text-align:left"><strong>serverWorkerThreads</strong></td><td style="text-align:left">8</td><td style="text-align:left">服务端业务处理线程数</td><td style="text-align:left">可根据负载调整</td></tr><tr><td style="text-align:left"><strong>serverCallbackExecutorThreads</strong></td><td style="text-align:left">0</td><td style="text-align:left">回调执行线程数</td><td style="text-align:left">0 表示自动设置</td></tr><tr><td style="text-align:left"><strong>serverSelectorThreads</strong></td><td style="text-align:left">3</td><td style="text-align:left">Selector 线程数</td><td style="text-align:left">一般 2~4 即可</td></tr><tr><td style="text-align:left"><strong>serverOnewaySemaphoreValue</strong></td><td style="text-align:left">256</td><td style="text-align:left">单向请求并发限制</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>serverAsyncSemaphoreValue</strong></td><td style="text-align:left">64</td><td style="text-align:left">异步请求并发限制</td><td style="text-align:left">可保持或略增</td></tr><tr><td style="text-align:left"><strong>serverChannelMaxIdleTimeSeconds</strong></td><td style="text-align:left">120</td><td style="text-align:left">连接空闲关闭时间</td><td style="text-align:left">可调大到 300 提高容错</td></tr><tr><td style="text-align:left"><strong>serverSocketSndBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">TCP 发送缓冲区大小</td><td style="text-align:left">0 表示使用系统默认</td></tr><tr><td style="text-align:left"><strong>serverSocketRcvBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">TCP 接收缓冲区大小</td><td style="text-align:left">建议 131072（128KB）以上</td></tr><tr><td style="text-align:left"><strong>writeBufferHighWaterMark</strong></td><td style="text-align:left">0</td><td style="text-align:left">写缓冲高水位标记</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>writeBufferLowWaterMark</strong></td><td style="text-align:left">0</td><td style="text-align:left">写缓冲低水位标记</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>serverSocketBacklog</strong></td><td style="text-align:left">1024</td><td style="text-align:left">TCP 连接等待队列</td><td style="text-align:left">✅ 高并发场景可调大至 2048</td></tr><tr><td style="text-align:left"><strong>serverNettyWorkerGroupEnable</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 Netty worker 线程组</td><td style="text-align:left">默认 true</td></tr><tr><td style="text-align:left"><strong>serverPooledByteBufAllocatorEnable</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 Netty 池化内存</td><td style="text-align:left">建议保持</td></tr><tr><td style="text-align:left"><strong>enableShutdownGracefully</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否优雅关闭</td><td style="text-align:left">✅ 建议设为 true</td></tr><tr><td style="text-align:left"><strong>shutdownWaitTimeSeconds</strong></td><td style="text-align:left">30</td><td style="text-align:left">优雅关闭等待时间</td><td style="text-align:left">建议 30~60</td></tr><tr><td style="text-align:left"><strong>useEpollNativeSelector</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 Linux Epoll</td><td style="text-align:left">✅ Linux 环境建议设为 true 提高性能</td></tr><tr><td style="text-align:left"><strong>clientWorkerThreads</strong></td><td style="text-align:left">4</td><td style="text-align:left">客户端 worker 线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientCallbackExecutorThreads</strong></td><td style="text-align:left">2</td><td style="text-align:left">客户端回调线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientOnewaySemaphoreValue</strong></td><td style="text-align:left">65535</td><td style="text-align:left">客户端单向请求并发限制</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientAsyncSemaphoreValue</strong></td><td style="text-align:left">65535</td><td style="text-align:left">客户端异步请求并发限制</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>connectTimeoutMillis</strong></td><td style="text-align:left">3000</td><td style="text-align:left">连接超时（ms）</td><td style="text-align:left">✅ 可提高至 5000 增加容错</td></tr><tr><td style="text-align:left"><strong>channelNotActiveInterval</strong></td><td style="text-align:left">60000</td><td style="text-align:left">检查通道非活动间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>isScanAvailableNameSrv</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否扫描可用 NameServer</td><td style="text-align:left">保持</td></tr><tr><td style="text-align:left"><strong>clientChannelMaxIdleTimeSeconds</strong></td><td style="text-align:left">120</td><td style="text-align:left">客户端空闲连接超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientSocketSndBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">客户端 TCP 发送缓冲区</td><td style="text-align:left">建议 131072</td></tr><tr><td style="text-align:left"><strong>clientSocketRcvBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">客户端 TCP 接收缓冲区</td><td style="text-align:left">建议 131072</td></tr><tr><td style="text-align:left"><strong>clientPooledByteBufAllocatorEnable</strong></td><td style="text-align:left">false</td><td style="text-align:left">客户端是否启用池化</td><td style="text-align:left">✅ 建议设为 true 提高性能</td></tr><tr><td style="text-align:left"><strong>clientCloseSocketIfTimeout</strong></td><td style="text-align:left">true</td><td style="text-align:left">超时是否关闭 socket</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>useTLS</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 TLS 通信</td><td style="text-align:left">✅ 若公网部署强烈建议开启</td></tr><tr><td style="text-align:left"><strong>socksProxyConfig</strong></td><td style="text-align:left">{}</td><td style="text-align:left">SOCKS 代理配置</td><td style="text-align:left">内网部署无需设置</td></tr><tr><td style="text-align:left"><strong>disableCallbackExecutor</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否禁用回调执行器</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>disableNettyWorkerGroup</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否禁用 Netty worker group</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>maxReconnectIntervalTimeSeconds</strong></td><td style="text-align:left">60</td><td style="text-align:left">最大重连间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>enableReconnectForGoAway</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 goaway 自动重连</td><td style="text-align:left">保持 true 增强健壮性</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">参数</th><th style="text-align:left">推荐值</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left">性能</td><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">true</td><td style="text-align:left">Linux 性能显著提升</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>bindAddress</code></td><td style="text-align:left">内网 IP</td><td style="text-align:left">防止暴露公网</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>useTLS</code></td><td style="text-align:left">true（公网）</td><td style="text-align:left">启用加密传输</td></tr><tr><td style="text-align:left">健壮性</td><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">true</td><td style="text-align:left">防止强制关闭导致状态不一致</td></tr><tr><td style="text-align:left">负载</td><td style="text-align:left"><code>clientRequestThreadPoolNums</code></td><td style="text-align:left">16~32</td><td style="text-align:left">提高并发能力</td></tr><tr><td style="text-align:left">网络</td><td style="text-align:left"><code>serverSocketBacklog</code></td><td style="text-align:left">2048</td><td style="text-align:left">减少连接拒绝</td></tr><tr><td style="text-align:left">缓冲</td><td style="text-align:left"><code>serverSocketSndBufSize</code> / <code>RcvBufSize</code></td><td style="text-align:left">131072</td><td style="text-align:left">提高网络吞吐</td></tr><tr><td style="text-align:left">文件路径</td><td style="text-align:left"><code>kvConfigPath</code> / <code>configStorePath</code></td><td style="text-align:left">非 root 路径</td><td style="text-align:left">避免权限问题</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ NameServer 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
</feed>
