<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-10-31T10:27:39.577Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ ACL 2.0</title>
    <link href="https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/"/>
    <id>https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/</id>
    <published>2025-10-31T13:40:05.000Z</published>
    <updated>2025-10-31T10:27:39.577Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li><li class="lvl-2"><p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p></li></ul><span id="more"></span><h2 id="ACL-2-0-简介">ACL 2.0 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 <a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href="https://rocketmq.apache.org/zh/docs/bestPractice/03access">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p></li><li class="lvl-2"><p>在阿里云上找到一篇参考资料：<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a></p></li></ul><h2 id="配置步骤">配置步骤</h2><ul class="lvl-0"><li class="lvl-2"><p>本文在 <a href="/2025/10/23/rocketmq-01-install/" title="RocketMQ 的安装及使用">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p></li><li class="lvl-2"><p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker.conf</span></span><br><span class="line"><span class="comment"># 认证配置</span></span><br><span class="line">authenticationEnabled = <span class="literal">true</span></span><br><span class="line">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class="line">initAuthenticationUser = &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">innerClientAuthenticationCredentials = &#123;<span class="string">&quot;accessKey&quot;</span>:<span class="string">&quot;mqadmin&quot;</span>,<span class="string">&quot;secretKey&quot;</span>:<span class="string">&quot;1234567&quot;</span>&#125;</span><br><span class="line">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class="line"><span class="comment"># 授权配置</span></span><br><span class="line">authorizationEnabled = <span class="literal">true</span></span><br><span class="line">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class="line">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数定义</th><th style="text-align:left">参数名称</th><th style="text-align:left">参数描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>authenticationEnabled</strong></td><td style="text-align:left">是否打开认证开关</td><td style="text-align:left">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td></tr><tr><td style="text-align:left"><strong>authenticationProvider</strong></td><td style="text-align:left">认证方式提供者</td><td style="text-align:left">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td></tr><tr><td style="text-align:left"><strong>initAuthenticationUser</strong></td><td style="text-align:left">系统初始化用户</td><td style="text-align:left">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>innerClientAuthenticationCredentials</strong></td><td style="text-align:left">组件间认证用户</td><td style="text-align:left">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td></tr><tr><td style="text-align:left"><strong>authenticationMetadataProvider</strong></td><td style="text-align:left">认证元数据提供者</td><td style="text-align:left">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td></tr><tr><td style="text-align:left"><strong>authenticationStrategy</strong></td><td style="text-align:left">认证策略</td><td style="text-align:left">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>重启启动所有 Broker</p></li></ul><h2 id="命令行管理用户">命令行管理用户</h2><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="用户管理">用户管理</h3><table><thead><tr><th style="text-align:left">接口定义</th><th style="text-align:left">接口名称</th><th style="text-align:left">接口参数</th></tr></thead><tbody><tr><td style="text-align:left"><strong>createUser</strong></td><td style="text-align:left">创建用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>updateUser</strong></td><td style="text-align:left">更新用户</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td></tr><tr><td style="text-align:left"><strong>deleteUser</strong></td><td style="text-align:left">删除用户</td><td style="text-align:left">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>getUser</strong></td><td style="text-align:left">查询用户详情</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td></tr><tr><td style="text-align:left"><strong>listUser</strong></td><td style="text-align:left">查询用户列表</td><td style="text-align:left">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class="line"><span class="comment"># 创建用户，指定用户类型</span></span><br><span class="line">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class="line"><span class="comment"># 更新用户</span></span><br><span class="line">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户详情</span></span><br><span class="line">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class="line"><span class="comment"># 查询用户列表</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询用户列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure><h3 id="权限管理">权限管理</h3><ul class="lvl-0"><li class="lvl-2"><p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p></li></ul><table><thead><tr><th style="text-align:left">命令名称</th><th style="text-align:left">操作定义</th><th style="text-align:left">命令参数及解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>createAcl</code></strong></td><td style="text-align:left">创建授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td></tr><tr><td style="text-align:left"><strong><code>updateAcl</code></strong></td><td style="text-align:left">更新授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td></tr><tr><td style="text-align:left"><strong><code>deleteAcl</code></strong></td><td style="text-align:left">删除授权</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td></tr><tr><td style="text-align:left"><strong><code>listAcl</code></strong></td><td style="text-align:left">查询授权列表</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td></tr><tr><td style="text-align:left"><strong><code>getAcl</code></strong></td><td style="text-align:left">查询授权详情</td><td style="text-align:left">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建授权</span></span><br><span class="line">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class="line"><span class="comment"># 更新授权</span></span><br><span class="line">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class="line"><span class="comment"># 删除授权</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class="line"><span class="comment"># 删除授权，指定资源</span></span><br><span class="line">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权列表</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment"># 查询授权列表，带过滤条件</span></span><br><span class="line">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class="line"><span class="comment"># 查询授权详情</span></span><br><span class="line">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure><h2 id="Dashboard-配置">Dashboard 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><h2 id="Proxy-配置">Proxy 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href="https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href="https://github.com/apache/rocketmq/tree/develop/example">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p></li><li class="lvl-2"><p>按照这篇文章<a href="https://developer.aliyun.com/article/1569146">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;authenticationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authenticationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;innerClientAuthenticationCredentials&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;accessKey\&quot;:\&quot;mqadmin\&quot;, \&quot;secretKey\&quot;:\&quot;1234567\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorizationMetadataProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>异常信息如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.zcw159357.com/article/1/2025-03-15-0048.html">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enableAclRpcHookForClusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p></li><li class="lvl-2"><p>之后通过这篇文章 <a href="https://blog.csdn.net/icebamboo2015/article/details/152118732">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p></li></ul><h2 id="后记">后记</h2><ul class="lvl-0"><li class="lvl-2"><p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ ACL 2.0 的使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ ACL 1.0</title>
    <link href="https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/"/>
    <id>https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/</id>
    <published>2025-10-29T13:40:05.000Z</published>
    <updated>2025-10-31T10:10:05.001Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ ACL 1.0 的使用方法。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li><li class="lvl-2"><p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p></li></ul><span id="more"></span><h2 id="ACL-1-0-简介">ACL 1.0 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。</p></li><li class="lvl-2"><p>一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。</p></li></ul><h2 id="ACL-1-0-使用方法">ACL 1.0 使用方法</h2><ul class="lvl-0"><li class="lvl-2"><p>本文在 <a href="/2025/10/23/rocketmq-01-install/" title="RocketMQ 的安装及使用">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 1.0。</p></li><li class="lvl-2"><p>首先需要在 Broker 节点开启 ACL 权限，在 <code>broker.conf</code> 文件中添加如下配置，并重启 Broker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclEnable=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>权限配置文件为 <code>conf/plain_acl.yml</code>，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1</span></span><br><span class="line"><span class="comment"># 白名单内的 IP 都可以访问，无需配置帐号</span></span><br><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局白名单外的IP,需要账号访问</span></span><br><span class="line"><span class="comment"># 账号配置，数组形式</span></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="comment"># 当前帐号的白名单</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">false</span>        <span class="comment"># 是否是管理员</span></span><br><span class="line">    <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span> <span class="comment"># 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class="line">    <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span>  <span class="comment"># 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class="line">    <span class="attr">topicPerms:</span>            <span class="comment"># 特定的 topic 权限</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicA=DENY</span>        <span class="comment"># topicName=perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicC=SUB</span></span><br><span class="line">    <span class="attr">groupPerms:</span>            <span class="comment"># 特定的 ConsumerGroup 权限</span></span><br><span class="line">      <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupA=DENY</span>        <span class="comment"># groupName=perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupB=PUB|SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">    <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">true</span>         <span class="comment"># 是否是管理员,true 表示管理员,管理员可以访问所有资源</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>权限定义</p></li></ul><table><thead><tr><th style="text-align:left">权限值</th><th style="text-align:left">含义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>DENY</strong></td><td style="text-align:left">拒绝</td><td style="text-align:left">禁止对该 Topic 的任何操作（无论是发送还是订阅）</td></tr><tr><td style="text-align:left"><strong>ANY</strong></td><td style="text-align:left">任意权限</td><td style="text-align:left">具有发布（PUB）和订阅（SUB）双重权限</td></tr><tr><td style="text-align:left"><strong>PUB</strong></td><td style="text-align:left">发送权限</td><td style="text-align:left">允许生产者向该 Topic 发送消息</td></tr><tr><td style="text-align:left"><strong>SUB</strong></td><td style="text-align:left">订阅权限</td><td style="text-align:left">允许消费者订阅并消费该 Topic 的消息</td></tr></tbody></table><div class="tips"><p><em><strong>defaultGroupPerm: SUB</strong></em></p><ul class="lvl-1"><li class="lvl-2">表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。</li></ul></div><h3 id="命令行配置-ACL">命令行配置 ACL</h3><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><blockquote><p>以下命令执行后会自动修改 <code>conf/plain_acl.yml</code> 文件</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>添加白名单</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin updateGlobalWhiteAddr \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -g 10.250.0.*,10.252.*.*,10.20.0.31</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一必填</td><td style="text-align:left">指定要更新白名单的 <strong>Broker 地址</strong></td><td style="text-align:left"><code>127.0.0.1:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一必填</td><td style="text-align:left">指定要更新白名单的 <strong>Cluster 名称</strong>，集群内所有 Broker 都会被更新</td><td style="text-align:left"><code>DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">要设置的全局白名单地址列表，支持通配符</td><td style="text-align:left"><code>&quot;10.10.103.*,192.168.0.*&quot;</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 ACL 配置文件路径（Broker 端对应的配置文件路径）</td><td style="text-align:left"><code>/home/rocketmq/conf/plain_acl.yml</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建管理员</span></span><br><span class="line">sh bin/mqadmin updateAclConfig \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -a mqadmin \</span><br><span class="line">    -s 1234567 \</span><br><span class="line">    -m <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建普通用户</span></span><br><span class="line">sh bin/mqadmin updateAclConfig \</span><br><span class="line">  -c DefaultCluster \</span><br><span class="line">  -a rocketmq_user \</span><br><span class="line">  -s 12345678 \</span><br><span class="line">  -i <span class="string">&quot;PUB|SUB&quot;</span> \</span><br><span class="line">  -u SUB \</span><br><span class="line">  -t <span class="string">&quot;topicA=PUB|SUB,topicB=DENY&quot;</span> \</span><br><span class="line">  -g <span class="string">&quot;groupA=SUB,groupB=DENY&quot;</span> \</span><br><span class="line">  -w <span class="string">&quot;192.168.0.*&quot;</span> \</span><br><span class="line">  -n 127.0.0.1:9876</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th><th></th></tr></thead><tbody><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">用户名（accessKey）</td><td style="text-align:left"><code>rocketmq_user</code></td><td></td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">密码（secretKey）</td><td style="text-align:left"><code>12345678</code></td><td></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标 Broker 地址</td><td style="text-align:left"><code>127.0.0.1:10911</code></td><td></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标集群名称，集群中所有 Broker 都会被更新</td><td style="text-align:left"><code>DefaultCluster</code></td><td></td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 Group 权限列表</td><td style="text-align:left"><code>groupA=SUB,groupB=DENY</code></td><td></td></tr><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 Topic 权限列表</td><td style="text-align:left">`topicA=PUB</td><td>SUB,topicB=DENY`</td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置默认 Group 权限</td><td style="text-align:left"><code>SUB</code></td><td></td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置默认 Topic 权限</td><td style="text-align:left"><code>DENY</code></td><td></td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left">可选</td><td style="text-align:left">设置 IP 白名单</td><td style="text-align:left"><code>&quot;10.10.10.*,192.168.1.*&quot;</code></td><td></td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left">可选</td><td style="text-align:left">是否设置为管理员账号</td><td style="text-align:left"><code>true</code> 或 <code>false</code></td><td></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td><td></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>删除用户</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin deleteAccessConfig \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -a mqadmin</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">是否必填</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left">✅ 必填</td><td style="text-align:left">要删除的用户名（accessKey）</td><td style="text-align:left"><code>rocketmq_user</code></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标 Broker 地址</td><td style="text-align:left"><code>127.0.0.1:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">二选一</td><td style="text-align:left">指定目标集群名称（删除整个集群上的该账号）</td><td style="text-align:left"><code>DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left">可选</td><td style="text-align:left">指定 NameServer 地址</td><td style="text-align:left"><code>127.0.0.1:9876</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left">否</td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">—</td></tr></tbody></table><h2 id="Dashboard-配置">Dashboard 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">1234567</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Proxy-配置">Proxy 配置</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href="https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href="https://github.com/apache/rocketmq/tree/develop/example">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p></li></ul><h3 id="目前有两种没什么意义的解决方法：">目前有两种没什么意义的解决方法：</h3><ul class="lvl-0"><li class="lvl-2"><ol><li class="lvl-5">将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin updateGlobalWhiteAddr \</span><br><span class="line">    -n 127.0.0.1:9876 \</span><br><span class="line">    -c DefaultCluster \</span><br><span class="line">    -g 10.250.0.*</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><ol start="2"><li class="lvl-5">为 Proxy 开启 <code>enableAclRpcHookForClusterMode</code></li></ol><ul class="lvl-2"><li class="lvl-6">修改<code>conf/rmq-proxy.json</code>文件，添加<code>enableAclRpcHookForClusterMode</code>参数</li></ul>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enableAclRpcHookForClusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">修改<code>conf/tools.yml</code>文件，配置帐号信息：</li></ul>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">重新启动Proxy即可</li></ul></li><li class="lvl-2"><p>两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息</p></li><li class="lvl-2"><p>但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ ACL 1.0 的使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Admin Tool</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/</id>
    <published>2025-10-28T13:40:05.000Z</published>
    <updated>2025-10-31T08:54:49.101Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Admin Tool 的常用命令。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="RocketMQ-Admin-Tool-简介">RocketMQ Admin Tool 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool">RocketMQ Admin Tool</a> 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。</p></li></ul><h2 id="Topic-相关命令">Topic 相关命令</h2><ul class="lvl-0"><li class="lvl-2"><p>创建或更新 Topic</p></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全称</th><th style="text-align:left">说明</th><th style="text-align:left">可选值 / 格式</th><th style="text-align:left">是否必填</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">主题名称</td><td style="text-align:left">字符串</td><td style="text-align:left">✅ 必填</td><td style="text-align:left"><code>-t MyTopic</code></td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerAddr</code></td><td style="text-align:left">指定创建 Topic 的 Broker 地址（与 <code>-c</code> 二选一）</td><td style="text-align:left"><code>ip:port</code></td><td style="text-align:left">✅ 必填（与 <code>-c</code> 二选一）</td><td style="text-align:left"><code>-b 192.168.1.10:10911</code></td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--clusterName</code></td><td style="text-align:left">指定创建 Topic 的集群名（与 <code>-b</code> 二选一）</td><td style="text-align:left">字符串</td><td style="text-align:left">✅ 必填（与 <code>-b</code> 二选一）</td><td style="text-align:left"><code>-c DefaultCluster</code></td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址列表</td><td style="text-align:left">多个地址用 <code>;</code> 分隔</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-n 192.168.1.1:9876;192.168.1.2:9876</code></td></tr><tr><td style="text-align:left"><code>-r</code></td><td style="text-align:left"><code>--readQueueNums</code></td><td style="text-align:left">读队列数量，默认为8，始终保持 r == w</td><td style="text-align:left">整数</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-r 4</code></td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left"><code>--writeQueueNums</code></td><td style="text-align:left">写队列数量，默认为8，始终保持 r == w</td><td style="text-align:left">整数</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-w 4</code></td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--perm</code></td><td style="text-align:left">Topic 权限，默认为6</td><td style="text-align:left">2：写（W）<br>4：读（R）<br>6：读写（RW）</td><td style="text-align:left">可选</td><td style="text-align:left"><code>-p 6</code></td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--order</code></td><td style="text-align:left">是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO”</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-o false</code></td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left"><code>--unit</code></td><td style="text-align:left">是否为单元（Unit）Topic（用于多租户隔离）</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-u false</code></td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--hasUnitSub</code></td><td style="text-align:left">是否有 Unit 订阅</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-s false</code></td></tr><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left">额外属性设置，用 <code>+</code> 表示添加、<code>-</code> 表示删除</td><td style="text-align:left">例：<code>+a=b,+c=d,-e</code></td><td style="text-align:left">可选</td><td style="text-align:left"><code>-a &quot;+message.type=NORMAL&quot;</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:left">无</td><td style="text-align:left">否</td><td style="text-align:left"><code>-h</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topic</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br><span class="line"><span class="comment"># 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建</span></span><br><span class="line">sh bin/mqadmin updateTopic  -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic</span><br><span class="line"><span class="comment"># 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMAL</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a <span class="string">&quot;+message.type=NORMAL&quot;</span></span><br><span class="line"><span class="comment"># 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a <span class="string">&quot;+message.type=FIFO&quot;</span></span><br><span class="line"><span class="comment"># 指定权限，默认为 6：读写</span></span><br><span class="line">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看与删除 Topic</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有 Topic，此时只打印 topic 列表</span></span><br><span class="line">sh bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class="line"><span class="comment"># 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Group</span></span><br><span class="line">sh bin/mqadmin topicList -n 127.0.0.1:9876 -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Topic，删除指定集群下的指定Topic</span></span><br><span class="line">sh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>其它 Topic 命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Topic 路由信息</span></span><br><span class="line">sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerDatas&quot;</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerAddrs&quot;</span>:&#123;0:<span class="string">&quot;10.250.0.188:11011&quot;</span>,1:<span class="string">&quot;10.250.0.31:10911&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-b&quot;</span>,</span><br><span class="line"><span class="string">&quot;cluster&quot;</span>:<span class="string">&quot;DefaultCluster&quot;</span>,</span><br><span class="line"><span class="string">&quot;enableActingMaster&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerAddrs&quot;</span>:&#123;0:<span class="string">&quot;10.250.0.31:11011&quot;</span>,1:<span class="string">&quot;10.250.0.188:10911&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-a&quot;</span>,</span><br><span class="line"><span class="string">&quot;cluster&quot;</span>:<span class="string">&quot;DefaultCluster&quot;</span>,</span><br><span class="line"><span class="string">&quot;enableActingMaster&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;filterServerTable&quot;</span>:&#123;&#125;,</span><br><span class="line"><span class="string">&quot;queueDatas&quot;</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-b&quot;</span>,</span><br><span class="line"><span class="string">&quot;perm&quot;</span>:6,</span><br><span class="line"><span class="string">&quot;readQueueNums&quot;</span>:8,</span><br><span class="line"><span class="string">&quot;topicSysFlag&quot;</span>:0,</span><br><span class="line"><span class="string">&quot;writeQueueNums&quot;</span>:8</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;brokerName&quot;</span>:<span class="string">&quot;broker-a&quot;</span>,</span><br><span class="line"><span class="string">&quot;perm&quot;</span>:6,</span><br><span class="line"><span class="string">&quot;readQueueNums&quot;</span>:8,</span><br><span class="line"><span class="string">&quot;topicSysFlag&quot;</span>:0,</span><br><span class="line"><span class="string">&quot;writeQueueNums&quot;</span>:8</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Topic 消息队列offset</span></span><br><span class="line">sh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Broker Name                      #QID  #Min Offset           #Max Offset             #Last Updated</span></span><br><span class="line">broker-a                          0     0                     3                       2025-10-27 03:08:43,112</span><br><span class="line">broker-a                          1     0                     4                       2025-10-27 06:13:21,968</span><br><span class="line">broker-a                          2     0                     2                       2025-10-27 06:13:34,685</span><br><span class="line">broker-a                          3     0                     2                       2025-10-26 05:44:17,222</span><br><span class="line">broker-a                          4     0                     1                       2025-10-26 05:44:45,513</span><br><span class="line">broker-a                          5     0                     1                       2025-10-26 06:13:10,541</span><br><span class="line">broker-a                          6     0                     2                       2025-10-26 02:58:34,393</span><br><span class="line">broker-a                          7     0                     1                       2025-10-25 12:42:41,189</span><br><span class="line">broker-b                          0     0                     1                       2025-10-25 14:01:24,836</span><br><span class="line">broker-b                          1     0                     2                       2025-10-26 06:14:24,411</span><br><span class="line">broker-b                          2     0                     0</span><br><span class="line">broker-b                          3     0                     0</span><br><span class="line">broker-b                          4     0                     0</span><br><span class="line">broker-b                          5     0                     1                       2025-10-25 12:30:57,672</span><br><span class="line">broker-b                          6     0                     1                       2025-10-26 06:19:47,051</span><br><span class="line">broker-b                          7     0                     1                       2025-10-26 06:14:49,216</span><br></pre></td></tr></table></figure><h2 id="集群相关命令">集群相关命令</h2><ul class="lvl-0"><li class="lvl-2"><p>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群信息</span></span><br><span class="line">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class="line">DefaultCluster          broker-a                0     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               2.60(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.03         0.3300          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-a                1     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  67.03         0.3200         <span class="literal">false</span></span><br><span class="line">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.80(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3200          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-b                1     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3300         <span class="literal">false</span></span><br><span class="line"><span class="comment">## Broker 统计信息</span></span><br><span class="line"><span class="comment">#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line"><span class="comment">#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)</span></span><br><span class="line"><span class="comment">#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)</span></span><br><span class="line"><span class="comment">#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计</span></span><br><span class="line"><span class="comment">#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好</span></span><br><span class="line"><span class="comment">#Hour: 表示 Broker 已运行的时长</span></span><br><span class="line"><span class="comment">#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%</span></span><br><span class="line"><span class="comment">#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群统计信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Cluster Name     #Broker Name                       #InTotalYest  #OutTotalYest  #InTotalToday #OutTotalToday</span></span><br><span class="line">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class="line">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class="line">DefaultCluster    broker-b                                      0            369              0              0</span><br><span class="line">DefaultCluster    broker-b                                      0              0              0              0</span><br><span class="line"><span class="comment">## Broker 统计信息</span></span><br><span class="line"><span class="comment">#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数</span></span><br><span class="line"><span class="comment">#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数</span></span><br><span class="line"><span class="comment">#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数</span></span><br><span class="line"><span class="comment">#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数</span></span><br></pre></td></tr></table></figure><h2 id="消息相关">消息相关</h2><h3 id="发送消息">发送消息</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">消息要发送的 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必须指定目标 Topic</td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--body</code></td><td style="text-align:left">消息体内容（UTF-8 字符串）</td><td style="text-align:center">✅</td><td style="text-align:left"><code>&quot;Hello RocketMQ&quot;</code></td><td style="text-align:left">实际消息内容</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">不指定则用默认配置</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--broker</code></td><td style="text-align:left">指定发送到哪个 broker</td><td style="text-align:center">❌</td><td style="text-align:left"><code>broker-a</code></td><td style="text-align:left">一般用于测试 Broker 状态</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--qid</code></td><td style="text-align:left">指定发送到的队列 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2</code></td><td style="text-align:left">一般不需要设置，RocketMQ 会自动选择</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--tags</code></td><td style="text-align:left">消息的标签（tag）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>testTag</code></td><td style="text-align:left">用于消息过滤</td></tr><tr><td style="text-align:left"><code>-k</code></td><td style="text-align:left"><code>--key</code></td><td style="text-align:left">消息的业务键（key）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>order123</code></td><td style="text-align:left">可用于追踪消息</td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left"><code>--msgTraceEnable</code></td><td style="text-align:left">是否开启消息轨迹</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">默认 <code>false</code></td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令参数说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class="string">&quot;Hello RocketMQ&quot;</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#Broker Name                      #QID  #Send Result            #MsgId</span></span><br><span class="line">broker-b                          2     SEND_OK                 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line"><span class="comment">## 输出解释</span></span><br><span class="line"><span class="comment">#Broker Name: Broker 名称</span></span><br><span class="line"><span class="comment">#QID: 队列 ID</span></span><br><span class="line"><span class="comment">#Send Result: 发送结果，SEND_OK 表示成功</span></span><br><span class="line"><span class="comment">#MsgId: 消息 ID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 tags、key</span></span><br><span class="line">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class="string">&quot;Hello RocketMQ&quot;</span> -c testTag -k order123</span><br></pre></td></tr></table></figure><h3 id="消费消息">消费消息</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">目标 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议填写以避免默认配置不生效</td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--consumerGroup</code></td><td style="text-align:left">消费组名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>TestGroup</code></td><td style="text-align:left">可指定消费组（影响消费位点）</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerName</code></td><td style="text-align:left">Broker 名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>broker-a</code></td><td style="text-align:left">指定从哪个 broker 拉取消息</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--queueId</code></td><td style="text-align:left">队列 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">默认从 0 号队列开始</td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--offset</code></td><td style="text-align:left">队列起始偏移量（offset）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">指定从哪个位置开始消费</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--MessageNumber</code></td><td style="text-align:left">消费消息数量</td><td style="text-align:center">❌</td><td style="text-align:left"><code>10</code></td><td style="text-align:left">默认通常为 1</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--beginTimestamp</code></td><td style="text-align:left">起始时间</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2025-10-28#10:00:00:000</code></td><td style="text-align:left">格式或时间戳均可</td></tr><tr><td style="text-align:left"><code>-e</code></td><td style="text-align:left"><code>--endTimestamp</code></td><td style="text-align:left">结束时间</td><td style="text-align:center">❌</td><td style="text-align:left"><code>2025-10-28#12:00:00:000</code></td><td style="text-align:left">与 <code>-s</code> 一起使用</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令参数说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认从队列 0 开始消费，拉取全部消息</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic</span><br><span class="line"><span class="comment"># 拉取指定条数的消息，-c 指定拉取条数</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10</span><br><span class="line"><span class="comment"># 指定偏移量，此时必须同时指定 brokerName、queueId、offset</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3</span><br><span class="line"><span class="comment"># 指定消费者组</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup</span><br><span class="line"><span class="comment"># 指定时间范围</span></span><br><span class="line">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000</span><br></pre></td></tr></table></figure><h4 id="消费结果">消费结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Consume ok</span><br><span class="line">MSGID: 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line">MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0,</span><br><span class="line">  bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362,</span><br><span class="line">  storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011,</span><br><span class="line">  msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881,</span><br><span class="line">  bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0,</span><br><span class="line">  toString()=Message&#123;topic=<span class="string">&#x27;TestTopic&#x27;</span>, flag=0,</span><br><span class="line">    properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000,</span><br><span class="line">      CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=<span class="literal">true</span>, TRACE_ON=<span class="literal">true</span>, MAX_OFFSET=1&#125;,</span><br><span class="line">    body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81],</span><br><span class="line">    transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]</span><br><span class="line">BODY: Hello RocketMQ</span><br><span class="line"></span><br><span class="line">MessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] <span class="built_in">print</span> msg finished. status=NO_NEW_MSG, offset=1</span><br><span class="line">The older -1 message of the 2 queue will be provided</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>📘 字段解析表格</p></li></ul><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">示例值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MSGID</strong></td><td style="text-align:left"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">消息唯一标识（客户端生成）</td></tr><tr><td style="text-align:left"><strong>brokerName</strong></td><td style="text-align:left"><code>broker-b</code></td><td style="text-align:left">消息存储在哪个 Broker 上</td></tr><tr><td style="text-align:left"><strong>queueId</strong></td><td style="text-align:left"><code>2</code></td><td style="text-align:left">存储的队列编号（TestTopic 有多个队列时的第 3 个）</td></tr><tr><td style="text-align:left"><strong>queueOffset</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">队列中的偏移量（从 0 开始）</td></tr><tr><td style="text-align:left"><strong>storeSize</strong></td><td style="text-align:left"><code>228</code></td><td style="text-align:left">消息在磁盘中的存储字节大小</td></tr><tr><td style="text-align:left"><strong>sysFlag</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">消息系统标志位（内部用途）</td></tr><tr><td style="text-align:left"><strong>bornTimestamp</strong></td><td style="text-align:left"><code>1761638706671</code></td><td style="text-align:left">消息在生产者端创建的时间（毫秒）</td></tr><tr><td style="text-align:left"><strong>bornHost</strong></td><td style="text-align:left"><code>/10.250.0.175:41362</code></td><td style="text-align:left">生产者客户端的 IP 和端口</td></tr><tr><td style="text-align:left"><strong>storeTimestamp</strong></td><td style="text-align:left"><code>1761638706691</code></td><td style="text-align:left">消息被 Broker 存储的时间（毫秒）</td></tr><tr><td style="text-align:left"><strong>storeHost</strong></td><td style="text-align:left"><code>/10.250.0.188:11011</code></td><td style="text-align:left">Broker 的存储节点地址</td></tr><tr><td style="text-align:left"><strong>msgId</strong></td><td style="text-align:left"><code>0AFA00BC00002B0300000000000CA1E9</code></td><td style="text-align:left">消息在 Broker 存储系统生成的唯一 ID</td></tr><tr><td style="text-align:left"><strong>commitLogOffset</strong></td><td style="text-align:left"><code>827881</code></td><td style="text-align:left">消息在 commitLog 文件中的偏移量</td></tr><tr><td style="text-align:left"><strong>bodyCRC</strong></td><td style="text-align:left"><code>1774740973</code></td><td style="text-align:left">消息体的 CRC 校验码（用于校验数据一致性）</td></tr><tr><td style="text-align:left"><strong>reconsumeTimes</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">被重新消费的次数（0 表示第一次消费）</td></tr><tr><td style="text-align:left"><strong>preparedTransactionOffset</strong></td><td style="text-align:left"><code>0</code></td><td style="text-align:left">如果是事务消息，这里会记录预提交偏移量；普通消息为 0</td></tr><tr><td style="text-align:left"><strong>topic</strong></td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">消息所属主题</td></tr><tr><td style="text-align:left"><strong>properties</strong></td><td style="text-align:left"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125;</code></td><td style="text-align:left">消息属性，包括系统属性与用户属性</td></tr><tr><td style="text-align:left"><strong>body</strong></td><td style="text-align:left"><code>[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81]</code></td><td style="text-align:left">消息体的字节数组</td></tr><tr><td style="text-align:left"><strong>BODY（解码后）</strong></td><td style="text-align:left"><code>Hello RocketMQ</code></td><td style="text-align:left">实际消息内容（UTF-8 字符串）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>⚙️ 消息状态说明</p></li></ul><table><thead><tr><th style="text-align:left">输出信息</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>Consume ok</code></td><td style="text-align:left">表示成功从 Broker 拉取消息</td></tr><tr><td style="text-align:left"><code>status=NO_NEW_MSG</code></td><td style="text-align:left">当前队列（queueId=2）中已经没有比 offset=1 更新的消息</td></tr><tr><td style="text-align:left"><code>offset=1</code></td><td style="text-align:left">当前队列消费到 offset=1（下次消费从此开始）</td></tr><tr><td style="text-align:left"><code>The older -1 message of the 2 queue will be provided</code></td><td style="text-align:left">这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息）</td></tr></tbody></table><h3 id="查询消息">查询消息</h3><h4 id="根据消息-ID-查询消息-queryMsgById">根据消息 ID 查询消息(queryMsgById)</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--msgId</code></td><td style="text-align:left">要查询的消息 ID</td><td style="text-align:center">✅</td><td style="text-align:left"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">必填，用于精确定位消息</td></tr><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left"><code>--topic</code></td><td style="text-align:left">目标 Topic 名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议明确指定</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--cluster</code></td><td style="text-align:left">集群名称或 LMQ 父 Topic</td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">在多集群场景下使用</td></tr><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--consumerGroup</code></td><td style="text-align:left">消费组名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>TestGroup</code></td><td style="text-align:left">当用于消费者关联查询时可指定</td></tr><tr><td style="text-align:left"><code>-d</code></td><td style="text-align:left"><code>--clientId</code></td><td style="text-align:left">消费者客户端 ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>192.168.0.1@12345</code></td><td style="text-align:left">辅助定位消费实例</td></tr><tr><td style="text-align:left"><code>-f</code></td><td style="text-align:left"><code>--bodyFormat</code></td><td style="text-align:left">消息体输出格式</td><td style="text-align:center">❌</td><td style="text-align:left"><code>UTF-8</code> / <code>HEX</code> / <code>BASE64</code></td><td style="text-align:left">默认 UTF-8</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--sendMessage</code></td><td style="text-align:left">是否重新发送消息</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">调试时可使用</td></tr><tr><td style="text-align:left"><code>-u</code></td><td style="text-align:left"><code>--unitName</code></td><td style="text-align:left">单元名（多单元部署时使用）</td><td style="text-align:center">❌</td><td style="text-align:left"><code>unit01</code></td><td style="text-align:left">一般场景可忽略</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助信息</td><td style="text-align:center">❌</td><td style="text-align:left">无</td><td style="text-align:left">显示命令说明</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">OffsetID:            0AFA00BC00002B0300000000000CA1E9</span><br><span class="line">Topic:               TestTopic</span><br><span class="line">Tags:                [null]</span><br><span class="line">Keys:                [null]</span><br><span class="line">Queue ID:            2</span><br><span class="line">Queue Offset:        0</span><br><span class="line">CommitLog Offset:    827881</span><br><span class="line">Reconsume Times:     0</span><br><span class="line">Born Timestamp:      2025-10-28 08:05:06,671</span><br><span class="line">Store Timestamp:     2025-10-28 08:05:06,691</span><br><span class="line">Born Host:           10.250.0.175:41362</span><br><span class="line">Store Host:          10.250.0.188:11011</span><br><span class="line">System Flag:         0</span><br><span class="line">Properties:          &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=<span class="literal">true</span>, TRACE_ON=<span class="literal">true</span>&#125;</span><br><span class="line">Message Body Path:   /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class="line">Message Body:        Hello RocketMQ</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>输出字段详解</p></li></ul><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>OffsetID</strong></td><td style="text-align:left">消息在 CommitLog 中的偏移标识（内部定位使用）</td><td style="text-align:left"><code>0AFA00BC00002B0300000000000CA1E9</code></td><td style="text-align:left">可用于 broker 内部追踪定位消息</td></tr><tr><td style="text-align:left"><strong>Topic</strong></td><td style="text-align:left">主题名称</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">消息所属的主题</td></tr><tr><td style="text-align:left"><strong>Tags</strong></td><td style="text-align:left">消息标签</td><td style="text-align:left"><code>[null]</code></td><td style="text-align:left">若生产消息时未设置 tag，则为 null</td></tr><tr><td style="text-align:left"><strong>Keys</strong></td><td style="text-align:left">消息键</td><td style="text-align:left"><code>[null]</code></td><td style="text-align:left">通常可用于业务层索引查询</td></tr><tr><td style="text-align:left"><strong>Queue ID</strong></td><td style="text-align:left">消息所在的队列编号</td><td style="text-align:left"><code>2</code></td><td style="text-align:left">对应 topic 的第 3 个队列（从 0 开始）</td></tr><tr><td style="text-align:left"><strong>Queue Offset</strong></td><td style="text-align:left">队列偏移量</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">表示是该队列的第一条消息</td></tr><tr><td style="text-align:left"><strong>CommitLog Offset</strong></td><td style="text-align:left">消息在 commitlog 文件中的偏移量</td><td style="text-align:left"><code>827881</code></td><td style="text-align:left">broker 存储层位置</td></tr><tr><td style="text-align:left"><strong>Reconsume Times</strong></td><td style="text-align:left">被重新消费的次数</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">表示未重试消费过</td></tr><tr><td style="text-align:left"><strong>Born Timestamp</strong></td><td style="text-align:left">消息生成时间</td><td style="text-align:left"><code>2025-10-28 08:05:06,671</code></td><td style="text-align:left">生产者发送消息的时间</td></tr><tr><td style="text-align:left"><strong>Store Timestamp</strong></td><td style="text-align:left">消息存储时间</td><td style="text-align:left"><code>2025-10-28 08:05:06,691</code></td><td style="text-align:left">broker 写入消息的时间（通常相差几毫秒）</td></tr><tr><td style="text-align:left"><strong>Born Host</strong></td><td style="text-align:left">生产者客户端 IP:端口</td><td style="text-align:left"><code>10.250.0.175:41362</code></td><td style="text-align:left">生产者所在机器</td></tr><tr><td style="text-align:left"><strong>Store Host</strong></td><td style="text-align:left">broker 存储该消息的地址</td><td style="text-align:left"><code>10.250.0.188:11011</code></td><td style="text-align:left">对应的 broker 服务端</td></tr><tr><td style="text-align:left"><strong>System Flag</strong></td><td style="text-align:left">系统标志位</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部使用（标识压缩/事务等）</td></tr><tr><td style="text-align:left"><strong>Properties</strong></td><td style="text-align:left">消息属性</td><td style="text-align:left"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;</code></td><td style="text-align:left">包含 RocketMQ 自动附加的元数据</td></tr><tr><td style="text-align:left"><strong>Message Body Path</strong></td><td style="text-align:left">消息体在本地保存的文件路径</td><td style="text-align:left"><code>/tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</code></td><td style="text-align:left">RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看</td></tr><tr><td style="text-align:left"><strong>Message Body</strong></td><td style="text-align:left">消息内容</td><td style="text-align:left"><code>Hello RocketMQ</code></td><td style="text-align:left">消息内容</td></tr></tbody></table><h4 id="根据消息-Key-查询消息-queryMsgByKey">根据消息 Key 查询消息(queryMsgByKey)</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">必填</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-t, --topic</code></td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestTopic</code></td><td style="text-align:left">要查询的主题名称</td></tr><tr><td style="text-align:left"><code>-k, --msgKey</code></td><td style="text-align:center">✅</td><td style="text-align:left"><code>order_10001</code></td><td style="text-align:left">发送消息时设置的业务 Key</td></tr><tr><td style="text-align:left"><code>-n, --namesrvAddr</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">NameServer 地址</td></tr><tr><td style="text-align:left"><code>-c, --cluster</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">指定集群名称（可选）</td></tr><tr><td style="text-align:left"><code>-b, --beginTimestamp</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>1730083200000</code></td><td style="text-align:left">查询起始时间戳（ms）</td></tr><tr><td style="text-align:left"><code>-e, --endTimestamp</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>1730173200000</code></td><td style="text-align:left">查询结束时间戳（ms）</td></tr><tr><td style="text-align:left"><code>-m, --maxNum</code></td><td style="text-align:center">❌</td><td style="text-align:left"><code>64</code></td><td style="text-align:left">返回的最大消息数，默认 64</td></tr><tr><td style="text-align:left"><code>-h, --help</code></td><td style="text-align:center">❌</td><td style="text-align:left">-</td><td style="text-align:left">打印帮助信息</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123</span><br><span class="line"><span class="comment">## 查询结果</span></span><br><span class="line"><span class="comment">#Message ID                                        #QID                                  #Offset</span></span><br><span class="line">0AFA00AFCF781EB44E468CC902A30000                      7                                        1</span><br></pre></td></tr></table></figure><h2 id="消费者">消费者</h2><h4 id="创建或更新消费者订阅组-updateSubGroup">创建或更新消费者订阅组(updateSubGroup)</h4><ul class="lvl-0"><li class="lvl-2"><p>消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如：</p><ul class="lvl-2"><li class="lvl-6">消费顺序（顺序/并发）</li><li class="lvl-6">广播模式</li><li class="lvl-6">消费使能</li><li class="lvl-6">消费重试策略</li><li class="lvl-6">延迟消费队列等</li></ul></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">全写</th><th style="text-align:left">说明</th><th style="text-align:center">是否必填</th><th style="text-align:left">示例值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left"><code>--groupName</code></td><td style="text-align:left">消费者组名称</td><td style="text-align:center">✅</td><td style="text-align:left"><code>TestConsumerGroup</code></td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left"><code>-n</code></td><td style="text-align:left"><code>--namesrvAddr</code></td><td style="text-align:left">NameServer 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>127.0.0.1:9876</code></td><td style="text-align:left">建议明确指定</td></tr><tr><td style="text-align:left"><code>-b</code></td><td style="text-align:left"><code>--brokerAddr</code></td><td style="text-align:left">指定 Broker 地址</td><td style="text-align:center">❌</td><td style="text-align:left"><code>10.250.0.188:10911</code></td><td style="text-align:left">仅对单 Broker 更新</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left"><code>--clusterName</code></td><td style="text-align:left">指定 Cluster 名称</td><td style="text-align:center">❌</td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">对整个集群更新</td></tr><tr><td style="text-align:left"><code>-d</code></td><td style="text-align:left"><code>--consumeBroadcastEnable</code></td><td style="text-align:left">是否广播消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">true 表示广播，false 表示集群模式</td></tr><tr><td style="text-align:left"><code>-o</code></td><td style="text-align:left"><code>--consumeMessageOrderly</code></td><td style="text-align:left">是否顺序消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">顺序消费只在同队列中生效</td></tr><tr><td style="text-align:left"><code>-i</code></td><td style="text-align:left"><code>--brokerId</code></td><td style="text-align:left">从哪个 Broker 获取订阅信息</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部用途，通常不用设置</td></tr><tr><td style="text-align:left"><code>-m</code></td><td style="text-align:left"><code>--consumeFromMinEnable</code></td><td style="text-align:left">是否从最小 offset 消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">新组首次消费时生效</td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left"><code>--groupRetryPolicy</code></td><td style="text-align:left">消费组重试策略 JSON</td><td style="text-align:center">❌</td><td style="text-align:left"><code>&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;</code></td><td style="text-align:left">可以自定义重试间隔</td></tr><tr><td style="text-align:left"><code>-q</code></td><td style="text-align:left"><code>--retryQueueNums</code></td><td style="text-align:left">重试队列数量</td><td style="text-align:center">❌</td><td style="text-align:left"><code>1</code> ~ <code>16</code></td><td style="text-align:left">默认为 1</td></tr><tr><td style="text-align:left"><code>-r</code></td><td style="text-align:left"><code>--retryMaxTimes</code></td><td style="text-align:left">最大重试次数</td><td style="text-align:center">❌</td><td style="text-align:left"><code>16</code></td><td style="text-align:left">默认 16 次</td></tr><tr><td style="text-align:left"><code>-s</code></td><td style="text-align:left"><code>--consumeEnable</code></td><td style="text-align:left">是否使能消费</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">false 表示暂停消费</td></tr><tr><td style="text-align:left"><code>-w</code></td><td style="text-align:left"><code>--whichBrokerWhenConsumeSlowly</code></td><td style="text-align:left">慢消费选择 Broker ID</td><td style="text-align:center">❌</td><td style="text-align:left"><code>0</code></td><td style="text-align:left">内部使用</td></tr><tr><td style="text-align:left"><code>-a</code></td><td style="text-align:left"><code>--notifyConsumerIdsChanged</code></td><td style="text-align:left">通知 ConsumerId 改变</td><td style="text-align:center">❌</td><td style="text-align:left"><code>true</code> / <code>false</code></td><td style="text-align:left">可触发消费者刷新订阅信息</td></tr><tr><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left"><code>--attributes</code></td><td style="text-align:left">其他自定义属性</td><td style="text-align:center">❌</td><td style="text-align:left"><code>attr1=val1,attr2=val2</code></td><td style="text-align:left">可设置自定义配置</td></tr><tr><td style="text-align:left"><code>-h</code></td><td style="text-align:left"><code>--help</code></td><td style="text-align:left">打印帮助</td><td style="text-align:center">❌</td><td style="text-align:left">-</td><td style="text-align:left">显示命令帮助</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建普通消费者组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876</span><br><span class="line"><span class="comment"># 创建顺序消费组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建广播消费组</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义属性的消费者组，这里配置了重试策略</span></span><br><span class="line">sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d <span class="literal">true</span> -o <span class="literal">true</span> -m <span class="literal">true</span> -p <span class="string">&#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27;</span> -q 1 -r 16 -s <span class="literal">true</span> -w 0 -a <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="删除消费者订阅组-deleteSubGroup">删除消费者订阅组(deleteSubGroup)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster</span><br></pre></td></tr></table></figure><h2 id="重要说明">重要说明</h2><ul class="lvl-0"><li class="lvl-2"><p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accessKey:</span> <span class="string">mqadmin</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Admin Tool 的常用命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Proxy 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/</id>
    <published>2025-10-28T13:33:05.000Z</published>
    <updated>2025-10-30T06:45:46.620Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Proxy 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。</p></li><li class="lvl-2"><p>另外在源码 <code>rocketmq-all-5.3.2-source-release/proxy</code> 的启动类 <code>org.apache.rocketmq.proxy.ProxyStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.proxy.config.ProxyConfig</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th><th style="text-align:left">优化建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础信息</strong></td><td style="text-align:left"><code>rocketMQClusterName</code></td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">Broker 集群名称（Proxy 用于关联 RocketMQ 集群）</td><td style="text-align:left">若有多个集群，应唯一命名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>proxyClusterName</code></td><td style="text-align:left"><code>DefaultCluster</code></td><td style="text-align:left">Proxy 所属集群名称（与 brokerClusterName 可不同）</td><td style="text-align:left">✅建议独立命名，区分 Proxy 集群</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>proxyName</code></td><td style="text-align:left">主机名（例：<code>ip-10-250-0-175...</code>）</td><td style="text-align:left">Proxy 实例名称，用于唯一标识</td><td style="text-align:left">✅建议设置唯一名称</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>localServeAddr</code></td><td style="text-align:left">本地 IP</td><td style="text-align:left">Proxy 本地服务地址（Remoting 通信使用）</td><td style="text-align:left">✅建议显式指定 IP</td></tr><tr><td style="text-align:left"><strong>Namesrv</strong></td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left">多个地址（分号分隔）</td><td style="text-align:left">NameServer 地址，Proxy 通过它同步路由</td><td style="text-align:left">✅推荐配置为可访问的内网地址</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>namesrvDomain</code></td><td style="text-align:left">空</td><td style="text-align:left">NameServer 域名（可用于动态解析）</td><td style="text-align:left">可选，DNS 方式时使用</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>namesrvDomainSubgroup</code></td><td style="text-align:left">空</td><td style="text-align:left">子域分组（多集群域名发现用）</td><td style="text-align:left">一般可忽略</td></tr><tr><td style="text-align:left"><strong>TLS 配置</strong></td><td style="text-align:left"><code>tlsTestModeEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">测试模式下跳过验证（仅用于本地测试）</td><td style="text-align:left">❗生产应设为 false</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>tlsKeyPath</code></td><td style="text-align:left"><code>/conf/tls/rocketmq.key</code></td><td style="text-align:left">TLS 私钥路径</td><td style="text-align:left">✅根据证书路径调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>tlsCertPath</code></td><td style="text-align:left"><code>/conf/tls/rocketmq.crt</code></td><td style="text-align:left">TLS 证书路径</td><td style="text-align:left">✅根据证书路径调整</td></tr><tr><td style="text-align:left"><strong>gRPC 基础</strong></td><td style="text-align:left"><code>proxyMode</code></td><td style="text-align:left"><code>CLUSTER</code></td><td style="text-align:left">Proxy 模式：CLUSTER / LOCAL / REMOTING</td><td style="text-align:left">✅生产推荐 CLUSTER</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcServerPort</code></td><td style="text-align:left">8081</td><td style="text-align:left">gRPC 服务端监听端口</td><td style="text-align:left">若冲突可修改</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcShutdownTimeSeconds</code></td><td style="text-align:left">30</td><td style="text-align:left">优雅关闭等待时间</td><td style="text-align:left">可适当调大</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableGrpcEpoll</code></td><td style="text-align:left">false</td><td style="text-align:left">启用 Linux epoll I/O 模型</td><td style="text-align:left">✅Linux 建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcMaxInboundMessageSize</code></td><td style="text-align:left">136314880 (~130MB)</td><td style="text-align:left">最大入站消息大小</td><td style="text-align:left">根据消息大小调整</td></tr><tr><td style="text-align:left"><strong>消息限制</strong></td><td style="text-align:left"><code>maxMessageSize</code></td><td style="text-align:left">4194304 (4MB)</td><td style="text-align:left">最大消息体大小</td><td style="text-align:left">✅应与 Broker 一致</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableMessageBodyEmptyCheck</code></td><td style="text-align:left">true</td><td style="text-align:left">校验消息体是否为空</td><td style="text-align:left">保持默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxUserPropertySize</code></td><td style="text-align:left">16384 (16KB)</td><td style="text-align:left">用户属性最大长度</td><td style="text-align:left">根据业务复杂度调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>userPropertyMaxNum</code></td><td style="text-align:left">128</td><td style="text-align:left">单条消息最大属性数量</td><td style="text-align:left">可适当调低防止性能损耗</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxMessageGroupSize</code></td><td style="text-align:left">64</td><td style="text-align:left">最大消息组大小（批量 pop 使用）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>消息可见性与延迟</strong></td><td style="text-align:left"><code>defaultInvisibleTimeMills</code></td><td style="text-align:left">60000 (60s)</td><td style="text-align:left">pop 消息默认不可见时间</td><td style="text-align:left">✅高并发时可调低</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxInvisibleTimeMills</code></td><td style="text-align:left">43200000 (12h)</td><td style="text-align:left">最大不可见时长</td><td style="text-align:left">✅可根据业务降低</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxDelayTimeMills</code></td><td style="text-align:left">86400000 (1d)</td><td style="text-align:left">最大延迟时间</td><td style="text-align:left">与 Broker 保持一致</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useDelayLevel</code></td><td style="text-align:left">false</td><td style="text-align:left">是否使用延迟等级模式</td><td style="text-align:left">若 Broker 启用等级延迟则开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>messageDelayLevel</code></td><td style="text-align:left"><code>&quot;1s 5s 10s ... 2h&quot;</code></td><td style="text-align:left">延迟等级配置表</td><td style="text-align:left">✅需与 broker.conf 对齐</td></tr><tr><td style="text-align:left"><strong>线程池（gRPC 模块）</strong></td><td style="text-align:left"><code>grpcBossLoopNum</code></td><td style="text-align:left">1</td><td style="text-align:left">Netty boss 线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcWorkerLoopNum</code></td><td style="text-align:left">4</td><td style="text-align:left">gRPC worker 线程</td><td style="text-align:left">✅CPU&gt;4 时可调高至核数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcThreadPoolNums</code></td><td style="text-align:left">20</td><td style="text-align:left">gRPC 业务线程数</td><td style="text-align:left">✅建议 ≈ CPU 核数×2</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>grpcThreadPoolQueueCapacity</code></td><td style="text-align:left">100000</td><td style="text-align:left">队列容量</td><td style="text-align:left">⚠️建议 ≤20000，防 OOM</td></tr><tr><td style="text-align:left"><strong>线程池（内部模块）</strong></td><td style="text-align:left"><code>producerProcessorThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">生产者处理线程</td><td style="text-align:left">✅可根据QPS调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>consumerProcessorThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">消费者处理线程</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>topicRouteServiceThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">路由服务线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>renewThreadPoolNums</code></td><td style="text-align:left">2</td><td style="text-align:left">自动续期线程</td><td style="text-align:left">高并发时可调大</td></tr><tr><td style="text-align:left"><strong>缓存配置</strong></td><td style="text-align:left"><code>topicRouteServiceCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">路由缓存有效期</td><td style="text-align:left">✅可适当调大</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>topicConfigCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">Topic 配置缓存有效期</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>subscriptionGroupConfigCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">订阅组缓存有效期</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>aclCacheExpiredSeconds</code></td><td style="text-align:left">300</td><td style="text-align:left">ACL 缓存有效期</td><td style="text-align:left">✅同上</td></tr><tr><td style="text-align:left"><strong>事务与心跳</strong></td><td style="text-align:left"><code>transactionHeartbeatThreadPoolNums</code></td><td style="text-align:left">20</td><td style="text-align:left">事务心跳线程数</td><td style="text-align:left">✅根据事务量调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionHeartbeatPeriodSecond</code></td><td style="text-align:left">20</td><td style="text-align:left">事务心跳周期</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionDataExpireMillis</code></td><td style="text-align:left">30000</td><td style="text-align:left">事务数据过期时间</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>指标与监控</strong></td><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">DISABLE</td><td style="text-align:left">指标导出方式：DISABLE / PROM / GRPC / LOG</td><td style="text-align:left">✅建议启用 PROM</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">Prometheus 导出端口</td><td style="text-align:left">✅建议暴露监控</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsInDelta</code></td><td style="text-align:left">false</td><td style="text-align:left">是否按增量导出指标</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>Remoting 模式</strong></td><td style="text-align:left"><code>enableRemotingLocalProxyGrpc</code></td><td style="text-align:left">true</td><td style="text-align:left">启用本地 Proxy gRPC 转发</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>remotingListenPort</code></td><td style="text-align:left">8080</td><td style="text-align:left">Remoting 通信端口</td><td style="text-align:left">若冲突修改</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>sendLatencyEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">启用发送延迟探测（LoadBalance 优化）</td><td style="text-align:left">✅建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>startDetectorEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">启用启动探测功能</td><td style="text-align:left">可选，测试阶段使用</td></tr><tr><td style="text-align:left"><strong>可观测性</strong></td><td style="text-align:left"><code>traceOn</code></td><td style="text-align:left">false</td><td style="text-align:left">启用链路追踪</td><td style="text-align:left">✅建议开启</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enablePrintJstack</code></td><td style="text-align:left">true</td><td style="text-align:left">打印线程堆栈（用于诊断）</td><td style="text-align:left">✅可延长周期减少日志</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>综合优化建议</p></li></ul><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>性能调优</strong></td><td style="text-align:left">启用 <code>enableGrpcEpoll=true</code>；合理配置线程池（如减少队列长度）；设置合适的 <code>grpcThreadPoolNums</code>。</td></tr><tr><td style="text-align:left"><strong>可靠性</strong></td><td style="text-align:left">开启 <code>traceOn</code> 与 <code>sendLatencyEnable</code> 监控；使用 Prometheus 指标导出。</td></tr><tr><td style="text-align:left"><strong>安全性</strong></td><td style="text-align:left">禁用 <code>tlsTestModeEnable</code>，使用真实 TLS 证书。</td></tr><tr><td style="text-align:left"><strong>资源管理</strong></td><td style="text-align:left">限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。</td></tr><tr><td style="text-align:left"><strong>可维护性</strong></td><td style="text-align:left">使用独立的 <code>proxyClusterName</code>，并在配置文件 <code>rmq-proxy.json</code> 中明确各项端口和路径。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Proxy 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Controller 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/</id>
    <published>2025-10-28T13:32:05.000Z</published>
    <updated>2025-10-28T03:25:35.545Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Controller 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-Controller-配置项">查看 Controller 配置项</h2><ul class="lvl-0"><li class="lvl-2"><p>查看全部默认配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全部默认配置项</span></span><br><span class="line">sh bin/mqcontroller -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class="line">sh bin/mqcontroller -p -c conf/broker.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/controller</code> 的启动类 <code>org.apache.rocketmq.controller.ControllerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ControllerConfig</span> <span class="variable">controllerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControllerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">JraftConfig</span> <span class="variable">jraftConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JraftConfig</span>();</span><br><span class="line">controllerConfig.setJraftConfig(jraftConfig);</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">19876</span>);</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Controller 配置参数说明与优化建议</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础信息</strong></td><td style="text-align:left"><code>rocketmqHome</code></td><td style="text-align:left">/usr/local/soft/rocketmq/rocketmq5</td><td style="text-align:left">RocketMQ 根路径</td><td style="text-align:left">保持默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>configStorePath</code></td><td style="text-align:left">/root/controller/controller.properties</td><td style="text-align:left">Controller 配置文件路径</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/controller/controller.properties</code>，避免使用 <code>/root</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerType</code></td><td style="text-align:left">DLedger</td><td style="text-align:left">Controller 类型（DLedger / STANDALONE）</td><td style="text-align:left">✅ 建议使用 DLedger（高可用）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerStorePath</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Controller 元数据存储路径</td><td style="text-align:left">✅ 建议 <code>/data/rocketmq/controller/store</code></td></tr><tr><td style="text-align:left"><strong>DLedger 选举配置</strong></td><td style="text-align:left"><code>controllerDLegerGroup</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Controller 集群组名</td><td style="text-align:left">✅ 必填，例如：<code>controllerGroup01</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerDLegerPeers</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">集群节点列表，格式：<code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td><td style="text-align:left">✅ 必填（3 节点推荐）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerDLegerSelfId</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">当前节点 ID，如 <code>n0</code></td><td style="text-align:left">✅ 必填</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>mappedFileSize</code></td><td style="text-align:left">1073741824</td><td style="text-align:left">DLedger 存储文件大小 (1GB)</td><td style="text-align:left">可保持默认</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>electMasterMaxRetryCount</code></td><td style="text-align:left">3</td><td style="text-align:left">Master 选举最大重试次数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableElectUncleanMaster</code></td><td style="text-align:left">false</td><td style="text-align:left">是否允许选举非同步 Master</td><td style="text-align:left">✅ 建议保持 false（避免数据丢失）</td></tr><tr><td style="text-align:left"><strong>Broker 管理</strong></td><td style="text-align:left"><code>scanNotActiveBrokerInterval</code></td><td style="text-align:left">5000</td><td style="text-align:left">扫描不活跃 Broker 的间隔(ms)</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>scanInactiveMasterInterval</code></td><td style="text-align:left">5000</td><td style="text-align:left">检测失活 Master 间隔(ms)</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>notifyBrokerRoleChanged</code></td><td style="text-align:left">true</td><td style="text-align:left">是否通知 Broker 角色变更</td><td style="text-align:left">✅ 建议开启（保持同步）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>isProcessReadEvent</code></td><td style="text-align:left">false</td><td style="text-align:left">是否处理读事件</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>线程与性能</strong></td><td style="text-align:left"><code>controllerThreadPoolNums</code></td><td style="text-align:left">16</td><td style="text-align:left">控制线程池大小</td><td style="text-align:left">可调至 8–32 视规模而定</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>controllerRequestThreadPoolQueueCapacity</code></td><td style="text-align:left">50000</td><td style="text-align:left">控制线程池队列容量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>Metrics 监控</strong></td><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">DISABLE</td><td style="text-align:left">指标输出方式（DISABLE / PROM / GRPC / LOG）</td><td style="text-align:left">✅ 建议设为 <code>PROM</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">Prometheus 端口</td><td style="text-align:left">✅ 若启用监控，可用默认 5557</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsPromExporterHost</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Prometheus 绑定主机</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricLoggingExporterIntervalInMills</code></td><td style="text-align:left">10000</td><td style="text-align:left">日志输出指标间隔</td><td style="text-align:left">可调整</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsGrpcExporterTarget</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">gRPC 监控目标</td><td style="text-align:left">可忽略</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>metricsInDelta</code></td><td style="text-align:left">false</td><td style="text-align:left">是否以增量输出指标</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>JRaft 配置（底层一致性协议）</strong></td><td style="text-align:left"><code>jRaftGroupId</code></td><td style="text-align:left">jRaft-Controller</td><td style="text-align:left">Raft 组名</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftServerId</code></td><td style="text-align:left">localhost:9880</td><td style="text-align:left">当前节点 ID</td><td style="text-align:left">✅ 修改为实际 IP，例如 <code>10.0.0.1:9880</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftInitConf</code></td><td style="text-align:left">localhost:9880,localhost:9881,localhost:9882</td><td style="text-align:left">集群配置</td><td style="text-align:left">✅ 修改为实际节点 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftControllerRPCAddr</code></td><td style="text-align:left">localhost:9770,localhost:9771,localhost:9772</td><td style="text-align:left">Controller RPC 地址</td><td style="text-align:left">✅ 修改为实际节点 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftElectionTimeoutMs</code></td><td style="text-align:left">1000</td><td style="text-align:left">选举超时（ms）</td><td style="text-align:left">默认即可（过低可能频繁选举）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftScanWaitTimeoutMs</code></td><td style="text-align:left">1000</td><td style="text-align:left">扫描等待超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>jRaftSnapshotIntervalSecs</code></td><td style="text-align:left">3600</td><td style="text-align:left">快照间隔时间（秒）</td><td style="text-align:left">✅ 可设为 600（10分钟）加快日志压缩</td></tr><tr><td style="text-align:left"><strong>网络配置</strong></td><td style="text-align:left"><code>bindAddress</code></td><td style="text-align:left">0.0.0.0</td><td style="text-align:left">绑定监听地址</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>listenPort</code></td><td style="text-align:left">19876</td><td style="text-align:left">Controller 服务端口</td><td style="text-align:left">✅ 确保未冲突</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverWorkerThreads</code></td><td style="text-align:left">8</td><td style="text-align:left">Netty 工作线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverSelectorThreads</code></td><td style="text-align:left">3</td><td style="text-align:left">Selector 线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>serverSocketBacklog</code></td><td style="text-align:left">1024</td><td style="text-align:left">Socket backlog 队列</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">false</td><td style="text-align:left">是否使用 Epoll</td><td style="text-align:left">✅ Linux 环境建议 true</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">false</td><td style="text-align:left">优雅停机</td><td style="text-align:left">✅ 建议 true</td></tr><tr><td style="text-align:left"><strong>客户端通信</strong></td><td style="text-align:left"><code>clientWorkerThreads</code></td><td style="text-align:left">4</td><td style="text-align:left">客户端工作线程</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clientAsyncSemaphoreValue</code></td><td style="text-align:left">65535</td><td style="text-align:left">异步请求信号量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clientCloseSocketIfTimeout</code></td><td style="text-align:left">true</td><td style="text-align:left">连接超时关闭</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>connectTimeoutMillis</code></td><td style="text-align:left">3000</td><td style="text-align:left">连接超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>useTLS</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 TLS</td><td style="text-align:left">✅ 若生产环境有安全要求，建议启用</td></tr><tr><td style="text-align:left"><strong>其他</strong></td><td style="text-align:left"><code>configBlackList</code></td><td style="text-align:left">configBlackList;configStorePath</td><td style="text-align:left">配置黑名单项</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxReconnectIntervalTimeSeconds</code></td><td style="text-align:left">60</td><td style="text-align:left">最大重连间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableReconnectForGoAway</code></td><td style="text-align:left">true</td><td style="text-align:left">是否为 GOAWAY 连接启用重连</td><td style="text-align:left">默认即可</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">推荐值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>controllerType</code></td><td style="text-align:left">DLedger</td><td style="text-align:left">高可用模式</td></tr><tr><td style="text-align:left"><code>controllerDLegerGroup</code></td><td style="text-align:left">controllerGroup01</td><td style="text-align:left">集群分组名</td></tr><tr><td style="text-align:left"><code>controllerDLegerPeers</code></td><td style="text-align:left"><code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td><td style="text-align:left">三节点推荐</td></tr><tr><td style="text-align:left"><code>controllerDLegerSelfId</code></td><td style="text-align:left">n0 / n1 / n2</td><td style="text-align:left">对应节点 ID</td></tr><tr><td style="text-align:left"><code>enableElectUncleanMaster</code></td><td style="text-align:left">false</td><td style="text-align:left">防止脏主选举</td></tr><tr><td style="text-align:left"><code>notifyBrokerRoleChanged</code></td><td style="text-align:left">true</td><td style="text-align:left">保持集群一致性</td></tr><tr><td style="text-align:left"><code>metricsExporterType</code></td><td style="text-align:left">PROM</td><td style="text-align:left">便于 Prometheus 监控</td></tr><tr><td style="text-align:left"><code>metricsPromExporterPort</code></td><td style="text-align:left">5557</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">true</td><td style="text-align:left">Linux 性能优化</td></tr><tr><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">true</td><td style="text-align:left">优雅停机</td></tr><tr><td style="text-align:left"><code>controllerStorePath</code></td><td style="text-align:left">/data/rocketmq/controller/store</td><td style="text-align:left">避免使用 <code>/root</code></td></tr><tr><td style="text-align:left"><code>jRaftSnapshotIntervalSecs</code></td><td style="text-align:left">600</td><td style="text-align:left">提高快照频率</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Controller 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Broker 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/</id>
    <published>2025-10-28T13:31:05.000Z</published>
    <updated>2025-10-28T03:23:18.328Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ Broker 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-Broker-配置项">查看 Broker 配置项</h2><ul class="lvl-0"><li class="lvl-2"><p>查看全部默认配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全部默认配置项</span></span><br><span class="line">sh bin/mqbroker -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class="line">sh bin/mqbroker -p -c conf/broker.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看重要的配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看重要的默认配置项</span></span><br><span class="line">sh bin/mqbroker -m</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的重要配置项</span></span><br><span class="line">sh bin/mqbroker -m -c conf/broker.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/broker</code> 的启动类 <code>org.apache.rocketmq.broker.BrokerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">BrokerConfig</span> <span class="variable">brokerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">MessageStoreConfig</span> <span class="variable">messageStoreConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageStoreConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">AuthConfig</span> <span class="variable">authConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthConfig</span>();</span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">10911</span>);</span><br><span class="line">messageStoreConfig.setHaListenPort(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>Broker的全部配置项非常多，这里仅列出了重要的配置项。</p></li></ul><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">参数说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础配置</strong></td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">NameServer 地址列表（多个用 <code>;</code> 分隔）</td><td style="text-align:left">✅ <strong>必须设置</strong>，否则 broker 无法注册到 nameserver。例：<code>namesrvAddr=10.250.0.10:9876;10.250.0.11:9876</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>listenPort</code></td><td style="text-align:left">6888</td><td style="text-align:left">Broker 监听客户端连接的端口</td><td style="text-align:left">✅ 建议保持默认或显式设置为 10911（经典端口）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>brokerIP1</code></td><td style="text-align:left">10.250.0.188</td><td style="text-align:left">Broker 对外通信 IP</td><td style="text-align:left">✅ 在多网卡环境务必指定公网/内网 IP</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>recoverConcurrently</code></td><td style="text-align:left">false</td><td style="text-align:left">是否并发恢复 CommitLog</td><td style="text-align:left">默认即可（高安全性）</td></tr><tr><td style="text-align:left"><strong>Topic &amp; 订阅</strong></td><td style="text-align:left"><code>autoCreateTopicEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否允许自动创建 Topic</td><td style="text-align:left">✅ 生产建议设为 <strong>false</strong>，防止误创建</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>autoCreateSubscriptionGroup</code></td><td style="text-align:left">true</td><td style="text-align:left">是否自动创建订阅组</td><td style="text-align:left">✅ 同上，建议 <strong>false</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>msgTraceTopicName</code></td><td style="text-align:left">RMQ_SYS_TRACE_TOPIC</td><td style="text-align:left">消息轨迹主题名</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>traceTopicEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否开启消息轨迹功能</td><td style="text-align:left">✅ 建议设为 <strong>true</strong> 以便问题排查</td></tr><tr><td style="text-align:left"><strong>事务消息</strong></td><td style="text-align:left"><code>rejectTransactionMessage</code></td><td style="text-align:left">false</td><td style="text-align:left">是否拒绝事务消息</td><td style="text-align:left">若不使用事务可设为 true 减少负担</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionTimeOut</code></td><td style="text-align:left">6000</td><td style="text-align:left">事务超时时间（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionCheckMax</code></td><td style="text-align:left">15</td><td style="text-align:left">事务最大回查次数</td><td style="text-align:left">可调高（20）提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transactionCheckInterval</code></td><td style="text-align:left">30000</td><td style="text-align:left">事务回查间隔（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>访问控制</strong></td><td style="text-align:left"><code>aclEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 ACL 权限验证</td><td style="text-align:left">✅ 生产环境 <strong>必须 true</strong></td></tr><tr><td style="text-align:left"><strong>存储路径</strong></td><td style="text-align:left"><code>storePathRootDir</code></td><td style="text-align:left">/root/store</td><td style="text-align:left">消息存储根目录</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/store</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathCommitLog</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">CommitLog 存储路径</td><td style="text-align:left">若为空则使用上面的根目录</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathDLedgerCommitLog</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">DLedger 模式存储路径</td><td style="text-align:left">DLedger 模式才需要</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathEpochFile</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">epoch 文件路径</td><td style="text-align:left">Controller 模式使用</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storePathBrokerIdentity</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Broker 身份文件路径</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>disappearTimeAfterStart</code></td><td style="text-align:left">-1</td><td style="text-align:left">Broker 启动后失效等待时间</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>storeType</code></td><td style="text-align:left">default</td><td style="text-align:left">存储类型（default / dledger）</td><td style="text-align:left">✅ 多副本部署建议 dledger</td></tr><tr><td style="text-align:left"><strong>刷盘与写入</strong></td><td style="text-align:left"><code>flushIntervalCommitLog</code></td><td style="text-align:left">500</td><td style="text-align:left">异步 flush 周期（ms）</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commitIntervalCommitLog</code></td><td style="text-align:left">200</td><td style="text-align:left">commit 间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>flushCommitLogTimed</code></td><td style="text-align:left">true</td><td style="text-align:left">是否定时 flush</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>文件清理</strong></td><td style="text-align:left"><code>deleteWhen</code></td><td style="text-align:left">04</td><td style="text-align:left">删除过期文件时间点</td><td style="text-align:left">每天凌晨 4 点</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>fileReservedTime</code></td><td style="text-align:left">72</td><td style="text-align:left">文件保留时间（小时）</td><td style="text-align:left">✅ 可改为 48 减少磁盘压力</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>deleteFileBatchMax</code></td><td style="text-align:left">10</td><td style="text-align:left">删除文件批量数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>消息访问性能</strong></td><td style="text-align:left"><code>maxTransferBytesOnMessageInMemory</code></td><td style="text-align:left">262144</td><td style="text-align:left">内存消息读取最大字节</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferCountOnMessageInMemory</code></td><td style="text-align:left">32</td><td style="text-align:left">内存消息读取最大条数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferBytesOnMessageInDisk</code></td><td style="text-align:left">65536</td><td style="text-align:left">磁盘消息读取最大字节</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>maxTransferCountOnMessageInDisk</code></td><td style="text-align:left">8</td><td style="text-align:left">磁盘消息读取最大条数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>accessMessageInMemoryMaxRatio</code></td><td style="text-align:left">40</td><td style="text-align:left">内存访问比例阈值</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>索引管理</strong></td><td style="text-align:left"><code>messageIndexEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否启用消息索引</td><td style="text-align:left">✅ 建议开启（提高按 key 查询性能）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>messageIndexSafe</code></td><td style="text-align:left">false</td><td style="text-align:left">是否安全模式索引</td><td style="text-align:left">若磁盘可靠性差可设为 true</td></tr><tr><td style="text-align:left"><strong>主从复制</strong></td><td style="text-align:left"><code>haMasterAddress</code></td><td style="text-align:left"><em>(空)</em></td><td style="text-align:left">Master 地址（Slave 模式使用）</td><td style="text-align:left">仅从节点配置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>brokerRole</code></td><td style="text-align:left">ASYNC_MASTER</td><td style="text-align:left">Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE）</td><td style="text-align:left">✅ 主节点建议 SYNC_MASTER 提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>flushDiskType</code></td><td style="text-align:left">ASYNC_FLUSH</td><td style="text-align:left">刷盘策略（SYNC_FLUSH / ASYNC_FLUSH）</td><td style="text-align:left">✅ 高可靠建议 SYNC_FLUSH</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>cleanFileForciblyEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">是否强制清理文件</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>transientStorePoolEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 transient pool（堆外内存）</td><td style="text-align:left">✅ 可设为 true 提升性能（需足够内存）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>dispatchFromSenderThread</code></td><td style="text-align:left">false</td><td style="text-align:left">是否由发送线程分发</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>wakeCommitWhenPutMessage</code></td><td style="text-align:left">true</td><td style="text-align:left">是否在消息写入时唤醒 commit</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>wakeFlushWhenPutMessage</code></td><td style="text-align:left">false</td><td style="text-align:left">是否写入后立即 flush</td><td style="text-align:left">✅ 对延迟敏感业务可设为 true</td></tr><tr><td style="text-align:left"><strong>消费进度清理</strong></td><td style="text-align:left"><code>enableCleanExpiredOffset</code></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 offset 清理</td><td style="text-align:left">默认 false</td></tr><tr><td style="text-align:left"><strong>副本参数</strong></td><td style="text-align:left"><code>totalReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">副本总数</td><td style="text-align:left">✅ 多节点建议设为 3</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>inSyncReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">同步副本数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>minInSyncReplicas</code></td><td style="text-align:left">1</td><td style="text-align:left">最小同步副本</td><td style="text-align:left">✅ 建议设为 2 提高可靠性</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>allAckInSyncStateSet</code></td><td style="text-align:left">false</td><td style="text-align:left">是否要求所有 ISR 确认</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>enableAutoInSyncReplicas</code></td><td style="text-align:left">false</td><td style="text-align:left">是否自动管理 ISR</td><td style="text-align:left">可保持默认</td></tr><tr><td style="text-align:left"><strong>HA 与流控</strong></td><td style="text-align:left"><code>haFlowControlEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">是否开启主从流控</td><td style="text-align:left">✅ 多副本建议 true</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">参数</th><th style="text-align:left">推荐值</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left">注册</td><td style="text-align:left"><code>namesrvAddr</code></td><td style="text-align:left">必填</td><td style="text-align:left">Broker 必须向 NameServer 注册</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>aclEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">启用访问控制</td></tr><tr><td style="text-align:left">自动创建</td><td style="text-align:left"><code>autoCreateTopicEnable</code></td><td style="text-align:left">false</td><td style="text-align:left">防止误创建 topic</td></tr><tr><td style="text-align:left">自动订阅</td><td style="text-align:left"><code>autoCreateSubscriptionGroup</code></td><td style="text-align:left">false</td><td style="text-align:left">防止误消费</td></tr><tr><td style="text-align:left">刷盘策略</td><td style="text-align:left"><code>flushDiskType</code></td><td style="text-align:left">SYNC_FLUSH</td><td style="text-align:left">保证可靠性</td></tr><tr><td style="text-align:left">主从</td><td style="text-align:left"><code>brokerRole</code></td><td style="text-align:left">SYNC_MASTER（主） / SLAVE（从）</td><td style="text-align:left">提升可用性</td></tr><tr><td style="text-align:left">存储路径</td><td style="text-align:left"><code>storePathRootDir</code></td><td style="text-align:left"><code>/data/rocketmq/store</code></td><td style="text-align:left">避免 <code>/root</code> 权限问题</td></tr><tr><td style="text-align:left">延迟优化</td><td style="text-align:left"><code>transientStorePoolEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">堆外内存加速写入</td></tr><tr><td style="text-align:left">清理</td><td style="text-align:left"><code>fileReservedTime</code></td><td style="text-align:left">48</td><td style="text-align:left">减少磁盘占用</td></tr><tr><td style="text-align:left">消息轨迹</td><td style="text-align:left"><code>traceTopicEnable</code></td><td style="text-align:left">true</td><td style="text-align:left">便于追踪消息链路</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ Broker 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ NameServer 的配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/</id>
    <published>2025-10-28T13:30:05.000Z</published>
    <updated>2025-10-28T03:19:35.144Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RocketMQ NameServer 的配置项。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="查看-NameServer-配置项">查看 NameServer 配置项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认配置项</span></span><br><span class="line">sh bin/mqnamesrv -p</span><br><span class="line"><span class="comment"># 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项</span></span><br><span class="line">sh bin/mqnamesrv -p -c conf/namesvr.conf</span><br></pre></td></tr></table></figure><h2 id="配置项项目源码简介">配置项项目源码简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在源码 <code>rocketmq-all-5.3.2-source-release/namesrv</code> 的启动类 <code>org.apache.rocketmq.namesrv.NamesrvStartup</code>中 可以看到其启动时会初始化如下配置项的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ControllerConfig</span> <span class="variable">controllerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="配置项说明">配置项说明</h2><ul class="lvl-0"><li class="lvl-2"><p>NameServer 配置项说明与建议</p></li></ul><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">参数说明</th><th style="text-align:left">优化 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>rocketmqHome</strong></td><td style="text-align:left">/usr/local/soft/rocketmq/rocketmq5</td><td style="text-align:left">RocketMQ 安装目录</td><td style="text-align:left">不建议修改</td></tr><tr><td style="text-align:left"><strong>kvConfigPath</strong></td><td style="text-align:left">/root/namesrv/kvConfig.json</td><td style="text-align:left">KV 配置存储路径</td><td style="text-align:left">✅ 改为 <code>/data/rocketmq/namesrv/kvConfig.json</code> 更规范</td></tr><tr><td style="text-align:left"><strong>configStorePath</strong></td><td style="text-align:left">/root/namesrv/namesrv.properties</td><td style="text-align:left">NameServer 启动配置文件路径</td><td style="text-align:left">✅ 放在非 root 路径下 <code>/etc/rocketmq/namesrv.properties</code></td></tr><tr><td style="text-align:left"><strong>productEnvName</strong></td><td style="text-align:left">center</td><td style="text-align:left">产品环境名称标识</td><td style="text-align:left">可用于区分环境（dev/test/prod）</td></tr><tr><td style="text-align:left"><strong>clusterTest</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用集群测试模式</td><td style="text-align:left">默认 false，生产勿启用</td></tr><tr><td style="text-align:left"><strong>orderMessageEnable</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否开启顺序消息功能</td><td style="text-align:left">NameServer 一般无需开启</td></tr><tr><td style="text-align:left"><strong>returnOrderTopicConfigToBroker</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否返回顺序消息主题配置给 broker</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>clientRequestThreadPoolNums</strong></td><td style="text-align:left">8</td><td style="text-align:left">客户端请求线程数</td><td style="text-align:left">✅ 若 NameServer 负载高可增至 16~32</td></tr><tr><td style="text-align:left"><strong>defaultThreadPoolNums</strong></td><td style="text-align:left">16</td><td style="text-align:left">默认线程池线程数</td><td style="text-align:left">视 CPU 核心数调整</td></tr><tr><td style="text-align:left"><strong>clientRequestThreadPoolQueueCapacity</strong></td><td style="text-align:left">50000</td><td style="text-align:left">客户端请求队列长度</td><td style="text-align:left">✅ 高并发环境可调高至 100000</td></tr><tr><td style="text-align:left"><strong>defaultThreadPoolQueueCapacity</strong></td><td style="text-align:left">10000</td><td style="text-align:left">默认任务队列长度</td><td style="text-align:left">适度提高防止拒绝任务</td></tr><tr><td style="text-align:left"><strong>scanNotActiveBrokerInterval</strong></td><td style="text-align:left">5000</td><td style="text-align:left">扫描失效 Broker 的间隔（ms）</td><td style="text-align:left">默认 5s，可保持</td></tr><tr><td style="text-align:left"><strong>unRegisterBrokerQueueCapacity</strong></td><td style="text-align:left">3000</td><td style="text-align:left">Broker 注销队列容量</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>supportActingMaster</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否支持 ActingMaster 功能</td><td style="text-align:left">✅ 若启用 controller 建议设为 true</td></tr><tr><td style="text-align:left"><strong>enableAllTopicList</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用所有主题列表接口</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>enableTopicList</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否允许主题列表查询</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>notifyMinBrokerIdChanged</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否通知最小 brokerId 变化</td><td style="text-align:left">一般无需开启</td></tr><tr><td style="text-align:left"><strong>enableControllerInNamesrv</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否在 NameServer 中启用 Controller 模块</td><td style="text-align:left">✅ 若部署简化集群可考虑 true（测试环境）</td></tr><tr><td style="text-align:left"><strong>needWaitForService</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否等待服务就绪再启动</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>waitSecondsForService</strong></td><td style="text-align:left">45</td><td style="text-align:left">启动等待时间</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>deleteTopicWithBrokerRegistration</strong></td><td style="text-align:left">false</td><td style="text-align:left">注册时是否删除 topic</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>configBlackList</strong></td><td style="text-align:left">configBlackList;configStorePath;kvConfigPath</td><td style="text-align:left">黑名单配置项</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>bindAddress</strong></td><td style="text-align:left">0.0.0.0</td><td style="text-align:left">绑定的监听地址</td><td style="text-align:left">✅ 生产环境建议绑定内网 IP</td></tr><tr><td style="text-align:left"><strong>listenPort</strong></td><td style="text-align:left">9876</td><td style="text-align:left">NameServer 监听端口</td><td style="text-align:left">✅ 可通过防火墙限制外部访问</td></tr><tr><td style="text-align:left"><strong>serverWorkerThreads</strong></td><td style="text-align:left">8</td><td style="text-align:left">服务端业务处理线程数</td><td style="text-align:left">可根据负载调整</td></tr><tr><td style="text-align:left"><strong>serverCallbackExecutorThreads</strong></td><td style="text-align:left">0</td><td style="text-align:left">回调执行线程数</td><td style="text-align:left">0 表示自动设置</td></tr><tr><td style="text-align:left"><strong>serverSelectorThreads</strong></td><td style="text-align:left">3</td><td style="text-align:left">Selector 线程数</td><td style="text-align:left">一般 2~4 即可</td></tr><tr><td style="text-align:left"><strong>serverOnewaySemaphoreValue</strong></td><td style="text-align:left">256</td><td style="text-align:left">单向请求并发限制</td><td style="text-align:left">可保持</td></tr><tr><td style="text-align:left"><strong>serverAsyncSemaphoreValue</strong></td><td style="text-align:left">64</td><td style="text-align:left">异步请求并发限制</td><td style="text-align:left">可保持或略增</td></tr><tr><td style="text-align:left"><strong>serverChannelMaxIdleTimeSeconds</strong></td><td style="text-align:left">120</td><td style="text-align:left">连接空闲关闭时间</td><td style="text-align:left">可调大到 300 提高容错</td></tr><tr><td style="text-align:left"><strong>serverSocketSndBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">TCP 发送缓冲区大小</td><td style="text-align:left">0 表示使用系统默认</td></tr><tr><td style="text-align:left"><strong>serverSocketRcvBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">TCP 接收缓冲区大小</td><td style="text-align:left">建议 131072（128KB）以上</td></tr><tr><td style="text-align:left"><strong>writeBufferHighWaterMark</strong></td><td style="text-align:left">0</td><td style="text-align:left">写缓冲高水位标记</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>writeBufferLowWaterMark</strong></td><td style="text-align:left">0</td><td style="text-align:left">写缓冲低水位标记</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>serverSocketBacklog</strong></td><td style="text-align:left">1024</td><td style="text-align:left">TCP 连接等待队列</td><td style="text-align:left">✅ 高并发场景可调大至 2048</td></tr><tr><td style="text-align:left"><strong>serverNettyWorkerGroupEnable</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 Netty worker 线程组</td><td style="text-align:left">默认 true</td></tr><tr><td style="text-align:left"><strong>serverPooledByteBufAllocatorEnable</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 Netty 池化内存</td><td style="text-align:left">建议保持</td></tr><tr><td style="text-align:left"><strong>enableShutdownGracefully</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否优雅关闭</td><td style="text-align:left">✅ 建议设为 true</td></tr><tr><td style="text-align:left"><strong>shutdownWaitTimeSeconds</strong></td><td style="text-align:left">30</td><td style="text-align:left">优雅关闭等待时间</td><td style="text-align:left">建议 30~60</td></tr><tr><td style="text-align:left"><strong>useEpollNativeSelector</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 Linux Epoll</td><td style="text-align:left">✅ Linux 环境建议设为 true 提高性能</td></tr><tr><td style="text-align:left"><strong>clientWorkerThreads</strong></td><td style="text-align:left">4</td><td style="text-align:left">客户端 worker 线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientCallbackExecutorThreads</strong></td><td style="text-align:left">2</td><td style="text-align:left">客户端回调线程数</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientOnewaySemaphoreValue</strong></td><td style="text-align:left">65535</td><td style="text-align:left">客户端单向请求并发限制</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientAsyncSemaphoreValue</strong></td><td style="text-align:left">65535</td><td style="text-align:left">客户端异步请求并发限制</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>connectTimeoutMillis</strong></td><td style="text-align:left">3000</td><td style="text-align:left">连接超时（ms）</td><td style="text-align:left">✅ 可提高至 5000 增加容错</td></tr><tr><td style="text-align:left"><strong>channelNotActiveInterval</strong></td><td style="text-align:left">60000</td><td style="text-align:left">检查通道非活动间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>isScanAvailableNameSrv</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否扫描可用 NameServer</td><td style="text-align:left">保持</td></tr><tr><td style="text-align:left"><strong>clientChannelMaxIdleTimeSeconds</strong></td><td style="text-align:left">120</td><td style="text-align:left">客户端空闲连接超时</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>clientSocketSndBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">客户端 TCP 发送缓冲区</td><td style="text-align:left">建议 131072</td></tr><tr><td style="text-align:left"><strong>clientSocketRcvBufSize</strong></td><td style="text-align:left">0</td><td style="text-align:left">客户端 TCP 接收缓冲区</td><td style="text-align:left">建议 131072</td></tr><tr><td style="text-align:left"><strong>clientPooledByteBufAllocatorEnable</strong></td><td style="text-align:left">false</td><td style="text-align:left">客户端是否启用池化</td><td style="text-align:left">✅ 建议设为 true 提高性能</td></tr><tr><td style="text-align:left"><strong>clientCloseSocketIfTimeout</strong></td><td style="text-align:left">true</td><td style="text-align:left">超时是否关闭 socket</td><td style="text-align:left">保持默认</td></tr><tr><td style="text-align:left"><strong>useTLS</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否启用 TLS 通信</td><td style="text-align:left">✅ 若公网部署强烈建议开启</td></tr><tr><td style="text-align:left"><strong>socksProxyConfig</strong></td><td style="text-align:left">{}</td><td style="text-align:left">SOCKS 代理配置</td><td style="text-align:left">内网部署无需设置</td></tr><tr><td style="text-align:left"><strong>disableCallbackExecutor</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否禁用回调执行器</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>disableNettyWorkerGroup</strong></td><td style="text-align:left">false</td><td style="text-align:left">是否禁用 Netty worker group</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>maxReconnectIntervalTimeSeconds</strong></td><td style="text-align:left">60</td><td style="text-align:left">最大重连间隔</td><td style="text-align:left">默认即可</td></tr><tr><td style="text-align:left"><strong>enableReconnectForGoAway</strong></td><td style="text-align:left">true</td><td style="text-align:left">是否启用 goaway 自动重连</td><td style="text-align:left">保持 true 增强健壮性</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>推荐重点优化的关键项</p></li></ul><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">参数</th><th style="text-align:left">推荐值</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left">性能</td><td style="text-align:left"><code>useEpollNativeSelector</code></td><td style="text-align:left">true</td><td style="text-align:left">Linux 性能显著提升</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>bindAddress</code></td><td style="text-align:left">内网 IP</td><td style="text-align:left">防止暴露公网</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left"><code>useTLS</code></td><td style="text-align:left">true（公网）</td><td style="text-align:left">启用加密传输</td></tr><tr><td style="text-align:left">健壮性</td><td style="text-align:left"><code>enableShutdownGracefully</code></td><td style="text-align:left">true</td><td style="text-align:left">防止强制关闭导致状态不一致</td></tr><tr><td style="text-align:left">负载</td><td style="text-align:left"><code>clientRequestThreadPoolNums</code></td><td style="text-align:left">16~32</td><td style="text-align:left">提高并发能力</td></tr><tr><td style="text-align:left">网络</td><td style="text-align:left"><code>serverSocketBacklog</code></td><td style="text-align:left">2048</td><td style="text-align:left">减少连接拒绝</td></tr><tr><td style="text-align:left">缓冲</td><td style="text-align:left"><code>serverSocketSndBufSize</code> / <code>RcvBufSize</code></td><td style="text-align:left">131072</td><td style="text-align:left">提高网络吞吐</td></tr><tr><td style="text-align:left">文件路径</td><td style="text-align:left"><code>kvConfigPath</code> / <code>configStorePath</code></td><td style="text-align:left">非 root 路径</td><td style="text-align:left">避免权限问题</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RocketMQ NameServer 的配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ Dashboard 的安装及使用</title>
    <link href="https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/"/>
    <id>https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/</id>
    <published>2025-10-24T13:30:05.000Z</published>
    <updated>2025-10-30T02:25:28.429Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="RocketMQ-Dashboard-简介">RocketMQ Dashboard 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard">官方文档</a></p></li><li class="lvl-2"><p>RocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。</p></li><li class="lvl-2"><p>功能概览</p></li></ul><table><thead><tr><th>面板</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>运维</strong></td><td>修改 <strong>NameServer 地址</strong>；选择 <strong>VIPChannel</strong> 等运维配置。</td></tr><tr><td><strong>驾驶舱</strong></td><td>查看 <strong>Broker、Topic 消息量</strong> 等运行总览信息。</td></tr><tr><td><strong>集群</strong></td><td>查看 <strong>集群分布</strong>、Broker 配置、运行状态及详细信息。</td></tr><tr><td><strong>主题（Topic）</strong></td><td>搜索、筛选、删除、更新/新增主题；查看 <strong>消息路由</strong>；执行 <strong>发送消息</strong>、<strong>重置消费位点</strong> 等操作。</td></tr><tr><td><strong>消费者（Consumer）</strong></td><td>搜索、删除、新增/更新消费者组；查看 <strong>终端信息、消费详情、配置项</strong>。</td></tr><tr><td><strong>消息（Message）</strong></td><td>查看 <strong>消息记录、死信消息、消息轨迹</strong> 等消息级详情。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>系统要求 与 网络配置</p></li></ul><table><thead><tr><th>类别</th><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>系统要求</strong></td><td>操作系统</td><td>Linux / Unix / macOS</td></tr><tr><td></td><td>JDK</td><td>64 位 JDK, 1.x 版本需要<strong>1.8+</strong>，2.x版本需要 <strong>17+</strong></td></tr><tr><td></td><td>构建工具</td><td><strong>Maven 3.2.x</strong> 或更高版本</td></tr><tr><td></td><td>启动项</td><td>启动 <strong>RocketMQ</strong>（包括 NameServer 与 Broker）</td></tr><tr><td><strong>网络配置</strong></td><td>网络访问</td><td>云服务器需可远程访问，或本地虚拟机需可 <strong>PING 通外网</strong></td></tr></tbody></table><h2 id="RocketMQ-Dashboard-的安装">RocketMQ Dashboard 的安装</h2><ul class="lvl-0"><li class="lvl-2"><p>部署 RocketMQ Dashboard 2.x，需要安装 JDK17</p></li><li class="lvl-2"><p>源码安装，<a href="https://github.com/apache/rocketmq-dashboard">源码下载</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft/rocketmq</span><br><span class="line">wget https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-2.1.0.tar.gz</span><br><span class="line">tar -zxvf rocketmq-dashboard-2.1.0.tar.gz</span><br><span class="line"><span class="built_in">ln</span> -s rocketmq-dashboard-rocketmq-dashboard-2.1.0 rocketmq-dashboard</span><br><span class="line"><span class="built_in">cd</span> rocketmq-dashboard</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>bug 修复，当前<code>2.1.0</code>版本存在bug，只能通过<code>http://localhost:8082</code>访问，如果需要ip或域名访问，则需要修改源码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> frontend-new/src/api/remoteApi</span><br><span class="line">sed -i <span class="string">&#x27;s|apiBaseUrl: &#x27;</span>\&#x27;<span class="string">&#x27;http://localhost:8082&#x27;</span>\&#x27;<span class="string">&#x27;|apiBaseUrl: process.env.REACT_APP_API_BASE_URL \|\| window.location.origin|&#x27;</span> remoteApi.js.bck</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换前：</span></span><br><span class="line">const appConfig = &#123;</span><br><span class="line">    apiBaseUrl: <span class="string">&#x27;http://localhost:8082&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment"># 替换后：</span></span><br><span class="line">const appConfig = &#123;</span><br><span class="line">    apiBaseUrl: process.env.REACT_APP_API_BASE_URL || window.location.origin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>环境</th><th>环境变量值</th><th>结果 (<code>appConfig.apiBaseUrl</code>)</th></tr></thead><tbody><tr><td>开发环境</td><td><code>REACT_APP_API_BASE_URL=http://localhost:8080</code></td><td><code>http://localhost:8080</code></td></tr><tr><td>测试环境</td><td><code>REACT_APP_API_BASE_URL=https://api.test.example.com</code></td><td><code>https://api.test.example.com</code></td></tr><tr><td>未设置变量</td><td><em>(无该环境变量)</em> 则使用默认的 <code>window.location.origin</code>，其表示 当前网页的 协议 + 域名 + 端口号</td><td>自动使用当前网站地址，如 <code>https://myapp.example.com</code></td></tr></tbody></table><blockquote><p>目前<code>2.1.0</code>版本的bug还比较多，GitHub仓库中的代码已经修复了包括该bug在内的部分bug，不过还没有发布到 release。<br>着急的小伙伴可以通过 <code>git clone</code> 项目，编译并运行，或者等待作者发布新版本。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>编译</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/soft/rocketmq/rocketmq-dashboard</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">JAVA_HOME=/usr/local/jdk/jdk17 mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 将jar包复制到run目录下，以避免重新编译时被覆盖</span></span><br><span class="line"><span class="built_in">mkdir</span> run</span><br><span class="line"><span class="built_in">cp</span> target/rocketmq-dashboard-2.1.0.jar run/</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>按需替换配置，</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run/application.yaml # 按需替换配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">namesrvAddrs:</span>                <span class="comment"># 填写NameServer地址列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.175</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.188</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.250</span><span class="number">.0</span><span class="number">.131</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/usr/local/soft/rocketmq/data/dashboard</span> <span class="comment"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class="line">    <span class="attr">loginRequired:</span> <span class="literal">true</span>  <span class="comment"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class="line">    <span class="comment"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class="line"><span class="comment">#    accessKey: mqadmin</span></span><br><span class="line"><span class="comment">#    secretKey: 1234567</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>users.properties</code> 文件格式如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class="line"><span class="comment"># 格式， 每行定义一个用户， username=password[,N]  #N是可选项，可以为0 (普通用户)； 1 （管理员）</span></span><br><span class="line"><span class="comment"># 定义管理员，管理员拥有全部权限</span></span><br><span class="line">super=passwd,1</span><br><span class="line"><span class="comment"># 定义普通用户，普通用户的权限需要在 dataPath 下的 role-permission.yml 文件中定义，如果该目录下不存在此文件，则默认使用resources/role-permission.yml文件</span></span><br><span class="line">user1=passwd</span><br><span class="line">user2=passwd</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>role-permission.yml</code> 文件格式如下：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class="line"><span class="comment"># 格式，如果增加和删除接口权限，直接在列表中增加和删除接口地址即可。</span></span><br><span class="line"><span class="comment"># 接口路径配置支持通配符</span></span><br><span class="line"><span class="comment"># * 表示匹配0或多个不是/的字符</span></span><br><span class="line"><span class="comment"># ** 表示匹配0或多个任意字符</span></span><br><span class="line"><span class="comment"># ? 表示匹配1个任意字符</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rolePerms:</span></span><br><span class="line">  <span class="comment"># 普通用户，以下权限为默认权限，基本上就只是查询的权限</span></span><br><span class="line">  <span class="attr">Normal:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/rocketmq/nsaddr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/ops/*</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/dashboard/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/topic/*.query</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/topic/sendTopicMessage.do</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/producer/*.query</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/message/*</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/messageTrace/*</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/monitor/*</span></span><br><span class="line">    <span class="string">....</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> run</span><br><span class="line"><span class="comment"># 启动，默认会加载与jar包同级目录下的application.yaml文件</span></span><br><span class="line"><span class="built_in">nohup</span> /usr/local/jdk/jdk17/bin/java -jar rocketmq-dashboard-2.1.0.jar 1&gt;dashboard.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line"><span class="built_in">tail</span> -f dashboard.log</span><br></pre></td></tr></table></figure><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/9F26eh.png" alt="" width="1400" height="800"></p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/apache/rocketmq-dashboard/blob/master/docs/1_0_0/UserGuide_CN.md">Dashboard 使用手册</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 的安装及使用</title>
    <link href="https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/"/>
    <id>https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/</id>
    <published>2025-10-23T13:30:05.000Z</published>
    <updated>2025-10-31T08:42:20.778Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 CentOS9 中 RocketMQ 的安装与使用。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/">RocketMQ官网</a></p></li><li class="lvl-2"><p>本文使用的 RocketMQ 版本为 5.3.2。</p></li></ul><span id="more"></span><h2 id="Apache-RocketMQ-简介">Apache RocketMQ 简介</h2><h3 id="一、RocketMQ-是什么？">一、RocketMQ 是什么？</h3><p>RocketMQ 是一个<strong>分布式、队列模型的消息中间件</strong>。它由阿里巴巴在2012年开源，并于2017年正式成为 Apache 基金会的顶级项目。</p><p>你可以把它想象成一个在分布式系统中负责可靠传递消息的“邮局”或“快递系统”。当系统A需要发送数据给系统B，但它们之间不直接通信时，就可以通过 RocketMQ 来中转，确保消息不丢失、不重复，并且能按顺序送达。</p><p><strong>RocketMQ 是一个高性能、高可靠、高实时的分布式消息中间件</strong>。它就像分布式系统的“中枢神经系统”，负责在各个服务之间可靠、高效地传递数据，是现代互联网架构中不可或缺的基础组件之一。</p><p><strong>RocketMQ 5.x 通过引入 Proxy 模式，极大地提升了架构的灵活性、多语言支持能力和云原生亲和力</strong>，是其在消息中间件领域持续演进的重要里程碑。</p><p>它与 Kafka、RabbitMQ 等都是业界顶级的消息队列，但各有侧重。RocketMQ 在事务消息、顺序消息和对在线业务的稳定性支持方面表现尤为出色。</p><hr><h3 id="二、核心特点与优势">二、核心特点与优势</h3><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">特性</th><th style="text-align:left">典型场景</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left"><strong>削峰填谷</strong></td><td style="text-align:left">电商秒杀、大促活动时大量下单请求瞬间涌入</td><td style="text-align:left">将突发请求先缓存为消息，后端系统按自身能力平稳消费，避免系统过载崩溃</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:left"><strong>异步解耦</strong></td><td style="text-align:left">用户注册后触发多系统任务（邮件、优惠券、积分）</td><td style="text-align:left">主流程只负责发送消息，其他系统独立异步处理，降低系统间耦合、提高扩展性</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left"><strong>顺序消息</strong></td><td style="text-align:left">订单状态变更（创建 → 付款 → 发货 → 收货）</td><td style="text-align:left">同一业务键（如订单ID）的消息按顺序发送和消费，保证业务逻辑正确性</td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:left"><strong>持久化与高可靠性</strong></td><td style="text-align:left">关键业务消息必须不丢失（交易、支付、日志）</td><td style="text-align:left">所有消息写入磁盘并支持主从复制，即使服务器重启也能恢复，保证高可用</td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:left"><strong>消息回溯</strong></td><td style="text-align:left">消费逻辑出错、数据重算、补偿任务</td><td style="text-align:left">支持重置消费位点，重新消费历史消息，实现业务补偿与追溯</td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:left"><strong>海量消息堆积能力</strong></td><td style="text-align:left">大规模异步日志收集、IoT 数据汇聚、埋点分析</td><td style="text-align:left">支持万亿级消息堆积，性能稳定不衰减，适用于大规模数据场景</td></tr></tbody></table><hr><h3 id="三、核心架构与概念">三、核心架构与概念</h3><p>要理解 RocketMQ，需要知道几个关键角色：<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/frTwo1.png" alt=""></p><h4 id="经典核心组件">经典核心组件</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">组件名称</th><th style="text-align:left">主要作用</th><th style="text-align:left">说明 / 特点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left"><strong>Producer（生产者）</strong></td><td style="text-align:left">发送消息的客户端</td><td style="text-align:left">负责将业务系统的消息发送到指定的 <strong>Topic</strong>，支持同步、异步、单向三种发送方式</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:left"><strong>Consumer（消费者）</strong></td><td style="text-align:left">接收并消费消息的客户端</td><td style="text-align:left">从 Broker 拉取消息并进行业务处理，可分为 <strong>Push</strong> 和 <strong>Pull</strong> 两种消费模式</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left"><strong>Consumer Group（消费者组）</strong></td><td style="text-align:left">实现负载均衡与高可用消费</td><td style="text-align:left">多个消费者订阅同一 Topic 时组成消费者组，一个分区只会被组内一个消费者消费</td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:left"><strong>Broker（消息服务器）</strong></td><td style="text-align:left">存储和转发消息</td><td style="text-align:left">RocketMQ 的核心组件，负责消息的持久化、转发、主从复制和高可用</td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:left"><strong>Topic（主题）</strong></td><td style="text-align:left">消息的分类与路由单元</td><td style="text-align:left">Producer 发送消息到指定 Topic，Consumer 订阅 Topic 消费消息；一个 Topic 可包含多个消息队列（分区）</td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:left"><strong>Name Server（名字服务）</strong></td><td style="text-align:left">管理 Broker 地址信息</td><td style="text-align:left">类似轻量级注册中心，维护 Broker 元数据，帮助 Producer 和 Consumer 定位消息存储位置</td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:left"><strong>Controller（控制器）</strong></td><td style="text-align:left">主从自动切换与高可用控制</td><td style="text-align:left">RocketMQ 5.x 引入，基于 Raft（DLedger）协议实现 Broker 自动选主和元数据管理</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:left"><strong>Proxy（代理层）</strong></td><td style="text-align:left">客户端访问入口与协议转换</td><td style="text-align:left">RocketMQ 5.x 新组件，无状态，可横向扩展；统一接入层，支持多协议（如 HTTP、gRPC），隔离客户端与 Broker</td></tr></tbody></table><blockquote><p><strong>引入 Proxy 模式的优势：</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**架构解耦与语言无关**：Proxy 作为通用代理，将复杂的 Broker 协议封装成更简单的接口（如 gRPC），使得用不同编程语言（如 Go, Python, C++ 等）开发的客户端更容易接入，而无需实现复杂的原生协议。</span><br><span class="line">**简化客户端**：客户端不再需要感知 Name Server 和 Broker 的地址变化，只需连接固定的 Proxy 地址即可，大大降低了客户端的复杂度。</span><br><span class="line">**增强安全性**：可以在 Proxy 层统一实现安全认证、限流、审计等策略，作为Broker集群的安全屏障。</span><br><span class="line">**云原生友好**：无状态的 Proxy 非常适合在 Kubernetes 等容器化环境中进行部署和弹性伸缩。</span><br></pre></td></tr></table></figure><hr><h2 id="消息中间件功能对比表（ActiveMQ-vs-Kafka-vs-RabbitMQ-vs-RocketMQ）">消息中间件功能对比表（ActiveMQ vs Kafka vs RabbitMQ vs RocketMQ）</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://support.huaweicloud.com/intl/zh-cn/productdesc-hrm/hrm_pd_012.html">参考资料</a></p></li></ul><table><thead><tr><th style="text-align:left">功能项</th><th style="text-align:left">ActiveMQ</th><th style="text-align:left">Kafka</th><th style="text-align:left">RabbitMQ</th><th style="text-align:left">RocketMQ</th></tr></thead><tbody><tr><td style="text-align:left">客户端 SDK</td><td style="text-align:left">Java、.NET、C++ 等</td><td style="text-align:left">Java、Scala 等</td><td style="text-align:left">Java、.NET、Go、Python、C 等</td><td style="text-align:left">Java、C++、Go</td></tr><tr><td style="text-align:left">通信协议与规范</td><td style="text-align:left">推送模型（Push），支持 OpenWire、STOMP、AMQP、MQTT、JMS</td><td style="text-align:left">拉取模型（Pull），支持 TCP</td><td style="text-align:left">推送模型（Push），支持 AMQP、MQTT、STOMP、HTTP、WebSocket</td><td style="text-align:left">拉取模型（Pull），支持 TCP、JMS、OpenMessaging</td></tr><tr><td style="text-align:left">消息有序性</td><td style="text-align:left">通过独占消费者（Exclusive Consumer）或独占队列（Exclusive Queues）保证顺序</td><td style="text-align:left">保证分区内消息顺序</td><td style="text-align:left">单队列内消息天然有序</td><td style="text-align:left">严格顺序消息，可平滑扩展</td></tr><tr><td style="text-align:left">定时/延迟消息</td><td style="text-align:left">支持</td><td style="text-align:left">不支持</td><td style="text-align:left">支持（使用延迟插件）</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">批量消息</td><td style="text-align:left">不支持</td><td style="text-align:left">支持（异步生产者）</td><td style="text-align:left">支持（Publisher Confirms 模式下）</td><td style="text-align:left">支持（同步模式可避免消息丢失）</td></tr><tr><td style="text-align:left">广播消息</td><td style="text-align:left">支持</td><td style="text-align:left">不支持</td><td style="text-align:left">支持（Fanout 交换机）</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">消息过滤</td><td style="text-align:left">支持</td><td style="text-align:left">支持（可用 Kafka Streams 实现）</td><td style="text-align:left">支持（基于 Exchange 的路由键或 Header）</td><td style="text-align:left">支持（基于 SQL92 属性过滤）</td></tr><tr><td style="text-align:left">服务器端触发重投递</td><td style="text-align:left">不支持</td><td style="text-align:left">不支持</td><td style="text-align:left">支持（Nack 或 TTL+DLX）</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">消息存储</td><td style="text-align:left">支持高性能持久化（JDBC + LevelDB/KahaDB）</td><td style="text-align:left">高性能文件存储</td><td style="text-align:left">内存+磁盘混合存储（Mnesia/基于 Erlang 的日志）</td><td style="text-align:left">高性能、低延迟文件存储</td></tr><tr><td style="text-align:left">消息回溯（历史消息查询）</td><td style="text-align:left">支持</td><td style="text-align:left">支持（通过 offset）</td><td style="text-align:left">不支持（消息被消费后无法回溯）</td><td style="text-align:left">支持（时间戳与 offset）</td></tr><tr><td style="text-align:left">消息优先级</td><td style="text-align:left">支持</td><td style="text-align:left">不支持</td><td style="text-align:left">支持（优先级队列）</td><td style="text-align:left">不支持</td></tr><tr><td style="text-align:left">高可用与故障转移</td><td style="text-align:left">依赖存储，如 LevelDB 需 ZooKeeper</td><td style="text-align:left">需要 ZooKeeper</td><td style="text-align:left">支持镜像队列（Classic / Quorum 模式）</td><td style="text-align:left">支持主从模式（无需额外组件）</td></tr><tr><td style="text-align:left">消息轨迹（Message Track）</td><td style="text-align:left">不支持</td><td style="text-align:left">不支持</td><td style="text-align:left">不支持（可通过插件扩展）</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">配置复杂度</td><td style="text-align:left">默认配置较低，需手动优化</td><td style="text-align:left">配置为键值对，可文件或代码提供</td><td style="text-align:left">开箱即用，配置灵活但选项较多</td><td style="text-align:left">开箱即用，仅需关注少量配置</td></tr><tr><td style="text-align:left">管理与运维工具</td><td style="text-align:left">支持</td><td style="text-align:left">支持（命令行监控）</td><td style="text-align:left">支持（Web 管理控制台、CLI）</td><td style="text-align:left">支持（丰富的 Web 与命令行工具）</td></tr></tbody></table><h2 id="RocketMQ-的安装">RocketMQ 的安装</h2><ul class="lvl-0"><li class="lvl-2"><p>RocketMQ 5.x 依赖 JDK 1.8+。</p></li></ul><h3 id="单机安装">单机安装</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/quickStart/01quickstart">官方文档</a></p></li><li class="lvl-2"><p>下载RocketMQ</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft/rocketmq/</span><br><span class="line">wget https://dist.apache.org/repos/dist/release/rocketmq/5.3.2/rocketmq-all-5.3.2-bin-release.zip</span><br><span class="line">unzip rocketmq-all-5.3.2-bin-release.zip</span><br><span class="line"><span class="built_in">ln</span> -s rocketmq-all-5.3.2-bin-release rocketmq5</span><br><span class="line"><span class="built_in">cd</span> rocketmq5</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">默认脚本中，NameServer需要4G内存，Broker 需要8G内存，如果内存不够，可以进入bin目录，对其中的<code>runserver.sh</code>和<code>runbroker.sh</code>两个脚本进行一下修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用vi runserver.sh指令，编辑这个脚本，找到下面的一行配置，调整Java进程的内存大小。</span></span><br><span class="line"><span class="comment"># NameServer,Controller,Proxy 都使用这个脚本启动</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class="line">修改为：</span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，同样调整runbroker.sh中的内存大小。Broker 使用这个脚本启动</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms8g -Xmx8g&quot;</span></span><br><span class="line">修改为：</span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g&quot;</span></span><br></pre></td></tr></table></figure></div><ul class="lvl-0"><li class="lvl-2"><p>启动 NameServer</p></li></ul><blockquote><p>安装完RocketMQ包后，我们启动NameServer</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 启动namesrv</span></span><br><span class="line">$ <span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="comment">## 指定配置文件</span></span><br><span class="line">$ <span class="built_in">nohup</span> sh bin/mqnamesrv -c namesrv.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证namesrv是否启动成功</span></span><br><span class="line">$ <span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="comment"># 我们可以在namesrv.log 中看到 &#x27;The Name Server boot success..&#x27;， 表示NameServer 已成功启动。</span></span><br><span class="line">The Name Server boot success. serializeType=JSON, address 0.0.0.0:9876</span><br></pre></td></tr></table></figure><blockquote><p>namesrv.conf 示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The port of nameserver</span></span><br><span class="line">listenPort = 9876</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 Broker+Proxy</p></li></ul><blockquote><p>NameServer成功启动后，我们启动Broker和Proxy。这里我们使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 先启动broker</span></span><br><span class="line">$ <span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;</span><br><span class="line"><span class="comment"># 指定配置文件， 默认就是 conf/broker.conf</span></span><br><span class="line">$ <span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 -c conf/broker.conf --enable-proxy &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span><br><span class="line">$ <span class="built_in">tail</span> -f ~/logs/rocketmqlogs/proxy.log</span><br><span class="line"><span class="comment"># 我们可以在 proxy.log 中看到“The broker[brokerName,ip:port] boot success..”，这表明 broker 已成功启动。</span></span><br><span class="line">The broker[broker-a, 10.250.0.175:10911] boot success. serializeType=JSON and name server is localhost:9876</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>关闭服务器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停止 Broker</span></span><br><span class="line">$ sh bin/mqshutdown broker</span><br><span class="line"><span class="comment"># 停止 NameServer</span></span><br><span class="line">$ sh bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure><h3 id="集群安装-多节点（集群）多副本模式-异步复制">集群安装:多节点（集群）多副本模式-异步复制</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/01deploy">官网文档</a> 对集群安装的方式介绍了多种，本文仅实战一种：<code>多节点（集群）多副本模式-异步复制</code></p></li><li class="lvl-2"><p>每个Master配置一个Slave，有多组 Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul class="lvl-2"><li class="lvl-6">优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li><li class="lvl-6">缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li></ul></li><li class="lvl-2"><p>该模式下，Master 节点和 Slave 节点之间是异步复制的，Master 节点挂掉后，Slave 节点不会自动切换为 Master 节点。</p></li><li class="lvl-2"><p>集群规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NameServer 3 台</span></span><br><span class="line">NameServer1 10.250.0.175</span><br><span class="line">NameServer2 10.250.0.188</span><br><span class="line">NameServer3 10.250.0.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 2 Master 2 Replicas</span></span><br><span class="line">Broker1 10.250.0.188 broker-a,broker-b-s</span><br><span class="line">Broker2 10.250.0.31  broker-b,broker-a-s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Proxy 3 台</span></span><br><span class="line">Proxy1 10.250.0.175</span><br><span class="line">Proxy2 10.250.0.188</span><br><span class="line">Proxy3 10.250.0.31</span><br></pre></td></tr></table></figure><h4 id="部署-NameServer">部署 NameServer</h4><ul class="lvl-0"><li class="lvl-2"><p>在三台服务器上分别启动RocketMQ NameServer</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/soft/rocketmq/rocketmq5</span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><h4 id="部署Broker">部署Broker</h4><ul class="lvl-0"><li class="lvl-2"><p>broker-a.properties</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster <span class="comment"># 集群名称必须一致</span></span><br><span class="line">brokerName=broker-a              <span class="comment"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class="line">brokerId=0                       <span class="comment"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class="line">deleteWhen=04                    <span class="comment"># 表示凌晨 4 点清理</span></span><br><span class="line">fileReservedTime=48              <span class="comment"># 表示保存 48 小时的数据</span></span><br><span class="line">brokerRole=ASYNC_MASTER          <span class="comment"># 角色，表示异步复制的主节点</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH        <span class="comment"># 表示异步刷盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class="line"><span class="comment"># 存储数据路径，后面会介绍</span></span><br><span class="line">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class="line">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class="line">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class="line">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class="line">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class="line">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class="line">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class="line">listenPort=10911</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>broker-a-s.properties</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster <span class="comment"># 集群名称必须一致</span></span><br><span class="line">brokerName=broker-a              <span class="comment"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class="line">brokerId=1                       <span class="comment"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=SLAVE                 <span class="comment"># 角色，表示异步复制的从节点</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class="line"><span class="comment"># 存储数据路径</span></span><br><span class="line">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class="line">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class="line">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class="line">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class="line">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class="line">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class="line">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class="line">listenPort=11011</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>broker-b.properties</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster <span class="comment"># 集群名称必须一致</span></span><br><span class="line">brokerName=broker-b              <span class="comment"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class="line">brokerId=0                       <span class="comment"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class="line">deleteWhen=04                    <span class="comment"># 表示凌晨 4 点清理</span></span><br><span class="line">fileReservedTime=48              <span class="comment"># 表示保存 48 小时的数据</span></span><br><span class="line">brokerRole=ASYNC_MASTER          <span class="comment"># 角色，表示异步复制的主节点</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH        <span class="comment"># 表示异步刷盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class="line"><span class="comment"># 存储数据路径</span></span><br><span class="line">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class="line">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class="line">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class="line">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class="line">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class="line">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class="line">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class="line"></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class="line">listenPort=10911</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>broker-b-s.properties</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster <span class="comment"># 集群名称必须一致</span></span><br><span class="line">brokerName=broker-b              <span class="comment"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class="line">brokerId=1                       <span class="comment"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=SLAVE                 <span class="comment"># 角色，表示异步复制的从节点</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class="line"><span class="comment"># 存储数据路径</span></span><br><span class="line">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class="line">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class="line">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class="line">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class="line">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class="line">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class="line">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class="line"></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class="line">listenPort=11011</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 Broker1 10.250.0.188 上启动 broker-a 和 broker-b-s</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 broker-a</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line"><span class="comment"># 启动 broker-b-s</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## nohup.out 中的输出类似与下面这种就表示启动成功</span></span><br><span class="line">The broker[broker-a, 10.250.0.31:11011] boot success. serializeType=JSON and name server is 10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 Broker2 10.250.0.31 上启动 broker-b 和 broker-a-s</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 broker-b</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line"><span class="comment"># 启动 broker-a-s</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动成功后，可以通过如下命令检查机器状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class="line">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class="line"><span class="comment">## 输出类似如下</span></span><br><span class="line"><span class="comment">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class="line">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-a                1     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600         <span class="literal">false</span></span><br><span class="line">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-b                1     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900         <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="配置-Proxy">配置 Proxy</h4><ul class="lvl-0"><li class="lvl-2"><p>在三台服务器上分别启动RocketMQ NameServer</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> sh bin/mqproxy -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定配置文件，这里要注意，集群的名称要与 conf/rmq-proxy.json 中配置的集群名称必须一致，默认是 DefaultCluster</span></span><br><span class="line"><span class="comment">## 默认的配置文件就是 conf/rmq-proxy.json，但如果通过 -pc 指定配置文件，则必须使用绝对路径</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqproxy -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看日志，输出如下内容就表示启动成功，tail -f nohup.out</span></span><br><span class="line">rocketmq-proxy startup successfully</span><br></pre></td></tr></table></figure><blockquote><p>rmq-proxy.json 示例</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rocketMQClusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DefaultCluster&quot;</span><span class="punctuation">,</span> # 集群名称</span><br><span class="line">  <span class="attr">&quot;remotingListenPort&quot;</span><span class="punctuation">:</span> <span class="number">8080</span><span class="punctuation">,</span>              # 监听端口，默认 <span class="number">8080</span></span><br><span class="line">  <span class="attr">&quot;grpcServerPort&quot;</span><span class="punctuation">:</span> <span class="number">8081</span>                   # grpc 监听端口，默认 <span class="number">8081</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>停止Proxy</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 Proxy</span></span><br><span class="line">sh bin/mqshutdown proxy</span><br></pre></td></tr></table></figure><h3 id="集群安装-主备自动切换模式部署">集群安装:主备自动切换模式部署</h3><ul class="lvl-0"><li class="lvl-2"><p>RocketMQ 5.x 提供了一种新的部署方式 <code>Controller</code>，可以在主从模式下实现主备自动切换，当主节点挂掉时，自动切换到从节点上运行。</p></li><li class="lvl-2"><p><a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/03autofailover">官方文档:主备自动切换模式部署</a></p></li><li class="lvl-2"><p>Controller 组件提供选主能力，若需要保证 Controller 具备容错能力，Controller 部署需要三副本及以上（遵循 Raft 的多数派协议）。</p></li><li class="lvl-2"><p>本文在上文“集群安装:多节点（集群）多副本模式-异步复制”的基础上进行修改</p></li><li class="lvl-2"><p>Controller 部署有两种方式。一种是嵌入于 NameServer 进行部署，另一种是独立部署，本文采用独立部署 Controller 组件的方式。</p></li><li class="lvl-2"><p>集群规划</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Controller 3 台</span></span><br><span class="line">Controller1 10.250.0.175</span><br><span class="line">Controller2 10.250.0.188</span><br><span class="line">Controller3 10.250.0.31</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别在每台机器上创建<code>controller.conf</code>配置文件，内容如下(注意修改节点Id)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># controller.conf</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># DLedger Raft Group 的名字，同一集群保持一致</span></span><br><span class="line">controllerDLegerGroup = group1</span><br><span class="line"><span class="comment"># 集群中三个节点的成员定义，每个节点都必须一致</span></span><br><span class="line">controllerDLegerPeers = n0-10.250.0.175:9877;n1-10.250.0.188:9877;n2-10.250.0.31:9877</span><br><span class="line"><span class="comment"># 节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一</span></span><br><span class="line">controllerDLegerSelfId = n0</span><br><span class="line"><span class="comment"># Controller 数据存储路径（非常关键！不要删除）</span></span><br><span class="line">controllerStorePath = /usr/local/soft/rocketmq/data/DledgerController</span><br><span class="line"><span class="comment"># 是否允许从 SyncStateSet 外选举 Master</span></span><br><span class="line"><span class="comment"># true 会加快选举但可能丢消息，建议生产保持 false</span></span><br><span class="line">enableElectUncleanMaster = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 当 Broker 副本角色变化时是否主动通知（建议开启）</span></span><br><span class="line">notifyBrokerRoleChanged = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 启动端口，端口不能与 NameServer、Broker、Proxy 端口冲突</span></span><br><span class="line">listenPort = 9877</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动每台机器上的 Controller</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> sh bin/mqcontroller -n <span class="string">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/controller.conf &amp;</span><br><span class="line"><span class="comment">## 启动成功后，查看 nohup.out 文件，输出如下内容就表示启动成功</span></span><br><span class="line">load config properties file OK, conf/controller.conf</span><br><span class="line">The Controller Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>修改 broker 配置文件，以 <code>broker-a.properties</code> 为例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉如下配置，Controller 模式下 会自动分配</span></span><br><span class="line"><span class="comment"># brokerId=1                       # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class="line"><span class="comment"># brokerRole=ASYNC_MASTER          # 角色，表示异步复制的主节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下配置</span></span><br><span class="line"><span class="comment"># 启用 Controller 模式（自动主从切换模式的总开关）</span></span><br><span class="line">enableControllerMode = <span class="literal">true</span></span><br><span class="line"><span class="comment"># Controller 集群地址列表（建议与 Controller 集群保持一致）</span></span><br><span class="line">controllerAddr = 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</span><br></pre></td></tr></table></figure><blockquote><p>RocketMQ 5 Broker Controller 模式配置参数表</p></blockquote><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">说明</th><th style="text-align:center">默认值</th><th style="text-align:left">备注 / 建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>enableControllerMode</strong></td><td style="text-align:left">是否启用 Controller 模式（自动主从切换总开关）</td><td style="text-align:center"><code>false</code></td><td style="text-align:left">必须设为 <code>true</code> 才能启用自动主从切换</td></tr><tr><td style="text-align:left"><strong>controllerAddr</strong></td><td style="text-align:left">Controller 集群地址列表（以分号分隔）</td><td style="text-align:center">无</td><td style="text-align:left">所有 Broker 配置应一致，例如 <code>10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</code></td></tr><tr><td style="text-align:left"><strong>syncBrokerMetadataPeriod</strong></td><td style="text-align:left">向 Controller 同步 Broker 副本信息的时间间隔（毫秒）</td><td style="text-align:center"><code>5000</code> (5s)</td><td style="text-align:left">保持默认即可；用于上报心跳与元数据</td></tr><tr><td style="text-align:left"><strong>checkSyncStateSetPeriod</strong></td><td style="text-align:left">检查同步状态集（SyncStateSet）的时间间隔（毫秒）</td><td style="text-align:center"><code>5000</code> (5s)</td><td style="text-align:left">Controller 会定期剔除落后副本</td></tr><tr><td style="text-align:left"><strong>syncControllerMetadataPeriod</strong></td><td style="text-align:left">同步 Controller 元数据的时间间隔（毫秒）</td><td style="text-align:center"><code>10000</code> (10s)</td><td style="text-align:left">Broker 定期从集群获取当前活跃 Controller 地址</td></tr><tr><td style="text-align:left"><strong>haMaxTimeSlaveNotCatchup</strong></td><td style="text-align:left">Slave 未跟上 Master 的最大时间间隔（毫秒）</td><td style="text-align:center"><code>15000</code> (15s)</td><td style="text-align:left">超过该时间将 Slave 移出 SyncStateSet</td></tr><tr><td style="text-align:left"><strong>storePathEpochFile</strong></td><td style="text-align:left">Epoch 文件存储路径</td><td style="text-align:center"><code>store/epochFile</code></td><td style="text-align:left">非常重要！不要删除；存储主从任期、epoch 等元信息</td></tr><tr><td style="text-align:left"><strong>allAckInSyncStateSet</strong></td><td style="text-align:left">是否要求所有同步副本都 ACK 后才返回成功</td><td style="text-align:center"><code>false</code></td><td style="text-align:left"><code>true</code> 可保证强一致但性能下降；建议保持默认</td></tr><tr><td style="text-align:left"><strong>syncFromLastFile</strong></td><td style="text-align:left">Slave 是否从最后一个文件开始复制（空盘启动时）</td><td style="text-align:center"><code>false</code></td><td style="text-align:left">若历史日志很大且 Slave 新建，可设为 <code>true</code></td></tr><tr><td style="text-align:left"><strong>asyncLearner</strong></td><td style="text-align:left">是否为异步 learner 副本（不参与选主）</td><td style="text-align:center"><code>false</code></td><td style="text-align:left">用于远程灾备副本，不会被选举为 Master</td></tr><tr><td style="text-align:left"><strong>inSyncReplicas</strong></td><td style="text-align:left">需保持同步的副本组数量</td><td style="text-align:center"><code>1</code></td><td style="text-align:left">若 <code>allAckInSyncStateSet=true</code>，该参数无效</td></tr><tr><td style="text-align:left"><strong>minInSyncReplicas</strong></td><td style="text-align:left">最小同步副本数量，低于该值则拒绝写入</td><td style="text-align:center"><code>1</code></td><td style="text-align:left">防止写入过多未同步副本导致数据丢失风险</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>重新启动 Broker，为保证主从数据一致性在重启时不被破坏，启动顺序应为先重新原Master，再重启原Slave</p></li><li class="lvl-2"><p>启动成功后，可以通过如下命令检查机器状态，可以看到集群内部自动分配了主从</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class="line">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class="line"><span class="comment">## 输出类似如下</span></span><br><span class="line"><span class="comment">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class="line">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  2-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700         <span class="literal">false</span></span><br><span class="line">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-b                2     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900         <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>验证主备自动切换，此时关闭 <code>broker-b</code> 的 Master，并查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class="line"><span class="comment">## 输出类似如下，可以看到`broker-b`原来的 Slave 被切换为 Master</span></span><br><span class="line"><span class="comment">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class="line">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class="literal">true</span></span><br><span class="line">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  489268.58     0.2700         <span class="literal">false</span></span><br><span class="line">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重新启动刚才关闭的 <code>broker-b</code> ，节点会自动加入集群，角色为 Slave</p></li><li class="lvl-2"><p>停止 Controller</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 PrControlleroxy</span></span><br><span class="line">sh bin/mqshutdown controller</span><br></pre></td></tr></table></figure><h2 id="端口说明">端口说明</h2><table><thead><tr><th>端口号</th><th>协议</th><th>组件/服务</th><th>作用说明</th></tr></thead><tbody><tr><td><strong>9876</strong></td><td>TCP</td><td><strong>NameServer</strong></td><td>RocketMQ 集群的 <strong>NameServer</strong> 服务端口。<br>用于 Broker 注册、客户端路由发现。<br>Producer/Consumer 连接此端口以获取 Broker 地址。</td></tr><tr><td><strong>8080</strong></td><td>TCP</td><td><strong>Proxy (gRPC / HTTP)</strong></td><td>RocketMQ 5 引入的 <strong>Proxy 服务</strong> 默认端口之一。<br>用于 <strong>HTTP/gRPC 客户端接入</strong>，例如 RocketMQ Proxy REST API、异步消息接口等。</td></tr><tr><td><strong>8081</strong></td><td>TCP</td><td><strong>Proxy Admin / Dashboard / gRPC Alt</strong></td><td>通常是 Proxy 的 <strong>管理接口</strong> 或 <strong>gRPC 辅助端口</strong>（依配置而定）。<br>也可能是控制面接口，用于与 Console 或控制工具通信。</td></tr><tr><td><strong>10909</strong></td><td>TCP</td><td><strong>Broker HA (High Availability)</strong></td><td>Broker <strong>主从同步端口</strong>（Master ↔ Slave 之间的数据复制）。<br>用于消息数据与元数据的同步。</td></tr><tr><td><strong>10911</strong></td><td>TCP</td><td><strong>Broker 服务端口</strong></td><td>Broker 的 <strong>主通信端口</strong>，客户端连接发送消息、消费消息、心跳等。<br>Producer 和 Consumer 通过 NameServer 获取该端口地址后进行通信。</td></tr><tr><td><strong>10912</strong></td><td>TCP</td><td><strong>Broker HA 客户端端口</strong></td><td>Broker <strong>主从复制中的 Slave 连接 Master</strong> 时使用的 <strong>客户端监听端口</strong>。<br>通常与 10909 配合使用，一主多从模式中 Slave 主动连接 Master。</td></tr></tbody></table><h2 id="日志及数据存储路径">日志及数据存储路径</h2><ul class="lvl-0"><li class="lvl-2"><p>RocketMQ 5 主要有三类服务组件需要关注它们的存储目录</p></li></ul><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">功能</th><th style="text-align:left">默认存储内容</th><th style="text-align:left">默认路径（Linux 环境）</th></tr></thead><tbody><tr><td style="text-align:left"><strong>NameServer</strong></td><td style="text-align:left">路由服务（注册中心）</td><td style="text-align:left">各个组件的的注册</td><td style="text-align:left">日志文件：<code>~/logs/rocketmqlogs/namesrv.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.namesrv.logback.xml</code> <br> 配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/namesrv.conf</code>（可选）</td></tr><tr><td style="text-align:left"><strong>Broker</strong></td><td style="text-align:left">核心消息存储与转发服务</td><td style="text-align:left">消息数据（CommitLog、ConsumeQueue、Index、Config）<br><strong>目录结构：</strong><br>├── <code>commitlog/</code> → 消息物理文件<br>├── <code>consumequeue/</code> → 消费队列索引<br>├── <code>index/</code> → 消息索引<br>├── <code>config/</code> → topic、offset、subscription 信息<br>├── <code>checkpoint</code> → 存储校验点<br>├── <code>abort</code> → 异常退出标志</td><td style="text-align:left"><strong>数据目录</strong>：<code>~/store</code><br>日志文件：<code>~/logs/rocketmqlogs/broker.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.broker.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/broker.conf</code></td></tr><tr><td style="text-align:left"><strong>Proxy</strong></td><td style="text-align:left">客户端访问入口层（无状态代理）<br>（5.x 新引入组件）</td><td style="text-align:left">转发日志、访问日志</td><td style="text-align:left">日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.proxy.logback.xml</code><br>日志文件：<code>~/logs/rocketmqlogs/proxy.log</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq-proxy.json</code></td></tr><tr><td style="text-align:left"><strong>Controller</strong></td><td style="text-align:left"><strong>Broker 主从协调与高可用管理</strong><br>（5.x 新引入组件）</td><td style="text-align:left">- 集群主从元数据（主从关系、broker注册信息）<br>- Controller 自身运行状态与选举元数据</td><td style="text-align:left"><strong>数据目录</strong>：<code>~/store/controller</code><br>日志文件：<code>~/logs/rocketmqlogs/controller.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.controller.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/controller.conf</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>NameServer 和 Proxy 都是无状态（stateless）组件，不会持久化业务数据。</p></li><li class="lvl-2"><p>Broker 数据路径说明</p></li></ul><table><thead><tr><th style="text-align:left">配置项</th><th style="text-align:left">默认路径</th><th style="text-align:left">说明</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:left"><strong>storePathRootDir</strong></td><td style="text-align:left"><code>/home/rocketmq/store</code><br>（默认）</td><td style="text-align:left">消息存储的根目录</td><td style="text-align:left">作为所有存储文件的父级目录，其他路径若未单独配置，则在此目录下创建</td></tr><tr><td style="text-align:left"><strong>storePathCommitLog</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/commitlog</code></td><td style="text-align:left">CommitLog 文件存放路径</td><td style="text-align:left">存储消息主体内容，是最核心的数据文件（顺序写入）</td></tr><tr><td style="text-align:left"><strong>storePathConsumeQueue</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/consumequeue</code></td><td style="text-align:left">消费队列文件存放路径</td><td style="text-align:left">存储消息在队列中的索引（逻辑队列），指向 CommitLog 的物理位置</td></tr><tr><td style="text-align:left"><strong>storePathIndex</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/index</code></td><td style="text-align:left">索引文件存放路径</td><td style="text-align:left">提供按 Key 查询消息的索引结构，便于通过 Message Key 快速检索消息</td></tr><tr><td style="text-align:left"><strong>storePathConfig</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/config</code></td><td style="text-align:left">Broker 运行时配置存储路径</td><td style="text-align:left">存储运行时生成的配置文件，如 topic、consumerOffset、subscriptionGroup 等</td></tr><tr><td style="text-align:left"><strong>storeCheckpoint</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/checkpoint</code></td><td style="text-align:left">Checkpoint 文件路径</td><td style="text-align:left">记录 CommitLog、ConsumeQueue、Index 三者的刷盘进度，用于崩溃恢复</td></tr><tr><td style="text-align:left"><strong>abortFile</strong></td><td style="text-align:left"><code>$&#123;storePathRootDir&#125;/abort</code></td><td style="text-align:left">异常退出标志文件路径</td><td style="text-align:left">用于标识 Broker 是否异常退出，启动时据此判断是否执行恢复流程</td></tr></tbody></table><hr><h2 id="安装过程中遇到的问题">安装过程中遇到的问题</h2><h3 id="1-启动-Proxy-失败">1.启动 Proxy 失败</h3><ul class="lvl-0"><li class="lvl-2"><p>无论是 <code>Broker+Proxy</code> 启动，还是 单独启动 <code>Proxy</code>，都报如下错误：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误会在 nohup.out 中输出</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.UnsatisfiedLinkError: failed to load the required native library</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64_fedora, netty_tcnative_linux_x86_64, netty_tcnative_x86_64, netty_tcnative]</span><br><span class="line"></span><br><span class="line">Suppressed: java.lang.UnsatisfiedLinkError: /tmp/libnetty_tcnative_linux_x86_642308675901892111861.so: libcrypt.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>原因分析</p><ul class="lvl-2"><li class="lvl-4"><ol><li class="lvl-7">Netty-tcnative 的编译依赖：RocketMQ 使用的 Netty 的 tcnative 模块是在较旧的环境中编译的，而动态链接的版本锁定：编译时链接的是 libcrypt.so.1，运行时必须找到相同主版本号的库</li></ol></li><li class="lvl-4"><ol start="2"><li class="lvl-7">而我当前使用的系统为 Amazon Linux 2023，基于更新的 glibc，其加密功能已经迁移到 libcrypt.so.2。（Amazon Linux 2：基于较旧的 glibc 版本，libcrypt.so.1 是主要的加密库）</li></ol></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 libcrypt 是否存在</span></span><br><span class="line">$ ldconfig -p | grep libcrypt</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class="line">libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class="line">libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class="line">libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class="line">libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>解决办法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装兼容性包</span></span><br><span class="line"><span class="built_in">sudo</span> yum install libxcrypt-compat</span><br><span class="line"><span class="comment"># 检查 libcrypt 是否存在</span></span><br><span class="line">$ ldconfig -p | grep libcrypt</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class="line">libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class="line">libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class="line">libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class="line">libcrypt.so.1 (libc6,x86-64) =&gt; /lib64/libcrypt.so.1</span><br><span class="line">libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure><h3 id="2-写入消息失败，并报如下错误">2.写入消息失败，并报如下错误</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.rocketmq.client.exception.MQBrokerException: CODE: 14 DESC: service not available now. It may be caused by one of the following reasons: the broker<span class="string">&#x27;s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00], messages are put to the slave, message store has been shut down, etc. BROKER: 10.250.0.175:10911</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>错误原因</p><ul class="lvl-2"><li class="lvl-4">RocketMQ 返回的 CODE: 14 表示：Broker 当前 不接受消息写入（服务暂不可用）。</li><li class="lvl-4">the broker’s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00]: Broker 的磁盘已满</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL: 0.95 → CommitLog 95% 已使用</span><br><span class="line">CQ: 0.95 → ConsumeQueue 95% 已使用</span><br><span class="line">INDEX: -1.00 → 索引异常或未采集</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>配置项</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td><code>diskMaxUsedSpaceRatio</code></td><td>Broker 磁盘最大可用比例（超过后禁止写入）</td><td><strong>75%</strong></td></tr><tr><td><code>storePathCommitLog</code></td><td>消息存储路径（CommitLog）</td><td><code>~/store/commitlog</code></td></tr><tr><td><code>storePathConsumeQueue</code></td><td>消费队列路径（ConsumeQueue）</td><td><code>~/store/consumequeue</code></td></tr><tr><td><code>storePathIndex</code></td><td>索引路径</td><td><code>~/store/index</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-4"><p>总结：可以确认是 磁盘使用率过高 导致 Broker 自动进入 “写保护” 模式。</p></li></ul><ul class="lvl-0"><li class="lvl-2"><p>解决方法</p><ul class="lvl-2"><li class="lvl-6"><ol><li class="lvl-9">清理磁盘：确认磁盘使用率过高，并清理磁盘空间，既降低磁盘使用率</li></ol></li><li class="lvl-6"><ol start="2"><li class="lvl-9">磁盘扩容：如果清理磁盘空间后，磁盘使用率依然过高，则需要扩容磁盘</li></ol></li><li class="lvl-6"><ol start="3"><li class="lvl-9">配置调整：调整 Broker 配置(<code>broker.conf</code>)，将 <code>diskMaxUsedSpaceRatio</code> 配置适当提高，如 96%(<code>diskMaxUsedSpaceRatio=96</code>)，调整后重启 Broker。仅建议在紧急情况下临时解决。</li></ol></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 CentOS9 中 RocketMQ 的安装与使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/zh/&quot;&gt;RocketMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RocketMQ 版本为 5.3.2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rocketmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rocketmq" scheme="https://blog.hanqunfeng.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 从 Zookeeper 迁移到 KRaft</title>
    <link href="https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/"/>
    <id>https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/</id>
    <published>2025-10-16T14:30:05.000Z</published>
    <updated>2025-10-20T02:50:02.041Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org/39/documentation.html#kraft_zk_migration">官方文档：ZooKeeper到KRaft迁移</a></p></li></ul><span id="more"></span><h2 id="从-Zookeeper-模式迁移到-KRaft-模式（平滑迁移）">从 Zookeeper 模式迁移到 KRaft 模式（平滑迁移）</h2><p><em><strong>！！！迁移后将无法再恢复到 ZooKeeper 模式！！！</strong></em></p><ul class="lvl-0"><li class="lvl-2"><p>Kafka 官方在 3.4+ 引入了完整的 Zookeeper → KRaft 平滑迁移机制，称为 <code>ZK to KRaft (ZkMigration)</code>。</p></li><li class="lvl-2"><p>迁移背景与前提</p></li></ul><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">支持版本</td><td style="text-align:left">Kafka <strong>3.4.0+</strong>（建议至少使用 <strong>3.6.x ，目前最新版为 3.9.x</strong>）</td></tr><tr><td style="text-align:left">迁移目的</td><td style="text-align:left">摆脱 ZooKeeper，完全切换为 KRaft 自管理模式</td></tr><tr><td style="text-align:left">迁移模式</td><td style="text-align:left"><strong>在线迁移</strong>（无停机或最小停机）</td></tr><tr><td style="text-align:left">最终目标</td><td style="text-align:left">Kafka 的控制器与元数据完全由 KRaft 管理，不再依赖 ZooKeeper。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>整体迁移流程概览</p></li></ul><table><thead><tr><th>阶段</th><th>控制器类型</th><th>Broker 模式</th><th>ZooKeeper 角色</th><th>KRaft 角色</th><th>特征说明</th></tr></thead><tbody><tr><td><strong>初始阶段</strong></td><td>ZooKeeper 控制器</td><td>全部为 ZK 模式</td><td>管理所有元数据</td><td>尚未启用</td><td>所有 Broker 都运行在 ZK 模式下，由 ZK 控制器管理集群。</td></tr><tr><td><strong>初始元数据加载阶段</strong></td><td>KRaft 控制器开始加载</td><td>部分（或全部）仍为 ZK 模式</td><td>提供元数据源</td><td>从 ZK 加载元数据</td><td>KRaft 法定节点（controller.quorum.voters）从 ZK 中读取并同步当前集群元数据。</td></tr><tr><td><strong>混合阶段</strong></td><td>KRaft 控制器</td><td>部分 ZK 模式，部分 KRaft 模式</td><td>保留只读元数据</td><td>管理并更新元数据</td><td>KRaft 控制器成为主控，ZK 仍存在但只提供读取，Broker 可处于不同模式（混合状态）。</td></tr><tr><td><strong>双写阶段</strong></td><td>KRaft 控制器</td><td>全部为 KRaft 模式</td><td>接收 KRaft 同步写入</td><td>管理元数据并写入 ZK</td><td>所有 Broker 都运行在 KRaft 模式，控制器将元数据同时写入 ZK 和 KRaft 日志。</td></tr><tr><td><strong>迁移完成阶段</strong></td><td>KRaft 控制器</td><td>全部为 KRaft 模式</td><td>不再使用</td><td>独立运行</td><td>停止向 ZK 写入元数据，ZK 可安全关闭，Kafka 完全运行在无 Zookeeper 的 KRaft 模式下。</td></tr></tbody></table><h2 id="开始迁移">开始迁移</h2><ul class="lvl-0"><li class="lvl-2"><p>这里以前文 <a href="/2025/10/13/kafka-01-install-zookeeper/" title="Kafka 的安装：基于 Zookeeper">Kafka 的安装：基于 Zookeeper</a> 中的3个节点的集群为例。</p></li></ul><h3 id="启动一个-Controller-节点">启动一个 Controller 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>在任意一个节点上启动一个 Controller 节点，这里为 worker1</p></li><li class="lvl-2"><p>启动前需要先获取当前 Kafka 集群的 Cluster ID</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ zookeeper-shell.sh localhost:2181 get /cluster/id</span><br><span class="line">Connecting to localhost:2181</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;hp_Q0pihQ0ORcIvXlfHobQ&quot;</span>&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>准备好 Controller 节点的配置文件，这里可以用 <code>config/kraft/controller.properties</code> 为模板进行修改</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置当前节点的角色，这里只能是controller</span></span><br><span class="line">process.roles=controller</span><br><span class="line"><span class="comment"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class="line">node.id=3000</span><br><span class="line"><span class="comment"># 配置集群的投票节点，因为我们当前只启动了一个controller节点，所以只能配置一个投票节点</span></span><br><span class="line">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class="line"><span class="comment"># 配置监听器，注意端口不能重复</span></span><br><span class="line">listeners=CONTROLLER://:9098</span><br><span class="line">advertised.listeners=CONTROLLER://worker1:9098</span><br><span class="line">controller.listener.names=CONTROLLER</span><br><span class="line"><span class="comment"># 日志存放目录，这里存放的是元数据，在格式化时这个目录必须为空目录</span></span><br><span class="line">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class="line">zookeeper.metadata.migration.enable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ZooKeeper client 连接</span></span><br><span class="line">zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class="line"><span class="comment"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class="line">inter.broker.listener.name=PLAINTEXT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它参数尽量保持与旧集群的配置一致</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 Controller 节点</p></li></ul><blockquote><p>千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 <a href="http://kafka-storage.sh">kafka-storage.sh</a> format ，那会把原有数据结构重置或踩坏。<br>必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化元数据目录，log.dirs 参数指定元数据存放目录，首次运行前必须为空目录</span></span><br><span class="line"><span class="comment"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class="line">kafka-storage.sh format --standalone -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br><span class="line"><span class="comment"># 启动，这里没有后台启动是为了方便观察日志输出</span></span><br><span class="line">kafka-server-start.sh /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>format 命令</th><th>quorum 状态</th><th>是否从 ZK 加载</th></tr></thead><tbody><tr><td>迁移阶段（standalone）</td><td><code>--standalone</code></td><td>无（单节点）</td><td>✅ 是</td></tr><tr><td>正式 KRaft 模式</td><td>无 <code>--standalone</code></td><td>✅ 多节点</td><td>❌ 否（独立运行）</td></tr></tbody></table><h3 id="将原先的三个节点作为-Broker-节点重新启动">将原先的三个节点作为 Broker 节点重新启动</h3><ul class="lvl-0"><li class="lvl-2"><p>修改原先的配置文件 <code>server.properties</code>，只需要修改如下内容即可</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在最后加入 CONTROLLER:PLAINTEXT</span></span><br><span class="line">listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,CONTROLLER:PLAINTEXT</span><br><span class="line"></span><br><span class="line"><span class="comment">## 以下是新加入的 配置项</span></span><br><span class="line"><span class="comment"># Set the IBP，当前 kafka 版本是 3.9.1，所以这里设置为 3.9</span></span><br><span class="line">inter.broker.protocol.version=3.9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class="line">zookeeper.metadata.migration.enable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KRaft controller quorum configuration，因为目前只启动了一个 controller 节点，所以只能配置一个投票节点</span></span><br><span class="line">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class="line"><span class="comment"># 控制器监听器名称，要与 contreller 节点配置文件 controller.properties 中的配置一致</span></span><br><span class="line">controller.listener.names=CONTROLLER</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别重新启动三个节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 kafka</span></span><br><span class="line">kafka-server-stop.sh</span><br><span class="line"><span class="comment"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class="line">ps -ef | grep kafka | grep  <span class="string">&quot;server\.properties&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动 kafka</span></span><br><span class="line">kafka-server-start.sh /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>当三个节点都以必要的配置重新启动后，迁移将自动开始。迁移完成后，可以在 Controller(worker1)节点 上看到类似如下日志：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 意味：从 ZooKeeper 到 KRaft 的初始元数据迁移已成功，共写入 62 条记录，当前 KRaft metadata offset 为 3179。这是迁移成功的明确证据。</span></span><br><span class="line">Completed migration of metadata from ZooKeeper to KRaft. 62 records were generated <span class="keyword">in</span> 300 ms across 1 batches. The average time spent waiting on a batch was 97.00 ms. The record types were &#123;TOPIC_RECORD=3, PARTITION_RECORD=56, CONFIG_RECORD=3&#125;. The current metadata offset is now 3179 with an epoch of 2. Saw 3 brokers <span class="keyword">in</span> the migrated metadata [1, 2, 3]. (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 意味：控制器已加载并生效新元数据与 feature set（与 offset 3179 对应）。</span></span><br><span class="line">Loaded new metadata Features(metadataVersion=3.9-IV0, finalizedFeatures=&#123;metadata.version=21&#125;, finalizedFeaturesEpoch=3179). (org.apache.kafka.metadata.publisher.FeaturesPublisher)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 意味：内部迁移状态已更新，KRaft 上有了写入位置记录。</span></span><br><span class="line">Finished initial migration of ZK metadata to KRaft <span class="keyword">in</span> 3486479 ns. Transitioned migration state from ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=-1, kraftMetadataEpoch=-1, lastUpdatedTimeMs=1760682050169, migrationZkVersion=1, controllerZkEpoch=3, controllerZkVersion=3&#125; to ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=3179, kraftMetadataEpoch=2, lastUpdatedTimeMs=1760682050169, migrationZkVersion=2, controllerZkEpoch=3, controllerZkVersion=3&#125; (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 意味：迁移流程按预期推进：先把 KRaft 的元数据与 ZK 对齐（sync），然后与 brokers 建立通信，最终进入 DUAL_WRITE（双写）。DUAL_WRITE 阶段表示控制器在写入 KRaft metadata log 的同时，仍然会把必要的写操作也写回 ZooKeeper（双写）——直到迁移完全完成并确认可以停止写 ZK 为止。</span></span><br><span class="line">3000 transitioning from ZK_MIGRATION to SYNC_KRAFT_TO_ZK state</span><br><span class="line">...</span><br><span class="line">Performing a full metadata <span class="built_in">sync</span> from KRaft to ZK.</span><br><span class="line">Did not make any ZK writes when reconciling with KRaft state.</span><br><span class="line">3000 transitioning ... to KRAFT_CONTROLLER_TO_BROKER_COMM</span><br><span class="line">...</span><br><span class="line">Sending RPCs to broker before moving to dual-write mode using at offset and epoch OffsetAndEpoch(offset=3179, epoch=2)</span><br><span class="line">...</span><br><span class="line">3000 transitioning ... to DUAL_WRITE state</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>上面的日志总体上表明，元数据迁移已成功完成并且控制器进入了双写（DUAL_WRITE）阶段。</p></li></ul><h3 id="将三个Broker节点的配置修改为-KRaft-模式的-broker-节点">将三个Broker节点的配置修改为 KRaft 模式的 broker 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>修改三个节点的配置文件 <code>server.properties</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加process.roles=broker</span></span><br><span class="line">process.roles=broker</span><br><span class="line"><span class="comment"># 用 node.id 替换 broker.id，注意，node.id 需要与 broker.id 一致</span></span><br><span class="line"><span class="comment"># broker.id=1</span></span><br><span class="line">node.id=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉 zookeeper 相关配置</span></span><br><span class="line"><span class="comment"># Don&#x27;t set the IBP, KRaft uses &quot;metadata.version&quot; feature flag</span></span><br><span class="line"><span class="comment"># inter.broker.protocol.version=3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove the migration enabled flag</span></span><br><span class="line"><span class="comment"># zookeeper.metadata.migration.enable=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove ZooKeeper client configuration</span></span><br><span class="line"><span class="comment"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别重新启动三个节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 kafka</span></span><br><span class="line">kafka-server-stop.sh</span><br><span class="line"><span class="comment"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class="line">ps -ef | grep kafka | grep  <span class="string">&quot;server\.properties&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动 kafka</span></span><br><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure><h3 id="将-Controller-节点的配置修改为-KRaft-模式的-controller-节点">将 Controller 节点的配置修改为 KRaft 模式的 controller 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>修改 controller 节点的配置文件 <code>controller.properties</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 去掉去下内容</span></span><br><span class="line"><span class="comment"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class="line"><span class="comment"># zookeeper.metadata.migration.enable=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ZooKeeper client 连接</span></span><br><span class="line"><span class="comment"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启启动 controller 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭后重新启动</span></span><br><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时你可以关闭 zookeeper 集群了，新的 kafka 集群将不再使用 ZooKeeper，也无法在恢复到 ZooKeeper 模式。</p></li></ul><h3 id="加入新的-Controller-节点">加入新的 Controller 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>Controller 尽量保持 奇数个节点。</p></li><li class="lvl-2"><p>之前已经在 <code>worker1</code> 节点上启动了 controller ，现在 <code>worker2</code> 和 <code>worker3</code> 上也来启动 controller 节点，并将它们加入到 kafka 集群中。</p></li><li class="lvl-2"><p>在开始配置前，先将上面的 controller 节点 和 三个 broker 节点 的如下配置进行修改，并重启启动。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 controller.quorum.bootstrap.servers 替换为 controller.quorum.voters</span></span><br><span class="line">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class="line"><span class="comment"># controller.quorum.bootstrap.servers=worker1:9098</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># controller.quorum.voters = 谁是正式投票成员（固定配置）</span></span><br><span class="line"><span class="comment"># controller.quorum.bootstrap.servers = 临时找谁引导连接（迁移或初始化用）</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>作用</th><th>适用阶段</th><th>是否必需</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>controller.quorum.voters</code></strong></td><td>定义 <strong>正式的 KRaft 控制器投票成员列表（voter set）</strong></td><td>集群正常运行时</td><td>✅ 是</td><td>所有节点必须配置相同的值</td></tr><tr><td><strong><code>controller.quorum.bootstrap.servers</code></strong></td><td>定义 <strong>迁移阶段或初始化阶段的控制器连接地址（bootstrap controller endpoint）</strong></td><td><strong>ZK → KRaft 迁移阶段</strong> 或 <strong>KRaft 集群初次启动</strong></td><td>⚙️ 可选（仅特定阶段）</td><td>用于在 controller quorum 尚未形成时的临时发现</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>参考 worker1 上的 controller 节点的配置文件 <code>controller.properties</code>，配置 woker2 的 controller 节点配置文件<code>controller.properties</code> ，worker3 也是类似的。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置当前节点的角色，这里只能是controller</span></span><br><span class="line">process.roles=controller</span><br><span class="line"><span class="comment"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class="line">node.id=3001</span><br><span class="line"><span class="comment"># 配置集群的投票节点</span></span><br><span class="line">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class="line"><span class="comment"># 配置监听器，注意端口不能重复</span></span><br><span class="line">listeners=CONTROLLER://:9098</span><br><span class="line">advertised.listeners=CONTROLLER://worker2:9098</span><br><span class="line">controller.listener.names=CONTROLLER</span><br><span class="line"><span class="comment"># 日志存放目录，这里存放的是元数据</span></span><br><span class="line">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class="line"><span class="comment"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class="line">inter.broker.listener.name=PLAINTEXT</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>初始化日志目录</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有 Controller 节点才需要初始化日志目录</span></span><br><span class="line"><span class="comment"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class="line">kafka-storage.sh format -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别启动 worker2 和 worker3 上的 controller 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时新的 controller 节点不会立刻加入选举队列，新节点初始状态默认是 observer，需要执行下面的命令将节点加入选举队列</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别在 worker2 和 worker3 上执行</span></span><br><span class="line">kafka-metadata-quorum.sh --bootstrap-server localhost:9092 --command-config /usr/local/kafka/kafka3/config/kraft/controller.properties add-controller</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群节点状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --replication</span><br><span class="line">NodeIdDirectoryId           LogEndOffsetLagLastFetchTimestampLastCaughtUpTimestampStatus</span><br><span class="line">3000  RJ4oOPGgTw-KxHFNn4SmiQ27820       0  1760696136345     1760696136345        Leader</span><br><span class="line">3001  zGnWA7zYmRHG6bcTlFV2qA27820       0  1760696136259     1760696136259        Follower</span><br><span class="line">3002  gIDkhOQJEHqg-GJBdezU1Q27820       0  1760696136257     1760696136257        Follower</span><br><span class="line">2     9KeeAYKEQHT92DxqNSwYuA27820       0  1760696136257     1760696136257        Observer</span><br><span class="line">1     Q8lr8JQ2vrDS35_DrI1MxA27820       0  1760696136257     1760696136257        Observer</span><br><span class="line">3     rgQR5wd_i5hLgU97dCKIvA27820       0  1760696136257     1760696136257        Observer</span><br><span class="line"></span><br><span class="line">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --status</span><br><span class="line">ClusterId:              hp_Q0pihQ0ORcIvXlfHobQ</span><br><span class="line">LeaderId:               3000</span><br><span class="line">LeaderEpoch:            5</span><br><span class="line">HighWatermark:          30094</span><br><span class="line">MaxFollowerLag:         0</span><br><span class="line">MaxFollowerLagTimeMs:   0</span><br><span class="line">CurrentVoters:          [&#123;<span class="string">&quot;id&quot;</span>: 3000, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;RJ4oOPGgTw-KxHFNn4SmiQ&quot;</span>, <span class="string">&quot;endpoints&quot;</span>: [<span class="string">&quot;CONTROLLER://worker1:9098&quot;</span>]&#125;, &#123;<span class="string">&quot;id&quot;</span>: 3001, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;zGnWA7zYmRHG6bcTlFV2qA&quot;</span>, <span class="string">&quot;endpoints&quot;</span>: [<span class="string">&quot;CONTROLLER://worker2:9098&quot;</span>]&#125;, &#123;<span class="string">&quot;id&quot;</span>: 3002, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;gIDkhOQJEHqg-GJBdezU1Q&quot;</span>, <span class="string">&quot;endpoints&quot;</span>: [<span class="string">&quot;CONTROLLER://worker3:9098&quot;</span>]&#125;]</span><br><span class="line">CurrentObservers:       [&#123;<span class="string">&quot;id&quot;</span>: 2, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;9KeeAYKEQHT92DxqNSwYuA&quot;</span>&#125;, &#123;<span class="string">&quot;id&quot;</span>: 1, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;Q8lr8JQ2vrDS35_DrI1MxA&quot;</span>&#125;, &#123;<span class="string">&quot;id&quot;</span>: 3, <span class="string">&quot;directoryId&quot;</span>: <span class="string">&quot;rgQR5wd_i5hLgU97dCKIvA&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="加入-新的-Broker-节点">加入 新的 Broker 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>创建新的 Broker 节点时，参考其它 Broker 节点 配置好配置文件 <code>server.properties</code>，并启动 Broker 节点即可。</p></li><li class="lvl-2"><p>无需运行日志目录初始化命令，因为 Broker 节点只存放 消息 数据。</p></li></ul><h2 id="迁移后注意事项">迁移后注意事项</h2><ul class="lvl-0"><li class="lvl-2"><p>迁移完成后，Kafka 客户端（Producer / Consumer / AdminClient）依然连接的是 Broker 节点，而不是 Controller 节点。</p></li><li class="lvl-2"><p>Kafka 在 ZooKeeper 模式与 KRaft 模式下的区别主要在于：</p><ul class="lvl-2"><li class="lvl-4">控制平面（Control Plane）：ZK 模式下由 ZooKeeper + Controller Broker 共同管理；KRaft 模式下由 独立的 Controller 进程或角色 管理（通过 Raft 协议同步元数据）。</li><li class="lvl-4">数据平面（Data Plane）：无论是哪个模式，客户端发送、消费消息仍然是通过 Broker 节点 完成的。</li><li class="lvl-4">也就是说，Controller 管理集群元数据（主题、分区、副本、Leader 选举等），而 Broker 节点处理实际的消息流。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org/39/documentation.html#kraft_zk_migration&quot;&gt;官方文档：ZooKeeper到KRaft迁移&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 的安装：基于 KRaft 模式</title>
    <link href="https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/"/>
    <id>https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/</id>
    <published>2025-10-16T13:30:05.000Z</published>
    <updated>2025-10-19T02:48:43.911Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li><li class="lvl-2"><p>本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。</p></li></ul><span id="more"></span><h2 id="KRaft-简介">KRaft 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Kraft 是 Kafka 从 2.8.0 版本 开始⽀持的⼀种新的集群架构⽅式。其⽬的主要是为了摆脱Kafka对Zookeeper的依赖。因为以往基于Zookeeper搭建的集群，增加了Kafka演进与运维的难度，逐渐开始成为Kakfa拥抱云原⽣的⼀种障碍。使⽤Kraft集群后，Kafka集群就不再需要依赖Zookeeper，将之前基于Zookeeper管理的集群数据，转为由Kafka集群⾃⼰管理。</p></li><li class="lvl-2"><p>传统的Kafka集群，会将每个节点的状态信息统一保存在Zookeeper中，并通过Zookeeper动态选举产生一个Controller节点，通过Controller节点来管理Kafka集群，比如触发Partition的选举。而在Kraft集群中，会固定配置几台Broker节点来共同担任Controller的角色，各组Partition的Leader节点就会由这些Controller选举产生。原本保存在Zookeeper中的元数据也转而保存到Controller节点中。</p></li><li class="lvl-2"><p>🧭 Kafka KRaft 模式 vs Zookeeper 模式 对比表</p></li></ul><table><thead><tr><th style="text-align:left">对比项</th><th style="text-align:left"><strong>KRaft 模式（Kafka Raft 模式）</strong></th><th style="text-align:left"><strong>Zookeeper 模式（传统模式）</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>架构结构</strong></td><td style="text-align:left">去中心化架构，Kafka 自身内置控制平面，不依赖外部 Zookeeper。</td><td style="text-align:left">控制平面依赖外部 Zookeeper 集群，Kafka Broker 只负责数据平面。</td></tr><tr><td style="text-align:left"><strong>组件数量</strong></td><td style="text-align:left">无需部署 Zookeeper，只有 Kafka Broker 节点。</td><td style="text-align:left">需要单独维护 Zookeeper 集群。</td></tr><tr><td style="text-align:left"><strong>元数据存储</strong></td><td style="text-align:left">元数据存储在 Kafka 自身的内置日志中（<code>__cluster_metadata</code> topic）。</td><td style="text-align:left">元数据存储在 Zookeeper 的 znode 树结构中。</td></tr><tr><td style="text-align:left"><strong>一致性协议</strong></td><td style="text-align:left">使用 Kafka 自己实现的 Raft 协议（KRaft）来保证元数据一致性。</td><td style="text-align:left">使用 ZAB（Zookeeper Atomic Broadcast）协议保证一致性。</td></tr><tr><td style="text-align:left"><strong>启动速度</strong></td><td style="text-align:left">更快，控制器内嵌于 Broker 中，不需要等待外部 Zookeeper 启动。</td><td style="text-align:left">启动依赖 Zookeeper，启动顺序和连通性要求更严格。</td></tr><tr><td style="text-align:left"><strong>容错性</strong></td><td style="text-align:left">Raft 控制器具备日志复制机制，容错性与 Kafka 数据副本一致。</td><td style="text-align:left">容错性由 Zookeeper 决定，Zookeeper 挂掉可能导致 Kafka 控制面不可用。</td></tr><tr><td style="text-align:left"><strong>扩展性</strong></td><td style="text-align:left">元数据存储在 Kafka 主题中，水平扩展能力更强。</td><td style="text-align:left">Zookeeper 在高分区数场景下易成为性能瓶颈。</td></tr><tr><td style="text-align:left"><strong>运维复杂度</strong></td><td style="text-align:left">无需维护 Zookeeper 集群，统一运维 Kafka 即可。</td><td style="text-align:left">需要额外维护 Zookeeper 集群（监控、扩容、升级）。</td></tr><tr><td style="text-align:left"><strong>数据恢复</strong></td><td style="text-align:left">元数据恢复与 Kafka 主题一致，可通过日志回放恢复。</td><td style="text-align:left">Zookeeper 数据恢复相对复杂，依赖快照和事务日志。</td></tr><tr><td style="text-align:left"><strong>安全机制</strong></td><td style="text-align:left">统一 Kafka 的安全机制（SASL、SSL、ACL 等）。</td><td style="text-align:left">Zookeeper 有独立的安全配置体系，需单独管理。</td></tr><tr><td style="text-align:left"><strong>性能表现</strong></td><td style="text-align:left">元数据操作延迟更低（控制器与 Broker 本地通信）。</td><td style="text-align:left">元数据操作需要跨进程网络通信，延迟更高。</td></tr><tr><td style="text-align:left"><strong>控制器角色</strong></td><td style="text-align:left">由 Broker 中的控制器 quorum 选举产生（支持多控制器候选）。</td><td style="text-align:left">由 Zookeeper 选举控制器（单点控制器）。</td></tr><tr><td style="text-align:left"><strong>分区与副本管理</strong></td><td style="text-align:left">全部元数据存储在 Kafka 自身，可实现更快的分区变更和扩容。</td><td style="text-align:left">分区、副本元数据同步依赖 Zookeeper，性能相对较低。</td></tr><tr><td style="text-align:left"><strong>版本支持</strong></td><td style="text-align:left">从 Kafka 2.8 开始引入，Kafka 3.3+ 已经非常稳定，Kafka 3.5+ 默认推荐。</td><td style="text-align:left">Kafka 3.5 开始标记为“Legacy”，未来版本计划移除支持。</td></tr><tr><td style="text-align:left"><strong>兼容性</strong></td><td style="text-align:left">可通过元数据迁移工具从 Zookeeper 模式平滑迁移。</td><td style="text-align:left">不能直接迁移到 KRaft，需要工具辅助。</td></tr><tr><td style="text-align:left"><strong>运维监控</strong></td><td style="text-align:left">单一系统可监控（Kafka 自带的 JMX、Prometheus 等）。</td><td style="text-align:left">Kafka 与 Zookeeper 各自需要独立监控体系。</td></tr><tr><td style="text-align:left"><strong>未来发展方向</strong></td><td style="text-align:left">官方推荐和默认模式（Zookeeper 模式将逐步淘汰）。</td><td style="text-align:left">官方已不再建议新集群使用。</td></tr></tbody></table><h2 id="Kafka-的-KRaft-集群配置">Kafka 的 KRaft 集群配置</h2><ul class="lvl-0"><li class="lvl-2"><p>在Kafka的config目录下，提供了一个kraft的文件夹，在这里面提供了三个Kraft协议的参考配置文件</p><ul class="lvl-2"><li class="lvl-4">broker.properties: 数据节点，client连接时只连接broker数据节点</li><li class="lvl-4">controller.properties: Controller控制节点</li><li class="lvl-4">server.properties: 即可以是数据节点，又可以是Controller控制节点。</li></ul></li><li class="lvl-2"><p>实际上这些配置文件中的配置项基本与 serrver.properties 一致，只是去除了与 zookeeper 相关的配置项，同时增加了一些 Kraft 模式下的配置项。关于 server.properties 的配置项，请参考 <a href="https://kafka.apache.org/39/documentation/#brokerconfigs">Kafka 官方文档</a></p></li><li class="lvl-2"><p>这里以 <code>kraft/serrver.properties</code> 为例进行修改，配置三个节点的Kafka集群，每个节点即是 controller 节点，也可以是 broker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这四个配置项是 kraft 模式下新增加的</span></span><br><span class="line"><span class="comment"># 配置当前节点的角色。Controller相当于Zookeeper的功能，负责集群管理。Broker提供具体的消息转发服务。</span></span><br><span class="line"><span class="comment"># 一个节点可以即是 Controller 又是 Broker，也可以只是 Controller 或 Broker。</span></span><br><span class="line">process.roles=broker,controller</span><br><span class="line"><span class="comment"># 配置当前节点的id。与普通集群一样，要求集群内每个节点的ID不能重复。</span></span><br><span class="line">node.id=1</span><br><span class="line"><span class="comment"># 配置集群的投票节点。其中@前面的是节点的id，后面是节点的地址和端口，这个端口跟客户端访问的端口是不一样的，要与 CONTROLLER 协议对应的端口一致，这里配置为 9098</span></span><br><span class="line"><span class="comment"># 通常将集群内的所有Controllor节点都配置进去。</span></span><br><span class="line">controller.quorum.voters=1@worker1:9098,2@worker2:9098,3@worker3:9098</span><br><span class="line"><span class="comment"># Controller服务协议的别名。默认就是CONTROLLER</span></span><br><span class="line">controller.listener.names=CONTROLLER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下配置项与之前一样，按需进行配置即可</span></span><br><span class="line"><span class="comment"># 集群间通信仍使用内网</span></span><br><span class="line">inter.broker.listener.name=PLAINTEXT</span><br><span class="line"><span class="comment"># 配置监听服务。不同的服务可以绑定不同的接口。这种配置方式在端口前面是省略了一个主机IP的，主机IP默认是使用的java.net.InetAddress.getCanonicalHostName()，这里同时开启外网访问，关于 sasl_plaintext 、sasl_ssl协议 的配置方式参考前文 kafka 通信协议</span></span><br><span class="line">listeners=PLAINTEXT://:9092,CONTROLLER://:9098,EXTERNAL://0.0.0.0:9093</span><br><span class="line"><span class="comment"># Broker对客户端暴露的服务地址。基于PLAINTEXT协议。这里要替换为各个节点的IP地址</span></span><br><span class="line">advertised.listeners=PLAINTEXT://worker1:9092,CONTROLLER://worker1:9098,EXTERNAL://161.189.227.200:9093</span><br><span class="line"><span class="comment"># 将监听器名称映射到安全协议类型，这里 CONTROLLER 协议对应的安全协议类型为 PLAINTEXT</span></span><br><span class="line">listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,EXTERNAL:PLAINTEXT</span><br><span class="line"><span class="comment"># 数据文件地址。默认配置在/tmp目录下。</span></span><br><span class="line">log.dirs=/usr/local/kafka/dataDir/kraft-logs</span><br><span class="line"><span class="comment"># topic默认的partition分区数。</span></span><br><span class="line">num.partitions=2</span><br></pre></td></tr></table></figure><h2 id="启动Kafka集群">启动Kafka集群</h2><ul class="lvl-0"><li class="lvl-2"><p>启动前要对日志目录进行格式化</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在worker1节点上生成集群ID</span></span><br><span class="line">$ kafka-storage.sh random-uuid</span><br><span class="line">oGwJsVANRDKYwE7Lhn2zIA</span><br><span class="line"><span class="comment"># 然后在集群的每个节点上执行如下命令，格式化日志目录，注意 --cluster-id 必须一致</span></span><br><span class="line"><span class="comment"># 必须在第一次启动前执行</span></span><br><span class="line"><span class="comment"># 不可以重复执行，否则会清空数据目录并破坏已有元数据</span></span><br><span class="line"><span class="comment"># 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。</span></span><br><span class="line"><span class="comment"># 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</span></span><br><span class="line">$ kafka-storage.sh format --cluster-id oGwJsVANRDKYwE7Lhn2zIA --config /usr/local/kafka/kafka3/config/kraft/server.properties</span><br><span class="line"><span class="comment">## 格式化后会在日志目录下生成两个文件</span></span><br><span class="line"><span class="comment"># bootstrap.checkpoint # 存储元数据日志（Metadata Log）对应的初始快照偏移量（snapshot offset）。用于控制器在启动时恢复状态的起点。</span></span><br><span class="line"><span class="comment"># meta.properties # 存储节点元信息：cluster.id、node.id、version 等</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动集群，所以节点启动 kafka 服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/server.properties</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><ul class="lvl-0"><li class="lvl-2"><p>Kafka 集群的启动顺序不能乱，必须先启动 Controller 节点，再启动 Broker 节点，我们这里是将节点同时做为Controller 和 Broker ，实际生产环境建议分开。</p></li><li class="lvl-2"><p>Controller 节点至少3个，建议配置为奇数个。Broker 节点数量任意，但建议至少2个以上，以保证分区的备份可以分开存储。</p></li><li class="lvl-2"><p>Client 仅能与 Broker 节点通信，不能与 Controller 节点通信。</p></li></ul><h2 id="Kafka-4-0-的新特性">Kafka 4.0 的新特性</h2><ul class="lvl-0"><li class="lvl-2"><p>彻底以 KRaft（Kafka Raft）取代 ZooKeeper（KRaft 成为默认且唯一的元数据管理）</p><ul class="lvl-2"><li class="lvl-4">说明：4.x 系列标志性变化是完全移除 ZooKeeper，元数据由 KRaft 管理（Controller 与 Broker 更紧密集成）。对运维而言：不再部署/维护 ZooKeeper 集群、元数据迁移/格式化步骤是升级时的关键。</li><li class="lvl-4">影响/提示：必须按官方迁移流程把元数据从 ZK 导入 KRaft（若从旧版本升级）。测试迁移/备份元数据是必须项。</li></ul></li><li class="lvl-2"><p>新的 consumer-group 协议（更高效的 rebalance/群组管理）与消费模型改进（包括“Queues/Shared Group”支持）</p><ul class="lvl-2"><li class="lvl-4">说明：引入/稳定了新的 Consumer Group 协议（相关 KIP），显著改善大群组下的重平衡延迟与稳定性；同时引入了类似“队列/共享组（Queues for Kafka）”的消费模式（用例：点对点消费），允许多消费者同时处理同一分区消息。</li><li class="lvl-4">影响/提示：如果你有大规模消费者群组或依赖旧 rebalance 行为，需要测试新协议行为；某些客户端配置/行为可能需要调整。</li></ul></li></ul><table><thead><tr><th>指标类别</th><th>旧协议（Eager Rebalance）</th><th>新协议（Incremental / Cooperative Rebalance）</th></tr></thead><tbody><tr><td>重平衡延迟（大规模群组）</td><td>约 <strong>60 秒</strong>（万级消费者规模）</td><td>小于 <strong>1 秒</strong>（测试显示在千级任务时可在一分钟内完成） (<a href="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/?utm_source=chatgpt.com" title="Incremental Cooperative Rebalancing in Apache Kafka">Confluent</a>)</td></tr><tr><td>资源消耗（CPU）</td><td>较高（在重平衡期间系统停止或大规模迁移资源）</td><td>据称可降低约 <strong>70%</strong> 的 CPU／系统中断负荷（社区经验）</td></tr><tr><td>消费者群组扩展上限</td><td>适用于“千级消费者”规模</td><td>可扩展至“十万级消费者”规模（理论/社区宣称）</td></tr></tbody></table><table><thead><tr><th><strong>特性</strong></th><th><strong>传统消费者组（Consumer Group）</strong></th><th><strong>共享组（Shared Group / Queues for Kafka）</strong></th></tr></thead><tbody><tr><td><strong>并行消费模型</strong></td><td>分区数 = 消费者数（一个分区只能被一个消费者消费）</td><td>消费者数 &gt; 分区数（同一分区可由多个消费者并行处理）</td></tr><tr><td><strong>消息确认机制</strong></td><td>通过提交偏移量（Offset Commit）实现确认</td><td>每条消息单独确认（ACK/NACK 机制）</td></tr><tr><td><strong>投递语义</strong></td><td><strong>At-Least-Once</strong>（至少一次投递）</td><td><strong>Exactly-Once（可选）</strong>，支持精确一次处理</td></tr><tr><td><strong>典型场景</strong></td><td>流式日志、监控、顺序性要求高的场景</td><td>任务队列、并行计算、高吞吐任务处理</td></tr><tr><td><strong>实现方式</strong></td><td>基于 Topic-Partition 分配与偏移管理</td><td>基于共享队列模型，允许多消费者竞争消费同一分区</td></tr><tr><td><strong>Kafka 版本支持</strong></td><td>Kafka ≤ 3.x</td><td>Kafka 4.x 引入（KIP-932 “Queues for Kafka”）</td></tr><tr><td><strong>优势</strong></td><td>顺序保证强、模型成熟稳定</td><td>并行能力强、吞吐提升、支持精确一次语义</td></tr><tr><td><strong>劣势</strong></td><td>分区限制吞吐，扩展受限</td><td>顺序性可能减弱，实现更复杂</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>删除长期弃用的旧 API / 协议（向后不兼容的清理）</p><ul class="lvl-2"><li class="lvl-4">说明：4.x 移除了那些已弃用 ≥12 个月的接口/协议，旨在简化代码库并鼓励采用新功能。</li><li class="lvl-4">影响/提示：升级前务必检查你使用到的 Broker/Client/Streams/Connect API 是否依赖被移除的功能；测试客户端与第三方 Connector/插件兼容性。</li></ul></li><li class="lvl-2"><p>Java 运行环境最低版本更新：Clients/Streams 与 Broker/Tools 的 JDK 要求提高</p><ul class="lvl-2"><li class="lvl-4">说明：Kafka 4.x 将客户端（Kafka Clients、Kafka Streams）与 Broker/Connect/工具分别提出了更高的 Java baseline（Clients/Streams 最低 Java 11，Broker/Connect/Tools 最低 Java 17 等）。</li><li class="lvl-4">影响/提示：升级集群前先统一平台 JDK 版本，CI/CD/容器镜像也要对应更新。</li></ul></li><li class="lvl-2"><p>许多新的 KIP（功能增强）与性能/可观测性改进</p><ul class="lvl-2"><li class="lvl-4">说明：包含改进的 Streams rebalance、更多 Admin/运维命令、节点注册/列举能力、插件/指标扩展点等（多项 KIP 在 4.0/4.1 陆续落地）。这些改进覆盖 Broker、Controller、Producer、Consumer、Admin 和 Streams 子系统。</li><li class="lvl-4">影响/提示：运维与监控面板可能受益（新增可观测指标/API）；如果你有自定义插件或监控接入，需要检查新的插件/metrics 注册机制。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 的 常用命令</title>
    <link href="https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/"/>
    <id>https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/</id>
    <published>2025-10-15T12:30:05.000Z</published>
    <updated>2025-10-16T06:05:44.574Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Kafka 的 常用命令</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li><li class="lvl-2"><p><a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/kafka-3-demo">Java-Client 代码示例</a></p></li></ul><span id="more"></span><h2 id="topic">topic</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 topic</span></span><br><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --partitions 3 --replication-factor 2</span><br><span class="line"><span class="comment"># --bootstrap-server 指定 kafka 集群地址</span></span><br><span class="line"><span class="comment"># --topic 创建的 topic 名称</span></span><br><span class="line"><span class="comment"># --partitions 指定分区数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class="line"><span class="comment"># --replication-factor 指定副本数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 topic</span></span><br><span class="line">kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class="line"><span class="comment"># 查看 topic 详情</span></span><br><span class="line">kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Topic: <span class="built_in">test</span>TopicId: Ru0tWQJ4RMWcjjGsKAdWQgPartitionCount: 3ReplicationFactor: 3Configs:</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 0Leader: 3Replicas: 3,1,2Isr: 3,2,1Elr: N/ALastKnownElr: N/A</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 1Leader: 1Replicas: 1,2,3Isr: 3,2,1Elr: N/ALastKnownElr: N/A</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 2Leader: 2Replicas: 2,3,1Isr: 3,2,1Elr: N/ALastKnownElr: N/A</span><br><span class="line"><span class="comment">## 输出说明</span></span><br><span class="line"><span class="comment"># 总体信息（Topic 概览）Topic: testTopicId: Ru0tWQJ4RMWcjjGsKAdWQgPartitionCount: 3ReplicationFactor: 3Configs:</span></span><br><span class="line">| 字段                                  | 含义                                                            |</span><br><span class="line">| ----------------------------------- | ------------------------------------------------------------- |</span><br><span class="line">| **Topic: disTopic**                 | Topic 名称，即当前描述的主题。                                            |</span><br><span class="line">| **TopicId: VUK7Mc9oQdS1mjGG7OhQzQ** | Kafka 内部自动生成的唯一标识符（UUID），Kafka 3.x 之后引入，用于区分同名但不同生命周期的 topic。 |</span><br><span class="line">| **PartitionCount: 3**               | 该主题有 3 个分区（partition）。每个分区存储一部分消息。                            |</span><br><span class="line">| **ReplicationFactor:**              | 副本因子。这里虽然输出中没显示具体值，但可从每行分区配置推断是 **3**（每个分区有 3 个副本）。           |</span><br><span class="line">| **Configs:**                        | topic 的配置项（例如清理策略、压缩类型等），如果为空，说明使用默认配置。                       |</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分区详情（每个 Partition 一行）</span></span><br><span class="line"></span><br><span class="line">| 字段                                | 含义                                                          |</span><br><span class="line">| --------------------------------- | ----------------------------------------------------------- |</span><br><span class="line">| **Partition: 0**                  | 第 0 号分区。                                                    |</span><br><span class="line">| **Leader: 2**                     | 该分区当前的 **Leader Broker 是 broker ID = 2**，只有 Leader 才处理读写请求。 |</span><br><span class="line">| **Replicas: 2,3,1**               | 该分区的所有副本存放在哪些 Broker 上（即副本分布,AR），分别是 broker 2、3、1。             |</span><br><span class="line">| **Isr (In-Sync Replicas): 2,3,1** | 当前与 Leader 保持同步的副本集合。这里所有副本都在同步中（健康状态 👍）。                  |</span><br><span class="line">| **Elr / LastKnownElr**            | Kafka 新版本中引入的 <span class="string">&quot;Enhanced Leader Replica&quot;</span> 状态，目前未启用（N/A）。      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 topic</span></span><br><span class="line">kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="consumer">consumer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 consumer</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --group <span class="built_in">test</span></span><br><span class="line"><span class="comment"># --topic 指定 topic</span></span><br><span class="line"><span class="comment"># --group 指定 consumer 组</span></span><br><span class="line"></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span>  --from-beginning</span><br><span class="line"><span class="comment"># --from-beginning 从 topic 的最开始消费</span></span><br></pre></td></tr></table></figure><h2 id="consumer-group">consumer-group</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 consumer 组</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class="line"><span class="comment"># --bootstrap-server 集群地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 consumer 组详情</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group <span class="built_in">test</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">GROUP  TOPIC  PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG  CONSUMER-ID                                             HOST         CLIENT-ID</span><br><span class="line"><span class="built_in">test</span>   <span class="built_in">test</span>   0          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class="line"><span class="built_in">test</span>   <span class="built_in">test</span>   1          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class="line"><span class="built_in">test</span>   <span class="built_in">test</span>   2          1               1               0    console-consumer-9ac45b29-d8f3-4649-ab09-7b567aa2ba53  /10.250.0.108 console-consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出说明</span></span><br><span class="line"><span class="comment"># GROUP       消费组名称</span></span><br><span class="line"><span class="comment"># TOPIC       topic 名称</span></span><br><span class="line"><span class="comment"># PARTITION   分区编号</span></span><br><span class="line"><span class="comment"># CURRENT-OFFSET  当前消费的 offset</span></span><br><span class="line"><span class="comment"># LOG-END-OFFSET   topic 中最大的 offset</span></span><br><span class="line"><span class="comment"># LAG         当前消费的 offset 与 topic 中最大的 offset 的差值，即剩余未消费的 消息数量</span></span><br><span class="line"><span class="comment"># CONSUMER-ID  当前消费的 consumer 的 id</span></span><br><span class="line"><span class="comment"># HOST        当前消费的 consumer 的主机名</span></span><br><span class="line"><span class="comment"># CLIENT-ID   当前消费的 consumer 的客户端名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 consumer 组</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="producer">producer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 producer</span></span><br><span class="line">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># --topic 指定 topic</span></span><br></pre></td></tr></table></figure><h2 id="手动触发-Kafka-Partitoin-的-Leader-选举-自平衡">手动触发 Kafka Partitoin 的 Leader 选举(自平衡)</h2><ul class="lvl-0"><li class="lvl-2"><p>kafka的自平衡默认开启，每隔 300秒扫描一次，如果需要平衡的比例高于 10%，则会触发一次</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启自动平衡</span></span><br><span class="line">auto.leader.rebalance.enable=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 间隔扫描时间 默认 300 秒</span></span><br><span class="line">eader.imbalance.check.interval.seconds=300</span><br><span class="line"><span class="comment"># 触发比例，即扫描的 broker 上需要平衡的 partition 占当前 broker 全部 partition 的比例，默认 10%</span></span><br><span class="line">leader.imbalance.per.broker.percentage=10</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>建议关闭，改为业务低峰时手动触发</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动平衡</span></span><br><span class="line">kafka-leader-election.sh --bootstrap-server localhost:9092  --election-type preferred --topic <span class="built_in">test</span> --partition 0</span><br><span class="line"><span class="comment"># --topic 指定要触发的 topic</span></span><br><span class="line"><span class="comment"># --partition 0 触发 partition 0 的 leader 选举</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>🧩 参数说明：–election-type</p></li></ul><table><thead><tr><th>参数值</th><th>含义</th><th>触发条件</th><th>典型使用场景</th></tr></thead><tbody><tr><td><strong><code>preferred</code></strong></td><td><strong>首选 Leader 选举</strong>（Preferred Leader Election）<br>Kafka 会尝试将分区的 leader 重新切换为「首选副本」（通常是第一个副本）。</td><td>只有当前 leader <strong>不是</strong> 首选副本时才执行。</td><td>某些副本被自动选举成 leader 后，希望恢复原有「首选 leader」结构，以实现负载均衡。</td></tr><tr><td><strong><code>unclean</code></strong></td><td><strong>非干净 Leader 选举</strong>（Unclean Leader Election）<br>允许从不同步的副本中选举新的 leader。</td><td>仅在分区 <strong>没有可用 leader</strong> 时执行。</td><td>在紧急恢复场景下（比如所有 ISR 副本都下线），为了恢复服务可用性，即使会导致数据丢失。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Leader Partition⾃动平衡机制</p><ul class="lvl-2"><li class="lvl-6">Leader Partitoin选举机制能够保证每⼀个Partition同⼀时刻有且仅有⼀个Leader Partition。但是，是不是只要分配好了Leader Partition就够了呢？</li><li class="lvl-6">在⼀组Partiton中，Leader Partition通常是⽐较繁忙的节点，因为他要负责与客户端的数据交互，以及向Follower同步数据。默认情况下，Kafka会尽量将Leader Partition分配到不同的Broker节点上，⽤以保证整个集群的性能压⼒能够⽐较平均。</li><li class="lvl-6">但是，经过Leader Partition选举后，这种平衡就有可能会被打破，让Leader Partition过多的集中到同⼀个Broker上。这样，这个Broker的压⼒就会明显⾼于其他Broker，从⽽影响到集群的整体性能。</li><li class="lvl-6">为此，Kafka设计了Leader Partition⾃动平衡机制，当发现Leader分配不均衡时，⾃动进⾏Leader Partition调整。</li><li class="lvl-6">Kafka在进⾏Leader Partition⾃平衡时的逻辑是这样的：他会认为AR(Replicas副本集)当中的第⼀个节点就应该是Leader节点。这种选举结果成为preferred election 理想选举结果。</li><li class="lvl-6">Controller会定期检测集群的Partition平衡情况，在开始检测时，Controller会依次检查所有的Broker。当发现这个Broker上的不平衡的Partition⽐例⾼于<code>leader.imbalance.per.broker.percentage</code>阈值时，就会触发⼀次Leader Partiton的⾃平衡。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Kafka 的 常用命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/kafka-3-demo&quot;&gt;Java-Client 代码示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 的 server.properties 配置项</title>
    <link href="https://blog.hanqunfeng.com/2025/10/14/kafka-01-server-config/"/>
    <id>https://blog.hanqunfeng.com/2025/10/14/kafka-01-server-config/</id>
    <published>2025-10-14T13:30:05.000Z</published>
    <updated>2025-10-18T12:00:31.595Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 CentOS9 中 Kafka 的 server.properties 的配置项，基于 Zookeeper。</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li></ul><span id="more"></span><h2 id="Kafka-3-x-server-properties-主要配置项清单">Kafka 3.x server.properties 主要配置项清单</h2><ul class="lvl-0"><li class="lvl-2"><p>关于 server.properties 的配置项，请参考 <a href="https://kafka.apache.org/39/documentation/#brokerconfigs">Kafka 官方文档</a></p></li></ul><table><thead><tr><th>分类</th><th>参数名</th><th>默认值</th><th>说明</th><th>推荐/备注</th></tr></thead><tbody><tr><td>🗂️ <strong>基本信息</strong></td><td><code>broker.id</code></td><td>0</td><td>Broker 唯一标识</td><td>集群中必须唯一</td></tr><tr><td></td><td><code>node.id</code></td><td>-</td><td>Raft 模式（KRaft）下使用</td><td>ZK 模式忽略</td></tr><tr><td></td><td><code>process.roles</code></td><td>-</td><td>KRaft 模式角色（controller, broker）</td><td>ZK 模式不配置</td></tr><tr><td>🔌 <strong>网络与监听配置</strong></td><td><code>listeners</code></td><td>PLAINTEXT://:9092</td><td>Broker 监听地址</td><td>可用多个协议，如 SASL_PLAINTEXT, SSL</td></tr><tr><td></td><td><code>advertised.listeners</code></td><td>-</td><td>客户端连接时看到的地址</td><td>外网访问需配置</td></tr><tr><td></td><td><code>listener.security.protocol.map</code></td><td>PLAINTEXT:PLAINTEXT</td><td>映射监听器协议</td><td>多协议时配置</td></tr><tr><td></td><td><code>inter.broker.listener.name</code></td><td>-（Kafka 2.4+ 默认第一个 listener）</td><td>指定 broker 间通信使用哪个 listener（如 INTERNAL）</td><td>集群内部通信必须一致；常配合多 listener 使用</td></tr><tr><td></td><td><code>num.network.threads</code></td><td>3</td><td>网络线程数</td><td>一般不需修改</td></tr><tr><td></td><td><code>num.io.threads</code></td><td>8</td><td>处理请求的 IO 线程数</td><td>根据 CPU 调整</td></tr><tr><td></td><td><code>socket.send.buffer.bytes</code></td><td>102400</td><td>发送缓冲区大小</td><td>网络优化参数</td></tr><tr><td></td><td><code>socket.receive.buffer.bytes</code></td><td>102400</td><td>接收缓冲区大小</td><td>网络优化参数</td></tr><tr><td></td><td><code>socket.request.max.bytes</code></td><td>104857600</td><td>单请求最大大小 (100MB)</td><td>大消息需调大</td></tr><tr><td>⚙️ <strong>集群与元数据</strong></td><td><code>log.dirs</code></td><td>/tmp/kafka-logs</td><td>数据存储路径</td><td>多目录可提升性能</td></tr><tr><td></td><td><code>num.recovery.threads.per.data.dir</code></td><td>1</td><td>每个数据目录的恢复线程数</td><td>多磁盘时可增加</td></tr><tr><td></td><td><code>auto.create.topics.enable</code></td><td>true</td><td>是否允许自动创建 Topic</td><td>生产建议禁用</td></tr><tr><td></td><td><code>controlled.shutdown.enable</code></td><td>true</td><td>优雅关闭 Broker</td><td>建议开启</td></tr><tr><td></td><td><code>delete.topic.enable</code></td><td>true</td><td>是否允许删除 Topic</td><td>生产慎用</td></tr><tr><td></td><td><code>auto.leader.rebalance.enable</code></td><td>true</td><td>是否自动均衡 Leader</td><td>建议开启</td></tr><tr><td></td><td><code>leader.imbalance.check.interval.seconds</code></td><td>300</td><td>检查 leader 失衡间隔</td><td>与上配合使用</td></tr><tr><td></td><td><code>leader.imbalance.per.broker.percentage</code></td><td>10</td><td>触发 leader 重平衡的阈值</td><td>默认即可</td></tr><tr><td>🧱 <strong>副本与复制机制</strong></td><td><code>default.replication.factor</code></td><td>1</td><td>新 Topic 默认副本数</td><td>生产建议 3</td></tr><tr><td></td><td><code>offsets.topic.replication.factor</code></td><td>1</td><td>消费组偏移主题副本数</td><td>建议 3</td></tr><tr><td></td><td><code>transaction.state.log.replication.factor</code></td><td>1</td><td>事务状态主题副本数</td><td>建议 3</td></tr><tr><td></td><td><code>transaction.state.log.min.isr</code></td><td>1</td><td>事务状态日志最小 ISR 数</td><td>建议 2</td></tr><tr><td></td><td><code>min.insync.replicas</code></td><td>1</td><td>Leader 写入时要求的最小 ISR 副本数</td><td>建议 <code>replication.factor - 1</code></td></tr><tr><td></td><td><code>unclean.leader.election.enable</code></td><td>false</td><td>是否允许非同步副本选为 leader</td><td>生产建议 false</td></tr><tr><td></td><td><code>num.replica.fetchers</code></td><td>1</td><td>follower 拉取线程数</td><td>可提升复制性能</td></tr><tr><td></td><td><code>replica.fetch.max.bytes</code></td><td>1048576 (1MB)</td><td>follower 拉取单分区最大数据量</td><td>增大可提速</td></tr><tr><td></td><td><code>replica.fetch.response.max.bytes</code></td><td>10485760 (10MB)</td><td>follower 一次拉取响应总量</td><td>可调大</td></tr><tr><td></td><td><code>replica.fetch.wait.max.ms</code></td><td>500</td><td>follower 等待新数据的最大时长</td><td>延迟与吞吐折中</td></tr><tr><td></td><td><code>replica.fetch.backoff.ms</code></td><td>1000</td><td>拉取失败后退避时间</td><td>网络不稳时调整</td></tr><tr><td></td><td><code>replica.socket.timeout.ms</code></td><td>30000</td><td>follower 与 leader 通信超时</td><td>≥ <a href="http://fetch.wait.ms">fetch.wait.ms</a></td></tr><tr><td></td><td><code>replica.socket.receive.buffer.bytes</code></td><td>65536</td><td>拉取 socket 缓冲区</td><td>调大可提速</td></tr><tr><td></td><td><code>replica.lag.time.max.ms</code></td><td>10000</td><td>follower 落后 leader 的最大时间</td><td>影响 ISR</td></tr><tr><td></td><td><code>replica.high.watermark.checkpoint.interval.ms</code></td><td>5000</td><td>高水位写入 checkpoint 周期</td><td>影响恢复速度</td></tr><tr><td></td><td><code>replica.selector.class</code></td><td>-</td><td>自定义副本选择类</td><td>一般保持默认</td></tr><tr><td>🧮 <strong>日志与段文件</strong></td><td><code>log.segment.bytes</code></td><td>1073741824 (1GB)</td><td>单日志段文件大小</td><td>调小便于删除</td></tr><tr><td></td><td><code>log.segment.ms</code></td><td>604800000 (7天)</td><td>强制滚动日志的时间</td><td>适用于时间控制</td></tr><tr><td></td><td><code>log.retention.hours</code></td><td>168</td><td>日志保留时间（小时）</td><td>与磁盘空间相关</td></tr><tr><td></td><td><code>log.retention.bytes</code></td><td>-1</td><td>日志总大小限制</td><td>-1 表示不限制</td></tr><tr><td></td><td><code>log.retention.check.interval.ms</code></td><td>300000</td><td>检查日志保留策略间隔</td><td>默认即可</td></tr><tr><td></td><td><code>log.cleaner.enable</code></td><td>true</td><td>是否启用日志压缩</td><td>compact 主题需启用</td></tr><tr><td></td><td><code>log.cleaner.threads</code></td><td>1</td><td>清理线程数</td><td>大集群可增加</td></tr><tr><td></td><td><code>log.cleaner.io.max.bytes.per.second</code></td><td>None</td><td>限制清理 IO 带宽</td><td>控制磁盘负载</td></tr><tr><td></td><td><code>log.flush.interval.messages</code></td><td>Long.MAX_VALUE</td><td>累计消息数达到后强制 flush</td><td>通常保持默认</td></tr><tr><td></td><td><code>log.flush.interval.ms</code></td><td>None</td><td>每隔多久强制 flush</td><td>SSD 可调大</td></tr><tr><td></td><td><code>num.partitions</code></td><td>1</td><td>新 Topic 默认分区数</td><td>通常 3~6 起步</td></tr><tr><td>🧵 <strong>生产与消费相关</strong></td><td><code>message.max.bytes</code></td><td>1048576</td><td>允许的最大消息大小</td><td>与 Producer <code>max.request.size</code> 对齐</td></tr><tr><td></td><td><code>replica.fetch.max.bytes</code></td><td>1048576</td><td>与 Producer/Consumer 对应的限制</td><td>防止大消息卡死</td></tr><tr><td></td><td><code>compression.type</code></td><td>producer</td><td>压缩算法（none, gzip, snappy, lz4, zstd）</td><td>建议 zstd</td></tr><tr><td></td><td><code>queued.max.requests</code></td><td>500</td><td>Broker 最大排队请求数</td><td>默认即可</td></tr><tr><td>🛠️ <strong>控制器与协调器</strong></td><td><code>controller.socket.timeout.ms</code></td><td>30000</td><td>控制器通信超时</td><td>默认即可</td></tr><tr><td></td><td><code>controller.quorum.voters</code></td><td>-</td><td>KRaft 模式选举成员</td><td>ZK 模式不需</td></tr><tr><td></td><td><code>controller.listener.names</code></td><td>-</td><td>控制器监听名</td><td>ZK 模式忽略</td></tr><tr><td>📈 <strong>监控与指标</strong></td><td><code>metric.reporters</code></td><td>空</td><td>指标上报类</td><td>可接 Prometheus</td></tr><tr><td></td><td><code>metrics.num.samples</code></td><td>2</td><td>指标采样数</td><td>默认即可</td></tr><tr><td></td><td><code>metrics.sample.window.ms</code></td><td>30000</td><td>指标采样窗口</td><td>默认即可</td></tr><tr><td></td><td><code>replica.fetchers.metrics.enabled</code></td><td>true</td><td>是否启用副本拉取指标</td><td>Kafka 3.x 新增</td></tr><tr><td>🔒 <strong>安全</strong></td><td><code>authorizer.class.name</code></td><td>空</td><td>授权类实现</td><td>开启 ACL 时配置</td></tr><tr><td></td><td><code>super.users</code></td><td>空</td><td>超级用户列表</td><td>ACL 模式下配置</td></tr><tr><td></td><td><code>ssl.keystore.location</code></td><td>-</td><td>SSL 证书路径</td><td>启用 SSL 时使用</td></tr><tr><td></td><td><code>ssl.truststore.location</code></td><td>-</td><td>信任证书路径</td><td>启用 SSL 时使用</td></tr></tbody></table><h2 id="参数使用建议总结">参数使用建议总结</h2><table><thead><tr><th>场景</th><th>推荐配置</th></tr></thead><tbody><tr><td><strong>高可靠性集群</strong></td><td><code>default.replication.factor=3</code>, <code>min.insync.replicas=2</code>, <code>unclean.leader.election.enable=false</code></td></tr><tr><td><strong>吞吐优先</strong></td><td>提高 <code>num.replica.fetchers</code>、<code>replica.fetch.max.bytes</code></td></tr><tr><td><strong>快速恢复</strong></td><td>减少 <code>replica.high.watermark.checkpoint.interval.ms</code></td></tr><tr><td><strong>节省磁盘</strong></td><td>启用 <code>log.cleaner.enable</code> 并设置 <code>log.retention.hours</code></td></tr><tr><td><strong>事务或精确一次语义</strong></td><td>设置 <code>transaction.state.log.replication.factor=3</code>、<code>transaction.state.log.min.isr=2</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 CentOS9 中 Kafka 的 server.properties 的配置项，基于 Zookeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 的 Web UI 之 Kafbat UI</title>
    <link href="https://blog.hanqunfeng.com/2025/10/13/kafka-03-webui/"/>
    <id>https://blog.hanqunfeng.com/2025/10/13/kafka-03-webui/</id>
    <published>2025-10-13T15:30:05.000Z</published>
    <updated>2025-10-18T12:19:42.683Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Kafka 的 Web UI 之 Kafbat UI</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li><li class="lvl-2"><p><a href="https://kafbat.io">Kafbat UI 官网</a>，<a href="https://github.com/kafbat/kafka-ui">Kafbat UI Github</a>，<a href="https://ui.docs.kafbat.io">Kafbat UI 文档</a>，Kafbat UI 支持 Docker 和 Jar 包两种方式运行，支持同时连接多个 Kafka 集群。</p></li><li class="lvl-2"><p>与 Kafbat UI 类似的 Kafka Web UI 还有一个 <a href="https://github.com/obsidiandynamics/kafdrop">kafdrop</a>，同样支持 Docker 和 Jar 包两种方式运行，只不过其仅支持单个 Kafka 集群，感兴趣的可以自己体验。</p></li></ul><span id="more"></span><h2 id="Kafbat-UI-简介">Kafbat UI 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Kafbat UI 是一个免费的开源 Web 用户界面，用于监控和管理 Apache Kafka 集群。</p></li><li class="lvl-2"><p>Kafbat UI 是一个简单的工具，使您的数据流变得可观察，帮助更快地发现和排除问题，并提供最佳性能。其轻量级的仪表盘使您能够轻松跟踪 Kafka 集群的关键指标: 包括 Brokers、Topics、Partitions、生产和消费情况。</p></li></ul><h2 id="运行-Kafbat-UI">运行 Kafbat UI</h2><h3 id="Docker-运行">Docker 运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 \</span><br><span class="line">    --name kafka-ui \</span><br><span class="line">    -e KAFKA_CLUSTERS_0_NAME=kafka_c01 \</span><br><span class="line">    -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=localhost:9092 \</span><br><span class="line">    -e TZ=Asia/Shanghai \</span><br><span class="line">    -d ghcr.io/kafbat/kafka-ui:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Jar-运行">Jar 运行</h3><ul class="lvl-0"><li class="lvl-2"><p>从<a href="https://github.com/kafbat/kafka-ui/releases">Github</a>上下载最新版jar包，要求 <code>jdk 21+</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /Users/hanqf/myservice_dir/kafka_webui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置kafka集群，可以同时配置多个，序号从0开始依次递增</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_NAME=kafka_c01</span><br><span class="line"><span class="comment"># =============================================================================================================</span></span><br><span class="line"><span class="comment"># 外网PLAINTEXT访问</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093</span></span><br><span class="line"><span class="comment"># =============================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================================================================================</span></span><br><span class="line"><span class="comment"># 外网SASL_PLAINTEXT访问</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9094,68.79.13.235:9094,43.192.84.195:9094</span></span><br><span class="line"><span class="comment"># # SASL_PLAINTEXT认证配置</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_PLAINTEXT</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAIN</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;</span></span><br><span class="line"><span class="comment"># =============================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================================================================================</span></span><br><span class="line"><span class="comment"># 外网SASL_SSL访问</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9095,68.79.13.235:9095,43.192.84.195:9095</span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_SSL</span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAIN</span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=<span class="string">&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;</span></span><br><span class="line"><span class="comment"># SSL配置</span></span><br><span class="line"><span class="comment"># JKS 格式证书</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_PASSWORD=123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># PEM 格式证书</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crt</span></span><br><span class="line"><span class="comment"># export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_TYPE=PEM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用主机名验证</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ============================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个集群配置示例</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_1_NAME=kafka_c02</span><br><span class="line"><span class="built_in">export</span> KAFKA_CLUSTERS_1_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line"><span class="built_in">export</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 语言</span></span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># webui访问路径</span></span><br><span class="line"><span class="built_in">export</span> SERVER_SERVLET_CONTEXT_PATH=/</span><br><span class="line"><span class="comment"># 认证方式，支持NONE(无认证)，LOGIN_FORM(登录表单认证)</span></span><br><span class="line"><span class="built_in">export</span> AUTH_TYPE=LOGIN_FORM</span><br><span class="line"><span class="comment"># webui认证用户名密码</span></span><br><span class="line"><span class="built_in">export</span> SPRING_SECURITY_USER_NAME=admin</span><br><span class="line"><span class="built_in">export</span> SPRING_SECURITY_USER_PASSWORD=admin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m&quot;</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">/Users/hanqf/develop_soft/jdk21/bin/java --add-opens java.rmi/javax.rmi.ssl=ALL-UNNAMED  <span class="variable">$JAVA_OPTS</span> -jar api-v1.3.0.jar</span><br></pre></td></tr></table></figure><h2 id="访问-Kafbat-UI">访问 Kafbat UI</h2><ul class="lvl-0"><li class="lvl-2"><p>访问 <a href="http://localhost:8080">http://localhost:8080</a><br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/ykd6F4.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Kafka 的 Web UI 之 Kafbat UI&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafbat.io&quot;&gt;Kafbat UI 官网&lt;/a&gt;，&lt;a href=&quot;https://github.com/kafbat/kafka-ui&quot;&gt;Kafbat UI Github&lt;/a&gt;，&lt;a href=&quot;https://ui.docs.kafbat.io&quot;&gt;Kafbat UI 文档&lt;/a&gt;，Kafbat UI 支持 Docker 和 Jar 包两种方式运行，支持同时连接多个 Kafka 集群。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;与 Kafbat UI 类似的 Kafka Web UI 还有一个 &lt;a href=&quot;https://github.com/obsidiandynamics/kafdrop&quot;&gt;kafdrop&lt;/a&gt;，同样支持 Docker 和 Jar 包两种方式运行，只不过其仅支持单个 Kafka 集群，感兴趣的可以自己体验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 通信协议、SSL加密和身份验证</title>
    <link href="https://blog.hanqunfeng.com/2025/10/13/kafka-02-protocol/"/>
    <id>https://blog.hanqunfeng.com/2025/10/13/kafka-02-protocol/</id>
    <published>2025-10-13T14:30:05.000Z</published>
    <updated>2025-10-16T08:58:11.618Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Kafka 的 通信协议，以及如何开启外网访问。</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li></ul><span id="more"></span><h2 id="Kafka-的-通信协议">Kafka 的 通信协议</h2><ul class="lvl-0"><li class="lvl-2"><p>Kafka 主要支持四种安全协议</p></li></ul><table><thead><tr><th>协议名称</th><th>加密</th><th>认证</th><th>说明</th><th>推荐场景</th><th>理由</th></tr></thead><tbody><tr><td><strong>PLAINTEXT</strong></td><td>❌ 否</td><td>❌ 否</td><td>无加密、无认证（默认最简单）</td><td>开发 / 测试环境、内网集群通信</td><td>简单、易调试；网络可信，性能优先</td></tr><tr><td><strong>SSL</strong></td><td>✅ 是</td><td>✅ 可选</td><td>使用 TLS/SSL 加密通信，可配置客户端证书认证</td><td>外网客户端访问</td><td>支持数据加密，可选认证，保证安全</td></tr><tr><td><strong>SASL_PLAINTEXT</strong></td><td>❌ 否</td><td>✅ 是</td><td>使用 SASL（用户名密码）认证，但不加密数据</td><td>需要用户认证但局域网环境</td><td>有认证，但不加密，性能开销低</td></tr><tr><td><strong>SASL_SSL</strong></td><td>✅ 是</td><td>✅ 是</td><td>同时支持 SASL 认证和 SSL 加密（最安全）</td><td>外网客户端访问</td><td>既有认证又加密，安全性最高</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>在 <code>config/server.properties</code> 文件中 可以看到如下配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 套接字服务器监听的地址。</span></span><br><span class="line"><span class="comment"># 如果未配置，则主机名默认等于 `java.net.InetAddress.getCanonicalHostName()` 的返回值，</span></span><br><span class="line"><span class="comment"># 使用监听器名称 `PLAINTEXT`，端口号为 9092。</span></span><br><span class="line"><span class="comment">#   格式：</span></span><br><span class="line"><span class="comment">#     listeners = listener_name://host_name:port</span></span><br><span class="line"><span class="comment">#   示例：</span></span><br><span class="line"><span class="comment">#     listeners = PLAINTEXT://your.host.name:9092</span></span><br><span class="line"><span class="comment">#listeners=PLAINTEXT://:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 向客户端“通告”的监听器名称、主机名和端口。</span></span><br><span class="line"><span class="comment"># 客户端实际会连接这个地址，而不是直接使用 listeners 的地址。</span></span><br><span class="line"><span class="comment"># 如果未设置，则默认使用 `listeners` 的值。</span></span><br><span class="line"><span class="comment">#advertised.listeners=PLAINTEXT://your.host.name:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将监听器名称映射到安全协议类型。</span></span><br><span class="line"><span class="comment"># 默认情况下，监听器名称与安全协议同名。</span></span><br><span class="line"><span class="comment"># 例如：PLAINTEXT→PLAINTEXT、SSL→SSL、SASL_PLAINTEXT→SASL_PLAINTEXT、SASL_SSL→SASL_SSL。</span></span><br><span class="line"><span class="comment"># 更多细节可参考 Kafka 官方配置文档。</span></span><br><span class="line"><span class="comment">#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>作用</th><th>说明值</th></tr></thead><tbody><tr><td><code>listeners</code></td><td>Kafka 实际监听的地址（Broker 对外开放的端口）</td><td><code>PLAINTEXT://:9092</code>这里 PLAINTEXT 是监听器名称，并不是协议名称，实际上可以配置为任何值，具体协议是通过 <code>listener.security.protocol.map</code> 配置的映射关系来确定。</td></tr><tr><td><code>advertised.listeners</code></td><td>Kafka 告诉客户端应该用哪个地址连接（客户端最终连的）</td><td>默认使用 <code>listeners</code> 的值</td></tr><tr><td><code>listener.security.protocol.map</code></td><td>映射监听器名称到通信安全协议（如明文、SSL、SASL 等）</td><td><code>PLAINTEXT:PLAINTEXT</code>，前面是监听器名称，后面是协议名称</td></tr></tbody></table><h2 id="仅需内网访问">仅需内网访问</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listeners=PLAINTEXT://0.0.0.0:9092</span><br><span class="line">advertised.listeners=PLAINTEXT://worker1:9092 <span class="comment"># 这里是内网ip</span></span><br></pre></td></tr></table></figure><h2 id="允许外网访问">允许外网访问</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listeners=PLAINTEXT://0.0.0.0:9092</span><br><span class="line">advertised.listeners=PLAINTEXT://161.189.227.200:9092 <span class="comment"># 这里是外网ip</span></span><br></pre></td></tr></table></figure><h2 id="内外网都要访问（推荐双通道方式）">内外网都要访问（推荐双通道方式）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里 INTERNAL 和 EXTERNAL 分别是自定义的监听器名称，此时内网端口为 9092，外网端口为 9093</span></span><br><span class="line">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093</span><br><span class="line"><span class="comment"># 告诉客户端应该用哪个地址连接</span></span><br><span class="line">advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9093</span><br><span class="line"><span class="comment"># 映射监听器名称到通信安全协议的映射关系</span></span><br><span class="line">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT</span><br><span class="line"><span class="comment"># 集群间通信仍使用内网</span></span><br><span class="line">inter.broker.listener.name=INTERNAL</span><br></pre></td></tr></table></figure><h2 id="开启-SASL-PLAINTEXT">开启 SASL_PLAINTEXT</h2><ul class="lvl-0"><li class="lvl-2"><p>这里设置外网访问时开启 SASL_PLAINTEXT</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class="line">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9094</span><br><span class="line"><span class="comment"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class="line">advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9094</span><br><span class="line">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_PLAINTEXT</span><br><span class="line"><span class="comment"># 集群间通信 still use INTERNAL</span></span><br><span class="line">inter.broker.listener.name=INTERNAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）</span></span><br><span class="line"><span class="comment"># client 连接时</span></span><br><span class="line">sasl.enabled.mechanisms=PLAIN</span><br><span class="line"><span class="comment"># broker 之间连接时，因为 inter.broker.listener.name=INTERNAL，所以 INTERNAL:SASL_PLAINTEXT 才有效</span></span><br><span class="line"><span class="comment">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建 kafka_jaas.conf</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment"># Kafka Broker (服务端)</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line">KafkaServer &#123;</span><br><span class="line">    <span class="comment"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    <span class="comment"># Broker 自己的身份（用于 broker 之间通信，本示例中没有使用）</span></span><br><span class="line">    username=<span class="string">&quot;admin&quot;</span></span><br><span class="line">    password=<span class="string">&quot;admin-secret&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户端可用账号，即 user_xxx，这里 xxx 为用户名，= 右边的为密码</span></span><br><span class="line">    user_admin=<span class="string">&quot;admin-secret&quot;</span></span><br><span class="line">    user_alice=<span class="string">&quot;alice-secret&quot;</span></span><br><span class="line">    user_bob=<span class="string">&quot;bob-secret&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 kafka</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在启动 Kafka Broker 前，设置环境变量指向 JAAS 文件</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_OPTS=<span class="string">&quot;-Djava.security.auth.login.config=/usr/local/kafka/kafka3/config/kafka_jaas.conf&quot;</span></span><br><span class="line">kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><h3 id="客户端访问">客户端访问</h3><ul class="lvl-0"><li class="lvl-2"><p>创建 client.conf</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security.protocol=SASL_PLAINTEXT</span><br><span class="line"><span class="comment"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class="line">sasl.mechanism=PLAIN</span><br><span class="line"><span class="comment"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class="line">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class="string">&quot;admin&quot;</span> password=<span class="string">&quot;admin-secret&quot;</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>命令行访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建topic</span></span><br><span class="line">kafka-topics.sh --create --topic test-topic --bootstrap-server=161.189.227.200:9094 --command-config=client.conf</span><br><span class="line"><span class="comment"># 查看topic</span></span><br><span class="line">kafka-topics.sh --list --bootstrap-server=161.189.227.200:9094 --command-config=client.conf</span><br><span class="line"><span class="comment"># 创建消费者，--group 指定消费者组名称</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --consumer.config=client.conf --group=test-group</span><br><span class="line"><span class="comment"># 创建生产者</span></span><br><span class="line">kafka-console-producer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --producer.config=client.conf</span><br></pre></td></tr></table></figure><h2 id="开启-SASL-SSL">开启 SASL_SSL</h2><ul class="lvl-0"><li class="lvl-2"><p>这里设置外网访问时开启 SASL_SSL</p></li></ul><h3 id="创建证书">创建证书</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://kafka.apache.org/39/documentation.html#security_ssl">官方文档</a></p></li><li class="lvl-2"><p>生成 Broker keystore，用于 存储 broker 的私钥和证书。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore kafka.server.keystore.jks \</span><br><span class="line">  -<span class="built_in">alias</span> broker -validity 3650 \</span><br><span class="line">  -genkey -keyalg RSA \</span><br><span class="line">  -dname <span class="string">&quot;CN=broker, OU=Kafka, O=YourOrg, L=City, ST=State, C=CN&quot;</span> \</span><br><span class="line">  -storepass 123456 \</span><br><span class="line">  -keypass 123456</span><br><span class="line"><span class="comment">## 参数说明：</span></span><br><span class="line"><span class="comment"># -keystore：生成的 keystore 文件路径</span></span><br><span class="line"><span class="comment"># -alias broker：证书别名</span></span><br><span class="line"><span class="comment"># -validity 3650：有效期 3650 天</span></span><br><span class="line"><span class="comment"># -keyalg RSA：密钥算法</span></span><br><span class="line"><span class="comment"># -dname：证书信息</span></span><br><span class="line"><span class="comment"># -storepass：keystore 密码</span></span><br><span class="line"><span class="comment"># -keypass：密钥密码</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>导出 Broker 证书（用于客户端 truststore）,生成 kafka.server.crt，客户端会用它来验证 broker。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore kafka.server.keystore.jks \</span><br><span class="line">  -<span class="built_in">alias</span> broker -<span class="built_in">export</span> -file kafka.server.crt \</span><br><span class="line">  -storepass 123456</span><br><span class="line"><span class="comment">## 参数说明：</span></span><br><span class="line"><span class="comment"># -keystore：keystore 文件路径</span></span><br><span class="line"><span class="comment"># -alias broker：证书别名</span></span><br><span class="line"><span class="comment"># -file kafka.server.crt：导出的证书文件路径</span></span><br><span class="line"><span class="comment"># -storepass：keystore 密码</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生成 Broker truststore，truststore 用于 存储信任的证书（这里把自己生成的证书导入进去即可）,生成 kafka.truststore.jks</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：这里 server 端 和 client 端 可以共用一个 truststore，也可以分别创建</span></span><br><span class="line">keytool -keystore kafka.truststore.jks \</span><br><span class="line">  -<span class="built_in">alias</span> broker -import -file kafka.server.crt \</span><br><span class="line">  -storepass 123456 -noprompt</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># -keystore：生成的 truststore 文件路径</span></span><br><span class="line"><span class="comment"># -alias broker：证书别名</span></span><br><span class="line"><span class="comment"># -file kafka.server.crt：导入的证书文件路径</span></span><br><span class="line"><span class="comment"># -storepass：truststore 密码</span></span><br><span class="line"><span class="comment"># -noprompt：不提示</span></span><br></pre></td></tr></table></figure><h3 id="server-properties-配置-SASL-SSL">server.properties 配置 SASL_SSL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class="line">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095</span><br><span class="line"><span class="comment"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class="line">advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095</span><br><span class="line">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSL</span><br><span class="line">inter.broker.listener.name=INTERNAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># SASL</span></span><br><span class="line"><span class="comment"># 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）</span></span><br><span class="line"><span class="comment"># client 连接时</span></span><br><span class="line">sasl.enabled.mechanisms=PLAIN</span><br><span class="line"><span class="comment"># broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效</span></span><br><span class="line"><span class="comment">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL</span></span><br><span class="line">ssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/kafka.server.keystore.jks</span><br><span class="line">ssl.keystore.password=123456</span><br><span class="line">ssl.key.password=123456</span><br><span class="line">ssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class="line">ssl.truststore.password=123456</span><br><span class="line"><span class="comment"># 如果不要求客户端证书，可以设置 none ，要求则设置为 required</span></span><br><span class="line">ssl.client.auth=none</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 kafka 前同样需要先创建好 kafka_jaas.conf，与 SASL_PLAINTEXT 一样。</p></li></ul><h3 id="客户端访问-2">客户端访问</h3><ul class="lvl-0"><li class="lvl-2"><p>将 <code>kafka.truststore.jks</code> 拷贝到客户端</p></li><li class="lvl-2"><p>与 SASL_PLAINTEXT 一样，创建 client.conf，并添加如下信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">security.protocol=SASL_SSL</span><br><span class="line"><span class="comment"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class="line">sasl.mechanism=PLAIN</span><br><span class="line"><span class="comment"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class="line">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class="string">&quot;admin&quot;</span> password=<span class="string">&quot;admin-secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL 配置</span></span><br><span class="line">ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class="line">ssl.truststore.password=123456</span><br><span class="line"><span class="comment"># 禁用主机名验证，否则会校验证书的 SAN，证书域名校验开关，为空则表示关闭，这里需要保持关闭状态，必须设置为空</span></span><br><span class="line">ssl.endpoint.identification.algorithm=</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>命令行访问 与 SASL_PLAINTEXT 一样，这里不再赘述</p></li><li class="lvl-2"><p>关于 Kafka JKS格式的SSL证书的创建及配置可以参考<a href="https://support.huaweicloud.com/usermanual-kafka/kafka-ug-0008.html">制作和替换Kafka JKS格式的SSL证书</a></p></li></ul><h4 id="PEM-证书">PEM 证书</h4><ul class="lvl-0"><li class="lvl-2"><p>Kafka 的 证书 默认使用 JKS 格式，但从 2.7.0 开始支持 PEM 格式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class="line">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095</span><br><span class="line"><span class="comment"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class="line">advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095</span><br><span class="line">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSL</span><br><span class="line">inter.broker.listener.name=INTERNAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># SASL</span></span><br><span class="line"><span class="comment"># 认证机制（常见为 PLAIN，也可以是 CRAM-SHA-256、SCRAM-SHA-512）</span></span><br><span class="line"><span class="comment"># client 连接时</span></span><br><span class="line">sasl.enabled.mechanisms=PLAIN</span><br><span class="line"><span class="comment"># broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效</span></span><br><span class="line"><span class="comment">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL-PEM</span></span><br><span class="line">ssl.keystore.type=PEM <span class="comment"># 指定证书类型是PEM，支持的类型 PEM、JKS</span></span><br><span class="line">ssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/fullchain.pem <span class="comment"># 包含私钥和公钥</span></span><br><span class="line"><span class="comment"># 指定客户端使用的证书类型是PEM</span></span><br><span class="line">ssl.truststore.type=PEM</span><br><span class="line">ssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/server.crt <span class="comment"># 公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不要求客户端证书，可以设置 none ，要求则设置为 required</span></span><br><span class="line">ssl.client.auth=none</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>client.conf 配置如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">security.protocol=SASL_SSL</span><br><span class="line"><span class="comment"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class="line">sasl.mechanism=PLAIN</span><br><span class="line"><span class="comment"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class="line">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class="string">&quot;admin&quot;</span> password=<span class="string">&quot;admin-secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL 配置，将 server 端的 server.crt 拷贝到 client 端</span></span><br><span class="line">ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crt</span><br><span class="line">ssl.truststore.type=PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用主机名验证</span></span><br><span class="line">ssl.endpoint.identification.algorithm=</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>jks 证书转换为 pem 格式</strong></em></p><ul class="lvl-1"><li class="lvl-2">从 JKS 导出为 PKCS#12 (.p12)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore \</span><br><span class="line">  -srckeystore kafka.server.keystore.jks \</span><br><span class="line">  -srcstoretype JKS \</span><br><span class="line">  -destkeystore kafka.server.p12 \</span><br><span class="line">  -deststoretype PKCS12 \</span><br><span class="line">  -srcstorepass 123456 \</span><br><span class="line">  -deststorepass 123456 \</span><br><span class="line">  -J<span class="string">&quot;-Djdk.tls.disabledAlgorithms=&quot;</span> \</span><br><span class="line">  -J<span class="string">&quot;-Dkeystore.pkcs12.legacy=false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 说明：</span></span><br><span class="line">  <span class="comment"># -srcstoretype JKS：原始格式；</span></span><br><span class="line">  <span class="comment"># -deststoretype PKCS12：转换为通用格式；</span></span><br><span class="line">  <span class="comment"># .p12 是 PEM 的“中间格式”。</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">导出证书[公钥] (.crt，这里是 PEM 格式)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="keyword">in</span> kafka.server.p12 -clcerts -nokeys -out server.crt -password pass:123456 -provider legacy -provider default</span><br><span class="line"><span class="comment">## 说明：</span></span><br><span class="line"><span class="comment"># -clcerts：只导出证书；</span></span><br><span class="line"><span class="comment"># -nokeys：不导出密钥；</span></span><br><span class="line"><span class="comment"># -out server.crt：导出文件名；</span></span><br><span class="line"><span class="comment"># -password：kafka.server.p12的密钥密码，注意密码前面加上 pass:</span></span><br><span class="line"><span class="comment"># -provider legacy：启用旧算法支持模块，在 OpenSSL 3.0（及更高版本）中，引入了一个新机制 —— Provider（算法提供者）,默认情况下，OpenSSL 只加载 modern provider（default provider），而许多老旧算法（例如 RC2、MD5、DES、SHA1）被移到了一个单独的 legacy provider 模块中。</span></span><br><span class="line"><span class="comment"># -provider default：同时启用默认 provider，因为有些命令（比如涉及现代加密算法或证书签名）还依赖默认 provider，所以两者一起使用最安全、最兼容</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">导出私钥 (.key，这里是 PEM 格式)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="keyword">in</span> kafka.server.p12 -nocerts -out server.key -nodes -password pass:123456 -provider legacy -provider default</span><br><span class="line"><span class="comment">## 说明：</span></span><br><span class="line"><span class="comment"># -nocerts：只导出密钥；</span></span><br><span class="line"><span class="comment"># -out server.key：导出文件名；</span></span><br><span class="line"><span class="comment"># -nodes：不加密导出的密钥文件</span></span><br><span class="line"><span class="comment"># -password：kafka.server.p12的密钥密码，注意密码前面加上 pass:</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">fullchain.pem</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="keyword">in</span> kafka.server.p12 -out fullchain.pem -nodes -password pass:123456 -provider legacy -provider default</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Kafka 的 通信协议，以及如何开启外网访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 的安装：基于 Zookeeper</title>
    <link href="https://blog.hanqunfeng.com/2025/10/13/kafka-01-install-zookeeper/"/>
    <id>https://blog.hanqunfeng.com/2025/10/13/kafka-01-install-zookeeper/</id>
    <published>2025-10-13T13:30:05.000Z</published>
    <updated>2025-10-20T02:47:41.647Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 CentOS9 中 Kafka 的安装与使用，基于 Zookeeper。</p></li><li class="lvl-2"><p><a href="https://kafka.apache.org">Kafka官网</a></p></li><li class="lvl-2"><p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p></li></ul><span id="more"></span><h2 id="Kafka-简介">Kafka 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Apache Kafka 是一个 <code>分布式的流处理/事件流平台</code>，既可以作为<code>消息系统</code>，也可以作为持久化的 <code>日志/记录存储与流处理平台</code>。</p></li><li class="lvl-2"><p>它的设计目标是高吞吐、低延迟、可水平扩展、容错，以及可持久化数据。</p></li><li class="lvl-2"><p>在 Kafka 中，消息被归类为 <code>主题（Topic）</code>，每个主题可以根据配置被拆分为多个 <code>分区（Partition）</code>，每个分区内部消息是<code>严格有序</code>的，并以<code>追加</code>方式写入。消费者可以按<code>偏移量（offset）</code>读取消息。</p></li><li class="lvl-2"><p>Kafka 提供多个 API：Producer、Consumer、Streams（流处理）、Connect（与外部系统整合）等。</p></li><li class="lvl-2"><p>Kafka 的核心架构要素与工作机制</p></li></ul><table><thead><tr><th>组件 / 概念</th><th>作用 / 描述</th></tr></thead><tbody><tr><td>Broker（节点 / 服务器）</td><td>Kafka 集群中的服务器实例，负责接收、存储、分发消息</td></tr><tr><td>Topic</td><td>消息的“分类”逻辑单元，Producer 写入、Consumer 读取</td></tr><tr><td>Partition</td><td>一个 Topic 被划分的子单元。分区使得主题可以横向扩展，并支持并行读写</td></tr><tr><td>Offset</td><td>每条消息在某个分区中的唯一位置标识，消费者根据 offset 来决定下一条读取</td></tr><tr><td>Replication（副本）</td><td>为了容错性，每个分区可以有多个副本（副本分布在不同 Broker 上）</td></tr><tr><td>Leader / Follower</td><td>在副本中，一个副本为 Leader，接受读写请求；其他为 Follower，从 Leader 同步数据</td></tr><tr><td>Consumer Group</td><td>一组消费者共同消费一个 Topic。每个分区在同一个消费者组中通常只被一个消费者 “拥有”</td></tr><tr><td>ZooKeeper / KRaft</td><td>用于元数据管理、集群协调（在较老版本中是 ZooKeeper；新版本推向 KRaft）</td></tr></tbody></table><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/Xe43JY.png" alt="" width="900" height="600"></p><ul class="lvl-0"><li class="lvl-2"><p>消息写入流程（简化）：</p><ul class="lvl-2"><li class="lvl-4">Producer 将消息发送给某个 Topic 的 Leader 分区节点</li><li class="lvl-4">Leader 接收到消息后，将其追加写入本地日志，并返回确认（ACK）</li><li class="lvl-4">Follower 副本从 Leader 拉取数据进行同步</li><li class="lvl-4">消费者根据自己的 offset 从对应 Partition 中读取消息</li></ul></li><li class="lvl-2"><p>消费控制与容错：</p><ul class="lvl-2"><li class="lvl-4">消费者维护自己的 offset（可以自动提交，也可手动控制），这样即使消费者重启，也可以从上次停止的位置继续。</li><li class="lvl-4">如果某个 Broker 宕机，副本可以切换（Leader 选举），保证服务继续。</li><li class="lvl-4">分区与副本机制使得 Kafka 能够扩展容量 &amp; 提高可靠性。</li></ul></li><li class="lvl-2"><p>Kafka 的典型使用场景</p></li></ul><table><thead><tr><th>场景类别</th><th>说明</th></tr></thead><tbody><tr><td><strong>实时数据管道 / 数据集成</strong></td><td>用于将各种数据源（如日志、数据库变更、传感器、用户事件等）实时采集、传输、分发到下游系统（如 OLAP、搜索引擎、监控平台等），构建高效的数据通道。</td></tr><tr><td><strong>事件驱动 / 事件溯源</strong></td><td>记录系统内部或跨系统的事件（状态变化），实现事件驱动架构（EDA）或事件溯源（Event Sourcing），可用于审计、回放、状态重建等。</td></tr><tr><td><strong>日志聚合 / 分析</strong></td><td>将分布式系统中的应用日志、监控指标、操作日志等统一收集到 Kafka 中，集中存储与分析，常与 ELK、ClickHouse 等结合。</td></tr><tr><td><strong>流处理</strong></td><td>与 Kafka Streams、Apache Flink、Spark Streaming 等流处理框架配合，对流经 Kafka 的数据进行实时计算、聚合、过滤、窗口统计等操作。</td></tr><tr><td><strong>系统解耦 / 异步通信</strong></td><td>作为系统间的消息中间件，实现发布-订阅模式，减少系统间耦合，支持异步通信、流量削峰、缓冲等，提升系统稳定性与扩展性。</td></tr></tbody></table><h2 id="Kafka-安装">Kafka 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>这里先介绍基于 Zookeeper 的安装方式，下文会介绍基于 KRaft 的安装方式。</p></li><li class="lvl-2"><p>Kafka 3.9.1 的安装与运行需要 JDK 8+，所有我们需要提前安装 JDK 8+。可以选择OpenJDK，<a href="https://mirrors.tuna.tsinghua.edu.cn/Adoptium/">清华大学镜像站</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root 用户</span></span><br><span class="line"><span class="comment"># 创建安装目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/jdk</span><br><span class="line"><span class="built_in">cd</span> /usr/local/jdk</span><br><span class="line"><span class="comment"># 下载JDK</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/Adoptium/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gz</span><br><span class="line">tar -zxvf OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gz</span><br><span class="line"><span class="built_in">ln</span> -s jdk8u462-b08 jdk8</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=/usr/local/jdk/jdk8&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="comment"># 注意这里是 单引号，双引号会解析变量，导致配置失败</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$JAVA_HOME/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 检查JDK安装</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装过程参考官网文档<a href="https://kafka.apache.org/39/documentation.html#quickstart">Kafka Quick Start</a>。</p></li></ul><h3 id="单机安装">单机安装</h3><ul class="lvl-0"><li class="lvl-2"><p>部署kafka都会使用集群模式，单机模式只作为学习试用。</p></li><li class="lvl-2"><p>下载Kafka，<a href="https://kafka.apache.org/downloads">下载页面</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root 用户</span></span><br><span class="line"><span class="comment"># 创建安装目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/kafka</span><br><span class="line"><span class="built_in">cd</span> /usr/local/kafka</span><br><span class="line"><span class="comment"># 下载Kafka</span></span><br><span class="line">wget https://dlcdn.apache.org/kafka/3.9.1/kafka_2.13-3.9.1.tgz</span><br><span class="line">tar -zxvf kafka_2.13-3.9.1.tgz</span><br><span class="line"><span class="built_in">ln</span> -s kafka_2.13-3.9.1 kafka3</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export KAFKA_HOME=/usr/local/kafka/kafka3&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$KAFKA_HOME/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 查看Kafka版本</span></span><br><span class="line">kafka-topics.sh --version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 Zookeeper，kafka内置了zookeeper，所以不需要单独安装。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前台运行</span></span><br><span class="line">zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="built_in">nohup</span> zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties &gt; zookeeper.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭zookeeper，kill进程，过滤 java &amp; QuorumPeerMain</span></span><br><span class="line">zookeeper-server-stop.sh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动 kafka</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -daemon 后台运行</span></span><br><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查kafka是否启动成功</span></span><br><span class="line">jps -l | grep kafka</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 kafka，kill进程，过滤 java &amp; &#x27;kafka\.Kafka&#x27;</span></span><br><span class="line">kafka-server-stop.sh</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">注意：默认情况下 启动 kafka 需要的内存大小为 1G，这一点可以在 <a href="http://kafka-server-start.sh">kafka-server-start.sh</a> 脚本中查看到</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$KAFKA_HEAP_OPTS</span>&quot;</span> = <span class="string">&quot;x&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-Xmx1G -Xms1G&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">所以如果内存不够，可以设置环境变量后再启动kafka</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-Xmx512M -Xms512M&quot;</span></span><br><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure></div><ul class="lvl-0"><li class="lvl-2"><p>测试</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 topic</span></span><br><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动消费者</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动生产者</span></span><br><span class="line">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line">&gt; hello world <span class="comment"># 输入内容，消费者会收到</span></span><br></pre></td></tr></table></figure><h3 id="集群安装">集群安装</h3><ul class="lvl-0"><li class="lvl-2"><p>集群安装需要准备多个节点，这里我准备三个节点，分别如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.7</span><br><span class="line">10.250.0.174</span><br><span class="line">10.250.0.108</span><br></pre></td></tr></table></figure><h4 id="搭建-Zookeeper-集群">搭建 Zookeeper 集群</h4><ul class="lvl-0"><li class="lvl-2"><p>关于如何搭建 Zookeeper 集群，可以参考我之前的文章 <a href="/2025/09/15/zookeeper-study/" title="Zookeeper 的安装及使用">Zookeeper 的安装及使用</a></p></li><li class="lvl-2"><p>如果图省事也可以直接使用 Kafka 自带的 zookeeper，编辑其配置文件 <code>config/zookeeper.properties</code>如下，注意要在 <code>dataDir</code> 目录下创建<code>myid</code>文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/usr/local/kafka/dataDir/zookeeper</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># disable the per-ip limit on the number of connections since this is a non-production config</span></span><br><span class="line">maxClientCnxns=0</span><br><span class="line"><span class="comment"># Disable the adminserver by default to avoid port conflicts.</span></span><br><span class="line"><span class="comment"># Set the port to something non-conflicting if choosing to enable this</span></span><br><span class="line">admin.enableServer=<span class="literal">false</span></span><br><span class="line"><span class="comment"># admin.serverPort=8080</span></span><br><span class="line"></span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line">server.1=10.250.0.7:2888:3888</span><br><span class="line">server.2=10.250.0.174:2888:3888</span><br><span class="line">server.3=10.250.0.108:2888:3888</span><br></pre></td></tr></table></figure><h4 id="配置-Kafka-集群">配置 Kafka 集群</h4><ul class="lvl-0"><li class="lvl-2"><p>修改主机的主机名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl hostname worker1</span><br><span class="line"><span class="comment"># hostnamectl hostname worker2</span></span><br><span class="line"><span class="comment"># hostnamectl hostname worker3</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了后续方便维护，将ip地址映射到 hosts 文件中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.7 worker1</span><br><span class="line">10.250.0.174 worker2</span><br><span class="line">10.250.0.108 worker3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>编辑 <code>config/server.properties</code> 文件，需要修改如下配置项</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#broker 的全局唯⼀编号，不能重复，只能是数字。</span></span><br><span class="line">broker.id=1 <span class="comment"># 这里分别设置为1、2、3</span></span><br><span class="line"><span class="comment">#服务监听地址</span></span><br><span class="line">listeners=PLAINTEXT://worker1:9092</span><br><span class="line"><span class="comment">#数据⽂件地址。同样默认是给的/tmp⽬录。</span></span><br><span class="line">log.dirs=/usr/local/kafka/dataDir/kafka-logs</span><br><span class="line"><span class="comment">#默认的每个Topic的分区数，创建Topic时，如果未指定分区数，则默认为1个分区。</span></span><br><span class="line">num.partitions=1</span><br><span class="line"><span class="comment"># 每个⽇志⽂件删除之前保存的时间，默认是168小时，即7天。</span></span><br><span class="line">log.retention.hours=168</span><br><span class="line"><span class="comment">#zookeeper的服务地址，如果是自建的 Zookeeper 集群，则这里需要填写集群的连接地址</span></span><br><span class="line">zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别在三个节点上启动 Kafka</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>测试</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 topic</span></span><br><span class="line">kafka-topics.sh --bootstrap-server worker1:9092 --create --replication-factor 3 --partitions 3 --topic disTopic</span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="comment"># --replication-factor 3 表示创建的副本数</span></span><br><span class="line"><span class="comment"># --partitions 3 表示创建的分区数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 topic 详情</span></span><br><span class="line">kafka-topics.sh --bootstrap-server worker1:9092 --describe --topic disTopic</span><br><span class="line">Topic: disTopicTopicId: VUK7Mc9oQdS1mjGG7OhQzQPartitionCount: 3ReplicationFactor: Configs:</span><br><span class="line">Topic: disTopicPartition: 0Leader: 2Replicas: 2,3,1Isr: 2,3,1Elr: N/ALastKnownElr: N/A</span><br><span class="line">Topic: disTopicPartition: 1Leader: 3Replicas: 3,1,2Isr: 3,1,2Elr: N/ALastKnownElr: N/A</span><br><span class="line">Topic: disTopicPartition: 2Leader: 1Replicas: 1,2,3Isr: 1,2,3Elr: N/ALastKnownElr: N/A</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 CentOS9 中 Kafka 的安装与使用，基于 Zookeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org&quot;&gt;Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/kafka/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="kafka" scheme="https://blog.hanqunfeng.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 之 Cluster</title>
    <link href="https://blog.hanqunfeng.com/2025/09/25/rabbitmq-cluster/"/>
    <id>https://blog.hanqunfeng.com/2025/09/25/rabbitmq-cluster/</id>
    <published>2025-09-25T14:30:05.000Z</published>
    <updated>2025-09-28T02:31:18.783Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RabbitMQ 的 Cluster 的基本概念和用法。</p></li><li class="lvl-2"><p><a href="https://www.rabbitmq.com">Zookeeper官网</a></p></li><li class="lvl-2"><p>本文使用的 RabbitMQ 版本为 4.1.4。</p></li><li class="lvl-2"><p><a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo">Java Client 示例</a></p></li></ul><span id="more"></span><h2 id="RabbitMQ-Cluster-集群-简介">RabbitMQ Cluster(集群) 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 RabbitMQ 中，<a href="https://www.rabbitmq.com/docs/clustering">Cluster（集群）</a> 是多个节点组成的集合，用于实现高可用和负载均衡。</p></li><li class="lvl-2"><p>RabbitMQ 集群是一个或多个（三个、五个、七个或更多）节点的逻辑分组， 每个节点共享 用户、虚拟主机、队列、流、交换、绑定、运行时参数和其他分布式状态。</p></li><li class="lvl-2"><p>在 RabbitMQ 中，Cluster（集群）的节点分为两种：</p><ul class="lvl-2"><li class="lvl-4">磁盘节点(disk)：会把集群的所有元数据信息（比如交换机、绑定、队列、虚拟主机等信息）持久化到磁盘中。Master 节点必须是磁盘节点。</li><li class="lvl-4">内存节点(ram)：只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失。Slave 节点可以是内存节点。</li></ul></li><li class="lvl-2"><p>RabbitMQ 4.0 开始， 集群不再区分 <code>普通集群模式（Classic Cluster）</code> 与 <code>镜像集群模式（Mirrored Queue Cluster）</code> ，集群创建好后，会根据队列的<code>初始复制因子参数</code>决定为该队列创建多少个副本，比如 <code>Quroum Queue</code> 的参数是 <code>x-quorum-initial-group-size</code>，默认为3。</p></li><li class="lvl-2"><p>RabbitMQ 4.0 开始，<code>Quroum Queue</code> 和 <code>Stream Queue</code> 默认开启节点间<code>消息复制</code>，但是 <code>Classic Queue</code> 队列不支持节点间的<code>消息复制</code>;</p></li></ul><div class="tips"><p><em><strong>RabbitMQ 4.0以前的 集群分为两种模式</strong></em></p><ul class="lvl-1"><li class="lvl-2"><ol><li class="lvl-5">普通集群模式（Classic Cluster）</li></ol><ul class="lvl-3"><li class="lvl-4">在 普通集群模式下，RabbitMQ 节点通过 Erlang 分布式系统实现互联，集群内的各个节点共享 消息队列、交换机、绑定等元素。</li><li class="lvl-4">普通集群的特点：<ul class="lvl-5"><li class="lvl-6">共享队列：队列数据仅存储在单一节点上，只有该节点可以处理队列中的消息。</li><li class="lvl-6">不自动复制数据：在普通集群中，消息并不会自动复制到其他节点。如果某个节点挂掉，队列上的消息就会丢失，无法恢复。</li><li class="lvl-6">负载均衡：交换机（Exchange）会把消息发送到不同的队列，但队列数据仍然只在一个节点上。因此，普通集群适合不要求极高可用性的场景。</li><li class="lvl-6">不具备高可用性：由于数据不会在集群的其他节点中复制，普通集群在某个节点宕机时，可能会导致消息丢失和系统不可用。</li></ul></li></ul></li><li class="lvl-2"><ol start="2"><li class="lvl-5">镜像集群模式（Mirrored Queue Cluster）</li></ol><ul class="lvl-3"><li class="lvl-4">镜像集群模式 是为了 高可用性 设计的，在该模式下，队列的数据会在集群中的多个节点上进行 复制（镜像），从而保证即使某个节点出现故障，数据也不会丢失。</li><li class="lvl-4">镜像集群的特点：<ul class="lvl-5"><li class="lvl-6">队列镜像：在镜像集群模式中，队列数据会在集群中的多个节点上复制。每个队列都有一个主节点和多个镜像节点。</li><li class="lvl-6">高可用性：消息会被复制到集群的其他节点上，从而保证如果一个节点宕机，数据不会丢失，系统能迅速恢复。</li><li class="lvl-6">节点故障恢复：当一个节点挂掉时，其他节点会继续处理该队列的消息，保证业务的高可用性。</li><li class="lvl-6">网络负担较重：由于需要在多个节点之间进行数据同步和复制，所以镜像队列模式会增加集群的网络负担和磁盘 I/O。</li><li class="lvl-6">性能影响：镜像队列模式会稍微影响性能，因为每次消息处理后，都需要将数据同步到其他镜像节点，增加了延迟。</li></ul></li></ul></li></ul></div><h2 id="集群搭建">集群搭建</h2><ul class="lvl-0"><li class="lvl-2"><p>准备三台服务器，分别安装 RabbitMQ ，安装方法参看 <a href="/2025/09/18/rabbitmq-install-01/" title="RabbitMQ 的安装及使用">RabbitMQ 的安装及使用</a></p></li><li class="lvl-2"><p>开放端口</p></li></ul><table><thead><tr><th><strong>端口范围</strong></th><th><strong>用途</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>4369</strong></td><td>epmd（Erlang Port Mapper Daemon）</td><td>RabbitMQ 节点和 CLI 工具使用的帮助程序发现守护进程。</td></tr><tr><td><strong>6000-6500</strong></td><td>RabbitMQ Stream 复制使用</td><td>用于 RabbitMQ Stream 的数据复制。</td></tr><tr><td><strong>25672</strong></td><td>Erlang 分发服务器端口</td><td>用于节点间和 CLI 工具通信，默认情况下仅限于单个端口（AMQP端口 + 20000）。</td></tr><tr><td><strong>35672-35682</strong></td><td>Erlang 分发客户端端口</td><td>用于 CLI 工具与节点通信，计算为服务器分发端口 + 10000 到 服务器分发端口 + 10010。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>分别修改三台服务器的 <code>hostname</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl hostname rabbitmq01</span><br><span class="line"><span class="comment"># hostnamectl hostname rabbitmq02</span></span><br><span class="line"><span class="comment"># hostnamectl hostname rabbitmq03</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别修改三台服务器的 <code>/etc/hosts</code> 文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.250.0.56  rabbitmq01</span><br><span class="line">10.250.0.232 rabbitmq02</span><br><span class="line">10.250.0.97  rabbitmq03</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>同步集群节点中的cookie</p><ul class="lvl-2"><li class="lvl-4">默认会在 <code>/var/lib/rabbitmq/</code>目录下生成一个<code>.erlang.cookie</code>，里面有一个字符串。</li><li class="lvl-4">我们使用 <code>rabbitmq01</code> 节点作为集群的主节点，其他节点作为集群的成员节点，我们要做的就是保证集群中三个节点的这个<code>cookie字符串一致</code>。</li><li class="lvl-4">将 <code>rabbitmq01</code> 的 <code>/var/lib/rabbitmq/.erlang.cookie</code> 文件中的<code>cookie字符串</code>复制到其他节点的 <code>/var/lib/rabbitmq/.erlang.cookie</code> 文件中。</li></ul></li><li class="lvl-2"><p>分别启动三台服务器的 RabbitMQ 服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分别登录 <code>rabbitmq02</code> 和 <code>rabbitmq03</code> 节点，执行如下命令，将节点加入集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停掉rabbitmq应用</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置rabbitmq、交换机、队列</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入集群，注意此时 rabbitmq01 是主节点，必须处于运行状态，</span></span><br><span class="line"><span class="comment"># --ram 表示以 ram 内存节点 加入集群。如果不带参数默认为 disk 磁盘节点</span></span><br><span class="line"><span class="comment"># RabbitMQ的集群节点分为 disk 和 ram，disk节点会将元数据保存到硬盘当中，而ram节点只是在内存中保存元数据。</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbitmq01 --ram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动rabbitmq应用</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录 任意 节点，执行如下命令，查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br><span class="line"><span class="comment">## 输出类似</span></span><br><span class="line">Cluster status of node rabbit@rabbitmq01 ...</span><br><span class="line">Basics</span><br><span class="line"></span><br><span class="line">Cluster name: rabbit@rabbitmq01</span><br><span class="line">Total CPU cores available cluster-wide: 6</span><br><span class="line"></span><br><span class="line">Cluster Tags</span><br><span class="line"></span><br><span class="line">(none)</span><br><span class="line"></span><br><span class="line">Disk Nodes</span><br><span class="line"></span><br><span class="line">rabbit@rabbitmq01</span><br><span class="line"></span><br><span class="line">RAM Nodes</span><br><span class="line"></span><br><span class="line">rabbit@rabbitmq02</span><br><span class="line">rabbit@rabbitmq03</span><br><span class="line"></span><br><span class="line">Running Nodes</span><br><span class="line"></span><br><span class="line">rabbit@rabbitmq01</span><br><span class="line">rabbit@rabbitmq02</span><br><span class="line">rabbit@rabbitmq03</span><br></pre></td></tr></table></figure><blockquote><p>PS: 由于ram节点减少了很多与硬盘的交互，所以，ram节点的元数据使用性能会比较高。但是，同时，这也意味着元数据的安全性是不如disk节点的。在我们这个集群中， rabbitmq02 和 rabbitmq03 都以 ram节点 的身份加入到 rabbitmq01 集群里，因此，是存在单点故障的。如果 rabbitmq01 节点服务崩溃，那么元数据就有可能丢失。在企业进行部署时，性能与安全性需要自己进行平衡。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>登录任意节点的管理页面，查看集群状态<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/R195gJ.png" alt=""></p></li><li class="lvl-2"><p>此时我们在任意节点中创建虚拟主机、队列、交换机和绑定关系 等元数据，都会自动同步到其他节点中。</p></li><li class="lvl-2"><p>我们也可以在 管理控制台 中查看队列时看到，此时多个一列，<code>Node</code>列，显示该队列在哪些节点中存在。只有 <code>Quorum 队列</code> 和 <code>Stream 队列</code> 才会显示多个节点，因为 <code>Classic 队列</code> 不支持多节点复制。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/GjHcLN.png" alt=""></p></li><li class="lvl-2"><p>查看某个具体的 <code>Quorum 队列</code> 或 <code>Stream 队列</code>，可以看到更详细的说明<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/XtIkpp.png" alt=""></p></li><li class="lvl-2"><p>此时新建队列，会要求我们指定主节点(Leader)，即负责存储消息的的节点，而 <code>Quorum 队列</code> 或 <code>Stream 队列</code>，会自动将消息复制到其它节点(Members)。</p><ul class="lvl-2"><li class="lvl-4">Leader: 队列的主节点，负责存储消息。</li><li class="lvl-4">Members: 队列的成员节点，负责存储消息的副本。</li></ul></li></ul><h2 id="演示队列复制">演示队列复制</h2><ul class="lvl-0"><li class="lvl-2"><p>默认情况下，<code>Quorum 队列</code> 和 <code>Stream 队列</code> 的 复制数 都为 3，这里为了演示，我在增加一个节点 <code>rabbitmq04</code>，请自行按上面的方法添加。</p></li></ul><h3 id="Quorum-队列">Quorum 队列</h3><ul class="lvl-0"><li class="lvl-2"><p>在页面上创建一个 <code>Quorum 队列</code>，与单节点上创建队列的区别就是需要我们选择主节点。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/JYfKgg.png" alt=""></p></li><li class="lvl-2"><p>通过 客户端 创建队列时，默认情况下，连接哪个节点，哪个节点就是Leader，但也可以通过参数<code>x-queue-leader-locator</code>指定主节点的选择策略。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin queues <span class="built_in">declare</span> --vhost <span class="string">&quot;/vtest&quot;</span> --name <span class="string">&quot;target.quorum.queue.name&quot;</span> --<span class="built_in">type</span> <span class="string">&quot;quorum&quot;</span> --durable <span class="literal">true</span> --arguments <span class="string">&#x27;&#123;&quot;x-queue-leader-locator&quot;:&quot;balanced&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># x-queue-leader-locator 有两种选择策略</span></span><br><span class="line"><span class="comment">## client-local：选择声明队列的客户端所连接的节点。这是默认值。</span></span><br><span class="line"><span class="comment">## balanced：如果队列总数少于 1000 个（经典队列、仲裁队列和流）， 选择托管最小数量的仲裁队列领导者的节点。 如果队列总体超过 1000 个，则随机选择一个节点。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建成功后，可以看到 <code>Quorum 队列</code> 的主节点和成员节点，可以看到这里成员节点有三个，除了主节点外，其余节点由集群自动选择。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/qBfNNh.png" alt=""></p></li><li class="lvl-2"><p>也就是说，默认情况下，<code>Quorum 队列</code> 的复制数是 <code>3</code>，如果我们希望改变复制数，可以在创建队列时指定参数 <code>x-quorum-initial-group-size</code>，其值为 <code>大于 0 的整数</code>，若设置值大于实际成员节点数，则以实际成员节点数为准。<code>x-quorum-initial-group-size</code> 设置为 <code>1</code> 时便不进行复制了。</p></li><li class="lvl-2"><p>如果集群中增加了新的节点，希望队列也被复制到新的节点中，可以通过如下命令，将新的节点加入成员节点中:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-queues add_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;</span></span><br><span class="line">rabbitmq-queues add_member -p /vtest q_4 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果希望将节点从成员节点中移除，可以通过如下命令:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-queues delete_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;</span></span><br><span class="line">rabbitmq-queues delete_member -p /vtest q_4 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>另外，当通过 <code>forget_cluster_node</code> 命令从集群中永久删除节点时，会自动将队列关联的节点从成员节点中移除。</p></li><li class="lvl-2"><p>删除节点时，请使用如下命令:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为要删除 rabbitmq04 节点，所以以下命令不能在 rabbitmq04 节点执行</span></span><br><span class="line"><span class="comment"># 删除前需要先关闭应用</span></span><br><span class="line">rabbitmqctl -n rabbit@rabbitmq04 stop_app</span><br><span class="line"><span class="comment"># 删除节点</span></span><br><span class="line"><span class="comment"># rabbitmqctl forget_cluster_node &lt;node&gt;</span></span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@rabbitmq04</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>新增节点后，一个个的对原有的队列进行复制扩展非常麻烦，可以通过如下命令快速对符合条件的队列进行复制扩展:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-queues grow &lt;node&gt; &lt;all | even&gt; [--vhost-pattern &lt;pattern&gt;] [--queue-pattern &lt;pattern&gt;]</span></span><br><span class="line"><span class="comment">## 参数说明：</span></span><br><span class="line"><span class="comment"># &lt;node&gt;: 这个参数指定了 RabbitMQ 节点的名称，通常是 rabbit@&lt;hostname&gt;。它表示在哪个节点上执行增长操作。</span></span><br><span class="line"><span class="comment"># &lt;all | even&gt;: 这个参数指定了要扩展的队列类型。all 表示扩展所有队列，even 表示扩展偶数编号的队列。</span></span><br><span class="line"><span class="comment"># --vhost-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的虚拟主机名称。</span></span><br><span class="line"><span class="comment"># --queue-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的队列名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 示例</span></span><br><span class="line"><span class="comment"># 扩展所有虚拟主机下的所有队列的副本：</span></span><br><span class="line">rabbitmq-queues grow rabbit@rabbitmq04 all</span><br><span class="line"><span class="comment"># 扩展所有虚拟主机下的偶数编号的队列的副本：</span></span><br><span class="line">rabbitmq-queues grow rabbit@rabbitmq04 even</span><br><span class="line"><span class="comment"># 扩展特定虚拟主机和队列名称的队列</span></span><br><span class="line">rabbitmq-queues grow rabbit@rabbitmq04 all --vhost-pattern /vtest --queue-pattern <span class="string">&quot;^q_&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Stream-队列">Stream 队列</h3><ul class="lvl-0"><li class="lvl-2"><p>Stream 队列 与 Quorum 队列 类似，通过哪个节点创建队列，哪个节点就是 Leader，但也是可以通过参数 <code>x-queue-leader-locator</code> 指定主节点的选择策略。</p></li><li class="lvl-2"><p>创建 Stream 队列时，默认复制数就是当前集群的节点数（Quorum 队列 默认是 3），可以通过指定参数 <code>x-initial-cluster-size</code> 进行初始设置。</p></li><li class="lvl-2"><p>添加新的节点时，与 Quorum 队列 类似，Stream 队列 也不会自动进行复制，可以通过如下命令手动复制</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-streams add_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;</span></span><br><span class="line">rabbitmq-streams add_replica -p /vtest sq_2 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除成员节点时，请使用如下命令:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-streams delete_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;</span></span><br><span class="line">rabbitmq-streams delete_replica -p /vtest sq_2 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看节点复制状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-streams stream_status [-p &lt;vhost&gt;] &lt;stream-name&gt;</span></span><br><span class="line">rabbitmq-streams stream_status -p /vtest sq_2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>当流出现异常状态（如副本分布异常、领导节点挂掉）时，为了恢复可用性，可以重启流</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-streams restart_stream [-p &lt;vhost&gt;] &lt;stream-name&gt;</span></span><br><span class="line">rabbitmq-streams restart_stream -p /vtest sq_2</span><br><span class="line"><span class="comment">## 重启操作</span></span><br><span class="line"><span class="comment"># 1.停止流的当前副本/分区。</span></span><br><span class="line"><span class="comment"># 2.重新初始化流的存储和元数据。</span></span><br><span class="line"><span class="comment"># 3.让流在集群中恢复为可用状态。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RabbitMQ 的 Cluster 的基本概念和用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rabbitmq.com&quot;&gt;Zookeeper官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RabbitMQ 版本为 4.1.4。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo&quot;&gt;Java Client 示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 之 Message</title>
    <link href="https://blog.hanqunfeng.com/2025/09/21/rabbitmq-message/"/>
    <id>https://blog.hanqunfeng.com/2025/09/21/rabbitmq-message/</id>
    <published>2025-09-21T14:30:05.000Z</published>
    <updated>2025-09-22T13:15:32.412Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RabbitMQ 的 Message 的基本概念和用法。</p></li><li class="lvl-2"><p><a href="https://www.rabbitmq.com">Zookeeper官网</a></p></li><li class="lvl-2"><p>本文使用的 RabbitMQ 版本为 4.1.4。</p></li><li class="lvl-2"><p><a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo">Java Client 示例</a></p></li></ul><span id="more"></span><h2 id="Message-消息-是什么？">Message(消息) 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>在 RabbitMQ 中，Message（消息）是消息队列中的数据单元。消息包含消息内容、消息属性等信息。</p></li><li class="lvl-2"><p>Message 组成：</p><ul class="lvl-2"><li class="lvl-4"><ol><li class="lvl-7">消息内容：消息的内容，可以是任意数据。</li></ol></li><li class="lvl-4"><ol start="2"><li class="lvl-7">消息属性：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。</li></ol></li></ul></li></ul><h2 id="Web-控制台-中-Message-的使用">Web 控制台 中 Message 的使用</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Exchange 和 Queue 的管理界面中，都可以在其详情页面测试 Message 的使用。</p></li><li class="lvl-2"><p>关于如何在代码中使用 Message，我会在下一节中详细介绍。</p></li></ul><h3 id="Publish-message">Publish message</h3><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/dHsDyt.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>Payload：消息的内容，可以是任意数据。</p></li><li class="lvl-2"><p>Payload encoding：消息内容的编码方式，<code>String</code> 或者 <code>Base64</code>，默认为 <code>String</code>。</p></li><li class="lvl-2"><p>Delivery mode：消息的持久化模式，1-Non-persistent 表示非持久化，2-Persistent 表示持久化。</p></li><li class="lvl-2"><p>Headers：消息的头信息，用于与 <code>Headers Exchange（头部交换机）</code>中的配置进行匹配。</p></li><li class="lvl-2"><p>Properties：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。</p></li></ul><table><thead><tr><th>属性名</th><th>中文含义</th><th>数据类型</th><th>默认值</th><th>典型用途</th></tr></thead><tbody><tr><td>content_type</td><td>内容类型</td><td>String</td><td>null</td><td>指定消息的 MIME 类型，如 <code>&quot;text/plain&quot;</code>、<code>&quot;application/json&quot;</code></td></tr><tr><td>content_encoding</td><td>内容编码</td><td>String</td><td>null</td><td>指定消息内容的编码方式，如 <code>&quot;gzip&quot;</code></td></tr><tr><td>priority</td><td>消息优先级</td><td>Integer (0-255)</td><td>0</td><td>结合 <code>x-max-priority</code> 控制消息处理顺序，数值越大优先级越高</td></tr><tr><td>correlation_id</td><td>关联 ID</td><td>String</td><td>null</td><td>RPC 模式中关联请求与响应</td></tr><tr><td>reply_to</td><td>回复队列名</td><td>String</td><td>null</td><td>RPC 模式中指定响应消息的返回队列</td></tr><tr><td>expiration</td><td>消息过期时间</td><td>String (ms)</td><td>null</td><td>消息的 TTL，毫秒为单位，过期后将被丢弃或进入死信队列</td></tr><tr><td>message_id</td><td>消息 ID</td><td>String</td><td>null</td><td>唯一标识一条消息，通常由生产者指定</td></tr><tr><td>timestamp</td><td>时间戳</td><td>Date / Long</td><td>null</td><td>消息发送时间，通常是 Unix 时间戳</td></tr><tr><td>type</td><td>消息类型</td><td>String</td><td>null</td><td>描述消息类型，如 <code>&quot;order&quot;</code> 或 <code>&quot;event&quot;</code></td></tr><tr><td>user_id</td><td>用户 ID</td><td>String</td><td>null</td><td>标识发送消息的用户，通常用于安全或审计</td></tr><tr><td>app_id</td><td>应用 ID</td><td>String</td><td>null</td><td>标识发送消息的应用程序</td></tr><tr><td>cluster_id</td><td>集群 ID</td><td>String</td><td>null</td><td>RabbitMQ 集群 ID，实际中很少使用</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>与队列重叠的属性：</p></li></ul><table><thead><tr><th>参数名称</th><th>队列参数（Queue Arguments）</th><th>消息属性（Message Properties）</th><th>谁的优先级更高 / 生效方式</th></tr></thead><tbody><tr><td><strong>priority / x-max-priority</strong></td><td><code>x-max-priority</code>: 定义队列支持的<strong>最大优先级值</strong></td><td><code>priority</code>: 为单个消息设置优先级</td><td>队列先定义范围，消息只能在这个范围内取值 <br> 若 <code>priority &gt; x-max-priority</code>，则以<code>x-max-priority</code>为准</td></tr><tr><td><strong>expiration / x-message-ttl</strong></td><td><code>x-message-ttl</code>: 队列级别的消息<strong>统一 TTL</strong></td><td><code>expiration</code>: 为单个消息设置 TTL（毫秒）</td><td>如果同时设置，<strong>较短的 TTL</strong> 会生效</td></tr></tbody></table><h3 id="Get-message">Get message</h3><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/Ar9qob.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>Ack Mode：消息确认模式</p><ul class="lvl-2"><li class="lvl-4">Nack message requeue true: 确认失败，消息重新入队，这是默认选择，主要是为了测试后消息依旧存在。</li><li class="lvl-4">Automatic ack: 自动确认</li><li class="lvl-4">Reject requeue true: 拒绝，消息重新入队</li><li class="lvl-4">Reject requeue false: 拒绝，消息不重新入队</li></ul></li><li class="lvl-2"><p>Encoding：消息内容编码方式</p><ul class="lvl-2"><li class="lvl-4"><code>Auto String / Base64</code>，默认。如果消息载荷可以解释为UTF-8编码的字符串，就是 <code>String</code>，否则就是 <code>Base64</code>。</li><li class="lvl-4"><code>Base64</code>。</li></ul></li><li class="lvl-2"><p>Messages: 一次获取消息数量，默认为 1。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RabbitMQ 的 Message 的基本概念和用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rabbitmq.com&quot;&gt;Zookeeper官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RabbitMQ 版本为 4.1.4。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo&quot;&gt;Java Client 示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 之 Exchange</title>
    <link href="https://blog.hanqunfeng.com/2025/09/21/rabbitmq-exchange/"/>
    <id>https://blog.hanqunfeng.com/2025/09/21/rabbitmq-exchange/</id>
    <published>2025-09-21T13:30:05.000Z</published>
    <updated>2025-09-22T13:17:07.914Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RabbitMQ 的 Exchange 的基本概念和用法。</p></li><li class="lvl-2"><p><a href="https://www.rabbitmq.com">Zookeeper官网</a></p></li><li class="lvl-2"><p>本文使用的 RabbitMQ 版本为 4.1.4。</p></li><li class="lvl-2"><p><a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo">Java Client 示例</a></p></li></ul><span id="more"></span><h2 id="Exchange-交换机-是什么？">Exchange(交换机) 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>在 RabbitMQ 中，<a href="https://www.rabbitmq.com/docs/exchanges">Exchange（交换机）</a> 是消息路由的核心组件。它负责接收生产者发送的消息，并根据预定义的路由规则将消息转发到一个或多个队列。</p></li><li class="lvl-2"><p>Exchange 类型决定了消息的路由方式。RabbitMQ 支持的 Exchange 类型</p></li></ul><table><thead><tr><th>Exchange 类型</th><th>声明类型</th><th>路由规则描述</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>Direct</strong></td><td><code>direct</code></td><td>消息根据 <strong>路由键（routing key）</strong> 精确匹配绑定键（binding key）进行路由。</td><td>精确消息传递，如日志分类、任务分发等。</td></tr><tr><td><strong>Fanout</strong></td><td><code>fanout</code></td><td>消息广播到所有绑定的队列，<strong>忽略路由键</strong>。</td><td>广播消息，如发布/订阅模式、实时通知等。</td></tr><tr><td><strong>Topic</strong></td><td><code>topic</code></td><td>消息根据路由键与绑定键模式的匹配进行路由，支持通配符 <code>*</code>（匹配一个词）和 <code>#</code>（匹配零个或多个词）。</td><td>模块化路由，如日志系统、事件驱动架构等。</td></tr><tr><td><strong>Headers</strong></td><td><code>headers</code></td><td>消息根据 <strong>消息头部（headers）</strong> 与绑定时指定的头部匹配进行路由，支持 <code>x-match</code> 参数（<code>any</code> 或 <code>all</code>）。</td><td>多条件路由，如复杂过滤、动态路由等。</td></tr><tr><td><strong>Local Random Exchange</strong></td><td><code>x-local-random</code></td><td>消息始终被路由到本地队列，如果有多个本地队列绑定，则随机选择一个进行投递。</td><td>请求-响应（RPC）模式，低延迟通信</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>RabbitMQ 默认为我们提供了如下的交换机<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/SKlqQK.png" alt=""></p></li><li class="lvl-2"><p>每新创建一个 Vhost，RabbitMQ 就会自动创建以下交换机，比如 <code>/vtest</code><br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/oGJ1oj.png" alt=""></p></li><li class="lvl-2"><p>当然我们也可以根据需要创建新的交换机<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/QjnZin.png" alt=""></p></li><li class="lvl-2"><p>配置说明</p><ul class="lvl-2"><li class="lvl-4">Durability: 指定 Exchange 是否持久化。<ul class="lvl-4"><li class="lvl-6">Durable: 持久化的 Exchange 会被保存在磁盘上，重启 RabbitMQ 时会自动恢复。</li><li class="lvl-6">Transient: 非持久化的 Exchange 会被保存在内存中，重启 RabbitMQ 时会丢失。</li></ul></li><li class="lvl-4">Auto-delete: 指定 Exchange 是否自动删除。<ul class="lvl-4"><li class="lvl-6">yes: 如果没有队列或交换机绑定该 Exchange，则该 Exchange 会自动删除。</li><li class="lvl-6">no: 该 Exchange 不会自动删除。</li></ul></li><li class="lvl-4">Internal: 用于控制交换机是否可以被生产者直接发布消息<ul class="lvl-4"><li class="lvl-6">yes: 不能被生产者直接发送消息，该交换机只能用于 将消息从其他交换机转发到该交换机。</li><li class="lvl-6">no: 可以被生产者直接发送消息。</li></ul></li><li class="lvl-4">Arguments: 用于设置 Exchange 的其他参数，目前仅支持一个参数<ul class="lvl-4"><li class="lvl-6">Alternate exchange(alternate-exchange): 指定该 Exchange 的备用交换机，如果无法以其他方式将发往此交换机的消息路由出去，则将它们发送至此处指定的备用交换机。</li></ul></li></ul></li></ul><h2 id="Direct-Exchange（直接交换机）">Direct Exchange（直接交换机）</h2><ul class="lvl-0"><li class="lvl-2"><p>路由规则：消息的路由键与队列的绑定键完全匹配时，消息被路由到该队列。</p></li><li class="lvl-2"><p>示例：如果队列绑定键为 error，则只有路由键为 error 的消息会被路由到该队列。</p></li><li class="lvl-2"><p>适用场景：需要精确匹配的场景，如日志分类、任务分发等。</p></li></ul><h2 id="Fanout-Exchange（扇出交换机）">Fanout Exchange（扇出交换机）</h2><ul class="lvl-0"><li class="lvl-2"><p>路由规则：消息广播到所有绑定的队列，忽略路由键。</p></li><li class="lvl-2"><p>示例：无论消息的路由键是什么，都会被路由到所有绑定的队列。</p></li><li class="lvl-2"><p>适用场景：广播消息，如发布/订阅模式、实时通知等。</p></li></ul><h2 id="Topic-Exchange（主题交换机）">Topic Exchange（主题交换机）</h2><ul class="lvl-0"><li class="lvl-2"><p>路由规则：消息的路由键与队列的绑定键模式匹配时，消息被路由到该队列。支持通配符 *（匹配一个词）和 #（匹配零个或多个词）。</p></li><li class="lvl-2"><p>示例：如果队列绑定键为 <em>.orange.</em>，则路由键为 quick.orange.rabbit 的消息会被路由到该队列。</p></li><li class="lvl-2"><p>适用场景：模块化路由，如日志系统、事件驱动架构等。</p></li></ul><h2 id="Headers-Exchange（头部交换机）">Headers Exchange（头部交换机）</h2><ul class="lvl-0"><li class="lvl-2"><p>路由规则：消息的头部与队列的绑定头部匹配时，消息被路由到该队列。支持 x-match 参数（any 或 all）。即使配置了路由键也会忽略。</p></li><li class="lvl-2"><p>示例：如果队列绑定头部为 { “x-match”: “all”, “format”: “pdf”, “priority”: “high” }，则只有同时满足这两个条件的消息会被路由到该队列。</p></li><li class="lvl-2"><p>适用场景：多条件路由，如复杂过滤、动态路由等。</p></li></ul><h2 id="Local-Random-Exchange（本地随机交换机）">Local Random Exchange（本地随机交换机）</h2><ul class="lvl-0"><li class="lvl-2"><p>Local Random Exchange 是 RabbitMQ 4.0 引入的交换机类型，旨在优化<code>请求-响应</code>模式下的消息路由，特别适用于低延迟和高吞吐量的场景。通过结合独占队列使用，可以确保消息快速传递到本地消费者，减少网络延迟，提高系统性能。</p></li><li class="lvl-2"><p>路由规则：消息始终被路由到本地队列（位于同一节点上），如果有多个本地队列绑定，则随机选择一个进行投递。</p></li><li class="lvl-2"><p>示例：假设节点 A 上有两个绑定了 x-local-random 交换机的队列 Q1 和 Q2，发布的消息会随机路由到 Q1 或 Q2，但不会路由到其他节点的队列。</p></li><li class="lvl-2"><p>适用场景：请求-响应（RPC）模式下的低延迟通信，适合微服务架构中每个节点上都有消费者的场景。</p></li><li class="lvl-2"><p>在使用 Local Random Exchange 时，必须满足以下条件：</p><ul class="lvl-2"><li class="lvl-4">独占队列：消费者应声明独占队列，以确保队列仅绑定到当前节点。</li><li class="lvl-4">每个节点至少一个消费者：每个 RabbitMQ 节点上应至少有一个消费者，否则在该节点上发布的消息将被丢弃。</li><li class="lvl-4">交换机类型声明：使用 <code>x-local-random</code> 类型声明交换机。</li></ul></li></ul><h2 id="Exchange-与-Queue-绑定-Binding">Exchange 与 Queue 绑定(Binding)</h2><ul class="lvl-0"><li class="lvl-2"><p>创建好 Exchange 之后，需要将 Exchange 与 Queue 绑定，才能将消息发送到指定的队列。</p></li><li class="lvl-2"><p>Exchange 与 Queue 的绑定关系，即 Exchange 发送的消息，会根据路由键与队列的绑定键进行匹配，如果匹配成功，则将消息发送到对应的队列。</p></li><li class="lvl-2"><p>在 Exchange 页面点击 Exchange 的名称，进入 Exchange 详情页面，此处可以进行 Exchange 与 Queue 绑定配置<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/taKUjm.png" alt=""></p><blockquote><p>这里的<code>Arguments</code>用于设置 绑定 的其他参数，比如 <code>Headers Exchange</code> 需要设置 <code>x-match</code> 参数等。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RabbitMQ 的 Exchange 的基本概念和用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rabbitmq.com&quot;&gt;Zookeeper官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RabbitMQ 版本为 4.1.4。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo&quot;&gt;Java Client 示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 之 Queue</title>
    <link href="https://blog.hanqunfeng.com/2025/09/20/rabbitmq-queue/"/>
    <id>https://blog.hanqunfeng.com/2025/09/20/rabbitmq-queue/</id>
    <published>2025-09-20T13:30:05.000Z</published>
    <updated>2025-09-28T07:30:09.100Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 RabbitMQ 的 Queue 的基本概念和用法。</p></li><li class="lvl-2"><p><a href="https://www.rabbitmq.com">Zookeeper官网</a></p></li><li class="lvl-2"><p>本文使用的 RabbitMQ 版本为 4.1.4。</p></li><li class="lvl-2"><p><a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo">Java Client 示例</a></p></li></ul><span id="more"></span><h2 id="Queue-队列-是什么？">Queue(队列) 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>在 RabbitMQ 中，<a href="https://www.rabbitmq.com/docs/queues">队列（Queue）</a> 是一种用于存储消息的 数据结构，消息会一直保存在队列中，直到被应用程序或服务消费为止。</p></li><li class="lvl-2"><p>生产者（Publisher） 把消息放进队列，消费者（Consumer） 从队列中取出消息。队列中的消息会按照 FIFO（先进先出）的顺序进行消费。</p></li><li class="lvl-2"><p>队列在生产者和消费者之间起到缓冲区的作用。生产者不需要知道消费者的存在，它们只需把消息发送到队列。消费者可以根据自身处理速度，按需消费消息。</p></li><li class="lvl-2"><p>RabbitMQ 目前 支持三种队列类型：</p></li></ul><table><thead><tr><th>队列类型</th><th>描述</th><th>特点</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>Classic Queue（经典队列）</strong></td><td>最常用的队列类型，消息按 FIFO（先进先出）顺序存储和消费</td><td>支持持久化、优先级、TTL、死信等</td><td>大多数常规消息场景</td></tr><tr><td><strong>Quorum Queue（仲裁队列）</strong></td><td>基于 Raft 协议的队列，确保高可用和数据一致性</td><td>内置复制（副本数量可配置）、适合高可靠性场景，但吞吐量略低于经典队列</td><td>关键任务消息、高可靠性场景</td></tr><tr><td><strong>Stream Queue（流式队列）</strong></td><td>面向大量消息的高吞吐队列，支持消息按偏移量读取</td><td>类似 Kafka，可随机访问历史消息、顺序读取、可持久化大量消息</td><td>大数据流、日志处理、事件溯源</td></tr></tbody></table><h2 id="Classic-Queue-经典队列">Classic Queue(经典队列)</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.rabbitmq.com/docs/classic-queues">RabbitMQ 经典队列（原始队列类型）</a>是一种通用队列类型。实际上它是在 3.8.x 版本之前唯一的队列类型。</p></li><li class="lvl-2"><p>经典队列适用于数据安全不是优先事项的用例，因为存储在经典队列中的数据不会被复制。 经典队列使用非复制的 FIFO 队列实现。</p></li><li class="lvl-2"><p>经典队列不适合积累太多的消息，如果队列中积累的消息太多了，会严重影响客户端生产消息以及消费消息的性能。因此，经典队列主要用在数据量比较小，并且生产消息和消费消息的速度比较稳定的业务场景。比如内部系统之间的服务调用。</p></li><li class="lvl-2"><p>RabbitMQ 4.0 删除了对经典队列 <code>version1</code> 的支持，同时也不再支持将 经典队列 的消息在节点间复制。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/MAdpRV.png" alt=""></p></li><li class="lvl-2"><p>参数说明(每个版本可能都有变化，具体以页面显示为准)</p></li></ul><table><thead><tr><th>参数名称</th><th>配置参数名</th><th>数据类型</th><th>作用说明</th><th>备注 / 使用场景</th></tr></thead><tbody><tr><td><strong>Auto expire</strong></td><td><code>x-expires</code></td><td>整数（毫秒）</td><td>队列在 <strong>指定时间内无人使用（无消费者、无发布、无访问）</strong> 时自动删除</td><td>类似“队列空闲过期时间”，节省资源</td></tr><tr><td><strong>Message TTL</strong></td><td><code>x-message-ttl</code></td><td>整数（毫秒）</td><td>消息的 <strong>存活时间</strong>，超过时间后消息会被丢弃或发送到死信队列</td><td>用于限制消息时效性，如延迟消息或短期缓存</td></tr><tr><td><strong>Overflow behaviour</strong></td><td><code>x-overflow</code></td><td>字符串（<code>drop-head</code> 或 <code>reject-publish</code>）</td><td>当队列达到 <strong>最大长度</strong> 或 <strong>最大字节数</strong> 时的行为</td><td>- <code>drop-head</code>：丢弃最早的消息 <br> - <code>reject-publish</code>：拒绝新的消息</td></tr><tr><td><strong>Single active consumer</strong></td><td><code>x-single-active-consumer</code></td><td>布尔值（true/false）</td><td>是否启用 <strong>单活消费者模式</strong>，一次只允许一个消费者消费队列</td><td>用于严格顺序消费，保证某个消息不会被多个消费者同时处理</td></tr><tr><td><strong>Dead letter exchange (DLX)</strong></td><td><code>x-dead-letter-exchange</code></td><td>字符串</td><td>指定队列的 <strong>死信交换机</strong>，用于接收无法消费或过期的消息</td><td>常用于失败重试、消息补偿场景</td></tr><tr><td><strong>Dead letter routing key</strong></td><td><code>x-dead-letter-routing-key</code></td><td>字符串</td><td>消息转发到 DLX 时的 <strong>路由键</strong></td><td>可以灵活转发到不同队列</td></tr><tr><td><strong>Max length</strong></td><td><code>x-max-length</code></td><td>整数</td><td>队列中 <strong>最大消息条数</strong></td><td>超过时按照 Overflow behaviour 处理</td></tr><tr><td><strong>Max length bytes</strong></td><td><code>x-max-length-bytes</code></td><td>整数（字节）</td><td>队列中 <strong>消息总字节数上限</strong></td><td>超过时按照 Overflow behaviour 处理，适合大消息场景</td></tr><tr><td><strong>Maximum priority</strong></td><td><code>x-max-priority</code></td><td>整数</td><td>启用优先级队列时，队列可设置的 <strong>最大优先级值</strong></td><td>消息优先级范围是 0 到这个值，优先级高的消息先被消费</td></tr><tr><td><strong>Leader locator</strong></td><td><code>x-queue-leader-locator</code></td><td>字符串（<code>client-local</code>、<code>balanced</code>）</td><td>设置在集群节点上声明队列时，队列主节点（Leader）的选取规则</td><td><code>client-local</code>（默认）：选择客户端所在节点作为Leader <br> <code>balanced</code>：在节点间均衡Leader分布，用于 HA 队列优化</td></tr></tbody></table><h2 id="Quorum-Queue-仲裁队列">Quorum Queue(仲裁队列)</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.rabbitmq.com/docs/quorum-queues">仲裁队列（Quorum Queue）</a> 是 RabbitMQ 从3.8.0版本之后引入的一种现代队列类型，也是目前官方比较推荐的一种对列类型。未来有可能取代 经典队列 成为默认队列类型。</p></li><li class="lvl-2"><p>其基于 Raft 共识算法 实现 持久化、复制和高可用。它保证 数据安全性、可靠的主节点选举，即使在升级或集群波动期间也能保持高可用性。</p></li><li class="lvl-2"><p>仲裁队列支持 毒消息处理、至少一次死信投递 以及 AMQP 修改（AMQP.modified）的处理结果。</p></li><li class="lvl-2"><p>它适合 以数据安全为首要目标 的场景。与经典队列相比，Quorum是以牺牲很多高级队列特性为代价，来进一步保证消息在分布式环境下的高可靠。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/oQ8YiT.png" alt=""></p></li><li class="lvl-2"><p>仲裁队列（Quorum Queue）的 <code>Durability</code> 只能设置为 Durable(true)。<code>Auto delete</code> 只能为 No(false)。</p></li><li class="lvl-2"><p>参数说明(每个版本可能都有变化，具体以页面显示为准)</p></li></ul><table><thead><tr><th>参数名称</th><th>配置参数名</th><th>数据类型</th><th>作用说明</th><th>备注 / 使用场景</th></tr></thead><tbody><tr><td><strong>Auto expire</strong></td><td><code>x-expires</code></td><td>整数（毫秒）</td><td>队列在指定时间内无人使用（无消费者、无发布、无访问）时自动删除</td><td>节省资源，队列空闲过期时间</td></tr><tr><td><strong>Message TTL</strong></td><td><code>x-message-ttl</code></td><td>整数（毫秒）</td><td>队列中消息的生存时间，超过时间后消息会被丢弃或转入死信队列</td><td>控制消息时效性</td></tr><tr><td><strong>Overflow behaviour</strong></td><td><code>x-overflow</code></td><td>字符串（<code>drop-head</code> 或 <code>reject-publish</code>）</td><td>当队列达到最大长度时的处理方式</td><td><code>drop-head</code>：丢弃最早消息，<code>reject-publish</code>：拒绝新消息</td></tr><tr><td><strong>Single active consumer</strong></td><td><code>x-single-active-consumer</code></td><td>布尔值（true/false）</td><td>是否启用单活消费者模式，一次只允许一个消费者消费队列</td><td>保证严格顺序消费</td></tr><tr><td><strong>Dead letter exchange (DLX)</strong></td><td><code>x-dead-letter-exchange</code></td><td>字符串</td><td>指定队列的死信交换机，用于接收无法消费或过期的消息</td><td>与 DLX 配合使用处理失败消息</td></tr><tr><td><strong>Dead letter routing key</strong></td><td><code>x-dead-letter-routing-key</code></td><td>字符串</td><td>消息转发到 DLX 时的路由键</td><td>灵活路由死信消息</td></tr><tr><td><strong>Max length</strong></td><td><code>x-max-length</code></td><td>整数</td><td>队列中最大消息条数</td><td>超过时按 Overflow behaviour 处理</td></tr><tr><td><strong>Max length bytes</strong></td><td><code>x-max-length-bytes</code></td><td>整数（字节）</td><td>队列消息总字节数上限</td><td>超过时按 Overflow behaviour 处理</td></tr><tr><td><strong>Delivery limit</strong></td><td><code>x-delivery-limit</code></td><td>整数</td><td>消息允许投递的最大次数，超过后变为死信</td><td>控制消息重试次数</td></tr><tr><td><strong>Initial cluster size</strong></td><td><code>x-quorum-initial-group-size</code></td><td>整数</td><td>队列在创建时需要的最小节点数</td><td>用于保证仲裁队列的高可用性</td></tr><tr><td><strong>Target cluster size</strong></td><td><code>x-quorum-target-group-size</code></td><td>整数</td><td>队列运行时的目标节点数</td><td>当集群节点变化时，仲裁队列会尝试调整副本数量</td></tr><tr><td><strong>Dead letter strategy</strong></td><td><code>x-dead-letter-strategy</code></td><td>字符串（<code>at-most-once</code>、<code>at-least-once</code>）</td><td>设置仲裁队列的死信处理策略</td><td>仅适用于 Quorum Queue。<br><code>at-most-once</code>（默认）：消息最多投递一次，可能丢失。<br><code>at-least-once</code>：确保消息至少投递一次，必须将 Overflow behaviour 设置为 <code>reject-publish</code>，否则回退到 <code>at-most-once</code>。</td></tr><tr><td><strong>Leader locator</strong></td><td><code>x-queue-leader-locator</code></td><td>字符串（<code>client-local</code>、<code>balanced</code>）</td><td>设置在集群节点上声明队列时，队列主节点（Leader）的选取规则</td><td><code>client-local</code>：选择客户端所在节点作为 Leader <br> <code>balanced</code>：在节点间均衡 Leader 分布</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Quorum Queues 和 Classic Queues 的功能对比如下：</p></li></ul><table><thead><tr><th>Feature</th><th>中文含义</th><th>Classic queues</th><th>Quorum queues</th><th>说明</th></tr></thead><tbody><tr><td>Non-durable queues</td><td>非持久化队列</td><td>yes</td><td>no</td><td>Quorum queues 总是持久化，不支持非持久化</td></tr><tr><td>Message replication</td><td>消息复制</td><td>no</td><td>yes</td><td>Quorum queues 内置消息复制，Classic queues 需镜像策略</td></tr><tr><td>Exclusivity</td><td>独占队列</td><td>yes</td><td>no</td><td>Classic queues 支持独占队列，Quorum queues 不支持独占</td></tr><tr><td>Per message persistence</td><td>消息级持久化</td><td>per message</td><td>always</td><td>Quorum queues 消息总是持久化</td></tr><tr><td>Membership changes</td><td>节点成员变更</td><td>no</td><td>semi-automatic</td><td>Quorum queues 节点变化时半自动处理复制</td></tr><tr><td>Message TTL (Time-To-Live)</td><td>消息存活时间</td><td>yes</td><td>yes</td><td>两者都支持消息过期时间</td></tr><tr><td>Queue TTL</td><td>队列存活时间</td><td>yes</td><td>partially</td><td>Quorum queues 的 lease 不会因重新声明而续期</td></tr><tr><td>Queue length limits</td><td>队列长度限制</td><td>yes</td><td>yes</td><td>Quorum queues 支持长度限制，但 <code>x-overflow=reject-publish-dlx</code> 不支持</td></tr><tr><td>Keeps messages in memory</td><td>消息内存保存</td><td>see Classic Queues</td><td>never</td><td>Quorum queues 消息总是写入磁盘，不保留在内存</td></tr><tr><td>Message priority</td><td>消息优先级</td><td>yes</td><td>yes</td><td>支持消息优先级</td></tr><tr><td>Single Active Consumer</td><td>单活消费者</td><td>yes</td><td>yes</td><td>支持单活消费者</td></tr><tr><td>Consumer exclusivity</td><td>独占消费者</td><td>yes</td><td>no</td><td>Quorum queues 不支持独占消费者，需使用 Single Active Consumer</td></tr><tr><td>Consumer priority</td><td>消费者优先级</td><td>yes</td><td>yes</td><td>支持消费者优先级</td></tr><tr><td>Dead letter exchanges</td><td>死信交换机</td><td>yes</td><td>yes</td><td>支持死信交换机</td></tr><tr><td>Adheres to policies</td><td>遵循策略</td><td>yes</td><td>yes</td><td>支持策略，但 Quorum queues 的部分策略行为不同</td></tr><tr><td>Poison message handling</td><td>毒消息处理</td><td>no</td><td>yes</td><td>Quorum queues 支持毒消息处理</td></tr><tr><td>Server-named queues</td><td>服务器自动命名队列</td><td>yes</td><td>no</td><td>Quorum queues 不支持服务器自动命名队列</td></tr></tbody></table><h2 id="Stream-流">Stream(流)</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.rabbitmq.com/docs/streams">Stream</a> 是RabbitMQ自 3.9.0 版本开始引入的一种新的数据队列类型。这种队列类型的消息是持久化到磁盘并且具备分布式备份的，更适合于消费者多，读消息非常频繁的场景。</p></li><li class="lvl-2"><p>Stream 的核心是以append-only只添加的日志来记录消息，整体来说，就是消息将以append-only的方式持久化到日志文件中，然后通过调整每个消费者的消费进度offset，来实现消息的多次分发。</p></li><li class="lvl-2"><p>Stream 不支持死信交换机，不支持处理毒消息。</p></li><li class="lvl-2"><p>实际上 Stream 不属于队列，流（Streams） 是一种 持久化、可复制的数据结构，功能上类似队列：从生产者缓冲消息供消费者读取。但它与队列有两个重要区别：</p><ul class="lvl-2"><li class="lvl-4">存储模型 – 流是 追加日志（append-only log），消息可以 重复读取直到过期。</li><li class="lvl-4">消费模型 – 流提供 非破坏性消费语义（non-destructive consumer semantics），多个消费者可以多次读取同一条消息而不会删除它。</li></ul></li><li class="lvl-2"><p>Stream 始终是持久化和复制的，保证数据安全。消费者可以通过 RabbitMQ 客户端库 或 专用二进制协议插件 读取流，其中插件方式可以 访问所有流特性 并提供 最佳性能。合理的客户端连接策略有助于提升 吞吐量和效率。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/8KqZY9.png" alt=""></p></li><li class="lvl-2"><p>参数说明(每个版本可能都有变化，具体以页面显示为准)</p></li></ul><table><thead><tr><th>参数名称</th><th>配置参数名</th><th>数据类型</th><th>作用说明</th><th>备注 / 使用场景</th></tr></thead><tbody><tr><td><strong>Max length bytes</strong></td><td><code>x-max-length-bytes</code></td><td>整数（字节）</td><td>流中允许存储的 <strong>最大数据总字节数</strong></td><td>超过时流将停止接收新消息，适合控制存储容量</td></tr><tr><td><strong>Max time retention</strong></td><td><code>x-max-age</code></td><td>字符串（时间单位，例如 <code>1h</code>, <code>30m</code>, <code>1d</code>）</td><td>设置流队列中消息的 <strong>最大保留时间</strong>，超过时间的消息会被删除</td><td>支持时间单位：Y=年, M=月, D=天, h=小时, m=分钟, s=秒。例如 <code>&quot;1h&quot;</code> 表示只保留最近 1 小时的消息，用于控制数据量和自动清理过期消息</td></tr><tr><td><strong>Max segment size in bytes</strong></td><td><code>x-stream-max-segment-size</code></td><td>整数（字节）</td><td>流分段存储时的 <strong>每个段的最大字节数</strong></td><td>控制单个文件段大小，有利于 I/O 性能和管理</td></tr><tr><td><strong>Filter size (per chunk) in bytes</strong></td><td><code>x-stream-filter-size-bytes</code></td><td>整数（字节）</td><td>流内部 <strong>过滤索引每块的大小</strong></td><td>用于加速消息定位和读取，影响内存使用和检索效率</td></tr><tr><td><strong>Initial cluster size</strong></td><td><code>x-initial-cluster-size</code></td><td>整数</td><td>流在创建时的 <strong>最小节点数</strong></td><td>保证流的复制和高可用性</td></tr><tr><td><strong>Leader locator</strong></td><td><code>x-queue-leader-locator</code></td><td>字符串（<code>client-local</code>、<code>balanced</code>）</td><td>设置在集群节点上声明流时，主节点（Leader）的选取规则</td><td><code>client-local</code>：客户端所在节点作为 Leader（默认）<br><code>balanced</code>：在节点间均衡 Leader 分布，用于优化 HA</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Classic Queue vs Stream Queue Feature Matrix</p></li></ul><table><thead><tr><th>Feature</th><th>中文含义</th><th>Classic queues</th><th>Stream queues</th><th>说明</th></tr></thead><tbody><tr><td>Non-durable queues</td><td>非持久化队列</td><td>yes</td><td>no</td><td>Stream 队列总是持久化，不支持非持久化</td></tr><tr><td>Exclusivity</td><td>独占队列</td><td>yes</td><td>no</td><td>Classic 队列支持独占，Stream 队列不支持独占</td></tr><tr><td>Per message persistence</td><td>消息级持久化</td><td>per message</td><td>always</td><td>Stream 队列的消息总是持久化</td></tr><tr><td>Membership changes</td><td>节点成员变更</td><td>no</td><td>manual</td><td>Stream 队列节点变更需要手动管理</td></tr><tr><td>TTL</td><td>消息存活时间</td><td>yes</td><td>no (but see Retention)</td><td>Stream 队列没有消息 TTL，但可通过 Retention 控制过期</td></tr><tr><td>Queue length limits</td><td>队列长度限制</td><td>yes</td><td>no (but see Retention)</td><td>Stream 队列没有固定长度限制，通过 Retention 控制数据量</td></tr><tr><td>Keeps messages in memory</td><td>消息内存保存</td><td>see Classic Queues</td><td>never</td><td>Stream 队列消息不保存在内存中，只写入磁盘</td></tr><tr><td>Message priority</td><td>消息优先级</td><td>yes</td><td>no</td><td>Stream 队列不支持消息优先级</td></tr><tr><td>Consumer priority</td><td>消费者优先级</td><td>yes</td><td>no</td><td>Stream 队列不支持消费者优先级</td></tr><tr><td>Dead letter exchanges</td><td>死信交换机</td><td>yes</td><td>no</td><td>Stream 队列不支持死信交换机</td></tr><tr><td>Adheres to policies</td><td>遵循策略</td><td>yes</td><td>yes (see Retention)</td><td>Stream 队列支持策略，但主要通过 Retention 控制行为</td></tr><tr><td>Reacts to memory alarms</td><td>内存告警响应</td><td>yes</td><td>no (uses minimal RAM)</td><td>Stream 队列使用最小内存，不触发内存告警</td></tr><tr><td>Poison message handling</td><td>毒消息处理</td><td>no</td><td>no</td><td>Stream 队列不支持毒消息处理</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>我们可以激活<code>流插件</code>来使用流的特有功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_stream rabbitmq_stream_management</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>激活<code>流插件</code>后，Stream队列的操作方式可以更高级，具体可以参考<a href="https://www.rabbitmq.com/tutorials/tutorial-two-java-stream">官方文档</a>，作者在<a href="https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo/rabbitmq-stream">Java Client 示例</a>中也给出了示例代码。</p></li></ul><h3 id="超级流-Super-Streams">超级流(Super Streams)</h3><ul class="lvl-0"><li class="lvl-2"><p>超级流（Super streams） 是一种通过将一个大的流分区成更小的流来实现扩展的方式。它们与 单个消费者（Single Active Consumer） 集成，以在分区内保持消息顺序。超级流从 RabbitMQ 3.11 开始可用。</p></li><li class="lvl-2"><p>一个超级流是由多个普通流组成的逻辑流。它是一种通过 RabbitMQ Streams 来扩展发布和消费的方法：一个大型逻辑流被划分成多个分区流，将存储和流量分散到多个集群节点上。</p></li><li class="lvl-2"><p>超级流依然是一个逻辑实体：由于客户端库的智能化处理，应用程序会把它视为一个“大型”流。超级流的拓扑结构基于 AMQP 0.9.1 模型，也就是交换机（exchange）、队列（queue）和它们之间的绑定（binding）。</p></li><li class="lvl-2"><p>可以使用任何 AMQP 0.9.1 库或管理插件创建超级流的拓扑。它需要创建一个直连交换机（direct exchange）、分区流（partition streams），并将它们绑定在一起。</p></li><li class="lvl-2"><p>通过管理控制台创建超级流<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/j2G1HC.png" alt=""></p></li><li class="lvl-2"><p>也可以通过命令创建超级流，以下是如何用命令创建一个包含 3 个分区的超级流：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq-streams add_super_stream [-p &lt;vhost&gt;] &lt;stream-name&gt; [--partitions &lt;number&gt;]</span></span><br><span class="line">rabbitmq-streams add_super_stream -p /vtest sq_3 --partitions 3</span><br></pre></td></tr></table></figure><blockquote><p>创建的Stream<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/4py5OE.png" alt=""><br>创建的 Exchange，名称 sq_3<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/EwfTRM.png" alt=""><br>绑定关系<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/NErhQX.png" alt=""></p></blockquote><h2 id="队列类型扩展">队列类型扩展</h2><h3 id="懒队列">懒队列</h3><ul class="lvl-0"><li class="lvl-2"><p>从3.6.x版本到3.12.x版本，RabbitMQ提供了一种针对Classic Queue的优化配置，<code>lazy-mode</code>，<a href="https://www.rabbitmq.com/docs/lazy-queues">懒对列</a>。懒队列会尽可能早的将消息内容保存到硬盘当中，并且只有在用户请求到时，才临时从硬盘加载到RAM内存当中。</p></li><li class="lvl-2"><p>默认情况下，RabbitMQ接收到消息时，会保存到内存以便使用，同时把消息写到硬盘。但是，消息写入硬盘的过程中，是会阻塞队列的。RabbitMQ虽然针对写入硬盘速度做了很多算法优化，但是在长队列中，依然表现不是很理想，所以就有了懒队列的出现。</p></li><li class="lvl-2"><p>懒队列会尝试尽可能早的把消息写到硬盘中。这意味着在正常操作的大多数情况下，RAM中要保存的消息要少得多。当然，这是以增加磁盘IO为代价的。</p></li><li class="lvl-2"><p>懒队列适合消息量大且长期有堆积的队列，可以减少内存使用，加快消费速度。但是这是以大量消耗集群的网络及磁盘IO为代价的。</p></li><li class="lvl-2"><p>从3.12往后的版本中，RabbitMQ 不再支持“惰性”模式，因为 经典队列 当前的特性就类似于以前的 懒队列。</p></li></ul><h3 id="死信队列">死信队列</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.rabbitmq.com/docs/dlx">死信队列（Dead Letter Queue）</a>，新版中叫做 死信交换机（Dead Letter Exchange, DLX），是RabbitMQ对于未能正常消费的消息进行的一种补救机制，用于保存无法被正常处理的消息。当消息被消费者处理失败时，RabbitMQ会将消息发送到死信队列中，等待消费者处理。</p></li><li class="lvl-2"><p>死信队列也是一个普通的队列，同样可以在队列上声明消费者，继续对消息进行消费处理。</p></li><li class="lvl-2"><p>有以下几种情况，RabbitMQ会将一个正常消息转成死信</p><ul class="lvl-2"><li class="lvl-4">消息被拒绝（Message rejection）<ul class="lvl-4"><li class="lvl-6">由 AMQP 1.0 接收端使用 rejected 结果拒绝</li><li class="lvl-6">由 AMQP 0.9.1 消费者使用 basic.reject 或 basic.nack，并且参数 requeue=false</li></ul></li><li class="lvl-4">消息过期（Message expiration）<ul class="lvl-4"><li class="lvl-6">消息超过其配置的 TTL（生存时间） 后过期。</li></ul></li><li class="lvl-4">队列长度超限（Queue length exceeded）<ul class="lvl-4"><li class="lvl-6">队列中的消息数量或总字节数达到配置的最大限制后，被丢弃的消息会死信化。</li></ul></li><li class="lvl-4">投递次数超限（仅适用于仲裁队列 Quorum Queue）<ul class="lvl-4"><li class="lvl-6">消息的投递次数超过了仲裁队列中配置的 delivery-limit。</li></ul></li></ul></li><li class="lvl-2"><p>使用场景</p><ul class="lvl-2"><li class="lvl-4">你可以在队列上配置 死信交换机（DLX） 和 死信路由键（Dead Letter Routing Key）。</li><li class="lvl-4">当消息成为死信时，会被 重新发布到 DLX，这样你可以：<ul class="lvl-4"><li class="lvl-6">做错误日志记录</li><li class="lvl-6">进行失败消息重试</li><li class="lvl-6">用于监控和告警</li></ul></li></ul></li><li class="lvl-2"><p>死信交换机的配置方法（How Dead Lettering is Configured）</p><ul class="lvl-2"><li class="lvl-4">在 RabbitMQ 中，任何队列都可以通过 客户端 或者 策略（policies） 来配置 死信交换机（DLX）。</li><li class="lvl-4">配置时主要涉及两个核心参数：</li></ul></li></ul><table><thead><tr><th>配置参数名</th><th>说明</th></tr></thead><tbody><tr><td><strong>dead-letter-exchange</strong></td><td>指定用于接收死信消息的 <strong>死信交换机名称</strong></td></tr><tr><td><strong>dead-letter-routing-key</strong></td><td>指定死信消息重新发布时使用的 <strong>路由键（Routing Key）</strong></td></tr></tbody></table><blockquote><p>死信在转移到死信队列时，他的 routingkey 也会保存下来。但是如果配置了 <code>x-dead-letter-routing-key</code> 这个参数的话，routingkey 就会被替换为配置的这个值。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>在创建队列时，我们可以通过为队列添加 <code>x-dead-letter-exchange</code> 和 <code>x-dead-letter-routing-key</code> 参数，来指定 死信交换机（DLX）和 死信路由键（Dead Letter Routing Key）。但是这样做很麻烦，每个队列都要单独配置，因此，我们可以使用 策略（policies） 来统一配置。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅指定死信交换机，这里交换机的名称是 my-dlx，交换机要提前创建好</span></span><br><span class="line">rabbitmqctl set_policy DLX <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;&#125;&#x27;</span> --apply-to queues --priority 7</span><br><span class="line"><span class="comment"># 同时指定 死信交换机 和 路由键</span></span><br><span class="line">rabbitmqctl set_policy DLX <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;, &quot;dead-letter-routing-key&quot;:&quot;my-routing-key&quot;&#125;&#x27;</span> --apply-to queues --priority 7</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数说明：</p></li></ul><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>rabbitmqctl</code></td><td>RabbitMQ 的命令行管理工具</td></tr><tr><td><code>set_policy</code></td><td>设置一个策略（Policy），用于动态配置交换机、队列或绑定的参数</td></tr><tr><td><code>DLX</code></td><td>策略的名称，用户自定义，例如这里叫 <code>DLX</code></td></tr><tr><td><code>&quot;.*&quot;</code></td><td>正则表达式，匹配对象的名称。<code>.*</code> 表示匹配 <strong>所有队列</strong>，也可以指定具体队列名，比如 <code>^my-queue$</code></td></tr><tr><td><code>&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;, &quot;dead-letter-routing-key&quot;:&quot;my-routing-key&quot;&#125;</code></td><td>策略内容，这里设置了死信交换机名称和路由键：<br> - <code>dead-letter-exchange</code>: 设置死信交换机名称为 <code>my-dlx</code><br> - <code>dead-letter-routing-key</code>: 设置路由键为 <code>my-routing-key</code></td></tr><tr><td><code>--apply-to queues</code></td><td>指定策略作用对象为 <strong>队列（queues）</strong>，而不是交换机（exchanges）或绑定（bindings）</td></tr><tr><td><code>--priority 7</code></td><td>策略的优先级，值越大优先级越高。多个策略作用在同一对象时，优先级高的会覆盖低的</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>执行这条命令后：</p><ul class="lvl-2"><li class="lvl-4">所有队列都会自动带上 <code>x-dead-letter-exchange=my-dlx</code> 和 <code>x-dead-letter-routing-key=my-routing-key</code> 配置。</li><li class="lvl-4">队列中被拒绝、过期、超长或超过投递次数的消息会被重新发布到 <code>my-dlx</code> 交换机，并使用 <code>my-routing-key</code> 作为路由键。</li></ul></li><li class="lvl-2"><p>消息被作为死信转移到死信队列后，会在Header当中增加⼀些消息。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x-first-death-queue：该消息首次成为死信时所在的队列名称</span><br><span class="line">x-first-death-reason：该消息首次被判定为死信的原因</span><br><span class="line">x-first-death-exchange：该消息在首次成为死信前被发布到的交换机名称</span><br><span class="line">x-last-death-queue：该消息最近一次成为死信时所在的队列名称</span><br><span class="line">x-last-death-reason：该消息最近一次被判定为死信的原因</span><br><span class="line">x-last-death-exchange：该消息在最近一次成为死信前被发布到的交换机名称</span><br></pre></td></tr></table></figure><h3 id="延迟队列">延迟队列</h3><ul class="lvl-0"><li class="lvl-2"><p>延迟队列（Delayed Message Queue）: 延迟队列是一种特殊类型的队列，用于延迟消息的投递。</p></li><li class="lvl-2"><p>RabbitMQ中，是不存在延迟队列的功能的，而通常如果要用到延迟队列，就会采用 <code>TTL</code> + <code>死信队列</code> 的方式来实现。</p></li><li class="lvl-2"><p>延迟队列的实现原理：</p><ul class="lvl-2"><li class="lvl-4">创建一个普通队列，并设置队列的 TTL（x-message-ttl）参数，以及指定一个死信队列(x-dead-letter-exchange)</li><li class="lvl-4">当消息的 TTL 到期时，消息会被自动从当前队列中删除，并进入死信队列。</li><li class="lvl-4">为死信队列创建一个消费者，并监听死信队列，处理延迟消息。</li></ul></li></ul><h3 id="优先级队列">优先级队列</h3><ul class="lvl-0"><li class="lvl-2"><p>优先级队列（Priority Queue）: RabbitMQ 支持为经典队列（classic queues）添加“优先级”功能。启用“优先级”功能的经典队列通常被称为“优先级队列”（priority queues）。</p></li><li class="lvl-2"><p>RabbitMQ 支持 1 到 255 之间的优先级值，但强烈建议使用 1 到 5 之间的值。需要注意的是，优先级值越高，会消耗更多的 CPU 和内存资源，因为 RabbitMQ 在内部需要为每个优先级（从 1 到最大配置值）维护一个子队列。</p></li><li class="lvl-2"><p>只有经典队列支持通过参数<code>x-max-priority</code>指定队列支持的最大优先级，且不支持 通过 策略（policies） 将经典队列声明为优先级队列。</p></li><li class="lvl-2"><p>发布消息时，可以通过参数 <code>priority</code> 指定消息的优先级。是的，消息也是可以设置参数的。</p></li><li class="lvl-2"><p>优先级队列如何与消费者协同工作</p><ul class="lvl-2"><li class="lvl-4">若消费者连接到一个 空队列，然后消息陆续被发布，那么这些消息可能 不会 在队列中等待（即刚发布就被消费者接收），此时优先级功能没有机会上场。优先级是在消息排队（ready 消息）状态时才能体现其作用。</li><li class="lvl-4">推荐在消费者端使用 basic.qos(prefetch) 设置（在 manual ack 模式下），以限制消费者同时处理的未确认消息数。这样能让优先级的分级效果更加明显，因为如果 prefetch 数量未满，高优先级消息可以先被取出。</li></ul></li><li class="lvl-2"><p>注意事项</p><ul class="lvl-2"><li class="lvl-4">未设置 <code>priority</code> 的消息 会被当作优先级 0 处理。若消息指定的优先级大于队列的最大值（x-max-priority），则该消息的优先级就是<code>x-max-priority</code>。</li><li class="lvl-4">TTL / 消息过期 (message expiration)：即使设置了 TTL，过期的消息只会在队列头被检查。这意味着如果一个低优先级的消息在前面但还没过期，而高优先级的消息在后面，低优先级的消息可能会阻塞队列头，导致高优先级的消息被延迟。</li><li class="lvl-4">队列最大长度限制 (max-length)：如果队列设置了最大长度，队列会从头部 (head) 丢弃消息以维持长度限制。这可能导致高优先级消息也被丢弃，从而违背直觉。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 RabbitMQ 的 Queue 的基本概念和用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rabbitmq.com&quot;&gt;Zookeeper官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文使用的 RabbitMQ 版本为 4.1.4。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo&quot;&gt;Java Client 示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/"/>
    
    <category term="分布式" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/rabbitmq/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="rabbitmq" scheme="https://blog.hanqunfeng.com/tags/rabbitmq/"/>
    
  </entry>
  
</feed>
