<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-07-20T06:04:20.219Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K8S 之 Horizontal Pod Autoscaler（HPA）</title>
    <link href="https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/"/>
    <id>https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/</id>
    <published>2025-07-20T13:30:05.000Z</published>
    <updated>2025-07-20T06:04:20.219Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/autoscaling/">Autoscaling k8s简介</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/">Horizontal Pod Autoscaler（HPA）</a></p></li></ul><span id="more"></span><h2 id="Horizontal-Pod-Autoscaler（HPA）-简介">Horizontal Pod Autoscaler（HPA） 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Horizontal Pod Autoscaler（HPA）基于资源 CPU 利用率自动调整 deployment、replication controller 或者 replica 中 pod 的数量，这有助于您的应用程序进行扩展以满足增长的需求，或在不需要资源时进行缩减，从而释放出节点用于其他应用程序。当您设置目标 CPU 利用率百分比时，HPA 扩展或缩减应用程序来尝试满足该目标。</p></li><li class="lvl-2"><p>Kubernetes 本身已经包含了 HPA 的 controller，所以不需要额外的安装或部署。</p></li><li class="lvl-2"><p>HPA 需要获取 metrics 信息，metrics 信息需要从 Metrics Server 中获取，所以需要先安装 Metrics Server。</p></li><li class="lvl-2"><p>HPA 会周期性(默认15秒)查询目标资源的使用情况，然后和 HPA 中定义的值做比较，并根据比较结果相应的调整 pod 数量。</p></li><li class="lvl-2"><p>创建pod时，必须为其设定cpu资源，用于与目标值进行比较，目前最新的v2版本的HPA除了支持CPU的对比，还可以设定其它指标，具体参考<a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">HorizontalPodAutoscaler 演练</a>中的“基于多项度量指标和自定义度量指标自动扩缩”。</p></li><li class="lvl-2"><p>博主之前写过一篇在aws的eks中使用hpa的文章 <a href="/2023/07/17/aws-eks17-hpa/" title="AWS-EKS-17--Horizontal Pod Autoscaler（HPA）">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>，和在自己搭建 k8s集群 中使用 hpa 基本一致，所以本文不再对重复内容进行赘述，建议读者先阅读 <a href="/2023/07/17/aws-eks17-hpa/" title="AWS-EKS-17--Horizontal Pod Autoscaler（HPA）">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>。</p></li></ul><h2 id="安装-Metrics-Server">安装 Metrics Server</h2><ul class="lvl-0"><li class="lvl-2"><p>Kubernetes 的 HPA 是依赖 Metrics API 的，默认并不内置。需要通过 metrics-server 来收集和提供节点/Pod 的资源用量数据（CPU、内存等）。</p></li><li class="lvl-2"><p>安装 <a href="https://github.com/kubernetes-sigs/metrics-server">metrics-server</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L -o metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br><span class="line">$ kubectl apply -f metrics-server.yaml</span><br><span class="line">serviceaccount/metrics-server created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class="line">service/metrics-server created</span><br><span class="line">deployment.apps/metrics-server created</span><br><span class="line">apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>部署后发现pod没有运行成功</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$  k get all -n kube-system -l k8s-app=metrics-server</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/metrics-server-867d48dc9c-fgdjq   0/1     Running   0          16s</span><br><span class="line"></span><br><span class="line">NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/metrics-server   ClusterIP   10.96.91.221   &lt;none&gt;        443/TCP   16s</span><br><span class="line"></span><br><span class="line">NAME                             READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/metrics-server   0/1     1            0           16s</span><br><span class="line"></span><br><span class="line">NAME                                        DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/metrics-server-867d48dc9c   1         1         0       16s</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>检查日志</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ k logs deployment.apps/metrics-server -n kube-system</span><br><span class="line"><span class="comment">## 输出类似于</span></span><br><span class="line">E0703 23:02:38.120831       1 scraper.go:149] <span class="string">&quot;Failed to scrape node&quot;</span> err=<span class="string">&quot;Get \&quot;https://10.211.55.15:10250/metrics/resource\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.15 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class="string">&quot;k8s-worker1&quot;</span></span><br><span class="line">E0703 23:02:38.127774       1 scraper.go:149] <span class="string">&quot;Failed to scrape node&quot;</span> err=<span class="string">&quot;Get \&quot;https://10.211.55.16:10250/metrics/resource\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.16 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class="string">&quot;k8s-worker2&quot;</span></span><br><span class="line">E0703 23:02:38.140583       1 scraper.go:149] <span class="string">&quot;Failed to scrape node&quot;</span> err=<span class="string">&quot;Get \&quot;https://10.211.55.11:10250/metrics/resource\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.11 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class="string">&quot;k8s-master&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>意思是 metrics-server 在通过 https://<node-ip>:10250 请求 kubelet 的时候，发现 kubelet 的证书不包含该 IP 的 Subject Alternative Name (SAN)，因此 TLS 校验失败。</p></li><li class="lvl-2"><p>解决方案: 添加 --kubelet-insecure-tls 参数，跳过 kubelet 的 TLS 证书校验(metrics-server 本身权限有限，风险可控，kubelet 自签证书维护成本高)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deployment metrics-server -n kube-system</span><br><span class="line"><span class="comment">## 在 args 中添加 --kubelet-insecure-tls</span></span><br><span class="line">  spec:</span><br><span class="line">    containers:</span><br><span class="line">    - args:</span><br><span class="line">      - --cert-dir=/tmp</span><br><span class="line">      - --secure-port=10250</span><br><span class="line">      - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">      - --kubelet-use-node-status-port</span><br><span class="line">      - --metric-resolution=15s</span><br><span class="line">      - --kubelet-insecure-tls   <span class="comment"># 添加此行</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>wq</code>保存后，等一会再次查看所有资源均已正常</p></li><li class="lvl-2"><p>查看所有 node 的资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ k top nodes</span><br><span class="line">NAME          CPU(cores)   CPU(%)   MEMORY(bytes)   MEMORY(%)</span><br><span class="line">k8s-master    216m         10%      1712Mi          44%</span><br><span class="line">k8s-worker1   79m          3%       1025Mi          26%</span><br><span class="line">k8s-worker2   82m          4%       982Mi           25%</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><strong>NAME</strong></td><td>节点名称，Kubernetes 集群的节点名字。</td></tr><tr><td><strong>CPU(cores)</strong></td><td>当前节点 CPU 的瞬时使用量，单位是核心数（Core），比如 <code>216m</code> = 0.216 核心。<code>m</code> = <strong>millicores</strong>，1000m = 1核。</td></tr><tr><td><strong>CPU(%)</strong></td><td>当前 CPU 使用率，相对于该节点 CPU 总核数的百分比。比如 <code>10%</code> 表示节点 CPU 的 10% 被使用。</td></tr><tr><td><strong>MEMORY(bytes)</strong></td><td>节点当前使用的内存，单位是字节（例如 <code>1712Mi</code> = 1712 Mebibytes ≈ 1.7 GB）。</td></tr><tr><td><strong>MEMORY(%)</strong></td><td>节点内存使用率，占总内存的百分比。比如 <code>44%</code> 表示该节点内存使用了 44%。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>查看所有 pod 的资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ k top pods -A</span><br><span class="line">NAMESPACE     NAME                                       CPU(cores)   MEMORY(bytes)</span><br><span class="line">default       nginx-5869d7778c-5682r                     0m           9Mi</span><br><span class="line">default       nginx-5869d7778c-thw8f                     0m           4Mi</span><br><span class="line">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   6m           35Mi</span><br><span class="line">kube-system   calico-node-7pbbq                          42m          281Mi</span><br><span class="line">kube-system   calico-node-v4hzr                          47m          260Mi</span><br><span class="line">kube-system   calico-node-w47qq                          40m          263Mi</span><br><span class="line">kube-system   coredns-674b8bbfcf-2tvld                   2m           23Mi</span><br><span class="line">kube-system   coredns-674b8bbfcf-h6kx7                   2m           22Mi</span><br><span class="line">kube-system   etcd-k8s-master                            27m          85Mi</span><br><span class="line">kube-system   kube-apiserver-k8s-master                  49m          404Mi</span><br><span class="line">kube-system   kube-controller-manager-k8s-master         28m          100Mi</span><br><span class="line">kube-system   kube-proxy-nkbns                           1m           41Mi</span><br><span class="line">kube-system   kube-proxy-plqw8                           1m           25Mi</span><br><span class="line">kube-system   kube-proxy-sbgh6                           1m           34Mi</span><br><span class="line">kube-system   kube-scheduler-k8s-master                  8m           38Mi</span><br><span class="line">kube-system   metrics-server-56fb9549f4-rtt7n            4m           21Mi</span><br></pre></td></tr></table></figure><h2 id="创建-HPA">创建 HPA</h2><ul class="lvl-0"><li class="lvl-2"><p>前面的文章中多次使用 nginx 镜像创建了 deployment，但是都没有配置过资源，为了测试 hpa，需要为其指定资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改 deployment，保存后立刻生效</span></span><br><span class="line">kubectl edit deployment nginx</span><br><span class="line"><span class="comment"># 增加资源限制</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: 1   <span class="comment"># 修改副本数位 1</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 500Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 200m</span><br><span class="line">            memory: 200Mi</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>命令行创建 HPA</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了一个叫“hpa-nginx”的 HPA，默认与 deployment 的名称相同，可以用 --name=&#x27;hpa-nginx&#x27; 指定hpa的名称</span></span><br><span class="line"><span class="comment"># replicas 变动范围是最小 3，最大 10</span></span><br><span class="line"><span class="comment"># 目标cpu利用率为 50%，上面我们设定 CPU request 值为 100m，所以当平均cpu值为 100m 时就会触发 autoscale</span></span><br><span class="line"><span class="comment"># 这里说平均cpu，是指所有pod的cpu利用率的平均值</span></span><br><span class="line">$ k autoscale deployment nginx --name=<span class="string">&quot;hpa-nginx&quot;</span> --cpu-percent=50 --min=3 --max=10</span><br><span class="line">horizontalpodautoscaler.autoscaling/hpa-nginx autoscaled</span><br><span class="line"><span class="comment"># 观察，大约 15秒后，hpa-nginx 发现 replicas 值为1，30秒的时候自动扩容到3个，因为我们设置的hpa的replicas最小值为3，并且采集到了cpu使用率</span></span><br><span class="line">$ k get hpa -w</span><br><span class="line">NAME        REFERENCE          TARGETS              MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        0          0s</span><br><span class="line">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        1          15s</span><br><span class="line">hpa-nginx   Deployment/nginx   cpu: 0%/50%          3         10        3          30s</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ymal文件创建 HPA</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span>    <span class="comment"># api版本，这里设置为 v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span> <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-nginx</span>             <span class="comment"># hpa资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>          <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span>             <span class="comment"># 最大副本数</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>              <span class="comment"># 最小副本数</span></span><br><span class="line">  <span class="attr">metrics:</span>                    <span class="comment"># 指标设定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span>            <span class="comment"># 资源类型，可以配置为 Resource/Object/Pods</span></span><br><span class="line">    <span class="attr">resource:</span>                 <span class="comment"># 资源对象</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span>               <span class="comment"># 资源名称 cpu/memory</span></span><br><span class="line">      <span class="attr">target:</span>                 <span class="comment"># 目标对象</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span>     <span class="comment"># 目标类型，可以配置为 Utilization/AverageValue/Value</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">50</span> <span class="comment"># 目标值，这里是平均使用率的百分比</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>             <span class="comment"># 指定要自动伸缩的资源对象</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span>          <span class="comment"># 资源类型为 Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>               <span class="comment"># 资源名称为 nginx</span></span><br></pre></td></tr></table></figure><h2 id="HPA-支持的监控指标类型">HPA 支持的监控指标类型</h2><table><thead><tr><th>类型</th><th>字段名</th><th>说明</th><th>常见用途</th></tr></thead><tbody><tr><td><strong>Resource</strong></td><td><code>resource</code></td><td>基于 Pod 资源使用情况（CPU、内存），最常用</td><td>按 CPU 利用率自动扩缩容</td></tr><tr><td><strong>Pods</strong></td><td><code>pods</code></td><td>基于每个 Pod 的自定义度量指标的平均值，需要第三方监控系统提供，比如 Prometheus</td><td>按业务指标（如请求数、队列长度）扩缩容</td></tr><tr><td><strong>Object</strong></td><td><code>object</code></td><td>基于单个 Kubernetes 对象（如 Service、Ingress）的指标，，比如 Prometheus</td><td>按某个对象的指标扩缩容，例如队列长度</td></tr></tbody></table><h3 id="Resource-资源指标（CPU-内存）">Resource 资源指标（CPU/内存）</h3><ul class="lvl-0"><li class="lvl-2"><p>Utilization: 利用率百分比</p></li><li class="lvl-2"><p>Utilization 不关心 limits，只看 requests。</p></li><li class="lvl-2"><p>如果 resources.requests 没有设置，HPA Utilization 会报错（除非 AverageValue）。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metrics:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">  <span class="attr">resource:</span>                   <span class="comment"># 资源 指标</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cpu</span>                 <span class="comment"># cpu</span></span><br><span class="line">    <span class="attr">target:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Utilization</span>       <span class="comment"># 利用率百分比</span></span><br><span class="line">      <span class="attr">averageUtilization:</span> <span class="number">50</span>  <span class="comment"># 50%</span></span><br></pre></td></tr></table></figure><blockquote><p>当前有 3 个 Pod：</p></blockquote><table><thead><tr><th>Pod</th><th>CPU 实际使用</th><th>CPU requests</th></tr></thead><tbody><tr><td>pod-1</td><td>150m</td><td>200m</td></tr><tr><td>pod-2</td><td>100m</td><td>200m</td></tr><tr><td>pod-3</td><td>50m</td><td>200m</td></tr><tr><td>合计</td><td>400m</td><td>600m</td></tr><tr><td><strong>平均</strong></td><td><strong>400m ÷ 600m × 100% ≈ 66.7%</strong></td><td></td></tr></tbody></table><blockquote><p>由于 66.7% &gt; 50%，会扩容；如果小于 50%，HPA 会缩容。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>AverageValue: 指定资源使用平均值</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metrics:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">  <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">memory</span>                <span class="comment"># 监控资源类型为 memory（内存）</span></span><br><span class="line">    <span class="attr">target:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">AverageValue</span>        <span class="comment"># 指标类型为 AverageValue，表示每个 Pod 平均使用多少</span></span><br><span class="line">      <span class="attr">averageValue:</span> <span class="string">400Mi</span>       <span class="comment"># 目标值：平均每个 Pod 使用 400Mi 内存</span></span><br></pre></td></tr></table></figure><blockquote><p>假设当前部署了 3 个副本，内存使用情况如下：</p></blockquote><table><thead><tr><th>Pod</th><th>当前内存使用</th></tr></thead><tbody><tr><td>pod-1</td><td>450Mi</td></tr><tr><td>pod-2</td><td>400Mi</td></tr><tr><td>pod-3</td><td>300Mi</td></tr><tr><td><strong>平均</strong></td><td><strong>(450+400+300)/3 = 383.3Mi</strong></td></tr></tbody></table><blockquote><p>因为 383.3Mi &lt; 400Mi，不触发扩容。如果将来平均使用超过 400Mi，HPA 就会扩容，反之缩容。</p></blockquote><h2 id="HPA-扩缩容速度配置">HPA 扩缩容速度配置</h2><ul class="lvl-0"><li class="lvl-2"><p>HPA 的扩缩容速度是可以控制的，通过 behavior 字段来自定义扩缩容的速度和策略。</p></li><li class="lvl-2"><p>以下是默认策略</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line">  <span class="attr">scaleUp:</span>                                  <span class="comment"># ⬆️ 扩容策略</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">0.1</span>                          <span class="comment"># 容忍阈值，默认0.1(10%)，表示每次扩容时，pod使用率超过1.1倍目标值时才会进行扩容</span></span><br><span class="line">    <span class="attr">stabilizationWindowSeconds:</span> <span class="number">0</span>           <span class="comment"># 默认0，即增加或减少pod数量后保持不变的时间，单位为秒</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>                         <span class="comment"># 扩容速度按百分比限制</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">100</span>                            <span class="comment"># 每 15 秒最多扩容 100% 的副本数</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span>                     <span class="comment"># 每 15 秒计算一次是否可以扩容，默认 15 秒</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span>                            <span class="comment"># 按固定 Pod 数量限制扩容速度</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">4</span>                              <span class="comment"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span>                     <span class="comment"># 同样 15 秒计算一次，默认 15 秒</span></span><br><span class="line">    <span class="attr">selectPolicy:</span> <span class="string">Max</span>                       <span class="comment"># 多个 policy 同时存在时，取 Percent 和 Pods 的最大值。Min 取最小值</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">scaleDown:</span>                                <span class="comment"># ⬇️ 缩容策略</span></span><br><span class="line">    <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>         <span class="comment"># 默认 300，即增加或减少pod数量后保持不变的时间，单位为秒，防止快速缩容（平滑策略）</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>                         <span class="comment"># 缩容速度按百分比限制</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">100</span>                            <span class="comment"># 每 15 秒最多缩容 100% 的副本数</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span>                     <span class="comment"># 每 15 秒评估一次是否可以缩容</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>完整的 HPA 配置文件示例(一般情况下，我们无需修改扩缩容速度的配置，默认策略满足大部分场景)</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span>                    <span class="comment"># api版本，使用 v2 版本支持 behavior 扩缩容策略</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span>                 <span class="comment"># 资源类型为 HPA</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-nginx</span>                             <span class="comment"># HPA 资源的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>                          <span class="comment"># 命名空间，设置为 default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span>                             <span class="comment"># HPA 自动扩容的最大副本数</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>                              <span class="comment"># HPA 自动缩容的最小副本数</span></span><br><span class="line">  <span class="attr">metrics:</span>                                    <span class="comment"># 自动伸缩的指标配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span>                            <span class="comment"># 指标类型为 Resource（资源型）</span></span><br><span class="line">    <span class="attr">resource:</span>                                 <span class="comment"># 资源指标对象</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span>                               <span class="comment"># 资源名称为 cpu，也可以设置为 memory</span></span><br><span class="line">      <span class="attr">target:</span>                                 <span class="comment"># 目标指标对象</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span>                     <span class="comment"># 指标类型为 Utilization（利用率百分比）</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">50</span>                <span class="comment"># CPU 平均使用率达到 50% 时进行扩缩容</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>                             <span class="comment"># HPA 绑定的目标资源对象</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span>                          <span class="comment"># 目标类型为 Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>                               <span class="comment"># 目标 Deployment 名称为 nginx</span></span><br><span class="line">  <span class="attr">behavior:</span>                                   <span class="comment"># ⬇️ 扩缩容行为控制</span></span><br><span class="line">    <span class="attr">scaleUp:</span>                                  <span class="comment"># 扩容策略</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">30</span>          <span class="comment"># 扩容平滑窗口为 30 秒，防止短时间抖动频繁扩容</span></span><br><span class="line">      <span class="attr">policies:</span>                               <span class="comment"># 扩容速度限制策略</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>                         <span class="comment"># 按百分比计算</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">100</span>                            <span class="comment"># 每 15 秒内最多扩容 100%</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">15</span>                     <span class="comment"># 每 15 秒评估一次扩容速率</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span>                            <span class="comment"># 按固定 Pod 数量计算</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">4</span>                              <span class="comment"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">15</span>                     <span class="comment"># 每 15 秒评估一次扩容速率</span></span><br><span class="line">      <span class="attr">selectPolicy:</span> <span class="string">Max</span>                       <span class="comment"># 如果多个 policy 同时满足，取最大值（更激进的扩容）</span></span><br><span class="line">    <span class="attr">scaleDown:</span>                                <span class="comment"># 缩容策略</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>         <span class="comment"># 缩容平滑窗口为 300 秒（5 分钟），避免短时流量降低快速缩容</span></span><br><span class="line">      <span class="attr">policies:</span>                               <span class="comment"># 缩容速度限制策略</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>                         <span class="comment"># 按百分比缩容</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">30</span>                             <span class="comment"># 每 60 秒最多缩容 30%</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">60</span>                     <span class="comment"># 每 60 秒评估一次缩容速率</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/autoscaling/&quot;&gt;Autoscaling k8s简介&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/&quot;&gt;Horizontal Pod Autoscaler（HPA）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Ingress Nginx</title>
    <link href="https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/"/>
    <id>https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/</id>
    <published>2025-07-19T13:30:05.000Z</published>
    <updated>2025-07-19T08:51:49.807Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.github.io/ingress-nginx/">ingress-nginx 官网</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">ingress-nginx k8s简介</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/">k8s支持的 ingress controller</a></p></li></ul><span id="more"></span><h2 id="Ingress-简介">Ingress 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Ingress 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由(7层)。 流量路由由 Ingress 资源所定义的规则来控制。</p></li><li class="lvl-2"><p>实际上 Ingress-Nginx 内置了 nginx，由 nginx 其负责接收请求并转发给后端服务。</p></li><li class="lvl-2"><p>下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/jVrIUP.png" alt=""></p></li></ul><h2 id="安装-Ingress-Nginx">安装 Ingress-Nginx</h2><ul class="lvl-0"><li class="lvl-2"><p>安装时要注意 ingress-nginx 的版本和 Kubernetes 的版本兼容性，参考 Github:<a href="https://github.com/kubernetes/ingress-nginx">ingress-nginx</a>。</p></li><li class="lvl-2"><p>获取对应版本的yaml文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的 v1.13.0 版本，其支持 Kubernetes 1.33 版本</span></span><br><span class="line"><span class="built_in">export</span> INGRESS_NGINX_VERSION=v1.13.0</span><br><span class="line">curl -L -o ingress-nginx-controller.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-<span class="variable">$&#123;INGRESS_NGINX_VERSION&#125;</span>/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 ingress-nginx</p></li></ul><blockquote><p>这里要注意，ingress-nginx 的 <code>service/ingress-nginx-controller</code> 默认使用 LoadBalancer 类型，所以需要先使 k8s 集群支持 LoadBalancer 类型，可以参考 <a href="/2025/07/18/k8s-service/" title="K8S 之 Service">K8S 之 Service</a> 中 LoadBalancer 部分。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f ingress-nginx-controller.yaml</span><br><span class="line">namespace/ingress-nginx created</span><br><span class="line">serviceaccount/ingress-nginx created</span><br><span class="line">serviceaccount/ingress-nginx-admission created</span><br><span class="line">role.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class="line">role.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class="line">configmap/ingress-nginx-controller created</span><br><span class="line">service/ingress-nginx-controller created</span><br><span class="line">service/ingress-nginx-controller-admission created</span><br><span class="line">deployment.apps/ingress-nginx-controller created</span><br><span class="line">job.batch/ingress-nginx-admission-create created</span><br><span class="line">job.batch/ingress-nginx-admission-patch created</span><br><span class="line">ingressclass.networking.k8s.io/nginx created</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx资源</span></span><br><span class="line">$ k get all -n ingress-nginx</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/ingress-nginx-controller-95f6586c6-nznwq   1/1     Running   0          2m46s</span><br><span class="line"></span><br><span class="line">NAME                                         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                      AGE</span><br><span class="line">service/ingress-nginx-controller             LoadBalancer   10.96.112.234   10.211.55.201   80:30168/TCP,443:30600/TCP   2m46s</span><br><span class="line">service/ingress-nginx-controller-admission   ClusterIP      10.96.245.155   &lt;none&gt;          443/TCP                      2m46s</span><br><span class="line"></span><br><span class="line">NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/ingress-nginx-controller   1/1     1            1           2m46s</span><br><span class="line"></span><br><span class="line">NAME                                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/ingress-nginx-controller-95f6586c6   1         1         1       2m46s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 IngressClass 资源</span></span><br><span class="line">$ k get ingressclasses.networking.k8s.io</span><br><span class="line">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class="line">nginx   k8s.io/ingress-nginx   &lt;none&gt;       14m</span><br></pre></td></tr></table></figure><h2 id="创建-Ingress-资源">创建 Ingress 资源</h2><ul class="lvl-0"><li class="lvl-2"><p>ingress-demo.yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>                   <span class="comment"># Ingress 资源</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span>             <span class="comment"># Ingress 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>            <span class="comment"># Ingress 所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span>       <span class="comment"># Ingress 使用的 IngressClass</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.hanqunfeng.com</span>  <span class="comment"># 转发域名，支持通配符 *.hanqunfeng.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span>        <span class="comment"># 路径匹配规则, 前缀匹配</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span>                 <span class="comment"># 路径</span></span><br><span class="line">        <span class="attr">backend:</span>                <span class="comment"># 后端服务</span></span><br><span class="line">          <span class="attr">service:</span>              <span class="comment"># 声明后端是一个 service</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx</span>         <span class="comment"># service名称，提前创建好 service，类型可以是ClusterIP、NodePort、LoadBalancer任意，推荐ClusterIP，因为使用 ingress 的话，就没必要创建其它类型的 service 了</span></span><br><span class="line">            <span class="attr">port:</span>               <span class="comment"># 端口</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span>        <span class="comment"># service的端口</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看 ingress 资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ k get ing -n ns1</span><br><span class="line">NAME          CLASS   HOSTS                  ADDRESS         PORTS   AGE</span><br><span class="line">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80      80s</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>访问 web-ingress</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将域名 nginx.hanqunfeng.com 解析到 10.211.55.201，如果是内部域名可以通过 hosts 文件添加解析</span></span><br><span class="line"><span class="comment"># 只能通过 nginx.hanqunfeng.com 访问，不能通过 10.211.55.201 访问</span></span><br><span class="line">curl http://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure><h2 id="让-Ingress-支持-HTTPS-访问">让 Ingress 支持 HTTPS 访问</h2><ul class="lvl-0"><li class="lvl-2"><p>创建证书，可以在阿里云上申请一个免费的证书</p></li><li class="lvl-2"><p>创建 secret</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret tls nginx-tls \</span><br><span class="line">    --key=nginx.hanqunfeng.com.key \</span><br><span class="line">    --cert=nginx.hanqunfeng.com.pem \</span><br><span class="line">    -n default</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以通过yaml创建</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-tls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">tls.crt:</span> <span class="string">base64</span> <span class="string">编码的证书，而非文件路径</span></span><br><span class="line">  <span class="attr">tls.key:</span> <span class="string">base64</span> <span class="string">编码的私钥，而非文件路径</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>你的 Ingress 资源需要增加 tls 字段，引用一个 Secret 存储的 TLS 证书。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>                   <span class="comment"># Ingress 资源</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span>             <span class="comment"># Ingress 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>            <span class="comment"># Ingress 所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span>       <span class="comment"># Ingress 使用的 IngressClass</span></span><br><span class="line">  <span class="attr">tls:</span>                          <span class="comment"># 配置 TLS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span>                      <span class="comment"># 域名列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx.hanqunfeng.com</span>      <span class="comment"># 域名</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">nginx-tls</span>       <span class="comment"># 存放证书的 Secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.hanqunfeng.com</span>  <span class="comment">#转发域名</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span>        <span class="comment"># 路径匹配规则, 前缀匹配</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span>                 <span class="comment"># 路径</span></span><br><span class="line">        <span class="attr">backend:</span>                <span class="comment"># 后端服务</span></span><br><span class="line">          <span class="attr">service:</span>              <span class="comment"># service</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx</span>         <span class="comment"># service名称</span></span><br><span class="line">            <span class="attr">port:</span>               <span class="comment"># 端口</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span>        <span class="comment"># service的端口</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新运行ingress</span></span><br><span class="line">k apply -f nginx-ingress.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress，此时多了一个 443 端口</span></span><br><span class="line">$ k get ing</span><br><span class="line">NAME          CLASS   HOSTS                  ADDRESS         PORTS     AGE</span><br><span class="line">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80, 443   51s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问https，但此时 80 端口访问不了，需要配置 80 端口重定向到 443</span></span><br><span class="line">curl https://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure><h2 id="80端口重定向到443">80端口重定向到443</h2><ul class="lvl-0"><li class="lvl-2"><p><code>nginx ingress controller</code>，它内置支持重定向，你可以在 Ingress 上添加 annotation</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class="string">&quot;true&quot;</span>  <span class="comment"># 80 重定向到 443</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>完整的yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx.hanqunfeng.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">nginx-tls</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.hanqunfeng.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>访问测试</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新运行ingress</span></span><br><span class="line">k apply -f nginx-ingress.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下 curl 不会自动跳转，使用浏览器访问会自动重定向，308 表示永久重定向</span></span><br><span class="line">$ curl http://nginx.hanqunfeng.com</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 -L 参数，curl 会自动跳转</span></span><br><span class="line">$ curl -L http://nginx.hanqunfeng.com</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><h3 id="ssl-证书过期怎么办？">ssl 证书过期怎么办？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apply 会直接更新 Secret，而不是删除重建</span></span><br><span class="line">kubectl create secret tls nginx-tls \</span><br><span class="line">    --key=新的.key \</span><br><span class="line">    --cert=新的.pem \</span><br><span class="line">    -n default --dry-run=client -o yaml | kubectl apply -f -</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Ingress Controller（如 nginx-ingress）通常会自动监听 Secret 变化，大概 30 秒 ~ 1 分钟内自动热加载新证书，无需重启 Pod。</p></li></ul><h3 id="pathType-可以设置哪些值？">pathType 可以设置哪些值？</h3><ul class="lvl-0"><li class="lvl-2"><p>在 Kubernetes Ingress 的 pathType 字段中，一共可以设置以下三种值</p></li></ul><table><thead><tr><th><strong>pathType 值</strong></th><th><strong>含义</strong></th><th><strong>匹配规则说明</strong></th></tr></thead><tbody><tr><td><strong>Exact</strong></td><td>精确匹配</td><td>路径必须<strong>完全匹配</strong></td></tr><tr><td><strong>Prefix</strong></td><td>前缀匹配</td><td>以指定路径为<strong>前缀</strong>即可匹配</td></tr><tr><td><strong>ImplementationSpecific</strong></td><td>由 Ingress Controller 自己决定</td><td>nginx 常常表现为前缀匹配</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Exact 精确匹配，且区分大小写</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只匹配 http://example.com/foo</span></span><br><span class="line"><span class="comment"># 不会匹配 /foo/abc 或 /foo/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Exact</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/foo</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Prefix 前缀匹配，且区分大小写</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配所有以 /foo 开头的路径：</span></span><br><span class="line"><span class="comment">#   /foo</span></span><br><span class="line"><span class="comment">#   /foo/   # 会忽略尾部的 /</span></span><br><span class="line"><span class="comment">#   /foo/abc</span></span><br><span class="line"><span class="comment">#   /foo/bar/test</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/foo</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ImplementationSpecific 控制器自定义（不推荐）</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配规则由 Ingress Controller 决定；</span></span><br><span class="line"><span class="comment"># 在 nginx-ingress 中通常行为类似于 Prefix，但不保证兼容性；</span></span><br><span class="line"><span class="comment"># Kubernetes 官方不推荐生产使用，建议显式使用 Prefix 或 Exact。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/foo</span></span><br></pre></td></tr></table></figure><h3 id="设置缺省的-ingressclass">设置缺省的 ingressclass</h3><ul class="lvl-0"><li class="lvl-2"><p>我们可以设置一个缺省的 ingressclass 为默认值，这样，当创建ingress时，如果未指定ingressclass，则使用缺省值</p></li><li class="lvl-2"><p>可以通过 kubectl patch 为 ingressclass 直接打上默认标识(通过 k edit ingressclass ingressclass-name 为其添加注解也可以)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ingressclasses</span></span><br><span class="line">$ k get ingressclasses</span><br><span class="line">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class="line">nginx   k8s.io/ingress-nginx   &lt;none&gt;       3h3m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 nginx 为默认 ingressclass，就是为其加上如下注解</span></span><br><span class="line">$ kubectl patch ingressclass nginx -p <span class="string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;ingressclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="ingerss-nginx-应用示例">ingerss-nginx 应用示例</h3><ul class="lvl-0"><li class="lvl-2"><p>同一域名不同路径<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/s1XbqM.png" alt=""></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-fanout-example</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># 未指定 ingressClassName ,则使用 上文中设置的默认 ingressClassName</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">4200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bar</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>不同域名的服务<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/sBhmbR.png" alt=""></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">name-virtual-host-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bar.foo.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过如下命令对 ingress 进行修改，修改保存(:wq)后会立刻生效</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit ingress web-ingress</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.github.io/ingress-nginx/&quot;&gt;ingress-nginx 官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/&quot;&gt;ingress-nginx k8s简介&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/&quot;&gt;k8s支持的 ingress controller&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Service</title>
    <link href="https://blog.hanqunfeng.com/2025/07/18/k8s-service/"/>
    <id>https://blog.hanqunfeng.com/2025/07/18/k8s-service/</id>
    <published>2025-07-18T14:30:05.000Z</published>
    <updated>2025-07-19T05:42:38.953Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">k8s Service 介绍</a></p></li></ul><span id="more"></span><h2 id="Service-介绍">Service 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>Service是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。</p></li><li class="lvl-2"><p>尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。</p></li><li class="lvl-2"><p>Service允许您的应用程序接收流量。</p></li><li class="lvl-2"><p>Service也可以用在ServiceSpec标记type的方式暴露，type类型如下：</p><ul class="lvl-2"><li class="lvl-4">ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。</li><li class="lvl-4">NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用 <NodeIP>:<NodePort> 从集群外部访问Service。是ClusterIP的超集。</li><li class="lvl-4">LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。</li><li class="lvl-4">ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。</li></ul></li></ul><h2 id="创建Service">创建Service</h2><h3 id="ClusterIP">ClusterIP</h3><ul class="lvl-0"><li class="lvl-2"><p>只能在集群内部访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建deployment，此时会为每个pod添加一个label app=nginx</span></span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建service，，将deployment的pod暴露出来，暴露类型为ClusterIP</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=ClusterIP --port=80</span><br><span class="line">$ kubectl get svc nginx</span><br><span class="line">NAME    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">nginx   ClusterIP   10.96.14.90   &lt;none&gt;        80/TCP    60s</span><br></pre></td></tr></table></figure><h3 id="NodePort">NodePort</h3><ul class="lvl-0"><li class="lvl-2"><p>暴露宿主机的端口，供外部访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建service，将deployment的pod暴露出来，暴露类型为NodePort</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"><span class="comment"># 查看service，此时可以看到service的端口和节点的端口，与 ClusterIP 的区别就是是否暴露在节点上的端口</span></span><br><span class="line">$ kubectl get svc nginx</span><br><span class="line">NAME    TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx   NodePort   10.96.7.8    &lt;none&gt;        80:32691/TCP   31s</span><br></pre></td></tr></table></figure><h3 id="yaml文件创建service">yaml文件创建service</h3><ul class="lvl-0"><li class="lvl-2"><p>yaml文件格式</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>      <span class="comment"># api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>       <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>           <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>       <span class="comment"># service名称</span></span><br><span class="line"><span class="attr">spec:</span>               <span class="comment"># 配置</span></span><br><span class="line">  <span class="attr">ports:</span>            <span class="comment"># 端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>        <span class="comment"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>   <span class="comment"># 协议</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span>  <span class="comment"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># node暴露的端口，service类型为 NodePort 时使用，默认范围在 30000-32767 之间</span></span><br><span class="line">  <span class="attr">selector:</span>         <span class="comment"># 选择器</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>      <span class="comment"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>    <span class="comment"># service类型</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里有个问题需要注意，service 默认是通过<code>标签</code>来匹配pod的，所以创建service的时候，一定要保证pod的标签是存在的，否则service无法匹配pod，另外虽然我们通过命令行创建service时是通过<code>kubectl expose deployment nginx --type=NodePort --port=80</code>创建的，但也并不表示service只会匹配这个deployment创建的pod，而是会匹配所有具有指定标签的pod（app=nginx）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取service的 selector</span></span><br><span class="line">$ k get svc -owide</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE    SELECTOR</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        4d5h   &lt;none&gt;</span><br><span class="line">nginx        NodePort    10.96.9.77   &lt;none&gt;        80:30080/TCP   8s     app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里有个名称为 kubernetes 的 service，其作用是为了方便集群内部的 Pod 调用 API Server 的统一入口</span></span><br><span class="line"><span class="comment"># 无论 API Server 实际运行在哪个节点哪个 IP，集群内部只要访问如下地址就能访问 API Server。</span></span><br><span class="line"><span class="comment"># https://kubernetes.default.svc</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># https://10.96.0.1</span></span><br><span class="line"><span class="comment"># 这个 Service 是 系统自带的，不建议删除或修改。</span></span><br></pre></td></tr></table></figure><h3 id="ExternalName">ExternalName</h3><ul class="lvl-0"><li class="lvl-2"><p>可以将其它 namespace 的 service 别名到 当前 namespace，这样访问 service 时就不需要加上命名空间名称了</p></li><li class="lvl-2"><p>ExternalName Service 是纯 DNS CNAME 映射，我们不经可以映射集群内容服务，也可以映射集群外部服务。</p></li><li class="lvl-2"><p>原先的 service 访问方式：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不同命名空间下创建service</span></span><br><span class="line"><span class="comment"># 创建两个命名空间以及下面的资源</span></span><br><span class="line"><span class="comment">## ns1</span></span><br><span class="line">kubectl create namespace ns1</span><br><span class="line">kubectl create deployment alpine-demo -n ns1 --image=alpine/curl --replicas=1 -- /bin/sh -c <span class="string">&quot;sleep infinity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ns2</span></span><br><span class="line">kubectl create namespace ns2</span><br><span class="line">kubectl create deployment nginx-demo -n ns2 --image=nginx --replicas=1</span><br><span class="line">kubectl expose deployment nginx-demo -n ns2 --<span class="built_in">type</span>=ClusterIP --port=80 --name=nginx-service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 ns1 中的 pod 访问 ns2 中的 nginx-service</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class="line">curl nginx-service.ns2.svc.cluster.local</span><br><span class="line">curl nginx-service.ns2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ExternalName 访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ns1 中创建 externalName 类型的 service，--external-name 指定 ns2 中的 nginx-service</span></span><br><span class="line">kubectl create service externalname nginx-service -n ns1 --external-name=nginx-service.ns2.svc.cluster.local</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以通过 yaml 创建</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>                               <span class="comment"># service 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span>                                    <span class="comment"># 指定命名空间 为 ns1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">nginx-service.ns2.svc.cluster.local</span> <span class="comment"># 指定外部服务名，比如 www.baidu.com</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span>                                <span class="comment"># 指定为 ExternalName 类型</span></span><br><span class="line">  <span class="attr">selector:</span>                                         <span class="comment"># 不需要配置 selector</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-service</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看 service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ k get svc -n ns1</span><br><span class="line">NAME            TYPE           CLUSTER-IP   EXTERNAL-IP                           PORT(S)   AGE</span><br><span class="line">nginx-service   ExternalName   &lt;none&gt;       nginx-service.ns2.svc.cluster.local   &lt;none&gt;    16s</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时再次进入 ns1 中的 pod 访问 ns2 中的 nginx-service 服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class="line"><span class="comment"># 此时就不需要加上 ns2 的 namespace 了</span></span><br><span class="line">curl nginx-service</span><br></pre></td></tr></table></figure><h3 id="LoadBalancer">LoadBalancer</h3><ul class="lvl-0"><li class="lvl-2"><p>LoadBalancer 是 Kubernetes Service 的一种类型，用于自动申请一个云厂商的负载均衡器（如 AWS ELB、GCP LB、阿里云 SLB），将外部流量转发到 Kubernetes 集群内部的 Pod 上。</p></li><li class="lvl-2"><p>在私有云上，需要借助第三方负载均衡器来实现，比如 <a href="https://metallb.io">MetalLB</a>，<a href="https://github.com/metallb/metallb">github</a></p></li></ul><h4 id="安装-MetallB">安装 MetallB</h4><ul class="lvl-0"><li class="lvl-2"><p>如果您在IPVS模式下使用kube代理，从Kubernetes v1.14.2开始，您必须启用严格的ARP模式。请注意，如果您使用kube-router作为服务代理，则不需要这个，因为它默认启用了严格的ARP。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看将要产生的变更，如果有变更则返回非零状态码</span></span><br><span class="line">kubectl get configmap kube-proxy -n kube-system -o yaml | \</span><br><span class="line">sed -e <span class="string">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \</span><br><span class="line">kubectl diff -f - -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用变更，只有发生错误时才返回非零状态码</span></span><br><span class="line">kubectl get configmap kube-proxy -n kube-system -o yaml | \</span><br><span class="line">sed -e <span class="string">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \</span><br><span class="line">kubectl apply -f - -n kube-system</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装MetalLB</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> METLB_VERSION=v0.15.2</span><br><span class="line">curl -L -o metallb.yaml https://raw.githubusercontent.com/metallb/metallb/<span class="variable">$&#123;METLB_VERSION&#125;</span>/config/manifests/metallb-native.yaml</span><br><span class="line">kubectl apply -f metallb.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看MetalLB资源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ k get all -n metallb-system -owide</span><br><span class="line">NAME                              READY   STATUS    RESTARTS      AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/controller-58fdf44d87-bsp4z   1/1     Running   0             4m13s   10.244.194.104   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/speaker-sjvq5                 1/1     Running   0             4m13s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/speaker-srpp4                 1/1     Running   0             4m13s   10.211.55.16     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/speaker-tbnls                 1/1     Running   2 (98s ago)   4m13s   10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class="line">service/metallb-webhook-service   ClusterIP   10.96.233.8   &lt;none&gt;        443/TCP   4m14s   component=controller</span><br><span class="line"></span><br><span class="line">NAME                     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS   IMAGES                            SELECTOR</span><br><span class="line">daemonset.apps/speaker   3         3         3       3            3           kubernetes.io/os=linux   4m13s   speaker      quay.io/metallb/speaker:v0.15.2   app=metallb,component=speaker</span><br><span class="line"></span><br><span class="line">NAME                         READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class="line">deployment.apps/controller   1/1     1            1           4m14s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller</span><br><span class="line"></span><br><span class="line">NAME                                    DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class="line">replicaset.apps/controller-58fdf44d87   1         1         1       4m13s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller,pod-template-hash=58fdf44d87</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>配置地址池:metallb-pool.yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IPAddressPool</span>                 <span class="comment"># 地址池类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metallb-pool</span>                <span class="comment"># 地址池名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span>         <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">addresses:</span>                        <span class="comment"># 配置地址池</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.200</span><span class="number">-10.211</span><span class="number">.55</span><span class="number">.250</span>     <span class="comment"># 与 节点 相同的网段，负载均衡器可以分配的IP范围</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f metallb-pool.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>配置地址池的二级公告:metallb-advertisement.yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">L2Advertisement</span>               <span class="comment"># 地址池二级公告类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metallb-advertisement</span>       <span class="comment"># 公告名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span>         <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipAddressPools:</span>                   <span class="comment"># 地址池名称列表，只有被公告的地址池才会被使用</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">metallb-pool</span>                    <span class="comment"># 地址池名称</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f metallb-advertisement.yaml</span><br></pre></td></tr></table></figure><h4 id="创建-LoadBalancer-类型的-service">创建 LoadBalancer 类型的 service</h4><ul class="lvl-0"><li class="lvl-2"><p>metallb-service.yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>                  <span class="comment"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>                     <span class="comment"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                       <span class="comment"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                        <span class="comment"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span>                     <span class="comment"># 命名空间，默认为 default</span></span><br><span class="line"><span class="attr">spec:</span>                                <span class="comment"># 配置项</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>                        <span class="comment"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class="line">  <span class="attr">selector:</span>                          <span class="comment"># 选择器，指定要管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>                     <span class="comment"># 标签选择器</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>                     <span class="comment"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class="line">  <span class="attr">template:</span>                          <span class="comment"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>                   <span class="comment"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 容器的名称</span></span><br><span class="line"><span class="string">---</span>                                  <span class="comment"># 分割线</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                       <span class="comment"># api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>                        <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>                            <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                        <span class="comment"># service名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span>                     <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span>                                <span class="comment"># 配置</span></span><br><span class="line">  <span class="attr">ports:</span>                             <span class="comment"># 端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>                         <span class="comment"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>                    <span class="comment"># 协议</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span>                   <span class="comment"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class="line">  <span class="attr">selector:</span>                          <span class="comment"># 选择器</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                       <span class="comment"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span>                 <span class="comment"># service类型</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ k apply -f metallb-service.yaml</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line">service/nginx created</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到 service 的类型为 LoadBalancer，并分配了 EXTERNAL-IP，这里还开放了nodePort 30613</span></span><br><span class="line">$ kubectl get svc -n ns1</span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE</span><br><span class="line">nginx        LoadBalancer   10.96.210.244   10.211.55.200   80:30613/TCP   52s</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>访问service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 service 的 port 访问，这里是 80</span></span><br><span class="line">curl 10.211.55.200</span><br><span class="line"><span class="comment"># 同样可以基于 nodeIP+nodePort 访问</span></span><br><span class="line">curl 10.211.55.11:30613</span><br></pre></td></tr></table></figure><h2 id="访问service，轮询pod">访问service，轮询pod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在集群内</span></span><br><span class="line"><span class="comment"># 在相同的 namespace 中，可以通过 serviceName 直接访问</span></span><br><span class="line">curl nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过 CLUSTER-IP 访问</span></span><br><span class="line">curl 10.96.9.77</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，比如本示例为</span></span><br><span class="line">curl nginx.default</span><br><span class="line">curl nginx.default.svc.cluster.local</span><br><span class="line"><span class="comment"># 这是因为在创建 service前，我们是不知道 service 的 IP 地址的，所以在其它pod中就可以预先使用 &lt;serviceName&gt;.&lt;namespace&gt; 占位，k8s会自动将其解析为 service 的 CLUSTER-IP</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在集群外</span></span><br><span class="line"><span class="comment"># 通过 NODE-IP:NODE-PORT 访问</span></span><br><span class="line">curl 10.211.55.16:30080</span><br></pre></td></tr></table></figure><h2 id="管理service">管理service</h2><ul class="lvl-0"><li class="lvl-2"><p>查看service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment"># 查看指定namespace下的service</span></span><br><span class="line">kubectl get svc -n kube-system</span><br><span class="line"><span class="comment"># 查看全部service</span></span><br><span class="line">kubectl get svc -A</span><br><span class="line"><span class="comment"># 查看service详情</span></span><br><span class="line">kubectl get svc nginx -o yaml</span><br><span class="line">kubectl describe svc nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">k logs svc/nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>编辑service，保存（:wq）后生效，不需要额外 apply 或 restart</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete svc nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/&quot;&gt;k8s Service 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>acme.sh 自动申请并续签 SSL 证书的工具</title>
    <link href="https://blog.hanqunfeng.com/2025/07/17/acme/"/>
    <id>https://blog.hanqunfeng.com/2025/07/17/acme/</id>
    <published>2025-07-17T14:30:05.000Z</published>
    <updated>2025-07-19T07:00:35.350Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍自动申请并续签 SSL 证书的工具: <a href="http://acme.sh">acme.sh</a></p></li><li class="lvl-2"><p><a href="https://github.com/acmesh-official/acme.sh">acme.sh Github</a></p></li></ul><span id="more"></span><h2 id="acme-sh-介绍"><a href="http://acme.sh">acme.sh</a> 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="http://acme.sh">acme.sh</a> 实现了 acme 协议，可以从 ZeroSSL，Let’s Encrypt 等 CA 生成免费的证书。</p></li><li class="lvl-2"><p>适用场景：shell脚本方式，几乎无依赖，极简，适合不想安装Python环境的人。</p></li><li class="lvl-2"><p>特点：</p><ul class="lvl-2"><li class="lvl-4">纯 Shell 脚本，单文件运行</li><li class="lvl-4">支持 100+ DNS API 自动续签（如 Cloudflare、阿里云、腾讯云等）</li><li class="lvl-4">支持通配符证书</li></ul></li></ul><h2 id="acme-sh-安装"><a href="http://acme.sh">acme.sh</a> 安装</h2><ul class="lvl-0"><li class="lvl-2"><p>需要先安装 crontab</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 crontab</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install cronie -y</span><br><span class="line"><span class="comment"># 启动 crond</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now crond</span><br><span class="line"><span class="comment"># 查看 crond 状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status crond</span><br><span class="line"><span class="comment"># 查看 crontab 是否正常</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 <a href="http://acme.sh">acme.sh</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装成功后会自动安装到 ~/.acme.sh/ 目录下，证书也会生成在该目录下</span></span><br><span class="line">curl https://get.acme.sh | sh -s email=qunfeng_han@aliyun.com</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装成功后会自动在 crontab 中添加了定时任务，每天检查一次证书是否到达下次更新日期，如果到期则自动更新</span></span><br><span class="line"><span class="comment"># 证书有效期默认为 90 天，还剩 30 天时会触发自动更新</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment"># 输出类似于 以下内容</span></span><br><span class="line">48 1 * * * <span class="string">&quot;/root/.acme.sh&quot;</span>/acme.sh --cron --home <span class="string">&quot;/root/.acme.sh&quot;</span> &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">acme.sh -h</span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">acme.sh -v</span><br></pre></td></tr></table></figure><h2 id="升级-acme-sh">升级 <a href="http://acme.sh">acme.sh</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级 acme.sh 到最新版</span></span><br><span class="line">acme.sh --upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启自动升级</span></span><br><span class="line">acme.sh --upgrade --auto-upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以随时关闭自动更新</span></span><br><span class="line">acme.sh --upgrade --auto-upgrade  0</span><br></pre></td></tr></table></figure><h2 id="卸载-acme-sh">卸载 <a href="http://acme.sh">acme.sh</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --uninstall</span><br><span class="line"><span class="built_in">rm</span> -rf ~/.acme.sh</span><br></pre></td></tr></table></figure><h2 id="生成证书">生成证书</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="http://acme.sh">acme.sh</a> 实现了 acme 协议支持的所有验证协议。</p></li><li class="lvl-2"><p>证书创建后会保存在 ~/.acme.sh/目录下，比如我的域名是 <code>acme.hanqunfeng.com</code>，则证书保存在 <code>~/.acme.sh/acme.hanqunfeng.com_ecc/</code>目录下</p></li><li class="lvl-2"><p>创建证书时一般有两种方式验证: HTTP 和 DNS 验证。</p></li></ul><h3 id="HTTP-验证">HTTP 验证</h3><ul class="lvl-0"><li class="lvl-2"><p>只支持单个子域名的证书生成，不支持通配符域名</p></li><li class="lvl-2"><p>需要提前将域名解析到本机的IP地址</p></li></ul><h4 id="直接签发">直接签发</h4><ul class="lvl-0"><li class="lvl-2"><p>只需要指定域名，并指定域名所在的网站根目录. <a href="http://acme.sh">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 指定域名，可以添加多个，--webroot 指定网站根目录</span></span><br><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># --server 指定 acme.sh 使用的 CA 服务商为 Let&#x27;s Encrypt，默认使用 ZeroSSL</span></span><br><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/ --server letsencrypt</span><br></pre></td></tr></table></figure><h4 id="使用-Nginx-Apache-模式">使用 Nginx/Apache 模式</h4><ul class="lvl-0"><li class="lvl-2"><p>如果你用的 Nginx/Apache 服务器，或者反代，<a href="http://acme.sh">acme.sh</a> 还可以智能的从 Nginx/Apache 的配置中自动完成验证，你不需要指定网站根目录</p></li><li class="lvl-2"><p>nginx 或 httpd 命令要在系统Path中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 域名，可以添加多个, --nginx 告诉 acme.sh 使用 Nginx 模式</span></span><br><span class="line">acme.sh --issue --nginx -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br><span class="line"><span class="comment"># -d 域名，可以添加多个, --apache 告诉 acme.sh 使用 Apache 模式</span></span><br><span class="line">acme.sh --issue --apache -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure><h4 id="使用独立服务模式">使用独立服务模式</h4><ul class="lvl-0"><li class="lvl-2"><p>如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 <a href="http://acme.sh">acme.sh</a> 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证</p></li><li class="lvl-2"><p>需要先安装 socat 命令，socat 常用于临时开启 TCP/UDP 监听端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install socat -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生成证书，要求80端口空闲，否则会失败</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --standalone 独立服务模式</span></span><br><span class="line">acme.sh --issue --standalone -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure><h3 id="DNS-验证">DNS 验证</h3><ul class="lvl-0"><li class="lvl-2"><p>如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。</p></li><li class="lvl-2"><p>支持通配符域名</p></li></ul><h4 id="手动验证">手动验证</h4><ul class="lvl-0"><li class="lvl-2"><p>这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。</p></li><li class="lvl-2"><p>注意，如果使用手动验证，<a href="http://acme.sh">acme.sh</a> 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要加上 --yes-I-know-dns-manual-mode-enough-go-ahead-please 选项</span></span><br><span class="line">acme.sh --issue --dns -d acme.hanqunfeng.com -d www.hanqunfeng.com --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>然后，<a href="http://acme.sh">acme.sh</a> 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Add the following txt record:</span><br><span class="line">Domain:_acme-challenge.acme.hanqunfeng.com</span><br><span class="line">Txt value:mUWNg9kuQ9hwOkqYFQ_DFMQ4Eu0CEaxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">Add the following txt record:</span><br><span class="line">Domain:_acme-challenge.www.hanqunfeng.com</span><br><span class="line">Txt value:vLwDR48eHcmcScOwHrDjaFZo-yw_f9xxxxxxxxxxx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>等待解析完成之后，执行以下命令重新生成证书：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里现在用的是 --renew 参数</span></span><br><span class="line">acme.sh --renew -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure><h4 id="自动验证（DNS-API）">自动验证（DNS API）</h4><ul class="lvl-0"><li class="lvl-2"><p>DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。</p></li><li class="lvl-2"><p><a href="http://acme.sh">acme.sh</a> 目前支持<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">超过一百家的 DNS API</a>。</p></li><li class="lvl-2"><p>以阿里云为例，登录阿里云帐号，获取 AccessKey 和 SecretKey，并设置环境变量：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要命令行执行一次，运行生成证书命令时会保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置</span></span><br><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">&quot;&lt;key&gt;&quot;</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">&quot;&lt;secret&gt;&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生成证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --dns dns_ali 指定阿里云的DNS API</span></span><br><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali</span><br></pre></td></tr></table></figure><h2 id="生成证书的其它说明">生成证书的其它说明</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="http://acme.sh">acme.sh</a> 脚本默认 CA 服务商是 ZeroSSL，<a href="https://github.com/acmesh-official/acme.sh/wiki/Server">acme.sh 支持的CA 服务商及其使用方法</a>，可以在命令行中通过 --server 指定</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用 Let&#x27;s Encrypt 的 CA 服务商</span></span><br><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以设置全局默认的 CA 服务商，这样就不需要每次都指定 --server</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --set-default-ca --server letsencrypt</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2"><a href="http://acme.sh">acme.sh</a> 官网说 默认的 CA 服务商 ZeroSSL 不是很稳定，有时可能会导致获取证书的时候一直出现：<code>Pending，The CA is processing your order，please just wait.</code>， 此时只需要把 CA 服务器改成 Let’s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功。</li><li class="lvl-2">但是 Let’s Encrypt 获取的证书，不支持比较旧的设备，比如 Android 5.0 以下的设备，如果有这方面的需要还是推荐使用 ZeroSSL。</li><li class="lvl-2">常见根证书表</li></ul><table><thead><tr><th>根证书（CN）</th><th>Android 5.0</th><th>常见签发方</th></tr></thead><tbody><tr><td><strong>ISRG Root X1</strong></td><td>❌ 不兼容</td><td>Let’s Encrypt</td></tr><tr><td><strong>DST Root CA X3</strong></td><td>✅ 兼容（2021年过期）</td><td>Let’s Encrypt 老版本</td></tr><tr><td><strong>GlobalSign Root R1</strong></td><td>✅ 兼容</td><td>GlobalSign</td></tr><tr><td><strong>USERTrust RSA Certification Authority</strong></td><td>✅ 兼容</td><td>ZeroSSL, Sectigo</td></tr><tr><td><strong>Starfield Root CA - G2</strong></td><td>❌ 不兼容</td><td>GoDaddy 新版</td></tr><tr><td><strong>Starfield Root CA - G1</strong></td><td>✅ 兼容</td><td>GoDaddy 老版</td></tr><tr><td><strong>GTS Root R1/R3</strong></td><td>❌ 不兼容</td><td>Google Trust Services</td></tr><tr><td><strong>Amazon Root CA 1</strong></td><td>❌ 不兼容</td><td>Amazon Trust</td></tr></tbody></table><ul class="lvl-1"><li class="lvl-2"><p>可以用在线工具直接查看证书链：<a href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a> ，它会显示完整证书链和各种设备的兼容性</p></li></ul></div><ul class="lvl-0"><li class="lvl-2"><p>查看已经生成的证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ acme.sh --list</span><br><span class="line">Main_Domain          KeyLength  SAN_Domains  CA           Created               Renew</span><br><span class="line">acme.hanqunfeng.com  <span class="string">&quot;ec-256&quot;</span>   no           ZeroSSL.com  2025-07-17T03:31:30Z  2025-09-14T03:31:30Z</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果生成证书时失败，可以通过添加 --debug 参数查看详细错误信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug</span><br><span class="line"><span class="comment"># --debug 2 输出更为详细的信息</span></span><br><span class="line">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug 2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>目前证书每 60 天自动更新，你无需任何操作。但是你也可以强制续签证书：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里要将 --issue 改为 --renew，--issue 只有第一次生成正式时才会使用。同时加上 --force，未到更新时间强制重新生成证书。</span></span><br><span class="line">acme.sh --renew -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --force</span><br></pre></td></tr></table></figure><h2 id="生成证书后自动部署和更新">生成证书后自动部署和更新</h2><ul class="lvl-0"><li class="lvl-2"><p>上面无论是 http 还是 dns 模式，生成证书后，都会在 ~/.acme.sh/acme.hanqunfeng.com_ecc/ 目录下生成以下文件：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── acme.hanqunfeng.com.cer</span><br><span class="line">├── acme.hanqunfeng.com.conf</span><br><span class="line">├── acme.hanqunfeng.com.csr</span><br><span class="line">├── acme.hanqunfeng.com.csr.conf</span><br><span class="line">├── acme.hanqunfeng.com.key</span><br><span class="line">├── ca.cer</span><br><span class="line">└── fullchain.cer</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>我们可以手动将证书拷贝到真正使用证书的目录下，如果我们使用nginx或者apache，可以让 <a href="http://acme.sh">acme.sh</a> 帮我们自动将证书拷贝到正确的目录下，并重启服务使证书生效，我们只需要通过如下命令进行设置即可，只需要运行一次命令，后续会通过 crontab 进行自动更新证书并完成部署。</p></li><li class="lvl-2"><p>Nginx</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --install-cert \</span><br><span class="line">-d acme.hanqunfeng.com \                               <span class="comment"># 生成证书时指定的域名</span></span><br><span class="line">--key-file /path/to/keyfile/in/nginx/key.pem \    <span class="comment"># nginx 中配置的 key 文件路径</span></span><br><span class="line">--fullchain-file /path/to/fullchain/nginx/cert.pem \  <span class="comment"># nginx 中配置的证书文件路径</span></span><br><span class="line">--reloadcmd <span class="string">&quot;systemctl reload nginx&quot;</span>                   <span class="comment"># nginx 重载命令，也可以使用 nginx -s reload</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>文件对应关系</p></li></ul><table><thead><tr><th><a href="http://acme.sh">acme.sh</a> 文件</th><th>含义</th><th>你配置的目标文件</th></tr></thead><tbody><tr><td><code>acme.hanqunfeng.com.key</code></td><td><strong>私钥 (Private Key)</strong></td><td><code>/path/to/keyfile/in/nginx/key.pem</code></td></tr><tr><td><code>fullchain.cer</code></td><td><strong>证书 + 中间证书链 (Fullchain)</strong></td><td><code>/path/to/fullchain/nginx/cert.pem</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Apache</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --install-cert \</span><br><span class="line">-d acme.hanqunfeng.com \</span><br><span class="line">--cert-file      /path/to/certfile/in/apache/cert.pem  \ <span class="comment"># apache 证书文件</span></span><br><span class="line">--key-file       /path/to/keyfile/in/apache/key.pem  \   <span class="comment"># apache 密钥文件</span></span><br><span class="line">--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \ <span class="comment"># apache 全链文件</span></span><br><span class="line">--reloadcmd     <span class="string">&quot;systemctl reload httpd&quot;</span>  <span class="comment"># apache 重载命令</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>文件对应关系</p></li></ul><table><thead><tr><th><a href="http://acme.sh">acme.sh</a> 文件</th><th>含义</th><th>你配置的目标文件</th></tr></thead><tbody><tr><td><code>acme.hanqunfeng.com.key</code></td><td><strong>私钥 (Private Key)</strong></td><td><code>/path/to/keyfile/in/apache/key.pem</code></td></tr><tr><td><code>acme.hanqunfeng.com.cer</code></td><td><strong>仅域名证书 (Certificate)</strong></td><td><code>/path/to/certfile/in/apache/cert.pem</code></td></tr><tr><td><code>fullchain.cer</code></td><td><strong>证书 + 中间证书链 (Fullchain)</strong></td><td><code>/path/to/fullchain/certfile/apache/fullchain.pem</code></td></tr></tbody></table><h2 id="停止自动更新并删除证书">停止自动更新并删除证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止自动更新</span></span><br><span class="line">acme.sh --remove -d acme.hanqunfeng.com --ecc</span><br><span class="line"><span class="comment"># 删除证书</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.acme.sh/acme.hanqunfeng.com_ecc</span><br></pre></td></tr></table></figure><h2 id="其它ssl自动续签工具">其它ssl自动续签工具</h2><table><thead><tr><th>工具</th><th>推荐场景</th><th>官网地址</th><th>依赖</th></tr></thead><tbody><tr><td>Certbot</td><td>传统服务器、Nginx/Apache</td><td><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></td><td>Python</td></tr><tr><td>Lego</td><td>静态二进制、K8s</td><td><a href="https://github.com/go-acme/lego">https://github.com/go-acme/lego</a></td><td>无依赖</td></tr><tr><td>cert-manager</td><td>K8s 集群</td><td><a href="https://cert-manager.io/">https://cert-manager.io/</a></td><td>K8s CRD</td></tr><tr><td>Caddy</td><td>简单站点自动HTTPS</td><td><a href="https://caddyserver.com/">https://caddyserver.com/</a></td><td>无需单独工具</td></tr><tr><td>Traefik</td><td>微服务网关</td><td><a href="https://traefik.io/">https://traefik.io/</a></td><td>Docker/K8s</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍自动申请并续签 SSL 证书的工具: &lt;a href=&quot;http://acme.sh&quot;&gt;acme.sh&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/acmesh-official/acme.sh&quot;&gt;acme.sh Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="acme" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/acme/"/>
    
    <category term="ssl" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/acme/ssl/"/>
    
    <category term="certificate" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/acme/ssl/certificate/"/>
    
    
    <category term="ssl" scheme="https://blog.hanqunfeng.com/tags/ssl/"/>
    
    <category term="acme" scheme="https://blog.hanqunfeng.com/tags/acme/"/>
    
  </entry>
  
  <entry>
    <title>K8S 镜像拉取 之 toomanyrequests 的解决方法</title>
    <link href="https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/"/>
    <id>https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/</id>
    <published>2025-07-16T15:30:05.000Z</published>
    <updated>2025-07-18T03:02:52.603Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 镜像拉取 的 <code>toomanyrequests</code> 的解决方法 ，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li></ul><span id="more"></span><h2 id="toomanyrequests-介绍">toomanyrequests 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>当我们通过k8s创建pod时需要从 dockerhub 上拉取镜像，但是 dockerhub 的api请求是有限制的，未认证用户限制为100/6h，如果超过这个限制就会返回<code>429 Too Many Requests响应</code>。<a href="https://docs.docker.com/docker-hub/usage/">Docker Hub的使用和限制</a></p></li><li class="lvl-2"><p>我们可以进行用户认证，这样可以将限制提高到2000/6h。如果还需要进一步提高请求限制，可以申请dockerhub的pro plan。</p></li></ul><h2 id="dockerhub-认证">dockerhub 认证</h2><ul class="lvl-0"><li class="lvl-2"><p>创建 Docker Registry Secret</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 namespace， 默认命名空间是 default</span></span><br><span class="line">kubectl create secret docker-registry \</span><br><span class="line">  dockerhub-secret \                            <span class="comment"># 创建 secret 名称</span></span><br><span class="line">  --namespace=你的命名空间 \                      <span class="comment"># 创建 secret 所在的命名空间</span></span><br><span class="line">  --docker-server=https://index.docker.io/v1/ \ <span class="comment"># 指定 docker registry 地址，默认就是这个，其它仓库或私服请更改为对应的url</span></span><br><span class="line">  --docker-username=你的用户名 \                  <span class="comment"># 仓库 的用户名</span></span><br><span class="line">  --docker-password=你的密码或访问令牌 \           <span class="comment"># 仓库 的密码或访问令牌</span></span><br><span class="line">  --docker-email=你的邮箱                        <span class="comment"># 仓库 的邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 secret</span></span><br><span class="line">kubectl get secret dockerhub-secret -o yaml -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以在创建 pod 或 deployment 时指定凭证</p></li></ul><blockquote><p>pod</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">username/repository:tag</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span>                         <span class="comment"># 添加凭证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockerhub-secret</span></span><br></pre></td></tr></table></figure><blockquote><p>deployment</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">username/repository:tag</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span>                       <span class="comment"># 添加凭证</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockerhub-secret</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将 Secret 添加到 ServiceAccount，这样 Pod 创建的时候，会自动将 Secret 挂载到 Pod 中</p></li></ul><blockquote><p>每个 namespace 下 都有一个 名称为 default 的 ServiceAccount</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 pod 的 ServiceAccount</span></span><br><span class="line">$ k describe pod pi-n65gn | grep <span class="string">&quot;Service Account&quot;</span></span><br><span class="line">Service Account:  default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 namespace 下的 Pod 使用这个凭证</span></span><br><span class="line">kubectl patch serviceaccount default -p <span class="string">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个凭证，这会覆盖之前的设置，多个 secret 按顺序生效，k8s 会逐个尝试去拉取镜像</span></span><br><span class="line">kubectl patch serviceaccount default -p <span class="string">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;harbor-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;aliyun-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加一个凭证，不会覆盖原有的设置</span></span><br><span class="line">kubectl patch serviceaccount default --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> -p=<span class="string">&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/imagePullSecrets/-&quot;, &quot;value&quot;: &#123;&quot;name&quot;: &quot;new-secret&quot;&#125;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前 imagePullSecrets 的索引，以下命令会输出凭证的名称，索引从 0 开始</span></span><br><span class="line">kubectl get sa default -o jsonpath=<span class="string">&#x27;&#123;.imagePullSecrets[*].name&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个凭证: 删除 index 为 1 的凭证</span></span><br><span class="line">kubectl patch serviceaccount default --<span class="built_in">type</span>=json -p=<span class="string">&#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/imagePullSecrets/1&quot;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空所有凭证</span></span><br><span class="line">kubectl patch sa default -p <span class="string">&#x27;&#123;&quot;imagePullSecrets&quot;: []&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为所有 namespace 下的 Pod 添加凭证</span></span><br><span class="line"><span class="keyword">for</span> ns <span class="keyword">in</span> $(kubectl get ns -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl patch serviceaccount default -n <span class="variable">$ns</span> \</span><br><span class="line">    --<span class="built_in">type</span>=merge \</span><br><span class="line">    -p <span class="string">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ServiceAccount</span></span><br><span class="line">$ kubectl get serviceaccount default -o yaml -n &lt;namespace&gt;</span><br><span class="line">apiVersion: v1</span><br><span class="line">imagePullSecrets:</span><br><span class="line">- name: dockerhub-secret</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2025-06-29T14:41:35Z&quot;</span></span><br><span class="line">  name: default</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: <span class="string">&quot;361001&quot;</span></span><br><span class="line">  uid: cb3a0f99-5804-4f21-816a-70533cc3d29d</span><br></pre></td></tr></table></figure><h2 id="提高下载频率的其他建议">提高下载频率的其他建议</h2><ul class="lvl-0"><li class="lvl-2"><p>1.使用镜像缓存:</p><ul class="lvl-2"><li class="lvl-4">设置集群内镜像缓存（如 Harbor, Nexus Registry）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改集群的镜像仓库配置（vim）</span></span><br><span class="line">kubectl edit configmap -n kube-system</span><br><span class="line"><span class="comment"># 找到 imageRepository: 替换为你的仓库地址</span></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4">使用 Docker Hub 镜像加速器（如果在中国大陆）<ul class="lvl-4"><li class="lvl-6">如果 k8s 使用的是 docker，则在<code>/etc/docker/daemon.json</code>添加镜像加速器配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://docker.1ms.run&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.xuanyuan.me&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><ul class="lvl-4"><li class="lvl-6">如果 k8s 使用的是 containerd，则在<code>/etc/containerd/config.toml</code>添加镜像加速器配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 registry.mirrors 字段，添加加速器，比如：</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class="line">  [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">    endpoint = [<span class="string">&quot;https://docker.1ms.run&quot;</span>, <span class="string">&quot;https://docker.xuanyuan.me&quot;</span>, <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后重启 containerd</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>2.升级 Docker Hub 订阅:</p><ul class="lvl-2"><li class="lvl-4">免费账户：200 pulls/6小时（匿名用户100 pulls/6小时）</li><li class="lvl-4">Pro/Team 账户：无限制拉取</li></ul></li><li class="lvl-2"><p>3.使用多个账户:</p><ul class="lvl-2"><li class="lvl-4">为不同节点配置不同的 Docker Hub 凭证</li></ul></li><li class="lvl-2"><p>4.减少不必要的拉取:</p><ul class="lvl-2"><li class="lvl-4">使用 imagePullPolicy: IfNotPresent</li><li class="lvl-4">尽量使用固定版本标签而非 latest</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 镜像拉取 的 &lt;code&gt;toomanyrequests&lt;/code&gt; 的解决方法 ，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Job/CronJob</title>
    <link href="https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/"/>
    <id>https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/</id>
    <published>2025-07-16T14:30:05.000Z</published>
    <updated>2025-07-16T07:15:13.338Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">k8s Job 介绍</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/">k8s CronJob 介绍</a></p></li></ul><span id="more"></span><h2 id="Job-介绍">Job 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>Job 表示一次性任务，运行完成后就会停止。</p></li><li class="lvl-2"><p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。</p></li><li class="lvl-2"><p>随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。</p></li><li class="lvl-2"><p>删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p></li></ul><h3 id="Job-创建">Job 创建</h3><ul class="lvl-0"><li class="lvl-2"><p>yaml 文件: job.yaml</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span>                      <span class="comment"># API 版本，这里使用 batch/v1，适用于 Job 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>                                 <span class="comment"># 资源类型，Job 用于一次性任务，完成后自动退出</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span>                                <span class="comment"># Job 的名称，这里命名为 pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span>            <span class="comment"># Job 完成后，自动删除job的延迟时间，单位为秒。默认不删除</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span>                          <span class="comment"># Job 的并发数，默认为1，即一次只能启动一个 Pod</span></span><br><span class="line">  <span class="attr">template:</span>                               <span class="comment"># Pod 模板，定义 Job 创建的 Pod 的规范</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>                         <span class="comment"># Pod 内的容器列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span>                          <span class="comment"># 容器名称，用户自定义的名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl:5.34.0</span>                <span class="comment"># 使用的镜像，这里是 Perl 5.34.0 官方镜像</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]  <span class="comment"># 容器启动时执行的命令，计算并输出圆周率的 2000 位小数</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span>                <span class="comment"># 重启策略，设置为 Never，表示 Pod 失败时不会自动重启</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span>                         <span class="comment"># Job 重试次数上限，若失败超过 4 次，则不再重试，Job 状态将标记为 Failed。默认为 6</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启动Job</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f job.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看 Job</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Job</span></span><br><span class="line">kubectl get <span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 查看日志，此时会看到输出 圆周率值</span></span><br><span class="line">kubectl logs <span class="built_in">jobs</span>/pi</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除 Job</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete <span class="built_in">jobs</span>/pi</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 删除</span></span><br><span class="line">kubectl delete -f job.yaml</span><br></pre></td></tr></table></figure><h2 id="CronJob-介绍">CronJob 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>CronJob 通过重复调度启动一次性的 Job。</p></li><li class="lvl-2"><p>CronJob 用于执行排期操作，例如备份、生成报告等。</p></li><li class="lvl-2"><p>一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p></li></ul><h3 id="CronJob-示例：">CronJob 示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: CronJob                               <span class="comment"># 创建CronJob</span></span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">&quot;* * * * *&quot;</span>                     <span class="comment"># 每分钟执行一次，不支持时区设置</span></span><br><span class="line">  successfulJobsHistoryLimit: 3             <span class="comment"># 指定要保留多少成功完成的 Job。默认值为 3</span></span><br><span class="line">  failedJobsHistoryLimit: 1                 <span class="comment"># 指定要保留多少失败完成的 Job。默认值为 1</span></span><br><span class="line">  concurrencyPolicy: Allow                  <span class="comment"># 默认值为 Allow：允许多个 Job 同时运行</span></span><br><span class="line">                                            <span class="comment"># Forbid：不允许多个 Job 同时运行。如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会忽略新 Job 的执行。 另请注意，当老 Job 执行完成时，仍然会考虑 .spec.startingDeadlineSeconds，可能会导致新的 Job 执行。</span></span><br><span class="line">                                            <span class="comment"># Replace：如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会用新 Job 替换当前正在运行的 Job。</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox:1.28</span><br><span class="line">            imagePullPolicy: IfNotPresent</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="built_in">date</span>; <span class="built_in">echo</span> Hello from the Kubernetes cluster</span><br><span class="line">          restartPolicy: OnFailure</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>.spec.schedule</code> 字段是必需的。该字段的值遵循 Cron 语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ┌───────────── 分钟 (0 - 59)</span></span><br><span class="line"><span class="comment"># │ ┌───────────── 小时 (0 - 23)</span></span><br><span class="line"><span class="comment"># │ │ ┌───────────── 月的某天 (1 - 31)</span></span><br><span class="line"><span class="comment"># │ │ │ ┌───────────── 月份 (1 - 12)</span></span><br><span class="line"><span class="comment"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）</span></span><br><span class="line"><span class="comment"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间表中的问号 (?) 和星号 * 含义相同，它们用来表示给定字段的任何可用值。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>除了标准语法，还可以使用一些类似 @monthly 的宏</p></li></ul><table><thead><tr><th><strong>输入</strong></th><th><strong>描述</strong></th><th><strong>等价 Cron 表达式</strong></th></tr></thead><tbody><tr><td><code>@yearly</code> 或 <code>@annually</code></td><td>每年 1 月 1 日的午夜运行一次</td><td><code>0 0 1 1 *</code></td></tr><tr><td><code>@monthly</code></td><td>每月第一天的午夜运行一次</td><td><code>0 0 1 * *</code></td></tr><tr><td><code>@weekly</code></td><td>每周的周日午夜运行一次</td><td><code>0 0 * * 0</code></td></tr><tr><td><code>@daily</code> 或 <code>@midnight</code></td><td>每天午夜运行一次</td><td><code>0 0 * * *</code></td></tr><tr><td><code>@hourly</code></td><td>每小时的开始运行一次</td><td><code>0 * * * *</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>管理cronjob</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建cronjob</span></span><br><span class="line">kubectl create -f cronjob.yaml</span><br><span class="line"><span class="comment"># 查看cronjob</span></span><br><span class="line">kubectl get cronjob hello -o yaml</span><br><span class="line"><span class="comment"># 删除cronjob</span></span><br><span class="line">kubectl delete cronjob hello</span><br><span class="line">k delete -f cronjob.yaml</span><br></pre></td></tr></table></figure><h2 id="以下是-Kubernetes-中-Job-和-CronJob-的对比表">以下是 Kubernetes 中 Job 和 CronJob 的对比表</h2><table><thead><tr><th>特性</th><th>Job</th><th>CronJob</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>一次性任务，完成即结束</td><td>定时周期性任务，按照时间计划定时运行</td></tr><tr><td><strong>调度方式</strong></td><td>手动创建或由控制器触发</td><td>按照 Cron 表达式自动周期性调度</td></tr><tr><td><strong>常用场景</strong></td><td>数据批处理、数据库迁移、一次性任务</td><td>每天备份、定时报告生成、周期性检查</td></tr><tr><td><strong>配置关键字段</strong></td><td><code>spec.template</code></td><td><code>spec.schedule</code>（Cron 表达式） + <code>spec.jobTemplate</code></td></tr><tr><td><strong>启动频率</strong></td><td>创建后立刻启动一次</td><td>根据 <code>schedule</code> 定期启动</td></tr><tr><td><strong>并发控制</strong></td><td>不支持并发策略</td><td>支持 <code>concurrencyPolicy</code>（Allow、Forbid、Replace）</td></tr><tr><td><strong>保留历史任务</strong></td><td>无保留，任务完成后直接终结</td><td>可配置保留成功或失败任务数：<code>successfulJobsHistoryLimit</code>、<code>failedJobsHistoryLimit</code></td></tr><tr><td><strong>失败重试机制</strong></td><td>支持 <code>backoffLimit</code>、<code>restartPolicy</code></td><td>同样支持，作用于每次周期性运行产生的 Job 上</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/&quot;&gt;k8s Job 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/&quot;&gt;k8s CronJob 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 DaemonSet</title>
    <link href="https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/"/>
    <id>https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/</id>
    <published>2025-07-15T14:30:05.000Z</published>
    <updated>2025-07-16T08:43:59.925Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">k8s DaemonSet 介绍</a></p></li></ul><span id="more"></span><h2 id="DaemonSet-介绍">DaemonSet 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>DaemonSet 定义了提供节点本地设施的 Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具，或者作为 add-on 的一部分。</p></li><li class="lvl-2"><p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p></li><li class="lvl-2"><p>DaemonSet 的一些典型用法：</p><ul class="lvl-2"><li class="lvl-4">在每个节点上运行集群守护进程</li><li class="lvl-4">在每个节点上运行日志收集守护进程</li><li class="lvl-4">在每个节点上运行监控守护进程</li></ul></li><li class="lvl-2"><p>DaemonSet 与 Deployment 的主要区别是：</p><ul class="lvl-2"><li class="lvl-4">无法自定义副本数量</li><li class="lvl-4">每个node上都会运行且只允许运行一个 Pod</li><li class="lvl-4">当有新Node加入集群时，会自动在其上部署并运行Pod副本，当Node从集群移除时，这些Pod也会被回收</li></ul></li></ul><h2 id="DaemonSet-管理">DaemonSet 管理</h2><h3 id="DaemonSet-创建">DaemonSet 创建</h3><ul class="lvl-0"><li class="lvl-2"><p>DaemonSet 只能 通过 <code>yaml</code> 创建，不支持 <code>create</code> 创建</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 yaml 文件创建</span></span><br><span class="line">kubectl apply -f daemonset.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>一个简单的 <code>daemonset.yaml</code> 文件说明</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>                  <span class="comment"># 指定使用的 API 版本，这里是 apps/v1，适用于 DaemonSet 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>                     <span class="comment"># Kubernetes 资源类型，这里是部署（DaemonSet）</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                       <span class="comment"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                        <span class="comment"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class="line"><span class="attr">spec:</span>                                <span class="comment"># 配置项</span></span><br><span class="line">  <span class="attr">selector:</span>                          <span class="comment"># 选择器，指定要管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>                     <span class="comment"># 标签选择器</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>                     <span class="comment"># 选择器，指定 DaemonSet 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class="line">  <span class="attr">updateStrategy:</span>                    <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span>              <span class="comment"># RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。</span></span><br><span class="line">                                     <span class="comment"># OnDelete：使用 OnDelete 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet Pod 之后，新的 DaemonSet Pod 才会被自动创建。</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span>                   <span class="comment"># 滚动升级的配置</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span>              <span class="comment"># 最大不可用 Pod 的数量，这里是 1，默认值为 1</span></span><br><span class="line">  <span class="attr">template:</span>                          <span class="comment"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>                   <span class="comment"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 容器的名称</span></span><br></pre></td></tr></table></figure><h3 id="查看-DaemonSet">查看 DaemonSet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 DaemonSet ，默认显示 default 命名空间下的 DaemonSet</span></span><br><span class="line">kubectl get daemonsets</span><br><span class="line">kubectl get ds <span class="comment"># 简称</span></span><br><span class="line"><span class="comment"># 查看 kube-system 命名空间下的 DaemonSet</span></span><br><span class="line">kubectl get ds -n kube-system</span><br><span class="line"><span class="comment"># 查看所有命名空间下的 DaemonSet</span></span><br><span class="line">kubectl get ds -A</span><br><span class="line"><span class="comment"># -o wide: 显示 deploy 的详细信息</span></span><br><span class="line">kubectl get ds -o wide</span><br><span class="line"><span class="comment"># 显示 DaemonSet 的标签</span></span><br><span class="line">kubectl get ds --show-labels</span><br><span class="line"><span class="comment"># 按 DaemonSet 的标签进程查询</span></span><br><span class="line">kubectl get ds -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class="line"><span class="comment"># 持续查看 DaemonSet 的状态，当 DaemonSet 状态发生改变时，会实时显示</span></span><br><span class="line">kubectl get ds -w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod、ds 的详细信息</span></span><br><span class="line">$ k get pod,ds -owide</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-6g8j8   1/1     Running   0          9m3s   10.244.126.18   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-tnvhn   1/1     Running   0          9m3s   10.244.194.89   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE    CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">daemonset.apps/nginx   2         2         2       2            2           &lt;none&gt;          9m3s   nginx        nginx    app=nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="允许-master-节点运行-pod">允许 master 节点运行 pod</h3><ul class="lvl-0"><li class="lvl-2"><p>上面看到pod只在worker1和worker2上运行,而没有在master节点上运行</p></li><li class="lvl-2"><p>默认情况下，Kubernetes 不允许在 master 节点上运行 Pod，这是因为master节点有污点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node k8s-master | grep Taints</span><br><span class="line">Taints:             node-role.kubernetes.io/control-plane:NoSchedule</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了能让pod运行在具有污点的节点上，我们需要为pod指定容忍度(tolerations)，实际上 DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod</p></li></ul><table><thead><tr><th>容忍度键名</th><th>效果</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td><code>NoExecute</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到不健康或未就绪的节点上，且不会被驱逐。</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td><code>NoExecute</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到不可达的节点上，且不会被驱逐。</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td><code>NoSchedule</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到存在磁盘压力的节点上。</td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td><code>NoSchedule</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到存在内存压力的节点上。</td></tr><tr><td><code>node.kubernetes.io/pid-pressure</code></td><td><code>NoSchedule</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到存在进程数压力的节点上。</td></tr><tr><td><code>node.kubernetes.io/unschedulable</code></td><td><code>NoSchedule</code></td><td>Exists</td><td>DaemonSet Pod 可以被调度到标记为不可调度的节点上。</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td><code>NoSchedule</code></td><td>Exists</td><td>针对 <code>spec.hostNetwork: true</code> 的 Pod，可以被调度到网络不可用的节点上。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>增加可以运行在 master 节点的容忍度</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span>                                   <span class="comment"># 增加容忍度</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span> <span class="comment"># 容忍控制平面节点</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span>                           <span class="comment"># 操作符</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span>                         <span class="comment"># 污点标签</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>增加容忍度后重新运行</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f daemonset.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ k get pod,ds -o wide</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-4gxwh   1/1     Running   0          79m   10.244.235.205   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-gx7tf   1/1     Running   0          78m   10.244.126.21    k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-sl8cc   1/1     Running   0          78m   10.244.194.92    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">daemonset.apps/nginx   3         3         3       3            3           &lt;none&gt;          3h42m   nginx        nginx    app=nginx</span><br></pre></td></tr></table></figure><h3 id="访问pod中的nginx服务">访问pod中的nginx服务</h3><ul class="lvl-0"><li class="lvl-2"><p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意pod的IP，端口80</span></span><br><span class="line">curl http://10.244.194.92</span><br></pre></td></tr></table></figure><h3 id="查看-DaemonSet-详情">查看 DaemonSet 详情</h3><ul class="lvl-0"><li class="lvl-2"><p>当 DaemonSet 运行错误时，可以通过该命令查看 DaemonSet 的详情，找到错误原因</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe ds &lt;ds-name&gt;</span><br><span class="line">kubectl describe ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="删除-DaemonSet">删除 DaemonSet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete ds &lt;ds-name&gt;</span><br><span class="line">kubectl delete ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 yaml 文件删除</span></span><br><span class="line">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure><h3 id="查看-DaemonSet-日志">查看 DaemonSet 日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs ds/&lt;ds-name&gt;</span><br><span class="line">kubectl logs ds/&lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="滚动升级与回滚-DaemonSet">滚动升级与回滚 DaemonSet</h3><ul class="lvl-0"><li class="lvl-2"><p>对 <code>RollingUpdate</code> 类型的 <code>DaemonSet</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p></li><li class="lvl-2"><p>我们修改过 <code>DaemonSet</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p></li><li class="lvl-2"><p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl set image ds/&lt;ds-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=true</span></span><br><span class="line">kubectl <span class="built_in">set</span> image ds nginx nginx=nginx:1.9.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看滚动升级状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl rollout status ds/&lt;ds-name&gt;</span></span><br><span class="line">kubectl rollout status ds nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看历史版本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的序号表示版本号</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> ds nginx</span><br><span class="line"><span class="comment"># 查看指定版本的详情</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> ds nginx --revision=1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>回滚</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退到前一个版本</span></span><br><span class="line">kubectl rollout undo ds nginx</span><br><span class="line"><span class="comment"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class="line">kubectl rollout undo ds nginx --to-revision=1</span><br></pre></td></tr></table></figure><h2 id="Deployment-和-DaemonSet-的对比总结">Deployment 和 DaemonSet 的对比总结</h2><table><thead><tr><th>特性</th><th><strong>Deployment</strong></th><th><strong>DaemonSet</strong></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>管理一组可水平扩展的 Pod，按需副本数运行</td><td>在每个（或特定）节点上运行 <strong>一个副本</strong> 的 Pod</td></tr><tr><td><strong>常见场景</strong></td><td>无状态服务、Web 服务、API、后端服务</td><td>日志采集（如 fluentd）、监控（如 node-exporter）、系统守护进程</td></tr><tr><td><strong>副本控制</strong></td><td>可通过 <code>spec.replicas</code> 灵活控制副本数</td><td>每个匹配的节点自动运行一个 Pod，无需设置 <code>replicas</code></td></tr><tr><td><strong>节点分布</strong></td><td>Pod 分布随机，调度器选择可用节点</td><td>Pod 分布固定，<strong>每个匹配节点必跑一个 Pod</strong></td></tr><tr><td><strong>更新策略</strong></td><td><code>RollingUpdate</code>（默认）、<code>Recreate</code>，支持回滚</td><td><code>RollingUpdate</code>（默认从 Kubernetes 1.6 起支持）</td></tr><tr><td><strong>伸缩方式</strong></td><td><code>kubectl scale deployment</code> 可以水平扩缩容</td><td><strong>不支持手动伸缩</strong>，跟随节点变化自动伸缩</td></tr><tr><td><strong>Pod 更新行为</strong></td><td>按策略滚动更新全部副本</td><td>每个节点上的 Pod 逐个滚动更新</td></tr><tr><td><strong>调度策略</strong></td><td>通过调度器分配节点，可搭配 <code>affinity</code> 使用</td><td>默认调度所有节点，可用 <code>nodeSelector</code>、<code>affinity</code>、<code>taints</code> 控制</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/&quot;&gt;k8s DaemonSet 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Deployment</title>
    <link href="https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/"/>
    <id>https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/</id>
    <published>2025-07-14T14:30:05.000Z</published>
    <updated>2025-07-15T03:44:28.895Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">k8s Deployment 介绍</a></p></li></ul><span id="more"></span><h2 id="Deployment-介绍">Deployment 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>在使用k8s创建容器时，我们一般不会直接创建pod，而是创建 deployment，daemonSet，StatefulSet等等。</p></li><li class="lvl-2"><p>Deployment 用于管理运行一个应用负载的一组 Pod，通常适用于不保持状态的负载。</p></li><li class="lvl-2"><p>Deployment 是最常用的无状态服务控制器，由Deployment、ReplicaSet、Pod组成、支持集群扩容缩容、滚动、更新、自动维护Pod可用性及副本数量等功能，<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>和Pod由Deployment自动管理，用户无需干预，也就是说，创建一个Deployment后，K8S会自动创建ReplicaSet，并创建指定数量的Pod。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Tcj2Px.png" alt="" width="1200" height="600"></p></li></ul><h2 id="Deployment-管理">Deployment 管理</h2><h3 id="Deployment-创建">Deployment 创建</h3><ul class="lvl-0"><li class="lvl-2"><p><code>create</code> 创建</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 多副本，--replicas=3 创建3个副本</span></span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=3</span><br><span class="line"><span class="comment"># -o 生成 yaml 文件, --dry-run: 不真的执行创建</span></span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml &gt; deployment.yaml</span><br><span class="line"><span class="comment"># 通过 yaml 文件创建</span></span><br><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>一个简单的 <code>deployment.yaml</code> 文件说明</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>                  <span class="comment"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>                     <span class="comment"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                       <span class="comment"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                        <span class="comment"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class="line"><span class="attr">spec:</span>                                <span class="comment"># 配置项</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>                        <span class="comment"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class="line">  <span class="attr">selector:</span>                          <span class="comment"># 选择器，指定要管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>                     <span class="comment"># 标签选择器</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>                     <span class="comment"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class="line">  <span class="attr">strategy:</span>                          <span class="comment"># 用新Pod替换现有Pod的部署策略，可省略，默认就是滚动更新</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span>              <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span>                   <span class="comment"># 滚动更新方式，type: RollingUpdate 时有效</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span>                  <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span>            <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class="line">  <span class="attr">template:</span>                          <span class="comment"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>                   <span class="comment"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 容器的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要新了解的配置项就是spec下面几个选项：</span></span><br><span class="line"><span class="comment"># replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</span></span><br><span class="line"><span class="comment"># selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</span></span><br><span class="line"><span class="comment"># template：模板，就是当前控制器创建pod所使用的模板，里面其实就是前一章学过的pod的定义</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取 deployment 的 yaml 文件配置项帮助</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如，这里查看用新Pod替换现有Pod的部署策略</span></span><br><span class="line">$ kubectl explain deployment.spec.strategy</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">DESCRIPTION:</span><br><span class="line">    The deployment strategy to use to replace existing pods with new ones.</span><br><span class="line">    DeploymentStrategy describes how to replace existing pods with new ones.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">  rollingUpdate&lt;RollingUpdateDeployment&gt;</span><br><span class="line">    Rolling update config params. Present only <span class="keyword">if</span> DeploymentStrategyType =</span><br><span class="line">    RollingUpdate.</span><br><span class="line"></span><br><span class="line">  <span class="built_in">type</span>&lt;string&gt;</span><br><span class="line">  enum: Recreate, RollingUpdate</span><br><span class="line">    Type of deployment. Can be <span class="string">&quot;Recreate&quot;</span> or <span class="string">&quot;RollingUpdate&quot;</span>. Default is</span><br><span class="line">        RollingUpdate.</span><br><span class="line"></span><br><span class="line">        Possible enum values:</span><br><span class="line">        <span class="comment"># 在创建新pod之前，先删除所有现有的pod</span></span><br><span class="line">        - `<span class="string">&quot;Recreate&quot;</span>` Kill all existing pods before creating new ones.</span><br><span class="line">        <span class="comment"># 使用滚动更新方式用新的 ReplicaSet 替换旧的 ReplicaSet更新，即逐步缩减旧的ReplicaSet并扩大新的ReplicaSet</span></span><br><span class="line">        - `<span class="string">&quot;RollingUpdate&quot;</span>` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">yaml 文件中，出现了 <code>metadata.labels</code>,<code>spec.selector.matchLabels</code> 以及 <code>template.metadata.labels</code>，三者是什么关系？</li></ul><ol><li class="lvl-3">metadata.labels（Deployment 的标签）</li></ol><blockquote><p>给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系<br>常用于资源分组、查找（比如：kubectl get deploy -l app=nginx）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># 属于这个 Deployment 的“标签”，只是标识它自己</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>spec.selector.matchLabels（选择器）</p></li></ol><blockquote><p>指定 Deployment 要管理哪些 Pod<br>必须精确匹配 Pod 的标签<br>决定 Deployment 会不会“接管”某些 Pod</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>template.metadata.labels（模板中的 Pod 标签）</p></li></ol><blockquote><p>Pod 模板中定义的标签<br>Deployment 按这个模板创建 Pod<br>必须与 matchLabels 完全一致，否则会报错</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 的标签，必须与 selector 匹配！</span></span><br></pre></td></tr></table></figure><p>🔁 关系图示意：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Deployment</span></span><br><span class="line"><span class="string">│</span></span><br><span class="line"><span class="string">├─</span> <span class="string">metadata.labels</span>                <span class="string">←</span> <span class="string">Deployment</span> <span class="string">本身的标签（非关键）</span></span><br><span class="line"><span class="string">│</span></span><br><span class="line"><span class="string">├─</span> <span class="string">spec.selector.matchLabels</span> <span class="string">─┐</span></span><br><span class="line"><span class="string">│</span>                             <span class="string">│</span></span><br><span class="line"><span class="string">└─</span> <span class="string">spec.template.metadata.labels</span> <span class="string">←</span> <span class="string">必须匹配</span> <span class="string">selector，才能让</span> <span class="string">Pod</span> <span class="string">被</span> <span class="string">Deployment</span> <span class="string">管理</span></span><br></pre></td></tr></table></figure></div><h3 id="Deployment-扩缩容">Deployment 扩缩容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扩容到5个，原先有3个，这里会再创建2个</span></span><br><span class="line">kubectl scale deployment nginx --replicas=5</span><br><span class="line"><span class="comment"># 缩容到3个，原先有5个，这里会删除2个</span></span><br><span class="line">kubectl scale deployment nginx --replicas=3</span><br></pre></td></tr></table></figure><h3 id="查看-Deployment">查看 Deployment</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment ，默认显示 default 命名空间下的 deployments</span></span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get deploy <span class="comment"># 简称</span></span><br><span class="line"><span class="comment"># 查看 kube-system 命名空间下的 Deployment</span></span><br><span class="line">kubectl get deploy -n kube-system</span><br><span class="line"><span class="comment"># 查看所有命名空间下的 Deployment</span></span><br><span class="line">kubectl get deploy -A</span><br><span class="line"><span class="comment"># -o wide: 显示 deploy 的详细信息</span></span><br><span class="line">kubectl get deployments -o wide</span><br><span class="line"><span class="comment"># 显示 Deployment 的标签</span></span><br><span class="line">kubectl get deploy --show-labels</span><br><span class="line"><span class="comment"># 按 Deployment 的标签进程查询</span></span><br><span class="line">kubectl get deploy -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class="line"><span class="comment"># 持续查看 Deployment 的状态，当 Deployment 状态发生改变时，会实时显示</span></span><br><span class="line">kubectl get deploy -w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod、deploy、replicaset</span></span><br><span class="line">$ k get pod,deploy,rs -owide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-5869d7778c-4sqwf   1/1     Running   0          105s   10.244.126.11   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-5869d7778c-kn6pg   1/1     Running   0          105s   10.244.126.12   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-5869d7778c-zkwkd   1/1     Running   0          18m    10.244.194.82   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">deployment.apps/nginx   3/3     3            3           18m   nginx        nginx    app=nginx</span><br><span class="line"></span><br><span class="line">NAME                               DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">replicaset.apps/nginx-5869d7778c   3         3         3       18m   nginx        nginx    app=nginx,pod-template-hash=5869d7778c</span><br></pre></td></tr></table></figure><h3 id="访问pod中的nginx服务">访问pod中的nginx服务</h3><ul class="lvl-0"><li class="lvl-2"><p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意pod的IP，端口80</span></span><br><span class="line">curl http://10.244.194.82</span><br></pre></td></tr></table></figure><h3 id="查看-Deployment-详情">查看 Deployment 详情</h3><ul class="lvl-0"><li class="lvl-2"><p>当 Deployment 运行错误时，可以通过该命令查看 Deployment 的详情，找到错误原因</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deploy &lt;deploy-name&gt;</span><br><span class="line">kubectl describe deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="删除-Deployment">删除 Deployment</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deploy &lt;deploy-name&gt;</span><br><span class="line">kubectl delete deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 yaml 文件删除</span></span><br><span class="line">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure><h3 id="查看-Deployment-日志">查看 Deployment 日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs deploy/&lt;deploy-name&gt;</span><br><span class="line">kubectl logs deploy/&lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="滚动升级与回滚-Deployment">滚动升级与回滚 Deployment</h3><ul class="lvl-0"><li class="lvl-2"><p>对 <code>RollingUpdate</code> 类型的 <code>Deployment</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p></li><li class="lvl-2"><p>我们修改过 <code>Deployment</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p></li><li class="lvl-2"><p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set image: 这里表示要改变的是镜像， --record=true 表示记录此次操作</span></span><br><span class="line"><span class="comment"># kubectl set image deploy &lt;deploy-name&gt; &lt;container-name&gt;=&lt;image-name&gt;:&lt;tag&gt;</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看历史版本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的序号表示版本号</span></span><br><span class="line">$ kubectl rollout <span class="built_in">history</span> deploy nginx</span><br><span class="line">deployment.apps/nginx</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         kubectl <span class="built_in">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定版本的详情</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deploy nginx --revision=1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看更新状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout status deploy nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>回滚</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退到前一个版本</span></span><br><span class="line">kubectl rollout undo deploy nginx</span><br><span class="line"><span class="comment"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class="line">kubectl rollout undo deploy nginx --to-revision=1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/&quot;&gt;k8s Deployment 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Pod</title>
    <link href="https://blog.hanqunfeng.com/2025/07/04/k8s-pod/"/>
    <id>https://blog.hanqunfeng.com/2025/07/04/k8s-pod/</id>
    <published>2025-07-04T14:30:05.000Z</published>
    <updated>2025-07-19T13:51:31.816Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">k8s Pod 介绍</a></p></li></ul><span id="more"></span><h2 id="Pod-介绍">Pod 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p></li><li class="lvl-2"><p>Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。</p></li><li class="lvl-2"><p>Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p></li><li class="lvl-2"><p>Kubernetes 集群中的 Pod 主要有两种用法：</p><ul class="lvl-2"><li class="lvl-4">运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li><li class="lvl-4">运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nLmg0X.png" alt=""></li></ul></li></ul><h2 id="Pod-管理">Pod 管理</h2><h3 id="Pod-创建">Pod 创建</h3><ul class="lvl-0"><li class="lvl-2"><p><code>run</code> 创建</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx</span><br><span class="line"><span class="comment"># 输出 yaml</span></span><br><span class="line">kubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml</span><br><span class="line"><span class="comment"># 通过 yaml 文件创建</span></span><br><span class="line">kubectl apply -f pod.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>pod 中至少包含两个容器，一个是业务容器，比如这里的 nginx，另一个是 <code>pause</code> 容器，负责共享容器的网络，进程，存储等资源。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 crictl ps 是看不到 pause 容器的，我们可以使用 ctr 命令查看，ctr 是 containerd 的命令行工具</span></span><br><span class="line">ctr --namespace=k8s.io c <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 查看容器所属的pod</span></span><br><span class="line">ctr --namespace=k8s.io c info &lt;container-id&gt; | grep <span class="string">&#x27;pod.name&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="pod-yaml-文件说明"><code>pod.yaml</code> 文件说明</h3><ul class="lvl-0"><li class="lvl-2"><p>因为 Pod 不支持扩缩容，所以日常使用时一般不会直接创建 Pod，而是创建 <code>Deployment</code>, <code>DaemonSet</code>等这些工作负载资源，这些后面会介绍到。</p></li><li class="lvl-2"><p>但我们这里还是要重点介绍一下 Pod 的 yaml 文件格式，因为它是后面所有资源创建的基础。</p></li><li class="lvl-2"><p>一个最基础的 Pod 配置如下：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                   <span class="comment"># 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                        <span class="comment"># 必填。资源类型：Pod</span></span><br><span class="line"><span class="attr">metadata:</span>                        <span class="comment"># 必填。元数据，包含 Pod 的名称、命名空间、标签、注解等信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                    <span class="comment"># 必填。Pod 的名称，命名空间中唯一</span></span><br><span class="line"><span class="attr">spec:</span>                            <span class="comment"># 必填。资源的特性描述（规约），定义Pod具体行为的部分</span></span><br><span class="line">  <span class="attr">containers:</span>                    <span class="comment"># 必填。容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span>                 <span class="comment"># 必填。容器使用的镜像</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>                  <span class="comment"># 必填。容器名称，在同一个 Pod 内必须唯一</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Pod是用来配置容器的，我们在学习docker时知道，容器有非常多的配置项，比如端口、网络、存储等，而 pod 的配置项更丰富。</p></li><li class="lvl-2"><p>一个Pod的配置主要包含两大部分：<code>metadata</code> 和 <code>spec</code>，每一项中包含的配置项非常多，这里只对常用的配置项进行说明，若要查看每个配置项的说明可以通过如下命令获取：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod开头，配置项以 . 连接，例如：</span></span><br><span class="line">kubectl explain pod.metadata</span><br><span class="line">kubectl explain pod.metadata.labels</span><br><span class="line">kubectl explain pod.spec</span><br><span class="line">kubectl explain pod.spec.containers</span><br><span class="line">kubectl explain pod.spec.containers.ports</span><br></pre></td></tr></table></figure><h4 id="metadata">metadata</h4><ul class="lvl-0"><li class="lvl-2"><p>metadata 是 Pod 的元数据，比如 Pod 的名称、命名空间、标签、注解等。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span>                 <span class="comment"># 元数据部分</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span>         <span class="comment"># Pod 的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>      <span class="comment"># Pod 所在的命名空间，默认是 default</span></span><br><span class="line">  <span class="attr">labels:</span>                 <span class="comment"># 标签，用于选择器、管理、分组</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">annotations:</span>            <span class="comment"># 注解，用于添加非结构化元信息</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;A sample pod for demonstration&quot;</span></span><br></pre></td></tr></table></figure><h4 id="spec">spec</h4><ul class="lvl-0"><li class="lvl-2"><p>spec 描述了 Pod 的配置信息，包括 Pod 的容器、存储、网络、资源限制、调度策略等</p></li></ul><h5 id="spec-containers">spec.containers</h5><ul class="lvl-0"><li class="lvl-2"><p>containers 描述了 Pod 中容器的配置信息，包括镜像、启动命令、环境变量、资源限制、卷挂载等</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span>                      <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>              <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>           <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>          <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]   <span class="comment">#获取镜像的策略，当镜像标签为 latest 时默认值为 Always，否则为 IfNotPresent</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]         <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>     <span class="comment">#容器的工作目录，如果为指定，则默认为镜像中的配置</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>          <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>         <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span>    <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span>    <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span>                 <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>         <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span>    <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>        <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>                   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>         <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span>        <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span>             <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>              <span class="comment">#资源限制的设置(上限)</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>        <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>     <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span>            <span class="comment">#资源请求的设置(下限)</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>        <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>     <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span>                         <span class="comment"># Pod 的具体规范</span></span><br><span class="line">  <span class="attr">containers:</span>                 <span class="comment"># Pod 中的容器数组，可以有多个容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span>   <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.25</span>       <span class="comment"># 使用的镜像</span></span><br><span class="line">      <span class="attr">ports:</span>                  <span class="comment"># 容器开放的端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>   <span class="comment"># 容器内部端口，只是声明性的字段，不具有决定作用</span></span><br><span class="line">      <span class="attr">env:</span>                    <span class="comment"># 环境变量配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENVIRONMENT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">production</span></span><br><span class="line">      <span class="attr">resources:</span>              <span class="comment"># 资源限制和请求</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span>     <span class="comment"># 最大内存限制</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>            <span class="comment"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class="line">          <span class="comment"># cpu: 1000m        # 1000m = 1 核</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span>     <span class="comment"># 初始分配内存</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span>          <span class="comment"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class="line">          <span class="comment"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br><span class="line">      <span class="attr">volumeMounts:</span>           <span class="comment"># 挂载到容器的卷</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-storage</span>   <span class="comment"># 卷名称，需要和 volumes 中定义的卷名称一致</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂载到容器的目录</span></span><br></pre></td></tr></table></figure><h5 id="spec-containers-command-args">spec.containers.command | args</h5><ul class="lvl-0"><li class="lvl-2"><p>容器启动时执行的命令</p></li><li class="lvl-2"><p>默认情况下，容器启动时，会从镜像中获取命令并执行，如果这里配置了命令，则容器启动时，会执行这里的命令，而不是镜像中的命令</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.36</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>或者</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.36</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>或者</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.36</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span>                  <span class="comment"># 使用 | 符号，表示多行输入</span></span><br><span class="line">        <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">5</span></span><br><span class="line">        <span class="string">done</span></span><br></pre></td></tr></table></figure><h5 id="spec-restartPolicy">spec.restartPolicy</h5><ul class="lvl-0"><li class="lvl-2"><p>指在系统发生故障或意外停机时，系统或应用程序如何处理和恢复的策略</p><ul class="lvl-2"><li class="lvl-4">Always：总是重启</li><li class="lvl-4">OnFailure：失败时重启</li><li class="lvl-4">Never：不重启</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span> <span class="comment">#失败时重启</span></span><br></pre></td></tr></table></figure><h4 id="spec-terminationGracePeriodSeconds">spec.terminationGracePeriodSeconds</h4><ul class="lvl-0"><li class="lvl-2"><p>Pod 删除时，系统给 Pod 留的时间，用于完成清理工作</p></li><li class="lvl-2"><p>宽限期为避免服务突然中断,造成事物不一致的问题,当容器运行完自己的任务后,会等待一段时间,然后优雅的退出</p></li><li class="lvl-2"><p>默认值为 30s，单位为秒</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h4 id="spec-volumes">spec.volumes</h4><ul class="lvl-0"><li class="lvl-2"><p>Kubernetes 中的卷（volumes）是为了在容器之间共享数据，或将数据从容器持久化到外部存储。</p></li></ul><h5 id="emptyDir（最简单，Pod-生命周期内有效）">emptyDir（最简单，Pod 生命周期内有效）</h5><ul class="lvl-0"><li class="lvl-2"><p>emptyDir 卷是一个没有名字的临时目录，Pod 创建时创建，Pod 删除时删除。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">html-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html-volume</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;  <span class="comment"># 表示一个空目录，在 Pod 生命周期内有效</span></span><br></pre></td></tr></table></figure><h5 id="hostPath（挂载宿主机路径）">hostPath（挂载宿主机路径）</h5><ul class="lvl-0"><li class="lvl-2"><p>用于测试或非常了解宿主机结构的场景。生产不推荐。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mydata</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/tmp/data</span>        <span class="comment"># 宿主机路径</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>  <span class="comment"># 如果目录不存在就创建</span></span><br></pre></td></tr></table></figure><h5 id="configMap（挂载配置文件）">configMap（挂载配置文件）</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">my-configmap</span>   <span class="comment"># 需提前创建 ConfigMap，这个后面会介绍</span></span><br></pre></td></tr></table></figure><h5 id="使用-PVC（挂载持久化存储）">使用 PVC（挂载持久化存储）</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">persistent-storage</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">mypvc</span>  <span class="comment"># PVC 名称，需要提前创建，这个后面会介绍</span></span><br></pre></td></tr></table></figure><h4 id="spec-tolerations-Pod容忍策略">spec.tolerations: Pod容忍策略</h4><ul class="lvl-0"><li class="lvl-2"><p>tolerations 是 Kubernetes Pod 中用来“容忍”某些 Node 节点的污点（Taints） 的字段。它允许 Pod 被调度到带有相应 Taint 的节点上。</p></li><li class="lvl-2"><p>默认情况下，Pod 会因为 Node 节点的 Taint 而不被调度。</p></li><li class="lvl-2"><p>比如一个 Node 有 NoSchedule 类型的 taint，而 Pod 没有设置对应的 toleration，该 Pod 就不会被调度到这个 Node 上。</p></li><li class="lvl-2"><p>示例： 容忍 key=value:NoSchedule 的 Taint</p></li><li class="lvl-2"><p>假设某节点打了如下污点（Taint）：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key=value:NoSchedule</span><br><span class="line"><span class="comment"># NoSchedule不调度到该节点，除非容忍策略显式允许</span></span><br><span class="line"><span class="comment"># PreferNoSchedule尽量不调度到该节点，但非强制，即可能会被调度</span></span><br><span class="line"><span class="comment"># NoExecute不仅不调度到该节点，还会把现有 Pod 驱逐出去，除非设置容忍时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key=value 是用来 区分不同类型的污点的。比如：</span></span><br><span class="line"><span class="comment">#   你可能给 node1 设置 env=prod:NoSchedule</span></span><br><span class="line"><span class="comment">#   给 node2 设置 gpu=true:NoSchedule</span></span><br><span class="line"><span class="comment">#   给 node3 设置 arch=arm64:NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些都属于不同的“原因”或“标签”，这样你可以：</span></span><br><span class="line"><span class="comment">#   用不同的 toleration 来容忍不同的 taint；</span></span><br><span class="line"><span class="comment">#   精准控制某些 Pod 只能被调度到符合条件的节点。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>容忍该 Taint</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tolerate-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br><span class="line">  <span class="attr">tolerations:</span>        <span class="comment"># 定义容忍策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 匹配方式，必选（Equal:精确匹配 key 和 value。Exists:只匹配 key 是否存在，不关心 value 是什么）</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">&quot;key&quot;</span>        <span class="comment"># 设置键值对的key，为空代表任意键值对</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;value&quot;</span>    <span class="comment"># 设置values的值，</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span> <span class="comment"># 设置容忍的标签，为空代表所有污点标签</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">60</span> <span class="comment"># 容忍时间，这里Pod 最多可停留 60 秒，之后仍会被驱逐，不设置表示永久容忍</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 Kubernetes 中，effect 有 三个可选值：</p></li></ul><table><thead><tr><th><code>effect</code> 值</th><th>含义</th><th>常见用途</th></tr></thead><tbody><tr><td><code>NoSchedule</code></td><td>节点上的污点会阻止 Pod 被调度到该节点，除非 Pod 有相应的 toleration。</td><td><strong>最常用</strong>，例如 Master 节点的容忍。</td></tr><tr><td><code>PreferNoSchedule</code></td><td><strong>倾向于不调度</strong> 到该节点，但不是强制性的，调度器会尽量避免把 Pod 安排到该节点。</td><td>用于软约束，尽量不调度。</td></tr><tr><td><code>NoExecute</code></td><td>不仅不调度新 Pod 到该节点，还会把当前节点上没有相应容忍度的 Pod 驱逐出去（<code>eviction</code>）。</td><td>节点异常自动驱逐，比如 not-ready。</td></tr></tbody></table><h4 id="spec-resources">spec.resources</h4><ul class="lvl-0"><li class="lvl-2"><p>Pod资源配额可以限制命名空间或项目中Pod使用的CPU、内存、存储等资源用量</p></li><li class="lvl-2"><p>CPU资源的约束和请求以豪核（m）为单位。在k8s中1m是最小的调度单元，CPU的一个核心可以看作1000m</p></li></ul><blockquote><p>如果你有2颗cpu，且每CPU为4核心，那么你的CPU资源总量就是8000</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span>                     <span class="comment"># Pod 的具体规范</span></span><br><span class="line">  <span class="attr">containers:</span>             <span class="comment"># Pod 中的容器数组，可以有多个容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span>    <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.25</span>        <span class="comment"># 使用的镜像</span></span><br><span class="line">      <span class="attr">resources:</span>              <span class="comment"># 资源限制和请求</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span>     <span class="comment"># 最大内存限制</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>            <span class="comment"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class="line">          <span class="comment"># cpu: 1000m          # 1000m = 1 核</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span>     <span class="comment"># 初始分配内存</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span>          <span class="comment"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class="line">          <span class="comment"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果有大量的容器需要设置资源配额，为每个Pod设置资源配额策略不方便且不好管理</p></li><li class="lvl-2"><p>可以以名称空间为单位（namespace），限制其资源的使用与创建，在该名称空间中创建的容器都会受到规则的限制。</p></li></ul><h5 id="LimitRange">LimitRange</h5><ul class="lvl-0"><li class="lvl-2"><p>对单个Pod内存、CPU进行配额</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mem-cpu-limit-range</span>          <span class="comment"># LimitRange 的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span>                    <span class="comment"># 生效的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span>                  <span class="comment"># 表示限制的是每个容器（也可设置为 Pod）</span></span><br><span class="line">    <span class="attr">default:</span>                         <span class="comment"># 容器未指定 resources.limits 时使用的默认值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span>                      <span class="comment"># 默认限制 CPU 为 0.5 核</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">512Mi</span>                  <span class="comment"># 默认限制内存为 512 MiB</span></span><br><span class="line">    <span class="attr">defaultRequest:</span>                  <span class="comment"># 容器未指定 resources.requests 时使用的默认请求值，初始值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">100m</span>                      <span class="comment"># 默认请求 CPU 为 0.1 核</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">128Mi</span>                  <span class="comment"># 默认请求内存为 128 MiB</span></span><br><span class="line">    <span class="attr">max:</span>                             <span class="comment"># 容器可设置的最大限制值，即 容器中指定的 resources.limits 的最大允许值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>                       <span class="comment"># 最大可使用 CPU 为 1 核</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">1Gi</span>                    <span class="comment"># 最大可使用内存为 1 GiB</span></span><br><span class="line">    <span class="attr">min:</span>                             <span class="comment"># 容器可设置的最小请求值，，即 容器中指定的 resources.requests 的最小允许值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">50m</span>                       <span class="comment"># 最小请求 CPU 为 0.05 核</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">64Mi</span>                   <span class="comment"># 最小请求内存为 64 MiB</span></span><br></pre></td></tr></table></figure><h5 id="ResourceQuota">ResourceQuota</h5><ul class="lvl-0"><li class="lvl-2"><p>限制整个 namespace 的资源总量</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">compute-resources</span>           <span class="comment"># ResourceQuota 的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span>                   <span class="comment"># 生效的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span>                             <span class="comment"># 定义各类资源的总配额上限</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="string">&quot;10&quot;</span>                      <span class="comment"># 该命名空间最多允许创建 10 个 Pod</span></span><br><span class="line">    <span class="attr">requests.cpu:</span> <span class="string">&quot;2&quot;</span>               <span class="comment"># 所有 Pod 的 requests.cpu 总和最多为 2 核</span></span><br><span class="line">    <span class="attr">requests.memory:</span> <span class="string">4Gi</span>            <span class="comment"># 所有 Pod 的 requests.memory 总和最多为 4 GiB</span></span><br><span class="line">    <span class="attr">limits.cpu:</span> <span class="string">&quot;4&quot;</span>                 <span class="comment"># 所有 Pod 的 limits.cpu 总和最多为 4 核</span></span><br><span class="line">    <span class="attr">limits.memory:</span> <span class="string">8Gi</span>              <span class="comment"># 所有 Pod 的 limits.memory 总和最多为 8 GiB</span></span><br></pre></td></tr></table></figure><h4 id="spec-priorityClassName">spec.priorityClassName</h4><ul class="lvl-0"><li class="lvl-2"><p>Pod 的优先级，优先级就是为了保证重要的Pod被优先调度并运行</p></li><li class="lvl-2"><p>优先级策略：</p><ul class="lvl-2"><li class="lvl-4">非抢占优先：指的是在调度阶段优先进行调度分配，一旦容器调度完成就不可以抢占，资源不足时，只能等待</li><li class="lvl-4">抢占优先：强制调度一个Pod，如果资源不足无法被调度，调度程序会抢占（删除）较低优先级的Pod的资 源，来保证高优先级Pod的运行</li></ul></li><li class="lvl-2"><p>创建优先级</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-non</span> <span class="comment"># 优先级名称</span></span><br><span class="line"><span class="attr">preemptionPolicy:</span> <span class="string">Never</span> <span class="comment"># 策略：非抢占，PreemptLowerPriority:抢占（删除）较低优先级的Pod的资源，保证高优先级Pod的运行</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000</span> <span class="comment"># 优先级，可以设置小于10亿的整数值，值越大，优先级越高，默认优先级0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node01</span> <span class="comment"># 指定匹配具有当前标签的节点</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-non</span> <span class="comment"># 优先级名称</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h4 id="spec-nodeName-nodeSelector-Pod调度策略">spec.nodeName | nodeSelector :Pod调度策略</h4><ul class="lvl-0"><li class="lvl-2"><p>在k8s中，调度是将Pod分配到合适的节点并运行的过程，kube-scheduler是默认调度器，是集群的核心组件。</p></li><li class="lvl-2"><p>调度器通过k8s的监测（Watch）机制来发现集群中尚未被调度到节点上的Pod，调度器依据调度原则将Pod分配到一个合适的节点上运行。</p></li><li class="lvl-2"><p>调度器给一个pod做调度包含两个步骤： 过滤 和 打分</p><ul class="lvl-2"><li class="lvl-4">过滤：首先要筛选出满足Pod所有的资源请求的节点，这里包含计算资源、内存、存储、网络、端口号等等，如果没有节点能满足Pod的需求，Pod将一直停留在Pending状态，直到调度器能够找到合适的节点运行它</li><li class="lvl-4">打分：调度器将节点按照打分规则进行打分，然后按照分数进行排序，将分数最高的节点作为Pod的运行节点。如果存在多个得分最高的节点，调度器会从中随机选取一个。</li></ul></li><li class="lvl-2"><p>Pod 支持两种调度策略：<code>nodeName</code> 和 <code>nodeSelector</code></p></li></ul><h5 id="spec-nodeName">spec.nodeName</h5><ul class="lvl-0"><li class="lvl-2"><p>指定 Pod 运行在指定名称的节点上</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node-1</span> <span class="comment"># 基于节点名进行调度</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myos:httpd</span></span><br></pre></td></tr></table></figure><h5 id="spec-nodeSelector">spec.nodeSelector</h5><ul class="lvl-0"><li class="lvl-2"><p>节点选择器，基于节点的标签进行调度</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>         <span class="comment"># 基于节点标签进行调度</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node-2</span>  <span class="comment"># 标签</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myos:httpd</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为节点设置标签</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有资源都可以设置标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;=&lt;标签value&gt;</span></span><br><span class="line">kubectl label nodes node-2 kubernetes.io/hostname=node-2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;-</span></span><br><span class="line"><span class="comment"># 这里注意，删除标签就是在标签key后加上 - 符号</span></span><br><span class="line">kubectl label nodes node-2 kubernetes.io/hostname-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看资源标签：kubectl get &lt;资源&gt; --show-labels</span></span><br><span class="line">kubectl get nodes --show-labels</span><br><span class="line"><span class="comment"># 查看指定节点的标签</span></span><br><span class="line">kubectl get nodes node-2 --show-labels</span><br></pre></td></tr></table></figure><h4 id="spec-affinity">spec.affinity</h4><ul class="lvl-0"><li class="lvl-2"><p>节点亲和性，用于控制 Pod 调度到具有特定标签的节点上，是 nodeSelector 的增强版本</p></li></ul><table><thead><tr><th>类型</th><th>功能</th><th>示例用途</th></tr></thead><tbody><tr><td>Node Affinity</td><td>控制调度到有指定标签的节点</td><td>SSD、高内存节点</td></tr><tr><td>Pod Affinity</td><td>调度到和某些 Pod 一起的节点</td><td>微服务协同部署</td></tr><tr><td>Pod Anti-Affinity</td><td>避免和某些 Pod 一起的节点</td><td>高可用副本分散部署</td></tr></tbody></table><h5 id="节点亲和性-Node-Affinity">节点亲和性(Node Affinity)</h5><ul class="lvl-0"><li class="lvl-2"><p>Pod 只能调度到具有标签 <code>disktype=ssd</code> 的节点上</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span>   <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># 节点亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 在调度期间必须满足，运行中忽略变化（即调度后标签变了不会驱逐 Pod）。也可以设置为 preferredDuringSchedulingIgnoredDuringExecution，表示节点亲和性优先级高，但不强制要求必须满足</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点选择器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 匹配表达式，支持复杂逻辑，比如 In、NotIn、Exists、DoesNotExist、Gt、Lt。</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disktype</span> <span class="comment"># 键</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span> <span class="comment"># 操作符</span></span><br><span class="line">            <span class="attr">values:</span> <span class="comment"># 值</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><h5 id="Pod-亲和性-Pod-Affinity">Pod 亲和性(Pod Affinity)</h5><ul class="lvl-0"><li class="lvl-2"><p>Pod 会被调度到 与标签为 app=web 的 Pod 所在同一节点（或拓扑层）上。</p></li></ul><blockquote><p>通常用于需要紧密协作的服务部署在一起（如同一机器内通信）。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span>  <span class="comment"># pod 亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span>  <span class="comment"># 标签选择器</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 标签选择条件</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span> <span class="comment"># 键</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span> <span class="comment"># 操作符</span></span><br><span class="line">            <span class="attr">values:</span>  <span class="comment"># 值</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">&quot;kubernetes.io/hostname&quot;</span> <span class="comment"># 拓扑键，表示“同一主机”</span></span><br></pre></td></tr></table></figure><h5 id="Pod-反亲和性-Pod-Anti-Affinity">Pod 反亲和性(Pod Anti-Affinity)</h5><ul class="lvl-0"><li class="lvl-2"><p>表示不能和 app=web 的 Pod 在同一节点上</p></li></ul><blockquote><p>常用于高可用部署，避免多个副本部署在同一个节点。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-anti-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment"># Pod 反亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">&quot;kubernetes.io/hostname&quot;</span></span><br></pre></td></tr></table></figure><h5 id="节点亲和性-Node-Affinity-两种策略的对比">节点亲和性 (Node Affinity) 两种策略的对比</h5><table><thead><tr><th>策略字段</th><th>含义</th><th>行为特点</th><th>场景适用</th><th>是否强制</th></tr></thead><tbody><tr><td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td><td><strong>“必须满足”亲和性规则</strong></td><td>Pod <strong>调度时必须满足条件</strong>，不满足则不调度；调度后节点变化不触发驱逐</td><td>硬性约束，比如必须调度到有 GPU 的节点</td><td>✅ 强制</td></tr><tr><td><code>preferredDuringSchedulingIgnoredDuringExecution</code></td><td><strong>“尽量满足”亲和性规则</strong></td><td>Pod <strong>调度时优先考虑满足条件的节点</strong>，但条件不满足时仍然可以调度到其他节点；调度后同样不会强制迁移</td><td>软性倾向，比如尽量调度到 SSD 节点，但实在没有也可调度</td><td>❌ 非强制</td></tr></tbody></table><h4 id="spec-securityContext-设置安全上下文">spec.securityContext: 设置安全上下文</h4><h5 id="runAsUser-设置运行用户">runAsUser: 设置运行用户</h5><ul class="lvl-0"><li class="lvl-2"><p>默认情况下容器都是以root用户运行的，但是很多应用需要以非root用户运行，比如 Elasticsearch 。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos:v1</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsUser:</span> <span class="number">1000</span>   <span class="comment"># 设置运行用户，这个UID可以不存在</span></span><br></pre></td></tr></table></figure><h5 id="privileged-是否以特权方式运行">privileged: 是否以特权方式运行</h5><ul class="lvl-0"><li class="lvl-2"><p>容器与宿主机是共享内核的，默认情况下，容器用户是不允许修改内核参数的，但是可以通过设置 <code>privileged: true</code> 来允许容器以特权方式运行。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos:v1</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span>   <span class="comment"># 特权方式运行，默认为 false</span></span><br></pre></td></tr></table></figure><h5 id="allowPrivilegeEscalation-是否可以提权（SUID）">allowPrivilegeEscalation: 是否可以提权（SUID）</h5><ul class="lvl-0"><li class="lvl-2"><p>s位：当某可执行命令的所有者的位置上有s位时，那么当普通用户执行这个命令时将具有所有者的权限。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos:v1</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">true</span>   <span class="comment"># 提权运行，可以使用suid，默认为 false</span></span><br></pre></td></tr></table></figure><h3 id="查看-Pod">查看 Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Pod，默认显示 default 命名空间下的 Pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment"># 查看 kube-system 命名空间下的 Pod</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"><span class="comment"># 查看所有命名空间下的 Pod</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line"><span class="comment"># -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 显示 Pod 的详细信息，输出为 json/yaml 格式</span></span><br><span class="line">kubectl get pods -o json/yaml</span><br><span class="line"><span class="comment"># 显示 Pod 的标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="comment"># 按 Pod 的标签进程查询</span></span><br><span class="line">kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class="line"><span class="comment"># 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示</span></span><br><span class="line">kubectl get pods -w</span><br><span class="line"><span class="comment">## 状态类型</span></span><br><span class="line">- Pending: Pod 尚未就绪</span><br><span class="line">- ContainerCreating: Pod 正在创建容器</span><br><span class="line">- Running: Pod 正在运行</span><br><span class="line">- Error: Pod 运行错误</span><br><span class="line">- Terminating: Pod 正在删除</span><br><span class="line">- Completed: Pod 执行完成</span><br><span class="line">- Failed: Pod中的所有容器至少有一个容器退出是非0状态</span><br><span class="line">- Unkown: 无法正常获取Pod对象的状态信息</span><br></pre></td></tr></table></figure><h3 id="查看-Pod-详情">查看 Pod 详情</h3><ul class="lvl-0"><li class="lvl-2"><p>当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br><span class="line">kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程</span></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From               Message</span><br><span class="line">  ----    ------     ----       ----               -------</span><br><span class="line">  <span class="comment"># 被调度器分配到 k8s-worker2 节点</span></span><br><span class="line">  Normal  Scheduled  4s         default-scheduler  Successfully assigned default/nginx to k8s-worker2</span><br><span class="line">  <span class="comment"># 开始拉取镜像</span></span><br><span class="line">  Normal  Pulling    &lt;invalid&gt;  kubelet            Pulling image <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="comment"># 镜像拉取成功</span></span><br><span class="line">  Normal  Pulled     &lt;invalid&gt;  kubelet            Successfully pulled image <span class="string">&quot;nginx&quot;</span> <span class="keyword">in</span> 2.067s (2.067s including waiting). Image size: 72225394 bytes.</span><br><span class="line">  <span class="comment"># 开始创建容器</span></span><br><span class="line">  Normal  Created    &lt;invalid&gt;  kubelet            Created container: nginx</span><br><span class="line">  <span class="comment"># 容器启动成功</span></span><br><span class="line">  Normal  Started    &lt;invalid&gt;  kubelet            Started container nginx</span><br></pre></td></tr></table></figure><h3 id="进入容器">进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx  -- /bin/bash</span><br></pre></td></tr></table></figure><h3 id="删除-Pod">删除 Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt;</span><br><span class="line">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="查看-Pod-日志">查看 Pod 日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br><span class="line">kubectl logs pod/&lt;pod-name&gt;</span><br><span class="line">kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h3 id="访问-Pod">访问 Pod</h3><ul class="lvl-0"><li class="lvl-2"><p>我们刚刚创建了一个nginx的pod，该如何访问呢？</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取pod的ip</span></span><br><span class="line">$ k get pod -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   IP             NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx   1/1     Running   0          12m   10.244.126.8   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在任意节点上访问，nginx 默认端口是80</span></span><br><span class="line">$ curl 10.244.126.8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问</p></li></ul><h3 id="一个-Pod-运行多个容器">一个 Pod 运行多个容器</h3><ul class="lvl-0"><li class="lvl-2"><p>yaml 文件</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">multi-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span> <span class="comment"># 允许相同pod中多个容器共享进程空间，即在一个容器里可以看到另一个容器中的进程，默认值为 false</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行 pod</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f multi_pod.yaml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看运行结果</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里看到，READY 里有两个，表示两个容器都运行成功</span></span><br><span class="line">$ kubectl get pods -owide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">multi-pod   2/2     Running   0          118s   10.244.194.81   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>访问nginx和tomcat</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问nginx，ngxin默认端口是80</span></span><br><span class="line">curl http://10.244.194.81</span><br><span class="line"><span class="comment"># 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常</span></span><br><span class="line">curl http://10.244.194.81:8080</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进入容器执行命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入nginx容器，-c 指定容器名称</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it multi-pod -c nginx -- /bin/bash</span><br><span class="line"><span class="comment">## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享网络和存储</span></span><br><span class="line">curl http://localhost:8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入tomcat容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it multi-pod -c tomcat -- /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/&quot;&gt;k8s Pod 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>K8S 之 Namespace</title>
    <link href="https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/"/>
    <id>https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/</id>
    <published>2025-07-02T13:30:05.000Z</published>
    <updated>2025-07-19T13:52:45.748Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/">k8s Namespace 介绍</a></p></li></ul><span id="more"></span><h2 id="命名空间-Namespace-介绍">命名空间(Namespace) 介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。</p></li><li class="lvl-2"><p>基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。</p></li><li class="lvl-2"><p>Namespace 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。</p></li><li class="lvl-2"><p>避免使用前缀 <code>kube-</code> 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。</p></li><li class="lvl-2"><p>Kubernetes 启动时会创建四个初始 Namespace：</p></li></ul><table><thead><tr><th>名称空间名称</th><th>说明</th></tr></thead><tbody><tr><td><code>default</code></td><td>默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。</td></tr><tr><td><code>kube-node-lease</code></td><td>存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。</td></tr><tr><td><code>kube-public</code></td><td>所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。</td></tr><tr><td><code>kube-system</code></td><td>Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。</td></tr></tbody></table><h2 id="查看集群中的命名空间">查看集群中的命名空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namespace 可以简写为 ns</span></span><br><span class="line">kubectl get namespace</span><br><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure><h2 id="创建命名空间">创建命名空间</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>yaml 方式</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># API 版本，可以通过 kubectl api-resources | grep Namespace 获取</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span> <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>       <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;namespace-name&gt;</span> <span class="comment"># 命名空间名称</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过命令行直接生成yaml文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式</span></span><br><span class="line">kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><h2 id="删除命名空间">删除命名空间</h2><ul class="lvl-0"><li class="lvl-2"><p>命令行方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>yaml 方式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure><h2 id="设置名字空间偏好">设置名字空间偏好</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Pod</span></span><br><span class="line">kubectl config set-context --current --namespace=&lt;namespace-name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看资源时指定命名空间">查看资源时指定命名空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n &lt;namespace-name&gt;</span><br><span class="line">kubectl get service -n &lt;namespace-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间下的资源，-A, --all-namespaces</span></span><br><span class="line">kubectl get pod -A</span><br><span class="line">kubectl get service -A</span><br></pre></td></tr></table></figure><h2 id="并非所有对象都在名字空间中">并非所有对象都在名字空间中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位于名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>kubectl api-resources</code> 这个命令很有用，我们可以通过该命令获取所有资源的 <code>简写</code>，也可以获取资源的 <code>apiVersion</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources</span><br><span class="line">NAME: 资源名称</span><br><span class="line">SHORTNAMES: 简写</span><br><span class="line">APIVERSION: apiVersion</span><br><span class="line">NAMESPACED: 是否在名字空间中</span><br><span class="line">KIND: 资源类型</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-中关于-命名空间（namespace）与-DNS-的机制">Kubernetes 中关于 命名空间（namespace）与 DNS 的机制</h2><ul class="lvl-0"><li class="lvl-2"><p>Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。</p></li><li class="lvl-2"><p>命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。</p></li></ul><h3 id="举个例子说明服务-DNS-是怎么工作的">举个例子说明服务 DNS 是怎么工作的</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：你在两个命名空间中部署了两个 nginx 服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名空间 dev 中创建服务 nginx</span></span><br><span class="line">kubectl create ns dev</span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=2 -n dev</span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort -n dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名空间 prod 中也创建服务 nginx</span></span><br><span class="line">kubectl create ns prod</span><br><span class="line">kubectl create deployment nginx --image=nginx --replicas=2 -n prod</span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort -n prod</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 <code>nginx.dev.svc.cluster.local</code>，也就是 <code>&lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://nginx.prod.svc.cluster.local</span><br></pre></td></tr></table></figure><h2 id="快速生成-k8s-资源的yaml模板">快速生成 k8s 资源的yaml模板</h2><ul class="lvl-0"><li class="lvl-2"><p>安装 vscode 插件：YAML(Red Hat)，Kubernetes Templates(lunuan)</p></li><li class="lvl-2"><p>使用时打开一个yaml文件，或者将文件格式切换为yaml，然后输入关键字 pod、deploy、service 等等 k8s 资源名称，就会弹出模板选择，选择后回车就会生成模板</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/&quot;&gt;k8s Namespace 介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 sealos</title>
    <link href="https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/"/>
    <id>https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/</id>
    <published>2025-07-01T13:30:05.000Z</published>
    <updated>2025-07-02T03:14:34.095Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://sealos.run/docs/k8s/quick-start/deploy-kubernetes">sealos官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/labring/sealos">sealos Github</a></p></li></ul><span id="more"></span><h2 id="安装前设置-所有节点">安装前设置(所有节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>准备三台可以连接外网的主机，不要安装docker,k8s等，如已安装需先卸载</p></li><li class="lvl-2"><p>(推荐)升级系统内核，本文中非必须，升级内核方法参看 <a href="/2025/06/29/k8s-install-kubeadm/" title="Linux 安装 K8S 之 kubeadm">Linux 安装 K8S 之 kubeadm</a></p></li></ul><h3 id="每个集群节点应该有不同的主机名，主机名不要带下划线">每个集群节点应该有不同的主机名，主机名不要带下划线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加主机名映射: vi /etc/hosts</span></span><br><span class="line">10.211.55.12 k8s-m1</span><br><span class="line">10.211.55.13 k8s-w1</span><br><span class="line">10.211.55.14 k8s-w2</span><br></pre></td></tr></table></figure><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-sealos">安装 sealos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/labring/sealos/releases/download/v5.0.1/sealos_5.0.1_linux_amd64.rpm</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y sealos_5.0.1_linux_amd64.rpm</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 sealos 的自动补全</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(sealos completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="创建k8s集群-master">创建k8s集群(master)</h2><ul class="lvl-0"><li class="lvl-2"><p>创建集群: 使用sealos创建集群只需要一行命令，目前官网示例中的k8s版本为v1.29.9(小版本号越高越稳定)</p></li><li class="lvl-2"><p>可以在<a href="https://hub.docker.com">docker hub</a>上查询，或者使用 <a href="https://explore.ggcr.dev/">Registry Explorer</a> 查看如下镜像的所有版本，不建议使用太高的版本，有可能安装失败。</p></li><li class="lvl-2"><p>注意 sealos 与 kubernetes 的版本有对应关系，目前 <code>Sealos &gt;=v5.0.0</code> 对应的 <code>K8s &gt;=1.28</code>，具体可以从<a href="https://sealos.run/docs/k8s/quick-start/deploy-kubernetes">sealos官网</a>查询</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内可以在镜像前面加上 registry.cn-shanghai.aliyuncs.com/</span></span><br><span class="line"><span class="comment"># sealos 推荐的网络接口是 cilium</span></span><br><span class="line">$ sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="comment"># -masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span></span><br><span class="line"><span class="comment"># -nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span></span><br><span class="line"><span class="comment"># -p, --passwd: 指定 SSH 登录密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装成功会显示如下内容</span></span><br><span class="line">ℹ️  Using Cilium version 1.13.4</span><br><span class="line">🔮 Auto-detected cluster name: kubernetes</span><br><span class="line">🔮 Auto-detected datapath mode: tunnel</span><br><span class="line">🔮 Auto-detected kube-proxy has been installed</span><br><span class="line">2025-07-01T16:59:27 info succeeded <span class="keyword">in</span> creating a new cluster, enjoy it!</span><br><span class="line">2025-07-01T16:59:27 info</span><br><span class="line">      ___           ___           ___           ___       ___           ___</span><br><span class="line">     /\  \         /\  \         /\  \         /\__\     /\  \         /\  \</span><br><span class="line">    /::\  \       /::\  \       /::\  \       /:/  /    /::\  \       /::\  \</span><br><span class="line">   /:/\ \  \     /:/\:\  \     /:/\:\  \     /:/  /    /:/\:\  \     /:/\ \  \</span><br><span class="line">  _\:\~\ \  \   /::\~\:\  \   /::\~\:\  \   /:/  /    /:/  \:\  \   _\:\~\ \  \</span><br><span class="line"> /\ \:\ \ \__\ /:/\:\ \:\__\ /:/\:\ \:\__\ /:/__/    /:/__/ \:\__\ /\ \:\ \ \__\</span><br><span class="line"> \:\ \:\ \/__/ \:\~\:\ \/__/ \/__\:\/:/  / \:\  \    \:\  \ /:/  / \:\ \:\ \/__/</span><br><span class="line">  \:\ \:\__\    \:\ \:\__\        \::/  /   \:\  \    \:\  /:/  /   \:\ \:\__\</span><br><span class="line">   \:\/:/  /     \:\ \/__/        /:/  /     \:\  \    \:\/:/  /     \:\/:/  /</span><br><span class="line">    \::/  /       \:\__\         /:/  /       \:\__\    \::/  /       \::/  /</span><br><span class="line">     \/__/         \/__/         \/__/         \/__/     \/__/         \/__/</span><br><span class="line"></span><br><span class="line">                  Website: https://www.sealos.io/</span><br><span class="line">                  Address: github.com/labring/sealos</span><br><span class="line">                  Version: 5.0.1-2b74a1281</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建集群成功后，查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">$ kubectl version</span><br><span class="line">Client Version: v1.29.9</span><br><span class="line">Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3</span><br><span class="line">Server Version: v1.29.9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes -owide</span><br><span class="line">NAME     STATUS   ROLES           AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                            KERNEL-VERSION             CONTAINER-RUNTIME</span><br><span class="line">k8s-m1   Ready    control-plane   3m11s   v1.29.9   10.211.55.12   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line">k8s-w1   Ready    &lt;none&gt;          2m52s   v1.29.9   10.211.55.13   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line">k8s-w2   Ready    &lt;none&gt;          2m55s   v1.29.9   10.211.55.14   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看资源</span></span><br><span class="line">$ kubectl get all -A -owide</span><br><span class="line">NAMESPACE     NAME                                   READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   pod/cilium-bbbdl                       1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-cz47k                       1/1     Running   0          3m47s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-operator-6946ccbcc5-cxnn4   1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/cilium-vfc22                       1/1     Running   0          3m47s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/coredns-76f75df574-2ln5x           1/1     Running   0          3m54s   10.0.0.74      k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/coredns-76f75df574-plsds           1/1     Running   0          3m54s   10.0.0.146     k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/etcd-k8s-m1                        1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-apiserver-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-controller-manager-k8s-m1     1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-4xbzt                   1/1     Running   0          3m51s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-rjs8h                   1/1     Running   0          3m54s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-proxy-xv4fg                   1/1     Running   0          3m55s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-scheduler-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-sealos-lvscare-k8s-w1         1/1     Running   0          3m31s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   pod/kube-sealos-lvscare-k8s-w2         1/1     Running   0          3m34s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE     SELECTOR</span><br><span class="line">default       service/kubernetes    ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP                  4m8s    &lt;none&gt;</span><br><span class="line">kube-system   service/hubble-peer   ClusterIP   10.96.1.9    &lt;none&gt;        443/TCP                  3m47s   k8s-app=cilium</span><br><span class="line">kube-system   service/kube-dns      ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   4m7s    k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS     IMAGES                               SELECTOR</span><br><span class="line">kube-system   daemonset.apps/cilium       3         3         3       3            3           kubernetes.io/os=linux   3m47s   cilium-agent   quay.io/cilium/cilium:v1.13.4        k8s-app=cilium</span><br><span class="line">kube-system   daemonset.apps/kube-proxy   3         3         3       3            3           kubernetes.io/os=linux   4m7s    kube-proxy     registry.k8s.io/kube-proxy:v1.29.9   k8s-app=kube-proxy</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                              READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class="line">kube-system   deployment.apps/cilium-operator   1/1     1            1           3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator</span><br><span class="line">kube-system   deployment.apps/coredns           2/2     2            2           4m7s    coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                                         DESIRED   CURRENT   READY   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class="line">kube-system   replicaset.apps/cilium-operator-6946ccbcc5   1         1         1       3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator,pod-template-hash=6946ccbcc5</span><br><span class="line">kube-system   replicaset.apps/coredns-76f75df574           2         2         2       3m54s   coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns,pod-template-hash=76f75df574</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试：用K8S部署Nginx">测试：用K8S部署Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class="line">$ k get pods,svc -owide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-7854ff8877-wgfxc   1/1     Running   0          19s   10.0.1.204   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        44m   &lt;none&gt;</span><br><span class="line">service/nginx        NodePort    10.96.2.54   &lt;none&gt;        80:31044/TCP   5s    app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问任意nodeIP:31044</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除测试资源</span></span><br><span class="line"><span class="comment">## 删除deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="comment">## 删除service</span></span><br><span class="line">kubectl delete service nginx</span><br></pre></td></tr></table></figure><h2 id="sealos-命令">sealos 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>sealos 命令概览</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Cluster Management Commands:</span><br><span class="line">  apply         使用 Clusterfile 在 Kubernetes 集群中运行云镜像</span><br><span class="line">  cert          更新 Kubernetes API Server 的证书</span><br><span class="line">  run           轻松运行云原生应用，可用于已有或新建集群</span><br><span class="line">  reset         重置集群中的所有内容</span><br><span class="line">  status        查看 sealos 的状态</span><br><span class="line"></span><br><span class="line">Node Management Commands:</span><br><span class="line">  add           向集群中添加节点</span><br><span class="line">  delete        从集群中移除节点</span><br><span class="line"></span><br><span class="line">Remote Operation Commands:</span><br><span class="line">  <span class="built_in">exec</span>          在指定节点上执行 shell 命令或脚本</span><br><span class="line">  scp           将文件复制到指定节点的远程主机上</span><br><span class="line"></span><br><span class="line">Experimental Commands:</span><br><span class="line">  registry      与镜像仓库相关的实验性功能</span><br><span class="line"></span><br><span class="line">Container and Image Commands:</span><br><span class="line">  build         根据 Containerfile 或 Kubefile 构建镜像</span><br><span class="line">  create        创建集群但不执行命令，用于检查镜像</span><br><span class="line">  diff          查看对象文件系统的更改</span><br><span class="line">  inspect       检查容器或镜像的配置信息</span><br><span class="line">  images        列出本地存储中的镜像</span><br><span class="line">  load          从归档文件加载镜像</span><br><span class="line">  login         登录到容器镜像仓库</span><br><span class="line">  <span class="built_in">logout</span>        登出容器镜像仓库</span><br><span class="line">  manifest      操作 manifest 列表和镜像索引</span><br><span class="line">  merge         合并多个镜像为一个</span><br><span class="line">  pull          从指定位置拉取镜像</span><br><span class="line">  push          将镜像推送到指定目标</span><br><span class="line">  rmi           从本地删除一个或多个镜像</span><br><span class="line">  save          将镜像保存为归档文件</span><br><span class="line">  tag           为本地镜像添加额外的名称标签</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  completion    生成指定 shell 的自动补全脚本</span><br><span class="line">  docs          生成 API 参考文档</span><br><span class="line">  <span class="built_in">env</span>           输出 sealos 使用的所有环境变量信息</span><br><span class="line">  gen           生成包含默认设置的 Clusterfile</span><br><span class="line">  version       打印版本信息</span><br></pre></td></tr></table></figure><h3 id="集群管理-master节点执行命令">集群管理(master节点执行命令)</h3><ul class="lvl-0"><li class="lvl-2"><p>创建集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line">-masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span><br><span class="line">-nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span><br><span class="line">-p, --passwd: 指定 SSH 登录密码</span><br><span class="line">-u, --user: 登录用户名，默认为 root</span><br><span class="line">-i, --pk=<span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: 指定 SSH 密钥文件路径</span><br><span class="line">--port: 指定 SSH 端口，默认为 22</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Clusterfile 方式创建集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成集群配置文件，Clusterfile就是一个yaml文件，里面包含集群的配置信息</span></span><br><span class="line">sealos gen labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \</span><br><span class="line">     --masters 10.211.55.12 \</span><br><span class="line">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd] &gt; Clusterfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行配置文件</span></span><br><span class="line">sealos apply -f Clusterfile</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos status</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>清除K8s集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos reset</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>更新 Kubernetes API 服务器的证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos 创建的证书存放在 /etc/kubernetes/pki/ 下，默认证书有效期为 100 年</span></span><br><span class="line"><span class="comment"># 更新证书一般只会在添加新的访问ip或域名时才需要</span></span><br><span class="line">sealos cert --alt-names apiserver.cluster.local,10.211.55.12,127.0.0.1,localhost</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># --alt-names: 添加新的访问ip或域名，多个逗号分隔</span></span><br><span class="line"><span class="comment"># -c, --cluster=&#x27;default&#x27;: 要执行 exec 操作的集群的名称。默认为 default。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新证书后，你可以使用以下命令进行校验：</span></span><br><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure><blockquote><p>在执行此操作之前，你最好先备份旧的证书。<br>执行 sealos cert 命令后，会更新集群 API 服务器的证书，你无需手动重启 API 服务器，sealos会自动帮你重启服务。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>查看环境变量</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v 显示变量的说明</span></span><br><span class="line">sealos <span class="built_in">env</span> -v</span><br><span class="line"><span class="comment">## 说明</span></span><br><span class="line">SEALOS_PROMPT=enabled <span class="comment"># 是否启用终端中的交互提示功能。</span></span><br><span class="line">SEALOS_RUNTIME_ROOT=/root/.sealos <span class="comment"># Sealos 的运行时根目录，用于持久化运行相关的操作或配置。</span></span><br><span class="line">SEALOS_DATA_ROOT=/var/lib/sealos  <span class="comment"># 集群在远程节点上的根目录路径，用于存储集群相关的数据。</span></span><br><span class="line">BUILDAH_FORMAT=oci <span class="comment"># 镜像构建时使用的格式，`oci` 表示符合 OCI 镜像规范。</span></span><br><span class="line">BUILDAH_LOG_LEVEL= <span class="comment"># buildah 模块中使用的日志级别，可以是 &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;, 或 &quot;panic&quot;。</span></span><br><span class="line">CONTAINERS_STORAGE_CONF= <span class="comment"># 容器存储配置文件的路径，设置这个变量可以覆盖默认的配置位置。</span></span><br><span class="line">SEALOS_SYNC_WORKDIR=<span class="literal">true</span> <span class="comment"># 是否将运行时根目录（SEALOS_RUNTIME_ROOT）同步到所有 master 节点，作为备份用途。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群中执行命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos exec &quot;shell command or script&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在所有节点上执行命令</span></span><br><span class="line">sealos <span class="built_in">exec</span> <span class="string">&quot;cat /etc/hosts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class="line">sealos <span class="built_in">exec</span> <span class="string">&quot;cat /etc/hosts&quot;</span> --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群间拷贝文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos scp &quot;source file path&quot; &quot;destination file path&quot;</span></span><br><span class="line"><span class="comment"># 在所有节点上执行命令</span></span><br><span class="line">sealos scp ~/Clusterfile /tmp/Clusterfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class="line">sealos scp ~/Clusterfile /tmp/Clusterfile --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure><h3 id="节点管理-master节点执行命令">节点管理(master节点执行命令)</h3><ul class="lvl-0"><li class="lvl-2"><p>添加 master 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 master 节点后，总的 master 节点个数必须为奇数，否则会报错</span></span><br><span class="line">sealos add --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 worker 节点，多个都会分隔</span></span><br><span class="line">sealos add --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除 master 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 master 节点后，剩余的 master 节点个数必须为奇数，否则会报错</span></span><br><span class="line">sealos delete --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos delete --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure><h3 id="镜像管理">镜像管理</h3><ul class="lvl-0"><li class="lvl-2"><p>查看所有镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sealos images</span><br><span class="line">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">docker.io/labring/kubernetes                               v1.29.9    bca192f35556   2 months ago    669 MB</span><br><span class="line">docker.io/labring/cilium                                   v1.13.4    71aa52ad0a11   23 months ago   483 MB</span><br><span class="line">docker.io/labring/helm                                     v3.9.4     3376f6822067   2 years ago     46.4 MB</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos rmi [image_id] | [image_name]</span></span><br><span class="line">sealos rmi docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>拉取镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos pull docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登录镜像仓库，建议登录仓库，这样可以提高拉取镜像的次数，避免拉取镜像失败</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker.io 官方dockerhub镜像仓库</span></span><br><span class="line">sealos login docker.io -u [username] -p [password]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为镜像打tag</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos tag docker.io/labring/kubernetes:v1.29.9 docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>推送镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos push docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看镜像详情</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos inspect [image_id] | [image_name]</span></span><br><span class="line">sealos inspect docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>登出镜像仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登出指定的仓库</span></span><br><span class="line">sealos <span class="built_in">logout</span> docker.io</span><br><span class="line"><span class="comment"># 登出所有仓库</span></span><br><span class="line">sealos <span class="built_in">logout</span> --all</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过 Dockerfile 构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与 docker build 类似，构建好的镜像会增加前缀 localhost/</span></span><br><span class="line">sealos build -t myapp:v1.0.0 -f Dockerfile .</span><br></pre></td></tr></table></figure><h3 id="容器管理">容器管理</h3><ul class="lvl-0"><li class="lvl-2"><p>查看所有容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealos ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看容器详情</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sealos inspect [container_id] | [container_name]</span></span><br><span class="line">sealos inspect bca192f35556</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://sealos.run/docs/k8s/quick-start/deploy-kubernetes&quot;&gt;sealos官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/labring/sealos&quot;&gt;sealos Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 kubeadm</title>
    <link href="https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/"/>
    <id>https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/</id>
    <published>2025-06-29T14:30:05.000Z</published>
    <updated>2025-07-20T03:10:41.428Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/">使用 kubeadm 引导集群</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/">kubeadm 命令指南</a></p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/">用 kubeadm 进行管理</a></p></li></ul><span id="more"></span><h2 id="安装前设置-所有节点">安装前设置(所有节点)</h2><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-docker-可选">安装 <code>docker</code>(可选)</h3><ul class="lvl-0"><li class="lvl-2"><p>k8s 使用<code>docker</code>作为容器运行时才需要安装，安装方法参见 <a href="/2025/05/20/docker-install/" title="Linux 安装 Docker">Linux 安装 Docker</a></p></li></ul><h3 id="创建用户">创建用户</h3><ul class="lvl-0"><li class="lvl-2"><p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建用户</span></span><br><span class="line">$ <span class="built_in">sudo</span> useradd -m -s /bin/bash centos</span><br><span class="line"><span class="comment"># 2.添加到docker用户组</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker centos</span><br><span class="line"><span class="comment"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG wheel centos</span><br><span class="line"><span class="comment">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class="line"><span class="comment"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class="line">$ su - centos</span><br></pre></td></tr></table></figure><h3 id="升级内核">升级内核</h3><ul class="lvl-0"><li class="lvl-2"><p>由 kubeadm 创建的 Kubernetes 集群依赖于使用内核特性的相关软件。</p></li><li class="lvl-3"><p>Kubernetes 集群的节点对于使用 Linux 内核版本要求参加<a href="https://kubernetes.io/zh-cn/docs/reference/node/kernel-version-requirements/">Linux 内核版本要求</a></p></li><li class="lvl-3"><p>kubeadm 项目支持 LTS 内核。参阅 <a href="https://www.kernel.org/category/releases.html">LTS 内核列表</a>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前内核版本，可以看到当前内核版本为 4.18.0</span></span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">4.18.0-553.el8_10.x86_64</span><br><span class="line"><span class="comment">#查看 yum 中可升级的内核版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list kernel --showduplicates</span><br><span class="line"><span class="comment">#如果list中有需要的版本可以直接执行 update 升级，多数是没有的，所以要按以下步骤操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入ELRepo软件仓库的公共秘钥</span></span><br><span class="line">$ <span class="built_in">sudo</span> rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#Centos7系统安装ELRepo</span></span><br><span class="line"><span class="comment"># $sudo yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span></span><br><span class="line"><span class="comment">#Centos8系统安装ELRepo</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ELRepo提供的内核版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#kernel-lt：表示longterm，即长期支持的内核，当前lt内核版本为 5.4.295</span></span><br><span class="line"><span class="comment">#kernel-ml：表示mainline，即当前主线的内核，当前ml内核版本为 6.15.4，笔者测试安装该版本内核最后创建集群时会失败</span></span><br><span class="line"><span class="comment">#安装lt内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum --enablerepo=elrepo-kernel install kernel-lt.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已安装的内核版本，可以看到 刚刚安装的 5.4.295 内核版本的两个文件</span></span><br><span class="line">$ <span class="built_in">ls</span> -lh /boot/vmlinuz-* /boot/initramfs-* | grep <span class="string">&quot;5.4&quot;</span></span><br><span class="line">-rw-------  1 root root  29M 6月  29 17:15 /boot/initramfs-5.4.295-1.el8.elrepo.x86_64.img</span><br><span class="line">-rwxr-xr-x  1 root root 9.5M 6月  28 01:21 /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可以使用的内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --info=ALL | grep ^kernel</span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64&quot;</span></span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-4.18.0-553.el8_10.x86_64&quot;</span></span><br><span class="line">kernel=<span class="string">&quot;/boot/vmlinuz-0-rescue-88f75739047993488aacc30b9cd25ca0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认内核，默认情况下，系统会自动将新安装的内核设置为默认启动内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --default-kernel</span><br><span class="line">/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有自动启用，则通过该命令设置默认内核</span></span><br><span class="line">$ <span class="built_in">sudo</span> grubby --set-default /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ <span class="built_in">sudo</span> reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启登录后验证内核版本</span></span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">5.4.295-1.el8.elrepo.x86_64</span><br></pre></td></tr></table></figure><h3 id="将-SELinux-设置为-permissive-模式（相当于将其禁用）">将 SELinux 设置为 permissive 模式（相当于将其禁用）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> setenforce 0</span><br><span class="line">$ <span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><h3 id="禁用Firewalld">禁用Firewalld</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了方便，这里可以禁用 firewalld</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop firewalld</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h4 id="不关-Firewalld-应该开放哪些端口？-实测还是会遇到各种各样的问题">不关 Firewalld 应该开放哪些端口？(实测还是会遇到各种各样的问题)</h4><ul class="lvl-0"><li class="lvl-2"><p>Master 节点需要开放的端口</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>6443</strong></td><td>TCP</td><td>kube-apiserver，用于 kubectl 与集群通信</td></tr><tr><td><strong>2379-2380</strong></td><td>TCP</td><td>etcd 集群通信（仅在你自己部署 etcd 时）</td></tr><tr><td><strong>10250</strong></td><td>TCP</td><td>kubelet 监听端口，供 apiserver 与节点通信</td></tr><tr><td><strong>10259</strong></td><td>TCP</td><td>kube-scheduler</td></tr><tr><td><strong>10257</strong></td><td>TCP</td><td>kube-controller-manager</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Worker 节点需要开放的端口</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>10250</strong></td><td>TCP</td><td>kubelet 与 apiserver 通信</td></tr><tr><td><strong>30000-32767</strong></td><td>TCP</td><td>NodePort 服务默认端口范围</td></tr><tr><td><strong>10255</strong></td><td>TCP</td><td>kubelet 只读端口（默认关闭，可不开放）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你使用的是 Calico 网络插件</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>179</strong></td><td>TCP</td><td>BGP 通信端口，用于 Calico 节点间路由（若使用 BGP 模式）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你使用的是 Flannel（VXLAN 模式）</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>8472</strong></td><td>UDP</td><td>VXLAN 数据通信</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Ingress 控制器（比如 NGINX Ingress）</p></li></ul><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td><strong>80</strong> / <strong>443</strong></td><td>TCP</td><td>提供 HTTP/HTTPS 服务访问（Ingress 服务）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例命令：使用 firewall-cmd 开放端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 firewalld</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start firewalld</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：开放常用端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=6443/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=2379-2380/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10250/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10259/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=10257/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=30000-32767/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=179/tcp       <span class="comment"># 如果用 Calico</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=8472/udp      <span class="comment"># 如果用 Flannel</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=80/tcp        <span class="comment"># Ingress</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=443/tcp       <span class="comment"># Ingress</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 Calico 的封装协议 IPIP ,允许 IPIP 协议（协议号 4）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p 4 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 Calico 使用 VXLAN 模式，则需要开放 4789 端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class="line"><span class="comment"># Calico Typha 网络</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=5473/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calico WireGuard（IPv4 和 IPv6）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=51820/udp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=51821/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开放的端口</span></span><br><span class="line">$ <span class="built_in">sudo</span> firewall-cmd --list-ports</span><br><span class="line">80/tcp 179/tcp 443/tcp 2377/tcp 2379-2380/tcp 6443/tcp 7946/tcp 10250/tcp 10257/tcp 10259/tcp 30000-32767/tcp 4789/udp 7946/udp 8472/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开放的直接规则</span></span><br><span class="line">$ <span class="built_in">sudo</span> firewall-cmd --direct --get-all-rules</span><br><span class="line">ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="关闭swap">关闭swap</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapoff -a</span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="加载内核模块">加载内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br></pre></td></tr></table></figure><h3 id="设置内核参数">设置内核参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/kubernetes.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br></pre></td></tr></table></figure><h3 id="安装containerd">安装containerd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="built_in">sudo</span> yum config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="built_in">sudo</span> yum install -y containerd.io</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/containerd</span><br><span class="line"><span class="built_in">sudo</span> containerd config default | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Systemd为cgroup driver</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now containerd</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果是国内环境，可以在<code>/etc/containerd/config.toml</code>添加镜像加速器配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 registry.mirrors 字段，添加加速器，比如：</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class="line">  [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">    endpoint = [<span class="string">&quot;https://docker.1ms.run&quot;</span>, <span class="string">&quot;https://docker.xuanyuan.me&quot;</span>, <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后重启 containerd</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure><h3 id="安装cri-dockerd-可选">安装cri-dockerd(可选)</h3><ul class="lvl-0"><li class="lvl-2"><p>如果使用 containerd，则不需要安装 cri-dockerd</p></li><li class="lvl-2"><p>Kubernetes 1.24+ 默认移除了 dockershim，所以你必须安装 cri-dockerd 才能继续使用 Docker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并安装 cri-dockerd RPM，目前最新版是 0.3.19，fc35: Fedora 35 构建，适配 RHEL/CentOS 8 系统的 glibc 和 libstdc++</span></span><br><span class="line">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.19/cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class="line"><span class="comment"># 安装时报错：cri-dockerd-0.3.19-3.fc35.x86_64.rpm 依赖 GLIBC ≥ 2.32 和 2.34，但 CentOS 8 系统只提供 GLIBC 2.28。</span></span><br><span class="line">$ <span class="built_in">sudo</span> dnf install -y ./cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新下载一个兼容的版本即可，这里选择：cri-dockerd-0.3.14-3.el8.x86_64.rpm</span></span><br><span class="line">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.14/cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class="line">$ <span class="built_in">sudo</span> dnf install -y ./cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载服务</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="comment"># 加入开机启动并立刻启动</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now cri-docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的 kubeadm 命令 都要加上 --cri-socket unix:///var/run/cri-dockerd.sock</span></span><br></pre></td></tr></table></figure><h3 id="安装-kubelet-kubeadm-kubectl">安装 kubelet, kubeadm, kubectl</h3><ul class="lvl-0"><li class="lvl-2"><p>添加 Kubernetes YUM 源，k8s 的版本从<a href="https://kubernetes.io/zh-cn/docs/home/supported-doc-versions/">官网</a>获取</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理yum缓存并重新建立缓存</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum clean all &amp;&amp; <span class="built_in">sudo</span> yum makecache</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装 kubelet, kubeadm, kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm有什么版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates  kubeadm</span><br><span class="line"><span class="comment"># 不指定版本默认那种最新版</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用kubelet</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器运行时为containerd，这里通过 crictl 指定容器运行时为 containerd</span></span><br><span class="line"><span class="comment"># 配置文件：/etc/crictl.yaml</span></span><br><span class="line">$ <span class="built_in">sudo</span> crictl config runtime-endpoint /run/containerd/containerd.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">$ kubeadm version</span><br><span class="line">$ kubelet --version</span><br><span class="line">$ kubectl version --client</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">$ kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="创建集群-master节点">创建集群(master节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>master节点: [hostname: k8s-master, IP: 10.211.55.11]</p></li><li class="lvl-2"><p>初始化master节点的控制面板，容器运行时基于 <code>containerd</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubeadm init --help可以查看命令的具体参数用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在master节点执行初始化（node节点不用执行）</span></span><br><span class="line"><span class="comment"># --apiserver-advertise-address  指定apiserver的IP，即master节点的IP</span></span><br><span class="line"><span class="comment"># --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers 设置镜像仓库为国内镜像仓库</span></span><br><span class="line"><span class="comment"># --kubernetes-version  设置k8s的版本，跟kubeadm版本一致</span></span><br><span class="line"><span class="comment"># --service-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class="line"><span class="comment"># --pod-network-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class="line"><span class="comment"># --cri-socket unix:///var/run/cri-dockerd.sock  设置cri使用cri-dockerd</span></span><br><span class="line"><span class="comment"># --ignore-preflight-errors=all  忽略所有预检错误（Preflight Errors）。这会跳过对系统状态的某些检查，例如是否启用了 swap、CPU 核心数、系统配置等。不推荐用于生产，只用于调试或测试环境。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.211.55.11 \</span><br><span class="line">--kubernetes-version v1.33.2 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"><span class="comment">## 安装成功会打印如下信息</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群信息</span></span><br><span class="line">$ k cluster-info</span><br><span class="line">Kubernetes control plane is running at https://10.211.55.11:6443</span><br><span class="line">CoreDNS is running at https://10.211.55.11:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"><span class="comment"># 查看组件状态</span></span><br><span class="line">$ k get cs</span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE   ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   ok</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为当前用户授予连接集群的权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>安装网络插件：<a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">k8s支持的网络插件</a>，</p></li><li class="lvl-2"><p><a href="https://www.tigera.io/project-calico/">calico官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/projectcalico/calico">calico GitHub</a>]</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装calico前查看pod，-A 查看所有命名空间</span></span><br><span class="line">$ kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                          READY   STATUS    RESTARTS      AGE</span><br><span class="line">kube-system   coredns-674b8bbfcf-8xllc      0/1     Pending   0             116m</span><br><span class="line">kube-system   coredns-674b8bbfcf-w2sxz      0/1     Pending   0             116m</span><br><span class="line">kube-system   etcd-k8s                      1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-apiserver-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-controller-manager-k8s   1/1     Running   2 (74m ago)   116m</span><br><span class="line">kube-system   kube-proxy-94zqw              1/1     Running   1 (74m ago)   116m</span><br><span class="line">kube-system   kube-scheduler-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载yaml文件，目前最新版为 v3.30.2</span></span><br><span class="line">$ curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">$ kubectl apply -f calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装calico后查看pod，在安装 Calico 之前 CoreDNS 是 Pending 状态，现在已经变成 Running</span></span><br><span class="line"><span class="comment"># -o wide: 显示pod的详细信息</span></span><br><span class="line">$ kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS      AGE     IP             NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   calico-kube-controllers-7bfdc5b57c-9qv9m   1/1     Running   0             6m23s   10.244.77.1    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-m7wc5                          1/1     Running   0             6m23s   10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-8xllc                   1/1     Running   0             123m    10.244.77.3    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-w2sxz                   1/1     Running   0             123m    10.244.77.2    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-k8s                                   1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-k8s                1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-94zqw                           1/1     Running   1 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><blockquote><p>calica 安装后可能出现不正常的情况，比如 <code>calico-node-xxx</code> 的pod始终无法正常运行，此时可以尝试重新安装 calica</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 calico</span></span><br><span class="line">$ kubectl delete -f calico.yaml</span><br><span class="line"><span class="comment">#如果是重装calico，需要先清除旧的配置</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/cni/net.d/</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/calico</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新安装 calico</span></span><br><span class="line">$ kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><h2 id="添加节点-worker节点">添加节点(worker节点)</h2><ul class="lvl-0"><li class="lvl-2"><p>worker节点: [hostname: k8s-worker1, IP: 10.211.55.15]</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在待加入的节点上执行如下命令，如果忘记token，则使用下文的命令重新获取</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING SystemVerification]: cgroups v1 support is <span class="keyword">in</span> maintenance mode, please migrate to cgroups v2</span><br><span class="line">[preflight] Reading configuration from the <span class="string">&quot;kubeadm-config&quot;</span> ConfigMap <span class="keyword">in</span> namespace <span class="string">&quot;kube-system&quot;</span>...</span><br><span class="line">[preflight] Use <span class="string">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">&quot;/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span></span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-check] Waiting <span class="keyword">for</span> a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s</span><br><span class="line">[kubelet-check] The kubelet is healthy after 1.004135788s</span><br><span class="line">[kubelet-start] Waiting <span class="keyword">for</span> the kubelet to perform the TLS Bootstrap</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node <span class="built_in">join</span> the cluster.</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果上面的令牌忘记了，或者新的 worker 节点加入，在 master 上执行下面的命令，生成新的令牌</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm token create --print-join-command</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.211.55.11:6443 --token 5o3p2i.gj95aopph0xbrcig --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 master 节点上查看新创建的资源，默认情况下 work 节点不支持管理 k8s</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME          STATUS     ROLES           AGE     VERSION</span><br><span class="line">k8s           Ready      control-plane   3h33m   v1.33.2</span><br><span class="line">k8s-worker1   Ready      &lt;none&gt;          115s    v1.33.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod list</span></span><br><span class="line">$ kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   0          37m     10.244.235.193   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-7pbbq                          1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-w47qq                          1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-2tvld                   1/1     Running   0          37m     10.244.235.195   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-674b8bbfcf-h6kx7                   1/1     Running   0          37m     10.244.235.194   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-k8s-master                            1/1     Running   2          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-k8s-master                  1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-k8s-master         1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-nkbns                           1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-plqw8                           1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-k8s-master                  1/1     Running   4          38m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使 work 节点支持管理 k8s(可选)：远程管理</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 master 节点中的 ~/.kube/config 复制到 work 节点的 ~/.kube/config 即可</span></span><br><span class="line"><span class="comment"># 在 master 节点执行</span></span><br><span class="line">scp ~/.kube/config k8s-work1:/tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 work 节点执行</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.kube</span><br><span class="line"><span class="built_in">mv</span> /tmp/config ~/.kube/config</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除work节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master, 删除节点前先清空节点上的所有 Pod，使其调度到其他节点</span></span><br><span class="line">$ kubectl drain k8s-worker1 --ignore-daemonsets</span><br><span class="line"></span><br><span class="line"><span class="comment"># worker节点上执行如下命令</span></span><br><span class="line"><span class="comment">## 在移除节点之前，请重置 kubeadm 安装的状态</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm reset</span><br><span class="line"><span class="comment">## 重置过程不会重置或清除 iptables 规则或 IPVS 表。如果你希望重置 iptables，则必须手动进行</span></span><br><span class="line">$ iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line"></span><br><span class="line"><span class="comment"># master 节点上删除节点</span></span><br><span class="line">$ kubectl delete node k8s-worker1</span><br></pre></td></tr></table></figure><h2 id="测试：用K8S部署Nginx">测试：用K8S部署Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class="line">$ kubectl get pod,svc -o wide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-5869d7778c-95z74   1/1     Running   0          19m   10.244.194.65   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        61m   &lt;none&gt;</span><br><span class="line">service/nginx        NodePort    10.96.48.156   &lt;none&gt;        80:30291/TCP   14m   app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器访问任意nodeIP:30291</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除测试资源</span></span><br><span class="line"><span class="comment">## 删除deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="comment">## 删除service</span></span><br><span class="line">kubectl delete service nginx</span><br></pre></td></tr></table></figure><h2 id="通过-kubeadm-卸载-Kubernetes">通过 kubeadm 卸载 Kubernetes</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 kubelet 相关组件,删除 /etc/kubernetes 配置,清除证书、状态目录等,取消 iptables 规则,清除容器运行时中的 Pod、镜像信息等</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm reset</span><br><span class="line"><span class="comment"># 虽然 kubeadm reset 已经会清除大部分内容，但以下文件和配置可能依然存在，建议一并手动清理</span></span><br><span class="line"><span class="comment">## 删除 kubeconfig 文件（本地 kubectl 配置）</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="comment">## 清理 etcd 数据（如你启用了本地 etcd）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/etcd</span><br><span class="line"><span class="comment">## 清理 CNI 网络配置和状态</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/cni/net.d</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/cni/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/kubelet/*</span><br><span class="line"><span class="comment"># 清理 Calico</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/calico</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 iptables</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -t mangle -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -t mangle -X</span><br><span class="line"><span class="built_in">sudo</span> iptables -P INPUT ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -P FORWARD ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -P OUTPUT ACCEPT</span><br></pre></td></tr></table></figure><h2 id="停止和禁用-kubelet-服务">停止和禁用 kubelet 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop kubelet</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> kubelet</span><br></pre></td></tr></table></figure><h2 id="升级-kubeadm-集群">升级 kubeadm 集群</h2><ul class="lvl-0"><li class="lvl-2"><p>将 kubeadm 创建的 Kubernetes 集群从 1.32.x 版本 升级到 1.33.x 版本以及从 1.33.x 升级到 1.33.y（其中 y &gt; x），略过次版本号的升级是 不被支持的。</p></li></ul><h3 id="升级步骤">升级步骤</h3><h4 id="升级-master-节点">升级 master 节点</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">升级 master 节点</a></p></li><li class="lvl-2"><p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p></li><li class="lvl-2"><p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubeadm 可以升级的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class="line"><span class="comment"># 查看升级后的版本</span></span><br><span class="line">kubeadm version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证升级计划: 此命令检查你的集群是否可被升级，并取回你要升级的目标版本。 命令也会显示一个包含组件配置版本状态的表格。</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade plan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级 master 节点: 这一步会升级 kube-apiserver、controller-manager、scheduler 等静态 Pod。</span></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade apply v1.33.3</span><br><span class="line"><span class="comment">## 一旦该命令结束，你应该会看到：</span></span><br><span class="line"> [upgrade/successful] SUCCESS! Your cluster was upgraded to <span class="string">&quot;v1.33.3&quot;</span>. Enjoy!</span><br><span class="line"></span><br><span class="line"> [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets <span class="keyword">if</span> you haven<span class="string">&#x27;t already done so.</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>手动升级你的 CNI 驱动插件，比如 Calico</p></li><li class="lvl-2"><p>升级 kubelet 和 kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的版本</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class="line"><span class="comment"># 重启 kubelet</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure><h4 id="升级-worker-节点">升级 worker 节点</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/upgrading-linux-nodes/">升级 worker 节点</a></p></li><li class="lvl-2"><p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p></li><li class="lvl-2"><p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubeadm 可以升级的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum list --showduplicates kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class="line"><span class="comment"># 查看升级后的版本</span></span><br><span class="line">$ kubeadm version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>腾空节点：如果有多个 worker 节点，可以选择先腾空节点。如果只有一个 worker 节点，则不需要。</p></li></ul><blockquote><p>drain 是为了在升级期间 避免该节点上正在运行的业务容器受到影响</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在控制平面节点上执行此命令</span></span><br><span class="line"><span class="comment"># 将 &lt;node-to-drain&gt; 替换为你正腾空的节点的名称</span></span><br><span class="line">$ kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>升级 node 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> kubeadm upgrade node</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>升级 kubelet 和 kubectl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的版本</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class="line"><span class="comment"># 重启 kubelet</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line">$ <span class="built_in">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果前面对节点做了 腾空节点 操作，则需要取消对节点的保护，将节点标记为可调度，让节点重新上线</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在控制平面节点上执行此命令</span></span><br><span class="line"><span class="comment"># 将 &lt;node-to-uncordon&gt; 替换为你的节点名称</span></span><br><span class="line">$ kubectl uncordon &lt;node-to-uncordon&gt;</span><br></pre></td></tr></table></figure><h2 id="更新证书">更新证书</h2><ul class="lvl-0"><li class="lvl-2"><p>kubeadm 创建的证书存放在 <code>/etc/kubernetes/pki/</code> 下，默认客户端证书有效期为 1 年</p></li><li class="lvl-2"><p>可以通过如下命令查看证书信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看证书到期时间</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm certs check-expiration</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line"><span class="comment">## 可以看到 客户端 的证书的过期时间，默认值为 1 年</span></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">apiserver                  Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">apiserver-etcd-client      Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">controller-manager.conf    Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">etcd-healthcheck-client    Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">etcd-server                Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Jun 29, 2026 14:41 UTC   363d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line">super-admin.conf           Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根证书默认有效期为 10 年</span></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Jun 27, 2035 14:41 UTC   9y              no</span><br><span class="line">etcd-ca                 Jun 27, 2035 14:41 UTC   9y              no</span><br><span class="line">front-proxy-ca          Jun 27, 2035 14:41 UTC   9y              no</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>更新客户端证书</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新前备份</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rf /etc/kubernetes/ /etc/kubernetes.bak</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rf /var/lib/etcd/ /var/lib/etcd.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以更新单个客户端证书</span></span><br><span class="line"><span class="comment"># sudo kubeadm certs renew admin.conf</span></span><br><span class="line"><span class="comment"># sudo kubeadm certs renew apiserver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级全部客户端证书，也只能续期1年</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm certs renew all</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[renew] Reading configuration from the <span class="string">&quot;kubeadm-config&quot;</span> ConfigMap <span class="keyword">in</span> namespace <span class="string">&quot;kube-system&quot;</span>...</span><br><span class="line">[renew] Use <span class="string">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class="line"></span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the admin to use and <span class="keyword">for</span> kubeadm itself renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving the Kubernetes API renewed</span><br><span class="line">certificate the apiserver uses to access etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the API server to connect to kubelet renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the controller manager to use renewed</span><br><span class="line">certificate <span class="keyword">for</span> liveness probes to healthcheck etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> etcd nodes to communicate with each other renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the front proxy client renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the scheduler manager to use renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the super-admin renewed</span><br><span class="line"></span><br><span class="line">Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据输出提示重启 kube-apiserver, kube-controller-manager, kube-scheduler 和 etcd</span></span><br><span class="line"><span class="comment"># 这几个组件是通过pod 启动的，可以通过 kubectl get pod -n kube-system 查看</span></span><br><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS        AGE</span><br><span class="line">calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">calico-node-7pbbq                          1/1     Running   3 (5h36m ago)   41h</span><br><span class="line">calico-node-v4hzr                          1/1     Running   2 (5h37m ago)   19h</span><br><span class="line">calico-node-w47qq                          1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">coredns-674b8bbfcf-2tvld                   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">coredns-674b8bbfcf-h6kx7                   1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">etcd-k8s-master                            1/1     Running   5 (5h37m ago)   41h</span><br><span class="line">kube-apiserver-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class="line">kube-controller-manager-k8s-master         1/1     Running   7 (5h37m ago)   41h</span><br><span class="line">kube-proxy-nkbns                           1/1     Running   3 (5h36m ago)   41h</span><br><span class="line">kube-proxy-plqw8                           1/1     Running   3 (5h37m ago)   41h</span><br><span class="line">kube-proxy-sbgh6                           1/1     Running   2 (5h37m ago)   19h</span><br><span class="line">kube-scheduler-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的pod就会自动重启</span></span><br><span class="line">kubectl delete pod -n kube-system kube-apiserver-k8s-master kube-controller-manager-k8s-master  kube-scheduler-k8s-master etcd-k8s-master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启成功后再次查看证书信息，就会看到更新后的到期时间为1年</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm certs check-expiration</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-节点组件">Kubernetes 节点组件</h2><table><thead><tr><th>角色</th><th>组件名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Master Node</strong></td><td><code>kube-apiserver</code></td><td>Kubernetes 的 API 请求入口，处理所有 REST 请求，协调各组件。</td></tr><tr><td></td><td><code>kube-scheduler</code></td><td>调度器，决定将 Pod 调度到哪个合适的 Node。</td></tr><tr><td></td><td><code>kube-controller-manager</code></td><td>包含多个控制器（如 NodeController、ReplicationController、DeploymentController 等），用于控制和调整集群状态。</td></tr><tr><td></td><td><code>etcd</code></td><td>分布式 KV 存储系统，存储 Kubernetes 所有状态数据。只有 API Server 能直接访问。</td></tr><tr><td><strong>Worker Node</strong></td><td><code>kubelet</code></td><td>负责与 Master 通信，执行其下发的 Pod 管理任务，控制容器生命周期。</td></tr><tr><td></td><td><code>kube-proxy</code></td><td>负责维护 Node 上的网络规则，支持服务负载均衡和网络通信。</td></tr><tr><td></td><td><code>container runtime</code></td><td>容器运行时，比如 Docker、containerd、CRI-O，负责实际运行容器。</td></tr></tbody></table><h2 id="crictl-命令">crictl 命令</h2><ul class="lvl-0"><li class="lvl-2"><p><code>crictl</code> 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。</p></li><li class="lvl-2"><p><code>crictl</code> 命令默认需要 sudo 权限，如果不想每次都加 sudo，可以将用户加入 containerd 的 socket 权限组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># containerd 的默认 socket 是 /var/run/containerd/containerd.sock</span></span><br><span class="line">$ <span class="built_in">ls</span> -l /var/run/containerd/containerd.sock</span><br><span class="line">srw-rw---- 1 root root 0 7月   1 10:57 /var/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 如果 group 是 root：你可以改为其它组，比如 docker</span></span><br><span class="line"><span class="comment"># 如果 docker 组不存在则创建</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment"># 修改文件所属组为 docker</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chgrp</span> docker /var/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 为组添加读写权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> g+rw /var/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 添加用户到 docker 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时虽然已经可以不用 sudo 了，但是一旦重启 containerd 就会重新回到 root 权限，因此需要添加如下配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/containerd.service.d/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/systemd/system/containerd.service.d/override.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStartPost=/bin/bash -c &#x27;chmod 660 /run/containerd/containerd.sock &amp;&amp; chgrp docker /run/containerd/containerd.sock&#x27;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>crictl</code> 命令的使用方式比较类似<code>docker</code>命令</p></li></ul><table><thead><tr><th>操作</th><th><code>docker</code> 命令</th><th><code>crictl</code> 命令</th><th>说明</th></tr></thead><tbody><tr><td>查看正在运行的容器</td><td><code>docker ps</code></td><td><code>crictl ps</code></td><td></td></tr><tr><td>查看所有容器（包括已停止）</td><td><code>docker ps -a</code></td><td><code>crictl ps -a</code></td><td></td></tr><tr><td>查看镜像</td><td><code>docker images</code></td><td><code>crictl images</code></td><td></td></tr><tr><td>查看容器日志</td><td><code>docker logs &lt;container_id&gt;</code></td><td><code>crictl logs &lt;container_id&gt;</code></td><td></td></tr><tr><td>进入容器交互</td><td><code>docker exec -it &lt;id&gt; sh</code></td><td><code>crictl exec -it &lt;id&gt; sh</code></td><td></td></tr><tr><td>查看容器详细信息</td><td><code>docker inspect &lt;container_id&gt;</code></td><td><code>crictl inspect &lt;container_id&gt;</code></td><td></td></tr><tr><td>查看 Pod 详细信息</td><td>❌（不支持）</td><td><code>crictl inspectp &lt;pod_id&gt;</code></td><td>K8s 专属</td></tr><tr><td>删除容器</td><td><code>docker rm &lt;container_id&gt;</code></td><td><code>crictl rm &lt;container_id&gt;</code></td><td></td></tr><tr><td>删除镜像</td><td><code>docker rmi &lt;image_id&gt;</code></td><td><code>crictl rmi &lt;image_id&gt;</code></td><td></td></tr><tr><td>拉取镜像</td><td><code>docker pull nginx</code></td><td><code>crictl pull nginx</code></td><td></td></tr><tr><td>运行容器（非 K8s 场景）</td><td><code>docker run -it nginx</code></td><td>❌（不支持）</td><td><code>crictl</code> 不运行容器，仅调试现有容器</td></tr><tr><td>列出容器运行时信息</td><td><code>docker info</code></td><td><code>crictl info</code></td><td></td></tr><tr><td>查看容器运行状态</td><td><code>docker stats</code></td><td><code>crictl stats</code></td><td>简要版</td></tr><tr><td>设置配置文件</td><td><code>~/.docker/config.json</code></td><td><code>/etc/crictl.yaml</code></td><td>如设置 endpoint</td></tr></tbody></table><h2 id="nerdctl">nerdctl</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/containerd/nerdctl">nerdctl</a> 是一个 兼容 Docker CLI 的容器命令行工具，用于管理 containerd 容器运行时。</p></li><li class="lvl-2"><p>它是 containerd 官方子项目，由 CNCF 维护，其命令语法与 Docker CLI 兼容，目标是让习惯 Docker 的用户也能轻松使用 containerd。</p></li><li class="lvl-2"><p>安装 nerdctl</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载最新版本</span></span><br><span class="line">VERSION=2.1.3</span><br><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/nerdctl-<span class="variable">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解压</span></span><br><span class="line">tar -xvf nerdctl-<span class="variable">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 移动到系统 PATH</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> nerdctl /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># nerdctl 需要 sudo 权限</span></span><br><span class="line"><span class="comment">## 为 sudo 添加 PATH</span></span><br><span class="line"><span class="built_in">sudo</span> visudo</span><br><span class="line"><span class="comment">## 找到这一行</span></span><br><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"><span class="comment">## 修改为，即将 nerdctl 所在的目录加入 PATH</span></span><br><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试</span></span><br><span class="line"><span class="comment">## 查看版本</span></span><br><span class="line"><span class="built_in">sudo</span> nerdctl version</span><br><span class="line"><span class="comment">## 列出容器，--namespace k8s.io 表示查看 k8s 中的容器</span></span><br><span class="line"><span class="built_in">sudo</span> nerdctl ps --namespace k8s.io</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果不想每次都加上 --namespace k8s.io，可以设置别名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias kps=&#x27;sudo nerdctl --namespace=k8s.io ps&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line">kps</span><br></pre></td></tr></table></figure><h2 id="远程连接-k8s-集群">远程连接 k8s 集群</h2><h3 id="本地不存在-kubeconfig-文件">本地不存在 kubeconfig 文件</h3><ul class="lvl-0"><li class="lvl-2"><p>获取 kubeconfig 文件，位于 Master 节点：/etc/kubernetes/admin.conf，将其拷贝到本地</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/config</span><br></pre></td></tr></table></figure><h3 id="本地已存在-kubeconfig-文件">本地已存在 kubeconfig 文件</h3><ul class="lvl-0"><li class="lvl-2"><p>已经配置了一个集群的连接，还想再添加一个集群，可以通过通过合并的方式添加</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将新集群的 kubeconfig 文件拷贝到本地</span></span><br><span class="line">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/new-cluster.conf</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">KUBECONFIG=~/.kube/config:new-cluster.conf kubectl config view --flatten &gt; merged-config.yaml</span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line"><span class="built_in">mv</span> merged-config.yaml ~/.kube/config</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取集群配置相关命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有集群配置</span></span><br><span class="line">kubectl config get-contexts</span><br><span class="line"><span class="comment"># 查看当前默认的 context</span></span><br><span class="line">kubectl config current-context</span><br><span class="line"><span class="comment"># 切换 context</span></span><br><span class="line">kubectl config use-context &lt;context_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集群名称</span></span><br><span class="line">kubectl config get-clusters</span><br><span class="line"><span class="comment"># 获取用户名称</span></span><br><span class="line">kubectl config get-users</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>测试</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除集群配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 context</span></span><br><span class="line">kubectl config delete-context &lt;context_name&gt;</span><br><span class="line"><span class="comment"># 删除 cluster</span></span><br><span class="line">kubectl config delete-cluster &lt;cluster_name&gt;</span><br><span class="line"><span class="comment"># 删除 user</span></span><br><span class="line">kubectl config delete-user &lt;user_name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>也可以直接编辑 kubeconfig（~/.kube/config） 文件，添加或删除不需要的集群、用户、上下文等信息</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/&quot;&gt;使用 kubeadm 引导集群&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/&quot;&gt;kubeadm 命令指南&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/&quot;&gt;用 kubeadm 进行管理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 K8S 之 minikube</title>
    <link href="https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/"/>
    <id>https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/</id>
    <published>2025-06-28T13:30:05.000Z</published>
    <updated>2025-06-30T05:56:30.873Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。</p></li><li class="lvl-2"><p><a href="https://kubernetes.io/zh-cn/">K8S官网</a></p></li><li class="lvl-2"><p><a href="https://github.com/kubernetes/kubernetes">k8s Github</a></p></li><li class="lvl-2"><p><a href="https://minikube.sigs.k8s.io/docs/">minikube官网</a></p></li></ul><span id="more"></span><h2 id="安装前设置">安装前设置</h2><h3 id="修正系统的时间">修正系统的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装chrony</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install chrony -y</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now chronyd</span><br><span class="line"><span class="comment"># 修正时间</span></span><br><span class="line"><span class="built_in">sudo</span> chronyc makestep</span><br><span class="line"><span class="comment"># 查看时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="安装-docker">安装 <code>docker</code></h3><ul class="lvl-0"><li class="lvl-2"><p>安装方法参见 <a href="/2025/05/20/docker-install/" title="Linux 安装 Docker">Linux 安装 Docker</a></p></li></ul><h3 id="创建用户">创建用户</h3><ul class="lvl-0"><li class="lvl-2"><p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建用户</span></span><br><span class="line">$ <span class="built_in">sudo</span> useradd -m -s /bin/bash centos</span><br><span class="line"><span class="comment"># 2.添加到docker用户组</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker centos</span><br><span class="line"><span class="comment"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class="line">$ <span class="built_in">sudo</span> usermod -aG wheel centos</span><br><span class="line"><span class="comment">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class="line"><span class="comment"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class="line">$ su - centos</span><br></pre></td></tr></table></figure><h3 id="安装-kubectl">安装 <code>kubectl</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载 kubectl</span></span><br><span class="line">$ curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.验证下载(可选)</span></span><br><span class="line">$ curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat kubectl.sha256)</span>  kubectl&quot;</span> | <span class="built_in">sha256sum</span> --check</span><br><span class="line"><span class="comment">## 验证通过输出</span></span><br><span class="line">kubectl: 成功</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装 kubectl</span></span><br><span class="line">$ <span class="built_in">sudo</span> install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看安装的版本</span></span><br><span class="line">$ kubectl version --client</span><br><span class="line">Client Version: v1.33.2</span><br><span class="line">Kustomize Version: v5.6.0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>启用 shell 自动补全功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装 bash-completion</span></span><br><span class="line"><span class="comment"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class="line">$ <span class="built_in">type</span> _init_completion</span><br><span class="line"><span class="comment"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class="line">$ dnf install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装 kubectl 的自动补全功能</span></span><br><span class="line"><span class="comment"># 2.1 当前用户</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"><span class="comment"># 2.2 所有用户</span></span><br><span class="line">$ kubectl completion bash | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.刷新配置文件</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="使用-minikube-创建-K8S-集群">使用 minikube 创建 K8S 集群</h2><ul class="lvl-0"><li class="lvl-2"><p>该工具只适合在本机进行开发和测试时使用，其原理是在本机的docker环境中创建一个<code>minikube</code>容器作为<code>k8s</code>的节点机。</p></li></ul><h3 id="安装-minikube">安装 minikube</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Fx86-64%2Fstable%2Fbinary+download">minikube安装说明</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载</span></span><br><span class="line">$ curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64</span><br><span class="line"><span class="comment"># 2.安装</span></span><br><span class="line">$ <span class="built_in">sudo</span> install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; <span class="built_in">rm</span> minikube-linux-amd64</span><br><span class="line"><span class="comment"># 3.验证</span></span><br><span class="line">$ minikube version</span><br><span class="line"><span class="comment"># 4.查看帮助</span></span><br><span class="line">$ minikube --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="创建集群">创建集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群，注意不能使用 root 用户，要求该用户具有 docker 权限，并且具有sudo权限，否则会报错</span></span><br><span class="line"><span class="comment"># 系统内存至少 4G，以保证稳定性</span></span><br><span class="line"><span class="comment"># 默认使用docker驱动 --driver=docker，minikube 支持的驱动：https://minikube.sigs.k8s.io/docs/drivers/</span></span><br><span class="line">$ minikube start</span><br><span class="line">😄  Rocky 8.10 (amd64) 上的 minikube v1.36.0</span><br><span class="line">✨  根据现有的配置文件使用 docker 驱动程序</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube&quot;</span> primary control-plane</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">    &gt; index.docker.io/kicbase/sta...:  502.26 MiB / 502.26 MiB  100.00% 27.50 M</span><br><span class="line">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.47, but successfully downloaded docker.io/kicbase/stable:v0.0.47@sha256:6ed579c9292b4370177b7ef3c42cc4b4a6dcd0735a1814916cbc22c8bf38412b as a fallback image</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">    ▪ 正在生成证书和密钥...</span><br><span class="line">    ▪ 正在启动控制平面...</span><br><span class="line">    ▪ 配置 RBAC 规则 ...</span><br><span class="line">🔗  配置 bridge CNI (Container Networking Interface) ...</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">    ▪ 正在使用镜像 gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">🌟  启用插件： default-storageclass, storage-provisioner</span><br><span class="line">🏄  完成！kubectl 现在已配置，默认使用<span class="string">&quot;minikube&quot;</span>集群和<span class="string">&quot;default&quot;</span>命名空间</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Minikube 允许你创建多个独立的 Kubernetes 集群，每个 profile 是一个单独的 minikube 实例，互不干扰。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 是 --profile 的缩写，表示 指定使用哪个 Minikube 集群（Profile）,默认 profile 名是 minikube</span></span><br><span class="line">minikube start -p dev</span><br><span class="line">minikube start -p <span class="built_in">test</span></span><br><span class="line">minikube start -p prod</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取集群状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME       STATUS   ROLES           AGE   VERSION</span><br><span class="line">minikube   Ready    control-plane   27s   v1.33.1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看本机容器，k8s 集群就在这个容器中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                   CREATED          STATUS          PORTS                                                                                                                                  NAMES</span><br><span class="line">4e7eaad73934   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   47 minutes ago   Up 47 minutes   127.0.0.1:32772-&gt;22/tcp, 127.0.0.1:32771-&gt;2376/tcp, 127.0.0.1:32770-&gt;5000/tcp, 127.0.0.1:32769-&gt;8443/tcp, 127.0.0.1:32768-&gt;32443/tcp   minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该容器中的docker容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it minikube docker ps</span><br><span class="line">CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">c25bcc3cb76c   1cf5f116067c                 <span class="string">&quot;/coredns -conf /etc…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_coredns_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class="line">a22714ccfce2   b79c189b052c                 <span class="string">&quot;/usr/local/bin/kube…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-proxy_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class="line">a368d902aef9   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class="line">973caed86b2c   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class="line">9db7567143a2   6e38f40d628d                 <span class="string">&quot;/storage-provisioner&quot;</span>   2 minutes ago   Up 2 minutes             k8s_storage-provisioner_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class="line">ba39fe88ad59   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class="line">ef0733df95b4   ef43894fa110                 <span class="string">&quot;kube-controller-man…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-controller-manager_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class="line">852828a600d5   c6ab243b29f8                 <span class="string">&quot;kube-apiserver --ad…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-apiserver_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class="line">97efb54702cd   499038711c08                 <span class="string">&quot;etcd --advertise-cl…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_etcd_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br><span class="line">a3dd2c2817f1   398c985c0d95                 <span class="string">&quot;kube-scheduler --au…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-scheduler_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class="line">927ebc63cf80   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class="line">744d4c6e3571   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class="line">4ae6bdc25908   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class="line">dff641d8672a   registry.k8s.io/pause:3.10   <span class="string">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-3"><p>配置你的终端，让 Docker CLI 指向 minikube 内部的 Docker 守护进程（就是通过 docker 远程连接的方式）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker远程的环境变量，我们可以将其配置到宿主机的环境变量中</span></span><br><span class="line">$ minikube docker-env</span><br><span class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">&quot;tcp://192.168.49.2:2376&quot;</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">&quot;/home/centos/.minikube/certs&quot;</span></span><br><span class="line"><span class="built_in">export</span> MINIKUBE_ACTIVE_DOCKERD=<span class="string">&quot;minikube&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To point your shell to minikube&#x27;s docker-daemon, run:</span></span><br><span class="line"><span class="comment"># eval $(minikube -p minikube docker-env)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时配置宿主机环境变量，此时我们再执行docker命令，就会使用minikube的docker-daemon</span></span><br><span class="line">$ <span class="built_in">eval</span> $(minikube -p minikube docker-env)</span><br><span class="line"><span class="comment"># 取消临时配置,-u 是 --unset 的缩写</span></span><br><span class="line">$ <span class="built_in">eval</span> $(minikube -p minikube docker-env -u)</span><br></pre></td></tr></table></figure><h3 id="minikube-命令">minikube 命令</h3><ul class="lvl-0"><li class="lvl-2"><p>登录到 minikube 环境（用于调试）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际上就是进入minikube容器的shell</span></span><br><span class="line">$ minikube ssh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行 kubectl 命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看支持的命令</span></span><br><span class="line">$ minikube kubectl -- --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 运行 kubectl 命令，这里注意 minikube kubectl -- 前面有空格</span></span><br><span class="line">$ minikube kubectl -- get pods --namespace kube-system</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-674b8bbfcf-8jrx4           1/1     Running   0          45m</span><br><span class="line">etcd-minikube                      1/1     Running   0          45m</span><br><span class="line">kube-apiserver-minikube            1/1     Running   0          45m</span><br><span class="line">kube-controller-manager-minikube   1/1     Running   0          45m</span><br><span class="line">kube-proxy-5dkt4                   1/1     Running   0          45m</span><br><span class="line">kube-scheduler-minikube            1/1     Running   0          45m</span><br><span class="line">storage-provisioner                1/1     Running   0          45m</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>node节点管理</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个worker节点，此时就是又启动了一个minikube容器</span></span><br><span class="line">$ minikube node add</span><br><span class="line">😄  将节点 m02 作为 [worker] 添加到集群 minikube</span><br><span class="line">❗  在没有任何 CNI 的情况下创建集群，向其中添加节点可能会导致网络中断。</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube-m02&quot;</span> worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">🏄  已成功将 m02 添加到 minikube！</span><br><span class="line"></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                   CREATED             STATUS             PORTS                                                                                                                                  NAMES</span><br><span class="line">ce5431e994c3   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   24 minutes ago      Up 24 minutes      127.0.0.1:32792-&gt;22/tcp, 127.0.0.1:32791-&gt;2376/tcp, 127.0.0.1:32790-&gt;5000/tcp, 127.0.0.1:32789-&gt;8443/tcp, 127.0.0.1:32788-&gt;32443/tcp   minikube-m02</span><br><span class="line">2739aa21a085   kicbase/stable:v0.0.47   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   About an hour ago   Up About an hour   127.0.0.1:32777-&gt;22/tcp, 127.0.0.1:32776-&gt;2376/tcp, 127.0.0.1:32775-&gt;5000/tcp, 127.0.0.1:32774-&gt;8443/tcp, 127.0.0.1:32773-&gt;32443/tcp   minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME           STATUS   ROLES           AGE   VERSION</span><br><span class="line">minikube       Ready    control-plane   55m   v1.33.1</span><br><span class="line">minikube-m02   Ready    &lt;none&gt;          70s   v1.33.1</span><br><span class="line"></span><br><span class="line">$ minikube node list</span><br><span class="line">minikube        192.168.49.2</span><br><span class="line">minikube-m02    192.168.49.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止节点</span></span><br><span class="line">$ minikube node stop minikube-m02</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube-m02&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class="line">🛑  成功停止节点 minikube-m02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">$ minikube node start minikube-m02</span><br><span class="line">👍  在集群中 <span class="string">&quot;minikube&quot;</span> 启动节点 <span class="string">&quot;minikube-m02&quot;</span> worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class="line">🔄  正在为<span class="string">&quot;minikube-m02&quot;</span>重启现有的 docker container ...</span><br><span class="line">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">🌟  启用插件：</span><br><span class="line">😄  成功启动节点 minikube-m02！</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点</span></span><br><span class="line">$ minikube node delete minikube-m02</span><br><span class="line">🔥  正在从集群 minikube 中删除节点 minikube-m02</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube-m02&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class="line">🔥  正在删除 docker 中的“minikube-m02”…</span><br><span class="line">💀  节点 minikube-m02 已成功删除。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>停止集群: 此时只是停止容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ minikube stop</span><br><span class="line">✋  正在停止节点 <span class="string">&quot;minikube&quot;</span> ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube”…</span><br><span class="line">🛑  1 个节点已停止</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除集群: 删除容器及其配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ minikube delete</span><br><span class="line">🔥  正在删除 docker 中的“minikube”…</span><br><span class="line">🔥  正在删除容器 <span class="string">&quot;minikube&quot;</span> ...</span><br><span class="line">🔥  正在移除 /home/centos/.minikube/machines/minikube…</span><br><span class="line">💀  已删除所有关于 <span class="string">&quot;minikube&quot;</span> 集群的痕迹。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>具体的使用方法参考<a href="https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/">https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/&quot;&gt;K8S官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;k8s Github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://minikube.sigs.k8s.io/docs/&quot;&gt;minikube官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="k8s" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/k8s/"/>
    
    
    <category term="K8S" scheme="https://blog.hanqunfeng.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 Config 与  Secret</title>
    <link href="https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/"/>
    <id>https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/</id>
    <published>2025-06-12T14:30:05.000Z</published>
    <updated>2025-06-12T03:19:18.357Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 中的 Config 与  Secret</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p></li></ul><span id="more"></span><h2 id="Config-简介">Config 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Docker Swarm 中，Config 是一种用于管理配置资源的机制，允许你将配置文件与容器分离，便于在不同环境中重用和共享配置。</p></li><li class="lvl-2"><p>Config 和 Volume 都是 Docker 中用于管理数据的机制，但它们的设计目的和使用场景有显著不同：</p></li></ul><table><thead><tr><th>特性</th><th>Config</th><th>Volume</th></tr></thead><tbody><tr><td>用途</td><td>只能是文件，用于存储配置文件、只读数据</td><td>文件目录均可，存储应用数据、可读写数据</td></tr><tr><td>可变性</td><td>通常不可变（只读）</td><td>可变（读写）</td></tr><tr><td>生命周期</td><td>随服务部署更新</td><td>独立于容器生命周期</td></tr><tr><td>存储位置</td><td>存储在Docker管理的内存/文件系统</td><td>存储在主机文件系统或网络存储</td></tr><tr><td>Swarm支持</td><td>原生Swarm功能</td><td>通用功能</td></tr><tr><td>更新机制</td><td>更新需要重新部署服务</td><td>可动态更新</td></tr><tr><td>典型用例</td><td>配置文件、环境变量</td><td>数据库文件、日志、用户上传内容</td></tr></tbody></table><h3 id="Config-命令">Config 命令</h3><table><thead><tr><th>命令</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td><code>create</code></td><td>从文件或标准输入创建一个 config</td><td><code>docker config create my_config config.txt</code></td></tr><tr><td><code>inspect</code></td><td>显示一个或多个 config 的详细信息</td><td><code>docker config inspect my_config</code></td></tr><tr><td><code>ls</code></td><td>列出所有 configs</td><td><code>docker config ls</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 config</td><td><code>docker config rm my_config</code></td></tr></tbody></table><h4 id="docker-config-create-创建一个-config"><code>docker config create</code>:  创建一个 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中创建</span></span><br><span class="line">docker config create my_config my_config.json</span><br><span class="line"><span class="comment"># 从标准输入创建</span></span><br><span class="line"><span class="built_in">cat</span> my_config.json | docker config create my_config -</span><br></pre></td></tr></table></figure><h4 id="docker-config-inspect-查看-config-的信息"><code>docker config inspect</code>:  查看 config 的信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker config inspect my_config</span><br><span class="line"><span class="comment">## 输出，可以看到 Data 字段，用 base64 解码后，就是 config 的原始内容</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;q4257t5c2wq6uvvkm4g3hssae&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 3145</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my_config&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: <span class="string">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span> | <span class="built_in">base64</span> -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更易读</span></span><br><span class="line">docker config inspect --pretty my_config</span><br><span class="line">docker config inspect --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_config</span><br></pre></td></tr></table></figure><h4 id="docker-config-ls-列出所有-config"><code>docker config ls</code>:  列出所有 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker config <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#  只显示 ID</span></span><br><span class="line">docker config <span class="built_in">ls</span> -q</span><br></pre></td></tr></table></figure><h4 id="docker-config-rm-删除一个或多个-config"><code>docker config rm</code>:  删除一个或多个 config</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker config <span class="built_in">rm</span> my_config</span><br><span class="line"><span class="comment"># 删除多个</span></span><br><span class="line">docker config <span class="built_in">rm</span> my_config1 my_config2</span><br><span class="line"><span class="comment"># 删除所有 ，慎重使用</span></span><br><span class="line">docker config <span class="built_in">rm</span> $(docker config <span class="built_in">ls</span> -q)</span><br></pre></td></tr></table></figure><h3 id="Stack中使用Config">Stack中使用Config</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/configs/">Configs top-level elements</a></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configs:</span> <span class="comment">#  声明 config 列表</span></span><br><span class="line">  <span class="attr">nginx_config:</span>  <span class="comment">#  config 名称</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./nginx/nginx.conf</span> <span class="comment">#  config 文件</span></span><br><span class="line">  <span class="attr">my_config:</span> <span class="comment">#  使用外部 config，即 docker config create 创建的</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">configs:</span> <span class="comment"># 服务使用 config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">nginx_config</span> <span class="comment"># 指定 config 名称</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/etc/nginx/nginx.conf</span> <span class="comment"># 指定容器中配置文件存放位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_config</span>  <span class="comment">#  使用外部 config</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/app/config.json</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0444</span> <span class="comment">#  指定权限</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;1000&quot;</span> <span class="comment"># 指定用户</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;1000&quot;</span> <span class="comment"># 指定用户组</span></span><br></pre></td></tr></table></figure><h2 id="Secret-简介">Secret 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Secrets 是 Docker 专门为敏感数据设计的安全管理机制，用于安全地存储和传输密码、API密钥、TLS证书等敏感信息。</p></li><li class="lvl-2"><p>与 Configs 的主要区别</p></li></ul><table><thead><tr><th>特性</th><th>Secrets</th><th>Configs</th></tr></thead><tbody><tr><td>用途</td><td>敏感数据（密码、密钥等）</td><td>普通配置文件</td></tr><tr><td>存储</td><td>加密存储</td><td>明文存储</td></tr><tr><td>传输</td><td>加密传输</td><td>明文传输</td></tr><tr><td>访问</td><td>挂载为内存文件</td><td>常规文件挂载</td></tr><tr><td>权限</td><td>默认仅 root 可读（0440）</td><td>可自定义权限</td></tr></tbody></table><h3 id="Secret-命令">Secret 命令</h3><table><thead><tr><th>命令</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td><code>create</code></td><td>从文件或标准输入创建一个 secret</td><td><code>docker secret create my_secret secret.txt</code></td></tr><tr><td><code>inspect</code></td><td>显示一个或多个 secret 的详细信息</td><td><code>docker secret inspect my_secret</code></td></tr><tr><td><code>ls</code></td><td>列出所有 secrets</td><td><code>docker secret ls</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 secret</td><td><code>docker secret rm my_secret</code></td></tr></tbody></table><h4 id="docker-secret-create-创建一个-secret"><code>docker secret create</code>:  创建一个 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中创建</span></span><br><span class="line">docker secret create my_secret my_secret.txt</span><br><span class="line"><span class="comment"># 从标准输入创建</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;my_secret&quot;</span> | docker secret create my_secret -</span><br></pre></td></tr></table></figure><h4 id="docker-secret-inspect-查看-secret-的信息"><code>docker secret inspect</code>:  查看 secret 的信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker secret inspect my_secret</span><br><span class="line"><span class="comment">## 输出，可以看到 没有 data 字段，所以无法查看原始的内容</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;qlklskvxthp61i0nbvzvr6wuw&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 3144</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my_secret&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 输出更易读</span></span><br><span class="line">docker secret inspect --pretty my_secret</span><br><span class="line">docker secret inspect --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_secret</span><br></pre></td></tr></table></figure><h4 id="docker-secret-ls-列出所有的-secret"><code>docker secret ls</code>:  列出所有的 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker secret <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 列出所有的 secret 的 ID</span></span><br><span class="line">docker secret <span class="built_in">ls</span> -q</span><br><span class="line">docker secret <span class="built_in">ls</span> --filter name=my_secret</span><br></pre></td></tr></table></figure><h4 id="docker-secret-rm-删除-secret"><code>docker secret rm</code>:  删除 secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker secret <span class="built_in">rm</span> my_secret</span><br><span class="line"><span class="comment"># 删除所有，慎重使用</span></span><br><span class="line">docker secret <span class="built_in">rm</span> $(docker secret <span class="built_in">ls</span> -q)</span><br></pre></td></tr></table></figure><h3 id="Stack中使用Secret">Stack中使用Secret</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/secrets/">Secrets top-level elements</a></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">    <span class="attr">secrets:</span> <span class="comment"># 关联secret，容器内关联路径为 /run/secrets/&lt;secret_name&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span> <span class="comment"># 声明 secret 列表</span></span><br><span class="line">  <span class="attr">db_root_password:</span> <span class="comment">#  secret 名称</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./mysql_root_password.txt</span> <span class="comment">#  secret 文件</span></span><br><span class="line">  <span class="attr">my_secret:</span> <span class="comment"># 生产环境建议使用预创建的secret</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>  <span class="comment"># 引用预先创建的secret</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优化: 使用非root用户，并隐藏 secret 文件</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&quot;mysql:mysql&quot;</span>  <span class="comment"># 关键点1：使用非root用户</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/.db_root_password</span>  <span class="comment"># 关键点2：隐藏文件</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">db_root_password</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">.db_root_password</span>  <span class="comment"># 隐藏文件名</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;999&quot;</span>  <span class="comment"># mysql用户ID</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;999&quot;</span>  <span class="comment"># mysql组ID</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0400</span>  <span class="comment"># 仅拥有者可读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_secret</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">.my_secret</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;999&quot;</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;999&quot;</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">db_root_password:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./mysql_root_password.txt</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 中的 Config 与  Secret&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/compose-file/&quot;&gt;Compose file reference&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 栈(Stack)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/"/>
    <id>https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/</id>
    <published>2025-06-11T14:30:05.000Z</published>
    <updated>2025-06-28T03:28:50.646Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 栈管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p></li></ul><span id="more"></span><h2 id="Stack简介">Stack简介</h2><ul class="lvl-0"><li class="lvl-2"><p>前面我们在Swarm中创建服务都是通过Service，每次创建一个，有没有类似<code>docker compose</code>的方式来创建多个服务呢？Docker Swarm为我们提供了Stack</p></li><li class="lvl-2"><p>在 Docker Swarm 中，Stack（栈） 是用来定义和部署一组相关服务的集合。你可以把它看成是一个应用的整体，由多个服务（service）、网络（network）、卷（volume）等组成。</p></li></ul><h2 id="Stack-通常用-Docker-Compose-文件（YAML-格式）-描述">Stack 通常用 Docker Compose 文件（YAML 格式） 描述</h2><ul class="lvl-0"><li class="lvl-2"><p>Stack 完全兼容 Docker Compose 文件，并可以在 compose 文件中声明副本集等与Service相关的配置项。</p></li><li class="lvl-2"><p>我用表格总结一下二者的差异，重点放在「Stack 支持的配置」上：</p></li></ul><table><thead><tr><th>配置项</th><th>Docker Compose (本地)</th><th>Docker Stack (Swarm 集群)</th><th>说明</th></tr></thead><tbody><tr><td><code>name</code></td><td>✅</td><td>❌</td><td>Stack 不支持 name  属性</td></tr><tr><td><code>build</code></td><td>✅</td><td>❌</td><td>Stack 不支持 build 属性，只能使用image</td></tr><tr><td><code>deploy</code></td><td>❌（部分支持，通常被忽略）</td><td>✅（核心支持）</td><td>Stack 支持用 <code>deploy</code> 定义副本数、资源限制、更新策略等</td></tr><tr><td><code>deploy.replicas</code></td><td>❌</td><td>✅</td><td>定义服务副本数</td></tr><tr><td><code>deploy.resources</code></td><td>❌</td><td>✅</td><td>定义 CPU、内存限制</td></tr><tr><td><code>deploy.placement</code></td><td>❌</td><td>✅</td><td>定义服务调度策略（在哪些节点上运行）</td></tr><tr><td><code>deploy.update_config</code></td><td>❌</td><td>✅</td><td>定义滚动更新的参数</td></tr><tr><td><code>deploy.restart_policy</code></td><td>❌</td><td>✅</td><td>定义重启策略</td></tr><tr><td><code>deploy.mode</code></td><td>❌</td><td>✅</td><td><code>replicated</code> 或 <code>global</code></td></tr><tr><td><code>depends_on</code></td><td>✅</td><td>🚫（被忽略）</td><td>Stack 不支持容器启动顺序控制</td></tr><tr><td><code>build</code></td><td>✅</td><td>🚫（被忽略）</td><td>Stack 不支持直接构建镜像，只能用已存在的镜像</td></tr><tr><td><code>network.external</code></td><td>✅</td><td>✅</td><td>都支持外部网络</td></tr><tr><td><code>volumes.external</code></td><td>✅</td><td>✅</td><td>都支持外部卷</td></tr><tr><td><code>configs</code></td><td>🚫</td><td>✅</td><td>Stack 支持 Config 对象，适合配置文件管理</td></tr><tr><td><code>secrets</code></td><td>🚫</td><td>✅</td><td>Stack 支持 Secrets，用于安全存储敏感信息</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>以<a href="https://docs.portainer.io/">Portainer:Docker可视化管理工具</a>的stack配置文件为例</p></li></ul><blockquote><p>Portainer 社区版 （CE）可让您在 Docker、Docker Swarm、Kubernetes 和 Azure ACI 中轻松构建和管理容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://downloads.portainer.io/ce-lts/portainer-agent-stack.yml -o portainer-agent-stack.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span> <span class="comment">#  docker-compose版本，新版的docker已经不需要配置版本号了</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">agent:</span>  <span class="comment"># agent服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/agent:lts</span> <span class="comment"># 镜像，不能使用 Dockerfile</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment"># 挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/docker/volumes:/var/lib/docker/volumes</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 挂载网络，必须是 overlay</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">agent_network</span></span><br><span class="line">    <span class="attr">deploy:</span>   <span class="comment"># 部署策略，service 特有属性</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span> <span class="comment"># 全局模式</span></span><br><span class="line">      <span class="attr">placement:</span> <span class="comment"># 部署条件</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.platform.os</span> <span class="string">==</span> <span class="string">linux</span>] <span class="comment">#  运行在linux节点</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">portainer:</span> <span class="comment">#  portainer服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/portainer-ce:lts</span> <span class="comment">#  镜像</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-H</span> <span class="string">tcp://tasks.agent:9001</span> <span class="string">--tlsskipverify</span> <span class="comment">#  启动参数</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9443:9443&quot;</span>  <span class="comment"># 浏览器访问 https://localhost:9443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#  挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">portainer_data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 挂载网络，与agent服务网络一致</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">agent_network</span></span><br><span class="line">    <span class="attr">deploy:</span> <span class="comment">#  部署配置</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span> <span class="comment"># 副本模式</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment">#  副本数量</span></span><br><span class="line">      <span class="attr">placement:</span> <span class="comment">#  部署条件</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>] <span class="comment">#  节点角色为manager</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#  网络声明</span></span><br><span class="line">  <span class="attr">agent_network:</span> <span class="comment">#  网络名称</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span> <span class="comment">#  网络驱动</span></span><br><span class="line">    <span class="attr">attachable:</span> <span class="literal">true</span> <span class="comment"># 允许容器加入</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#  挂载卷声明</span></span><br><span class="line">  <span class="attr">portainer_data:</span> <span class="comment">#  挂载卷名称</span></span><br></pre></td></tr></table></figure><h2 id="Stack-命令">Stack 命令</h2><table><thead><tr><th>子命令</th><th>中文说明</th><th>示例命令</th></tr></thead><tbody><tr><td><code>config</code></td><td>输出最终的配置文件（经过合并与变量替换后）</td><td><code>docker stack config -c docker-compose.yml</code></td></tr><tr><td><code>deploy</code></td><td>部署新 stack 或更新已有 stack</td><td><code>docker stack deploy -c docker-compose.yml mystack</code></td></tr><tr><td><code>ls</code></td><td>列出所有已部署的 stack</td><td><code>docker stack ls</code></td></tr><tr><td><code>ps</code></td><td>查看 stack 中的所有任务（即各个容器实例）</td><td><code>docker stack ps mystack</code></td></tr><tr><td><code>rm</code></td><td>删除一个或多个 stack</td><td><code>docker stack rm mystack</code></td></tr><tr><td><code>services</code></td><td>列出某个 stack 中的所有服务</td><td><code>docker stack services mystack</code></td></tr></tbody></table><h3 id="docker-stack-config-输出最终的配置文件"><code>docker stack config</code>: 输出最终的配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此命令也可以用来验证compose文件格式是否正确，只保证格式正确，不保证逻辑正确</span></span><br><span class="line">docker stack config -c portainer-agent-stack.yml</span><br></pre></td></tr></table></figure><h3 id="docker-stack-deploy-部署-stack"><code>docker stack deploy</code>: 部署 stack</h3><ul class="lvl-0"><li class="lvl-3"><p><code>docker stack deploy</code> == <code>docker stack up</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c portainer-agent-stack.yml portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Creating network portainer_agent_network</span><br><span class="line">Creating service portainer_agent</span><br><span class="line">Creating service portainer_portainer</span><br></pre></td></tr></table></figure><h3 id="docker-stack-ls-列出所有-stack"><code>docker stack ls</code>: 列出所有 stack</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker stack ls</code> == <code>docker stack list</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，stack名称为portainer，其内部有两个服务，agent和portainer</span></span><br><span class="line">NAME        SERVICES</span><br><span class="line">portainer   2</span><br></pre></td></tr></table></figure><h3 id="docker-stack-services-查看服务"><code>docker stack services</code>:  查看服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker stack services portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class="line">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class="line">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等效</span></span><br><span class="line">docker service <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class="line">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class="line">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br></pre></td></tr></table></figure><h3 id="docker-stack-ps-列出-stack-下的所有服务实例"><code>docker stack ps</code>: 列出 stack 下的所有服务实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker stack ps portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 30 seconds ago</span><br><span class="line">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 59 seconds ago</span><br><span class="line">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 3 minutes ago</span><br><span class="line">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 35 seconds ago</span><br><span class="line">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 48 seconds ago</span><br><span class="line">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 2 minutes ago</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等效</span></span><br><span class="line">docker service ps portainer_agent portainer_portainer</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 7 minutes ago</span><br><span class="line">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 8 minutes ago</span><br><span class="line">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 10 minutes ago</span><br><span class="line">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 7 minutes ago</span><br><span class="line">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 7 minutes ago</span><br><span class="line">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 10 minutes ago</span><br></pre></td></tr></table></figure><h3 id="docker-stack-rm-停止并删除-stack"><code>docker stack rm</code>: 停止并删除 stack</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker stack rm</code> == <code>docker stack remove</code> == <code>docker stack down</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> portainer</span><br></pre></td></tr></table></figure><h2 id="deploy-参数详解"><code>deploy</code> 参数详解</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-service:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span>  <span class="comment"># 指定副本数，仅在 mode: replicated 下有效。表示同时运行3个容器副本。</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span>  <span class="comment"># 服务运行模式，可选值：</span></span><br><span class="line">                        <span class="comment"># - replicated：通过 replicas 指定副本数量（默认）</span></span><br><span class="line">                        <span class="comment"># - global：每个节点运行一个副本，忽略 replicas 配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span>         <span class="comment"># 容器的“硬限制”，超过会被强制限制</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;1.0&#x27;</span>    <span class="comment"># 限制每个容器最多使用1个逻辑 CPU</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span>   <span class="comment"># 限制每个容器最多使用512MB内存</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">reservations:</span>   <span class="comment"># 容器的“软限制”，Swarm调度时预留资源参考值（不会强制限制）</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.25&#x27;</span>   <span class="comment"># 建议每个容器至少分配0.25个CPU</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span>   <span class="comment"># 建议每个容器至少分配128MB内存</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span>  <span class="comment"># 控制容器重启行为，可选值：</span></span><br><span class="line">                               <span class="comment"># - none：不重启</span></span><br><span class="line">                               <span class="comment"># - on-failure：失败时重启（非0退出码）</span></span><br><span class="line">                               <span class="comment"># - any：无论是否失败都重启</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span>              <span class="comment"># 重启前等待时间</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span>        <span class="comment"># 最多重启3次</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span>            <span class="comment"># 判断失败次数的时间窗口（60秒内最多失败3次）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span>           <span class="comment"># 指定容器调度到哪些节点上运行，可用条件有：</span></span><br><span class="line">                               <span class="comment"># - node.role == manager/worker</span></span><br><span class="line">                               <span class="comment"># - node.hostname == xxx</span></span><br><span class="line">                               <span class="comment"># - node.labels.xxx == yyy</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">worker</span>  <span class="comment"># 只调度到 worker 节点</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">preferences:</span>           <span class="comment"># 调度偏好（不是强约束）</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">spread:</span> <span class="string">node.labels.zone</span>  <span class="comment"># 将服务均匀地分布在 zone 标签不同的节点上</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">update_config:</span>           <span class="comment"># 控制服务滚动更新的行为</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span>         <span class="comment"># 每次最多并发更新2个容器</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span>             <span class="comment"># 每批更新之间等待10秒</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span>  <span class="comment"># 更新失败时的处理方式，可选值：</span></span><br><span class="line">                                  <span class="comment"># - pause：暂停更新（默认）</span></span><br><span class="line">                                  <span class="comment"># - continue：继续更新</span></span><br><span class="line">                                  <span class="comment"># - rollback：回滚到旧版本</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">stop-first</span>      <span class="comment"># 控制更新顺序，可选值：</span></span><br><span class="line">                               <span class="comment"># - stop-first（先停后启，默认）</span></span><br><span class="line">                               <span class="comment"># - start-first（先启后停，适用于无状态服务）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">rollback_config:</span>         <span class="comment"># 回滚时的行为，字段与 update_config 类似</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span>         <span class="comment"># 回滚时每次最多处理1个容器</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span>              <span class="comment"># 每批回滚之间等待5秒</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">pause</span>  <span class="comment"># 回滚失败时暂停</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">stop-first</span>      <span class="comment"># 回滚时先停再启</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 栈管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/reference/compose-file/&quot;&gt;Compose file reference&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 网络(Overlay)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/"/>
    <id>https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/</id>
    <published>2025-06-11T13:30:05.000Z</published>
    <updated>2025-06-11T08:04:58.671Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 网络(Overlay)</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Overlay-简介">Overlay 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。</p></li><li class="lvl-2"><p>当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。</p></li><li class="lvl-2"><p>overlay 网络特点</p><ul class="lvl-2"><li class="lvl-4">跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。</li><li class="lvl-4">内置服务发现：容器之间可以通过服务名称直接通信。</li><li class="lvl-4">支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。</li><li class="lvl-4">自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。</li></ul></li></ul><h2 id="Swarm-中的-overlay-网络">Swarm 中的 overlay 网络</h2><ul class="lvl-0"><li class="lvl-2"><p>当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：<code>docker_gwbridge</code> ，一个是 overlay network：<code>ingress</code>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">6b7aadbbd180   bridge            bridge    <span class="built_in">local</span></span><br><span class="line">5ddadf5d0608   docker_gwbridge   bridge    <span class="built_in">local</span></span><br><span class="line">21c6f5b1bedd   host              host      <span class="built_in">local</span></span><br><span class="line">idx465x3jg68   ingress           overlay   swarm</span><br><span class="line">a770c5ad4b13   none              null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h3 id="docker-gwbridge"><code>docker_gwbridge</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查看 <code>docker_gwbridge</code> 详情，其网段为 <code>172.18.0.0/16</code>，网关为 <code>172.18.0.1</code>，内部有一个容器 <code>ingress-sbox</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker inspect docker_gwbridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;docker_gwbridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2025-06-08T07:29:52.119033035-04:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;gateway_ingress-sbox&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker_gwbridge&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>先来看这个网段 <code>172.18.0.0/16</code>，我们查看主机的网络和路由表，可以看到 <code>261: docker_gwbridge</code>，其IP地址为 <code>172.18.0.1</code>，所以这里我们就可以知道 <code>docker_gwbridge</code> 就是连接到<code>261: docker_gwbridge</code>这块网卡上的，另外当前还有一个<code>263: veth3176100@if262</code>虚拟网络接口也连接到<code>261: docker_gwbridge</code>上，通过路由表我们得知其最终连接到<code>2: enp0s5</code>上，也就是这台主机的网卡。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute</span><br><span class="line">       valid_lft 2591886sec preferred_lft 604686sec</span><br><span class="line">    inet6 fe80::21c:42ff:fe49:1282/64 scope <span class="built_in">link</span> noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:5c:31:<span class="built_in">cd</span>:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:5cff:fe31:cd30/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:feff:fee3:caf7/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::944b:c1ff:fed9:83c5/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看路由表</span></span><br><span class="line">route -n</span><br><span class="line"><span class="comment">## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.211.55.1     0.0.0.0         UG    100    0        0 enp0s5</span><br><span class="line">10.211.55.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s5</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker_gwbridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100</span></span><br><span class="line">brctl show docker_gwbridge</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker_gwbridge         8000.0242fee3caf7       no              veth3176100</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>按理说<code>263: veth3176100@if262</code>虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 <code>ingress-sbox</code>，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的<code>/var/run/docker/netns/</code>下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/run/docker/netns/</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线</span></span><br><span class="line">1-idx465x3jg  ingress_sbox</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：<code>262: eth1@if263</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=ingress_sbox ip a</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里还有一个网络接口 <code>259: eth0@if260</code>，它又是与谁对接的呢？别着急，我们接着往下看。</p></li></ul><h3 id="ingress"><code>ingress</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查看 <code>ingress</code> 详情，其网段为 <code>10.0.0.0/24</code>，网关为 <code>10.0.0.1</code>，内部有一个容器 <code>ingress-sbox</code>，另外其有一个<code>Peers</code>属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect ingress</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ingress&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;idx465x3jg682fmceumsio297&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2025-06-08T07:29:51.734714967-04:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;swarm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;overlay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;10.0.0.0/24&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;10.0.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ingress-endpoint&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:0a:00:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;10.0.0.2/24&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.overlay.vxlanid_list&quot;</span>: <span class="string">&quot;4096&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Peers&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;4969a4611607&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.10&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ae3756658a26&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.14&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;f12309731131&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.13&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;de5000b11067&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.12&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;377001904d63&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;10.211.55.11&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>我们还是先来看这个网关<code>10.0.0.1</code>，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从<code>/var/run/docker/netns</code>中查看一下，这里还有一个名称为 <code>1-idx465x3jg</code> 的网络命名空间，我们进去看看</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.1/24 brd 10.0.0.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 8a:d3:52:ac:7d:<span class="built_in">cd</span> brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在这里我们找到了<code>2: br0</code>，其IP地址为<code>10.0.0.1</code>，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 <code>260: veth0@if259</code>，这个就是与<code>ingress_sbox</code> 中<code>259: eth0@if260</code>对应的网络接口 ，另一个是 <code>258: vxlan0@if258</code>，其基于<code>vxlan</code>协议，负责集群跨主机通信。</p></li></ul><h3 id="overlay总结">overlay总结</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker_gwbridge</code>中的容器<code>ingress-sbox</code>，其有两块网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p></li><li class="lvl-2"><p>实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p></li><li class="lvl-2"><p>当请求到达宿主机时，会通过<code>enp0s5</code>转发到<code>docker_gwbridge</code>，然后先被转到<code>ingress-sbox</code>容器，然后再经过其转发到<code>br0</code>网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过<code>vxlan0</code>网络接口转发到其它节点进行查找，中间经过一系列的网络地址转换。</p></li></ul><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/9UVZzm.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>当你通过<code>docker network create --driver overlay my-network</code>创建一个overlay网络时，Docker会创建一个类似“ingress”的网络结构(新的<code>br0</code>)，如果不指定ip段，其ip段会从<code>10.0.1.0/24</code>开始，依次递增一个网段。但会共用<code>docker_gwbridge</code>。</p></li></ul><h2 id="查看overlay网络中的负载均衡">查看overlay网络中的负载均衡</h2><ul class="lvl-0"><li class="lvl-2"><p>启动一个service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name my-nginx --replicas 5 --publish 80:80 nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看<code>ingress_sbox</code>的<code>iptables</code>数据链中的 mangle 表</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle</span><br><span class="line"><span class="comment">## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 MARK <span class="built_in">set</span> 0x105</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.0.33            MARK <span class="built_in">set</span> 0x105</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过<code>ipvsadm</code>查看负载均衡信息</p></li></ul><blockquote><p>ipvsadm 是 Linux 下管理 IPVS（IP Virtual Server）负载均衡器的命令之一</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果没有ipvsadm，则安装</span></span><br><span class="line">dnf install ipvsadm -y</span><br><span class="line"><span class="comment"># 查看ipvs信息</span></span><br><span class="line">nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln</span><br><span class="line"><span class="comment"># -L：表示列出当前 IPVS 的规则和状态（List）。</span></span><br><span class="line"><span class="comment"># -n：表示以数字方式显示地址和端口，而不进行 DNS 解析或端口名解析（即：IP 和端口号以数字显示，更直观，也更快）。</span></span><br><span class="line"><span class="comment">## 输出，可以看到 FWM 261 rr，这里rr表示轮询</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">FWM  261 rr</span><br><span class="line">  -&gt; 10.0.0.34:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.35:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.36:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.37:0                  Masq    1      0          0</span><br><span class="line">  -&gt; 10.0.0.38:0                  Masq    1      0          0</span><br><span class="line"><span class="comment">## 输出解释</span></span><br><span class="line"><span class="comment"># Prot: 协议（TCP/UDP）,这里是 FWM，表示Firewall Mark（防火墙标记）模式</span></span><br><span class="line"><span class="comment"># LocalAddress:Port: 本地地址和端口号，这里是 261 ，这是防火墙标记值（mark 值）,就是上面看到的那个16进制 0x105</span></span><br><span class="line"><span class="comment"># Scheduler: 调度算法，这里是 rr，表示轮询(round-robin)，调度算法还有 wrr（加权轮询）、lc（最少连接）等</span></span><br><span class="line"><span class="comment"># RemoteAddress:Port: 远程地址和端口号，这里是 10.0.0.34:0，表示负载均衡到的第一个节点，后面同理</span></span><br><span class="line"><span class="comment"># Forward: 转发策略，这里是 Masq，表示将负载均衡到的节点的IP地址转换成宿主机的IP地址，即 Masquerade（伪装）。转发方式（如：Masq、Tunnel、Direct Route）</span></span><br><span class="line"><span class="comment"># Weight: 权重，这里是 1，表示负载均衡到的节点的权重，默认为 1</span></span><br><span class="line"><span class="comment"># ActiveConn: 当前活动连接数，这里是 0</span></span><br><span class="line"><span class="comment"># InActConn: 当前不活动连接数（等待关闭的连接），这里是 0</span></span><br></pre></td></tr></table></figure><h2 id="VXLAN是什么？">VXLAN是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>VXLAN（Virtual Extensible LAN）是 Cisco 公司开发的一种虚拟局域网（VLAN）技术，它可以将多个 VLAN 逻辑分组，并使用单个物理网络进行管理。VXLAN 的主要作用是提高网络性能和扩展性。</p></li><li class="lvl-2"><p>它本质上是一种 网络封装协议（overlay protocol），用来在已有的 IP 网络之上，构建二层（L2）虚拟网络。</p></li></ul><h3 id="为什么需要-VXLAN？">为什么需要 VXLAN？</h3><ul class="lvl-0"><li class="lvl-2"><p>在传统数据中心或云计算中，经常有这样的需求：</p><ul class="lvl-2"><li class="lvl-6">跨不同物理网络或子网，部署在不同服务器上的虚拟机或容器，要能像在同一个二层网络里一样直接通信。</li><li class="lvl-6">VLAN（802.1Q）提供的二层隔离能力只有 12 bit VLAN ID（最多 4096 个 VLAN），在大型数据中心远远不够用。</li></ul></li><li class="lvl-2"><p>数据中心想要更好的弹性、跨区域部署、容器编排、大规模租户隔离。</p></li></ul><h3 id="VXLAN-核心原理">VXLAN 核心原理</h3><ul class="lvl-0"><li class="lvl-2"><p>VXLAN 通过封装的方式，把二层以太网帧包在 UDP 数据报里，在三层 IP 网络中传递。</p></li><li class="lvl-2"><p>封装格式大致是：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">| 外层IP头 (IP Header)    |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 外层UDP头 (UDP Header)  |</span><br><span class="line">+-------------------------+</span><br><span class="line">| VXLAN头 (VXLAN Header)  |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 内层二层帧 (Ethernet)   |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>外层 IP/UDP 用于三层传输</p></li><li class="lvl-2"><p>内层保留原本的二层以太网帧（如 MAC 地址）</p></li><li class="lvl-2"><p>VXLAN 头部里面包含了一个 VNI (VXLAN Network Identifier)：24 bit，可支持 1600万个虚拟网络</p></li><li class="lvl-2"><p>简单示意图</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VM1 (10.1.1.1) ——&gt; VTEP1 ——&gt; Underlay IP网络 ——&gt; VTEP2 ——&gt; VM2 (10.1.1.2)</span><br><span class="line"></span><br><span class="line">VTEP1 封装：</span><br><span class="line">  内层以太网帧  + VXLAN头 (VNI) + UDP + IP</span><br><span class="line"></span><br><span class="line">VTEP2 解封装：</span><br><span class="line">  去掉外层头部，还原原始二层帧</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 网络(Overlay)&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 服务(Service)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/"/>
    <id>https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/</id>
    <published>2025-06-10T13:30:05.000Z</published>
    <updated>2025-06-28T03:23:06.766Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 服务管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Service-与-Task">Service 与 Task</h2><h3 id="什么是-Service？">什么是 Service？</h3><ul class="lvl-0"><li class="lvl-2"><p>Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。</p></li><li class="lvl-2"><p>它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。</p></li><li class="lvl-2"><p>可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。</p></li></ul><h3 id="什么是-Task？">什么是 Task？</h3><ul class="lvl-0"><li class="lvl-2"><p>Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。</p></li><li class="lvl-2"><p>Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。</p></li><li class="lvl-2"><p>Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。</p></li><li class="lvl-2"><p>当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。</p></li><li class="lvl-2"><p>Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。</p></li></ul><h3 id="示例">示例</h3><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name nginx --replicas 3 nginx:latest</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。</p></li></ul><table><thead><tr><th>项目</th><th>Service</th><th>Task</th></tr></thead><tbody><tr><td>定义</td><td>用户定义的服务配置</td><td>服务配置生成的执行单元</td></tr><tr><td>数量关系</td><td>一个 Service 包含多个 Task</td><td>一个 Task 属于一个 Service</td></tr><tr><td>状态</td><td>描述“期望状态”</td><td>代表“实际状态”</td></tr><tr><td>生命周期</td><td>可以更新</td><td>不可变，更新意味着重新创建</td></tr><tr><td>管理者</td><td>由用户管理</td><td>完全由 Swarm 调度和管理</td></tr></tbody></table><h2 id="Service-相关命令">Service 相关命令</h2><table><thead><tr><th>命令</th><th>中文说明</th></tr></thead><tbody><tr><td>create</td><td>创建一个新的服务</td></tr><tr><td>inspect</td><td>显示一个或多个服务的详细信息</td></tr><tr><td>logs</td><td>获取服务或任务的日志</td></tr><tr><td>ls</td><td>列出所有服务</td></tr><tr><td>ps</td><td>列出一个或多个服务的任务（Task）</td></tr><tr><td>rm</td><td>删除一个或多个服务</td></tr><tr><td>rollback</td><td>回滚服务的配置更改</td></tr><tr><td>scale</td><td>扩缩一个或多个可复制服务的副本数量</td></tr><tr><td>update</td><td>更新服务配置</td></tr></tbody></table><h3 id="docker-service-create-创建服务"><code>docker service create</code>:  创建服务</h3><ul class="lvl-0"><li class="lvl-2"><p>常用参数说明</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例命令（含说明）</th></tr></thead><tbody><tr><td><code>--name</code></td><td>指定服务名称</td><td><code>docker service create --name my-web nginx</code><br>→ 创建一个名为 <code>my-web</code> 的 nginx 服务</td></tr><tr><td><code>--replicas</code></td><td>设置副本数量（仅适用于 replicated 模式）</td><td><code>docker service create --replicas 3 nginx</code><br>→ 启动 3 个 nginx 副本</td></tr><tr><td><code>--publish</code> 或 <code>-p</code></td><td>映射端口（格式如 <code>80:80</code>）</td><td><code>docker service create -p 8080:80 nginx</code><br>→ 将容器的 80 端口映射到主机 8080</td></tr><tr><td><code>--env</code> 或 <code>-e</code></td><td>设置环境变量</td><td><code>docker service create -e ENV=prod nginx</code><br>→ 设置环境变量 <code>ENV=prod</code></td></tr><tr><td><code>--mount</code></td><td>设置数据卷挂载</td><td><code>docker service create --mount type=bind,src=/data,target=/app nginx</code><br>→ 将主机的 <code>/data</code> 目录挂载到容器内 <code>/app</code></td></tr><tr><td><code>--constraint</code></td><td>设置部署约束（如指定节点）</td><td><code>docker service create --constraint 'node.labels.type == web' nginx</code><br>→ 仅部署在带标签 <code>type=web</code> 的节点上</td></tr><tr><td><code>--network</code></td><td>指定服务所属的网络（通常使用 overlay 网络）</td><td><code>docker service create --network my-net nginx</code><br>→ 将服务连接到自定义网络 <code>my-net</code></td></tr><tr><td><code>--detach</code> 或 <code>-d</code></td><td>后台运行服务（默认行为）</td><td><code>docker service create -d nginx</code><br>→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行</td></tr><tr><td><code>--limit-cpu</code> / <code>--limit-memory</code></td><td>设置资源限制</td><td><code>docker service create --limit-cpu 0.5 --limit-memory 256M nginx</code><br>→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存</td></tr><tr><td><code>--restart-condition</code></td><td>设置重启策略（如 on-failure、any、none）</td><td><code>docker service create --restart-condition on-failure nginx</code><br>→ 仅当容器失败时自动重启</td></tr><tr><td><code>--mode</code></td><td>指定服务运行模式，支持：<code>replicated</code>、<code>global</code>、<code>replicated-job</code>、<code>global-job</code></td><td><code>docker service create --mode global nginx</code><br>→ 在集群每个节点上运行一个 nginx 实例</td></tr></tbody></table><blockquote><p>cpu 与 内存限制</p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td><code>--limit-cpu 1.0</code></td><td>限制每个容器最多使用 1 核 CPU时间 , 1 CPU = 在每个调度周期中可占满 CPU 的全部时间份额(一个周期时间默认100ms)</td></tr><tr><td><code>--limit-cpu 0.5</code></td><td>限制每个容器最多使用 50% 的单核CPU时间</td></tr><tr><td><code>--limit-cpu 3.5</code></td><td>每个容器最多可以使用 3.5 核的 CPU 时间，由调度器决定分配。并不是限制成只能跑在一个核上，而是限制“总共使用不超过 3.5 核的时间片”。</td></tr><tr><td><code>--limit-memory 512M</code></td><td>限制每个容器最多使用指定内存（如 512M）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>服务运行模式（–mode）详解</p></li></ul><table><thead><tr><th>模式名称</th><th>说明</th><th>使用场景示例</th></tr></thead><tbody><tr><td><code>replicated</code></td><td>默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。</td><td>典型的 Web 服务，如 nginx、Node.js、Java 应用等</td></tr><tr><td><code>global</code></td><td>每个可用节点只部署一个任务实例，不需要用户指定副本数。</td><td>系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter）</td></tr><tr><td><code>replicated-job</code></td><td>在多个节点上<strong>按副本数</strong>运行一次性任务，任务完成后即退出。</td><td>数据处理、批处理任务，如转换文件或跑 ETL</td></tr><tr><td><code>global-job</code></td><td>在<strong>所有节点上各运行一次</strong>的短暂任务，执行完毕即退出。</td><td>初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等</td></tr></tbody></table><blockquote><p>job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。<br>replicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>服务重启策略（–restart-condition）详解</p></li></ul><table><thead><tr><th>值</th><th>含义说明</th></tr></thead><tbody><tr><td><code>none</code></td><td>不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。</td></tr><tr><td><code>on-failure</code></td><td><strong>仅在任务异常失败时</strong>（exit code 非 0）自动重启。常用于可能偶发失败的服务。</td></tr><tr><td><code>any</code>（默认）</td><td><strong>无论任务如何退出</strong>（包括正常退出或失败），都会尝试重启。适用于持续运行服务。</td></tr></tbody></table><blockquote><p>情景总结</p></blockquote><table><thead><tr><th>情景</th><th><code>none</code></th><th><code>on-failure</code></th><th><code>any</code></th></tr></thead><tbody><tr><td>服务运行时崩溃（exit code ≠ 0）</td><td>❌ 不重启</td><td>✅ 自动重启</td><td>✅ 自动重启</td></tr><tr><td>服务正常结束（exit code = 0）</td><td>❌ 不重启</td><td>❌ 不重启</td><td>✅ 自动重启</td></tr><tr><td>持续运行型服务（如 nginx）</td><td>❌ 不推荐</td><td>可用</td><td>✅ 推荐</td></tr><tr><td>一次性任务（如批处理、数据初始化）</td><td>✅ 推荐</td><td>可用</td><td>❌ 不推荐</td></tr></tbody></table><h4 id="docker-service-create-使用示例"><code>docker service create</code> 使用示例</h4><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --publish 80:80 \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global</span></span><br><span class="line">docker service create --name log-agent --mode global fluentd</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name web-app \</span><br><span class="line">  --<span class="built_in">env</span> NODE_ENV=production \</span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/data,target=/app/data \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  node:18 node server.js</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷</span></span><br><span class="line">docker volume create db-data</span><br><span class="line"><span class="comment"># 创建服务</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name db \</span><br><span class="line">  --constraint <span class="string">&#x27;node.labels.role == db&#x27;</span> \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=db-data,target=/var/lib/mysql \</span><br><span class="line">  mysql:8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使用 on-failure 策略，仅在失败时自动重启</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name unstable-worker \</span><br><span class="line">  --restart-condition on-failure \</span><br><span class="line">  my-worker-image</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>指定网络，网络驱动类型为 overlay</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）</span></span><br><span class="line">docker network create --driver overlay my-overlay-net</span><br><span class="line"><span class="comment"># 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务并加入该网络</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name web-service \</span><br><span class="line">  --network my-overlay-net \</span><br><span class="line">  --replicas 5 \</span><br><span class="line">  nginx</span><br><span class="line">  <span class="comment"># --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>小贴士</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class="line">6b7aadbbd180   bridge            bridge    <span class="built_in">local</span></span><br><span class="line">5ddadf5d0608   docker_gwbridge   bridge    <span class="built_in">local</span></span><br><span class="line">21c6f5b1bedd   host              host      <span class="built_in">local</span></span><br><span class="line">idx465x3jg68   ingress           overlay   swarm</span><br><span class="line">a770c5ad4b13   none              null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。</li><li class="lvl-2">但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。</li><li class="lvl-2">默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。</li><li class="lvl-2">另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发<ul class="lvl-3"><li class="lvl-4">当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。</li><li class="lvl-4">节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。</li></ul></li></ul></div><h3 id="docker-service-ls-列出所有服务"><code>docker service ls</code>: 列出所有服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span></span><br><span class="line">ID             NAME       MODE         REPLICAS   IMAGE          PORTS</span><br><span class="line">dmnztimv3pb8   my-nginx   replicated   2/2        nginx:latest   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure><h3 id="docker-service-inspect-查看服务详情"><code>docker service inspect</code>: 查看服务详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-log-查看服务日志"><code>docker service log</code>: 查看服务日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定服务下所有任务的日志</span></span><br><span class="line">docker service logs my-nginx</span><br><span class="line"><span class="comment"># 查看指定任务的日志，指定任务ID，不支持任务名称</span></span><br><span class="line">docker service logs p4tats0f9npk</span><br><span class="line"><span class="comment"># 滚动查看日志</span></span><br><span class="line">docker service logs -f my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-ps-列出服务任务"><code>docker service ps</code>: 列出服务任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 13 minutes ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 15 minutes ago</span><br></pre></td></tr></table></figure><h3 id="docker-service-scale-扩容-缩容服务"><code>docker service scale</code>: 扩容/缩容服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个服务</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --publish 80:80 \</span><br><span class="line">  nginx</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 14 seconds ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 2 minutes ago</span><br><span class="line">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running 4 seconds ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩容到5个任务</span></span><br><span class="line">docker service scale my-nginx=5</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running about a minute ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 3 minutes ago</span><br><span class="line">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">ksbeflwg3mcj   my-nginx.4   nginx:latest   worker1    Running         Running less than a second ago</span><br><span class="line">iw4zlm56n1x8   my-nginx.5   nginx:latest   manager3   Running         Running less than a second ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩容到2个人任务</span></span><br><span class="line">docker service scale my-nginx=2</span><br><span class="line"><span class="comment"># 查看服务任务</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE           ERROR     PORTS</span><br><span class="line">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 2 minutes ago</span><br><span class="line">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 4 minutes ago</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用如下命令进行扩缩容</span></span><br><span class="line">docker service update --replicas=5 my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-update-更新服务"><code>docker service update</code>: 更新服务</h3><ul class="lvl-0"><li class="lvl-2"><p>支持的参数</p></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>--image</code></td><td>更新服务使用的镜像</td><td><code>--image nginx:1.25</code></td></tr><tr><td><code>--replicas</code></td><td>设置服务的副本数量（仅适用于 replicated 模式）</td><td><code>--replicas 5</code></td></tr><tr><td><code>--env-add</code></td><td>添加环境变量</td><td><code>--env-add DEBUG=true</code></td></tr><tr><td><code>--env-rm</code></td><td>移除环境变量</td><td><code>--env-rm OLD_VAR</code></td></tr><tr><td><code>--publish-add</code></td><td>添加端口映射</td><td><code>--publish-add published=8080,target=80</code></td></tr><tr><td><code>--publish-rm</code></td><td>移除端口映射</td><td><code>--publish-rm 80</code></td></tr><tr><td><code>--mount-add</code></td><td>添加挂载</td><td><code>--mount-add type=bind,src=/data,dst=/data</code></td></tr><tr><td><code>--mount-rm</code></td><td>移除挂载</td><td><code>--mount-rm /data</code></td></tr><tr><td><code>--constraint-add</code></td><td>添加部署约束</td><td><code>--constraint-add 'node.labels.zone==east'</code></td></tr><tr><td><code>--constraint-rm</code></td><td>移除部署约束</td><td><code>--constraint-rm 'node.labels.zone==east'</code></td></tr><tr><td><code>--limit-cpu</code></td><td>设置 CPU 限制</td><td><code>--limit-cpu 0.5</code></td></tr><tr><td><code>--limit-memory</code></td><td>设置内存限制</td><td><code>--limit-memory 256M</code></td></tr><tr><td><code>--restart-condition</code></td><td>设置重启策略（none、on-failure、any）</td><td><code>--restart-condition on-failure</code></td></tr><tr><td><code>--update-delay</code></td><td>设置任务更新之间的延迟</td><td><code>--update-delay 10s</code></td></tr><tr><td><code>--update-parallelism</code></td><td>设置并发更新任务的数量</td><td><code>--update-parallelism 2</code></td></tr><tr><td><code>--update-order</code></td><td>设置更新顺序（start-first 或 stop-first）</td><td><code>--update-order start-first</code></td></tr><tr><td><code>--update-failure-action</code></td><td>更新失败后的动作（pause、continue、rollback）</td><td><code>--update-failure-action rollback</code></td></tr><tr><td><code>--rollback</code></td><td>回滚到上一次成功配置</td><td><code>--rollback</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service update \</span><br><span class="line">  --image nginx:1.25 \</span><br><span class="line">  --replicas 4 \</span><br><span class="line">  --env-add ENV=prod \</span><br><span class="line">  --limit-memory 512M \</span><br><span class="line">  --limit-cpu 1.0 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  --update-failure-action rollback \</span><br><span class="line">  my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-rollback-回滚服务"><code>docker service rollback</code>: 回滚服务</h3><ul class="lvl-0"><li class="lvl-2"><p>会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker service rollback &lt;service_name&gt;</span></span><br><span class="line">docker service rollback my-nginx</span><br></pre></td></tr></table></figure><h3 id="docker-service-rm-删除服务"><code>docker service rm</code>: 删除服务</h3><ul class="lvl-0"><li class="lvl-2"><p>删除服务会停止服务并删除服务。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker service rm &lt;service_name&gt;</span></span><br><span class="line">docker service <span class="built_in">rm</span> my-nginx</span><br></pre></td></tr></table></figure><h2 id="经验技巧">经验技巧</h2><h3 id="如何让任务运行在指定的节点上？">如何让任务运行在指定的节点上？</h3><ul class="lvl-0"><li class="lvl-2"><p>创建服务时，可以使用 <code>--constraint</code> 参数指定节点的标签，使其运行在具有指定标签的节点上。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给结点加标签</span></span><br><span class="line">docker node update --label-add <span class="built_in">env</span>=prod worker1</span><br><span class="line"></span><br><span class="line"><span class="comment"># node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=prod</span></span><br><span class="line">docker service create \</span><br><span class="line">--name my-nginx \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--constraint <span class="string">&#x27;node.labels.env == prod&#x27;</span> \</span><br><span class="line">nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>只能运行在管理节点上</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name manager-only-service \</span><br><span class="line">  --constraint <span class="string">&#x27;node.role == manager&#x27;</span> \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Swarm 内置属性</p></li></ul><table><thead><tr><th>属性名</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>node.id</code></td><td><code>node.id == abcd1234</code></td><td>节点的唯一 ID（可用 <code>docker node ls</code> 查看）</td></tr><tr><td><code>node.hostname</code></td><td><code>node.hostname == manager-1</code></td><td>节点主机名</td></tr><tr><td><code>node.role</code></td><td><code>node.role == manager</code> 或 <code>node.role == worker</code></td><td>节点在 Swarm 中的角色（管理/工作）</td></tr><tr><td><code>engine.labels.*</code></td><td><code>engine.labels.disk == ssd</code></td><td>Docker 引擎级别的标签（需手动设置）</td></tr><tr><td><code>node.platform.os</code></td><td><code>node.platform.os == linux</code></td><td>节点操作系统类型</td></tr><tr><td><code>node.platform.arch</code></td><td><code>node.platform.arch == x86_64</code></td><td>节点架构类型（如 <code>arm64</code>, <code>x86_64</code>）</td></tr></tbody></table><h3 id="如何访问Service服务？">如何访问Service服务？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostname</span></span><br><span class="line">docker service create --name <span class="built_in">whoami</span> \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  traefik/whoami</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service服务运行在哪些节点上，看到这里只有 manager1\manager2\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器ID</span></span><br><span class="line">docker service ps <span class="built_in">whoami</span></span><br><span class="line">ID             NAME       IMAGE                   NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">u1elzp22hyvm   whoami.1   traefik/whoami:latest   manager2   Running         Running 2 minutes ago</span><br><span class="line">4cent1kfgghb   whoami.2   traefik/whoami:latest   worker2    Running         Running 17 seconds ago</span><br><span class="line">lu6u6j8ji0uq   whoami.3   traefik/whoami:latest   manager1   Running         Running 40 seconds ago</span><br><span class="line"><span class="comment"># 如果希望查询某个Service的所有容器的ID，可以执行如下命令</span></span><br><span class="line">docker service ps <span class="built_in">whoami</span> -q | xargs docker inspect --format <span class="string">&#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27;</span> | <span class="built_in">cut</span> -c 1-12</span><br><span class="line">a3fb63bde8e7</span><br><span class="line">a14e30a02987</span><br><span class="line">549610f3a1e9</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 <code>curl 10.211.55.12</code>，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.211.55.12</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Hostname: a3fb63bde8e7   <span class="comment"># 容器ID</span></span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: ::1</span><br><span class="line">IP: 10.0.0.36            <span class="comment"># 容器IP，对接 br0</span></span><br><span class="line">IP: 172.18.0.4           <span class="comment"># 容器IP，对接 docker_gwbridge</span></span><br><span class="line">RemoteAddr: 10.0.0.6:52964</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 10.211.55.12</span><br><span class="line">User-Agent: curl/7.61.1</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。</p></li><li class="lvl-2"><p>可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># filename: docker_service_container</span></span><br><span class="line"><span class="comment"># 用法提示</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> &lt;SERVICE_NAME&gt;&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># service名称</span></span><br><span class="line">SERVCIE_NAME=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># 所属network,默认 ingress，这里要注意一下，如果是自定义的overlay网络，只能获取到当前主机上的容器IP</span></span><br><span class="line">NETWORK=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  NETWORK=$(docker service inspect <span class="variable">$SERVCIE_NAME</span> --format <span class="string">&#x27;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;.[0].NetworkID&#x27;</span> | sed <span class="string">&#x27;s/&quot;//g&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NETWORK=$&#123;2:-ingress&#125;</span></span><br><span class="line"></span><br><span class="line">d1=$(<span class="built_in">echo</span> -e <span class="string">&quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span> ;\</span><br><span class="line">docker service ps <span class="variable">$SERVCIE_NAME</span> --filter <span class="string">&quot;desired-state=running&quot;</span> -q | xargs docker inspect --format <span class="string">&#x27;&#123;&#123;.ServiceID&#125;&#125;    &#123;&#123;.ID&#125;&#125;    &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;    &#123;&#123;.NodeID&#125;&#125;&#x27;</span> \</span><br><span class="line">| awk <span class="string">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;$d1&quot;</span></span><br><span class="line"></span><br><span class="line">d2=$(docker service ps <span class="variable">$SERVCIE_NAME</span> --filter <span class="string">&quot;desired-state=running&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;$d2&quot;</span></span><br><span class="line"></span><br><span class="line">nn1=$(awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">NR==FNR &amp;&amp; FNR &gt; 1 &#123;</span></span><br><span class="line"><span class="string">  id = $1</span></span><br><span class="line"><span class="string">  name = $2</span></span><br><span class="line"><span class="string">  node = $4</span></span><br><span class="line"><span class="string">  desired = $5</span></span><br><span class="line"><span class="string">  # 拼接 CURRENT STATE（从第6列开始的所有字段）</span></span><br><span class="line"><span class="string">  current = &quot;&quot;</span></span><br><span class="line"><span class="string">  for (i=6; i&lt;=NF; i++) &#123;</span></span><br><span class="line"><span class="string">    current = current $i &quot; &quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  gsub(/ /, &quot;-&quot;, current)</span></span><br><span class="line"><span class="string">  current = substr(current, 1, length(current)-1)  # 去掉最后空格</span></span><br><span class="line"><span class="string">  info[id] = name &quot;\t&quot; node &quot;\t&quot; desired &quot;\t&quot; current</span></span><br><span class="line"><span class="string">  next</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">FNR==1 &#123;</span></span><br><span class="line"><span class="string">  print $0 &quot;\tTASK-NAME\tNODE\tDESIRED_STATE\tCURRENT_STATE&quot;</span></span><br><span class="line"><span class="string">  next</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  print $0 &quot;\t&quot; info[$2]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span> &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$d2</span>&quot;</span>) &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$d1</span>&quot;</span>) | <span class="built_in">tail</span> -n +2 | column -t)</span><br><span class="line"></span><br><span class="line">nn2=$(<span class="built_in">echo</span> <span class="string">&quot;CONTAINER-ID IP&quot;</span>;docker network inspect <span class="variable">$&#123;NETWORK&#125;</span> -f <span class="string">&#x27;&#123;&#123;range $id, $container := .Containers&#125;&#125;&#123;&#123;slice $id 0 12&#125;&#125; &#123;&#123;$container.Name&#125;&#125; &#123;&#123;$container.IPv4Address&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> | grep <span class="variable">$SERVCIE_NAME</span> | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&quot; &quot;$3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">NR==FNR &#123; ip[$1]=$2; next &#125;</span></span><br><span class="line"><span class="string">&#123; print $0, ip[$3] &#125;</span></span><br><span class="line"><span class="string">&#x27;</span> &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$nn2</span>&quot;</span>) &lt;(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$nn1</span>&quot;</span>) | column -t</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-swarm-service</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">docker-swarm-service <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">SERVICE-ID    TASK-ID       CONTAINER-ID  NODE-ID       TASK-NAME  NODE      DESIRED_STATE  CURRENT_STATE              IP</span><br><span class="line">snuhv0g2dm1q  czisrjrp8k2t  9e4ce349971c  kp2zerd28xgz  whoami.1   manager1  Running        Running-about-an-hour-ago  10.0.0.35/24</span><br><span class="line">snuhv0g2dm1q  tvbkwmnafedw  0d586021260d  kp2zerd28xgz  whoami.2   manager1  Running        Running-about-an-hour-ago  10.0.0.36/24</span><br><span class="line">snuhv0g2dm1q  815qp859a1f4  449d5e1a231d  kp2zerd28xgz  whoami.3   manager1  Running        Running-about-an-hour-ago  10.0.0.15/24</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 服务管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 之 节点(Node)</title>
    <link href="https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/"/>
    <id>https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/</id>
    <published>2025-06-09T13:30:05.000Z</published>
    <updated>2025-06-10T06:00:11.021Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker Swarm 的 节点管理</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/swarm/">Docker Swarm 官方文档</a></p></li></ul><span id="more"></span><h2 id="Docker-Swarm-简介">Docker Swarm 简介</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。</p></li><li class="lvl-2"><p>从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。</p></li><li class="lvl-2"><p>Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。</p></li><li class="lvl-2"><p>Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/KwTed9.png" alt=""></p></li><li class="lvl-2"><p>以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比</p></li></ul><table><thead><tr><th>特性/功能</th><th>管理节点（Manager Node）</th><th>工作节点（Worker Node）</th></tr></thead><tbody><tr><td>角色</td><td>负责集群管理和决策</td><td>执行分配的服务任务</td></tr><tr><td>是否参与服务运行</td><td>可以运行服务任务，也可以只做管理（可配置）</td><td>仅运行服务任务，不参与管理决策</td></tr><tr><td>集群状态维护</td><td>维护整个 Swarm 的状态（使用 Raft 协议）</td><td>不维护集群状态</td></tr><tr><td>调度任务</td><td>决定将服务任务分配给哪个节点</td><td>不负责调度，只执行接收到的任务</td></tr><tr><td>管理命令处理</td><td>接收并处理 Swarm 管理命令（如创建服务、扩缩容等）</td><td>不处理管理命令</td></tr><tr><td>数据一致性</td><td>需要保持一致性（至少 3 个管理节点形成高可用）</td><td>不涉及一致性</td></tr><tr><td>资源要求</td><td>相对较高，需要承担管理和协调开销</td><td>相对较低，专注于运行容器</td></tr><tr><td>可用性要求</td><td>通常配置奇数个（3、5、7…）以保障高可用</td><td>可根据需要自由扩展或缩减</td></tr><tr><td>节点加入方式</td><td>通过 manager token 加入 Swarm</td><td>通过 worker token 加入 Swarm</td></tr><tr><td>故障影响</td><td>多个管理节点故障可能影响整个 Swarm 的控制能力</td><td>部分工作节点故障通常不会影响 Swarm 的管理能力</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。</p></li><li class="lvl-2"><p>worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。</p></li><li class="lvl-2"><p>默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。</p></li><li class="lvl-2"><p>manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。</p></li></ul><h2 id="搭建Swarm集群">搭建Swarm集群</h2><ul class="lvl-0"><li class="lvl-2"><p>本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。</p></li><li class="lvl-2"><p>其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。</p></li></ul><table><thead><tr><th>IP 地址</th><th>HostName</th><th>角色类型</th></tr></thead><tbody><tr><td>10.211.55.10</td><td>manager1</td><td>管理节点</td></tr><tr><td>10.211.55.11</td><td>manager2</td><td>管理节点</td></tr><tr><td>10.211.55.12</td><td>manager3</td><td>管理节点</td></tr><tr><td>10.211.55.13</td><td>worker1</td><td>工作节点</td></tr><tr><td>10.211.55.14</td><td>worker2</td><td>工作节点</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信：</p></li></ul><table><thead><tr><th>端口号</th><th>协议</th><th>用途说明</th></tr></thead><tbody><tr><td>2377</td><td>TCP</td><td>管理器节点之间通信（管理指令和加入集群）</td></tr><tr><td>7946</td><td>TCP/UDP</td><td>节点发现和通信（集群内部发现机制）</td></tr><tr><td>4789</td><td>UDP</td><td>覆盖网络流量（VXLAN，用于容器间网络）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 Swarm 管理节点通信端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=2377/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点发现（cluster communication）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=7946/tcp</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=7946/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay 网络流量（容器间通信）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>所有主机必须时间一致</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步系统时间</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart chronyd</span><br><span class="line">chronyc tracking</span><br><span class="line"><span class="comment"># 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）</span></span><br><span class="line"><span class="comment"># 设置时区为中国上海时间（CST）</span></span><br><span class="line"><span class="built_in">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># 查看时间和时区</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure><h3 id="创建集群">创建集群</h3><ul class="lvl-0"><li class="lvl-2"><p>在 manager1 节点上执行如下命令来创建一个新的swarm集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前docker的swarm模式是否开启</span></span><br><span class="line">docker info | grep <span class="string">&quot;Swarm&quot;</span></span><br><span class="line"><span class="comment">## 输出， inactive 表示没有开启swarm集群</span></span><br><span class="line"> Swarm: inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群初始化</span></span><br><span class="line"><span class="comment"># docker swarm init --advertise-addr &lt;MANAGER-IP&gt;</span></span><br><span class="line">docker swarm init --advertise-addr 10.211.55.10</span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="comment"># --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377</span></span><br><span class="line"><span class="comment"># 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leader</span></span><br><span class="line">Swarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.</span><br><span class="line"><span class="comment"># 将一个worker node加入集群请运行下面的命令</span></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line">    <span class="comment"># 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取</span></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br><span class="line"><span class="comment"># 添加一个manager node需要执行下面的命令获取 manager token</span></span><br><span class="line">To add a manager to this swarm, run <span class="string">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看当前docker的swarm模式是否开启</span></span><br><span class="line">docker info | grep Swarm</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"> Swarm: active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点</span></span><br><span class="line">docker info --format <span class="string">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">LocalNodeState: active         <span class="comment"># 节点状态</span></span><br><span class="line">NodeID: kp2zerd28xgz5mmglnje0jp22 <span class="comment"># 节点ID</span></span><br><span class="line">NodeAddr: 10.211.55.10           <span class="comment"># 节点IP</span></span><br><span class="line">RemoteManagers: [                <span class="comment"># 节点管理节点信息</span></span><br><span class="line">  - NodeID: kp2zerd28xgz5mmglnje0jp22 <span class="comment"># 节点管理节点ID</span></span><br><span class="line">    Addr: 10.211.55.10:2377       <span class="comment"># 节点管理节点地址</span></span><br><span class="line">Nodes: 1                          <span class="comment"># 节点数量</span></span><br><span class="line">Managers: 1                       <span class="comment"># 管理节点数量</span></span><br><span class="line">ControlAvailable: <span class="literal">true</span>            <span class="comment"># 是否有控制节点</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>安装 yq 工具</strong></em></p><ul class="lvl-1"><li class="lvl-2">yq 是 yaml 的命令行处理工具，具体参考<a href="https://github.com/mikefarah/yq">yq</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 yq 最新版本</span></span><br><span class="line">VERSION=v4.45.4</span><br><span class="line">ARCH=amd64</span><br><span class="line">wget https://github.com/mikefarah/yq/releases/download/<span class="variable">$&#123;VERSION&#125;</span>/yq_linux_<span class="variable">$&#123;ARCH&#125;</span> -O /usr/local/bin/yq</span><br><span class="line"><span class="comment"># 添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/yq</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">yq --version</span><br></pre></td></tr></table></figure></div><h3 id="添加-manager-节点">添加 manager 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>获取 manager 节点的 token</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">To add a manager to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将 manager2 和 manager3 加入 swarm 集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别在 manager2 和 manager3 上运行如下命令，</span></span><br><span class="line">docker swarm <span class="built_in">join</span> \</span><br><span class="line">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \</span><br><span class="line">10.211.55.10:2377</span><br><span class="line"><span class="comment">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><h3 id="添加-worker-节点">添加 worker 节点</h3><ul class="lvl-0"><li class="lvl-2"><p>获取 worker 节点的 token</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm <span class="built_in">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将 worker1 和 worker2 加入 swarm 集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别在 worker1 和 worker2 上运行如下命令，</span></span><br><span class="line">docker swarm <span class="built_in">join</span> \</span><br><span class="line">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \</span><br><span class="line">10.211.55.10:2377</span><br><span class="line"><span class="comment">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><h3 id="查看集群状态">查看集群状态</h3><ul class="lvl-0"><li class="lvl-2"><p>在 manager1 上执行如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker info --format <span class="string">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">LocalNodeState: active</span><br><span class="line">NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class="line">NodeAddr: 10.211.55.10</span><br><span class="line">RemoteManagers:</span><br><span class="line">  - NodeID: oymi74epagdqeprah7s81tsa2</span><br><span class="line">    Addr: 10.211.55.11:2377</span><br><span class="line">  - NodeID: r7388xl84nczjtnf53pwh7hla</span><br><span class="line">    Addr: 10.211.55.12:2377</span><br><span class="line">  - NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class="line">    Addr: 10.211.55.10:2377</span><br><span class="line">Nodes: 5</span><br><span class="line">Managers: 3</span><br><span class="line">ControlAvailable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="查看集群内节点信息">查看集群内节点信息</h3><ul class="lvl-0"><li class="lvl-2"><p>在 任意 manager 节点上运行如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">lsxj50x8ftqw8etvz5y37xc5q     worker2    Ready     Active                          26.1.3</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段名</th><th>示例值</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>ID</strong></td><td><code>kp2zerd28xgz5mmglnje0jp22</code></td><td>节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符）</td></tr><tr><td><strong>HOSTNAME</strong></td><td><code>manager1</code></td><td>节点的主机名（即加入 swarm 集群时该节点的 <code>hostname</code>）</td></tr><tr><td><strong>STATUS</strong></td><td><code>Ready</code></td><td>节点的状态：<br>• <code>Ready</code>：节点正常运行中<br>• <code>Down</code>：节点离线或无法通信<br>• <code>Paused</code>：暂停<br>• <code>Drain</code>：排空，正在迁移任务</td></tr><tr><td><strong>AVAILABILITY</strong></td><td><code>Active</code></td><td>节点的可用性设置：<br>• <code>Active</code>：节点可以调度任务（默认）<br>• <code>Pause</code>：暂停调度新任务<br>• <code>Drain</code>：迁移任务并不再调度</td></tr><tr><td><strong>MANAGER STATUS</strong></td><td><code>Leader</code> / <code>Reachable</code> / 空</td><td>仅适用于管理节点：<br>• <code>Leader</code>：当前 swarm 的主节点（负责协调）<br>• <code>Reachable</code>：集群中可通信的管理节点<br>• 空：表示这是一个工作节点（非管理节点）</td></tr><tr><td><strong>ENGINE VERSION</strong></td><td><code>26.1.3</code></td><td>Docker 引擎的版本号（即该节点上运行的 Docker 版本）</td></tr></tbody></table><h2 id="docker-swarm集群管理"><code>docker swarm</code>集群管理</h2><table><thead><tr><th>命令</th><th>中文含义</th></tr></thead><tbody><tr><td><code>ca</code></td><td>显示和轮换 Swarm 的根证书（CA）</td></tr><tr><td><code>init</code></td><td>初始化一个新的 Swarm 集群</td></tr><tr><td><code>join</code></td><td>将当前节点加入到 Swarm 中，作为工作节点或管理节点</td></tr><tr><td><code>join-token</code></td><td>管理用于加入 Swarm 的令牌（查看或重新生成）</td></tr><tr><td><code>leave</code></td><td>当前节点离开 Swarm 集群</td></tr><tr><td><code>unlock</code></td><td>解锁被加密的 Swarm（用于恢复 Manager 节点）</td></tr><tr><td><code>unlock-key</code></td><td>管理 Swarm 的解锁密钥（查看、备份等）</td></tr><tr><td><code>update</code></td><td>更新 Swarm 集群的全局配置（如加密、日志等）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm init</code>: 初始化 Swarm 集群（只在首次创建时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 10.211.55.10</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm join-token</code>:  生成加入集群的令牌</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 worker 节点的令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"><span class="comment"># 生成 manager 节点的令牌</span></span><br><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm join</code>: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span> --token &lt;token&gt; 10.211.55.10:2377</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm leave</code>: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker 节点离开集群</span></span><br><span class="line">docker swarm leave</span><br><span class="line"><span class="comment"># manager 节点必须先降级为 worker节点，或者加上 --force 强制离开</span></span><br><span class="line">docker swarm leave --force</span><br><span class="line"><span class="comment"># 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点</span></span><br><span class="line"><span class="comment"># 集群中至少需要一个Manager节点，否则无法运行服务</span></span><br><span class="line"><span class="comment"># 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 down</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">lsxj50x8ftqw8etvz5y37xc5q     worker2    Down      Active                          26.1.3</span><br><span class="line"><span class="comment"># 如需彻底删除需要运行</span></span><br><span class="line">docker node <span class="built_in">rm</span> worker2</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm update</code>: 更新 Swarm 集群配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看</span></span><br><span class="line">docker swarm update --autolock=<span class="literal">true</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Swarm updated.</span><br><span class="line">To unlock a swarm manager after it restarts, run the `docker swarm unlock`</span><br><span class="line"><span class="built_in">command</span> and provide the following key:</span><br><span class="line"></span><br><span class="line">    SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4</span><br><span class="line"></span><br><span class="line">Please remember to store this key <span class="keyword">in</span> a password manager, since without it you</span><br><span class="line">will not be able to restart the manager.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swarm集群锁定</span></span><br><span class="line">docker swarm update --autolock=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm unlock-key</code>: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取Swarm集群的解锁密钥</span></span><br><span class="line">docker swarm unlock-key</span><br><span class="line"><span class="comment"># 轮换Swarm集群的解锁密钥</span></span><br><span class="line">docker swarm unlock-key --rotate</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm unlock</code>: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class="string">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class="line"><span class="comment"># 需要先解锁才可以运行节点管理命令</span></span><br><span class="line">docker swarm unlock</span><br><span class="line"><span class="comment">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class="line">Please enter unlock key:</span><br></pre></td></tr></table></figure><h2 id="docker-node节点管理"><code>docker node</code>节点管理</h2><ul class="lvl-0"><li class="lvl-2"><p>节点管理相关命令，只能在 管理节点 上执行</p></li></ul><table><thead><tr><th>命令</th><th>中文含义</th></tr></thead><tbody><tr><td><code>demote</code></td><td>将一个或多个管理节点降级为工作节点</td></tr><tr><td><code>inspect</code></td><td>显示一个或多个节点的详细信息</td></tr><tr><td><code>ls</code></td><td>列出 swarm 集群中的所有节点</td></tr><tr><td><code>promote</code></td><td>将一个或多个工作节点提升为管理节点</td></tr><tr><td><code>ps</code></td><td>查看一个或多个节点上正在运行的任务（默认当前节点）</td></tr><tr><td><code>rm</code></td><td>从 swarm 集群中移除一个或多个节点</td></tr><tr><td><code>update</code></td><td>更新节点的元数据（如标签、可用性等）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><code>docker node ls</code>: 列出 swarm 集群中的所有节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node inspect &lt;node_id&gt;/&lt;hostname&gt;</code>: 查看指定节点的详细信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node inspect --pretty manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;</code>: 更新节点的元数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置节点为不可用</span></span><br><span class="line">docker node update --availability drain manager1</span><br><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">docker node update --label-add foo=bar manager1</span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">docker node update --label-rm foo manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node demote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将管理节点降级为工作节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker note promote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将工作节点升级为管理节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node promote worker1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker node rm &lt;node_id&gt;/&lt;hostname&gt;</code>: 从 swarm 集群中移除一个节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">rm</span> manager1</span><br></pre></td></tr></table></figure><h2 id="节点管理常见情况">节点管理常见情况</h2><h3 id="如何正确的删除一个节点">如何正确的删除一个节点</h3><ul class="lvl-0"><li class="lvl-2"><p>1.如果是 manager 节点，先将 manager 节点降级为 worker 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote manager1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.退出集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在要退出集群的节点上执行</span></span><br><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.删除节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">rm</span> manager1</span><br></pre></td></tr></table></figure><h3 id="节点被退群或删除后，其上运行的service会怎样？">节点被退群或删除后，其上运行的service会怎样？</h3><ul class="lvl-0"><li class="lvl-2"><p>用一个示例来说明，先在 manager1 节点上创建一个 service</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  --replicas 10 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看service状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出结果，可以看到每个节点上都启动了2个nginx容器</span></span><br><span class="line">ID             NAME          IMAGE          NODE       DESIRED STATE   CURRENT STATE                ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">t9agioefr316   my-nginx.2    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">moitlj50nunh   my-nginx.3    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4    nginx:latest   manager1   Running         Running about a minute ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class="line">i6mieuodbrtg   my-nginx.6    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">2yohffzzsrrl   my-nginx.7    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class="line">f3lusxoflqn2   my-nginx.8    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class="line">xovzfmzsjlet   my-nginx.9    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10   nginx:latest   manager1   Running         Running about a minute ago</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这时将 worker2 从集群中退群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在worker2节点执行</span></span><br><span class="line">docker swarm leave</span><br><span class="line"><span class="comment"># 在manager节点查看集群节点</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class="line">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再次查看service状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment"># 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class="line">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class="line">t9agioefr316   my-nginx.2       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class="line">moitlj50nunh   my-nginx.3       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4       nginx:latest   manager1   Running         Running 6 minutes ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class="line">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2   Running         Running 43 seconds ago</span><br><span class="line">i6mieuodbrtg    \_ my-nginx.6   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class="line">2yohffzzsrrl   my-nginx.7       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class="line">34km8mzg3xat   my-nginx.8       nginx:latest   manager3   Running         Running 43 seconds ago</span><br><span class="line">f3lusxoflqn2    \_ my-nginx.8   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class="line">xovzfmzsjlet   my-nginx.9       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1   Running         Running 6 minutes ago</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果不退群直接删除节点呢？这次我们直接删除 worker1 节点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 worker1 节点</span></span><br><span class="line">docker node <span class="built_in">rm</span> worker1</span><br><span class="line"><span class="comment"># 输出，提示 worker1 节点不是 down 状态，不能删除</span></span><br><span class="line"><span class="comment"># Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着我们强制删除</span></span><br><span class="line">docker node <span class="built_in">rm</span> -f worker1</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 输出，可以看到worker1节点已经删除了</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class="line">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看service状态</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line">ID             NAME             IMAGE          NODE                        DESIRED STATE   CURRENT STATE                 ERROR     PORTS</span><br><span class="line">fciheo523fb3   my-nginx.1       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class="line">t9agioefr316   my-nginx.2       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class="line">moitlj50nunh   my-nginx.3       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class="line">x07voc2qth5q   my-nginx.4       nginx:latest   manager1                    Running         Running 12 minutes ago</span><br><span class="line">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class="line">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2                    Running         Running 6 minutes ago</span><br><span class="line">i6mieuodbrtg    \_ my-nginx.6   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class="line">3t4qvpvrzpg3   my-nginx.7       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class="line">2yohffzzsrrl    \_ my-nginx.7   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class="line">34km8mzg3xat   my-nginx.8       nginx:latest   manager3                    Running         Running 6 minutes ago</span><br><span class="line">f3lusxoflqn2    \_ my-nginx.8   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class="line">4w5zfpfye3t8   my-nginx.9       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class="line">xovzfmzsjlet    \_ my-nginx.9   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class="line">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1                    Running         Running 12 minutes ago</span><br></pre></td></tr></table></figure><h3 id="节点被退群或删除后是否可以重新加入集群">节点被退群或删除后是否可以重新加入集群</h3><ul class="lvl-0"><li class="lvl-2"><p>节点被退群或删除后，可以通过 <code>docker swarm join</code> 命令重新加入集群</p></li><li class="lvl-2"><p>若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 <code>docker swarm leave</code> 命令退群后再加入集群</p></li></ul><h3 id="如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法">如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里重启一个manager节点的docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看节点列表</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class="string">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class="line"><span class="comment"># 需要先解锁才可以运行节点管理命令</span></span><br><span class="line">docker swarm unlock</span><br><span class="line"><span class="comment">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class="line">Please enter unlock key:</span><br><span class="line"><span class="comment">## 如果忘记了密钥，可以在其它manager节点通过如下命令查看</span></span><br><span class="line">docker swarm unlock-key</span><br><span class="line"><span class="comment"># 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了</span></span><br></pre></td></tr></table></figure><h3 id="Swarm-集群锁定功能的作用及使用场景">Swarm 集群锁定功能的作用及使用场景</h3><ul class="lvl-0"><li class="lvl-2"><p>作用</p></li></ul><table><thead><tr><th>✅ 作用</th><th>📋 说明</th></tr></thead><tbody><tr><td>加密保护管理密钥</td><td>管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。</td></tr><tr><td>防止节点被非法重启后加入集群</td><td>如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>场景</p></li></ul><table><thead><tr><th>场景类型</th><th>具体描述</th></tr></thead><tbody><tr><td>✅ 适合场景</td><td>对安全性要求高的生产环境</td></tr><tr><td></td><td>部署在不可信或共享物理环境中</td></tr><tr><td></td><td>云服务器、数据中心有专人运维管理解锁过程</td></tr><tr><td></td><td>希望防止物理/远程入侵者恢复管理器角色的公司</td></tr><tr><td>❌ 不适合场景</td><td>需要自动化部署或重启的 CI/CD 系统</td></tr><tr><td></td><td>测试环境或开发集群</td></tr><tr><td></td><td>无人值守、要求高可用自动恢复的部署系统</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>总结</p></li></ul><table><thead><tr><th>项目</th><th>是否推荐</th></tr></thead><tbody><tr><td>安全性</td><td>✅ 强烈推荐启用（尤其在生产环境）</td></tr><tr><td>自动化</td><td>❌ 不推荐（增加人工干预步骤）</td></tr><tr><td>解锁方式</td><td>解锁命令 + unlock key</td></tr><tr><td>unlock key 丢失后果</td><td>可能需要重建 Swarm（除非提前备份）</td></tr></tbody></table><h3 id="docker-swarm-ca-是做什么用的？"><code>docker swarm ca</code> 是做什么用的？</h3><ul class="lvl-0"><li class="lvl-2"><p><code>docker swarm ca</code> 命令是用来 <strong>管理 Swarm 集群中的根证书颁发机构（CA）</strong> 的工具。具体功能包括：</p></li></ul><table><thead><tr><th>子命令/参数</th><th>说明</th></tr></thead><tbody><tr><td><code>docker swarm ca</code></td><td>查看当前 Swarm 的根 CA 公钥（PEM 格式）</td></tr><tr><td><code>docker swarm ca --rotate</code></td><td>轮换根 CA，用于安全更新</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Swarm 中的证书是干什么用的？</p></li></ul><table><thead><tr><th>用途</th><th>说明</th></tr></thead><tbody><tr><td>✅ 节点身份验证</td><td>每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。</td></tr><tr><td>🔐 通信加密</td><td>节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。</td></tr><tr><td>🔄 自动轮换</td><td>Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/swarm/certificates</span><br><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── swarm-node.crt      <span class="comment"># 节点证书</span></span><br><span class="line">├── swarm-node.key      <span class="comment"># 节点密钥</span></span><br><span class="line">└── swarm-root-ca.crt   <span class="comment"># 根CA证书</span></span><br></pre></td></tr></table></figure><h3 id="只让-Manager-做管理，不运行服务">只让 Manager 做管理，不运行服务</h3><ul class="lvl-0"><li class="lvl-2"><p>节点的<code>AVAILABILITY</code>有三种：<code>active</code>、<code>pause</code>、<code>drain</code>。</p></li></ul><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>active</code></td><td>可调度，Swarm 可以在此节点上运行服务任务（默认）</td></tr><tr><td><code>pause</code></td><td>暂停调度，不会分配新任务，但保留已有任务</td></tr><tr><td><code>drain</code></td><td>排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 manager1 节点为“不可调度”，即 排空模式</span></span><br><span class="line">docker node update --availability drain manager1</span><br><span class="line"><span class="comment"># 查看节点状态</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，manager1 节点状态变为 排空</span></span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Drain          Reachable        26.1.3</span><br><span class="line">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class="line">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Leader           26.1.3</span><br><span class="line">xkww4853bbdgv7bv8771xibob     worker1    Ready     Active                          26.1.3</span><br><span class="line">hvzkh3ip5ef8gx973z1ywahbu     worker2    Ready     Active                          26.1.3</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">docker service ps my-nginx</span><br><span class="line"><span class="comment">## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。</span></span><br><span class="line">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class="line">23m03nj54mzo   my-nginx.1       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class="line">9xi83bnh4fus   my-nginx.2       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class="line">wos8tbk449lk   my-nginx.3       nginx:latest   manager2   Running         Running 28 seconds ago</span><br><span class="line">uosmuh6bvwm0    \_ my-nginx.3   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class="line">yeqhqc3f735y   my-nginx.4       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">g8rduix7s74v   my-nginx.5       nginx:latest   worker2    Running         Running less than a second ago</span><br><span class="line">wuxilgpv9f50    \_ my-nginx.5   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class="line">3bxtn9boit28   my-nginx.6       nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class="line">57kdggaf8sag   my-nginx.7       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class="line">uugi506p74s8   my-nginx.8       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class="line">yifwpqjnts9l   my-nginx.9       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class="line">yv4p6su7aom5   my-nginx.10      nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复运行任务能力</span></span><br><span class="line">docker node update --availability active manager1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止接收新的任务但保留运行中的任务</span></span><br><span class="line">docker node update --availability pause manager1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker Swarm 的 节点管理&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 命令 之 Dockerfile 多平台构建</title>
    <link href="https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/"/>
    <id>https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/</id>
    <published>2025-06-06T13:30:05.000Z</published>
    <updated>2025-06-07T11:32:29.230Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile官方文档</a></p></li><li class="lvl-2"><p><a href="https://docs.docker.com/build/building/multi-platform/">Multi-platform builds</a></p></li></ul><span id="more"></span><h2 id="什么是Dockerfile-多平台构建？">什么是Dockerfile 多平台构建？</h2><ul class="lvl-0"><li class="lvl-2"><p>Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。</p></li><li class="lvl-2"><p>在没有安装 <code>docker-buildx-plugin</code> 的情况下，<code>docker build</code> 命令是不支持使用 <code>--platform</code> 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。</p></li><li class="lvl-2"><p>要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。</p></li><li class="lvl-2"><p><code>docker-buildx-plugin</code> 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 <code>docker build</code> 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。</p></li></ul><h2 id="安装-docker-buildx-plugin">安装 docker-buildx-plugin</h2><ul class="lvl-0"><li class="lvl-2"><p>随docker服务一起安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>单独安装</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install docker-buildx-plugin</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看版本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx version</span><br></pre></td></tr></table></figure><h2 id="docker-buildx-基本命令"><code>docker buildx</code> 基本命令</h2><ul class="lvl-0"><li class="lvl-2"><p>以下命令在后面的示例中都有使用</p></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker buildx create</code></td><td>创建一个新的构建器实例</td></tr><tr><td><code>docker buildx use</code></td><td>设置当前使用的构建器</td></tr><tr><td><code>docker buildx inspect</code></td><td>查看构建器状态和支持的平台</td></tr><tr><td><code>docker buildx build</code></td><td>构建镜像（增强版），等同于 <code>docker build</code></td></tr><tr><td><code>docker buildx ls</code></td><td>列出所有构建器</td></tr><tr><td><code>docker buildx rm</code></td><td>删除构建器</td></tr><tr><td><code>docker buildx du</code></td><td>查看构建器使用的磁盘空间</td></tr><tr><td><code>docker buildx prune</code></td><td>删除构建过程中产生的缓存</td></tr><tr><td><code>docker buildx version</code></td><td>查看 Docker Buildx 的版本信息</td></tr></tbody></table><h2 id="要让Docker支持多平台构建，需要满足以下几个条件：">要让Docker支持多平台构建，需要满足以下几个条件：</h2><ul class="lvl-0"><li class="lvl-2"><p>Linux内核开启多处理器架构支持</p></li><li class="lvl-2"><p>构建时使用基于<code>docker-container</code>驱动的Buildx实例</p></li><li class="lvl-2"><p>使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>–platform</code>参数</p></li></ul><h2 id="Linux内核开启多处理器架构支持">Linux内核开启多处理器架构支持</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">default          docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启多处理器架构支持</span></span><br><span class="line">docker run --privileged --<span class="built_in">rm</span> tonistiigi/binfmt --install all</span><br><span class="line"><span class="comment"># 这个镜像用完就可以删除了</span></span><br><span class="line">docker rmi tonistiigi/binfmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次列出所有构建器</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出，此时可以看到PLATFORMS中有多个平台</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">default*         docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br></pre></td></tr></table></figure><h2 id="构建时使用基于docker-container驱动的Buildx实例">构建时使用基于<code>docker-container</code>驱动的Buildx实例</h2><ul class="lvl-0"><li class="lvl-2"><p>Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。</p></li><li class="lvl-2"><p>多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前默认的构建器default</span></span><br><span class="line">docker buildx inspect default</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Name:          default</span><br><span class="line">Driver:        docker</span><br><span class="line">Last Activity: 2025-06-06 07:42:42 +0000 UTC</span><br><span class="line"></span><br><span class="line">Nodes:</span><br><span class="line">Name:             default</span><br><span class="line">Endpoint:         default</span><br><span class="line">Status:           running</span><br><span class="line">BuildKit version: v0.13.2</span><br><span class="line">Platforms:        linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line">Labels:</span><br><span class="line"> org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建基于 <code>docker-container</code> 驱动的Buildx实例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并切换到名为mybuilder的构建器实例</span></span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container</span><br><span class="line"><span class="comment"># 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了</span></span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">Name:          mybuilder</span><br><span class="line">Driver:        docker-container</span><br><span class="line">……………………………………</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除</span></span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID   IMAGE                           COMMAND                   CREATED             STATUS                       PORTS                    NAMES</span><br><span class="line">0ab9cab9ec9b   moby/buildkit:buildx-stable-1   <span class="string">&quot;buildkitd --allow-i…&quot;</span>   About an hour ago   Up About an hour                                      buildx_buildkit_mybuilder0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>buildx_buildkit_xxx</code>这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为<code>moby/buildkit:buildx-stable-1</code>，容器会在执行<code>docker buildx build</code> 或 <code>docker buildx inspect --bootstrap</code> 时启动</p></li></ul><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>👷 执行构建任务</td><td>真正执行 <code>buildx build</code> 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等</td></tr><tr><td>📦 拉取镜像</td><td>拉取 <code>Dockerfile</code> 中的基础镜像</td></tr><tr><td>📤 上传/导出镜像</td><td>支持导出为 <code>docker image</code>, <code>tar</code>, 推送到远程 registry</td></tr><tr><td>🪣 管理缓存</td><td>管理构建缓存（中间镜像、层等）以加速后续构建</td></tr><tr><td>🌍 支持多平台</td><td>通过 QEMU 或交叉编译器支持跨平台（如构建 <code>arm64</code> 镜像）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在<code>/etc/docker/daemon.json</code>中配置了国内的镜像源也不行，这是因为<code>docker buildx</code> 使用的是 BuildKit，它的行为不同于传统的 <code>docker build</code></p></li></ul><table><thead><tr><th>特性</th><th><code>docker build</code>（传统）</th><th><code>docker buildx</code>（BuildKit）</th></tr></thead><tbody><tr><td>是否使用本地镜像缓存</td><td>✅ 是</td><td>⚠️ <strong>不是</strong></td></tr><tr><td>是否需要联网拉取元数据（即使镜像已存在）</td><td>否</td><td>是</td></tr><tr><td>构建网络隔离</td><td>不隔离</td><td>隔离构建，无法直接访问宿主镜像缓存</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>解决方法为构建器配置镜像源</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 BuildKit 配置文件 buildkitd.toml</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; buildkitd.toml</span></span><br><span class="line"><span class="string">[registry.&quot;docker.io&quot;]</span></span><br><span class="line"><span class="string">  mirrors = [&quot;https://docker.1ms.run&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[worker.oci]</span></span><br><span class="line"><span class="string">  gc = true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 BuildKit 构建器，并指定配置文件</span></span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果存在同名的构建器，则删除它后再创建</span></span><br><span class="line">docker buildx <span class="built_in">rm</span> mybuilder</span><br><span class="line">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构建器列表</span></span><br><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class="line">mybuilder*       docker-container</span><br><span class="line"> \_ mybuilder0    \_ unix:///var/run/docker.sock   running   v0.21.1    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line">default          docker</span><br><span class="line"> \_ default       \_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要切换回默认的构建器，请执行以下命令</span></span><br><span class="line">docker buildx use default</span><br></pre></td></tr></table></figure><h2 id="使用docker-buildx-build命令构建镜像，构建命令必须指定-platform参数">使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>--platform</code>参数</h2><h3 id="示例一：单阶段构建">示例一：单阶段构建</h3><ul class="lvl-0"><li class="lvl-2"><p>我们依旧以一个springboot项目为例，其Dockerfile如下：</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像元信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;yourname@example.com&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>开始构建镜像，<code>docker buildx build == docker build</code>，构建多平台架构时需要使用<code>--platform</code>指定构建平台</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --platform inux/arm64 :构建arm64镜像</span></span><br><span class="line"><span class="comment"># -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest</span></span><br><span class="line"><span class="comment"># --load :构建后加载到本地</span></span><br><span class="line"><span class="comment"># . :当前目录查找Dockerfile文件</span></span><br><span class="line"><span class="comment"># -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称</span></span><br><span class="line">docker buildx build --platform linux/arm64 -t <span class="string">&quot;app.arm64&quot;</span> --load .</span><br><span class="line"><span class="comment">## 此时会遇到如下错误</span></span><br><span class="line">ERROR: failed to solve: openjdk:17-alpine: failed to resolve <span class="built_in">source</span> metadata <span class="keyword">for</span> docker.io/library/openjdk:17-alpine: no match <span class="keyword">for</span> platform <span class="keyword">in</span> manifest: not found</span><br><span class="line"><span class="comment">## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询镜像支持的平台，不过国内依旧是不支持</span></span><br><span class="line">docker buildx imagetools inspect nginx:latest |  grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment"># 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/nginx:latest |  grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">  Platform:    linux/386</span><br><span class="line">  Platform:    linux/amd64</span><br><span class="line">  Platform:    linux/arm64/v8</span><br><span class="line">  Platform:    linux/arm/v5</span><br><span class="line">  Platform:    linux/arm/v7</span><br><span class="line">  Platform:    linux/mips64le</span><br><span class="line">  Platform:    linux/ppc64le</span><br><span class="line">  Platform:    linux/s390x</span><br><span class="line">  Platform:    unknown/unknown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着我们查看openjdk:17-alpine这个镜像</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果，其确实不支持 linux/arm64</span></span><br><span class="line">  Platform:  linux/amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们换一个openjdk镜像试试</span></span><br><span class="line">docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment">## 输出结果，可以看到这个镜像同时支持amd64和arm64架构</span></span><br><span class="line">  Platform:  linux/amd64</span><br><span class="line">  Platform:  linux/arm64/v8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用skopeo容器的方式进行查询</span></span><br><span class="line">docker run --<span class="built_in">rm</span> quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r <span class="string">&#x27;.manifests[].platform | &quot;\(.os)/\(.architecture)/\(.variant)&quot;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | sed <span class="string">&#x27;s/\/null//&#x27;</span></span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">linux/amd64</span><br><span class="line">linux/arm64/v8</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>替换支持多架构的镜像后重新构建镜像就会成功</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/arm64 -t <span class="string">&quot;app.arm64&quot;</span> --load .</span><br><span class="line">docker buildx build --platform linux/amd64 -t <span class="string">&quot;app.amd64&quot;</span> --load .</span><br><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class="line">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class="line">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构建后镜像的架构</span></span><br><span class="line">docker inspect app.amd64 | jq <span class="string">&#x27;.[0].Architecture&#x27;</span></span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以将构建后的镜像输出到本地目录</span></span><br><span class="line">docker buildx build --platform linux/amd64 -t <span class="string">&quot;app.amd64&quot;</span> --output <span class="built_in">type</span>=docker,dest=./app.amd64.tar .</span><br><span class="line"><span class="comment"># 然后再将镜像导入到本地镜像仓库中</span></span><br><span class="line">docker load -i app.amd64.tar</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>--load</code>和 <code>--output</code>都不支持一个镜像多种架构，要构建像<code>openjdk:17-slim</code>这种支持多架构的镜像可以使用<code>--push</code>，一步就推送到远程仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。</span></span><br><span class="line"><span class="comment"># 这里以推送到 docker hub 为例</span></span><br><span class="line"><span class="comment"># 登录 docker hup</span></span><br><span class="line">docker login -u hanqunfeng</span><br><span class="line"><span class="comment"># 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构</span></span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push .</span><br></pre></td></tr></table></figure><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/WdmJx0.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>镜像拉取</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像</span></span><br><span class="line">docker pull --platform=linux/arm64 hanqunfeng/app:latest</span><br></pre></td></tr></table></figure><h3 id="示例二：多阶段构建">示例二：多阶段构建</h3><ul class="lvl-0"><li class="lvl-2"><p>要求每个阶段中的基础镜像都要支持多架构</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：获取代码</span></span><br><span class="line"><span class="keyword">FROM</span> alpine/git AS fetcher</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class="line"><span class="keyword">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class="line"><span class="keyword">ARG</span> GIT_BRANCH=master</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> -b <span class="variable">$&#123;GIT_BRANCH&#125;</span> <span class="variable">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：使用Maven环境进行构建</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.8</span>.<span class="number">4</span>-openjdk-<span class="number">17</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace/application</span></span><br><span class="line"><span class="comment"># 从第一阶段复制代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=fetcher /workspace/application .</span></span><br><span class="line"><span class="comment"># 使用Maven清理并打包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三阶段：创建最终的运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 设置运行时环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class="line"><span class="comment"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class="line"><span class="comment"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/app/logs&quot;</span>]</span></span><br><span class="line"><span class="comment"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class="line"><span class="comment"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--spring.profiles.active=app&quot;</span>, <span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class="line"><span class="comment"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多平台镜像并发布到dockerhub</span></span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push .</span><br></pre></td></tr></table></figure><h2 id="如何将构建好的多个单平台镜像发布为一个多平台镜像">如何将构建好的多个单平台镜像发布为一个多平台镜像</h2><ul class="lvl-0"><li class="lvl-2"><p>如果你已经分别构建好单平台镜像，也可以用 <code>docker buildx imagetools create</code> 来合并</p></li><li class="lvl-2"><p>以上面创建的两个单平台镜像为例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class="line">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class="line">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定要推送单平台镜像到远程仓库，否则无法完成合并</span></span><br><span class="line">docker tag app.amd64 hanqunfeng/app:amd64</span><br><span class="line">docker push hanqunfeng/app:amd64</span><br><span class="line"></span><br><span class="line">docker tag app.arm64 hanqunfeng/app:arm64</span><br><span class="line">docker push hanqunfeng/app:arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并，创建多平台镜像指向（manifest list）</span></span><br><span class="line">docker buildx imagetools create \</span><br><span class="line">  --tag hanqunfeng/app:latest \</span><br><span class="line">   hanqunfeng/app:amd64 \</span><br><span class="line">   hanqunfeng/app:arm64</span><br></pre></td></tr></table></figure><p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/5azhzj.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>如果不需要单平台镜像，可以在dockerhub上删除即可。</p></li></ul><h2 id="移除-BuildKit（Buildx）构建过程中产生的缓存数据">移除 BuildKit（Buildx）构建过程中产生的缓存数据</h2><ul class="lvl-0"><li class="lvl-2"><p>BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。</p></li><li class="lvl-2"><p>可以通过该命令查看缓存占用磁盘空间的大小</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx <span class="built_in">du</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker buildx prune</code> 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。</p></li><li class="lvl-2"><p>命令语法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx prune [OPTIONS]</span><br></pre></td></tr></table></figure><table><thead><tr><th>OPTIONS</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code>, <code>--all</code></td><td><strong>包括内部/前端镜像</strong>。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。</td></tr><tr><td><code>--builder string</code></td><td>指定使用哪个 builder 实例（可通过 <code>docker buildx ls</code> 查看当前有哪些 builder）。</td></tr><tr><td><code>--filter filter</code></td><td>设定清理条件，例如：<code>until=24h</code> 表示只删除 24 小时前的缓存。</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td><strong>不提示确认，直接执行清理操作</strong>。常用于脚本中。</td></tr><tr><td><code>--keep-storage bytes</code></td><td>保留指定大小的缓存空间，其余删除（如：<code>--keep-storage 5GB</code>）。</td></tr><tr><td><code>--verbose</code></td><td>输出更详细的清理信息。</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未使用的缓存，并跳过确认提示</span></span><br><span class="line">docker buildx prune -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只删除 24 小时前的缓存，保留 10GB 的缓存空间</span></span><br><span class="line">docker buildx prune --filter <span class="string">&quot;until=24h&quot;</span> --keep-storage 10GB</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/build/building/multi-platform/&quot;&gt;Multi-platform builds&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 之 远程连接</title>
    <link href="https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/"/>
    <id>https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/</id>
    <published>2025-06-05T13:30:05.000Z</published>
    <updated>2025-06-06T06:03:47.970Z</updated>
    
    <content type="html"><![CDATA[<!-- **加粗** *斜体* ***加粗并斜体*** ~~删除线~~ ==突出显示== `突出显示(推荐)` ++下划线++ ~下标~ ^上标^ 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference. 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600) +++ **点击折叠** 这是被隐藏的内容 +++::: tips success warning danger这里是容器内的内容:::% note info % success warning danger这里是容器内的内容% endnote %引用本地其它文章连接{} 大括号开始% post_link 文件名称(不包含.md) %大括号结束 --><h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2"><p>本文介绍如何远程连接Docker</p></li><li class="lvl-2"><p><a href="https://docs.docker.com">Docker官方文档</a></p></li></ul><span id="more"></span><h2 id="远程连接Docker有如下三种方式">远程连接Docker有如下三种方式</h2><h3 id="方式一：开启-TCP（不带-TLS，仅用于内网调试）">方式一：开启 TCP（不带 TLS，仅用于内网调试）</h3><ul class="lvl-0"><li class="lvl-2"><p>在docker服务端编辑 <code>/etc/docker/daemon.json</code>，加上：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;unix:///var/run/docker.sock&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tcp://0.0.0.0:2375&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>此时通过<code>sudo systemctl restart docker</code>重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 <code>-H fd://</code>，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 <code>-H fd://</code> 意思是：“不用自己打开 socket，去 systemd 那里拿吧。”</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.service</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br><span class="line"><span class="comment"># 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到  -H fd://</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 另外可以在与 docker.service 同目录下找到  docker.socket 文件，可以看到如下内容</span></span><br><span class="line">ListenStream=/run/docker.sock <span class="comment"># /run 目录是被软连接到 /var/run/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock</span></span><br><span class="line"><span class="comment"># 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了</span></span><br><span class="line"><span class="comment"># 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 docker</span></span><br><span class="line"><span class="built_in">sudo</span> dockerd --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://`</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一: 去掉 `-H fd://` 参数</span></span><br><span class="line"><span class="built_in">sudo</span> vi /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，</span></span><br><span class="line"><span class="comment"># 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。</span></span><br><span class="line"><span class="comment"># Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启 docker daemon</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端测试连接</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://远程IP:2375 ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端加入环境变量后就不需要每次都加上 -H 参数了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh 就换成 ~/.zshrc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=tcp://远程IP:2375&quot;</span>  &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>❗不要开启无认证的 <code>tcp://0.0.0.0:2375</code> 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。</p></li><li class="lvl-2"><p>✅ 推荐方式是：</p><ul class="lvl-2"><li class="lvl-6">使用 <code>tcp://0.0.0.0:2376 + --tlsverify</code></li><li class="lvl-6">或通过 <code>ssh:// 隧道</code> 访问 Docker</li></ul></li></ul><div class="tips"><p><em><strong>小贴士</strong></em></p><ul class="lvl-1"><li class="lvl-2">通过上面的介绍你应该搞明白一件事，就是我们可以不用在 <code>/etc/docker/daemon.json</code> 中配置远程连接，而是通过 systemd 来配置，即在 <code>/usr/lib/systemd/system/docker.service</code> 或者 <code>/etc/systemd/system/docker.service.d/override.conf</code>中配置。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">那么问题来了：既然 systemd 就能搞定一切，那还要 <code>/etc/docker/daemon.json</code> 有什么用？答案是：可读性、可维护性、工具兼容性更强。</li></ul><table><thead><tr><th>项目</th><th><code>daemon.json</code></th><th><code>systemd ExecStart</code></th></tr></thead><tbody><tr><td>语法</td><td>JSON</td><td>Shell 命令行</td></tr><tr><td>适合设置</td><td>Hosts、日志、registry、镜像驱动等</td><td>启动命令、资源限制等</td></tr><tr><td>可读性</td><td>👍 结构化</td><td>👎 较长、容易出错</td></tr><tr><td>自动化支持</td><td>👍 工具友好</td><td>👎 需要 patch systemd</td></tr></tbody></table></div><h3 id="方式二：开启-TCP-TLS-安全访问（推荐用于公网）">方式二：开启 TCP + TLS 安全访问（推荐用于公网）</h3><ul class="lvl-0"><li class="lvl-2"><p>创建 TLS 证书，通过一个脚本实现，脚本名称 <code>generate-docker-certs.sh</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">SERVER_IP=166.189.9.114  <span class="comment"># 🚨 修改为你的 Docker 服务器 IP 或域名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建 CA...&quot;</span></span><br><span class="line">openssl genrsa -out ca-key.pem 4096</span><br><span class="line">openssl req -new -x509 -days 365 \</span><br><span class="line">  -key ca-key.pem -subj <span class="string">&quot;/CN=docker-ca&quot;</span> -out ca.pem</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建服务器私钥...&quot;</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建 OpenSSL 配置文件...&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extfile.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[req]</span></span><br><span class="line"><span class="string">distinguished_name = req_distinguished_name</span></span><br><span class="line"><span class="string">x509_extensions = v3_req</span></span><br><span class="line"><span class="string">prompt = no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[req_distinguished_name]</span></span><br><span class="line"><span class="string">CN = $&#123;SERVER_IP&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[v3_req]</span></span><br><span class="line"><span class="string">keyUsage = keyEncipherment, dataEncipherment</span></span><br><span class="line"><span class="string">extendedKeyUsage = serverAuth</span></span><br><span class="line"><span class="string">subjectAltName = @alt_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[alt_names]</span></span><br><span class="line"><span class="string">IP.1 = $&#123;SERVER_IP&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建服务器证书签名请求 (CSR)...&quot;</span></span><br><span class="line">openssl req -new -key server-key.pem \</span><br><span class="line">  -out server.csr -config extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 签发服务器证书...&quot;</span></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr \</span><br><span class="line">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">  -out server-cert.pem -extensions v3_req -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建客户端私钥...&quot;</span></span><br><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 创建客户端 CSR...&quot;</span></span><br><span class="line">openssl req -new -key key.pem -subj <span class="string">&quot;/CN=client&quot;</span> -out client.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+] 签发客户端证书...&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &gt; client-ext.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">extendedKeyUsage = clientAuth</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> client.csr \</span><br><span class="line">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \</span><br><span class="line">  -out cert.pem -extfile client-ext.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[✓] 所有证书生成完成！&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; 服务器证书: server-cert.pem, server-key.pem&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; 客户端证书: cert.pem, key.pem&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; CA根证书:   ca.pem&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>执行脚本</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x generate-docker-certs.sh</span><br><span class="line">./generate-docker-certs.sh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将以下证书文件部署到docker服务端</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端：server-cert.pem, server-key.pem, ca.pem</span></span><br><span class="line"><span class="built_in">cp</span> server-cert.pem /etc/docker/server-cert.pem</span><br><span class="line"><span class="built_in">cp</span> server-key.pem /etc/docker/server-key.pem</span><br><span class="line"><span class="built_in">cp</span> ca.pem /etc/docker/ca.pem</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将以下证书文件部署到docker客户端</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cert.pem, key.pem, ca.pem</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在docker服务端编辑 <code>/etc/docker/daemon.json</code></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;unix:///var/run/docker.sock&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tcp://0.0.0.0:2376&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlsverify&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlscacert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/ca.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlscert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/server-cert.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tlskey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/etc/docker/server-key.pem&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启 docker daemon</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端测试连接</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker \</span><br><span class="line">  --tlsverify \</span><br><span class="line">  --tlscacert=ca.pem \</span><br><span class="line">  --tlscert=cert.pem \</span><br><span class="line">  --tlskey=key.pem \</span><br><span class="line">  -H tcp://166.189.9.114:2376 \</span><br><span class="line">  ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="string"># 远程Docker IP和端口</span></span><br><span class="line"><span class="string">export DOCKER_HOST=tcp://166.189.9.114:2376</span></span><br><span class="line"><span class="string"># 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverify</span></span><br><span class="line"><span class="string">export DOCKER_TLS_VERIFY=1</span></span><br><span class="line"><span class="string"># 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pem</span></span><br><span class="line"><span class="string">export DOCKER_CERT_PATH=/path/to/certs</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="方式三：ssh-隧道访问">方式三：ssh:// 隧道访问</h3><ul class="lvl-0"><li class="lvl-2"><p>最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 <span class="string">&quot;docker ps&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>基于免密认证，如何配置免密登录可以参考 <a href="/2023/02/28/linux-command02-ssh/" title="Linux常用命令--ssh、scp与免密登录">Linux常用命令--ssh、scp与免密登录</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22</span></span><br><span class="line"><span class="comment"># 要求登录用户必须拥有docker的运行权限（加入 docker group）</span></span><br><span class="line">docker -H ssh://centos@166.189.9.114 ps</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>基于<code>config</code>配置(推荐)</p><ul class="lvl-2"><li class="lvl-6">这种方式的优点是可以配置证书和端口</li><li class="lvl-6">在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group）</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host mydocker</span><br><span class="line">HostName 166.189.9.114</span><br><span class="line">User centos</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile ~/.ssh/my_docker_key</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-6">测试</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H ssh://mydocker ps</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>添加环境变量避免每次都加上 <code>-H</code> 参数</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 基于免密认证</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=ssh://user@host&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment">## 或者基于config的方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DOCKER_HOST=ssh://mydocker&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="docker-context-同时连接多个远程docker"><code>docker context</code>: 同时连接多个远程docker</h2><ul class="lvl-0"><li class="lvl-2"><p>上面介绍的三种方式，为了简化连接，都加上了<code>DOCKER_HOST</code>环境变量，但是<code>DOCKER_HOST</code>只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换<code>DOCKER_HOST</code>环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 <code>context</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP</span></span><br><span class="line">docker context create remote-tcp \</span><br><span class="line">    --docker <span class="string">&quot;host=tcp://166.189.9.114:2375&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP + TLS</span></span><br><span class="line">docker context create remote-tls \</span><br><span class="line">  --docker <span class="string">&quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh隧道</span></span><br><span class="line">docker context create remote-ssh --docker <span class="string">&quot;host=ssh://mydocker&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">docker context <span class="built_in">ls</span> <span class="comment"># 列出所有context</span></span><br><span class="line">docker context use remote-ssh <span class="comment"># 切换到指定的context</span></span><br><span class="line">docker ps <span class="comment"># 查看容器</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>docker context</code> 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如：</p><ul class="lvl-2"><li class="lvl-6">本地 Docker（默认）</li><li class="lvl-6">远程主机的 Docker（通过 SSH 或 TCP/TLS）</li><li class="lvl-6">Docker Desktop</li><li class="lvl-6">Docker Swarm 或 Kubernetes（部分支持）</li></ul></li><li class="lvl-2"><p>就像你用 <code>kubectl config use-context</code> 切换 Kubernetes 集群，<code>docker context</code> 也允许你在多个 Docker 后端之间切换，而无需反复设置 <code>DOCKER_HOST</code> 环境变量或写繁琐的 SSH 隧道命令。</p></li><li class="lvl-2"><p>常用命令一览</p></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker context ls</code></td><td>列出所有上下文</td></tr><tr><td><code>docker context use &lt;name&gt;</code></td><td>切换到指定 context</td></tr><tr><td><code>docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td><td>创建一个新的 context</td></tr><tr><td><code>docker context rm &lt;name&gt;</code></td><td>删除 context</td></tr><tr><td><code>docker context inspect &lt;name&gt;</code></td><td>查看 context 详情</td></tr><tr><td><code>docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td><td>更新 context 参数（Docker 24+ 支持）</td></tr><tr><td><code>docker context show</code></td><td>显示当前 context</td></tr><tr><td><code>docker context export &lt;name&gt; &lt;file.tar&gt;</code></td><td>导出 context 到tar文件</td></tr><tr><td><code>docker context import &lt;name&gt; &lt;file.tar&gt;</code></td><td>导入 context 从tar文件</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>Docker endpoint config</p></li></ul><table><thead><tr><th>参数名</th><th>中文描述</th></tr></thead><tbody><tr><td><code>from</code></td><td>复制指定 context 名称 的 Docker 端点配置</td></tr><tr><td><code>host</code></td><td>要连接的 Docker 端点地址</td></tr><tr><td><code>ca</code></td><td>CA 签名的证书的路径</td></tr><tr><td><code>cert</code></td><td>TLS 证书文件的路径</td></tr><tr><td><code>key</code></td><td>TLS 密钥文件的路径</td></tr><tr><td><code>skip-tls-verify</code></td><td>跳过 TLS 证书验证（⚠️ 不建议用于生产环境）</td></tr></tbody></table><h2 id="三种远程连接-Docker-的方式及其优缺点总结">三种远程连接 Docker 的方式及其优缺点总结</h2><table><thead><tr><th>连接方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>1. SSH 方式 (<code>ssh://</code>)</strong></td><td>- 配置简单，无需额外开启 Docker TCP 端口和 TLS<br>- 安全性高，基于 SSH 加密和认证<br>- 不用开放额外端口，防火墙友好<br>- 易于用 SSH 代理和密钥管理</td><td>- 需要远程用户有 Docker 权限（如属于 <code>docker</code> 组）<br>- 连接速度可能受 SSH 连接影响<br>- 需要在本地安装并配置 SSH</td><td>开发环境、内网管理、小规模远程操作</td></tr><tr><td><strong>2. TCP + TLS 方式</strong></td><td>- 标准的远程 Docker API 访问<br>- 支持证书认证，安全性高<br>- 可以配置多个客户端和权限控制<br>- 适合自动化脚本、CI/CD 访问</td><td>- 配置较复杂，需要生成和管理 CA、服务器和客户端证书<br>- 需要开放 TCP 端口（如 2376），增加安全风险<br>- 证书配置错误容易导致连接失败</td><td>生产环境、自动化集成、需要高安全认证</td></tr><tr><td><strong>3. TCP 明文访问（无 TLS）</strong></td><td>- 配置最简单，只需监听 TCP 端口<br>- 方便快速测试和调试</td><td>- 极度不安全，数据明文传输<br>- 任何人都可访问 Docker API，极易被攻击<br>- 生产环境严重不建议使用</td><td>仅限局域网内测试或极简环境</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 --&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;本文介绍如何远程连接Docker&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;Docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    
    <category term="docker" scheme="https://blog.hanqunfeng.com/tags/docker/"/>
    
  </entry>
  
</feed>
