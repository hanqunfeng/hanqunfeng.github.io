<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飘逸峰的博客</title>
  
  <subtitle>Spring--Java程序员的春天</subtitle>
  <link href="https://blog.hanqunfeng.com/atom.xml" rel="self"/>
  
  <link href="https://blog.hanqunfeng.com/"/>
  <updated>2025-12-24T09:38:40.816Z</updated>
  <id>https://blog.hanqunfeng.com/</id>
  
  <author>
    <name>飘逸峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Amazon Linux 2023(内核 6.1) 安装 Redis8</title>
    <link href="https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/"/>
    <id>https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/</id>
    <published>2025-12-25T13:30:05.000Z</published>
    <updated>2025-12-24T09:38:40.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Linux 安装 Redis8 的方法</li><li class="lvl-2">Linux 版本：<code>Amazon Linux 2023(内核 6.1)</code>。</li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2"><a href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/">Redis官网安装手册</a></li></ul><span id="more"></span><h2 id="Yum-安装">Yum 安装</h2><blockquote><p>最省事，国内环境也可以顺利完成安装。<br><code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1.添加仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Redis]</span></span><br><span class="line"><span class="string">name=Redis</span></span><br><span class="line"><span class="string">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.安装 Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class="line"><span class="built_in">sudo</span> rpm --import /tmp/redis.key</span><br><span class="line"><span class="built_in">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.查看redis安装信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已安装的redis版本</span></span><br><span class="line">$ rpm -qa | grep redis</span><br><span class="line">redis-8.4.0-1.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis安装信息</span></span><br><span class="line">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class="line">Name        : redis</span><br><span class="line">Version     : 8.4.0</span><br><span class="line">Release     : 1</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class="line">Group       : Applications/Databases</span><br><span class="line">Size        : 83034075</span><br><span class="line">License     :</span><br><span class="line">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class="line">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class="line">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class="line">Build Host  : 331d5099e900</span><br><span class="line">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class="line">URL         : https://redis.io/</span><br><span class="line">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class="line">Description :</span><br><span class="line">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis安装的文件</span></span><br><span class="line">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class="line">/etc/redis</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">/etc/redis/sentinel</span><br><span class="line">/etc/redis/sentinel/sentinel.conf</span><br><span class="line">/run/redis</span><br><span class="line">/run/redis/redis-server.pid</span><br><span class="line">/usr/bin/redis-benchmark</span><br><span class="line">/usr/bin/redis-check-aof</span><br><span class="line">/usr/bin/redis-check-rdb</span><br><span class="line">/usr/bin/redis-cli</span><br><span class="line">/usr/bin/redis-sentinel</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">/usr/lib/redis</span><br><span class="line">/usr/lib/redis/modules</span><br><span class="line">/usr/lib/redis/modules/redisbloom.so</span><br><span class="line">/usr/lib/redis/modules/redisearch.so</span><br><span class="line">/usr/lib/redis/modules/redistimeseries.so</span><br><span class="line">/usr/lib/redis/modules/rejson.so</span><br><span class="line">/usr/lib/redis/redisbloom.so</span><br><span class="line">/usr/lib/redis/redisearch.so</span><br><span class="line">/usr/lib/redis/redistimeseries.so</span><br><span class="line">/usr/lib/redis/rejson.so</span><br><span class="line">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class="line">/usr/lib/systemd/system/redis.service</span><br><span class="line">/usr/share/selinux/packages/redis-ce.fc</span><br><span class="line">/usr/share/selinux/packages/redis-ce.te</span><br><span class="line">/var/lib/redis</span><br><span class="line">/var/log/redis</span><br><span class="line">/var/log/redis/redis-sentinel.log</span><br><span class="line">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>4.启动redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis</span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis</span><br><span class="line"><span class="built_in">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>5.登录redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;timeseries&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">3) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;ReJSON&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">4) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;vectorset&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">5) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;search&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80402</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure><h2 id="源码安装">源码安装</h2><ul class="lvl-0"><li class="lvl-2"><p>1.更新环境(非必须)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.安装依赖包</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install -y --nobest --skip-broken \</span><br><span class="line">    pkg-config \</span><br><span class="line">    xz \</span><br><span class="line">    wget \</span><br><span class="line">    <span class="built_in">which</span> \</span><br><span class="line">    git \</span><br><span class="line">    make \</span><br><span class="line">    openssl \</span><br><span class="line">    openssl-devel \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-devel \</span><br><span class="line">    unzip \</span><br><span class="line">    rsync \</span><br><span class="line">    clang \</span><br><span class="line">    llvm \</span><br><span class="line">    curl \</span><br><span class="line">    libtool \</span><br><span class="line">    automake \</span><br><span class="line">    autoconf \</span><br><span class="line">    jq \</span><br><span class="line">    systemd-devel</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.下载并提取Redis源代码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line"><span class="built_in">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>4.编译Redis</p></li></ul><blockquote><p>这里要注意，不会自动安装模块，需要手动安装。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用GCC工具集</span></span><br><span class="line"><span class="built_in">cd</span> /usr/src/redis-8.4.0</span><br><span class="line"><span class="comment"># 构建TLS</span></span><br><span class="line"><span class="built_in">export</span> BUILD_TLS=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 构建Redis模块，配不配都不会自动安装模块</span></span><br><span class="line"><span class="built_in">export</span> BUILD_WITH_MODULES=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 安装Rust工具链</span></span><br><span class="line"><span class="built_in">export</span> INSTALL_RUST_TOOLCHAIN=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 关闭警告</span></span><br><span class="line"><span class="built_in">export</span> DISABLE_WERRORS=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 开始编译</span></span><br><span class="line"><span class="built_in">sudo</span> make -j <span class="string">&quot;<span class="subst">$(nproc)</span>&quot;</span> all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">./src/redis-server --version</span><br><span class="line">./src/redis-cli --version</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>5.启动Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./src/redis-server redis.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>6.登录Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./src/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;vectorset&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>7.安装模块，可以参考如下文章中的介绍</p><ul class="lvl-2"><li class="lvl-5"><a href="/2025/12/24/redis7-module-RedisJSON/" title="Redis 扩展模块 -- RedisJSON">Redis 扩展模块 -- RedisJSON</a></li><li class="lvl-5"><a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Linux 安装 Redis8 的方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Linux 版本：&lt;code&gt;Amazon Linux 2023(内核 6.1)&lt;/code&gt;。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;a href=&quot;https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/&quot;&gt;Redis官网安装手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Rcoky9 安装 Redis8</title>
    <link href="https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/"/>
    <id>https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/</id>
    <published>2025-12-25T13:30:05.000Z</published>
    <updated>2025-12-24T10:06:24.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Linux 安装 Redis8 的方法</li><li class="lvl-2">Linux 版本：<code>Rocky Linux release 9.4 (Blue Onyx)</code>。</li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2"><a href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/">Redis官网安装手册</a></li></ul><span id="more"></span><h2 id="Yum-安装">Yum 安装</h2><blockquote><p>最省事，国内环境也可以顺利完成安装。<br><code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1.添加仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Redis]</span></span><br><span class="line"><span class="string">name=Redis</span></span><br><span class="line"><span class="string">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.安装 Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class="line"><span class="built_in">sudo</span> rpm --import /tmp/redis.key</span><br><span class="line"><span class="built_in">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.查看redis安装信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已安装的redis版本</span></span><br><span class="line">$ rpm -qa | grep redis</span><br><span class="line">redis-8.4.0-1.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis安装信息</span></span><br><span class="line">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class="line">Name        : redis</span><br><span class="line">Version     : 8.4.0</span><br><span class="line">Release     : 1</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class="line">Group       : Applications/Databases</span><br><span class="line">Size        : 83034075</span><br><span class="line">License     :</span><br><span class="line">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class="line">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class="line">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class="line">Build Host  : 331d5099e900</span><br><span class="line">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class="line">URL         : https://redis.io/</span><br><span class="line">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class="line">Description :</span><br><span class="line">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis安装的文件</span></span><br><span class="line">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class="line">/etc/redis</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">/etc/redis/sentinel</span><br><span class="line">/etc/redis/sentinel/sentinel.conf</span><br><span class="line">/run/redis</span><br><span class="line">/run/redis/redis-server.pid</span><br><span class="line">/usr/bin/redis-benchmark</span><br><span class="line">/usr/bin/redis-check-aof</span><br><span class="line">/usr/bin/redis-check-rdb</span><br><span class="line">/usr/bin/redis-cli</span><br><span class="line">/usr/bin/redis-sentinel</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">/usr/lib/redis</span><br><span class="line">/usr/lib/redis/modules</span><br><span class="line">/usr/lib/redis/modules/redisbloom.so</span><br><span class="line">/usr/lib/redis/modules/redisearch.so</span><br><span class="line">/usr/lib/redis/modules/redistimeseries.so</span><br><span class="line">/usr/lib/redis/modules/rejson.so</span><br><span class="line">/usr/lib/redis/redisbloom.so</span><br><span class="line">/usr/lib/redis/redisearch.so</span><br><span class="line">/usr/lib/redis/redistimeseries.so</span><br><span class="line">/usr/lib/redis/rejson.so</span><br><span class="line">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class="line">/usr/lib/systemd/system/redis.service</span><br><span class="line">/usr/share/selinux/packages/redis-ce.fc</span><br><span class="line">/usr/share/selinux/packages/redis-ce.te</span><br><span class="line">/var/lib/redis</span><br><span class="line">/var/log/redis</span><br><span class="line">/var/log/redis/redis-sentinel.log</span><br><span class="line">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>4.启动redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis</span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis</span><br><span class="line"><span class="built_in">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>5.登录redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;timeseries&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">3) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;ReJSON&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">4) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;vectorset&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">5) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;search&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80402</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure><h2 id="源码安装">源码安装</h2><ul class="lvl-0"><li class="lvl-2"><p>1.添加仓库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/yum.repos.d/goreleaser.repo &gt; /dev/null &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[goreleaser]</span></span><br><span class="line"><span class="string">name=GoReleaser</span></span><br><span class="line"><span class="string">baseurl=https://repo.goreleaser.com/yum/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> dnf clean all</span><br><span class="line"><span class="built_in">sudo</span> dnf makecache</span><br><span class="line"><span class="built_in">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>2.安装依赖包</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install -y --nobest --skip-broken \</span><br><span class="line">    pkg-config \</span><br><span class="line">    xz \</span><br><span class="line">    wget \</span><br><span class="line">    <span class="built_in">which</span> \</span><br><span class="line">    gcc-toolset-13-gcc \</span><br><span class="line">    gcc-toolset-13-gcc-c++ \</span><br><span class="line">    git \</span><br><span class="line">    make \</span><br><span class="line">    openssl \</span><br><span class="line">    openssl-devel \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-devel \</span><br><span class="line">    unzip \</span><br><span class="line">    rsync \</span><br><span class="line">    clang \</span><br><span class="line">    curl \</span><br><span class="line">    libtool \</span><br><span class="line">    automake \</span><br><span class="line">    autoconf \</span><br><span class="line">    jq \</span><br><span class="line">    systemd-devel</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>3.创建一个Python虚拟环境</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> python3 -m venv /opt/venv</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>4.启用GCC工具集</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /opt/rh/gcc-toolset-13/enable /etc/profile.d/gcc-toolset-13.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /etc/profile.d/gcc-toolset-13.sh&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/bashrc</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>5.安装CMake</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_VERSION=3.25.1</span><br><span class="line">ARCH=$(<span class="built_in">uname</span> -m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  CMAKE_FILE=cmake-<span class="variable">$&#123;CMAKE_VERSION&#125;</span>-linux-x86_64.sh</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  CMAKE_FILE=cmake-<span class="variable">$&#123;CMAKE_VERSION&#125;</span>-linux-aarch64.sh</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> wget https://github.com/Kitware/CMake/releases/download/v<span class="variable">$&#123;CMAKE_VERSION&#125;</span>/<span class="variable">$&#123;CMAKE_FILE&#125;</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x <span class="variable">$&#123;CMAKE_FILE&#125;</span></span><br><span class="line"><span class="built_in">sudo</span> ./<span class="variable">$&#123;CMAKE_FILE&#125;</span> --skip-license --prefix=/usr/local --exclude-subdir</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> <span class="variable">$&#123;CMAKE_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/bin</span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>6.下载并提取Redis源代码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line"><span class="built_in">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>7.编译Redis</p></li></ul><blockquote><p>国内环境安装时因为需要从GitHub下载模块，速度很慢，而且经常失败，建议安装时先不要安装模块，安装好redis后再按需安装模块。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用GCC工具集</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/gcc-toolset-13.sh</span><br><span class="line"><span class="built_in">cd</span> /usr/src/redis-8.4.0</span><br><span class="line"><span class="comment"># 构建TLS</span></span><br><span class="line"><span class="built_in">export</span> BUILD_TLS=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 构建Redis模块，如果不安装模块，则不需要此参数</span></span><br><span class="line"><span class="built_in">export</span> BUILD_WITH_MODULES=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 安装Rust工具链</span></span><br><span class="line"><span class="built_in">export</span> INSTALL_RUST_TOOLCHAIN=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 关闭警告</span></span><br><span class="line"><span class="built_in">export</span> DISABLE_WERRORS=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 开始编译</span></span><br><span class="line"><span class="built_in">sudo</span> make -j <span class="string">&quot;<span class="subst">$(nproc)</span>&quot;</span> all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">./src/redis-server --version</span><br><span class="line">./src/redis-cli --version</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>8.启动Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./src/redis-server redis-full.conf</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>9.登录Redis</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ ./src/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;search&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80402</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;./modules/redisearch/redisearch.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;vectorset&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">3) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;ReJSON&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;./modules/redisjson/rejson.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">4) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;./modules/redisbloom/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">5) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;timeseries&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 80400</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;./modules/redistimeseries/redistimeseries.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>10.安装模块，如果安装时没有安装模块，可以参考如下文章中的介绍</p><ul class="lvl-2"><li class="lvl-5"><a href="/2025/12/24/redis7-module-RedisJSON/" title="Redis 扩展模块 -- RedisJSON">Redis 扩展模块 -- RedisJSON</a></li><li class="lvl-5"><a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Linux 安装 Redis8 的方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Linux 版本：&lt;code&gt;Rocky Linux release 9.4 (Blue Onyx)&lt;/code&gt;。&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;a href=&quot;https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/&quot;&gt;Redis官网安装手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- JSON</title>
    <link href="https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/"/>
    <id>https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/</id>
    <published>2025-12-24T13:40:05.000Z</published>
    <updated>2025-12-24T10:31:39.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisJSON 的安装参见 <a href="/2025/12/24/redis7-module-RedisJSON/" title="Redis 扩展模块 -- RedisJSON">Redis 扩展模块 -- RedisJSON</a></li></ul><span id="more"></span><h2 id="JSON-vs-String">JSON vs String</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis JSON存储数据的性能更高。</p><ul class="lvl-2"><li class="lvl-6">Redis JSON 底层其实是以一种高效的二进制的格式存储。</li><li class="lvl-6">相比简单的文本格式，二进制格式进行 JOSN 格式读写的性能更高，也更节省内存。</li><li class="lvl-6">根据官网的性能测试报告，使用 Redis JSON 读写 JSON数据，性能已经能够媲美 MongoDB 以及 ElasticSearch 等传统 NoSQL 数据库。</li></ul></li><li class="lvl-2"><p>Redis JSON 使用树状结构来存储JSON。</p><ul class="lvl-2"><li class="lvl-6">这种存储方式可以快速访问子元素。</li><li class="lvl-6">与传统的文本存储方案相比，树状存储结构能够更高效的执行查询操作。</li></ul></li><li class="lvl-2"><p>与Redis生态集成度高。</p><ul class="lvl-2"><li class="lvl-6">作为Redis的扩展模块，Redis JSON 和Redis的其他功能和工具无缝集成。</li><li class="lvl-6">这意味着开发者可以继续使用TTL、Redis事务、发布/订阅、Lua脚本等功能。</li></ul></li></ul><h2 id="JSONPath">JSONPath</h2><ul class="lvl-0"><li class="lvl-2"><p>JSONPath 是一种用于查询和修改 JSON 数据的语法。</p></li><li class="lvl-2"><p>JSONPath 语法</p></li></ul><table><thead><tr><th>语法元素</th><th>中文说明</th><th>示例</th></tr></thead><tbody><tr><td><code>$</code></td><td>根节点（最外层 JSON 元素），JSONPath 的起点</td><td><code>$</code>、<code>$.user.name</code></td></tr><tr><td><code>.</code></td><td>访问子字段（对象属性访问）</td><td><code>$.user.age</code></td></tr><tr><td><code>[]</code></td><td>子元素选择器（字段名或数组索引）</td><td><code>$['user']['name']</code></td></tr><tr><td><code>..</code></td><td>递归下降，遍历所有层级的节点</td><td><code>$..id</code></td></tr><tr><td><code>*</code></td><td>通配符，匹配当前层级的所有元素</td><td><code>$.users[*]</code></td></tr><tr><td><code>[index]</code></td><td>数组下标访问（支持负索引）</td><td><code>$.scores[0]</code></td></tr><tr><td><code>[a,b,c]</code></td><td>联合选择，返回多个指定元素</td><td><code>$.scores[0,2,4]</code></td></tr><tr><td><code>[start:end:step]</code></td><td>数组切片（起始索引 : 结束索引 : 步长）</td><td><code>$.scores[1:5:2]</code></td></tr><tr><td><code>[*]</code></td><td>选择数组中的所有元素</td><td><code>$.items[*]</code></td></tr><tr><td><code>[:]</code></td><td>选择数组中的所有元素（切片写法）</td><td><code>$.items[:]</code></td></tr><tr><td><code>?()</code></td><td>过滤表达式，用于数组或对象的条件筛选</td><td><code>$.users[?(@.age &gt;= 18)]</code></td></tr><tr><td><code>()</code></td><td>脚本表达式，用于计算或复杂逻辑判断</td><td><code>$.items[?((@.a + @.b) &gt; 10)]</code></td></tr><tr><td><code>@</code></td><td>当前元素引用，常用于过滤或脚本表达式中</td><td><code>@.price &lt; 100</code></td></tr></tbody></table><h2 id="JSON-命令">JSON 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>JSON 命令 汇总</p></li></ul><table><thead><tr><th>分类</th><th>命令</th></tr></thead><tbody><tr><td>基础读写</td><td>SET / MSET / GET / MGET</td></tr><tr><td>数组操作</td><td>ARRAPPEND / ARRINSERT / ARRPOP / ARRLEN / ARRINDEX / ARRTRIM</td></tr><tr><td>对象操作</td><td>OBJKEYS / OBJLEN / TYPE</td></tr><tr><td>数值运算</td><td>NUMINCRBY / NUMMULTBY / TOGGLE</td></tr><tr><td>字符串</td><td>STRAPPEND / STRLEN</td></tr><tr><td>删除清空</td><td>DEL / FORGET / CLEAR</td></tr><tr><td>合并输出</td><td>MERGE / RESP</td></tr><tr><td>调试诊断</td><td>DEBUG / DEBUG MEMORY</td></tr></tbody></table><h3 id="一、基础读写类（CRUD）">一、基础读写类（CRUD）</h3><table><thead><tr><th>命令</th><th>作用</th><th>关键参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.SET</td><td>设置或更新某个 path 的值</td><td><code>key</code>：键名<br><code>path</code>：JSONPath（如 <code>$</code>、<code>$.a.b</code>）<br><code>value</code>：JSON 值</td><td><code>JSON.SET user:1 $ '&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;'</code></td></tr><tr><td>JSON.MSET</td><td>批量设置多个 key</td><td><code>(key path value)...</code></td><td><code>JSON.MSET k1 $ '&#123;&quot;a&quot;:1&#125;' k2 $.b 2</code></td></tr><tr><td>JSON.GET</td><td>获取一个 key 的 JSON 值</td><td><code>key</code><br><code>path...</code>：可多个</td><td><code>JSON.GET user:1 $.name $.age</code></td></tr><tr><td>JSON.MGET</td><td>从多个 key 获取同一路径</td><td><code>key... path</code></td><td><code>JSON.MGET k1 k2 $.a</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>说明：</p><ul class="lvl-2"><li class="lvl-6">JSON.GET 返回 字符串化 JSON</li><li class="lvl-6">JSON.MGET 返回数组，对应多个 key</li></ul></li></ul><h3 id="二、数组操作类（Array）">二、数组操作类（Array）</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数含义</th><th>示例</th></tr></thead><tbody><tr><td>JSON.ARRAPPEND</td><td>向数组末尾追加元素</td><td><code>key path value...</code></td><td><code>JSON.ARRAPPEND k $.tags &quot;redis&quot; &quot;json&quot;</code></td></tr><tr><td>JSON.ARRINSERT</td><td>在指定索引插入元素</td><td><code>key path index value...</code></td><td><code>JSON.ARRINSERT k $.tags 1 &quot;nosql&quot;</code></td></tr><tr><td>JSON.ARRPOP</td><td>删除并返回指定索引元素</td><td><code>key path [index]</code></td><td><code>JSON.ARRPOP k $.tags -1</code></td></tr><tr><td>JSON.ARRLEN</td><td>获取数组长度</td><td><code>key path</code></td><td><code>JSON.ARRLEN k $.tags</code></td></tr><tr><td>JSON.ARRINDEX</td><td>查找元素索引</td><td><code>key path value</code></td><td><code>JSON.ARRINDEX k $.tags &quot;redis&quot;</code></td></tr><tr><td>JSON.ARRTRIM</td><td>截取数组区间</td><td><code>key path start stop</code></td><td><code>JSON.ARRTRIM k $.scores 0 9</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>说明：</p><ul class="lvl-2"><li class="lvl-6">索引支持负数（-1 表示最后一个）</li><li class="lvl-6">ARRTRIM 类似 LTRIM</li></ul></li></ul><h3 id="三、对象操作类（Object）">三、对象操作类（Object）</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.OBJKEYS</td><td>获取对象的所有 key</td><td><code>key path</code></td><td><code>JSON.OBJKEYS k $.user</code></td></tr><tr><td>JSON.OBJLEN</td><td>获取对象字段数量</td><td><code>key path</code></td><td><code>JSON.OBJLEN k $.user</code></td></tr><tr><td>JSON.TYPE</td><td>返回 path 对应值类型</td><td><code>key path</code></td><td><code>JSON.TYPE k $.user.name</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>JSON.TYPE 返回类型包括：object / array / string / number / boolean / null</p></li></ul><h3 id="四、数值运算类（Numeric）">四、数值运算类（Numeric）</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.NUMINCRBY</td><td>数值自增</td><td><code>key path number</code></td><td><code>JSON.NUMINCRBY k $.count 1</code></td></tr><tr><td>JSON.NUMMULTBY</td><td>数值乘法</td><td><code>key path number</code></td><td><code>JSON.NUMMULTBY k $.price 0.8</code></td></tr><tr><td>JSON.TOGGLE</td><td>布尔值取反</td><td><code>key path</code></td><td><code>JSON.TOGGLE k $.enabled</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>说明：</p><ul class="lvl-2"><li class="lvl-6">保证 原子性</li><li class="lvl-6">常用于计数、开关状态</li></ul></li></ul><h3 id="五、字符串操作类（String）">五、字符串操作类（String）</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.STRAPPEND</td><td>追加字符串</td><td><code>key path value</code></td><td><code>JSON.STRAPPEND k $.msg &quot; world&quot;</code></td></tr><tr><td>JSON.STRLEN</td><td>字符串长度</td><td><code>key path</code></td><td><code>JSON.STRLEN k $.msg</code></td></tr></tbody></table><h3 id="六、删除-清空类">六、删除 / 清空类</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.DEL</td><td>删除指定 path</td><td><code>key path</code></td><td><code>JSON.DEL k $.user.age</code></td></tr><tr><td>JSON.FORGET</td><td>等价 JSON.DEL</td><td>同上</td><td><code>JSON.FORGET k $.tmp</code></td></tr><tr><td>JSON.CLEAR</td><td>清空值</td><td><code>key path</code></td><td><code>JSON.CLEAR k $.list</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>JSON.CLEAR 行为说明：</p><ul class="lvl-2"><li class="lvl-6">数组 → []</li><li class="lvl-6">对象 → {}</li><li class="lvl-6">数值 → 0</li></ul></li></ul><h3 id="七、合并与高级操作">七、合并与高级操作</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.MERGE</td><td>合并 JSON（RFC7396）</td><td><code>key path value</code></td><td><code>JSON.MERGE k $ '&#123;&quot;a&quot;:2,&quot;b&quot;:3&#125;'</code></td></tr><tr><td>JSON.RESP</td><td>RESP 格式返回</td><td><code>key path</code></td><td><code>JSON.RESP k $.user</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>说明：</p><ul class="lvl-2"><li class="lvl-6">MERGE 支持字段覆盖、删除、扩展</li><li class="lvl-6">RESP 适合客户端直接解析</li></ul></li></ul><h3 id="八、调试与诊断类（Debug）">八、调试与诊断类（Debug）</h3><table><thead><tr><th>命令</th><th>作用</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>JSON.DEBUG</td><td>调试命令容器</td><td>子命令</td><td><code>JSON.DEBUG MEMORY k</code></td></tr><tr><td>JSON.DEBUG MEMORY</td><td>查看 JSON 占用内存</td><td><code>key</code></td><td><code>JSON.DEBUG MEMORY user:1</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisJSON 的安装参见 &lt;a href=&quot;/2025/12/24/redis7-module-RedisJSON/&quot; title=&quot;Redis 扩展模块 -- RedisJSON&quot;&gt;Redis 扩展模块 -- RedisJSON&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 扩展模块 -- RedisJSON</title>
    <link href="https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/"/>
    <id>https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/</id>
    <published>2025-12-24T13:30:05.000Z</published>
    <updated>2025-12-24T10:01:58.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模块 – RedisJSON 的安装方法</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="RedisJSON-简介">RedisJSON 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/RedisJSON/RedisJSON">RedisJSON</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于对JSON数据进行操作。</p></li><li class="lvl-2"><p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p></li><li class="lvl-2"><p>Redis8+，RedisJSON 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p></li></ul><h2 id="安装-RedisJSON">安装 RedisJSON</h2><ul class="lvl-0"><li class="lvl-2"><p>虽然<a href="https://cloud.redis.io">Redis Cloud</a>的<code>Download Center</code>中提供了所有Redis模块编译后的<code>.so</code>文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。</p></li></ul><blockquote><p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>rejson.so</code>上传到国内服务器即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft/modules/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft/modules</span><br><span class="line"><span class="comment"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/RedisJSON/RedisJSON.git</span><br><span class="line"><span class="built_in">cd</span> RedisJSON</span><br><span class="line"><span class="comment"># 推荐切换到稳定的release版本</span></span><br><span class="line">git checkout v2.8.16</span><br><span class="line"><span class="comment"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并安装需要的依赖</span></span><br><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># readies version: 7fc8e62</span></span><br><span class="line">dnf install -q -y ca-certificates</span><br><span class="line">dnf install -q -y wget unzip</span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/enable-utf8</span><br><span class="line">dnf install -q -y git unzip rsync</span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getrust</span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getcmake --usr</span><br><span class="line">dnf install -q -y <span class="built_in">which</span></span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getgcc --modern</span><br><span class="line"><span class="built_in">dir</span>=$(<span class="built_in">mktemp</span> -d /tmp/tar.XXXXXX); (<span class="built_in">cd</span> <span class="variable">$dir</span>; wget --no-verbose -O tar.tgz http://redismodules.s3.amazonaws.com/readies/gnu/gnu-tar-1.32-x64-centos7.tgz; tar -xzf tar.tgz -C /; ); <span class="built_in">rm</span> -rf <span class="variable">$dir</span></span><br><span class="line">dnf install -q -y lcov</span><br><span class="line">/usr/bin/python3 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class="line">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r /usr/local/soft/modules/RedisJSON/tests/pytest/requirements.txt</span><br><span class="line">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getaws</span><br><span class="line">NO_PY2=1 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getpudb</span><br><span class="line"></span><br><span class="line"><span class="comment"># RedisJSON 的编译依赖 Rust 工具链，所以编译前需要安装rust，若已经安装则忽略</span></span><br><span class="line"><span class="comment"># 安装 rustup</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按提示选择默认安装（通常选择 1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 Rust 生效</span></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.cargo/env</span><br><span class="line"><span class="comment"># 检查 rust 版本</span></span><br><span class="line">rustc --version <span class="comment"># rustc 1.92.0 (ded5c06cf 2025-12-08)</span></span><br><span class="line">cargo --version <span class="comment"># cargo 1.92.0 (344c4567c 2025-10-21)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 RedisJSON</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/rejson.so`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong><code>./sbin/setup</code> 报错</strong></em></p><ul class="lvl-1"><li class="lvl-2">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li></ul><blockquote><p><code>install_raven</code> 的报错参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a> 进行修改。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 错误信息</span></span><br><span class="line">……</span><br><span class="line">dnf install -q -y llvm-toolset-7.0</span><br><span class="line">Error: Unable to find a match: llvm-toolset-7.0</span><br><span class="line"><span class="built_in">command</span> failed: dnf install -q -y llvm-toolset-7.0</span><br><span class="line"><span class="built_in">command</span> failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class="line"></span><br><span class="line">In /usr/local/soft/modules/RedisJSON/sbin/setup:</span><br><span class="line">18       python3 -m pip list</span><br><span class="line">19       <span class="keyword">fi</span></span><br><span class="line">20</span><br><span class="line">21   &gt;&gt;&gt; <span class="variable">$ROOT</span>/sbin/system-setup.py</span><br><span class="line">22       <span class="keyword">if</span> [[ <span class="variable">$VERBOSE</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">23       python3 -m pip list</span><br><span class="line">24       <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误分析与解决方法：</span></span><br><span class="line">问题原因：</span><br><span class="line">    操作系统的事，在 `deps/readies/bin/getclang`中有一个方法，其实一看就明白了</span><br><span class="line">    def redhat_compat(self):</span><br><span class="line">        <span class="keyword">if</span> not self.modern:</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        self.run(<span class="string">&quot;%s/bin/getepel&quot;</span> % READIES, <span class="built_in">sudo</span>=True)</span><br><span class="line">        <span class="keyword">if</span> self.dist <span class="keyword">in</span> [<span class="string">&#x27;centos&#x27;</span>, <span class="string">&#x27;ol&#x27;</span>] and self.os_version[0] &gt;= 8:</span><br><span class="line">            self.install(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line">            self.install(<span class="string">&quot;llvm-toolset&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.install(<span class="string">&quot;llvm-toolset-7.0&quot;</span>)</span><br><span class="line">            self.cp_to_profile_d(<span class="string">&quot;/opt/rh/llvm-toolset-7.0/enable&quot;</span>, <span class="string">&quot;llvm-toolset-7.0.sh&quot;</span>)</span><br><span class="line">    我使用的机器不是 centos，所以就走<span class="keyword">else</span>的逻辑了，另外这里即便走了 centos 逻辑，也有问题，就是el9中已经没有 llvm-toolset 了，取而代之的是 llvm，所以需要修改该方法</span><br><span class="line"></span><br><span class="line">修改方法如下：</span><br><span class="line">    def redhat_compat(self):</span><br><span class="line">        <span class="keyword">if</span> not self.modern:</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        self.run(<span class="string">&quot;%s/bin/getepel&quot;</span> % READIES, <span class="built_in">sudo</span>=True)</span><br><span class="line">        <span class="comment"># 去掉判断，直接安装，前提是 el9</span></span><br><span class="line">        self.install(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line">        self.install(<span class="string">&quot;llvm&quot;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="Redis-启用模块">Redis 启用模块</h2><ul class="lvl-0"><li class="lvl-2"><p>将生成的 <a href="http://rejson.so">rejson.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意 .so 文件需要包含可执行权限</span></span><br><span class="line"><span class="built_in">cp</span> bin/linux-x64-release/rejson.so /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>本文采用 <code>loadmodule</code> 加载模块</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 rejson.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class="line">loadmodule /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">redis-server redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录测试</span></span><br><span class="line">redis-cli --user admin --pass 123456</span><br><span class="line"><span class="comment"># 查看模块</span></span><br><span class="line">127.0.0.1:6379&gt; info Modules</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line">module:name=ReJSON,ver=20816,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class="line">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;ReJSON&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 20816</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line">2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 20817</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模块 – RedisJSON 的安装方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- TDigest</title>
    <link href="https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/"/>
    <id>https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/</id>
    <published>2025-12-23T07:40:05.000Z</published>
    <updated>2025-12-23T09:53:35.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisBloom 的安装参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul><span id="more"></span><h2 id="T-Digest-分位数估计算法">T-Digest(分位数估计算法)</h2><ul class="lvl-0"><li class="lvl-2"><p>T-Digest（TDigest）解决的问题与 CMS、TopK 完全不同，核心目标是 分位数（quantile）统计。</p></li><li class="lvl-2"><p>T-Digest 由 Ted Dunning 提出，专门为 <code>高精度尾部分位数</code> 设计。</p></li><li class="lvl-2"><p>TDigest 可以在极低内存占用下，近似计算分位数（P50 / P90 / P99 / Median 等）。</p></li><li class="lvl-2"><p>分位数（Percentile）指标对照表</p></li></ul><table><thead><tr><th>指标</th><th>英文全称</th><th>数学含义</th><th>通俗解释</th><th>典型业务解读</th><th>常见使用场景</th></tr></thead><tbody><tr><td>Median</td><td>Median</td><td>排序后位于中间位置的值</td><td>一半数据在它左右</td><td>“一般用户的体验”</td><td>基础体验评估</td></tr><tr><td>P50</td><td>50th Percentile</td><td>50% 的数据 ≤ 该值</td><td>和 Median 完全相同</td><td>“典型请求耗时”</td><td>常规性能监控</td></tr><tr><td>P90</td><td>90th Percentile</td><td>90% 的数据 ≤ 该值</td><td>10% 的请求更慢</td><td>“大多数用户的体验”</td><td>业务体验监控</td></tr><tr><td>P95</td><td>95th Percentile</td><td>95% 的数据 ≤ 该值</td><td>5% 的请求更慢</td><td>“尾部开始恶化”</td><td>SLA 边界监控</td></tr><tr><td>P99</td><td>99th Percentile</td><td>99% 的数据 ≤ 该值</td><td>1% 的请求最慢</td><td>“极端但真实的用户体验”</td><td>核心 SLA / SLO</td></tr><tr><td>P99.9</td><td>99.9th Percentile</td><td>99.9% 的数据 ≤ 该值</td><td>千分之一最慢请求</td><td>“极端尾延迟”</td><td>金融 / 核心链路</td></tr><tr><td>Max</td><td>Maximum</td><td>数据中的最大值</td><td>最慢的那一次</td><td>噪音极大</td><td>几乎不用</td></tr></tbody></table><blockquote><p>一个快速理解示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设 100 次请求：</span><br><span class="line">    99 次耗时：10 ms</span><br><span class="line">    1 次耗时：3000 ms</span><br><span class="line"></span><br><span class="line">所以：</span><br><span class="line">    P99 = 3000 ms</span><br><span class="line">    P90 = 10 ms</span><br><span class="line">    P50/Median = 10 ms</span><br><span class="line">    平均值 = （99*10 + 1*3000）/ 100 = 39.9 ms</span><br><span class="line"></span><br><span class="line">👉 只有 P99 真实暴露了问题。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>工程实践中的“标准搭配”</p></li></ul><table><thead><tr><th>应用场景</th><th>常看指标</th></tr></thead><tbody><tr><td>Web / API 服务</td><td>P90 / P99</td></tr><tr><td>微服务链路</td><td>P99 / P99.9</td></tr><tr><td>数据库 / 存储</td><td>P95 / P99</td></tr><tr><td>前端体验</td><td>P50 / P90</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>一句话：TDigest 用于统计数字的分布，P50 看中间，P90 看大多数，P99 看最差那 1%</p></li></ul><h2 id="RedisBloom-中-TDigest-的核心命令">RedisBloom 中 TDigest 的核心命令</h2><h3 id="创建-TDigest">创建 TDigest</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.CREATE key [COMPRESSION compression]</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key： TDigest 的名称</span></span><br><span class="line"><span class="comment"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.CREATE latency:td COMPRESSION 200</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 TDigest 的类型</span></span><br><span class="line"><span class="built_in">type</span> latency:td</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">TDIS-TYPE</span><br></pre></td></tr></table></figure><h3 id="添加样本">添加样本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.ADD key value [value ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.ADD latency:td 12.3 15.7 100.4</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="查看最大-最小值">查看最大/最小值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最大值</span></span><br><span class="line"><span class="comment"># TDIGEST.MAX key</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.MAX latency:td</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line"><span class="string">&quot;100.4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取最小值</span></span><br><span class="line"><span class="comment"># TDIGEST.MIN key</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.MIN latency:td</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line"><span class="string">&quot;12.3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="查询分位数">查询分位数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.QUANTILE key quantile [quantile ...]</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key： TDigest 的名称</span></span><br><span class="line"><span class="comment"># quantile： 查询的分位数，0.5=&gt;P50 / 0.9=&gt;P90 / 0.99=&gt;P99</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.QUANTILE latency:td 0.5 0.9 0.99</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">1) <span class="string">&quot;15.7&quot;</span></span><br><span class="line">2) <span class="string">&quot;100.4&quot;</span></span><br><span class="line">3) <span class="string">&quot;100.4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="反向查询（值-→-百分位）">反向查询（值 → 百分位）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.CDF key value [value ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.CDF latency:td 12.3 15.7 100.4 20</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">1) <span class="string">&quot;0.16666666666666666&quot;</span></span><br><span class="line">2) <span class="string">&quot;0.5&quot;</span></span><br><span class="line">3) <span class="string">&quot;0.8333333333333334&quot;</span></span><br><span class="line">4) <span class="string">&quot;0.6666666666666666&quot;</span>  <span class="comment"># 这里注意 value 不必须在 TDIGEST 中，这里的含义是 P66=20，即 66% 的值都 ≤ 20</span></span><br></pre></td></tr></table></figure><h3 id="合并-TDigest">合并 TDigest</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.MERGE destination-key numkeys source-key [source-key ...] [COMPRESSION compression] [OVERRIDE]</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># destination-key： 目标 TDigest 的名称</span></span><br><span class="line"><span class="comment"># numkeys： 源 TDigest 的数量</span></span><br><span class="line"><span class="comment"># source-key： 源 TDigest 的名称</span></span><br><span class="line"><span class="comment"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class="line"><span class="comment"># OVERRIDE： 是否覆盖目标 TDigest，默认为 false</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.MERGE latency:td 2 latency:td:1 latency:td:2 COMPRESSION 200 OVERRIDE</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="获取近似排名">获取近似排名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向排名</span></span><br><span class="line"><span class="comment"># TDIGEST.RANK key value [value ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># TDIGEST.ADD latency:td 12.3 15.7 100.4 # 假设这些数据已经写入了 TDigest</span></span><br><span class="line"><span class="comment"># 如果把 value 放入当前分布中，它的 rank（小于该值的样本数量）是多少</span></span><br><span class="line">TDIGEST.RANK latency:td 0 12.3 15.7 20 100.4 200</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">1) (<span class="built_in">integer</span>) -1   <span class="comment"># 0: 小于最小值 12.3 → 返回 -1</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 0    <span class="comment"># 12.3: 第 0 位 → 返回 0，真实存在的位数</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1    <span class="comment"># 15.7: 排在 12.3 后 → 返回 1，真实存在的位数</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 2    <span class="comment"># 20: 介于 15.7 与 100.4 之间 → 返回 2</span></span><br><span class="line">5) (<span class="built_in">integer</span>) 2    <span class="comment"># 100.4: 第 2 位 → 20，真实存在的位数</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 3    <span class="comment"># 200: 大于 100.4 → 返回 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向排名</span></span><br><span class="line"><span class="comment"># TDIGEST.REVRANK key value [value ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.REVRANK latency:td 0 12.3 15.7 20 100.4 200</span><br></pre></td></tr></table></figure><h2 id="根据排名获取元素">根据排名获取元素</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向排名</span></span><br><span class="line"><span class="comment"># TDIGEST.BYRANK key rank [rank ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.BYRANK latency:td 0 1 2 3</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1) <span class="string">&quot;12.3&quot;</span></span><br><span class="line">2) <span class="string">&quot;15.7&quot;</span></span><br><span class="line">3) <span class="string">&quot;100.4&quot;</span></span><br><span class="line">4) <span class="string">&quot;inf&quot;</span>  <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向排名</span></span><br><span class="line"><span class="comment"># TDIGEST.BYREVRANK key rank [rank ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.BYREVRANK latency:td 0 1 2 3</span><br></pre></td></tr></table></figure><h3 id="计算-TDigest-内部样本-去掉尾部极值后的平均近似值（Trimmed-Mean，截断均值）">计算 TDigest 内部样本 去掉尾部极值后的平均近似值（Trimmed Mean，截断均值）</h3><ul class="lvl-0"><li class="lvl-2"><p>去掉数据分布的极端尾部，只算主要集中区域的平均值，这样更能代表“绝大多数用户的体验”</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.TRIMMED_MEAN key low_cut_quantile high_cut_quantile</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key： TDigest 的名称</span></span><br><span class="line"><span class="comment"># low_cut_quantile： 去掉的左侧百分比</span></span><br><span class="line"><span class="comment"># high_cut_quantile： 去掉的右侧百分比</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.TRIMMED_MEAN latency:td 0.05 0.95</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">&quot;42.800000000000004&quot;</span></span><br></pre></td></tr></table></figure><h3 id="获取-TDigest-的信息">获取 TDigest 的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.INFO key</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.INFO latency:td</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"> 1) Compression     <span class="comment"># 压缩级别，控制质心的数量与精度。值越大 → 精度越高，内存稍大。</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 200</span><br><span class="line"> 3) Capacity       <span class="comment"># 质心最大容量。表示内部能容纳的最大节点数，实际使用中 TDigest 会动态合并质心以控制内存。</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1210</span><br><span class="line"> 5) Merged nodes   <span class="comment"># 已合并的质心数量。这些是 TDigest 当前压缩后的节点，用于计算 rank / quantile。</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 3</span><br><span class="line"> 7) Unmerged nodes <span class="comment"># 未合并的节点数量。表示新加入但尚未压缩到质心的样本。</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 0</span><br><span class="line"> 9) Merged weight  <span class="comment"># 已合并质心的总权重。每个样本权重默认为 1，3 表示目前总共有 3 个样本被合并进质心。</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 3</span><br><span class="line">11) Unmerged weight <span class="comment"># 未合并节点的权重总和。0 表示没有未压缩的样本</span></span><br><span class="line">12) (<span class="built_in">integer</span>) 0</span><br><span class="line">13) Observations    <span class="comment"># 观测到的样本总数。你 TDIGEST.ADD 的 3 个样本正好对应这个值。</span></span><br><span class="line">14) (<span class="built_in">integer</span>) 3</span><br><span class="line">15) Total compressions <span class="comment"># 已经执行的压缩次数。每次 TDigest 内部质心合并称为一次压缩。</span></span><br><span class="line">16) (<span class="built_in">integer</span>) 1</span><br><span class="line">17) Memory usage     <span class="comment"># Redis 为这个 TDigest 分配的内存（字节）。包含质心、索引、结构开销。TDigest 内存使用是固定的、与样本数量无关（主要由 Compression 决定）</span></span><br><span class="line">18) (<span class="built_in">integer</span>) 19368</span><br></pre></td></tr></table></figure><h3 id="清空元素">清空元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TDIGEST.RESET key</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">TDIGEST.RESET latency:td</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="TDigest-的内存与精度">TDigest 的内存与精度</h2><table><thead><tr><th>维度</th><th>特性</th></tr></thead><tbody><tr><td>内存占用</td><td>与 COMPRESSION 成正比（通常 KB 级）</td></tr><tr><td>精度</td><td>尾部分位数（P95/P99）极高</td></tr><tr><td>写入复杂度</td><td>近似 O(log n)</td></tr><tr><td>查询复杂度</td><td>O(log n)</td></tr></tbody></table><blockquote><p>与样本数量无关。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisBloom 的安装参见 &lt;a href=&quot;/2025/12/21/redis7-module-RedisBloom/&quot; title=&quot;Redis 扩展模块 -- RedisBloom&quot;&gt;Redis 扩展模块 -- RedisBloom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- TopK</title>
    <link href="https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/"/>
    <id>https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/</id>
    <published>2025-12-23T06:50:05.000Z</published>
    <updated>2025-12-24T03:37:03.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisBloom 的安装参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul><span id="more"></span><h2 id="TopK">TopK</h2><ul class="lvl-0"><li class="lvl-2"><p>TopK，专门用于解决 “在海量数据流中，实时找出最热门的 N 个元素” 这一类问题</p></li><li class="lvl-2"><p>Top-K 属于流式重频（Heavy Hitters）算法家族，其目标不是记录所有元素，而是：</p><ul class="lvl-2"><li class="lvl-6">在受限内存下，持续维护出现频率最高的 K 个元素</li></ul></li><li class="lvl-3"><p>TopK 的核心特性</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定容量：只维护 K 个元素</span><br><span class="line">近似统计：计数可能略有误差</span><br><span class="line">自动淘汰：低频元素会被踢出</span><br><span class="line">写入极快：适合高 QPS</span><br><span class="line">内存稳定：与数据规模无关</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>RedisBloom 的 TopK 内部使用 CMS 作为频次估算基础，并结合<code>堆+淘汰策略</code>来维护热点集合。</p><ul class="lvl-2"><li class="lvl-6">CMS: 参考 <a href="/2025/12/23/redis7-datatype-13-CMS/" title="Redis 命令及数据类型 -- CMS(Count-Min Sketch)">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li><li class="lvl-6">堆+淘汰策略: TopK 在内部如何决定谁能进入 TopK、谁必须被踢出 TopK 的一整套机制。<ul class="lvl-4"><li class="lvl-10">堆：TopK 使用一个最小堆来维护 TopK 元素，TopK 维护 K 个候选元素，堆顶永远是 当前 TopK 中频次最低的那个</li><li class="lvl-10">淘汰策略：TopK 使用一个 LRU 缓存来记录最近访问的元素，当 TopK 元素数量达到上限时，将 LRU 缓存中的元素逐个加入 TopK，并更新 TopK 元素的频率。</li><li class="lvl-10">一句话：当新元素的估算频次超过当前最弱的那个时，就把弱者淘汰掉，让新元素进榜。</li></ul></li></ul></li></ul><h3 id="当一个新元素到来时，我该不该让它进入-TopK？">当一个新元素到来时，我该不该让它进入 TopK？</h3><ul class="lvl-0"><li class="lvl-2"><p>下面是 TopK 在 TOPK.ADD 时的真实逻辑抽象</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1：更新 CMS（不存 item，只更新计数器）</span></span><br><span class="line">CMS.increment(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2：item 是否在 TopK 显式集合中？</span></span><br><span class="line"><span class="keyword">if</span> item <span class="keyword">in</span> TopK:</span><br><span class="line">    <span class="comment"># 重新平衡堆位置</span></span><br><span class="line">    update_heap(item)</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3：TopK 是否未满？</span></span><br><span class="line"><span class="keyword">if</span> TopK.size &lt; K:</span><br><span class="line">    TopK.insert(item)</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4：比较 CMS 估算值</span></span><br><span class="line">freq_new = CMS.query(item)</span><br><span class="line">freq_min = CMS.query(TopK.min_item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> freq_new &gt; freq_min:</span><br><span class="line">    TopK.evict_min()</span><br><span class="line">    TopK.insert(item)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 什么都不做</span></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h2 id="TopK-的应用场景">TopK 的应用场景</h2><table><thead><tr><th>问题</th><th>TopK 是否适合</th></tr></thead><tbody><tr><td>当前访问量最高的 URL</td><td>✅</td></tr><tr><td>搜索热词 Top 10</td><td>✅</td></tr><tr><td>商品点击榜</td><td>✅</td></tr><tr><td>所有商品的点击次数</td><td>❌</td></tr><tr><td>精确计数</td><td>❌</td></tr></tbody></table><h2 id="RedisBloom-TopK-的核心命令">RedisBloom TopK 的核心命令</h2><h3 id="创建-TopK">创建 TopK</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 TopK 前必须先创建 TopK</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.RESERVE key topk [width depth decay]</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key: 键名</span></span><br><span class="line"><span class="comment"># topk: 存储的元素数量，即统计的前 K 个元素</span></span><br><span class="line"><span class="comment"># width: 内部CMS 的宽度，默认 8</span></span><br><span class="line"><span class="comment"># depth: 内部CMS 的深度，默认 7</span></span><br><span class="line"><span class="comment"># decay: 衰减因子（0 ~ 1），默认 0.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：维护访问量最高的 100 个 URL，允许历史热度逐渐衰减。</span></span><br><span class="line">TOPK.RESERVE topk:urls 100 2000 7 0.9</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证类型</span></span><br><span class="line"><span class="built_in">type</span> topk:urls</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">TopK-TYPE</span><br></pre></td></tr></table></figure><h3 id="添加元素">添加元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.ADD key items [items ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：添加元素 &quot;a&quot; 和 &quot;b&quot; 到 TopK 中</span></span><br><span class="line">TOPK.ADD topk:urls a b</span><br><span class="line"><span class="comment"># 返回值，被挤出 TopK 的元素（如果有）</span></span><br><span class="line">1) (nil)</span><br><span class="line">2) (nil)</span><br></pre></td></tr></table></figure><h3 id="增加元素的频率">增加元素的频率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.INCRBY key item increment [item increment ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：将元素 &quot;a&quot; 的频率增加 1</span></span><br><span class="line">TOPK.INCRBY topk:urls a 1</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure><h3 id="查询元素是否在-TopK-中">查询元素是否在 TopK 中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.QUERY key item [item ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：查询元素 &quot;a&quot; 是否在 TopK 中</span></span><br><span class="line">TOPK.QUERY topk:urls a</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1 <span class="comment"># 1 表示元素 &quot;a&quot; 在 TopK 中，0 表示元素 &quot;a&quot; 不在 TopK 中</span></span><br></pre></td></tr></table></figure><h3 id="获取-TopK-中的元素">获取 TopK 中的元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.LIST key [WITHCOUNT]</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># WITHCOUNT: 是否返回每个元素出现的次数，默认不返回</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：获取 TopK 中的元素，并返回每个元素出现的次数</span></span><br><span class="line">TOPK.LIST topk:urls WITHCOUNT</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="获取近似计数">获取近似计数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.COUNT key item [item ...]</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：获取元素 &quot;a&quot; 的近似计数</span></span><br><span class="line">TOPK.COUNT topk:urls a</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="查看TopK-的状态">查看TopK 的状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOPK.INFO key</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 含义：查看 TopK 的状态</span></span><br><span class="line">TOPK.INFO topk:urls</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">1) k                    <span class="comment"># topk 的大小</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 100</span><br><span class="line">3) width                <span class="comment"># 内部 CMS 的宽度</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 2000</span><br><span class="line">5) depth                <span class="comment"># 内部 CMS 的深度</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 7</span><br><span class="line">7) decay                <span class="comment"># 衰减因子</span></span><br><span class="line">8) <span class="string">&quot;0.9&quot;</span></span><br></pre></td></tr></table></figure><h2 id="TopK-的衰减（decay）参数怎么理解">TopK 的衰减（decay）参数怎么理解</h2><ul class="lvl-0"><li class="lvl-2"><p>decay 用于解决一个问题：“老热点永远霸榜，新热点上不来”</p></li></ul><table><thead><tr><th>decay</th><th>行为</th></tr></thead><tbody><tr><td>1.0</td><td>永不衰减（全历史统计）</td></tr><tr><td>0.9</td><td>越老的数据权重越低</td></tr><tr><td>0.5</td><td>热点更新非常快</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>经验值：</p><ul class="lvl-2"><li class="lvl-6">实时热点：0.8 ~ 0.9</li><li class="lvl-6">长周期榜单：0.95 ~ 1.0</li></ul></li></ul><h2 id="CMS-和-TopK-组合使用场景">CMS 和 TopK 组合使用场景</h2><h3 id="📌场景1：-实时热搜榜（最经典组合）">📌场景1： 实时热搜榜（最经典组合）</h3><ul class="lvl-0"><li class="lvl-2"><p>需求：统计所有搜索词频次（CMS），同时实时出TOP10热搜（TOPK），既知热度又能排序</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化CMS（统计全量搜索词计数，误差0.001）</span></span><br><span class="line">cms.initbyprob search_count 0.001 0.01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初始化TOPK（取TOP10热搜）</span></span><br><span class="line">topk.reserve search_top10 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 用户搜索核心操作（2命令必一起执行）</span></span><br><span class="line"><span class="comment"># 搜索&quot;周杰伦&quot;，CMS计数+1，同时录入TOPK（自动累加热度）</span></span><br><span class="line">cms.incrby search_count 周杰伦 1</span><br><span class="line">topk.incrby search_top10 周杰伦 1</span><br><span class="line"></span><br><span class="line">cms.incrby search_count 原神 1</span><br><span class="line">topk.incrby search_top10 原神 1</span><br><span class="line">cms.incrby search_count 周杰伦 1  <span class="comment"># 重复搜索，双端同步+1</span></span><br><span class="line">topk.incrby search_top10 周杰伦 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 核心查询：先取TOP10，再查精准计数（组合核心）</span></span><br><span class="line"><span class="comment"># 第一步：取TOP10热搜列表</span></span><br><span class="line">topk.list search_top10  <span class="comment"># 返回：周杰伦、原神...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：查热搜词精准近似计数（CMS比TOPK.count更准）</span></span><br><span class="line">cms.query search_count 周杰伦  <span class="comment"># 返回2（精准）</span></span><br><span class="line">topk.count search_top10 周杰伦  <span class="comment"># 参考值，优先用CMS结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 辅助查询：判断词是否在热搜榜</span></span><br><span class="line">topk.query search_top10 周杰伦  <span class="comment"># 1=在，0=不在</span></span><br></pre></td></tr></table></figure><h2 id="TopK-vs-ZSET">TopK vs ZSET</h2><ul class="lvl-0"><li class="lvl-2"><p>能力边界对比</p></li></ul><table><thead><tr><th>能力</th><th>TopK</th><th>ZSet</th></tr></thead><tbody><tr><td>是否近似</td><td>✔️ 是</td><td>❌ 否</td></tr><tr><td>是否保存全部元素</td><td>❌ 只保存 Top K</td><td>✔️ 保存全部</td></tr><tr><td>频次是否精确</td><td>❌ 估计</td><td>✔️ 精确</td></tr><tr><td>是否支持排序</td><td>⚠️ 仅 Top K</td><td>✔️ 全量排序</td></tr><tr><td>是否可遍历</td><td>❌ 仅 K 个</td><td>✔️ 全量</td></tr><tr><td>是否支持删除</td><td>❌ 不支持</td><td>✔️ 支持</td></tr><tr><td>是否支持范围查询</td><td>❌</td><td>✔️</td></tr><tr><td>Top N 查询</td><td>✔️ 原生</td><td>✔️</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>性能与吞吐量对比</p></li></ul><table><thead><tr><th>维度</th><th>TopK</th><th>ZSet</th></tr></thead><tbody><tr><td>写入复杂度</td><td>O(d)</td><td>O(log N)</td></tr><tr><td>高并发写入</td><td>极优</td><td>一般</td></tr><tr><td>查询 TopK</td><td>O(K)</td><td>O(K)</td></tr><tr><td>查询单元素频次</td><td>O(d)</td><td>O(1)</td></tr><tr><td>批量写入</td><td>极快</td><td>较慢</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisBloom 的安装参见 &lt;a href=&quot;/2025/12/21/redis7-module-RedisBloom/&quot; title=&quot;Redis 扩展模块 -- RedisBloom&quot;&gt;Redis 扩展模块 -- RedisBloom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- CMS(Count-Min Sketch)</title>
    <link href="https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/"/>
    <id>https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/</id>
    <published>2025-12-23T06:40:05.000Z</published>
    <updated>2025-12-24T03:38:33.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisBloom 的安装参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul><span id="more"></span><h2 id="Count-Min-Sketch">Count-Min Sketch</h2><ul class="lvl-0"><li class="lvl-2"><p>Count-Min Sketch（CMS） 用于在极低内存占用下，对高频写入的计数型数据进行近似统计，非常适合流量、事件、关键词等“只关心频次规模、不要求精确值”的场景。</p></li><li class="lvl-2"><p>Count-Min Sketch 是一种基于哈希的概率型计数结构，用于估算元素出现次数，具有以下核心特征：</p><ul class="lvl-2"><li class="lvl-6">只会高估，不会低估（over-estimation）</li><li class="lvl-6">固定内存，与元素种类数无关</li><li class="lvl-6">O(1) 的更新与查询复杂度</li><li class="lvl-6">不支持删除（或只能近似删除）</li><li class="lvl-6">只能返回给定元素近似统计其频次，而无法返回全部元素的统计频次</li></ul></li><li class="lvl-2"><p>基本工作原理（简化版）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.初始化一个二维数组 counter[d][w]</span><br><span class="line">2.对每个元素 x：</span><br><span class="line">    a. 通过 d 个哈希函数映射到 d 行中的 w 个位置</span><br><span class="line">    b. 对对应的 d 个计数器全部 +1</span><br><span class="line">3.查询元素 x 的频次：</span><br><span class="line">    a.取这 d 个计数器的 最小值(取最小值是为了尽量抵消哈希冲突带来的“多加”)</span><br></pre></td></tr></table></figure><blockquote><p>注意下图中的数组不是二进制的，每次映射都会+1<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Ybl5tj.png" alt=""></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>误差与空间复杂度</p></li></ul><table><thead><tr><th>维度</th><th>说明</th></tr></thead><tbody><tr><td>误差上界</td><td>≤ ε × 总插入次数</td></tr><tr><td>错误概率</td><td>≤ δ</td></tr><tr><td>空间复杂度</td><td>O(1 / ε × log(1 / δ))</td></tr><tr><td>查询复杂度</td><td>O(d)</td></tr><tr><td>更新复杂度</td><td>O(d)</td></tr></tbody></table><blockquote><p>结论：数据量再大，内存不增长，代价是“精度换空间”</p></blockquote><h2 id="RedisBloom-中-CMS-的核心命令">RedisBloom 中 CMS 的核心命令</h2><h3 id="创建-CMS">创建 CMS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按底层维度初始化</span></span><br><span class="line"><span class="comment"># CMS.INITBYDIM key width depth</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># width (w)：每一行的桶数（影响误差）</span></span><br><span class="line"><span class="comment"># depth (d)：哈希函数数量（影响冲突概率）</span></span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">CMS.INITBYDIM page:view 1000 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证类型</span></span><br><span class="line"><span class="built_in">type</span> page:view</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">CMSk-TYPE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按误差+容量初始化</span></span><br><span class="line"><span class="comment"># CMS.INITBYPROB page:view error probability</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># error (ε)：误差上界</span></span><br><span class="line"><span class="comment"># probability (δ)：超过误差上界的概率，这个数字越接近零，每个项目的内存消耗就越大，每次操作的CPU使用就越多。</span></span><br><span class="line"><span class="comment"># RedisBloom 会自动换算 w 和 d</span></span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">CMS.INITBYPROB key 0.001 0.01</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>数值</th><th>说明</th></tr></thead><tbody><tr><td><code>error</code></td><td><code>0.001</code></td><td>最大相对误差 ε = 0.1%</td></tr><tr><td><code>probability</code></td><td><code>0.01</code></td><td>只有 1% 的概率超过该误差</td></tr></tbody></table><h3 id="增加计数">增加计数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS.INCRBY key item1 count1 item2 count2 ...</span></span><br><span class="line">CMS.INCRBY page:view home 1 about 1 home 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="查询计数">查询计数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS.QUERY key item1 item2 ...</span></span><br><span class="line">CMS.QUERY page:view home about</span><br><span class="line"><span class="comment"># 返回的是 估算值（可能偏大）</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 2</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="合并-CMS">合并 CMS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS.MERGE dest numkeys src1 src2 ... WEIGHTS w1 w2 ...</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># dest：目标 CMS，必须存在</span></span><br><span class="line"><span class="comment"># numkeys：源 CMS 数量</span></span><br><span class="line"><span class="comment"># src1 src2 ...：源 CMS，必须存在</span></span><br><span class="line"><span class="comment"># WEIGHTS w1 w2 ...：源 CMS 权重</span></span><br><span class="line">CMS.MERGE page:view 2 page:view:1 page:view:2 WEIGHTS 1 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="获取-CMS-的信息">获取 CMS 的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS.INFO key</span></span><br><span class="line">CMS.INFO page:view</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) width            <span class="comment"># 每一行桶数 w</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 1000</span><br><span class="line">3) depth            <span class="comment"># 哈希函数数量 d</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 10</span><br><span class="line">5) count            <span class="comment"># 当前已插入的元素数量</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="CMS-的使用场景">CMS 的使用场景</h2><h3 id="场景1：网站PV统计">场景1：网站PV统计</h3><ul class="lvl-0"><li class="lvl-2"><p>需求：统计网站 PV，即页面被访问的次数，允许0.1%的误差</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 CMS</span></span><br><span class="line">CMS.INITBYPROB page:pv 0.001 0.01</span><br><span class="line"><span class="comment"># 添加计数</span></span><br><span class="line">CMS.INCRBY page:pv /home 1 /about 1</span><br><span class="line">CMS.INCRBY page:pv /home 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询计数</span></span><br><span class="line">CMS.QUERY page:pv /home</span><br></pre></td></tr></table></figure><h3 id="场景2：接口调用频次限流前置统计">场景2：接口调用频次限流前置统计</h3><ul class="lvl-0"><li class="lvl-2"><p>需求：统计接口调用次数，为限流提供已经，不需要精准计数，允许0.1%的误差</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 CMS</span></span><br><span class="line">CMS.INITBYPROB api:<span class="built_in">limit</span> 0.001 0.01</span><br><span class="line"><span class="comment"># 添加计数</span></span><br><span class="line">CMS.INCRBY api:<span class="built_in">limit</span> /api/user/list 1</span><br><span class="line"><span class="comment"># 获取计数</span></span><br><span class="line">CMS.QUERY api:<span class="built_in">limit</span> /api/user/list</span><br></pre></td></tr></table></figure><h2 id="CMS-vs-ZSET">CMS vs ZSET</h2><ul class="lvl-0"><li class="lvl-2"><p>能力边界对比</p></li></ul><table><thead><tr><th>能力</th><th>CMS</th><th>ZSet</th></tr></thead><tbody><tr><td>频次统计</td><td>✔️ 近似</td><td>✔️ 精确</td></tr><tr><td>是否存元素</td><td>❌ 不存</td><td>✔️ 存</td></tr><tr><td>是否可遍历元素</td><td>❌ 不可</td><td>✔️ 可</td></tr><tr><td>TopK / 排行</td><td>❌（需配合 TopK）</td><td>✔️ 天然支持</td></tr><tr><td>删除元素</td><td>❌ 不支持</td><td>✔️ 支持</td></tr><tr><td>误判 / 误差</td><td>✔️ 存在</td><td>❌ 无</td></tr><tr><td>是否可逆（查成员）</td><td>❌ 不可逆</td><td>✔️ 可逆</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>性能特征对比</p></li></ul><table><thead><tr><th>操作</th><th>CMS</th><th>ZSet</th></tr></thead><tbody><tr><td>插入 / 计数</td><td>O(d)（常数级）</td><td>O(log N)</td></tr><tr><td>查询频次</td><td>O(d)</td><td>O(1)</td></tr><tr><td>排名查询</td><td>❌</td><td>O(log N)</td></tr><tr><td>批量写入</td><td>极快</td><td>中等</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisBloom 的安装参见 &lt;a href=&quot;/2025/12/21/redis7-module-RedisBloom/&quot; title=&quot;Redis 扩展模块 -- RedisBloom&quot;&gt;Redis 扩展模块 -- RedisBloom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- CF(Cuckoo Filter)</title>
    <link href="https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/"/>
    <id>https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/</id>
    <published>2025-12-22T06:40:05.000Z</published>
    <updated>2025-12-24T03:27:09.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisBloom 的安装参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul><span id="more"></span><h2 id="Cuckoo-Filter（布谷鸟过滤器）">Cuckoo Filter（布谷鸟过滤器）</h2><ul class="lvl-0"><li class="lvl-2"><p>Cuckoo Filter 是 Bloom Filter 的改进版，支持 动态添加和删除元素，仍能提供比布隆过滤器更高的查询性能。</p></li><li class="lvl-2"><p><a href="https://en.wikipedia.org/wiki/Cuckoo_filter">维基百科对 Cuckoo Filter 的描述</a></p></li><li class="lvl-2"><p>在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</p></li><li class="lvl-2"><p>优点：低误判率 + 高负载率，基于相同的集合和误报率，Cuckoo Filter通常占用空间更少。相对的，算法实现也就更复杂。</p></li><li class="lvl-2"><p>缺点：与Bloom Filter一样，有可能将一个不在集合中的元素错误的判断成在集合中</p></li><li class="lvl-2"><p>Bloom Filter 的误报率通过调整<code>位数组的大小</code>和<code>哈希函数数量</code>来控制，而 Cuckoo Filter 的误报率受<code>指纹大小</code>和<code>桶大小</code>控制。</p></li></ul><h3 id="布谷哈希算法">布谷哈希算法</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://baike.baidu.com/item/Cockoo%20hash/3022855">百度百科对布谷哈希算法的描述</a>]</p></li><li class="lvl-2"><p>算法使用两个不同哈希函数计算对应 key 的位置。</p><ul class="lvl-2"><li class="lvl-6"><ol><li class="lvl-9">当两个哈希任意位置为空，则随机选择一个位置插入</li></ol></li><li class="lvl-6"><ol start="2"><li class="lvl-9">当两个哈希有位置为空时，则插入到空位置</li></ol></li><li class="lvl-6"><ol start="3"><li class="lvl-9">当两个哈希位置均不为空时，随机选择一个位置插入并踢出原key，原key会再次经过计算获得新的位置，转至1执行，反复直到成功或者达到最大迭代次数。</li></ol></li></ul></li></ul><h3 id="Cuckoo-Filter-的实现原理">Cuckoo Filter 的实现原理</h3><ul class="lvl-0"><li class="lvl-2"><p>布谷过滤器 是在<code>布谷哈希算法</code>的算法基础上扩充来的，但是它所提供的概念不是表，而是提供了多个数据桶(Bucket)</p></li><li class="lvl-2"><p>每一个数据桶都是个<code>一维数组</code>，每个数组的保存内容为<code>条目(Entry)</code>，每一个条目里面可以保存一个<code>指纹数据</code>(指纹数据就是原始数据经过哈希计算得到的一个n位的数据标记)，除了指纹数据之外，还会同时得出一个<code>保存位置P1标记</code>。</p></li><li class="lvl-2"><p>当两个数据计算得到的指纹数据相同时，就会发生冲突，冲突操作的解决思路是使用<code>布谷哈希算法</code>，简单说就是新的数据会将原有数据<code>踢出</code>，而被踢出的数据会被重新计算得到新的指纹数据和保存位置标记。</p></li><li class="lvl-2"><p>布谷过滤器里面需要进行各种数据的<code>踢出</code>操作，这个踢出的方式就是使用<code>P1标志位</code>和<code>指纹数据</code>进行<code>异或计算</code>得出来的<code>P2标志位</code>，按照同样的思路(前提:一直都有冲突操作)一直计算新的P2位，直到冲突解决或者达到最大迭代次数，就会失败。</p></li><li class="lvl-2"><p>指纹数据里面包含有<code>唯一性</code>，所以可以实现数据的删除，当然，不同的数据计算是有可能得到相同指纹的，那么一旦删除数据之后，有可能造成数据的&quot;假删除&quot;，所以布谷过滤器本身也是存在有误差的。</p></li><li class="lvl-2"><p>Cuckoo Filter 中的 <code>BUSKETSIZE</code></p><ul class="lvl-2"><li class="lvl-6">BUSKETSIZE，表示每个桶(Busket)中存放的元素个数，即桶大小。</li><li class="lvl-6">Cuckoo Filter的数组里存的不是位，而是桶(busket)，每个桶里可以存放多个数据。</li><li class="lvl-6">同一个桶中存放的数据越多，空间利用率更高，相应的误判率也就越高，性能也更慢。</li><li class="lvl-6">Redis的CuckooFilter实现中，BUSKETSIZE应该是一个在1到255之间的整数，默认的 BUSKETSIZE 是 <code>2</code>。</li><li class="lvl-6">桶(Busket)中并不实际保存数据本身，而是保存数据的指纹(fingerprint)。指纹越小，HASH冲突造成误判的几率就越小。这个参数的调整比较复杂，Redis的CuckooFilter中不支持调整这个参数。</li></ul></li></ul><h2 id="CF-命令说明">CF 命令说明</h2><ul class="lvl-0"><li class="lvl-2"><p>对应Redis命令： <code>CF.xxx</code></p></li></ul><table><thead><tr><th>命令</th><th>功能说明</th><th>是否创建 Filter</th><th>关键参数含义</th><th>返回值</th><th>示例</th><th>使用要点 / 备注</th></tr></thead><tbody><tr><td><strong>CF.RESERVE</strong></td><td>显式创建 Cuckoo Filter</td><td>是</td><td><code>capacity</code>：容量(必填)<br><code>BUCKETSIZE</code>：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)<br><code>MAXITERATIONS</code>：重排次数，越大成功率越高<br><code>EXPANSION</code>：扩容倍数，默认 1（不扩容）</td><td>OK</td><td><code>CF.RESERVE user:cf 100000</code></td><td>✅ <strong>生产推荐</strong><br>支持删除与计数</td></tr><tr><td><strong>CF.ADD</strong></td><td>添加一个元素，不去重</td><td>是 （不存在则创建）</td><td><code>item</code>：元素</td><td>OK</td><td><code>CF.ADD user:cf user_1</code></td><td>若满可能失败</td></tr><tr><td><strong>CF.ADDNX</strong></td><td>元素不存在时才添加，去重</td><td>是 （不存在则创建）</td><td><code>item</code></td><td><code>1</code> 新增<br><code>0</code> 已存在</td><td><code>CF.ADDNX user:cf user_1</code></td><td>幂等写入首选</td></tr><tr><td><strong>CF.INSERT</strong></td><td>批量插入</td><td>是（不存在则创建）</td><td><code>ITEMS</code>：元素列表</td><td>OK</td><td><code>CF.INSERT user:cf ITEMS u1 u2</code></td><td>默认配置</td></tr><tr><td><strong>CF.INSERTNX</strong></td><td>批量插入（不存在才加）</td><td>是</td><td><code>ITEMS</code></td><td><code>0/1</code> 列表</td><td><code>CF.INSERTNX user:cf ITEMS u1 u2</code></td><td>幂等 + 批量</td></tr><tr><td><strong>CF.EXISTS</strong></td><td>判断单个元素是否存在</td><td>否</td><td><code>item</code></td><td><code>1</code> 可能存在<br><code>0</code> 不存在</td><td><code>CF.EXISTS user:cf user_1</code></td><td>仍有误判</td></tr><tr><td><strong>CF.MEXISTS</strong></td><td>批量判断是否存在</td><td>否</td><td><code>item...</code></td><td><code>0/1</code> 列表</td><td><code>CF.MEXISTS user:cf u1 u9</code></td><td>高并发推荐</td></tr><tr><td><strong>CF.COUNT</strong></td><td>返回元素出现次数</td><td>否</td><td><code>item</code></td><td>整数</td><td><code>CF.COUNT user:cf user_1</code></td><td>⭐ Bloom 没有的能力</td></tr><tr><td><strong>CF.DEL</strong></td><td>删除一个元素</td><td>否</td><td><code>item</code></td><td><code>1</code> 删除成功<br><code>0</code> 不存在</td><td><code>CF.DEL user:cf user_1</code></td><td>⭐ Bloom 不支持</td></tr><tr><td><strong><a href="http://CF.INFO">CF.INFO</a></strong></td><td>查看 Filter 元信息</td><td>否</td><td>无</td><td>KV 列表</td><td><code>CF.INFO user:cf</code></td><td>运维分析</td></tr><tr><td><strong>CF.SCANDUMP</strong></td><td>分块导出 Filter</td><td>否</td><td><code>iterator</code></td><td><code>iterator + data</code></td><td><code>CF.SCANDUMP user:cf 0</code></td><td>迁移 / 备份</td></tr><tr><td><strong>CF.LOADCHUNK</strong></td><td>从 dump 恢复 Filter</td><td>是</td><td><code>iterator + data</code></td><td>OK</td><td><code>CF.LOADCHUNK user:cf 1 &quot;xxx&quot;</code></td><td>与 SCANDUMP 配合</td></tr></tbody></table><h2 id="Bloom-vs-Cuckoo">Bloom vs Cuckoo</h2><table><thead><tr><th>维度</th><th>Bloom Filter</th><th>Cuckoo Filter</th></tr></thead><tbody><tr><td>查询复杂度</td><td>O(k)（k 个哈希函数）</td><td>O(1)（2–4 次 bucket 访问）</td></tr><tr><td>插入复杂度</td><td>O(k)</td><td>平均 O(1)，最坏可能触发重排</td></tr><tr><td>删除支持</td><td>❌ 原生不支持</td><td>✅ 原生支持</td></tr><tr><td>误判率（False Positive）</td><td>可配置，稳定</td><td>可配置，通常更低</td></tr><tr><td>漏判（False Negative）</td><td>❌ 理论上不会</td><td>❌ 理论上不会</td></tr><tr><td>空间利用率</td><td>高（但受 k 影响）</td><td>通常更高（特别是低误判率）</td></tr><tr><td>扩容成本</td><td>高（需重建）</td><td>中等（支持扩展策略）</td></tr><tr><td>实现复杂度</td><td>低</td><td>较高</td></tr></tbody></table><blockquote><p>RedisBloom Cuckoo Filter 不支持设置 <code>误判率</code>，通常 容量 越大，误判率越低。</p></blockquote><h2 id="CF-命令示例">CF 命令示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Cuckoo Filter</span></span><br><span class="line"><span class="comment">## 容量1000，这个是必填参数。后面几个都是可选参数。</span></span><br><span class="line"><span class="comment">## BUSKETSIZE越大，空间利用率更高，但是误判率也更高，性能更差，默认2</span></span><br><span class="line"><span class="comment">## MAXITARATIONS越小，性能越好。如果设置越大，空间利用率就越好。默认20</span></span><br><span class="line"><span class="comment">## EXPANSION 是指空间扩容的比例。默认1，不扩容</span></span><br><span class="line">127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; CF.ADD user:cf user_2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 可以重复添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 返回元素出现次数</span></span><br><span class="line">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 判断元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; CF.EXISTS user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 批量判断元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_100</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 删除元素，一次只删除一个</span></span><br><span class="line">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 因为user_1有两个，所以才是还是能查询出 user_1</span></span><br><span class="line">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 再次删除</span></span><br><span class="line">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 同名元素已全部删除，查询不到</span></span><br><span class="line">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素不存在时才添加，幂等</span></span><br><span class="line">127.0.0.1:6379&gt; CF.ADDNX user:cf user_2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; CF.ADDNX user:cf user_3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Filter 元信息</span></span><br><span class="line">127.0.0.1:6379&gt; CF.INFO user:cf</span><br><span class="line"> 1) Size                      <span class="comment"># 当前 Cuckoo Filter 实际占用的内存大小（字节）</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 1080</span><br><span class="line"> 3) Number of buckets         <span class="comment"># 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2)</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 512</span><br><span class="line"> 5) Number of filters         <span class="comment"># 内部 子 Cuckoo Filter 的数量</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 7) Number of items inserted  <span class="comment"># 成功插入的元素总数（近似）</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 9) Number of items deleted   <span class="comment"># 已删除元素的累计次数</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 2</span><br><span class="line">11) Bucket size               <span class="comment"># 每个 bucket 可容纳的 fingerprint 数，默认为 2</span></span><br><span class="line">12) (<span class="built_in">integer</span>) 2</span><br><span class="line">13) Expansion rate            <span class="comment"># 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）</span></span><br><span class="line">14) (<span class="built_in">integer</span>) 2</span><br><span class="line">15) Max iterations            <span class="comment"># Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升</span></span><br><span class="line">16) (<span class="built_in">integer</span>) 500</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加，key不存在则创建</span></span><br><span class="line">127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order2</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 幂等，元素不存在时才添加</span></span><br><span class="line">127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order100</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> order:cf</span><br><span class="line">MBbloomCF</span><br></pre></td></tr></table></figure><h2 id="SpringBoot-集成">SpringBoot 集成</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisCuckooFilterTool</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.redisbloom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 RedisBloom 插件的 CuckooFilter 实现</span></span><br><span class="line"><span class="comment"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCuckooFilterTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCuckooFilterTool</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 Cuckoo Filter</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 不能重复创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      Filter 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 预计容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reserve</span><span class="params">(String key, <span class="type">long</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot;</span> + capacity + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            redisTemplate.execute(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class="line">                    Collections.singletonList(key)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 Cuckoo Filter（高级参数）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不能重复创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key           Filter 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity      预计容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketSize    每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxIterations 重排次数，越大成功率越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expansion     扩容倍数，默认 1（不扩容）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reserve</span><span class="params">(String key, <span class="type">long</span> capacity, <span class="type">int</span> bucketSize, <span class="type">int</span> maxIterations, <span class="type">int</span> expansion)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> String.format(</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;</span>,</span><br><span class="line">                capacity, bucketSize, maxIterations, expansion</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            redisTemplate.execute(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class="line">                    Collections.singletonList(key)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素（不去重）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素（仅当不存在时）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示成功插入，false 表示已存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addNx</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断元素是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量判断是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 每个元素对应的结果，1 表示存在，0 表示不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">mexists</span><span class="params">(String key, String... items)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                items</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回元素出现次数（近似）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">count</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 删除成功，false 表示不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入，不去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">insert</span><span class="params">(String key, String... items)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                items</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入，去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">insertNx</span><span class="params">(String key, String... items)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                items</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Cuckoo Filter 元信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Long&gt; <span class="title function_">info</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class="line">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; infoMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> toString(result.get(i));</span><br><span class="line">            <span class="type">Long</span> <span class="variable">value</span> <span class="operator">=</span> (Long) result.get(i + <span class="number">1</span>);</span><br><span class="line">            infoMap.put(field, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> infoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转字符串</span></span><br><span class="line"><span class="comment">     * info 返回的 List</span></span><br><span class="line"><span class="comment">     * [</span></span><br><span class="line"><span class="comment">     * byte[](&quot;Size&quot;),                  Long(1080),</span></span><br><span class="line"><span class="comment">     * byte[](&quot;Number of buckets&quot;),     Long(512),</span></span><br><span class="line"><span class="comment">     * byte[](&quot;Number of filters&quot;),     Long(1),</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * ]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toString</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="type">byte</span>[]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>((<span class="type">byte</span>[]) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisBloom 的安装参见 &lt;a href=&quot;/2025/12/21/redis7-module-RedisBloom/&quot; title=&quot;Redis 扩展模块 -- RedisBloom&quot;&gt;Redis 扩展模块 -- RedisBloom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- BF(Bloom Filter)</title>
    <link href="https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/"/>
    <id>https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/</id>
    <published>2025-12-22T05:40:05.000Z</published>
    <updated>2025-12-23T06:22:51.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">RedisBloom 的安装参见 <a href="/2025/12/21/redis7-module-RedisBloom/" title="Redis 扩展模块 -- RedisBloom">Redis 扩展模块 -- RedisBloom</a></li></ul><span id="more"></span><h2 id="Bloom-Filter-布隆过滤器">Bloom Filter(布隆过滤器)</h2><ul class="lvl-0"><li class="lvl-2"><p>布隆过滤器是一种用于快速判断元素是否存在的 probabilistic data structure（概率数据结构），非常适合海量数据且不要求绝对精确的场景。</p></li><li class="lvl-2"><p><a href="https://en.wikipedia.org/wiki/Bloom_filter">维基百科对 Bloom Filter 的描述</a></p></li><li class="lvl-2"><p>生产环境推荐使用 <a href="https://redisson.pro/docs/data-and-services/objects/#bloom-filter">Redisson的布隆过滤器</a></p></li><li class="lvl-2"><p>布隆过滤器使用一个很长的二进制位数组和一系列哈希函数来保存元素。</p><ul class="lvl-2"><li class="lvl-6">优点: 非常节省空间、查询快</li><li class="lvl-6">缺点: 有一定的误判概率、无法删除元素、无法给元素计数</li></ul></li><li class="lvl-2"><p>布隆过滤器判断一个元素不在集合中，那么这个元素肯定不在集合中。但是，布隆过滤器判断一个元素在集合中，那么这个元素有可能不在集合中。<br><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/l7rGDM.png" alt=""></p></li><li class="lvl-2"><p>位数组（Bit Array）：布隆过滤器使用一个长度固定的位数组来存储数据。每个位置只占用一个比特（0或1），初始时所有位都设置为0。位数组的长度和哈希函数的数量决定了过滤器的误报率和容量。</p></li><li class="lvl-2"><p>哈希函数集合：布隆过滤器使用多个哈希函数，每个函数都会将输入数据映射到位数组的一个不同位置。哈希函数的选择对过滤器的性能有很大影响，理想的哈希函数应该具有良好的散列性，使得不同的输入尽可能均匀地映射到位数组的不同位置。</p></li><li class="lvl-2"><p>如何降低误判率？</p><ul class="lvl-2"><li class="lvl-6">更大的位数组</li><li class="lvl-6">更多的哈希函数</li></ul></li><li class="lvl-2"><p>很多人都是用过Google开源的Guava的布隆过滤器，但其是JVM层的布隆过滤器，若需要分布式布隆过滤器，就可以使用RedisBloom提供的BF(Bloom Filter)。</p></li></ul><h2 id="BF-命令说明">BF 命令说明</h2><ul class="lvl-0"><li class="lvl-2"><p>对应Redis命令： <code>BF.xxx</code></p></li></ul><table><thead><tr><th>命令</th><th>功能说明</th><th>是否创建 Filter</th><th>关键参数含义</th><th>返回值</th><th>示例</th><th>使用要点 / 备注</th></tr></thead><tbody><tr><td><strong>BF.RESERVE</strong></td><td>显式创建 Bloom Filter</td><td>是（已存在则报错）</td><td><code>error_rate</code>：误判率<br><code>capacity</code>：预计元素数<br><code>EXPANSION</code>：扩容倍率</td><td>OK</td><td><code>BF.RESERVE user:bf 0.001 1000000</code></td><td>✅ <strong>生产推荐</strong><br>显式规划容量与误判率，避免隐式创建</td></tr><tr><td><strong>BF.ADD</strong></td><td>添加单个元素</td><td>是（不存在则创建）</td><td>无</td><td><code>1</code> 新增<br><code>0</code> 可能已存在</td><td><code>BF.ADD user:bf user_1</code></td><td>Key 必须已存在，否则报错</td></tr><tr><td><strong>BF.MADD</strong></td><td>批量添加元素</td><td>是（不存在则创建）</td><td><code>item...</code>：多个元素</td><td><code>0/1</code> 列表</td><td><code>BF.MADD user:bf u1 u2 u3</code></td><td>⚠ 使用默认配置，不建议生产</td></tr><tr><td><strong>BF.INSERT</strong></td><td>批量插入（可控参数）</td><td>是</td><td><code>CAPACITY</code>：容量<br><code>ERROR</code>：误判率<br><code>NOCREATE</code>:不自动创建过滤器<br><code>NONSCALING</code>: 不扩容，达到capacity时，过滤器返回错误<br><code>EXPANSION expansion</code>:扩容时，新建子过滤器的容量增长倍率，默认2 <br><code>ITEMS</code>：元素列表</td><td><code>0/1</code> 列表</td><td><code>BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2</code></td><td>✅ <strong>最推荐的写入方式</strong><br>支持初始化 + 插入</td></tr><tr><td><strong>BF.EXISTS</strong></td><td>判断单个元素是否存在</td><td>否</td><td><code>item</code>：待判断元素</td><td><code>1</code> 可能存在<br><code>0</code> 一定不存在</td><td><code>BF.EXISTS user:bf user_1</code></td><td>不存在结果 <strong>绝对可靠</strong></td></tr><tr><td><strong>BF.MEXISTS</strong></td><td>批量判断是否存在</td><td>否</td><td><code>item...</code>：多个元素</td><td><code>0/1</code> 列表</td><td><code>BF.MEXISTS user:bf u1 u9</code></td><td>高并发批量查询首选</td></tr><tr><td><strong>BF.CARD</strong></td><td>返回插入元素数量（近似）</td><td>否</td><td>无</td><td>整数</td><td><code>BF.CARD user:bf</code></td><td>用于容量监控，非精确</td></tr><tr><td><strong><a href="http://BF.INFO">BF.INFO</a></strong></td><td>返回 Bloom Filter 元信息</td><td>否</td><td>无</td><td>KV 列表</td><td><code>BF.INFO user:bf</code></td><td>运维、容量与内存分析必备</td></tr><tr><td><strong>BF.SCANDUMP</strong></td><td>分块导出 Bloom Filter</td><td>否</td><td><code>iterator</code>：游标</td><td><code>iterator + data</code></td><td><code>BF.SCANDUMP user:bf 0</code></td><td>用于迁移、备份</td></tr><tr><td><strong>BF.LOADCHUNK</strong></td><td>从 dump 数据恢复 Filter</td><td>是</td><td><code>iterator</code><br><code>data</code></td><td>OK</td><td><code>BF.LOADCHUNK user:bf 1 &quot;xxx&quot;</code></td><td>必须与 SCANDUMP 配合使用</td></tr></tbody></table><h2 id="BF-命令示例">BF 命令示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个BloomFilter，错误率0.01，元素数量1000</span></span><br><span class="line">127.0.0.1:6379&gt; BF.RESERVE <span class="built_in">test</span> 0.01 1000</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line">MBbloom--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; BF.ADD <span class="built_in">test</span> user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD <span class="built_in">test</span> user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 批量添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; BF.MADD <span class="built_in">test</span> user3 user4 user5</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 返回Bloom过滤器的基数，即添加的元素数量(存在误差)</span></span><br><span class="line">127.0.0.1:6379&gt; BF.CARD <span class="built_in">test</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"><span class="comment"># 查询元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS <span class="built_in">test</span> user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS <span class="built_in">test</span> user6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 批量查询元素是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; BF.MEXISTS <span class="built_in">test</span> user1 user2 user6</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取信息</span></span><br><span class="line">127.0.0.1:6379&gt; BF.INFO <span class="built_in">test</span></span><br><span class="line"> 1) Capacity       <span class="comment"># 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter）</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 1000</span><br><span class="line"> 3) Size           <span class="comment"># 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1480</span><br><span class="line"> 5) Number of filters <span class="comment"># 当前 key 内部包含的 Bloom Filter 数量</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 7) Number of items inserted  <span class="comment"># 已调用 BF.ADD / BF.MADD 插入的元素总数</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 5</span><br><span class="line"> 9) Expansion rate     <span class="comment"># Bloom Filter 扩容时，新建子过滤器的容量增长倍率</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-集成">SpringBoot 集成</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisBloomFilterTool</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.redisbloom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 RedisBloom 插件的 BloomFilter 实现</span></span><br><span class="line"><span class="comment"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 不想安装插件也可以使用 Redission 的 BloomFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisBloomFilterTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisBloomFilterTool</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 BloomFilter</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 不能重复创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       BloomFilter 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorRate 错误率，比如为0.01，即 1%</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity  容量，比如为1000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reserve</span><span class="params">(String key, <span class="type">double</span> errorRate, <span class="type">long</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot;</span> + errorRate + <span class="string">&quot;, &quot;</span> + capacity + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.execute(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class="line">                    Collections.singletonList(key)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;RedisBloomFilterTool reserve error:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 RedisModule 提供的 BF.ADD 命令</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断元素是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                value</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(execute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">addBatch</span><span class="params">(String key, String... items)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 BF.MADD 命令</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                items</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       BloomFilter 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity  容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorRate 错误率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items     要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">insert</span><span class="params">(String key, <span class="type">long</span> capacity, <span class="type">double</span> errorRate, String... items)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], &#x27;CAPACITY&#x27;, ARGV[1], &#x27;ERROR&#x27;, ARGV[2], &#x27;ITEMS&#x27;, unpack(ARGV, 3))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        args.add(String.valueOf(capacity));</span><br><span class="line">        args.add(String.valueOf(errorRate));</span><br><span class="line">        Collections.addAll(args, items);   <span class="comment">// ✅ 关键点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BF.INSERT 命令</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                args.toArray()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量判断元素是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在 1，不存在 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">mexists</span><span class="params">(String key, String... items)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BF.MADD 命令</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                items</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">card</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用 RedisModule 提供的 BF.CARD 命令</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class="line">                Collections.singletonList(key)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Bloom Filter 元信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Long&gt; <span class="title function_">info</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class="line">                Collections.singletonList(key)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; infoMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> toString(result.get(i));</span><br><span class="line">            <span class="type">Long</span> <span class="variable">value</span> <span class="operator">=</span> (Long) result.get(i + <span class="number">1</span>);</span><br><span class="line">            infoMap.put(field, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> infoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toString</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="type">byte</span>[]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>((<span class="type">byte</span>[]) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;RedisBloom 的安装参见 &lt;a href=&quot;/2025/12/21/redis7-module-RedisBloom/&quot; title=&quot;Redis 扩展模块 -- RedisBloom&quot;&gt;Redis 扩展模块 -- RedisBloom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 扩展模块 -- RedisBloom</title>
    <link href="https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/"/>
    <id>https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/</id>
    <published>2025-12-21T13:30:05.000Z</published>
    <updated>2025-12-24T10:01:44.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis 扩展模块 – RedisBloom 的安装方法</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="RedisBloom-简介">RedisBloom 简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。</p></li><li class="lvl-2"><p>它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。</p></li><li class="lvl-2"><p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p></li><li class="lvl-2"><p>Redis8+，RedisBloom 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p></li></ul><h2 id="RedisBloom-提供的核心数据结构">RedisBloom 提供的核心数据结构</h2><ul class="lvl-0"><li class="lvl-2"><p>安装好RedisBloom后，我们可以通过如下方式查看RedisBloom 支持的命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际上所有 Stack Module Commands都是通过如下命令查看，因为我们这里只安装了 RedisBloom，所以此时仅可以看到 RedisBloom 模块的命令</span></span><br><span class="line">&gt; <span class="built_in">help</span> @module</span><br></pre></td></tr></table></figure><h3 id="通过输出我们可以看到-RedisBloom-模块支持的命令大致分为-5-类">通过输出我们可以看到 RedisBloom 模块支持的命令大致分为 5 类</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ Bloom Filter（布隆过滤器）</p><ul class="lvl-2"><li class="lvl-6">判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</li><li class="lvl-6"><a href="https://en.wikipedia.org/wiki/Bloom_filter">维基百科对 Bloom Filter 的描述</a></li><li class="lvl-6">生产环境推荐使用 <a href="https://redisson.pro/docs/data-and-services/objects/#bloom-filter">Redisson的布隆过滤器</a></li><li class="lvl-6">对应Redis命令： <code>BF.xxx</code>，详细的使用方法参见 <a href="/2025/12/22/redis7-datatype-11-BF/" title="Redis 命令及数据类型 -- BF(Bloom Filter)">Redis 命令及数据类型 -- BF(Bloom Filter)</a></li></ul></li><li class="lvl-2"><p>2️⃣ Cuckoo Filter（布谷鸟过滤器）</p><ul class="lvl-2"><li class="lvl-6">Bloom Filter 的增强版，支持 删除元素</li><li class="lvl-6"><a href="https://en.wikipedia.org/wiki/Cuckoo_filter">维基百科对 Cuckoo Filter 的描述</a></li><li class="lvl-6">在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</li><li class="lvl-6">低误判率 + 高负载率场景，Cuckoo Filter 更省内存。</li><li class="lvl-6">对应Redis命令： <code>CF.xxx</code>，详细的使用方法参见 <a href="/2025/12/22/redis7-datatype-12-CF/" title="Redis 命令及数据类型 -- CF(Cuckoo Filter)">Redis 命令及数据类型 -- CF(Cuckoo Filter)</a></li></ul></li><li class="lvl-2"><p>3️⃣ Count-Min Sketch（CMS）</p><ul class="lvl-2"><li class="lvl-6">近似统计元素出现频率</li><li class="lvl-6">对应Redis命令： <code>CMS.xxx</code>，详细的使用方法参见 <a href="/2025/12/23/redis7-datatype-13-CMS/" title="Redis 命令及数据类型 -- CMS(Count-Min Sketch)">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li></ul></li><li class="lvl-2"><p>4️⃣ Top-K</p><ul class="lvl-2"><li class="lvl-6">统计访问频率最高的 K 个元素</li><li class="lvl-6">对应Redis命令： <code>TOPK.xxx</code>，详细的使用方法参见 <a href="/2025/12/23/redis7-datatype-14-TopK/" title="Redis 命令及数据类型 -- TopK">Redis 命令及数据类型 -- TopK</a></li></ul></li><li class="lvl-2"><p>5️⃣ TDigest</p><ul class="lvl-2"><li class="lvl-6">统计数字的分布</li><li class="lvl-6">对应Redis命令： <code>TDIGEST.xxx</code>，详细的使用方法参见 <a href="/2025/12/23/redis7-datatype-15-TDigest/" title="Redis 命令及数据类型 -- TDigest">Redis 命令及数据类型 -- TDigest</a></li></ul></li></ul><h2 id="安装-RedisBloom">安装 RedisBloom</h2><ul class="lvl-0"><li class="lvl-2"><p>虽然<a href="https://cloud.redis.io">Redis Cloud</a>的<code>Download Center</code>中提供了所有Redis模块编译后的<code>.so</code>文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。</p></li></ul><blockquote><p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisbloom.so</code>上传到国内服务器即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/soft/modules/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/soft/modules</span><br><span class="line"><span class="comment"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class="line"><span class="built_in">cd</span> RedisBloom</span><br><span class="line"><span class="comment"># 推荐切换到稳定的release版本</span></span><br><span class="line">git checkout v2.8.17</span><br><span class="line"><span class="comment"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并安装需要的依赖</span></span><br><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># readies version: 7fc8e62</span></span><br><span class="line">dnf install -q -y ca-certificates</span><br><span class="line">dnf install -q -y wget unzip</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8</span><br><span class="line">dnf install -q -y git jq</span><br><span class="line">dnf install -q -y <span class="built_in">which</span></span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --modern</span><br><span class="line">dnf install -q -y valgrind</span><br><span class="line">/usr/local/soft/modules/RedisBloom/sbin/get-fbinfer</span><br><span class="line">dnf install -q -y lcov</span><br><span class="line">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class="line">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr</span><br><span class="line">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r tests/flow/requirements.txt</span><br><span class="line">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws</span><br><span class="line">/usr/bin/python3 -m pip install --disable-pip-version-check --user  pudb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...</span><br><span class="line"></span><br><span class="line">Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...</span><br><span class="line">-- The C compiler identification is GNU 11.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 11.5.0</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/gcc - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/g++ - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Setting build <span class="built_in">type</span> to <span class="string">&#x27;Release&#x27;</span> as none was specified.</span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c</span><br><span class="line"></span><br><span class="line">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...</span><br><span class="line">[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o</span><br><span class="line">[100%] Linking C static library libtdigest_static.a</span><br><span class="line">[100%] Built target tdigest_static</span><br><span class="line">Compiling deps/bloom/bloom.c...</span><br><span class="line">Compiling deps/murmur2/MurmurHash2.c...</span><br><span class="line">Compiling deps/rmutil/util.c...</span><br><span class="line">Compiling src/rebloom.c...</span><br><span class="line">Compiling src/sb.c...</span><br><span class="line">Compiling src/cf.c...</span><br><span class="line">Compiling src/rm_topk.c...</span><br><span class="line">Compiling src/rm_tdigest.c...</span><br><span class="line">Compiling src/topk.c...</span><br><span class="line">Compiling src/rm_cms.c...</span><br><span class="line">Compiling src/cms.c...</span><br><span class="line">Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so...</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong><code>./sbin/setup</code> 报错</strong></em></p><ul class="lvl-1"><li class="lvl-2">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">./sbin/setup</span><br><span class="line"><span class="comment">## 错误信息</span></span><br><span class="line">……</span><br><span class="line">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class="keyword">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class="line">Status code: 403 <span class="keyword">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class="line"></span><br><span class="line">In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:</span><br><span class="line">346      <span class="comment"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class="line">347      <span class="keyword">fi</span></span><br><span class="line">348</span><br><span class="line">349  &gt;&gt;&gt; install_raven</span><br><span class="line">350      install_remi</span><br><span class="line">351      <span class="comment"># install_centos_stream_repos</span></span><br><span class="line">352</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class="line"></span><br><span class="line">In /usr/local/soft/modules/RedisBloom/sbin/setup:</span><br><span class="line">16       python3 -m pip list</span><br><span class="line">17       <span class="keyword">fi</span></span><br><span class="line">18</span><br><span class="line">19   &gt;&gt;&gt; <span class="variable">$ROOT</span>/sbin/system-setup.py</span><br><span class="line">20       <span class="keyword">if</span> [[ <span class="variable">$VERBOSE</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">21       python3 -m pip list</span><br><span class="line">22       <span class="keyword">fi</span> 编译安装时报错</span><br><span class="line"></span><br><span class="line"><span class="comment">## 错误分析与解决方法</span></span><br><span class="line">问题原因：</span><br><span class="line">    你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。</span><br><span class="line">readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。</span><br><span class="line">    这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。</span><br><span class="line">    RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel</span><br><span class="line">    这个脚本用于：</span><br><span class="line">        安装 EPEL</span><br><span class="line">        安装 Raven Repo（EL9 特有）</span><br><span class="line">        安装 Remi Repo</span><br><span class="line">    但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。</span><br><span class="line">    你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm</span><br><span class="line">    说明你使用的可能是如下系统中的一个：</span><br><span class="line">        RHEL 9</span><br><span class="line">        Rocky Linux 9</span><br><span class="line">        AlmaLinux 9</span><br><span class="line">        CentOS Stream 9</span><br><span class="line"></span><br><span class="line">推荐解决方案:</span><br><span class="line">   Raven Repo 并非是 ReidsBloom 的必要依赖，所以直接修改 getepel 脚本，禁用 install_raven</span><br><span class="line">   vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可</span><br></pre></td></tr></table></figure></div><h2 id="Redis-启用模块">Redis 启用模块</h2><ul class="lvl-0"><li class="lvl-2"><p>将生成的 <a href="http://redisbloom.so">redisbloom.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意 .so 文件需要具有可执行权限</span></span><br><span class="line"><span class="built_in">cp</span> bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 启用模块有三种方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class="line">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"><span class="comment"># 2.也可以通过如下方式加载模块</span></span><br><span class="line">redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"><span class="comment"># 3.不需要重启redis</span></span><br><span class="line">redis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure><table><thead><tr><th>加载方式</th><th>是否持久</th></tr></thead><tbody><tr><td><code>MODULE LOAD</code>（redis-cli）</td><td>❌ 仅当前进程</td></tr><tr><td>命令行 <code>redis-server --loadmodule</code></td><td>❌ 仅本次启动</td></tr><tr><td><code>redis.conf</code> 中 <code>loadmodule</code></td><td>✅ <strong>永久生效</strong> （推荐/生产）</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>本文采用 <code>loadmodule</code> 加载模块</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class="line">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">redis-server redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录测试</span></span><br><span class="line">redis-cli --user admin --pass 123456</span><br><span class="line"><span class="comment"># 查看模块</span></span><br><span class="line">127.0.0.1:6379&gt; info Modules</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;bf&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 20817</span><br><span class="line">   5) <span class="string">&quot;path&quot;</span></span><br><span class="line">   6) <span class="string">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class="line">   7) <span class="string">&quot;args&quot;</span></span><br><span class="line">   8) (empty array)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis 扩展模块 – RedisBloom 的安装方法&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Stream</title>
    <link href="https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/"/>
    <id>https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/</id>
    <published>2025-12-20T05:40:05.000Z</published>
    <updated>2025-12-20T08:35:36.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Stream 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Stream-核心详解">Stream 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的<code>消息队列</code>，底层用<code>基数树+链表</code>实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。</p></li><li class="lvl-2"><p>建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。</p></li><li class="lvl-2"><p>Stream 与传统的MQ 的对比</p></li></ul><table><thead><tr><th>对比维度</th><th>Redis Stream</th><th>RabbitMQ</th><th>Kafka</th></tr></thead><tbody><tr><td><strong>数据模型</strong></td><td>类似日志的有序 KV 消息流（ID → field/value）</td><td>队列（FIFO）</td><td>日志分区（Partitioned Append-Only Log）</td></tr><tr><td><strong>消息持久化</strong></td><td>可选持久化（AOF / RDB），默认内存优先</td><td>可持久化到磁盘</td><td>持久化到磁盘，顺序写入，效率高</td></tr><tr><td><strong>消息确认</strong></td><td>XACK 对单条消息确认，支持 Pending 消息管理</td><td>ACK / NACK</td><td>Offset 控制，Consumer 自行提交</td></tr><tr><td><strong>消费模式</strong></td><td>支持 Consumer Group，多消费者共享 Pending 消息</td><td>Queue 绑定 Consumer，多消费者抢占</td><td>Consumer Group，多消费者平行消费</td></tr><tr><td><strong>重复消费</strong></td><td>默认可能重复，需要应用端幂等</td><td>可通过 ACK/NACK 控制</td><td>默认可能重复，Consumer 需幂等处理</td></tr><tr><td><strong>消息顺序</strong></td><td>按 Stream ID 顺序，可保证分组内顺序</td><td>队列顺序保证</td><td>Partition 内顺序保证</td></tr><tr><td><strong>消息保留策略</strong></td><td>可配置 maxlen / minid，按时间或长度裁剪</td><td>队列长度 / TTL 控制</td><td>基于时间或大小保留（Retention Policy）</td></tr><tr><td><strong>延时/定时消费</strong></td><td>原生不支持延时队列，需要应用端处理</td><td>支持插件或 TTL</td><td>原生不支持，需要应用端处理或 Kafka Streams</td></tr><tr><td><strong>事务与原子操作</strong></td><td>事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项</td><td>原生事务支持（事务 / confirm 模式）</td><td>不支持事务，依赖幂等生产者</td></tr><tr><td><strong>性能</strong></td><td>内存级高吞吐，持久化会有开销</td><td>中等，受磁盘和网络限制</td><td>高吞吐，顺序写入磁盘效率极高</td></tr><tr><td><strong>典型使用场景</strong></td><td>事件日志、轻量 MQ、内部异步流水线</td><td>企业级消息、任务调度、RPC</td><td>大数据管道、日志收集、流处理</td></tr><tr><td><strong>多语言支持</strong></td><td>客户端支持多种语言（Java、Python、Go 等）</td><td>客户端丰富</td><td>客户端丰富</td></tr><tr><td><strong>易运维性</strong></td><td>单节点即可使用，但持久化需关注内存</td><td>集群较复杂，需要 RabbitMQ 集群</td><td>集群复杂度高，需要 ZooKeeper 或 KRaft</td></tr></tbody></table><h3 id="底层核心实现">底层核心实现</h3><ol><li class="lvl-3"><p>存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。</p></li><li class="lvl-3"><p>消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。</p></li><li class="lvl-3"><p>持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。</p></li><li class="lvl-3"><p>核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。</p></li></ol><h2 id="Stream-核心基础操作（必用）">Stream 核心基础操作（必用）</h2><h3 id="1-生产消息（XADD）：写入队列">1. 生产消息（XADD）：写入队列</h3><p>• 核心命令：<code>XADD key ID 字段1 值1 字段2 值2 ...</code>，ID 写*表示自动生成（生产首选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">XADD key</span><br><span class="line">     [NOMKSTREAM]</span><br><span class="line">     [MAXLEN | MINID [= | ~] threshold [LIMIT count]]</span><br><span class="line">     * | <span class="built_in">id</span></span><br><span class="line">     field value [field value ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream 名称</span></span><br><span class="line"><span class="comment"># NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败</span></span><br><span class="line"><span class="comment"># MAXLEN threshold —— 按长度裁剪</span></span><br><span class="line"><span class="comment">#   MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）</span></span><br><span class="line"><span class="comment">#   MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大</span></span><br><span class="line"><span class="comment">#   MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高</span></span><br><span class="line"><span class="comment"># LIMIT count —— 每次最多裁剪多少条</span></span><br><span class="line"><span class="comment">#   MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程</span></span><br><span class="line"><span class="comment"># MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）</span></span><br><span class="line"><span class="comment">#   MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略</span></span><br><span class="line"><span class="comment"># * | id —— 消息 ID</span></span><br><span class="line"><span class="comment">#   *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理</span></span><br><span class="line"><span class="comment">#   id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败</span></span><br><span class="line"><span class="comment"># field value —— 消息体（Payload）</span></span><br><span class="line"><span class="comment">#   至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改</span></span><br></pre></td></tr></table></figure><p>• 示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向订单队列写入1条消息，自动生成消息ID</span></span><br><span class="line">XADD order_stream * uid 1001 order_no ORD20251220 price 299</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">&quot;1766215406540-0&quot;</span> <span class="comment"># 消息ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留某个时间点之后的日志</span></span><br><span class="line">XADD <span class="built_in">log</span> MINID ~ 1689900000000-0 * level INFO msg <span class="string">&quot;startup&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-消费消息（2种核心模式）">2. 消费消息（2种核心模式）</h3><h4 id="（1）-独立消费（无消费组）：一对一消费，适合简单场景">（1） 独立消费（无消费组）：一对一消费，适合简单场景</h4><p>• XREAD：主动拉取消息，支持阻塞/非阻塞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XREAD</span><br><span class="line">  [COUNT count]</span><br><span class="line">  [BLOCK milliseconds]</span><br><span class="line">  STREAMS key [key ...]</span><br><span class="line">          <span class="built_in">id</span>  [<span class="built_in">id</span>  ...]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># COUNT count —— 单次最多读取多少条，是“上限”，不是保证值</span></span><br><span class="line"><span class="comment"># BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil</span></span><br><span class="line"><span class="comment">#   BLOCK 0: 无限阻塞，直到有新消息</span></span><br><span class="line"><span class="comment"># STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应</span></span><br><span class="line"><span class="comment"># id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身</span></span><br><span class="line"><span class="comment">#   普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0</span></span><br><span class="line"><span class="comment">#   $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $</span></span><br></pre></td></tr></table></figure><p>• 示例1（非阻塞）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从开头拉5条消息</span></span><br><span class="line">XREAD COUNT 5 STREAMS order_stream 0-0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;order_stream&quot;</span>          <span class="comment"># Stream名称</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1766215406540-0&quot;</span> <span class="comment"># 消息ID</span></span><br><span class="line">         2) 1) <span class="string">&quot;uid&quot;</span>          <span class="comment"># 消息体 键值对</span></span><br><span class="line">            2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">            3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">            4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">            5) <span class="string">&quot;price&quot;</span></span><br><span class="line">            6) <span class="string">&quot;299&quot;</span></span><br></pre></td></tr></table></figure><p>• 示例2（阻塞）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。</span></span><br><span class="line">XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $</span><br></pre></td></tr></table></figure><h4 id="（2）-消费组消费（XGROUP）：一对多消费，核心生产模式">（2） 消费组消费（XGROUP）：一对多消费，核心生产模式</h4><ul class="lvl-0"><li class="lvl-2"><p>Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。</p></li><li class="lvl-2"><ol><li class="lvl-5">先创建消费组<code>XGROUP CREATE</code></li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key group <span class="built_in">id</span>|$</span><br><span class="line">       [MKSTREAM]</span><br><span class="line">       [ENTRIESREAD entries-read]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key：Stream 名称，为指定的Stream创建消费组</span></span><br><span class="line"><span class="comment"># group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group</span></span><br><span class="line"><span class="comment"># id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。</span></span><br><span class="line"><span class="comment"># [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用</span></span><br><span class="line"><span class="comment"># [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建group1消费组，从最新订单消息开始消费</span></span><br><span class="line">XGROUP CREATE order_stream group1 $ MKSTREAM</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>消费者拉取消息<code>XREADGROUP</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer</span><br><span class="line">           [COUNT count]</span><br><span class="line">           [BLOCK milliseconds]</span><br><span class="line">           [NOACK]</span><br><span class="line">           STREAMS key [key ...]</span><br><span class="line">                   <span class="built_in">id</span>  [<span class="built_in">id</span>  ...]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># GROUP group consumer: 指定消费者组名：group，消费者名：consumer</span></span><br><span class="line"><span class="comment">#    同一个 group 下，不同 consumer 不会收到重复消息</span></span><br><span class="line"><span class="comment"># [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证</span></span><br><span class="line"><span class="comment"># [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒</span></span><br><span class="line"><span class="comment">#    BLOCK 0 → 永久阻塞</span></span><br><span class="line"><span class="comment"># [NOACK] —— 不进入 Pending（⚠️ 谨慎）</span></span><br><span class="line"><span class="comment">#    消息 不会进入 Pending，不需要 XACK，消费后即认为完成</span></span><br><span class="line"><span class="comment">#    风险：消费者崩溃 → 消息直接丢失，不可重投递</span></span><br><span class="line"><span class="comment"># STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致</span></span><br><span class="line"><span class="comment"># id [id ...] —— 决定“读什么”的关键</span></span><br><span class="line"><span class="comment">#    使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息</span></span><br><span class="line"><span class="comment">#    使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息</span></span><br><span class="line"><span class="comment">#    多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。</span></span><br><span class="line">XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;</span><br><span class="line"><span class="comment">## 此时在5秒内创建新的消息，就会有类似如下输出</span></span><br><span class="line">1) 1) <span class="string">&quot;order_stream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1766215642763-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;uid&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">            3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">            4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">            5) <span class="string">&quot;price&quot;</span></span><br><span class="line">            6) <span class="string">&quot;299&quot;</span></span><br><span class="line">(1.50s)</span><br></pre></td></tr></table></figure><h3 id="3-消息确认（XACK）">3. 消息确认（XACK）</h3><ul class="lvl-0"><li class="lvl-2"><p>消费完成后必须确认，否则会被标记为「未确认消息」</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XACK key 消费组名 消息ID1 消息ID2 ...。</span></span><br><span class="line">XACK key group <span class="built_in">id</span> [<span class="built_in">id</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记</span></span><br><span class="line">XACK order_stream group1 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure><h3 id="4-消息重试">4. 消息重试</h3><ul class="lvl-0"><li class="lvl-2"><p>未确认的消息，会被存入消费组的<code>「PEL（Pending Entries List）」</code>，可通过<code>XPENDING key 消费组名</code>查看，支持<code>XCLAIM</code>将<code>PEL</code>中的消息转移给其他消费者处理，避免单点故障导致消息堆积。</p></li><li class="lvl-2"><p>XPENDING：查看未被确认的消息情况</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">XPENDING key group</span><br><span class="line">        [[IDLE min-idle-time]</span><br><span class="line">         start end count</span><br><span class="line">         [consumer]]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream 名称，必须存在</span></span><br><span class="line"><span class="comment"># group: 消费者组名称，必须存在</span></span><br><span class="line"><span class="comment"># [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息</span></span><br><span class="line"><span class="comment">#    min-idle-time(空闲时间) = 从上次投递 / claim到现在</span></span><br><span class="line"><span class="comment"># start end —— ID 范围</span></span><br><span class="line"><span class="comment">#    -: 最小ID</span></span><br><span class="line"><span class="comment">#    +: 最大ID</span></span><br><span class="line"><span class="comment"># count —— 返回条数上限</span></span><br><span class="line"><span class="comment"># [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部</span></span><br><span class="line"><span class="comment"># 只返回 元数据，不返回消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1: 查看是否有消息积压</span></span><br><span class="line">XPENDING order_stream group1</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1      <span class="comment"># 积压消息数，未确认消息数量</span></span><br><span class="line">2) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># Pending 中最小 ID</span></span><br><span class="line">3) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># Pending 中最大 ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumerA&quot;</span> <span class="comment"># 按 consumer 统计的 Pending 数量</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条</span></span><br><span class="line">XPENDING order_stream group1 IDLE 60000 - + 10</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;1766215642763-0&quot;</span> <span class="comment"># 消息 ID</span></span><br><span class="line">   2) <span class="string">&quot;consumerA&quot;</span>       <span class="comment"># 当前持有该消息的 consumer</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 255581  <span class="comment"># idle 时间（毫秒）</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 2       <span class="comment"># delivery count（投递次数）,该消息至少被投递过 2 次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3: 只查看 consumerA 的 Pending，最多返回20条</span></span><br><span class="line">XPENDING order_stream group1 - + 20 consumerA</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>XCLAIM: 转移投递</p></li></ul><blockquote><p>将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。<br>一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">XCLAIM key group consumer min-idle-time <span class="built_in">id</span> [<span class="built_in">id</span> ...]</span><br><span class="line">       [IDLE ms]</span><br><span class="line">       [TIME unix-time-milliseconds]</span><br><span class="line">       [RETRYCOUNT count]</span><br><span class="line">       [FORCE]</span><br><span class="line">       [JUSTID]</span><br><span class="line">       [LASTID lastid]</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line"><span class="comment"># key: Stream Key，必须存在</span></span><br><span class="line"><span class="comment"># group: 消费者组名称，必须存在</span></span><br><span class="line"><span class="comment"># consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer</span></span><br><span class="line"><span class="comment"># min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim</span></span><br><span class="line"><span class="comment"># id [id ...]: 指定要 claim 的消息 ID，ID必须存在</span></span><br><span class="line"><span class="comment"># [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态</span></span><br><span class="line"><span class="comment"># [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码</span></span><br><span class="line"><span class="comment"># [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”</span></span><br><span class="line"><span class="comment"># [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险</span></span><br><span class="line"><span class="comment"># [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销</span></span><br><span class="line"><span class="comment"># [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为</span></span><br><span class="line"><span class="comment">#    ⚠️ 高级特性，一般不建议业务代码使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"><span class="comment"># 1️⃣ 抢占 idle 超过 60s 的消息</span></span><br><span class="line">XCLAIM order_stream group1 consumerB 60000 1766215642763-0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;1766215642763-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;uid&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1001&quot;</span></span><br><span class="line">      3) <span class="string">&quot;order_no&quot;</span></span><br><span class="line">      4) <span class="string">&quot;ORD20251220&quot;</span></span><br><span class="line">      5) <span class="string">&quot;price&quot;</span></span><br><span class="line">      6) <span class="string">&quot;299&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2️⃣ 抢占并标记为第 3 次重试</span></span><br><span class="line">XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3</span><br><span class="line"><span class="comment"># 3️⃣ 只返回 ID（配合批处理）</span></span><br><span class="line">XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID</span><br></pre></td></tr></table></figure><h2 id="高级特性（生产必备）">高级特性（生产必备）</h2><ol><li class="lvl-3"><p>消息回溯与遍历</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）</span></span><br><span class="line">XRANGE key start end [COUNT count]</span><br><span class="line"><span class="comment"># XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）</span></span><br><span class="line">XREVRANGE key end start [COUNT count]</span><br><span class="line"><span class="comment"># 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。</span></span><br><span class="line">XRANGE order_stream 0-0 + COUNT 10</span><br><span class="line">XRANGE order_stream - + COUNT 10</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>队列信息查询</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查消息总数</span></span><br><span class="line">XLEN key</span><br><span class="line"><span class="comment"># 查Stream完整元数据（最新ID、消费组数量、消息总数等）</span></span><br><span class="line"></span><br><span class="line">XINFO STREAM key [FULL [COUNT count]]</span><br><span class="line"><span class="comment">## FULL: 完整模式</span></span><br><span class="line">    <span class="comment"># 👉 返回：</span></span><br><span class="line">    <span class="comment">#     Stream 元信息</span></span><br><span class="line">    <span class="comment">#     所有 Consumer Group</span></span><br><span class="line">    <span class="comment">#     每个 Group 的 Consumer</span></span><br><span class="line">    <span class="comment">#     Pending Entries List（PEL）</span></span><br><span class="line">    <span class="comment">#     部分历史 entries</span></span><br><span class="line">    <span class="comment"># ⚠️ 开销很大，慎用于生产环境。</span></span><br><span class="line"><span class="comment">## COUNT count（FULL 模式的限制参数）</span></span><br><span class="line">    <span class="comment">#   XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查所有消费组信息</span></span><br><span class="line">XINFO GROUPS key</span><br><span class="line"><span class="comment"># 查该组下所有消费者</span></span><br><span class="line">XINFO CONSUMERS key 消费组名</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>消费组管理</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除消费组</span></span><br><span class="line">XGROUP DESTROY key 消费组名</span><br><span class="line"><span class="comment"># 删除消费者</span></span><br><span class="line">XGROUP DELCONSUMER key 消费组名 消费者名</span><br><span class="line"><span class="comment"># 重置消费组起始ID</span></span><br><span class="line">XGROUP SETID key 消费组名 新ID</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。</p></li></ol><h2 id="生产环境核心痛点与解决方案">生产环境核心痛点与解决方案</h2><ol><li class="lvl-3"><p>消息丢失：3重保障</p><ul class="lvl-2"><li class="lvl-6">开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性）</li><li class="lvl-6">生产者写入后确认返回值（确保写入成功）</li><li class="lvl-6">消费者消费后必须<code>XACK</code>确认。</li></ul></li><li class="lvl-3"><p>消息堆积：2种处理</p><ul class="lvl-2"><li class="lvl-6">① 写入时用<code>MAXLEN</code>设置上限，淘汰旧消息；</li><li class="lvl-6">② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。</li></ul></li><li class="lvl-3"><p>重复消费</p><ul class="lvl-2"><li class="lvl-6">根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL）</li><li class="lvl-6">解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。</li></ul></li><li class="lvl-3"><p>阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。</p></li></ol><h2 id="典型应用场景">典型应用场景</h2><h3 id="分布式业务解耦（订单-库存-支付-物流解耦）">分布式业务解耦（订单-库存-支付-物流解耦）</h3><blockquote><p>核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。</p></blockquote><ol><li class="lvl-3"><p>生产者（订单服务）：写入订单完成消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）</span></span><br><span class="line">XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建3个独立消费组（库存/支付/物流）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库存消费组：从最新消息开始消费，队列不存在则自动创建</span></span><br><span class="line">XGROUP CREATE order_core_stream group_stock $ MKSTREAM</span><br><span class="line"><span class="comment"># 支付消费组</span></span><br><span class="line">XGROUP CREATE order_core_stream group_pay $ MKSTREAM</span><br><span class="line"><span class="comment"># 物流消费组</span></span><br><span class="line">XGROUP CREATE order_core_stream group_logistics $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>各消费组消费者拉取+确认消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒</span></span><br><span class="line">XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line"><span class="comment"># 库存处理完成后确认消息（替换为实际拉取到的消息ID）</span></span><br><span class="line">XACK order_core_stream group_stock 1734567890000-0 1734567890001-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付服务消费者（consumer_pay1）同理</span></span><br><span class="line">XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line">XACK order_core_stream group_pay 1734567890000-0 1734567890001-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物流服务消费者（consumer_log1）同理</span></span><br><span class="line">XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class="line">XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure><h3 id="异步任务处理（用户注册-邮件-短信-积分异步执行）">异步任务处理（用户注册-邮件/短信/积分异步执行）</h3><blockquote><p>核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。</p></blockquote><ol><li class="lvl-3"><p>生产者（注册服务）：用户注册成功后写入消息</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息</span></span><br><span class="line">XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建单个消费组（统一处理注册后续任务）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短信发送消费者（consumer_sms）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件发送消费者（consumer_email）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 积分发放消费者（consumer_score）</span></span><br><span class="line">XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class="line">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br></pre></td></tr></table></figure><h3 id="日志收集（系统实时日志-分析-告警）">日志收集（系统实时日志-分析/告警）</h3><blockquote><p>核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。</p></blockquote><ol><li class="lvl-3"><p>生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）</span></span><br><span class="line">XADD sys_log_stream * module order_service level ERROR content <span class="string">&quot;库存扣减失败，订单号ORD20251220001&quot;</span> log_time 1734567910</span><br><span class="line">XADD sys_log_stream * module pay_service level INFO content <span class="string">&quot;支付成功，uid1001，金额299&quot;</span> log_time 1734567912</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建2个消费组（日志分析+实时告警）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志</span></span><br><span class="line">XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM</span><br><span class="line"><span class="comment"># 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费</span></span><br><span class="line">XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>对应消费者拉取处理</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志分析消费者（批量拉取，非阻塞，适合离线处理）</span></span><br><span class="line">XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;</span><br><span class="line">XACK sys_log_stream group_log_analysis 批量消息ID...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）</span></span><br><span class="line">XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt;  <span class="comment"># BLOCK 0 永久阻塞，有消息立即返回</span></span><br><span class="line">XACK sys_log_stream group_log_alert 告警消息ID</span><br></pre></td></tr></table></figure><h3 id="限流削峰（秒杀场景-请求削峰填谷）">限流削峰（秒杀场景-请求削峰填谷）</h3><blockquote><p>核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。</p></blockquote><ol><li class="lvl-3"><p>生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中”</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）</span></span><br><span class="line">XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建消费组（单消费组+多消费者，控制总处理速率）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE seckill_stream group_seckill $ MKSTREAM</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）</span></span><br><span class="line">XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;</span><br><span class="line"><span class="comment"># 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）</span></span><br><span class="line">XACK seckill_stream group_seckill 秒杀请求消息ID...</span><br></pre></td></tr></table></figure><blockquote><p>关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。</p></blockquote><h2 id="与其他-Redis-队列方案对比（核心优势）">与其他 Redis 队列方案对比（核心优势）</h2><p>• 对比 List<br>- List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列；<br>- Stream 支持多播+消费组+确认机制，适合复杂分布式场景。</p><table><thead><tr><th>对比项</th><th>Stream</th><th>List</th></tr></thead><tbody><tr><td>消费者组</td><td>✅</td><td>❌</td></tr><tr><td>ACK</td><td>✅</td><td>❌</td></tr><tr><td>重试</td><td>✅</td><td>❌</td></tr><tr><td>阻塞</td><td>✅</td><td>✅</td></tr><tr><td>顺序性</td><td>强</td><td>强</td></tr></tbody></table><p>• 对比 Pub/Sub<br>- Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息；<br>- Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。</p><h2 id="Stream-命令">Stream 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForStream()</code> 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里不一定要用 <code>StringRedisTemplate</code> 来操作 Stream，但是用 <code>StringRedisTemplate</code> 可以保证可读性。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>核心能力划分：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">消息写入（XADD）</span><br><span class="line">消息确认（XACK）</span><br><span class="line">消息读取（XRANGE / XREAD / XREADGROUP）</span><br><span class="line">Pending 消息管理（XPENDING / XCLAIM）</span><br><span class="line">消费者组管理（XGROUP）</span><br><span class="line">Stream 元信息（XINFO）</span><br><span class="line">Stream 裁剪与删除（XTRIM / XDEL）</span><br><span class="line">对象映射（MapRecord / ObjectRecord）</span><br></pre></td></tr></table></figure><h3 id="消息写入（XADD）">消息写入（XADD）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 基础写入</p></li></ul><table><thead><tr><th>方法功能</th><th>方法 <code>opsForStream().xxx()</code></th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>写入 Map</td><td><code>add(K key, Map&lt;HK,HV&gt;)</code></td><td><code>XADD key * field value</code></td><td>自动生成 ID</td></tr><tr><td>写入 Record</td><td><code>add(Record&lt;K, ?&gt; record)</code></td><td><code>XADD</code></td><td>支持 ObjectRecord</td></tr><tr><td>写入 MapRecord</td><td><code>add(MapRecord&lt;K,HK,HV&gt;)</code></td><td><code>XADD</code></td><td>Map 形式</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 带参数写入（推荐）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>写入 + 选项</td><td><code>add(record, XAddOptions)</code></td><td><code>XADD ...</code></td><td>支持 MAXLEN / NOMKSTREAM</td></tr><tr><td>Map + 选项</td><td><code>add(key, map, XAddOptions)</code></td><td><code>XADD</code></td><td>Redis ≥ 6</td></tr></tbody></table><h3 id="消息确认（XACK）">消息确认（XACK）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>确认消息</td><td><code>acknowledge(key, group, recordIds…)</code></td><td><code>XACK</code></td><td>标记已消费</td></tr><tr><td>Record 确认</td><td><code>acknowledge(group, record)</code></td><td><code>XACK</code></td><td>常用</td></tr></tbody></table><blockquote><p>⚠️ 只对 Consumer Group 生效</p></blockquote><h3 id="消息读取（无消费者组）">消息读取（无消费者组）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 按 Range 读取（历史数据）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>正序读取</td><td><code>range(key, range)</code></td><td><code>XRANGE</code></td></tr><tr><td>限制条数</td><td><code>range(key, range, limit)</code></td><td><code>XRANGE</code></td></tr><tr><td>反序读取</td><td><code>reverseRange(key, range)</code></td><td><code>XREVRANGE</code></td></tr><tr><td>反序 + limit</td><td><code>reverseRange(key, range, limit)</code></td><td><code>XREVRANGE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 实时读取（XREAD）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>读取</td><td><code>read(StreamOffset…)</code></td><td><code>XREAD</code></td><td>不支持 ACK</td></tr><tr><td>带参数</td><td><code>read(options, offsets…)</code></td><td><code>XREAD</code></td><td>BLOCK / COUNT</td></tr><tr><td>映射对象</td><td><code>read(Class&lt;T&gt;, …)</code></td><td><code>XREAD</code></td><td>自动反序列化</td></tr></tbody></table><h3 id="消费者组读取（XREADGROUP）">消费者组读取（XREADGROUP）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>组内读取</td><td><code>read(Consumer, offsets…)</code></td><td><code>XREADGROUP</code></td><td>MQ 核心</td></tr><tr><td>带参数</td><td><code>read(Consumer, options, offsets…)</code></td><td><code>XREADGROUP</code></td><td>BLOCK</td></tr><tr><td>映射对象</td><td><code>read(Class&lt;T&gt;, Consumer, …)</code></td><td><code>XREADGROUP</code></td><td>—</td></tr></tbody></table><h3 id="Pending-消息管理（XPENDING-XCLAIM）">Pending 消息管理（XPENDING / XCLAIM）</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ Pending 查询</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>Pending 汇总</td><td><code>pending(key, group)</code></td><td><code>XPENDING</code></td></tr><tr><td>指定消费者</td><td><code>pending(key, consumer)</code></td><td><code>XPENDING</code></td></tr><tr><td>范围查询</td><td><code>pending(key, group, range, count)</code></td><td><code>XPENDING</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 消息重新分配（XCLAIM）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>重新分配</td><td><code>claim(key, group, newOwner, minIdle, ids…)</code></td><td><code>XCLAIM</code></td><td>超时接管</td></tr><tr><td>高级配置</td><td><code>claim(key, group, newOwner, XClaimOptions)</code></td><td><code>XCLAIM</code></td><td>force / retry</td></tr></tbody></table><h3 id="消费者组管理（XGROUP）">消费者组管理（XGROUP）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>创建组</td><td><code>createGroup(key, group)</code></td><td><code>XGROUP CREATE</code></td><td>从 <code>$</code> 开始</td></tr><tr><td>指定 offset</td><td><code>createGroup(key, offset, group)</code></td><td><code>XGROUP CREATE</code></td><td>常用 <code>0-0</code></td></tr><tr><td>删除消费者</td><td><code>deleteConsumer(key, consumer)</code></td><td><code>XGROUP DELCONSUMER</code></td><td></td></tr><tr><td>销毁组</td><td><code>destroyGroup(key, group)</code></td><td><code>XGROUP DESTROY</code></td><td></td></tr></tbody></table><h3 id="Stream-元信息（XINFO）">Stream 元信息（XINFO）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>Stream 信息</td><td><code>info(key)</code></td><td><code>XINFO STREAM</code></td></tr><tr><td>组信息</td><td><code>groups(key)</code></td><td><code>XINFO GROUPS</code></td></tr><tr><td>消费者信息</td><td><code>consumers(key, group)</code></td><td><code>XINFO CONSUMERS</code></td></tr></tbody></table><h3 id="Stream-删除-裁剪">Stream 删除 / 裁剪</h3><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 删除消息</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>删除消息</td><td><code>delete(key, recordIds…)</code></td><td><code>XDEL</code></td></tr><tr><td>删除 Record</td><td><code>delete(record)</code></td><td><code>XDEL</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 裁剪 Stream（XTRIM）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>精确裁剪</td><td><code>trim(key, count)</code></td><td><code>XTRIM</code></td><td></td></tr><tr><td>近似裁剪</td><td><code>trim(key, count, true)</code></td><td><code>XTRIM ~</code></td><td>性能更好</td></tr></tbody></table><h3 id="对象映射能力（非常重要）">对象映射能力（非常重要）</h3><table><thead><tr><th>能力</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Map → Object</td><td><code>map(MapRecord, Class&lt;T&gt;)</code></td><td>自动反序列化</td></tr><tr><td>List 映射</td><td><code>map(List&lt;MapRecord&gt;, Class&lt;T&gt;)</code></td><td></td></tr><tr><td>HashMapper</td><td><code>getHashMapper(Class&lt;T&gt;)</code></td><td>自定义映射</td></tr><tr><td>反序列化</td><td><code>deserializeRecord(ByteRecord)</code></td><td>底层能力</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Stream 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Geo</title>
    <link href="https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/"/>
    <id>https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/</id>
    <published>2025-12-19T13:40:05.000Z</published>
    <updated>2025-12-20T05:57:13.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Geo 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Geo-核心详解">Geo 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Geo 是基于有序集合（<code>zset</code>） 实现的地理空间操作功能，底层用<code>geohash编码</code>存储<code>经纬度</code>，核心支持 6 个基础操作 + 2 个扩展操作，兼顾<code>精准存储</code>、<code>距离计算</code>、<code>范围筛选</code>等核心需求，直接对接实际场景（如附近门店、同城好友）。</p></li><li class="lvl-2"><p>有效经度(longitude)为 <code>-180 ~ 180</code>，有效纬度(latitude)为 <code>-85.05112878 ~ 85.05112878</code>。</p></li><li class="lvl-2"><p>Redis 内部实现中：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEO 数据 ≈ ZSET</span><br><span class="line">score = GeoHash（52 位bit ≈ 11 个字符）</span><br><span class="line">member = 实际成员名</span><br></pre></td></tr></table></figure><h2 id="Geohash-是什么">Geohash 是什么?</h2><ul class="lvl-0"><li class="lvl-2"><p>Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将「位置」映射为「可排序的值」</span><br><span class="line">相近的地理位置 → 前缀相同或接近</span><br><span class="line">便于 范围查询、邻近查询、索引存储</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>核心思想</p></li></ul><blockquote><p>不断对经纬度区间进行二分，并交叉编码<br>编码顺序：经度 → 纬度 → 经度 → 纬度 → …</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每一步：</span><br><span class="line">    1.取当前区间的中点</span><br><span class="line">    2.大于中点记为 1</span><br><span class="line">    3.小于中点记为 0</span><br><span class="line">    4.缩小区间，继续下一位</span><br><span class="line">最终得到一个 bit 序列。</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis 内部的 Geohash 字符 = <code>52bit</code>，即 经度 <code>26 bit</code>，纬度 <code>26 bit</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个字符 = 5 bit</span><br><span class="line">内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bit</span><br><span class="line"></span><br><span class="line">Redis 默认在输出字符串时：</span><br><span class="line">    会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0</span><br><span class="line">    因此最终得到 11 个 Base32 字符</span><br></pre></td></tr></table></figure><h3 id="Geohash-计算过程示例">Geohash 计算过程示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">longitude = 116.397128</span><br><span class="line">latitude  = 39.916527</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>为了简化计算过程，我们这里固定一个常用精度：</p><ul class="lvl-2"><li class="lvl-6">精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度）</li></ul></li><li class="lvl-2"><p>逐位计算（关键过程）<br>1️⃣ 经度 bit（13 位）</p></li></ul><table><thead><tr><th>位次</th><th>区间</th><th>mid</th><th>判断</th><th>bit</th></tr></thead><tbody><tr><td>1</td><td>[-180,180]</td><td>0</td><td>116 ≥ 0</td><td>1</td></tr><tr><td>2</td><td>[0,180]</td><td>90</td><td>116 ≥ 90</td><td>1</td></tr><tr><td>3</td><td>[90,180]</td><td>135</td><td>116 &lt; 135</td><td>0</td></tr><tr><td>4</td><td>[90,135]</td><td>112.5</td><td>116 ≥ 112.5</td><td>1</td></tr><tr><td>5</td><td>[112.5,135]</td><td>123.75</td><td>116 &lt; 123.75</td><td>0</td></tr><tr><td>6</td><td>[112.5,123.75]</td><td>118.125</td><td>116 &lt; 118.125</td><td>0</td></tr><tr><td>7</td><td>[112.5,118.125]</td><td>115.3125</td><td>116 ≥ 115.3125</td><td>1</td></tr><tr><td>8</td><td>[115.3125,118.125]</td><td>116.71875</td><td>116 &lt; 116.71875</td><td>0</td></tr><tr><td>9</td><td>[115.3125,116.71875]</td><td>116.015625</td><td>116 ≥ 116.015625</td><td>1</td></tr><tr><td>10</td><td>[116.015625,116.71875]</td><td>116.3671875</td><td>116 ≥ 116.3671875</td><td>1</td></tr><tr><td>11</td><td>[116.3671875,116.71875]</td><td>116.54296875</td><td>116 &lt; 116.54296875</td><td>0</td></tr><tr><td>12</td><td>[116.3671875,116.54296875]</td><td>116.455078125</td><td>116 &lt; 116.455078125</td><td>0</td></tr><tr><td>13</td><td>[116.3671875,116.455078125]</td><td>116.4111328125</td><td>116 &lt; 116.4111328125</td><td>0</td></tr></tbody></table><blockquote><p>经度 bit（13 位）：<code>1101001011000</code></p></blockquote><p>2️⃣ 纬度 bit（12 位）</p><table><thead><tr><th>位次</th><th>区间</th><th>mid</th><th>判断</th><th>bit</th></tr></thead><tbody><tr><td>1</td><td>[-90,90]</td><td>0</td><td>39 ≥ 0</td><td>1</td></tr><tr><td>2</td><td>[0,90]</td><td>45</td><td>39 &lt; 45</td><td>0</td></tr><tr><td>3</td><td>[0,45]</td><td>22.5</td><td>39 ≥ 22.5</td><td>1</td></tr><tr><td>4</td><td>[22.5,45]</td><td>33.75</td><td>39 ≥ 33.75</td><td>1</td></tr><tr><td>5</td><td>[33.75,45]</td><td>39.375</td><td>39 &lt; 39.375</td><td>0</td></tr><tr><td>6</td><td>[33.75,39.375]</td><td>36.5625</td><td>39 ≥ 36.5625</td><td>1</td></tr><tr><td>7</td><td>[36.5625,39.375]</td><td>37.96875</td><td>39 ≥ 37.96875</td><td>1</td></tr><tr><td>8</td><td>[37.96875,39.375]</td><td>38.671875</td><td>39 ≥ 38.671875</td><td>1</td></tr><tr><td>9</td><td>[38.671875,39.375]</td><td>39.0234375</td><td>39 &lt; 39.0234375</td><td>0</td></tr><tr><td>10</td><td>[38.671875,39.0234375]</td><td>38.84765625</td><td>39 ≥ 38.84765625</td><td>1</td></tr><tr><td>11</td><td>[38.84765625,39.0234375]</td><td>38.935546875</td><td>39 ≥ 38.935546875</td><td>1</td></tr><tr><td>12</td><td>[38.935546875,39.0234375]</td><td>38.9794921875</td><td>39 ≥ 38.9794921875</td><td>1</td></tr></tbody></table><blockquote><p>纬度 bit（12 位）：<code>101101110111</code></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>交叉合并（最终 bit 序列）</p></li></ul><blockquote><p>按规则：经度 → 纬度 → 经度 → 纬度 …</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经度: 1 1 0 1 0 0 1 0 1 1 0 0 0</span><br><span class="line">纬度: 1 0 1 1 0 1 1 1 0 1 1 1</span><br><span class="line"></span><br><span class="line">交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01</span><br><span class="line">合并为一行：1110011100011101101010101</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>每 5 bit → 1 个 Base32 字符</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从左到右，每 5 位一组：</span></span><br><span class="line">11100 | 11100 | 01110 | 11010 | 10101</span><br><span class="line"><span class="comment"># 转10进制</span></span><br><span class="line">28    | 28    | 14    | 26    | 21</span><br><span class="line"><span class="comment"># 转 Base32</span></span><br><span class="line">w     | w    | f    | u    | p</span><br><span class="line"><span class="comment"># 最终结果：</span></span><br><span class="line">wwfup</span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）：</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Index:  0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Char :  0 1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">Index: 10 11 12 13 14 15 16 17 18 19</span><br><span class="line">Char :  b  c  d  e  f  g  h  j  k  m</span><br><span class="line"></span><br><span class="line">Index: 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">Char :  n  p  q  r  s  t  u  v  w  x</span><br><span class="line"></span><br><span class="line">Index: 30 31</span><br><span class="line">Char :  y  z</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">Geohash Base32 字符集 为什么缺少 <code>a, i, l, o</code><ul class="lvl-3"><li class="lvl-6">为了避免在视觉上引起数字混淆</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a 容易和 4 混淆</span><br><span class="line">i 容易和 1 混淆</span><br><span class="line">l 容易和 1 混淆</span><br><span class="line">o 容易和 0 混淆</span><br></pre></td></tr></table></figure><ul class="lvl-3"><li class="lvl-6">去掉 <code>a, i, l, o</code> 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度</li></ul></li></ul></div><h2 id="Geo-核心基础操作（必用）">Geo 核心基础操作（必用）</h2><h3 id="1-GEOADD：添加地理位置坐标（核心写入操作）">1. GEOADD：添加地理位置坐标（核心写入操作）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># NX：如果已存在，则不执行写入操作</span></span><br><span class="line"><span class="comment"># XX: 如果不存在，则执行写入操作，与 NX 互斥</span></span><br><span class="line"><span class="comment"># CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量</span></span><br><span class="line"><span class="comment"># longitude: 经度 (-180 ~ 180)</span></span><br><span class="line"><span class="comment"># latitude: 纬度 (-85.05112878 ~ 85.05112878)</span></span><br><span class="line"><span class="comment"># member: 成员名称，位置唯一标识（字符串）</span></span><br><span class="line"><span class="comment"># 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量</span></span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给shop集合加王府井、西单2个门店的经纬度</span></span><br><span class="line">GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。</p><h3 id="2-GEOPOS：获取指定成员的经纬度（精准查询坐标）">2. GEOPOS：获取指定成员的经纬度（精准查询坐标）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key [member [member ...]]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井的经纬度数组 [经度, 纬度]</span></span><br><span class="line">GEOPOS shop wangfujing</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。</p><h3 id="3-GEODIST：计算两个成员之间的距离（核心计算操作）">3. GEODIST：计算两个成员之间的距离（核心计算操作）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GEODIST key member1 member2 [M|KM|FT|MI]</span><br><span class="line"><span class="comment"># [M|KM|FT|MI] : 距离单位</span></span><br><span class="line"><span class="comment"># M : 米，默认</span></span><br><span class="line"><span class="comment"># KM : 千米</span></span><br><span class="line"><span class="comment"># FT : 英尺</span></span><br><span class="line"><span class="comment"># MI : 英里</span></span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井和西单之间的距离，单位为米</span></span><br><span class="line">GEODIST shop wangfujing xidan</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">&quot;1468.0611&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算王府井到西单的距离，单位千米</span></span><br><span class="line">GEODIST shop wangfujing xidan km</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。</p><h3 id="4-GEOHASH：获取指定成员的geohash编码（底层编码查询）">4. GEOHASH：获取指定成员的geohash编码（底层编码查询）</h3><p>◦ 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH key [member [member ...]]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回王府井的geohash字符串，共11位</span></span><br><span class="line">GEOHASH shop wangfujing</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) <span class="string">&quot;wx4g0f6f2u0&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。</p><h3 id="5-GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）">5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）</h3><ul class="lvl-0"><li class="lvl-2"><p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>◦ 语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># longitude: 经度</span></span><br><span class="line"><span class="comment"># latitude: 纬度</span></span><br><span class="line"><span class="comment"># radius: 半径</span></span><br><span class="line"><span class="comment"># M|KM|FT|MI: 单位</span></span><br><span class="line"><span class="comment">## 可选参数</span></span><br><span class="line"><span class="comment"># WITHCOORD: 返回经纬度</span></span><br><span class="line"><span class="comment"># WITHDIST: 带距离</span></span><br><span class="line"><span class="comment"># WITHHASH: 带geohash</span></span><br><span class="line"><span class="comment"># COUNT count: 限制返回数量</span></span><br><span class="line"><span class="comment"># ANY: 随机返回数量</span></span><br><span class="line"><span class="comment"># ASC/DESC: 按距离正/倒序</span></span><br><span class="line"><span class="comment"># STORE key: 存储结果到指定key</span></span><br><span class="line"><span class="comment"># STOREDIST key: 存储结果到指定key，结果为距离</span></span><br></pre></td></tr></table></figure><p>◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序）</p><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离</span></span><br><span class="line">GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.6463&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.8223&quot;</span></span><br></pre></td></tr></table></figure><h3 id="6-GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）">6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）</h3><ul class="lvl-0"><li class="lvl-2"><p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>◦ 语法：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class="line"><span class="comment"># 语法说明：</span></span><br><span class="line"><span class="comment"># key: key名称</span></span><br><span class="line"><span class="comment"># member: 已有成员名称</span></span><br><span class="line"><span class="comment"># radius: 半径</span></span><br><span class="line"><span class="comment"># M|KM|FT|MI: 单位</span></span><br><span class="line"><span class="comment">## 可选参数说明同 GEORADIUS</span></span><br></pre></td></tr></table></figure><p>◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令）<br>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井3km内的门店，按距离排序</span></span><br><span class="line">GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Geo-扩展操作（实战常用）">Geo 扩展操作（实战常用）</h2><h3 id="1-GEOSEARCH（Redis-6-2-新增，替代-GEORADIUS-GEORADIUSBYMEMBER）">1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER）</h3><p>◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class="line">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class="line">  [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure><p>◦ 语法1（按坐标中心）：<code>GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查天安门3km内的门店，按距离排序</span></span><br><span class="line">GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.6463&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885362016563</span><br><span class="line">   4) 1) <span class="string">&quot;116.39124959707260132&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90621776267477827&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.8223&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 语法2（按成员中心）：<code>GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井3km内的门店，按距离排序</span></span><br><span class="line">GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xidan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;1.4681&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885362016563</span><br><span class="line">   4) 1) <span class="string">&quot;116.39124959707260132&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90621776267477827&quot;</span></span><br></pre></td></tr></table></figure><p>◦ 新增特性：支持 <code>BYBOX（按矩形范围查询）</code>，适配更多场景（如查询某片区内的门店）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店</span></span><br><span class="line"><span class="comment"># 西单距离王府井 1.4681 km，所以不在结果中</span></span><br><span class="line">GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) 1) <span class="string">&quot;wangfujing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069885555089518</span><br><span class="line">   4) 1) <span class="string">&quot;116.40396326780319214&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-GEOSEARCHSTORE（Redis-6-2-新增）">2. GEOSEARCHSTORE（Redis 6.2+ 新增）</h3><p>◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序）<br>◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCHSTORE destination <span class="built_in">source</span></span><br><span class="line">  &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class="line">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class="line">  [ASC | DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure><p>◦ 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把王府井3km内的门店，存到near_shop集合</span></span><br><span class="line">GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km</span><br></pre></td></tr></table></figure><h2 id="底层核心与实战注意事项">底层核心与实战注意事项</h2><ol><li class="lvl-3"><p>底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。</p></li><li class="lvl-3"><p>精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。</p></li><li class="lvl-3"><p>性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。</p></li><li class="lvl-3"><p>适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。</p></li></ol><h2 id="典型实战场景示例">典型实战场景示例</h2><ul class="lvl-0"><li class="lvl-2"><p>需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 批量添加餐饮坐标</span></span><br><span class="line">GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）</span></span><br><span class="line">GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除某餐饮</span></span><br><span class="line">ZREM restaurant aaa</span><br></pre></td></tr></table></figure><h2 id="Geo-命令">Geo 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForGeo()</code> 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Geo</p></blockquote><h3 id="写入-删除类操作">写入 / 删除类操作</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>添加单个坐标</td><td><code>add(K key, Point point, M member)</code></td><td><code>GEOADD key longitude latitude member</code></td><td>返回 <strong>新增成员数量</strong>（已存在则返回 0）</td></tr><tr><td>添加单个位置</td><td><code>add(K key, GeoLocation&lt;M&gt; location)</code></td><td><code>GEOADD key longitude latitude member</code></td><td><code>GeoLocation</code> 内部封装了 <code>Point + member</code></td></tr><tr><td>批量添加</td><td><code>add(K key, Map&lt;M, Point&gt; map)</code></td><td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td><td><strong>推荐</strong>，一次网络 IO</td></tr><tr><td>批量添加</td><td><code>add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations)</code></td><td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td><td>与 Map 方式等价</td></tr><tr><td>删除成员</td><td><code>remove(K key, M... members)</code></td><td><code>ZREM key member [member ...]</code></td><td>GEO 本质是 <strong>Sorted Set</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(longitude, latitude);</span><br><span class="line">redisTemplate.opsForGeo().add(key, point, member);</span><br><span class="line"></span><br><span class="line">RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= <span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(member, point);</span><br><span class="line">redisTemplate.opsForGeo().add(key, geoLocation);</span><br></pre></td></tr></table></figure><h3 id="距离-坐标-哈希查询">距离 / 坐标 / 哈希查询</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>两点距离</td><td><code>distance(K key, m1, m2)</code></td><td><code>GEODIST key m1 m2</code></td><td>默认单位米</td></tr><tr><td>指定单位距离</td><td><code>distance(K key, m1, m2, metric)</code></td><td><code>GEODIST key m1 m2 unit</code></td><td>m / km / mi / ft</td></tr><tr><td>获取 GeoHash</td><td><code>hash(K key, M... members)</code></td><td><code>GEOHASH key member</code></td><td>用于调试</td></tr><tr><td>获取坐标</td><td><code>position(K key, M... members)</code></td><td><code>GEOPOS key member</code></td><td>lon / lat</td></tr></tbody></table><h3 id="半径查询（旧接口，已不推荐）">半径查询（旧接口，已不推荐）</h3><blockquote><p>Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 基于坐标点</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>半径查询</td><td><code>radius(K key, Circle within)</code></td><td><code>GEORADIUS key lon lat radius</code></td></tr><tr><td>半径 + 参数</td><td><code>radius(K key, Circle within, args)</code></td><td><code>GEORADIUS</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 基于成员</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>半径查询</td><td><code>radius(K key, member, radius)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr><tr><td>指定单位</td><td><code>radius(K key, member, Distance)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr><tr><td>带参数</td><td><code>radius(K key, member, Distance, args)</code></td><td><code>GEORADIUSBYMEMBER</code></td></tr></tbody></table><h3 id="搜索查询（推荐使用-GEOSEARCH）">搜索查询（推荐使用 GEOSEARCH）</h3><blockquote><p>替代 GEORADIUS / GEORADIUSBYMEMBER</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 按圆形范围搜索</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>说明</th></tr></thead><tbody><tr><td>圆形搜索</td><td><code>search(K key, Circle within)</code></td><td><code>GEOSEARCH</code></td><td>新推荐接口</td></tr><tr><td>指定参考点</td><td><code>search(K key, GeoReference, Distance)</code></td><td><code>GEOSEARCH</code></td><td>FROMMEMBER / FROMLONLAT</td></tr><tr><td>带参数</td><td><code>search(K key, reference, radius, args)</code></td><td><code>GEOSEARCH</code></td><td>支持排序、limit</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 按矩形范围搜索</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>矩形搜索</td><td><code>search(K key, reference, BoundingBox)</code></td><td><code>GEOSEARCH</code></td></tr><tr><td>带参数</td><td><code>search(K key, reference, BoundingBox, args)</code></td><td><code>GEOSEARCH</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>通用搜索（底层能力）</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>任意 GeoShape</td><td><code>search(K key, reference, GeoShape, args)</code></td><td><code>GEOSEARCH</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于给定的坐标搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String key, <span class="type">double</span> longitude, <span class="type">double</span> latitude, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="comment">// 中心点</span></span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(longitude, latitude);</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class="line">    <span class="comment">// 创建圆形</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(point, distance);</span><br><span class="line">    <span class="comment">// 创建地理参考</span></span><br><span class="line">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle);</span><br><span class="line">    <span class="comment">// 创建地理形状</span></span><br><span class="line">    <span class="type">GeoShape</span> <span class="variable">geoShape</span> <span class="operator">=</span> GeoShape.byRadius(distance);</span><br><span class="line">    <span class="comment">// 创建参数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class="line">            .includeCoordinates() <span class="comment">// 返回坐标</span></span><br><span class="line">            .includeDistance() <span class="comment">// 返回距离</span></span><br><span class="line">            .sortAscending() <span class="comment">// 排序</span></span><br><span class="line">            .limit(<span class="number">10</span>); <span class="comment">// 限制返回数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class="line">    <span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">        results.forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取成员名称</span></span><br><span class="line">            System.out.println(result.getContent().getName());</span><br><span class="line">            <span class="comment">// 获取坐标</span></span><br><span class="line">            System.out.println(result.getContent().getPoint());</span><br><span class="line">            <span class="comment">// 获取距离</span></span><br><span class="line">            System.out.println(result.getDistance());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于成员的坐标搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String key, String member, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class="line">    <span class="comment">// 创建地理参考</span></span><br><span class="line">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member);</span><br><span class="line">    <span class="comment">// 创建地理形状</span></span><br><span class="line">    <span class="type">GeoShape</span> <span class="variable">geoShape</span> <span class="operator">=</span> GeoShape.byRadius(distance);</span><br><span class="line">    <span class="comment">// 创建参数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class="line">            .includeCoordinates() <span class="comment">// 返回坐标</span></span><br><span class="line">            .includeDistance() <span class="comment">// 返回距离</span></span><br><span class="line">            .sortAscending() <span class="comment">// 排序</span></span><br><span class="line">            .limit(<span class="number">10</span>); <span class="comment">// 限制返回数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class="line">    <span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">        results.forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取成员名称</span></span><br><span class="line">            System.out.println(result.getContent().getName());</span><br><span class="line">            <span class="comment">// 获取坐标</span></span><br><span class="line">            System.out.println(result.getContent().getPoint());</span><br><span class="line">            <span class="comment">// 获取距离</span></span><br><span class="line">            System.out.println(result.getDistance());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="搜索并存储（GEOSEARCHSTORE）">搜索并存储（GEOSEARCHSTORE）</h3><blockquote><p>这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>1️⃣ 圆形范围存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>搜索并存储</td><td><code>searchAndStore(K key, destKey, Circle)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>指定参考点</td><td><code>searchAndStore(K key, destKey, reference, radius)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>带参数</td><td><code>searchAndStore(K key, destKey, reference, radius, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>2️⃣ 矩形范围存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>矩形存储</td><td><code>searchAndStore(K key, destKey, reference, BoundingBox)</code></td><td><code>GEOSEARCHSTORE</code></td></tr><tr><td>带参数</td><td><code>searchAndStore(K key, destKey, reference, BoundingBox, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>3️⃣ 通用 GeoShape 存储</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th></tr></thead><tbody><tr><td>通用存储</td><td><code>searchAndStore(K key, destKey, reference, GeoShape, args)</code></td><td><code>GEOSEARCHSTORE</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Geo 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Hyperloglog</title>
    <link href="https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/"/>
    <id>https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/</id>
    <published>2025-12-19T13:30:05.000Z</published>
    <updated>2025-12-20T05:57:19.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Hyperloglog 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Hyperloglog-核心详解">Hyperloglog 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 <code>12KB</code>）就能统计海量数据的基数，误差率仅 <code>0.81%</code>，无需存储全部数据本身。</p></li></ul><blockquote><p>基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展</p></li></ul><h2 id="核心使用方式（3个核心命令）">核心使用方式（3个核心命令）</h2><ul class="lvl-0"><li class="lvl-2"><p>HyperLogLog 命令极简，只有 3 个核心操作</p></li></ul><h3 id="PFADD">PFADD</h3><ul class="lvl-0"><li class="lvl-2"><p>向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD key [element [element ...]]</span><br></pre></td></tr></table></figure><h3 id="PFCOUNT">PFCOUNT</h3><ul class="lvl-0"><li class="lvl-2"><p>统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure><h3 id="PFMERGE">PFMERGE</h3><ul class="lvl-0"><li class="lvl-2"><p>将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey [sourcekey [sourcekey ...]]</span><br></pre></td></tr></table></figure><h2 id="实操示例">实操示例</h2><h3 id="示例1：单-key-基础统计（统计网站-UV）">示例1：单 key 基础统计（统计网站 UV）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 模拟3个访客访问，其中用户A重复访问</span></span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 统计当日UV（去重后是3，忽略重复的userA）</span></span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:20251218</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="示例2：-多-key-合并与汇总统计">示例2： 多 key 合并与汇总统计</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 分别统计12.17和12.18的UV</span></span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251217 userA userD</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合并两日UV到 uv:20251217_18</span></span><br><span class="line">127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）</span></span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:20251217_18</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h2 id="核心应用场景（精准落地场景）">核心应用场景（精准落地场景）</h2><ul class="lvl-0"><li class="lvl-2"><p>HyperLogLog 只关注 <strong>“去重数量”</strong>，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案：</p></li></ul><ol><li class="lvl-3"><p>网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。</p></li><li class="lvl-3"><p>业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。</p></li><li class="lvl-3"><p>海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。</p></li><li class="lvl-3"><p>跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。</p></li></ol><h2 id="关键注意事项（避坑重点）">关键注意事项（避坑重点）</h2><ol><li class="lvl-3"><p>不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。</p></li><li class="lvl-3"><p>误差不可避免，可控不影响大部分场景：固定误差率 <code>0.81%</code>，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。</p></li><li class="lvl-3"><p>内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 <code>12KB</code>，这是其核心优势，也是区别于 Set 的关键。</p></li><li class="lvl-3"><p>元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。</p></li><li class="lvl-3"><p>过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 <code>EXPIRE key seconds</code> 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。</p></li><li class="lvl-3"><p>PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。</p></li></ol><h2 id="与-Set-统计基数的对比（选型参考）">与 Set 统计基数的对比（选型参考）</h2><table><thead><tr><th>对比维度</th><th>HyperLogLog</th><th>Set</th></tr></thead><tbody><tr><td>数据结构类型</td><td>基数统计结构</td><td>无序集合</td></tr><tr><td>内存占用</td><td>固定约 <strong>12KB</strong>，与数据量无关</td><td>随元素数量线性增长，海量数据内存占用极高</td></tr><tr><td>统计结果精度</td><td><strong>非精准</strong>，标准误差约 <strong>0.81%</strong></td><td><strong>100% 精准</strong></td></tr><tr><td>是否支持获取具体元素</td><td>不支持</td><td>支持（如 <code>SMEMBERS</code>）</td></tr><tr><td>是否支持去重</td><td>支持（基数去重）</td><td>支持（元素级去重）</td></tr><tr><td>统计性能</td><td>极快（固定计算逻辑，O(1)）</td><td>数据量越大，统计与遍历成本越高</td></tr><tr><td>适合数据规模</td><td>超大规模（百万 / 千万 / 亿级）</td><td>中小规模集合</td></tr><tr><td>常见使用场景</td><td>UV / DAU 统计、独立 IP 数、访问用户数</td><td>好友列表、标签集合、关注列表</td></tr><tr><td>是否可做集合运算</td><td>不支持</td><td>支持（<code>SUNION</code> / <code>SINTER</code> / <code>SDIFF</code>）</td></tr><tr><td>是否可序列化/持久化</td><td>可（Redis 内部结构）</td><td>可</td></tr><tr><td>选型结论</td><td><strong>低成本 + 海量数据 + 可接受误差的基数统计</strong></td><td><strong>精准统计 + 需要元素明细的场景</strong></td></tr></tbody></table><h2 id="HyperLogLog-命令">HyperLogLog 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForHyperLogLog()</code> 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 HyperLogLog</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注 / 使用建议</th></tr></thead><tbody><tr><td>添加元素</td><td><code>Long add(K key, V... values)</code></td><td><code>PFADD key element [element ...]</code></td><td>返回 1 表示 HLL 结构发生变化</td></tr><tr><td>获取基数（去重数）</td><td><code>Long size(K... keys)</code></td><td><code>PFCOUNT key [key ...]</code></td><td>支持多 key 合并统计</td></tr><tr><td>合并 HLL</td><td><code>Long union(K destination, K... sourceKeys)</code></td><td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td><td>合并后写入 destkey</td></tr><tr><td>删除 HLL</td><td><code>void delete(K key)</code></td><td><code>DEL key</code></td><td>直接删除整个 HLL</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Hyperloglog 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Bitfield</title>
    <link href="https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/"/>
    <id>https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/</id>
    <published>2025-12-18T13:30:06.000Z</published>
    <updated>2025-12-24T02:43:10.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Bitfield 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Bitfield-核心详解">Bitfield 核心详解</h2><p>• BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。<br>• 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。</p><h2 id="Bitfield-命令">Bitfield 命令</h2><h3 id="1-BITFIELD-批量操作">1. <code>BITFIELD</code> 批量操作</h3><p>• BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class="line">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class="line">  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class="line">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class="line">  ...]]</span><br></pre></td></tr></table></figure><p>• 参数说明（核心部分）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><strong>key</strong></td><td>操作的 Redis 字符串键</td></tr><tr><td><strong>GET encoding offset</strong></td><td>从指定位偏移量读取一个整数</td></tr><tr><td><strong>SET encoding offset value</strong></td><td>在指定位置写入整数</td></tr><tr><td><strong>INCRBY encoding offset increment</strong></td><td>在指定位置对整数做增量操作</td></tr><tr><td><strong>OVERFLOW WRAP/SAT/FAIL</strong></td><td>配置随后的算数操作溢出行为</td></tr></tbody></table><p>• 数据类型（encoding）:用于指定整数的位宽和符号类型</p><table><thead><tr><th>前缀</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>u&lt;number&gt;</code></td><td>无符号整数（unsigned），占位 bits = number</td><td>u5 — 5 位无符号整数</td></tr><tr><td><code>i&lt;number&gt;</code></td><td>有符号整数（signed），占位 bits = number</td><td>i10 — 10 位有符号整数</td></tr></tbody></table><p>• 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。</p><table><thead><tr><th>策略</th><th>行为</th></tr></thead><tbody><tr><td><strong>WRAP</strong></td><td>环绕（默认）溢出按环形计数处理</td></tr><tr><td><strong>SAT</strong></td><td>饱和，在边界值保持最大/最小</td></tr><tr><td><strong>FAIL</strong></td><td>溢出时操作失败并返回错误</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。</span></span><br><span class="line">BITFIELD key OVERFLOW SAT INCRBY u4 0 1</span><br></pre></td></tr></table></figure><p>• 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="2-BITFIELD-RO-批量只读">2. <code>BITFIELD_RO</code> 批量只读</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 6.0 新增的只读版本，用于批量只读</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD_RO key [GET encoding offset [GET encoding offset ...]]</span><br></pre></td></tr></table></figure><h2 id="综合示例">综合示例</h2><h3 id="示例-1-设置并读取简单整数">示例 1. 设置并读取简单整数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET mykey <span class="string">&quot;&quot;</span> <span class="comment"># 此时mykey 的值是空字符串，长度为 0</span></span><br><span class="line"><span class="comment"># SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000</span></span><br><span class="line"><span class="comment"># GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7</span></span><br><span class="line">&gt; BITFIELD mykey SET u4 0 7 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 0 <span class="comment"># set命令的返回值，这里返回set前的值</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 7 <span class="comment"># get命令的返回值</span></span><br><span class="line"><span class="comment"># 设置有符号整数</span></span><br><span class="line">&gt; BITFIELD mykey SET i4 0 -2 GET i4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 7 <span class="comment"># 返回set前的值，之前是7，即 0111，set后变为 -2，即 1110</span></span><br><span class="line">2) (<span class="built_in">integer</span>) -2 <span class="comment"># get命令的返回值</span></span><br></pre></td></tr></table></figure><div class="tips"><p><em><strong>负数的二进制表示</strong></em></p><ul class="lvl-1"><li class="lvl-2">以 -2 为例，先写出 +2 的二进制，以8位为例，就是 <code>00000010</code>，4位就是 <code>0010</code></li><li class="lvl-2">按位取反（得到反码），例如 <code>00000010</code>，按位取反就是 <code>11111101</code></li><li class="lvl-2">加 1（得到补码），<code>11111101</code> + 1，得到 <code>11111110</code>，这就是 -2 的二进制表示</li><li class="lvl-2">如果是4位，则 -2 就是 <code>1110</code></li></ul></div><h3 id="示例-2-自增计数器">示例 2. 自增计数器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 counter 之前为空，则视为 0</span></span><br><span class="line"><span class="comment"># INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5</span></span><br><span class="line"><span class="comment"># GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值</span></span><br><span class="line">BITFIELD counter INCRBY u8 8 5 GET u8 8</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 5 <span class="comment"># INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="示例-3-带溢出控制的操作">示例 3. 带溢出控制的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OVERFLOW SAT: 设置溢出策略为 SAT（饱和）</span></span><br><span class="line"><span class="comment"># INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）</span></span><br><span class="line"><span class="comment"># GET u4 0：读取 4 位无符号整数，即15</span></span><br><span class="line">BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br><span class="line">2) (<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure><h3 id="示例-4-批量多个操作">示例 4. 批量多个操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数</span></span><br><span class="line"><span class="comment"># SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理</span></span><br><span class="line"><span class="comment"># 返回结果数组对应每个子命令顺序返回结果</span></span><br><span class="line">BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，所以这里返回0</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，所以这里返回0</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0 <span class="comment"># events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 0000000000110000</span></span><br><span class="line">4) (<span class="built_in">integer</span>) 1 <span class="comment"># 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-操作-BitField">SpringBoot 操作 BitField</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 BitField 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 BitField</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>位字段读/写/自增</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>位字段操作（读/写/自增）</td><td><code>bitField(K key, BitFieldSubCommands subCommands)</code></td><td><code>BITFIELD key ...</code></td><td>原子执行多个子命令</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>示例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD limits</span><br><span class="line">    OVERFLOW SAT</span><br><span class="line">    SET u4 0 3</span><br><span class="line">    INCRBY u4 0 20</span><br><span class="line">    GET u4 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SET u4 0 3</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldSet</span> <span class="variable">bitFieldSet</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>), <span class="number">3</span>);</span><br><span class="line"><span class="comment">// OVERFLOW SAT INCRBY u4 0 20</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldIncrBy</span> <span class="variable">bitFieldIncrBy</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>), <span class="number">20</span>, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);</span><br><span class="line"><span class="comment">// GET u4 0</span></span><br><span class="line">BitFieldSubCommands.<span class="type">BitFieldGet</span> <span class="variable">bitFieldGet</span> <span class="operator">=</span> BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class="number">4</span>), BitFieldSubCommands.Offset.offset(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果，每个子操作返回一个结果</span></span><br><span class="line">List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(<span class="string">&quot;limits&quot;</span>, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Bitfield 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Bitmap</title>
    <link href="https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/"/>
    <id>https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/</id>
    <published>2025-12-18T13:30:05.000Z</published>
    <updated>2025-12-24T02:40:40.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Bitmap 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Bitmap-核心详解">Bitmap 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展</p></li><li class="lvl-2"><p>String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值）</p></li></ul><h2 id="Bitmap-命令使用方式">Bitmap 命令使用方式</h2><ul class="lvl-0"><li class="lvl-2"><p>核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础</p></li></ul><h3 id="1-位设置：SETBIT-key-offset-value">1. 位设置：<code>SETBIT key offset value</code></h3><ul class="lvl-0"><li class="lvl-2"><p>给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容）</p></li><li class="lvl-2"><p>offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SETBIT bitkey 1 1 <span class="comment"># 实际的bit为 01000000</span></span><br><span class="line">SETBIT bitkey 10 1 <span class="comment"># 实际的bit为 0100000000100000</span></span><br><span class="line"><span class="comment"># 操作 String</span></span><br><span class="line">SET k1 v1 <span class="comment"># 实际的bit为 0111011000110001</span></span><br><span class="line">SETBIT k1 1 0 <span class="comment"># 实际bit为 0011011000110001</span></span><br><span class="line">GET k1 <span class="comment"># 输出 61</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bitmap 实际上是 string</span></span><br><span class="line">TYPE bitkey <span class="comment"># 输出 string</span></span><br></pre></td></tr></table></figure><h3 id="2-位查询：GETBIT-key-offset">2. 位查询：<code>GETBIT key offset</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查询指定偏移量的位值，不存在的 offset 默认返回 0</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GETBIT bitkey 1</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="3-位统计：BITCOUNT-key-start-end">3. 位统计：<code>BITCOUNT key [start end]</code></h3><ul class="lvl-0"><li class="lvl-2"><p>统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT bitkey</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">BITCOUNT bitkey 0 -1</span><br></pre></td></tr></table></figure><h3 id="4-位运算：BITOP-op-destkey-key1-key2">4. 位运算：<code>BITOP op destkey key1 key2...</code></h3><ul class="lvl-0"><li class="lvl-2"><p>对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将key1 与 key2 做按位与运算，结果存入 destkey</span></span><br><span class="line">BITOP AND destkey key1 key2</span><br></pre></td></tr></table></figure><h3 id="5-位查找：BITPOS-key-value-start-end">5. 位查找：<code>BITPOS key value [start end]</code></h3><ul class="lvl-0"><li class="lvl-2"><p>查找第一个值为 0/1 的 bit 偏移量，快速定位目标位</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BITPOS bitkey 1</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">BITPOS bitkey 1 0 -1</span><br></pre></td></tr></table></figure><h2 id="核心使用场景-实操举例（贴合开发实战）">核心使用场景 + 实操举例（贴合开发实战）</h2><ul class="lvl-0"><li class="lvl-2"><p>Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景</p></li></ul><h3 id="场景1：-用户签到-打卡（最经典场景）">场景1： 用户签到/打卡（最经典场景）</h3><p>• 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数<br>• 设计：key 格式 <code>user:sign:uid:202512</code>（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0<br>• 实操命令：</p><ol><li class="lvl-3"><p>12月1号签到：<code>SETBIT user:sign:uid:202512 0 1</code></p></li><li class="lvl-3"><p>查询12月1号是否签到：<code>GETBIT user:sign:uid:202512 0</code>（返回1=签到）</p></li><li class="lvl-3"><p>统计12月总签到次数：<code>BITCOUNT user:sign:uid:202512</code></p></li></ol><p>• 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。</p><ul class="lvl-0"><li class="lvl-2"><p>劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p></li></ul><h3 id="场景2：-日活-周活-月活（DAU-WAU-MAU）统计（高并发场景首选）">场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选）</h3><p>• 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计<br>• 设计：按日期建 Bitmap，key 格式 <code>active:user:20251217</code>（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1<br>• 实操命令：</p><ol><li class="lvl-3"><p>用户ID 10086 12月17日访问：<code>SETBIT active:user:20251217 10086 1</code></p></li><li class="lvl-3"><p>统计12月17日日活：<code>BITCOUNT active:user:20251217</code></p></li><li class="lvl-3"><p>统计12月15-17日3天内活跃的用户数：<code>BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p></li><li class="lvl-3"><p>统计12月15-17日每天都登录的用户数：<code>BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p></li></ol><p>• 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。</p><ul class="lvl-0"><li class="lvl-2"><p>劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p></li></ul><h3 id="场景3：-功能开关-状态标记（多维度轻量标记）">场景3： 功能开关/状态标记（多维度轻量标记）</h3><p>• 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key<br>• 设计：1个key对应1个用户，key 格式 <code>user:status:10086</code>，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否<br>• 实操命令：</p><ol><li class="lvl-3"><p>给用户10086绑定手机：<code>SETBIT user:status:10086 0 1</code></p></li><li class="lvl-3"><p>开通会员：<code>SETBIT user:status:10086 1 1</code></p></li><li class="lvl-3"><p>查询是否是会员：<code>GETBIT user:status:10086 1</code></p></li></ol><p>• 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。</p><ul class="lvl-0"><li class="lvl-2"><p>劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p></li></ul><h3 id="场景4：-布隆过滤器底层实现（核心依赖Bitmap）">场景4： 布隆过滤器底层实现（核心依赖Bitmap）</h3><p>• 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判<br>• 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在<br>• 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。<br>• 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。</p><ul class="lvl-0"><li class="lvl-2"><p>劣势：布隆过滤器虽然有极小误判率，但不允许删除。</p></li></ul><h2 id="注意事项（避坑关键）">注意事项（避坑关键）</h2><ol><li class="lvl-3"><p>offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩）</p></li><li class="lvl-3"><p>避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长</p></li><li class="lvl-3"><p>注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置</p></li></ol><h2 id="Bitmap-命令">Bitmap 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><blockquote><p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Bitmap</p></blockquote><h3 id="写操作（位修改）">写操作（位修改）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置指定偏移量的位</td><td><code>setBit(K key, long offset, boolean value)</code></td><td><code>SETBIT key offset value</code></td><td>返回旧值（0 / 1），offset 从 0 开始</td></tr></tbody></table><blockquote><p>offset 表示 第几位（bit），不是字节</p></blockquote><h3 id="读操作（位查询）">读操作（位查询）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定偏移量的位</td><td><code>getBit(K key, long offset)</code></td><td><code>GETBIT key offset</code></td><td>返回 0 / 1，不会修改数据</td></tr></tbody></table><h3 id="Bitmap-常用但-Spring-未直接封装的命令">Bitmap 常用但 Spring 未直接封装的命令</h3><ul class="lvl-0"><li class="lvl-2"><p>Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。</p></li></ul><table><thead><tr><th>Redis 命令</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><code>BITCOUNT key [start end]</code></td><td>统计 bit=1 的数量</td><td>常用于活跃用户统计</td></tr><tr><td><code>BITPOS key bit [start end]</code></td><td>查找第一个 0/1 的位置</td><td>常用于分配位</td></tr><tr><td><code>BITOP AND/OR/XOR/NOT</code></td><td>位运算</td><td>多 bitmap 计算</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.bitmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.CommonUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Range;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitmapUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITCOUNT key [start end]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 统计 bit=1 的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitCount</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitCount</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitCount(key.getBytes(), start, end)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITPOS key bit [start] [end]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * bit = false → 查找第一个 0</span></span><br><span class="line"><span class="comment">     * bit = true → 查找第一个 1</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 返回值是 bit 索引（不是 byte）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitPos</span><span class="params">(String key, <span class="type">boolean</span> bit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitPos(key.getBytes(), bit)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitPos</span><span class="params">(String key, <span class="type">boolean</span> bit, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BITOP operation destKey key [key ...]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * operation: AND\OR\XOR\NOT</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 运算结果保存在 destKey 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">bitOp</span><span class="params">(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123;</span><br><span class="line">            <span class="type">byte</span>[][] keys = Arrays.stream(sourceKeys)</span><br><span class="line">                    .map(String::getBytes)</span><br><span class="line">                    .toArray(<span class="type">byte</span>[][]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> connection.stringCommands().bitOp(</span><br><span class="line">                    operation,</span><br><span class="line">                    destKey.getBytes(),</span><br><span class="line">                    keys</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Bitmap 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>一个基于 Redis 的可重入分布式锁的实现</title>
    <link href="https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/"/>
    <id>https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/</id>
    <published>2025-12-17T13:30:05.000Z</published>
    <updated>2025-12-21T08:18:02.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 一个基于 Redis 的可重入分布式锁的实现方案</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li><li class="lvl-2">本文仅为学习原理，生产环境推荐使用 <a href="https://redisson.pro/docs/data-and-services/locks-and-synchronizers/">Redisson 分布式锁</a> 吧。</li></ul><span id="more"></span><h2 id="设计目标与关键约束">设计目标与关键约束</h2><h3 id="设计目标">设计目标</h3><ul class="lvl-0"><li class="lvl-2"><p>互斥性：同一时间只有一个持有者</p></li><li class="lvl-2"><p>可重入：同一线程 / 请求可多次加锁</p></li><li class="lvl-2"><p>安全释放：只能释放自己持有的锁</p></li><li class="lvl-2"><p>自动过期：防止死锁</p></li><li class="lvl-2"><p>续期能力（Watch Dog）：业务时间不确定时依然安全</p></li><li class="lvl-2"><p>高性能：单 Redis Key，Lua 保证原子性</p></li></ul><h3 id="技术选型">技术选型</h3><ul class="lvl-0"><li class="lvl-2"><p>Spring Boot</p></li><li class="lvl-2"><p>Spring Data Redis（Lettuce）</p></li><li class="lvl-2"><p>Redis Lua Script</p></li></ul><blockquote><p>Redis 是唯一依赖组件：Redis<br>Spring Boot 作为运行框架：Spring Boot</p></blockquote><h3 id="锁的核心数据结构设计（关键）">锁的核心数据结构设计（关键）</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis Key 结构(String)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock:前缀</span></span><br><span class="line">lock:order:123</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Value 结构（Hash）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uuid:threadId&quot;</span> : 重入次数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同一线程重入 → count +1，不同线程 → 拒绝</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>使用<code>StringRedisTemplate</code>，因其序列化器是<code>StringRedisSerializer</code>，可以保证 Lua 脚本能够正常执行。</p></li></ul><blockquote><p>基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer</p></blockquote><h3 id="Lua-脚本（原子性保障）">Lua 脚本（原子性保障）</h3><ul class="lvl-0"><li class="lvl-2"><p>加锁脚本（支持可重入）</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">-- ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">-- ARGV[2] expireMillis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>解锁脚本（防误删）</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">-- ARGV[1] ownerId</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hdel&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> (redis.call(<span class="string">&#x27;hlen&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Java-实现（核心代码）">Java 实现（核心代码）</h2><ul class="lvl-0"><li class="lvl-2"><p>WatchDog，实现锁自动续期</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockWatchDog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WatchDog的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     * ARGV[2] expireMillis 过期时间</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 拥有者是当前线程就续期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WATCHDOG_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程足够（Redisson 也是）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span></span><br><span class="line">            Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                t.setName(<span class="string">&quot;redis-lock-watch-dog&quot;</span>);</span><br><span class="line">                t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个 lockKey 对应一个续期任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLockWatchDog</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动续期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey     Redis 锁 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ownerId     uuid:threadId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseMillis 锁过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startRenew</span><span class="params">(String lockKey, String ownerId, <span class="type">long</span> leaseMillis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止重复启动</span></span><br><span class="line">        <span class="keyword">if</span> (renewTasks.containsKey(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 间隔多久续期一次</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> leaseMillis / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                renew(lockKey, ownerId, leaseMillis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 生产环境建议接日志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        renewTasks.put(lockKey, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消续期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopRenew</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            future.cancel(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际续期逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renew</span><span class="params">(String lockKey, String ownerId, <span class="type">long</span> leaseMillis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId,</span><br><span class="line">                String.valueOf(leaseMillis)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="comment">// 锁已不属于当前线程，停止 Watch Dog</span></span><br><span class="line">            stopRenew(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用关闭时释放资源（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>锁接口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  尝试获取锁的最大等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * 不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * 只要获取到锁就返回，否则一直自旋获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>锁实现类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的key前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     * ARGV[2] expireMillis 过期时间</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.key 不存在时创建锁</span></span><br><span class="line"><span class="comment">     * 2.key 存在时判断锁的拥有者是否为当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class="line"><span class="string">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的Lua脚本</span></span><br><span class="line"><span class="comment">     * KEYS[1] 锁key</span></span><br><span class="line"><span class="comment">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNLOCK_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then</span></span><br><span class="line"><span class="string">                return 0</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)</span></span><br><span class="line"><span class="string">            if (count &gt; 0) then</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1])</span></span><br><span class="line"><span class="string">                if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then</span></span><br><span class="line"><span class="string">                    redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">                return 1</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisLockWatchDog watchDog;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisReentrantLock</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        watchDog = <span class="keyword">new</span> <span class="title class_">RedisLockWatchDog</span>(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的 ownerId</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">ownerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expireMillis</span> <span class="operator">=</span> unit.toMillis(leaseTime);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(LOCK_SCRIPT, Boolean.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId(),</span><br><span class="line">                String.valueOf(expireMillis)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(success)) &#123;<span class="comment">//防止NullPointerException</span></span><br><span class="line">            <span class="comment">// 启动 Watch Dog（只有在 leaseTime 不确定时）</span></span><br><span class="line">            watchDog.startRenew(</span><br><span class="line">                    lockKey,</span><br><span class="line">                    ownerId(),</span><br><span class="line">                    expireMillis</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, <span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.currentTimeMillis() + unit.toMillis(waitTime);</span><br><span class="line">        <span class="comment">// 使用带条件的循环，避免重复赋值</span></span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() &lt; deadline) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class="line">                <span class="comment">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class="line">                <span class="comment">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class="line">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class="number">50</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用无限循环，语义更清晰</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class="line">                <span class="comment">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class="line">                <span class="comment">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class="line">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class="number">50</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line">        <span class="comment">// 先停续期</span></span><br><span class="line">        watchDog.stopRenew(lockKey);</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(UNLOCK_SCRIPT, Long.class),</span><br><span class="line">                Collections.singletonList(lockKey),</span><br><span class="line">                ownerId()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>测试类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lock.RedisReentrantLock;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisReentrantLock redisReentrantLock;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试获取锁</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisReentrantLock.tryLock(lockKey, <span class="number">5</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">                doBusiness();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redisReentrantLock.unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisReentrantLock.lock(lockKey, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束执行业务逻辑&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    redisReentrantLock.unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试多线程同时获取锁</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">demoMultiThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 每个线程都尝试获取同一个锁</span></span><br><span class="line">                    <span class="keyword">if</span> (redisReentrantLock.tryLock(lockKey, <span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            successCount.incrementAndGet();</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 获取锁成功，开始执行业务&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 模拟业务执行时间</span></span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 业务执行完成&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            redisReentrantLock.unlock(lockKey);</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 获取锁失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取锁的线程数: &quot;</span> + successCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 一个基于 Redis 的可重入分布式锁的实现方案&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文仅为学习原理，生产环境推荐使用 &lt;a href=&quot;https://redisson.pro/docs/data-and-services/locks-and-synchronizers/&quot;&gt;Redisson 分布式锁&lt;/a&gt; 吧。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- ZSet</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/</id>
    <published>2025-12-16T13:40:05.000Z</published>
    <updated>2025-12-20T05:57:30.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis ZSet 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="ZSet-核心详解">ZSet 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; &#123; member -&gt; score &#125;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">member：唯一，不可重复（String，二进制安全）</span><br><span class="line">score：double 类型，用于排序</span><br><span class="line">集合按 score 从小到大 排序</span><br><span class="line">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>ZSet = Set（去重） + 排序能力</p></li><li class="lvl-2"><p>ZSet 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素唯一</span><br><span class="line">天然有序</span><br><span class="line">支持范围查询</span><br><span class="line">支持排名（rank）</span><br><span class="line">支持按 score 增量更新</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p></li><li class="lvl-2"><p>ZSet 的应用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Zset集合操作实现新闻点击排行榜</span></span><br><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY hotNews:20251201 1 news1 <span class="comment"># 点击一次分数 +1</span></span><br><span class="line">2）展示当日点击排行前十</span><br><span class="line">ZREVRANGE hotNews:20251201 0 9 WITHSCORES <span class="comment"># 倒序</span></span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 <span class="comment"># 合并</span></span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZSet 适合 排序 + 查询</span><br><span class="line">score 设计要稳定、可扩展</span><br><span class="line">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class="line">大 ZSet 避免全量遍历</span><br><span class="line">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure><h2 id="ZSet-命令">ZSet 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForZSet()</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="基础写入-删除-计数">基础写入 / 删除 / 计数</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注 / 推荐替代</th></tr></thead><tbody><tr><td>添加元素（含 score）</td><td><code>Boolean add(K key, V value, double score)</code></td><td><code>ZADD key score member</code></td><td>新增返回 <code>true</code></td></tr><tr><td>添加元素（仅不存在时）</td><td><code>Boolean addIfAbsent(K key, V value, double score)</code></td><td><code>ZADD key NX score member</code></td><td>Redis ≥ 3.0</td></tr><tr><td>批量添加</td><td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key score member [score member ...]</code></td><td>返回新增数量</td></tr><tr><td>批量添加（仅不存在）</td><td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td><td><code>ZADD key NX ...</code></td><td>—</td></tr><tr><td>删除成员</td><td><code>Long remove(K key, Object... values)</code></td><td><code>ZREM key member [member ...]</code></td><td>返回删除数量</td></tr><tr><td>递增 score</td><td><code>Double incrementScore(K key, V value, double delta)</code></td><td><code>ZINCRBY key delta member</code></td><td>—</td></tr><tr><td>获取集合大小</td><td><code>Long size(K key)</code></td><td><code>ZCARD key</code></td><td>—</td></tr><tr><td>获取集合大小（同义）</td><td><code>Long zCard(K key)</code></td><td><code>ZCARD key</code></td><td>API 别名</td></tr></tbody></table><h3 id="随机访问">随机访问</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>命令备注</th></tr></thead><tbody><tr><td>随机获取成员</td><td><code>V randomMember(K key)</code></td><td><code>ZRANDMEMBER key</code></td><td>不返回 score</td></tr><tr><td>随机获取不重复成员</td><td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td><td><code>ZRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr><tr><td>随机获取成员及 score</td><td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td><td><code>ZRANDMEMBER key WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机获取不重复成员及 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key count WITHSCORES</code></td><td>—</td></tr><tr><td>随机获取可重复成员及 score</td><td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td><td><code>ZRANDMEMBER key -count WITHSCORES</code></td><td>—</td></tr></tbody></table><h3 id="排名-score-查询">排名 / score 查询</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取正序排名</td><td><code>Long rank(K key, Object o)</code></td><td><code>ZRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取倒序排名</td><td><code>Long reverseRank(K key, Object o)</code></td><td><code>ZREVRANK key member</code></td><td>从 0 开始</td></tr><tr><td>获取 score</td><td><code>Double score(K key, Object o)</code></td><td><code>ZSCORE key member</code></td><td>—</td></tr><tr><td>批量获取 score</td><td><code>List&lt;Double&gt; score(K key, Object... o)</code></td><td><code>ZMScore key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>score 区间计数</td><td><code>Long count(K key, double min, double max)</code></td><td><code>ZCOUNT key min max</code></td><td>—</td></tr></tbody></table><h3 id="区间查询（rank-score）">区间查询（rank / score）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>按 rank 查询</td><td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td><td><code>ZRANGE key start end</code></td><td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td></tr><tr><td>按 rank 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td><td><code>ZRANGE key start end WITHSCORES</code></td><td>—</td></tr><tr><td>按 score 查询</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max</code></td><td>—</td></tr><tr><td>按 score 查询（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td><td>—</td></tr><tr><td>score 分页</td><td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td><td>—</td></tr><tr><td>score 分页（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td><td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td><td>按 score 升序分页，返回 member + score</td></tr><tr><td>倒序 rank 查询</td><td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end</code></td><td>按 rank 倒序（高 → 低）</td></tr><tr><td>倒序 rank（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td><td><code>ZREVRANGE key start end WITHSCORES</code></td><td>倒序 rank，返回 score</td></tr><tr><td>倒序 score 查询</td><td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min</code></td><td>注意：<strong>max 在前，min 在后</strong></td></tr><tr><td>倒序 score（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td><td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td><td>倒序 score，返回 score</td></tr></tbody></table><h3 id="弹出元素（队列-TopN-场景）">弹出元素（队列 / TopN 场景）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td><td><code>ZPOPMIN key</code></td><td>—</td></tr><tr><td>批量弹出最小 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td><td><code>ZPOPMIN key count</code></td><td>—</td></tr><tr><td>阻塞弹出最小 score</td><td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td><td><code>BZPOPMIN key timeout</code></td><td>—</td></tr><tr><td>弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td><td><code>ZPOPMAX key</code></td><td>—</td></tr><tr><td>批量弹出最大 score</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td><td><code>ZPOPMAX key count</code></td><td>—</td></tr><tr><td>阻塞弹出最大 score</td><td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td><td><code>BZPOPMAX key timeout</code></td><td>—</td></tr></tbody></table><h3 id="区间删除">区间删除</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th></tr></thead><tbody><tr><td>按 rank 删除</td><td><code>Long removeRange(K key, long start, long end)</code></td><td><code>ZREMRANGEBYRANK key start end</code></td></tr><tr><td>按 score 删除</td><td><code>Long removeRangeByScore(K key, double min, double max)</code></td><td><code>ZREMRANGEBYSCORE key min max</code></td></tr><tr><td>按 lex 删除</td><td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td><td><code>ZREMRANGEBYLEX key min max</code></td></tr></tbody></table><h3 id="集合运算（ZSet-特有）">集合运算（ZSet 特有）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>差集</td><td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>差集并存储</td><td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集</td><td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集</td><td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...]</code></td><td>Redis ≥ 6.2</td></tr><tr><td>并集（含 score）</td><td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>交集并存储</td><td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZINTERSTORE destination numkeys key [key ...]</code></td><td></td></tr><tr><td>并集并存储</td><td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td><td></td></tr></tbody></table><h3 id="Lex（字典序，仅-score-相同）">Lex（字典序，仅 score 相同）</h3><blockquote><p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>如果 score 不同，Redis 文档明确说明：结果不可预测</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>按 lex 查询</td><td><code>Set&lt;V&gt; rangeByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td><td>score 必须相同</td></tr><tr><td>倒序 lex 查询</td><td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td><td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td><td>—</td></tr><tr><td>lex 范围存储</td><td><code>Long rangeAndStoreByLex(...)</code></td><td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td><td>Spring 封装</td></tr><tr><td>score 范围存储</td><td><code>Long rangeAndStoreByScore(...)</code></td><td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td><td>Spring 封装</td></tr></tbody></table><blockquote><p>Lex 范围写法规则</p></blockquote><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[a</code></td><td>≥ a（包含）</td></tr><tr><td><code>(a</code></td><td>&gt; a（不包含）</td></tr><tr><td><code>[z</code></td><td>≤ z</td></tr><tr><td><code>+</code></td><td>正无穷</td></tr><tr><td><code>-</code></td><td>负无穷</td></tr></tbody></table><blockquote><p>示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a ≤ member &lt; d</span></span><br><span class="line">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure><h3 id="遍历">遍历</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令（完整）</th><th>备注</th></tr></thead><tbody><tr><td>游标扫描</td><td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td><td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>推荐替代全量查询</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis ZSet 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Set</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/</id>
    <published>2025-12-16T13:38:05.000Z</published>
    <updated>2025-12-20T05:57:35.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Set 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Set-核心详解">Set 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 是一个无序、不重复元素集合，本质上是：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Set&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素唯一（自动去重）</span><br><span class="line">无顺序（不保证插入顺序）</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Set 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动去重</span><br><span class="line">高效成员判断</span><br><span class="line">支持集合运算</span><br><span class="line">操作原子性强</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>Set 应用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微信抽奖小程序</span></span><br><span class="line">1）点击参与抽奖加入集合</span><br><span class="line">SADD key &#123;userlD&#125;</span><br><span class="line">2）查看参与抽奖所有用户</span><br><span class="line">SMEMBERS key</span><br><span class="line">3）抽取count名中奖者</span><br><span class="line">SRANDMEMBER key [count] / SPOP key [count]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微信微博点赞，收藏，标签</span></span><br><span class="line">1) 点赞</span><br><span class="line">SADD like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">2) 取消点赞</span><br><span class="line">SREM like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">3) 检查用户是否点过赞</span><br><span class="line">SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">4) 获取点赞的用户列表</span><br><span class="line">SMEMBERS like:&#123;消息ID&#125;</span><br><span class="line">5) 获取点赞用户数</span><br><span class="line">SCARD like:&#123;消息ID&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line"><span class="comment"># 交集：多个集合中同时存在的元素</span></span><br><span class="line">SINTER set1 set2 set3 -&gt; &#123; c &#125; <span class="comment"># 交集，共同关注 / 共同好友 / 共同兴趣</span></span><br><span class="line"><span class="comment"># 并集：存在于任意一个集合中的元素</span></span><br><span class="line">SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; <span class="comment"># 多来源合并后的用户全集</span></span><br><span class="line"><span class="comment"># 差集：只存在于第一个集合中的元素</span></span><br><span class="line">SDIFF set1 set2 set3 -&gt; &#123;a&#125; <span class="comment"># 差集，推荐好友</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set 适合 成员资格判断</span><br><span class="line">始终控制成员规模</span><br><span class="line">大 Set 遍历使用 SSCAN</span><br><span class="line">集合运算放在离线或低频场景</span><br><span class="line">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure><h2 id="Set-命令">Set 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForSet()</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="写操作（增-删-移动）">写操作（增 / 删 / 移动）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>向集合添加元素</td><td><code>add(K key, V... values)</code></td><td><code>SADD key member [member ...]</code></td><td>返回新增成员数量</td></tr></tbody></table><h3 id="移除-弹出成员">移除 / 弹出成员</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>从集合移除元素</td><td><code>remove(K key, Object... values)</code></td><td><code>SREM key member [member ...]</code></td><td>返回移除成员数量</td></tr><tr><td>随机弹出一个元素</td><td><code>pop(K key)</code></td><td><code>SPOP key</code></td><td>随机且删除</td></tr><tr><td>随机弹出多个元素</td><td><code>pop(K key, long count)</code></td><td><code>SPOP key count</code></td><td>Redis ≥ 3.2</td></tr></tbody></table><h3 id="成员移动（原子）">成员移动（原子）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>将成员移动到其他集合</td><td><code>move(K key, V value, K destKey)</code></td><td><code>SMOVE source dest member</code></td><td>原子操作</td></tr></tbody></table><h3 id="集合大小">集合大小</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取集合大小</td><td><code>size(K key)</code></td><td><code>SCARD key</code></td><td>—</td></tr></tbody></table><h3 id="成员存在性判断">成员存在性判断</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>判断是否是成员</td><td><code>isMember(K key, Object o)</code></td><td><code>SISMEMBER key member</code></td><td>—</td></tr><tr><td>批量判断成员是否存在</td><td><code>isMember(K key, Object... objects)</code></td><td><code>SMISMEMBER key member [member ...]</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><h3 id="交集（Intersection）">交集（Intersection）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算交集</td><td><code>intersect(K key, K otherKey)</code></td><td><code>SINTER key key</code></td><td>O(N × M)</td></tr><tr><td>计算交集</td><td><code>intersect(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>计算交集</td><td><code>intersect(Collection&lt;K&gt; keys)</code></td><td><code>SINTER key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(K key, K otherKey, K destKey)</code></td><td><code>SINTERSTORE dest key key</code></td><td>返回结果数量</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>交集并存储</td><td><code>intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SINTERSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="并集（Union）">并集（Union）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算并集</td><td><code>union(K key, K otherKey)</code></td><td><code>SUNION key key</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>union(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>计算并集</td><td><code>union(Collection&lt;K&gt; keys)</code></td><td><code>SUNION key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(K key, K otherKey, K destKey)</code></td><td><code>SUNIONSTORE dest key key</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>并集并存储</td><td><code>unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SUNIONSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="差集（Difference）">差集（Difference）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>计算差集</td><td><code>difference(K key, K otherKey)</code></td><td><code>SDIFF key key</code></td><td>key 顺序影响结果</td></tr><tr><td>计算差集</td><td><code>difference(K key, Collection&lt;K&gt; otherKeys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>计算差集</td><td><code>difference(Collection&lt;K&gt; keys)</code></td><td><code>SDIFF key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(K key, K otherKey, K destKey)</code></td><td><code>SDIFFSTORE dest key key</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr><tr><td>差集并存储</td><td><code>differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td><td><code>SDIFFSTORE dest key [key ...]</code></td><td>—</td></tr></tbody></table><h3 id="全量-随机读取">全量 / 随机读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取所有成员</td><td><code>members(K key)</code></td><td><code>SMEMBERS key</code></td><td>大集合慎用</td></tr><tr><td>随机获取一个成员</td><td><code>randomMember(K key)</code></td><td><code>SRANDMEMBER key</code></td><td>不删除</td></tr><tr><td>随机获取不重复成员</td><td><code>distinctRandomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key count</code></td><td>count &gt; 0</td></tr><tr><td>随机获取可重复成员</td><td><code>randomMembers(K key, long count)</code></td><td><code>SRANDMEMBER key -count</code></td><td>count &lt; 0</td></tr></tbody></table><h3 id="游标扫描（大集合推荐）">游标扫描（大集合推荐）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>游标扫描成员</td><td><code>scan(K key, ScanOptions options)</code></td><td><code>SSCAN key cursor [MATCH] [COUNT]</code></td><td>推荐替代 <code>SMEMBERS</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Set 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- List</title>
    <link href="https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/"/>
    <id>https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/</id>
    <published>2025-12-16T13:35:05.000Z</published>
    <updated>2025-12-20T05:57:39.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis List 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="List-核心详解">List 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis List 是一个有序字符串列表，本质上是:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; List&lt;String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">元素按插入顺序排列</span><br><span class="line">允许重复元素</span><br><span class="line">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>List 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有序</span><br><span class="line">可重复</span><br><span class="line">双端操作（Deque）</span><br><span class="line">支持阻塞读</span><br><span class="line">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p></li><li class="lvl-2"><p>List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差</p></li><li class="lvl-2"><p>常用数据结构</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack(栈) = LPUSH + LPOP</span><br><span class="line">Queue(队列）= LPUSH + RPOP</span><br><span class="line">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>List 的使用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">视频列表、签到列表</span><br><span class="line">排队机</span><br><span class="line">简化版的MQ</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List 只用于 顺序消费</span><br><span class="line">始终限制 List 长度（LTRIM）</span><br><span class="line">避免中间插入、删除</span><br><span class="line">大 List 删除使用 UNLINK</span><br><span class="line">高可靠消息不要用 List</span><br></pre></td></tr></table></figure><h2 id="List-命令">List 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForList()</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="区间访问与整体控制">区间访问与整体控制</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定区间元素</td><td><code>range(K key, long start, long end)</code></td><td><code>LRANGE key start end</code></td><td><code>end = -1</code> 表示到末尾</td></tr><tr><td>裁剪 list，仅保留指定区间</td><td><code>trim(K key, long start, long end)</code></td><td><code>LTRIM key start end</code></td><td><strong>原地修改</strong></td></tr><tr><td>获取 list 长度</td><td><code>size(K key)</code></td><td><code>LLEN key</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>📌 使用建议</p><ul class="lvl-2"><li class="lvl-6"><code>LRANGE 0 -1</code> 等价全量读取，小 list 可用</li><li class="lvl-6">大 list 建议分页 + LRANGE</li></ul></li></ul><h3 id="左侧入队（Head）">左侧入队（Head）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧插入一个元素</td><td><code>leftPush(K key, V value)</code></td><td><code>LPUSH key value</code></td><td>返回插入后长度</td></tr><tr><td>左侧批量插入</td><td><code>leftPushAll(K key, V... values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>依次从左插入</td></tr><tr><td>左侧批量插入</td><td><code>leftPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>LPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时左侧插入</td><td><code>leftPushIfPresent(K key, V value)</code></td><td><code>LPUSHX key value</code></td><td>key 不存在不执行</td></tr><tr><td>在 pivot 左侧插入</td><td><code>leftPush(K key, V pivot, V value)</code></td><td><code>LINSERT key BEFORE pivot value</code></td><td>pivot 不存在返回 <code>-1</code></td></tr></tbody></table><h3 id="右侧入队（Tail）">右侧入队（Tail）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>右侧插入一个元素</td><td><code>rightPush(K key, V value)</code></td><td><code>RPUSH key value</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>rightPushAll(K key, V... values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>右侧批量插入</td><td><code>rightPushAll(K key, Collection&lt;V&gt; values)</code></td><td><code>RPUSH key value [value ...]</code></td><td>—</td></tr><tr><td>key 存在时右侧插入</td><td><code>rightPushIfPresent(K key, V value)</code></td><td><code>RPUSHX key value</code></td><td>—</td></tr><tr><td>在 pivot 右侧插入</td><td><code>rightPush(K key, V pivot, V value)</code></td><td><code>LINSERT key AFTER pivot value</code></td><td>pivot 不存在返回 <code>-1</code></td></tr></tbody></table><h3 id="非阻塞弹出">非阻塞弹出</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧弹出</td><td><code>leftPop(K key)</code></td><td><code>LPOP key</code></td><td>—</td></tr><tr><td>左侧批量弹出</td><td><code>leftPop(K key, long count)</code></td><td><code>LPOP key count</code></td><td>Redis ≥ 6.2</td></tr><tr><td>右侧弹出</td><td><code>rightPop(K key)</code></td><td><code>RPOP key</code></td><td>—</td></tr><tr><td>右侧批量弹出</td><td><code>rightPop(K key, long count)</code></td><td><code>RPOP key count</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><h3 id="阻塞弹出（Blocking-Queue）">阻塞弹出（Blocking Queue）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>左侧阻塞弹出</td><td><code>leftPop(K key, timeout)</code></td><td><code>BLPOP key timeout</code></td><td>队列为空时阻塞</td></tr><tr><td>右侧阻塞弹出</td><td><code>rightPop(K key, timeout)</code></td><td><code>BRPOP key timeout</code></td><td>—</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>📌 典型场景：</p><ul class="lvl-2"><li class="lvl-6">消息队列 / 任务队列</li><li class="lvl-6">简单生产者-消费者模型</li></ul></li></ul><h3 id="原子移动">原子移动</h3><blockquote><p>Redis 6.2+ 新模型（统一、可读性更强）</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>原子移动（非阻塞）</td><td><code>move(sourceKey, from, destinationKey, to)</code></td><td><code>LMOVE source dest LEFT|RIGHT LEFT|RIGHT</code></td><td>Redis ≥ 6.2</td></tr><tr><td>原子移动（阻塞）</td><td><code>move(sourceKey, from, destinationKey, to, timeout)</code></td><td><code>BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout</code></td><td>Redis ≥ 6.2</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>语义说明</p><ul class="lvl-2"><li class="lvl-6">从 sourceKey 的一端 POP</li><li class="lvl-6">向 destinationKey 的一端 PUSH</li><li class="lvl-6">整个过程 原子性保证</li></ul></li><li class="lvl-2"><p>命令参数说明：</p><ul class="lvl-2"><li class="lvl-6">source:源 List（从这里取一个元素）</li><li class="lvl-6">dest:目标 List（往这里放一个元素）</li><li class="lvl-6">第一个 LEFT/RIGHT:从 source 的哪一端弹出元素</li><li class="lvl-6">第二个 LEFT/RIGHT:从 dest 的哪一端插入元素</li><li class="lvl-6">timeout: 阻塞时间<ul class="lvl-4"><li class="lvl-10">当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。</li><li class="lvl-10">timeout = 0：无限期阻塞，直到有数据可用或连接断开</li></ul></li></ul></li></ul><blockquote><p>旧命令（即将废弃）</p></blockquote><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>推荐替代</th></tr></thead><tbody><tr><td>右弹左插</td><td><code>rightPopAndLeftPush(...)</code></td><td><code>RPOPLPUSH</code></td><td><code>LMOVE</code></td></tr><tr><td>阻塞右弹左插</td><td><code>rightPopAndLeftPush(..., timeout)</code></td><td><code>BRPOPLPUSH</code></td><td><code>BLMOVE</code></td></tr></tbody></table><h3 id="随机访问与定位（O-N-）">随机访问与定位（O(N)）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取第一个元素</td><td><code>getFirst(K key)</code></td><td><code>LINDEX key 0</code></td><td>O(N)</td></tr><tr><td>获取最后一个元素</td><td><code>getLast(K key)</code></td><td><code>LINDEX key -1</code></td><td>O(N)</td></tr><tr><td>获取指定索引元素</td><td><code>index(K key, long index)</code></td><td><code>LINDEX key index</code></td><td>O(N)</td></tr></tbody></table><blockquote><p>⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取</p></blockquote><h3 id="搜索与删除">搜索与删除</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>删除指定值</td><td><code>remove(K key, long count, Object value)</code></td><td><code>LREM key count value</code></td><td>count &gt;0 从左，&lt;0 从右</td></tr><tr><td>获取首次出现位置</td><td><code>indexOf(K key, V value)</code></td><td><code>LPOS key value</code></td><td>Redis ≥ 6.0</td></tr><tr><td>获取最后出现位置</td><td><code>lastIndexOf(K key, V value)</code></td><td><code>LPOS key value RANK -1</code></td><td>Redis ≥ 6.0</td></tr></tbody></table><h3 id="List-的典型使用模式总结">List 的典型使用模式总结</h3><table><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>队列（FIFO）</td><td><code>RPUSH + LPOP</code></td></tr><tr><td>栈（LIFO）</td><td><code>LPUSH + LPOP</code></td></tr><tr><td>阻塞队列</td><td><code>BLPOP / BRPOP</code></td></tr><tr><td>可靠队列</td><td><code>LMOVE / BLMOVE</code></td></tr><tr><td>消息转移</td><td><code>LMOVE source dest</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis List 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令及数据类型 -- Hash</title>
    <link href="https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/"/>
    <id>https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/</id>
    <published>2025-12-15T13:33:05.000Z</published>
    <updated>2025-12-20T05:57:45.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><ul class="lvl-0"><li class="lvl-2">本文介绍 Redis Hash 数据类型</li><li class="lvl-2">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li><li class="lvl-2">Redis官网：<a href="https://redis.io/">https://redis.io/</a></li><li class="lvl-2">Redis 命令文档：<a href="https://redis.io/docs/latest/commands/">https://redis.io/docs/latest/commands/</a></li></ul><span id="more"></span><h2 id="Hash-核心详解">Hash 核心详解</h2><ul class="lvl-0"><li class="lvl-2"><p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; Map&lt;String, String&gt;</span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">key：Redis 的键（只能是 String）</span><br><span class="line">field：Hash 内的字段名（String）</span><br><span class="line">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 的核心特性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适合存储对象型数据</span><br><span class="line">支持 字段级别读写</span><br><span class="line">所有操作均为 原子性</span><br><span class="line">内存效率优于「String + JSON」</span><br><span class="line">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash 的使用场景</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象缓存</span></span><br><span class="line">HSET user:1 name zhangsan age 20</span><br><span class="line"><span class="comment"># 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为value</span></span><br><span class="line">HSET cart:userId commodity:1001 1 commodity:1002 5</span><br><span class="line"><span class="comment"># 分布式锁，一个命令搞不定，需要结合Lua脚本</span></span><br><span class="line">HINCRBY lock uuid:threadId 1 <span class="comment"># 创建锁 或 重入+1</span></span><br><span class="line">EXPIRE lock 30 <span class="comment"># 30 秒后自动释放锁</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Hash结构优缺点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">• 优点</span><br><span class="line">1）同类数据聚合存储，适合表达对象模型，便于管理与维护</span><br><span class="line">2）相比 string 操作消耗内存与 CPU 更小</span><br><span class="line">    a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销</span><br><span class="line">    b.Hash 过大时（BigHash）优势消失</span><br><span class="line">3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销</span><br><span class="line">• 缺点</span><br><span class="line">1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持</span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># user:1 这个 Hash 不会过期</span></span><br><span class="line">HSET user:1 name <span class="string">&quot;Tom&quot;</span> age 18</span><br><span class="line"><span class="comment"># HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class="line"><span class="comment"># 只有 name field 60 秒后自动删除</span></span><br><span class="line">HEXPIRE user:1 60 FIELDS 1 name</span><br><span class="line"><span class="comment"># 同时给多个 field 设置过期时间</span></span><br><span class="line">HEXPIRE user:1 60 FIELDS 2 name age</span><br><span class="line"><span class="comment"># 使用毫秒级过期（HPEXPIRE）</span></span><br><span class="line"><span class="comment"># HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class="line">HPEXPIRE user:1 60 FIELDS 2 name age</span><br><span class="line"><span class="comment"># 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class="line"><span class="comment"># HTTL key FIELDS numfields field [field ...]</span></span><br><span class="line">HTTL user:1 FIELDS 1 name</span><br><span class="line"><span class="comment"># 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class="line"><span class="comment"># HPTTL key FIELDS numfields field [field ...]</span></span><br><span class="line">HPTTL user:1 FIELDS 1 name</span><br><span class="line"><span class="comment"># 移出过期时间</span></span><br><span class="line"><span class="comment"># HPERSIST key FIELDS numfields field [field ...]</span></span><br><span class="line">HPERSIST user:1 FIELDS 1 name</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>生产环境建议</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个 Hash = 一个对象</span><br><span class="line">field 数量建议 &lt; 100</span><br><span class="line">单 field value 建议 &lt; 1 KB</span><br><span class="line">大对象拆分为多个 Hash</span><br><span class="line">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure><h2 id="Hash-命令">Hash 命令</h2><ul class="lvl-0"><li class="lvl-2"><p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForHash()</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p></li></ul><h3 id="写入-更新">写入 / 更新</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>设置单个 field-value</td><td><code>put(H key, HK hashKey, HV value)</code></td><td><code>HSET key field value</code></td><td>新增或覆盖</td></tr><tr><td>批量设置 field-value</td><td><code>putAll(H key, Map&lt;HK,HV&gt; m)</code></td><td><code>HSET key field value [field value ...]</code></td><td><code>HMSET</code> 已废弃</td></tr><tr><td>field 不存在时设置</td><td><code>putIfAbsent(H key, HK hashKey, HV value)</code></td><td><code>HSETNX key field value</code></td><td>原子操作</td></tr></tbody></table><h3 id="读取">读取</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取指定 field 的值</td><td><code>get(H key, Object hashKey)</code></td><td><code>HGET key field</code></td><td>不存在返回 <code>null</code></td></tr><tr><td>批量获取多个 field</td><td><code>multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HMGET key field [field ...]</code></td><td>不存在返回 <code>null</code></td></tr><tr><td>获取所有 value</td><td><code>values(H key)</code></td><td><code>HVALS key</code></td><td>O(N)</td></tr><tr><td>获取所有 field-value</td><td><code>entries(H key)</code></td><td><code>HGETALL key</code></td><td><strong>生产环境慎用</strong></td></tr></tbody></table><h3 id="删除-存在性判断">删除 / 存在性判断</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>删除一个或多个 field</td><td><code>delete(H key, Object... hashKeys)</code></td><td><code>HDEL key field [field ...]</code></td><td>返回删除数量</td></tr><tr><td>判断 field 是否存在</td><td><code>hasKey(H key, Object hashKey)</code></td><td><code>HEXISTS key field</code></td><td>—</td></tr></tbody></table><h3 id="计数与数值运算">计数与数值运算</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>field 整数自增</td><td><code>increment(H key, HK hashKey, long delta)</code></td><td><code>HINCRBY key field increment</code></td><td>value 必须是整数</td></tr><tr><td>field 浮点数自增</td><td><code>increment(H key, HK hashKey, double delta)</code></td><td><code>HINCRBYFLOAT key field increment</code></td><td>Redis ≥ 2.6</td></tr><tr><td>获取 field 对应 value 长度</td><td><code>lengthOfValue(H key, HK hashKey)</code></td><td><code>HSTRLEN key field</code></td><td>不存在返回 0</td></tr><tr><td>获取 hash 中 field 数量</td><td><code>size(H key)</code></td><td><code>HLEN key</code></td><td>—</td></tr></tbody></table><h3 id="随机访问（Random-Access）">随机访问（Random Access）</h3><ul class="lvl-0"><li class="lvl-2"><p>⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>随机返回一个 field</td><td><code>randomKey(H key)</code></td><td><code>HRANDFIELD key</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回一个 field-value</td><td><code>randomEntry(H key)</code></td><td><code>HRANDFIELD key WITHVALUES</code></td><td>Redis ≥ 6.2</td></tr><tr><td>随机返回多个 field</td><td><code>randomKeys(H key, long count)</code></td><td><code>HRANDFIELD key count</code></td><td>count &lt; 0 可重复</td></tr><tr><td>随机返回多个 field-value</td><td><code>randomEntries(H key, long count)</code></td><td><code>HRANDFIELD key count WITHVALUES</code></td><td>—</td></tr></tbody></table><h3 id="遍历与扫描（推荐方式）">遍历与扫描（推荐方式）</h3><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>获取所有 field</td><td><code>keys(H key)</code></td><td><code>HKEYS key</code></td><td>O(N)，大 hash 慎用</td></tr><tr><td>游标扫描 hash</td><td><code>scan(H key, ScanOptions options)</code></td><td><code>HSCAN key cursor [MATCH] [COUNT]</code></td><td><strong>推荐替代 <code>HGETALL</code></strong></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-3"><p>📌 最佳实践</p><ul class="lvl-2"><li class="lvl-6">小 hash：HGETALL</li><li class="lvl-6">大 hash / 线上系统：HSCAN</li></ul></li></ul><h3 id="Hash-Field-级别过期（Redis-7-4-）">Hash Field 级别过期（Redis 7.4+）</h3><ul class="lvl-0"><li class="lvl-3"><p>Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强</p></li><li class="lvl-2"><p>设置过期</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>为指定 field 设置过期时间</td><td><code>expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE key seconds FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr><tr><td>为指定 field 设置过期时间点</td><td><code>expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr><tr><td>高级过期策略</td><td><code>expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HEXPIRE / HEXPIREAT</code></td><td>Spring 抽象封装</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>移除过期时间</p></li></ul><table><thead><tr><th>方法功能</th><th>方法</th><th>Redis 原始命令</th><th>备注</th></tr></thead><tbody><tr><td>移除指定 field 的过期时间</td><td><code>persist(H key, Collection&lt;HK&gt; hashKeys)</code></td><td><code>HPERSIST key FIELDS n field [...]</code></td><td>Redis ≥ 7.4</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文介绍 Redis Hash 数据类型&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;本文基于&lt;code&gt;redis-7.4.7&lt;/code&gt;，&lt;code&gt;springboot-3.5.8&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis官网：&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;Redis 命令文档：&lt;a href=&quot;https://redis.io/docs/latest/commands/&quot;&gt;https://redis.io/docs/latest/commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/categories/%E6%8A%80%E6%9C%AF/redis/"/>
    
    
    <category term="redis" scheme="https://blog.hanqunfeng.com/tags/redis/"/>
    
  </entry>
  
</feed>
