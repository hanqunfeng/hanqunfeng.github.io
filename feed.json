{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","title":"Redis 命令及数据类型 -- ZSet","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis ZSet 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ZSet-数据类型\">ZSet 数据类型</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; &#123; member -&gt; score &#125;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">member：唯一，不可重复（String，二进制安全）</span><br><span class=\"line\">score：double 类型，用于排序</span><br><span class=\"line\">集合按 score 从小到大 排序</span><br><span class=\"line\">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSet = Set（去重） + 排序能力</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素唯一</span><br><span class=\"line\">天然有序</span><br><span class=\"line\">支持范围查询</span><br><span class=\"line\">支持排名（rank）</span><br><span class=\"line\">支持按 score 增量更新</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSet 适合 排序 + 查询</span><br><span class=\"line\">score 设计要稳定、可扩展</span><br><span class=\"line\">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class=\"line\">大 ZSet 避免全量遍历</span><br><span class=\"line\">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n<li class=\"lvl-2\">\n<p>基础写入 / 删除 / 计数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素（含 score）</td>\n<td><code>Boolean add(K key, V value, double score)</code></td>\n<td><code>ZADD key score member</code></td>\n<td>新增返回 <code>true</code></td>\n</tr>\n<tr>\n<td>添加元素（仅不存在时）</td>\n<td><code>Boolean addIfAbsent(K key, V value, double score)</code></td>\n<td><code>ZADD key NX score member</code></td>\n<td>Redis ≥ 3.0</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key score member [score member ...]</code></td>\n<td>返回新增数量</td>\n</tr>\n<tr>\n<td>批量添加（仅不存在）</td>\n<td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key NX ...</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>Long remove(K key, Object... values)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>递增 score</td>\n<td><code>Double incrementScore(K key, V value, double delta)</code></td>\n<td><code>ZINCRBY key delta member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小</td>\n<td><code>Long size(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小（同义）</td>\n<td><code>Long zCard(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>API 别名</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>随机访问</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机获取成员</td>\n<td><code>V randomMember(K key)</code></td>\n<td><code>ZRANDMEMBER key</code></td>\n<td>不返回 score</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n<tr>\n<td>随机获取成员及 score</td>\n<td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td>\n<td><code>ZRANDMEMBER key WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机获取不重复成员及 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>随机获取可重复成员及 score</td>\n<td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>排名 / score 查询</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取正序排名</td>\n<td><code>Long rank(K key, Object o)</code></td>\n<td><code>ZRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取倒序排名</td>\n<td><code>Long reverseRank(K key, Object o)</code></td>\n<td><code>ZREVRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取 score</td>\n<td><code>Double score(K key, Object o)</code></td>\n<td><code>ZSCORE key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量获取 score</td>\n<td><code>List&lt;Double&gt; score(K key, Object... o)</code></td>\n<td><code>ZMScore key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>score 区间计数</td>\n<td><code>Long count(K key, double min, double max)</code></td>\n<td><code>ZCOUNT key min max</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>区间查询（rank / score）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 查询</td>\n<td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end</code></td>\n<td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td>\n</tr>\n<tr>\n<td>按 rank 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td>\n<td>按 score 升序分页，返回 member + score</td>\n</tr>\n<tr>\n<td>倒序 rank 查询</td>\n<td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end</code></td>\n<td>按 rank 倒序（高 → 低）</td>\n</tr>\n<tr>\n<td>倒序 rank（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end WITHSCORES</code></td>\n<td>倒序 rank，返回 score</td>\n</tr>\n<tr>\n<td>倒序 score 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min</code></td>\n<td>注意：<strong>max 在前，min 在后</strong></td>\n</tr>\n<tr>\n<td>倒序 score（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td>\n<td>倒序 score，返回 score</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>弹出元素（队列 / TopN 场景）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td>\n<td><code>ZPOPMIN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最小 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td>\n<td><code>ZPOPMIN key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td>\n<td><code>BZPOPMIN key timeout</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td>\n<td><code>ZPOPMAX key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最大 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td>\n<td><code>ZPOPMAX key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td>\n<td><code>BZPOPMAX key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>区间删除</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令（完整）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 删除</td>\n<td><code>Long removeRange(K key, long start, long end)</code></td>\n<td><code>ZREMRANGEBYRANK key start end</code></td>\n</tr>\n<tr>\n<td>按 score 删除</td>\n<td><code>Long removeRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREMRANGEBYSCORE key min max</code></td>\n</tr>\n<tr>\n<td>按 lex 删除</td>\n<td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td>\n<td><code>ZREMRANGEBYLEX key min max</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集合运算（ZSet 特有）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差集</td>\n<td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集</td>\n<td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZINTERSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Lex（字典序，仅 score 相同）</p>\n</li>\n</ul>\n<blockquote>\n<p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>\n只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>\n如果 score 不同，Redis 文档明确说明：结果不可预测</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 lex 查询</td>\n<td><code>Set&lt;V&gt; rangeByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td>\n<td>score 必须相同</td>\n</tr>\n<tr>\n<td>倒序 lex 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td>\n<td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>lex 范围存储</td>\n<td><code>Long rangeAndStoreByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>score 范围存储</td>\n<td><code>Long rangeAndStoreByScore(...)</code></td>\n<td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Lex 范围写法规则</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[a</code></td>\n<td>≥ a（包含）</td>\n</tr>\n<tr>\n<td><code>(a</code></td>\n<td>&gt; a（不包含）</td>\n</tr>\n<tr>\n<td><code>[z</code></td>\n<td>≤ z</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>正无穷</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>负无穷</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a ≤ member &lt; d</span></span><br><span class=\"line\">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>遍历</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForZSet().xxx()</code></th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描</td>\n<td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td>\n<td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td>\n<td>推荐替代全量查询</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ ZSet 数据类型 Redis ZSet 是一种 带权重的有序集合，本质结构为： 123456key -&gt; &#123; member -&gt; score &#125;# 说明member：唯一，不可重复（String，二进制安全）score：double 类型，用于排序集合按 score 从小到大 排序score 相同则按 member 的字典序(Lex)排序 ZSet = Set（去重） + 排序能力 ZSet 的核心特性 12345元素唯一天然有序支持范围查询支持排名（rank）支持按 score 增量更新 Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。 生产环境建议 12345ZSet 适合 排序 + 查询score 设计要稳定、可扩展定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）大 ZSet 避免全量遍历删除大 ZSet 使用 UNLINK SpringBoot 的 RedisTemplate&lt;K,V&gt; 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 基础写入 / 删除 / 计数 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令 命令备注 / 推荐替代 添加元素（含 score） Boolean add(K key, V value, double score) ZADD key score member 新增返回 true 添加元素（仅不存在时） Boolean addIfAbsent(K key, V value, double score) ZADD key NX score member Redis ≥ 3.0 批量添加 Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key score member [score member ...] 返回新增数量 批量添加（仅不存在） Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key NX ... — 删除成员 Long remove(K key, Object... values) ZREM key member [member ...] 返回删除数量 递增 score Double incrementScore(K key, V value, double delta) ZINCRBY key delta member — 获取集合大小 Long size(K key) ZCARD key — 获取集合大小（同义） Long zCard(K key) ZCARD key API 别名 随机访问 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令 命令备注 随机获取成员 V randomMember(K key) ZRANDMEMBER key 不返回 score 随机获取不重复成员 Set&lt;V&gt; distinctRandomMembers(K key, long count) ZRANDMEMBER key count count &gt; 0 随机获取可重复成员 List&lt;V&gt; randomMembers(K key, long count) ZRANDMEMBER key -count count &lt; 0 随机获取成员及 score TypedTuple&lt;V&gt; randomMemberWithScore(K key) ZRANDMEMBER key WITHSCORES Redis ≥ 6.2 随机获取不重复成员及 score Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count) ZRANDMEMBER key count WITHSCORES — 随机获取可重复成员及 score List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count) ZRANDMEMBER key -count WITHSCORES — 排名 / score 查询 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令 备注 获取正序排名 Long rank(K key, Object o) ZRANK key member 从 0 开始 获取倒序排名 Long reverseRank(K key, Object o) ZREVRANK key member 从 0 开始 获取 score Double score(K key, Object o) ZSCORE key member — 批量获取 score List&lt;Double&gt; score(K key, Object... o) ZMScore key member [member ...] Redis ≥ 6.2 score 区间计数 Long count(K key, double min, double max) ZCOUNT key min max — 区间查询（rank / score） 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令 备注 按 rank 查询 Set&lt;V&gt; range(K key, long start, long end) ZRANGE key start end 正序rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始） 按 rank 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end) ZRANGE key start end WITHSCORES — 按 score 查询 Set&lt;V&gt; rangeByScore(K key, double min, double max) ZRANGEBYSCORE key min max — 按 score 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max) ZRANGEBYSCORE key min max WITHSCORES — score 分页 Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max LIMIT offset count — score 分页（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count 按 score 升序分页，返回 member + score 倒序 rank 查询 Set&lt;V&gt; reverseRange(K key, long start, long end) ZREVRANGE key start end 按 rank 倒序（高 → 低） 倒序 rank（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end) ZREVRANGE key start end WITHSCORES 倒序 rank，返回 score 倒序 score 查询 Set&lt;V&gt; reverseRangeByScore(K key, double min, double max) ZREVRANGEBYSCORE key max min 注意：max 在前，min 在后 倒序 score（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max) ZREVRANGEBYSCORE key max min WITHSCORES 倒序 score，返回 score 弹出元素（队列 / TopN 场景） 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令 备注 弹出最小 score TypedTuple&lt;V&gt; popMin(K key) ZPOPMIN key — 批量弹出最小 score Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count) ZPOPMIN key count — 阻塞弹出最小 score TypedTuple&lt;V&gt; popMin(K key, timeout) BZPOPMIN key timeout — 弹出最大 score TypedTuple&lt;V&gt; popMax(K key) ZPOPMAX key — 批量弹出最大 score Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count) ZPOPMAX key count — 阻塞弹出最大 score TypedTuple&lt;V&gt; popMax(K key, timeout) BZPOPMAX key timeout — 区间删除 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令（完整） 按 rank 删除 Long removeRange(K key, long start, long end) ZREMRANGEBYRANK key start end 按 score 删除 Long removeRangeByScore(K key, double min, double max) ZREMRANGEBYSCORE key min max 按 lex 删除 Long removeRangeByLex(K key, Range&lt;String&gt; range) ZREMRANGEBYLEX key min max 集合运算（ZSet 特有） 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令（完整） 备注 差集 Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] Redis ≥ 6.2 差集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 差集并存储 Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZDIFFSTORE destination numkeys key [otherKey ...] Redis ≥ 6.2 交集 Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] Redis ≥ 6.2 交集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 并集 Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] Redis ≥ 6.2 并集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 交集并存储 Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZINTERSTORE destination numkeys key [key ...] 并集并存储 Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZUNIONSTORE destination numkeys key [key ...] Lex（字典序，仅 score 相同） Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。 只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义 如果 score 不同，Redis 文档明确说明：结果不可预测 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令（完整） 备注 按 lex 查询 Set&lt;V&gt; rangeByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] score 必须相同 倒序 lex 查询 Set&lt;V&gt; reverseRangeByLex(...) ZREVRANGEBYLEX key max min [LIMIT offset count] — lex 范围存储 Long rangeAndStoreByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey Spring 封装 score 范围存储 Long rangeAndStoreByScore(...) ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey Spring 封装 Lex 范围写法规则 写法 含义 [a ≥ a（包含） (a &gt; a（不包含） [z ≤ z + 正无穷 - 负无穷 示例 12# a ≤ member &lt; dZRANGEBYLEX my:zset [a (d 遍历 方法功能 方法redisTemplate.opsForZSet().xxx() Redis 原始命令（完整） 备注 游标扫描 Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options) ZSCAN key cursor [MATCH pattern] [COUNT count] 推荐替代全量查询","summary":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","title":"Redis 命令及数据类型 -- Set","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Set 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Set-数据类型\">Set 数据类型</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 是一个无序、不重复元素集合，本质上是：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Set&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素唯一（自动去重）</span><br><span class=\"line\">无顺序（不保证插入顺序）</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Set 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动去重</span><br><span class=\"line\">高效成员判断</span><br><span class=\"line\">支持集合运算</span><br><span class=\"line\">操作原子性强</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 适合 成员资格判断</span><br><span class=\"line\">始终控制成员规模</span><br><span class=\"line\">大 Set 遍历使用 SSCAN</span><br><span class=\"line\">集合运算放在离线或低频场景</span><br><span class=\"line\">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForSet().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>向集合添加元素</td>\n<td><code>Long add(K key, V... values)</code></td>\n<td><code>SADD key member [member ...]</code></td>\n<td>返回新增成员数量</td>\n</tr>\n<tr>\n<td>从集合移除元素</td>\n<td><code>Long remove(K key, Object... values)</code></td>\n<td><code>SREM key member [member ...]</code></td>\n<td>返回移除成员数量</td>\n</tr>\n<tr>\n<td>随机弹出一个元素</td>\n<td><code>V pop(K key)</code></td>\n<td><code>SPOP key</code></td>\n<td>随机且删除</td>\n</tr>\n<tr>\n<td>随机弹出多个元素</td>\n<td><code>List&lt;V&gt; pop(K key, long count)</code></td>\n<td><code>SPOP key count</code></td>\n<td>Redis ≥ 3.2</td>\n</tr>\n<tr>\n<td>将成员移动到其他集合</td>\n<td><code>Boolean move(K key, V value, K destKey)</code></td>\n<td><code>SMOVE source dest member</code></td>\n<td>原子操作</td>\n</tr>\n<tr>\n<td>获取集合大小</td>\n<td><code>Long size(K key)</code></td>\n<td><code>SCARD key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>判断是否是成员</td>\n<td><code>Boolean isMember(K key, Object o)</code></td>\n<td><code>SISMEMBER key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量判断成员是否存在</td>\n<td><code>Map&lt;Object, Boolean&gt; isMember(K key, Object... objects)</code></td>\n<td><code>SMISMEMBER key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, K otherKey)</code></td>\n<td><code>SINTER key key</code></td>\n<td>O(N × M)</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>Set&lt;V&gt; intersect(Collection&lt;K&gt; keys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SINTERSTORE dest key key</code></td>\n<td>返回结果数量</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>Set&lt;V&gt; union(K key, K otherKey)</code></td>\n<td><code>SUNION key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>Set&lt;V&gt; union(Collection&lt;K&gt; keys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>Set&lt;V&gt; difference(K key, K otherKey)</code></td>\n<td><code>SDIFF key key</code></td>\n<td>key 顺序影响结果</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>Set&lt;V&gt; difference(Collection&lt;K&gt; keys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取所有成员</td>\n<td><code>Set&lt;V&gt; members(K key)</code></td>\n<td><code>SMEMBERS key</code></td>\n<td>大集合慎用，推荐 <code>SSCAN key cursor [MATCH] [COUNT]</code></td>\n</tr>\n<tr>\n<td>随机获取一个成员（不删除）</td>\n<td><code>V randomMember(K key)</code></td>\n<td><code>SRANDMEMBER key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n<tr>\n<td>游标扫描成员</td>\n<td><code>Cursor&lt;V&gt; scan(K key, ScanOptions options)</code></td>\n<td><code>SSCAN key cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>SMEMBERS</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Set 数据类型 Redis Set 是一个无序、不重复元素集合，本质上是： 12345key -&gt; Set&lt;String&gt;# 说明元素唯一（自动去重）无顺序（不保证插入顺序）元素类型为 String（二进制安全） Set 的核心特性 1234自动去重高效成员判断支持集合运算操作原子性强 Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 生产环境建议 12345Set 适合 成员资格判断始终控制成员规模大 Set 遍历使用 SSCAN集合运算放在离线或低频场景删除大 Set 使用 UNLINK SpringBoot 的 RedisTemplate&lt;K,V&gt; 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 方法功能 方法redisTemplate.opsForSet().xxx() Redis 原始命令 命令备注 / 推荐替代 向集合添加元素 Long add(K key, V... values) SADD key member [member ...] 返回新增成员数量 从集合移除元素 Long remove(K key, Object... values) SREM key member [member ...] 返回移除成员数量 随机弹出一个元素 V pop(K key) SPOP key 随机且删除 随机弹出多个元素 List&lt;V&gt; pop(K key, long count) SPOP key count Redis ≥ 3.2 将成员移动到其他集合 Boolean move(K key, V value, K destKey) SMOVE source dest member 原子操作 获取集合大小 Long size(K key) SCARD key — 判断是否是成员 Boolean isMember(K key, Object o) SISMEMBER key member — 批量判断成员是否存在 Map&lt;Object, Boolean&gt; isMember(K key, Object... objects) SMISMEMBER key member [member ...] Redis ≥ 6.2 计算交集 Set&lt;V&gt; intersect(K key, K otherKey) SINTER key key O(N × M) 计算交集 Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys) SINTER key [key ...] — 计算交集 Set&lt;V&gt; intersect(Collection&lt;K&gt; keys) SINTER key [key ...] — 交集并存储 Long intersectAndStore(K key, K otherKey, K destKey) SINTERSTORE dest key key 返回结果数量 交集并存储 Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SINTERSTORE dest key [key ...] — 交集并存储 Long intersectAndStore(Collection&lt;K&gt; keys, K destKey) SINTERSTORE dest key [key ...] — 计算并集 Set&lt;V&gt; union(K key, K otherKey) SUNION key key — 计算并集 Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys) SUNION key [key ...] — 计算并集 Set&lt;V&gt; union(Collection&lt;K&gt; keys) SUNION key [key ...] — 并集并存储 Long unionAndStore(K key, K otherKey, K destKey) SUNIONSTORE dest key key — 并集并存储 Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SUNIONSTORE dest key [key ...] — 并集并存储 Long unionAndStore(Collection&lt;K&gt; keys, K destKey) SUNIONSTORE dest key [key ...] — 计算差集 Set&lt;V&gt; difference(K key, K otherKey) SDIFF key key key 顺序影响结果 计算差集 Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys) SDIFF key [key ...] — 计算差集 Set&lt;V&gt; difference(Collection&lt;K&gt; keys) SDIFF key [key ...] — 差集并存储 Long differenceAndStore(K key, K otherKey, K destKey) SDIFFSTORE dest key key — 差集并存储 Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SDIFFSTORE dest key [key ...] — 差集并存储 Long differenceAndStore(Collection&lt;K&gt; keys, K destKey) SDIFFSTORE dest key [key ...] — 获取所有成员 Set&lt;V&gt; members(K key) SMEMBERS key 大集合慎用，推荐 SSCAN key cursor [MATCH] [COUNT] 随机获取一个成员（不删除） V randomMember(K key) SRANDMEMBER key — 随机获取不重复成员 Set&lt;V&gt; distinctRandomMembers(K key, long count) SRANDMEMBER key count count &gt; 0 随机获取可重复成员 List&lt;V&gt; randomMembers(K key, long count) SRANDMEMBER key -count count &lt; 0 游标扫描成员 Cursor&lt;V&gt; scan(K key, ScanOptions options) SSCAN key cursor [MATCH] [COUNT] 推荐替代 SMEMBERS","summary":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:38:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","title":"Redis 命令及数据类型 -- List","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis List 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"List-数据类型\">List 数据类型</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 是一个有序字符串列表，本质上是:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; List&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素按插入顺序排列</span><br><span class=\"line\">允许重复元素</span><br><span class=\"line\">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>List 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有序</span><br><span class=\"line\">可重复</span><br><span class=\"line\">双端操作（Deque）</span><br><span class=\"line\">支持阻塞读</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List 只用于 顺序消费</span><br><span class=\"line\">始终限制 List 长度（LTRIM）</span><br><span class=\"line\">避免中间插入、删除</span><br><span class=\"line\">大 List 删除使用 UNLINK</span><br><span class=\"line\">高可靠消息不要用 List</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>redisTemplate.opsForList().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定区间元素</td>\n<td><code>List&lt;V&gt; range(K key, long start, long end)</code></td>\n<td><code>LRANGE key start end</code></td>\n<td>end = -1 表示到末尾</td>\n</tr>\n<tr>\n<td>裁剪 list，仅保留指定区间</td>\n<td><code>void trim(K key, long start, long end)</code></td>\n<td><code>LTRIM key start end</code></td>\n<td>原地修改</td>\n</tr>\n<tr>\n<td>获取 list 长度</td>\n<td><code>Long size(K key)</code></td>\n<td><code>LLEN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>左侧插入一个元素</td>\n<td><code>Long leftPush(K key, V value)</code></td>\n<td><code>LPUSH key value</code></td>\n<td>返回插入后长度</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>Long leftPushAll(K key, V... values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>依次从左插入</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>Long leftPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时左侧插入</td>\n<td><code>Long leftPushIfPresent(K key, V value)</code></td>\n<td><code>LPUSHX key value</code></td>\n<td>key 不存在不执行</td>\n</tr>\n<tr>\n<td>在 pivot 左侧插入</td>\n<td><code>Long leftPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key BEFORE pivot value</code></td>\n<td>pivot：List 中某一个已存在的元素值 <br>pivot 不存在返回 -1</td>\n</tr>\n<tr>\n<td>右侧插入一个元素</td>\n<td><code>Long rightPush(K key, V value)</code></td>\n<td><code>RPUSH key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>Long rightPushAll(K key, V... values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>Long rightPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时右侧插入</td>\n<td><code>Long rightPushIfPresent(K key, V value)</code></td>\n<td><code>RPUSHX key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>在 pivot 右侧插入</td>\n<td><code>Long rightPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key AFTER pivot value</code></td>\n<td>pivot 不存在返回 -1</td>\n</tr>\n<tr>\n<td>原子移动元素（非阻塞）</td>\n<td><code>V move(sourceKey, from, destinationKey, to)</code></td>\n<td><code>LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT</code></td>\n<td>Redis ≥ 6.2<br>LMOVE 本质等价于以下两个操作的原子组合:<br>1. 从 source 的一端 POP 一个元素<br>2. 将该元素 PUSH 到 destination 的一端<br>参数说明：  <br> sourceKey:源 List（从这里取一个元素）<br>destinationKey:目标 List（往这里放一个元素）<br>第一个 LEFT/RIGHT:从 sourceKey 的哪一端弹出元素<br>第二个 LEFT/RIGHT:从 destinationKey 的哪一端插入元素</td>\n</tr>\n<tr>\n<td>原子移动元素（阻塞）</td>\n<td><code>V move(sourceKey, from, destinationKey, to, timeout)</code></td>\n<td><code>BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout</code></td>\n<td>Redis ≥ 6.2<br>timeout: 当 sourceKey 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。<br>timeout = 0：无限期阻塞，直到有数据可用或连接断开</td>\n</tr>\n<tr>\n<td>设置指定索引的值</td>\n<td><code>void set(K key, long index, V value)</code></td>\n<td><code>LSET key index value</code></td>\n<td>index 越界报错</td>\n</tr>\n<tr>\n<td>删除指定值</td>\n<td><code>Long remove(K key, long count, Object value)</code></td>\n<td><code>LREM key count value</code></td>\n<td>count &gt;0 从左，&lt;0 从右</td>\n</tr>\n<tr>\n<td>获取第一个元素</td>\n<td><code>V getFirst(K key)</code></td>\n<td><code>LINDEX key 0</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取最后一个元素</td>\n<td><code>V getLast(K key)</code></td>\n<td><code>LINDEX key -1</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取指定索引元素</td>\n<td><code>V index(K key, long index)</code></td>\n<td><code>LINDEX key index</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取首次出现位置</td>\n<td><code>Long indexOf(K key, V value)</code></td>\n<td><code>LPOS key value</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n<tr>\n<td>获取最后出现位置</td>\n<td><code>Long lastIndexOf(K key, V value)</code></td>\n<td><code>LPOS key value RANK -1</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n<tr>\n<td>左侧弹出</td>\n<td><code>V leftPop(K key)</code></td>\n<td><code>LPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>左侧批量弹出</td>\n<td><code>List&lt;V&gt; leftPop(K key, long count)</code></td>\n<td><code>LPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>左侧阻塞弹出</td>\n<td><code>V leftPop(K key, timeout)</code></td>\n<td><code>BLPOP key timeout</code></td>\n<td>阻塞操作</td>\n</tr>\n<tr>\n<td>右侧弹出</td>\n<td><code>V rightPop(K key)</code></td>\n<td><code>RPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量弹出</td>\n<td><code>List&lt;V&gt; rightPop(K key, long count)</code></td>\n<td><code>RPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>右侧阻塞弹出</td>\n<td><code>V rightPop(K key, timeout)</code></td>\n<td><code>BRPOP key timeout</code></td>\n<td>阻塞操作</td>\n</tr>\n<tr>\n<td>右侧弹出并左侧插入</td>\n<td><code>V rightPopAndLeftPush(sourceKey, destinationKey)</code></td>\n<td><code>RPOPLPUSH source dest</code> <strong>已废弃</strong></td>\n<td><strong>推荐</strong> <code>LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT</code></td>\n</tr>\n<tr>\n<td>阻塞式右弹左插</td>\n<td><code>V rightPopAndLeftPush(sourceKey, destinationKey, timeout)</code></td>\n<td><code>BRPOPLPUSH source dest timeout</code><strong>已废弃</strong></td>\n<td><strong>推荐</strong> <code>BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ List 数据类型 Redis List 是一个有序字符串列表，本质上是: 12345key -&gt; List&lt;String&gt;# 说明元素按插入顺序排列允许重复元素支持从 左（头） 和 右（尾） 两端操作 List 的核心特性 12345有序可重复双端操作（Deque）支持阻塞读元素类型为 String（二进制安全） Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 生产环境建议 12345List 只用于 顺序消费始终限制 List 长度（LTRIM）避免中间插入、删除大 List 删除使用 UNLINK高可靠消息不要用 List SpringBoot 的 RedisTemplate&lt;K,V&gt; 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 方法功能 方法 redisTemplate.opsForList().xxx() Redis 原始命令 命令备注 / 推荐替代 获取指定区间元素 List&lt;V&gt; range(K key, long start, long end) LRANGE key start end end = -1 表示到末尾 裁剪 list，仅保留指定区间 void trim(K key, long start, long end) LTRIM key start end 原地修改 获取 list 长度 Long size(K key) LLEN key — 左侧插入一个元素 Long leftPush(K key, V value) LPUSH key value 返回插入后长度 左侧批量插入 Long leftPushAll(K key, V... values) LPUSH key value [value ...] 依次从左插入 左侧批量插入 Long leftPushAll(K key, Collection&lt;V&gt; values) LPUSH key value [value ...] — key 存在时左侧插入 Long leftPushIfPresent(K key, V value) LPUSHX key value key 不存在不执行 在 pivot 左侧插入 Long leftPush(K key, V pivot, V value) LINSERT key BEFORE pivot value pivot：List 中某一个已存在的元素值 pivot 不存在返回 -1 右侧插入一个元素 Long rightPush(K key, V value) RPUSH key value — 右侧批量插入 Long rightPushAll(K key, V... values) RPUSH key value [value ...] — 右侧批量插入 Long rightPushAll(K key, Collection&lt;V&gt; values) RPUSH key value [value ...] — key 存在时右侧插入 Long rightPushIfPresent(K key, V value) RPUSHX key value — 在 pivot 右侧插入 Long rightPush(K key, V pivot, V value) LINSERT key AFTER pivot value pivot 不存在返回 -1 原子移动元素（非阻塞） V move(sourceKey, from, destinationKey, to) LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT Redis ≥ 6.2LMOVE 本质等价于以下两个操作的原子组合:1. 从 source 的一端 POP 一个元素2. 将该元素 PUSH 到 destination 的一端参数说明： sourceKey:源 List（从这里取一个元素）destinationKey:目标 List（往这里放一个元素）第一个 LEFT/RIGHT:从 sourceKey 的哪一端弹出元素第二个 LEFT/RIGHT:从 destinationKey 的哪一端插入元素 原子移动元素（阻塞） V move(sourceKey, from, destinationKey, to, timeout) BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout Redis ≥ 6.2timeout: 当 sourceKey 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。timeout = 0：无限期阻塞，直到有数据可用或连接断开 设置指定索引的值 void set(K key, long index, V value) LSET key index value index 越界报错 删除指定值 Long remove(K key, long count, Object value) LREM key count value count &gt;0 从左，&lt;0 从右 获取第一个元素 V getFirst(K key) LINDEX key 0 O(N) 获取最后一个元素 V getLast(K key) LINDEX key -1 O(N) 获取指定索引元素 V index(K key, long index) LINDEX key index O(N) 获取首次出现位置 Long indexOf(K key, V value) LPOS key value Redis ≥ 6.0 获取最后出现位置 Long lastIndexOf(K key, V value) LPOS key value RANK -1 Redis ≥ 6.0 左侧弹出 V leftPop(K key) LPOP key — 左侧批量弹出 List&lt;V&gt; leftPop(K key, long count) LPOP key count Redis ≥ 6.2 左侧阻塞弹出 V leftPop(K key, timeout) BLPOP key timeout 阻塞操作 右侧弹出 V rightPop(K key) RPOP key — 右侧批量弹出 List&lt;V&gt; rightPop(K key, long count) RPOP key count Redis ≥ 6.2 右侧阻塞弹出 V rightPop(K key, timeout) BRPOP key timeout 阻塞操作 右侧弹出并左侧插入 V rightPopAndLeftPush(sourceKey, destinationKey) RPOPLPUSH source dest 已废弃 推荐 LMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT 阻塞式右弹左插 V rightPopAndLeftPush(sourceKey, destinationKey, timeout) BRPOPLPUSH source dest timeout已废弃 推荐 BLMOVE sourceKey destKey LEFT|RIGHT LEFT|RIGHT timeout","summary":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:35:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","title":"Redis 命令及数据类型 -- Hash","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hash 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hash-数据类型\">Hash 数据类型</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Map&lt;String, String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">key：Redis 的键（只能是 String）</span><br><span class=\"line\">field：Hash 内的字段名（String）</span><br><span class=\"line\">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">适合存储对象型数据</span><br><span class=\"line\">支持 字段级别读写</span><br><span class=\"line\">所有操作均为 原子性</span><br><span class=\"line\">内存效率优于「String + JSON」</span><br><span class=\"line\">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个 Hash = 一个对象</span><br><span class=\"line\">field 数量建议 &lt; 100</span><br><span class=\"line\">单 field value 建议 &lt; 1 KB</span><br><span class=\"line\">大对象拆分为多个 Hash</span><br><span class=\"line\">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法<code>redisTemplate.opsForHash().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除一个或多个 hash field</td>\n<td><code>Long delete(H key, Object... hashKeys)</code></td>\n<td><code>HDEL key field [field ...]</code></td>\n<td>返回删除 field 数量</td>\n</tr>\n<tr>\n<td>判断 hash field 是否存在</td>\n<td><code>Boolean hasKey(H key, Object hashKey)</code></td>\n<td><code>HEXISTS key field</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取指定 field 的值</td>\n<td><code>HV get(H key, Object hashKey)</code></td>\n<td><code>HGET key field</code></td>\n<td>field 不存在返回 <code>null</code></td>\n</tr>\n<tr>\n<td>批量获取多个 field 的值</td>\n<td><code>List&lt;HV&gt; multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HMGET key field [field ...]</code></td>\n<td>不存在的 field 返回 <code>null</code></td>\n</tr>\n<tr>\n<td>hash field 整数自增</td>\n<td><code>Long increment(H key, HK hashKey, long delta)</code></td>\n<td><code>HINCRBY key field increment</code></td>\n<td>value 必须是整数</td>\n</tr>\n<tr>\n<td>hash field 浮点数自增</td>\n<td><code>Double increment(H key, HK hashKey, double delta)</code></td>\n<td><code>HINCRBYFLOAT key field increment</code></td>\n<td>Redis ≥ 2.6</td>\n</tr>\n<tr>\n<td>随机返回一个 field</td>\n<td><code>HK randomKey(H key)</code></td>\n<td><code>HRANDFIELD key</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回一个 field-value</td>\n<td><code>Map.Entry&lt;HK,HV&gt; randomEntry(H key)</code></td>\n<td><code>HRANDFIELD key WITHVALUES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回多个 field</td>\n<td><code>List&lt;HK&gt; randomKeys(H key, long count)</code></td>\n<td><code>HRANDFIELD key count</code></td>\n<td>count &lt; 0 可重复</td>\n</tr>\n<tr>\n<td>随机返回多个 field-value</td>\n<td><code>Map&lt;HK,HV&gt; randomEntries(H key, long count)</code></td>\n<td><code>HRANDFIELD key count WITHVALUES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>获取 hash 中所有 field</td>\n<td><code>Set&lt;HK&gt; keys(H key)</code></td>\n<td><code>HKEYS key</code></td>\n<td>O(N)，大 hash 慎用</td>\n</tr>\n<tr>\n<td>获取 field 对应 value 长度</td>\n<td><code>Long lengthOfValue(H key, HK hashKey)</code></td>\n<td><code>HSTRLEN key field</code></td>\n<td>field 不存在返回 0</td>\n</tr>\n<tr>\n<td>获取 hash 中 field 数量</td>\n<td><code>Long size(H key)</code></td>\n<td><code>HLEN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量设置 field-value</td>\n<td><code>void putAll(H key, Map&lt;HK,HV&gt; m)</code></td>\n<td><code>HMSET key field value [...]</code> <strong>已废弃</strong></td>\n<td>Redis 4+ 实际映射为 <code>HSET</code></td>\n</tr>\n<tr>\n<td>设置单个 field-value</td>\n<td><code>void put(H key, HK hashKey, HV value)</code></td>\n<td><code>HSET key field value</code></td>\n<td>新增或覆盖</td>\n</tr>\n<tr>\n<td>field 不存在时设置</td>\n<td><code>Boolean putIfAbsent(H key, HK hashKey, HV value)</code></td>\n<td><code>HSETNX key field value</code></td>\n<td>原子操作</td>\n</tr>\n<tr>\n<td>获取所有 value</td>\n<td><code>List&lt;HV&gt; values(H key)</code></td>\n<td><code>HVALS key</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取所有 field-value</td>\n<td><code>Map&lt;HK,HV&gt; entries(H key)</code></td>\n<td><code>HGETALL key</code></td>\n<td><strong>生产环境慎用</strong></td>\n</tr>\n<tr>\n<td>游标扫描 hash</td>\n<td><code>Cursor&lt;Map.Entry&lt;HK,HV&gt;&gt; scan(H key, ScanOptions options)</code></td>\n<td><code>HSCAN key cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>HGETALL</code></td>\n</tr>\n<tr>\n<td>为指定 field 设置过期时间</td>\n<td><code>ExpireChanges&lt;HK&gt; expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE key seconds FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.0</td>\n</tr>\n<tr>\n<td>为指定 field 设置过期时间点</td>\n<td><code>ExpireChanges&lt;HK&gt; expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.0</td>\n</tr>\n<tr>\n<td>设置 field 过期策略（高级）</td>\n<td><code>ExpireChanges&lt;HK&gt; expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE / HEXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n<tr>\n<td>移除指定 field 的过期时间</td>\n<td><code>ExpireChanges&lt;HK&gt; persist(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HPERSIST key FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.0</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hash 数据类型 Redis Hash 是一种 key → field → value 的数据结构，本质上是 12345key -&gt; Map&lt;String, String&gt;# 说明key：Redis 的键（只能是 String）field：Hash 内的字段名（String）value：字段值（String，二进制安全） Hash 的核心特性 12345适合存储对象型数据支持 字段级别读写所有操作均为 原子性内存效率优于「String + JSON」单个 Hash 理论最大 512 MB 生产环境建议 12345一个 Hash = 一个对象field 数量建议 &lt; 100单 field value 建议 &lt; 1 KB大对象拆分为多个 Hash避免在大 Hash 上使用 HGETALL SpringBoot 的 RedisTemplate&lt;K,V&gt; 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 方法功能 方法redisTemplate.opsForHash().xxx() Redis 原始命令 命令备注 / 推荐替代 删除一个或多个 hash field Long delete(H key, Object... hashKeys) HDEL key field [field ...] 返回删除 field 数量 判断 hash field 是否存在 Boolean hasKey(H key, Object hashKey) HEXISTS key field — 获取指定 field 的值 HV get(H key, Object hashKey) HGET key field field 不存在返回 null 批量获取多个 field 的值 List&lt;HV&gt; multiGet(H key, Collection&lt;HK&gt; hashKeys) HMGET key field [field ...] 不存在的 field 返回 null hash field 整数自增 Long increment(H key, HK hashKey, long delta) HINCRBY key field increment value 必须是整数 hash field 浮点数自增 Double increment(H key, HK hashKey, double delta) HINCRBYFLOAT key field increment Redis ≥ 2.6 随机返回一个 field HK randomKey(H key) HRANDFIELD key Redis ≥ 6.2 随机返回一个 field-value Map.Entry&lt;HK,HV&gt; randomEntry(H key) HRANDFIELD key WITHVALUES Redis ≥ 6.2 随机返回多个 field List&lt;HK&gt; randomKeys(H key, long count) HRANDFIELD key count count &lt; 0 可重复 随机返回多个 field-value Map&lt;HK,HV&gt; randomEntries(H key, long count) HRANDFIELD key count WITHVALUES Redis ≥ 6.2 获取 hash 中所有 field Set&lt;HK&gt; keys(H key) HKEYS key O(N)，大 hash 慎用 获取 field 对应 value 长度 Long lengthOfValue(H key, HK hashKey) HSTRLEN key field field 不存在返回 0 获取 hash 中 field 数量 Long size(H key) HLEN key — 批量设置 field-value void putAll(H key, Map&lt;HK,HV&gt; m) HMSET key field value [...] 已废弃 Redis 4+ 实际映射为 HSET 设置单个 field-value void put(H key, HK hashKey, HV value) HSET key field value 新增或覆盖 field 不存在时设置 Boolean putIfAbsent(H key, HK hashKey, HV value) HSETNX key field value 原子操作 获取所有 value List&lt;HV&gt; values(H key) HVALS key O(N) 获取所有 field-value Map&lt;HK,HV&gt; entries(H key) HGETALL key 生产环境慎用 游标扫描 hash Cursor&lt;Map.Entry&lt;HK,HV&gt;&gt; scan(H key, ScanOptions options) HSCAN key cursor [MATCH] [COUNT] 推荐替代 HGETALL 为指定 field 设置过期时间 ExpireChanges&lt;HK&gt; expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys) HEXPIRE key seconds FIELDS n field [...] Redis ≥ 7.0 为指定 field 设置过期时间点 ExpireChanges&lt;HK&gt; expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys) HEXPIREAT key timestamp FIELDS n field [...] Redis ≥ 7.0 设置 field 过期策略（高级） ExpireChanges&lt;HK&gt; expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys) HEXPIRE / HEXPIREAT Spring 抽象封装 移除指定 field 的过期时间 ExpireChanges&lt;HK&gt; persist(H key, Collection&lt;HK&gt; hashKeys) HPERSIST key FIELDS n field [...] Redis ≥ 7.0","summary":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:33:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","title":"Redis 命令及数据类型 -- String","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis String 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"String-数据类型\">String 数据类型</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据形式</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通字符串</td>\n<td><code>&quot;hello redis&quot;</code></td>\n</tr>\n<tr>\n<td>数字（整型/浮点）</td>\n<td><code>&quot;100&quot;</code>, <code>&quot;3.14&quot;</code></td>\n</tr>\n<tr>\n<td>JSON</td>\n<td><code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125;</code></td>\n</tr>\n<tr>\n<td>序列化对象</td>\n<td>Java / JSON / ProtoBuf</td>\n</tr>\n<tr>\n<td>Base64 / 二进制</td>\n<td>图片、Token 等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>最大存储大小（MB）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Key</td>\n<td>&lt; 1k</td>\n</tr>\n<tr>\n<td>Value</td>\n<td>&lt; 1MB</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;</code> 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>redisTemplate.opsForValue().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置 key 的值</td>\n<td><code>void set(K key, V value)</code></td>\n<td><code>SET key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 不存在时设置</td>\n<td><code>Boolean setIfAbsent(K key, V value)</code></td>\n<td><code>SET key value NX</code></td>\n<td>NX: 如果key 不存在则设置</td>\n</tr>\n<tr>\n<td>key 不存在时设置并指定过期时间</td>\n<td><code>Boolean setIfAbsent(K key, V value, long timeout, TimeUnit unit)</code></td>\n<td><code>SET key value NX EX seconds</code></td>\n<td>EX: 指定过期时间，单位为秒<br>PX: 指定过期时间，单位为毫秒</td>\n</tr>\n<tr>\n<td>key 存在时设置</td>\n<td><code>Boolean setIfPresent(K key, V value)</code></td>\n<td><code>SET key value XX</code></td>\n<td>XX: 如果key 存在则设置</td>\n</tr>\n<tr>\n<td>key 存在时设置并指定过期时间</td>\n<td><code>Boolean setIfPresent(K key, V value, long timeout, TimeUnit unit)</code></td>\n<td><code>SET key value XX EX seconds</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>设置值并指定过期时间</td>\n<td><code>void set(K key, V value, long timeout, TimeUnit unit)</code></td>\n<td><code>SETEX key seconds value</code> <strong>即将作废</strong></td>\n<td><strong>推荐</strong> → <code>SET key value EX seconds</code></td>\n</tr>\n<tr>\n<td>获取 key 的值</td>\n<td><code>V get(K key)</code></td>\n<td><code>GET key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取值并重置过期时间</td>\n<td><code>V getAndExpire(K key, long timeout, TimeUnit unit)</code></td>\n<td><code>GETEX key EX seconds</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>获取值并删除 key</td>\n<td><code>V getAndDelete(K key)</code></td>\n<td><code>GETDEL key</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>获取字符串指定区间</td>\n<td><code>V get(K key, long start, long end)</code></td>\n<td><code>GETRANGE key start end</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取字符串长度</td>\n<td><code>Long size(K key)</code></td>\n<td><code>STRLEN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取旧值并设置新值</td>\n<td><code>V getAndSet(K key, V value)</code></td>\n<td><code>GETSET key value</code> <strong>即将作废</strong></td>\n<td><strong>推荐</strong> → <code>SET key value GET</code></td>\n</tr>\n<tr>\n<td>获取 key 的当前值并移除过期时间</td>\n<td><code>V getAndPersist(K key)</code></td>\n<td><code>GETEX key PERSIST</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>数值自增 1</td>\n<td><code>Long increment(K key)</code></td>\n<td><code>INCR key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值增加指定值</td>\n<td><code>Long increment(K key, long delta)</code></td>\n<td><code>INCRBY key increment</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值自减 1</td>\n<td><code>Long decrement(K key)</code></td>\n<td><code>DECR key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值减少指定值</td>\n<td><code>Long decrement(K key, long delta)</code></td>\n<td><code>DECRBY key decrement</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量设置 key-value</td>\n<td><code>void multiSet(Map&lt;K,V&gt; map)</code></td>\n<td><code>MSET key value [key value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量获取 key 的值</td>\n<td><code>List&lt;V&gt; multiGet(Collection&lt;K&gt; keys)</code></td>\n<td><code>MGET key [key ...]</code></td>\n<td>不存在的 key 返回 <code>null</code></td>\n</tr>\n<tr>\n<td>同时设置多个 key-value（仅当全部不存在）</td>\n<td><code>Boolean multiSetIfAbsent(Map&lt;K, V&gt; map)</code></td>\n<td><code>MSETNX key value [key value ...]</code></td>\n<td>原子操作：要么全部成功，要么全部失败</td>\n</tr>\n<tr>\n<td>追加字符串并返回新长度</td>\n<td><code>Integer append(K key, String value)</code></td>\n<td><code>APPEND key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>为key设置新值，同时保留原来的过期时间</td>\n<td><code>没有对应的方法</code></td>\n<td><code>SET key value KEEPTTL</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ String 数据类型 在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。 Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。 Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等 数据形式 示例 普通字符串 &quot;hello redis&quot; 数字（整型/浮点） &quot;100&quot;, &quot;3.14&quot; JSON &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125; 序列化对象 Java / JSON / ProtoBuf Base64 / 二进制 图片、Token 等 单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下 分类 最大存储大小（MB） Key &lt; 1k Value &lt; 1MB SpringBoot 的 RedisTemplate&lt;K,V&gt; 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 方法功能 方法 redisTemplate.opsForValue().xxx() Redis 原始命令 命令备注 / 推荐替代 设置 key 的值 void set(K key, V value) SET key value — key 不存在时设置 Boolean setIfAbsent(K key, V value) SET key value NX NX: 如果key 不存在则设置 key 不存在时设置并指定过期时间 Boolean setIfAbsent(K key, V value, long timeout, TimeUnit unit) SET key value NX EX seconds EX: 指定过期时间，单位为秒PX: 指定过期时间，单位为毫秒 key 存在时设置 Boolean setIfPresent(K key, V value) SET key value XX XX: 如果key 存在则设置 key 存在时设置并指定过期时间 Boolean setIfPresent(K key, V value, long timeout, TimeUnit unit) SET key value XX EX seconds — 设置值并指定过期时间 void set(K key, V value, long timeout, TimeUnit unit) SETEX key seconds value 即将作废 推荐 → SET key value EX seconds 获取 key 的值 V get(K key) GET key — 获取值并重置过期时间 V getAndExpire(K key, long timeout, TimeUnit unit) GETEX key EX seconds Redis ≥ 6.2 获取值并删除 key V getAndDelete(K key) GETDEL key Redis ≥ 6.2 获取字符串指定区间 V get(K key, long start, long end) GETRANGE key start end — 获取字符串长度 Long size(K key) STRLEN key — 获取旧值并设置新值 V getAndSet(K key, V value) GETSET key value 即将作废 推荐 → SET key value GET 获取 key 的当前值并移除过期时间 V getAndPersist(K key) GETEX key PERSIST Redis ≥ 6.2 数值自增 1 Long increment(K key) INCR key — 数值增加指定值 Long increment(K key, long delta) INCRBY key increment — 数值自减 1 Long decrement(K key) DECR key — 数值减少指定值 Long decrement(K key, long delta) DECRBY key decrement — 批量设置 key-value void multiSet(Map&lt;K,V&gt; map) MSET key value [key value ...] — 批量获取 key 的值 List&lt;V&gt; multiGet(Collection&lt;K&gt; keys) MGET key [key ...] 不存在的 key 返回 null 同时设置多个 key-value（仅当全部不存在） Boolean multiSetIfAbsent(Map&lt;K, V&gt; map) MSETNX key value [key value ...] 原子操作：要么全部成功，要么全部失败 追加字符串并返回新长度 Integer append(K key, String value) APPEND key value — 为key设置新值，同时保留原来的过期时间 没有对应的方法 SET key value KEEPTTL —","summary":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:31:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","title":"Redis 命令及数据类型 -- 通用命令","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"通用命令\">通用命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>针对所有数据类型均可使用给的方法和命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>redisTemplate.xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制 key 到新 key</td>\n<td><code>Boolean copy(K source, K target, boolean replace)</code></td>\n<td><code>COPY source target [REPLACE]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>判断 key 是否存在（单个）</td>\n<td><code>Boolean hasKey(K key)</code></td>\n<td><code>EXISTS key</code></td>\n<td>CLI 返回存在数量</td>\n</tr>\n<tr>\n<td>统计存在的 key 数量</td>\n<td><code>Long countExistingKeys(Collection&lt;K&gt; keys)</code></td>\n<td><code>EXISTS key [key ...]</code></td>\n<td>返回存在 key 的数量</td>\n</tr>\n<tr>\n<td>删除指定 key（同步）</td>\n<td><code>Boolean delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>返回是否删除成功</td>\n</tr>\n<tr>\n<td>批量删除 key（同步）</td>\n<td><code>Long delete(Collection&lt;K&gt; keys)</code></td>\n<td><code>DEL key [key ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>删除 key（异步）</td>\n<td><code>Boolean unlink(K key)</code></td>\n<td><code>UNLINK key</code></td>\n<td>非阻塞删除</td>\n</tr>\n<tr>\n<td>批量删除 key（异步）</td>\n<td><code>Long unlink(Collection&lt;K&gt; keys)</code></td>\n<td><code>UNLINK key [key ...]</code></td>\n<td>推荐大 key 使用</td>\n</tr>\n<tr>\n<td>获取 key 的数据类型</td>\n<td><code>DataType type(K key)</code></td>\n<td><code>TYPE key</code></td>\n<td>返回 string/hash/list/set/zset/none</td>\n</tr>\n<tr>\n<td>按模式匹配 key（阻塞）</td>\n<td><code>Set&lt;K&gt; keys(K pattern)</code></td>\n<td><code>KEYS pattern</code></td>\n<td><strong>生产环境不推荐</strong></td>\n</tr>\n<tr>\n<td>游标方式扫描 key</td>\n<td><code>Cursor&lt;K&gt; scan(ScanOptions options)</code></td>\n<td><code>SCAN cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>KEYS</code></td>\n</tr>\n<tr>\n<td>随机返回一个 key</td>\n<td><code>K randomKey()</code></td>\n<td><code>RANDOMKEY</code></td>\n<td>可能返回 <code>null</code></td>\n</tr>\n<tr>\n<td>重命名 key</td>\n<td><code>void rename(K oldKey, K newKey)</code></td>\n<td><code>RENAME oldKey newKey</code></td>\n<td>覆盖目标 key</td>\n</tr>\n<tr>\n<td>key 不存在时重命名</td>\n<td><code>Boolean renameIfAbsent(K oldKey, K newKey)</code></td>\n<td><code>RENAMENX oldKey newKey</code></td>\n<td>原子操作</td>\n</tr>\n<tr>\n<td>设置 key 过期时间</td>\n<td><code>Boolean expire(K key, long timeout, TimeUnit unit)</code></td>\n<td><code>PEXPIRE / EXPIRE</code></td>\n<td>优先毫秒精度</td>\n</tr>\n<tr>\n<td>设置 key 在指定时间过期</td>\n<td><code>Boolean expireAt(K key, Date date)</code></td>\n<td><code>PEXPIREAT / EXPIREAT</code></td>\n<td>精度自动降级</td>\n</tr>\n<tr>\n<td>设置过期策略（高级 API）</td>\n<td><code>ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options)</code></td>\n<td><code>EXPIRE / PEXPIRE / EXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n<tr>\n<td>清除 key 的过期时间</td>\n<td><code>Boolean persist(K key)</code></td>\n<td><code>PERSIST key</code></td>\n<td>变为永久 key</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（秒）</td>\n<td><code>Long getExpire(K key)</code></td>\n<td><code>TTL key</code></td>\n<td><code>-1</code> 无 TTL，<code>-2</code> 不存在</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（指定单位）</td>\n<td><code>Long getExpire(K key, TimeUnit unit)</code></td>\n<td><code>PTTL / TTL</code></td>\n<td>优先毫秒</td>\n</tr>\n<tr>\n<td>将 key 移动到其他 DB</td>\n<td><code>Boolean move(K key, int dbIndex)</code></td>\n<td><code>MOVE key db</code></td>\n<td>集群模式不可用</td>\n</tr>\n<tr>\n<td>导出 key 的序列化值</td>\n<td><code>byte[] dump(K key)</code></td>\n<td><code>DUMP key</code></td>\n<td>用于迁移</td>\n</tr>\n<tr>\n<td>恢复 key</td>\n<td><code>void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace)</code></td>\n<td><code>RESTORE key ttl value [REPLACE]</code></td>\n<td>与 <code>DUMP</code> 配合</td>\n</tr>\n<tr>\n<td>排序并返回结果</td>\n<td><code>List&lt;V&gt; sort(SortQuery&lt;K&gt; query)</code></td>\n<td><code>SORT key</code></td>\n<td>阻塞操作</td>\n</tr>\n<tr>\n<td>排序并指定返回类型</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer)</code></td>\n<td><code>SORT key</code></td>\n<td>结果反序列化</td>\n</tr>\n<tr>\n<td>排序并映射结果</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>排序并映射（高级）</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>批量映射</td>\n</tr>\n<tr>\n<td>排序并存储结果</td>\n<td><code>Long sort(SortQuery&lt;K&gt; query, K storeKey)</code></td>\n<td><code>SORT key STORE destination</code></td>\n<td>返回结果条数</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境慎用的命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>原因</th>\n<th>推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>KEYS</code></td>\n<td>阻塞、O(N)</td>\n<td><code>SCAN</code></td>\n</tr>\n<tr>\n<td><code>SORT</code></td>\n<td>阻塞、消耗 CPU</td>\n<td>业务侧排序</td>\n</tr>\n<tr>\n<td><code>DEL</code></td>\n<td>阻塞、消耗 CPU</td>\n<td><code>UNLINK</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 通用命令 针对所有数据类型均可使用给的方法和命令 方法功能 方法 redisTemplate.xxx() Redis 原始命令 命令备注 / 推荐替代 复制 key 到新 key Boolean copy(K source, K target, boolean replace) COPY source target [REPLACE] Redis ≥ 6.2 判断 key 是否存在（单个） Boolean hasKey(K key) EXISTS key CLI 返回存在数量 统计存在的 key 数量 Long countExistingKeys(Collection&lt;K&gt; keys) EXISTS key [key ...] 返回存在 key 的数量 删除指定 key（同步） Boolean delete(K key) DEL key 返回是否删除成功 批量删除 key（同步） Long delete(Collection&lt;K&gt; keys) DEL key [key ...] 返回删除数量 删除 key（异步） Boolean unlink(K key) UNLINK key 非阻塞删除 批量删除 key（异步） Long unlink(Collection&lt;K&gt; keys) UNLINK key [key ...] 推荐大 key 使用 获取 key 的数据类型 DataType type(K key) TYPE key 返回 string/hash/list/set/zset/none 按模式匹配 key（阻塞） Set&lt;K&gt; keys(K pattern) KEYS pattern 生产环境不推荐 游标方式扫描 key Cursor&lt;K&gt; scan(ScanOptions options) SCAN cursor [MATCH] [COUNT] 推荐替代 KEYS 随机返回一个 key K randomKey() RANDOMKEY 可能返回 null 重命名 key void rename(K oldKey, K newKey) RENAME oldKey newKey 覆盖目标 key key 不存在时重命名 Boolean renameIfAbsent(K oldKey, K newKey) RENAMENX oldKey newKey 原子操作 设置 key 过期时间 Boolean expire(K key, long timeout, TimeUnit unit) PEXPIRE / EXPIRE 优先毫秒精度 设置 key 在指定时间过期 Boolean expireAt(K key, Date date) PEXPIREAT / EXPIREAT 精度自动降级 设置过期策略（高级 API） ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options) EXPIRE / PEXPIRE / EXPIREAT Spring 抽象封装 清除 key 的过期时间 Boolean persist(K key) PERSIST key 变为永久 key 获取剩余 TTL（秒） Long getExpire(K key) TTL key -1 无 TTL，-2 不存在 获取剩余 TTL（指定单位） Long getExpire(K key, TimeUnit unit) PTTL / TTL 优先毫秒 将 key 移动到其他 DB Boolean move(K key, int dbIndex) MOVE key db 集群模式不可用 导出 key 的序列化值 byte[] dump(K key) DUMP key 用于迁移 恢复 key void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace) RESTORE key ttl value [REPLACE] 与 DUMP 配合 排序并返回结果 List&lt;V&gt; sort(SortQuery&lt;K&gt; query) SORT key 阻塞操作 排序并指定返回类型 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer) SORT key 结果反序列化 排序并映射结果 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper) SORT key Spring 封装 排序并映射（高级） List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper) SORT key 批量映射 排序并存储结果 Long sort(SortQuery&lt;K&gt; query, K storeKey) SORT key STORE destination 返回结果条数 生产环境慎用的命令 命令 原因 推荐 KEYS 阻塞、O(N) SCAN SORT 阻塞、消耗 CPU 业务侧排序 DEL 阻塞、消耗 CPU UNLINK","summary":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","url":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","title":"Redis SCAN 命令详解：作用、用法与最佳实践","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。</li>\n<li class=\"lvl-2\">Redis 提供了两种思路：使用 <code>KEYS pattern</code> 或使用游标式遍历命令 <code>SCAN</code>。</li>\n<li class=\"lvl-2\"><code>KEYS pattern</code> 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用<code>KEYS pattern</code>等危险命令。</li>\n<li class=\"lvl-2\">所以Redis官方强烈推荐 <code>SCAN</code> 方式，其是最安全、最可控的遍历方法。</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"SCAN-的核心作用\">SCAN 的核心作用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的主要功能是<strong>基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key</strong>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 的设计目标包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">避免阻塞 Redis 主线程</li>\n<li class=\"lvl-5\">分批、渐进扫描大规模 key 集合</li>\n<li class=\"lvl-5\">灵活配合模式匹配（MATCH）</li>\n<li class=\"lvl-5\">控制每次返回 key 的数量（COUNT）</li>\n<li class=\"lvl-5\">在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 命令是完整游标遍历族的一部分，还包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\"><code>HSCAN</code>：遍历哈希表 field/value</li>\n<li class=\"lvl-5\"><code>SSCAN</code>：遍历 set 元素</li>\n<li class=\"lvl-5\"><code>ZSCAN</code>：遍历有序集合</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>为了完成后面的示例演示，这里准备一个测试数据批量生产脚本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 脚本名称：import_unified_data.sh</span></span><br><span class=\"line\"><span class=\"comment\"># 运行方法：sh $0 &lt;type&gt; [count]</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;type&gt;: string, hash, list, set, 或 zset</span></span><br><span class=\"line\"><span class=\"comment\"># [count]: 导入的数据量 (可选，默认为 100)</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 1. 参数校验与配置 ---</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUPPORTED_TYPES=<span class=\"string\">&quot;string hash list set zset&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 定义每个集合/列表/有序集合要添加的成员数量</span></span><br><span class=\"line\">MEMBERS_PER_KEY=5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查是否提供了类型参数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -lt 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：请指定导入类型。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: sh <span class=\"variable\">$0</span> &lt;type&gt; [count]&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取类型参数 (第一个参数)</span></span><br><span class=\"line\">DATA_TYPE=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;[:upper:]&#x27;</span> <span class=\"string\">&#x27;[:lower:]&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据量参数 (第二个参数)，不存在则默认为 1000</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -ge 2 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    DATA_COUNT=<span class=\"variable\">$2</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    DATA_COUNT=100</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查类型是否有效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ ! <span class=\"string\">&quot; <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span> &quot;</span> =~ <span class=\"string\">&quot; <span class=\"variable\">$&#123;DATA_TYPE&#125;</span> &quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：不支持的类型 &#x27;<span class=\"variable\">$DATA_TYPE</span>&#x27;。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 连接配置</span></span><br><span class=\"line\">REDIS_HOST=<span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">REDIS_PORT=<span class=\"string\">&quot;6379&quot;</span></span><br><span class=\"line\">REDIS_PASSWORD=<span class=\"string\">&quot;password&quot;</span> <span class=\"comment\"># 替换为你的实际密码或留空</span></span><br><span class=\"line\">KEY_PREFIX=<span class=\"string\">&quot;test_data&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># --- 2. 命令生成主逻辑 ---</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;⏳ 正在生成 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 Redis [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 命令...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建 RESP 命令流</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le <span class=\"variable\">$DATA_COUNT</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$DATA_TYPE</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\"># --- String 类型导入 (SET key value) ---</span></span><br><span class=\"line\">        string)</span><br><span class=\"line\">            KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:string:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            VALUE=<span class=\"string\">&quot;value_of_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"subst\">$(date +%s%N)</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># SET 命令 RESP 协议: *3 (SET, key, value)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$<span class=\"variable\">$&#123;#KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Hash 类型导入 (HSET key field1 value1 field2 value2) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">hash</span>)</span><br><span class=\"line\">            HASH_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:hash:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD1=<span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">            VALUE1=<span class=\"string\">&quot;User_Name_<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD2=<span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">            VALUE2=$(( (i % <span class=\"number\">50</span>) + <span class=\"number\">20</span> ))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$<span class=\"variable\">$&#123;#HASH_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;HASH_KEY&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD1&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD1&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE1&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE1&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD2&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD2&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE2&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE2&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- List 类型导入 (LPUSH key value) ---</span></span><br><span class=\"line\">        list)</span><br><span class=\"line\">            LIST_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:list:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                VALUE=<span class=\"string\">&quot;list_element_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># LPUSH 命令 RESP 协议: *3 (LPUSH, key, value)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$<span class=\"variable\">$&#123;#LIST_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;LIST_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Set 类型导入 (SADD key member) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">set</span>)</span><br><span class=\"line\">            SET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:set:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;set_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># SADD 命令 RESP 协议: *3 (SADD, key, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$<span class=\"variable\">$&#123;#SET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;SET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Sorted Set 类型导入 (ZADD key score member) ---</span></span><br><span class=\"line\">        zset)</span><br><span class=\"line\">            ZSET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:zset:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                SCORE=<span class=\"string\">&quot;<span class=\"variable\">$&#123;i&#125;</span><span class=\"variable\">$&#123;j&#125;</span>&quot;</span> <span class=\"comment\"># 生成唯一分数：例如 key 1 的分数是 11, 12...</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;zset_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># ZADD 命令 RESP 协议: *4 (ZADD, key, score, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$<span class=\"variable\">$&#123;#ZSET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;ZSET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#SCORE&#125;</span>\\r\\n<span class=\"variable\">$&#123;SCORE&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\"></span><br><span class=\"line\">    i=$((i+<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">done</span> | (</span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"comment\"># --- 3. 管道导入到 Redis ---</span></span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;📤 正在通过 redis-cli --pipe 导入数据...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构建 redis-cli 命令</span></span><br><span class=\"line\">    REDIS_CLI_CMD=<span class=\"string\">&quot;redis-cli -h <span class=\"variable\">$&#123;REDIS_HOST&#125;</span> -p <span class=\"variable\">$&#123;REDIS_PORT&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果设置了密码，则添加 -a 参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        REDIS_CLI_CMD=<span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> -a <span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 执行导入</span></span><br><span class=\"line\">    <span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> --pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 检查命令是否执行成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ $? -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;✅ 数据导入成功！共导入 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 记录。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"SCAN-的基本用法\">SCAN 的基本用法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class=\"built_in\">type</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>TYPE type</td>\n<td>匹配的 key 类型（可选）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例：\">示例：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh string 100</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 key：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 游标初始值为0</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span>  <span class=\"comment\"># 游标</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\"><span class=\"comment\"># 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key</span></span><br><span class=\"line\"><span class=\"comment\">## 扫描结果中：</span></span><br><span class=\"line\"><span class=\"comment\"># 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束</span></span><br><span class=\"line\"><span class=\"comment\"># 第二个元素是匹配的 key列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着上面给出的游标，继续扫描：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 88</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span>  <span class=\"comment\"># 不为0就表示还有更多的 key 可以继续扫描</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">……………………………………</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 87</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span> <span class=\"comment\"># 扫描结束 游标为0</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:68&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:79&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:41&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">控制每次获取的 key 数量</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 count 20</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。</span></span><br><span class=\"line\"><span class=\"comment\"># 本示例就返回了21条，比 count 还多了 1 条</span></span><br><span class=\"line\"><span class=\"comment\"># 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string*</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">   22) <span class=\"string\">&quot;test_data:string:48&quot;</span></span><br><span class=\"line\">   23) <span class=\"string\">&quot;test_data:string:74&quot;</span></span><br><span class=\"line\">   24) <span class=\"string\">&quot;test_data:string:67&quot;</span></span><br><span class=\"line\">   25) <span class=\"string\">&quot;test_data:string:26&quot;</span></span><br><span class=\"line\">   26) <span class=\"string\">&quot;test_data:string:60&quot;</span></span><br><span class=\"line\">   27) <span class=\"string\">&quot;test_data:string:36&quot;</span></span><br><span class=\"line\">   28) <span class=\"string\">&quot;test_data:string:49&quot;</span></span><br><span class=\"line\">   29) <span class=\"string\">&quot;test_data:string:3&quot;</span></span><br><span class=\"line\">   30) <span class=\"string\">&quot;test_data:string:44&quot;</span></span><br><span class=\"line\">   31) <span class=\"string\">&quot;test_data:string:68&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个</span></span><br><span class=\"line\"><span class=\"comment\"># 也有可能比 count 少，甚至为 0 个</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"5\">\n<li class=\"lvl-5\">扫描以 h_key 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先插入一条记录</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> h_key:1 1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个</span></span><br><span class=\"line\"><span class=\"comment\"># 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回</span></span><br><span class=\"line\"><span class=\"comment\"># 并且此时返回的游标也不为0，说明我们还需要继续扫描</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整的扫描过程如下：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)  <span class=\"comment\"># empty array 也不能说明一定没有</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 9 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;43&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 43 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span>      <span class=\"comment\"># 只有游标为0时才算扫描结束</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;75&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 75 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"6\">\n<li class=\"lvl-5\">扫描指定类型的key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> string</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支持的类型有：</span></span><br><span class=\"line\"><span class=\"comment\"># string list set zset hash stream</span></span><br><span class=\"line\"><span class=\"comment\"># 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。</span></span><br><span class=\"line\"><span class=\"comment\"># 例如，ZSET 和 GEOHASH 都是 zset 类型。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; GEOADD geokey 0 0 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> geokey</span><br><span class=\"line\">zset</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD zkey 1000 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SCAN 0 TYPE zset count 1000</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zkey&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;geokey&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"HSCAN-的基本使用方法\">HSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key</td>\n<td>键名</td>\n</tr>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>NOVALUES</td>\n<td>redis8+增加的属性，只返回key，不返回 value（可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 HSCAN，我们先插入一些数据：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh <span class=\"built_in\">hash</span> 100</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 field 和 value：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">hash</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;48&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:hash:42&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:hash:71&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:hash:54&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:hash:87&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:hash:96&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:hash:49&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 获取 test_data:hash:42 的所有 field 和 value</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配 field：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match age*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">模糊匹配 field，并返回 10 条数据：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match *e* count 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">不显示value(需要redis8+)</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 novalues</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SSCAN-的基本使用方法\">SSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-2\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">set</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:set:43&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:set:33&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:set:98&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:set:61&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:set:2&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:set:70&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">返回 1 个元素: 实际上控制不住，大概率会返回所有元素</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSCAN-的基本使用方法\">ZSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-3\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> zset</span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:zset:89&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:zset:81&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:zset:73&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:zset:79&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:zset:15&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;893&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">获取指定key的所有元素，并返回 1 个元素，同样控制不住</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;  zscan test_data:zset:89 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/ SCAN 的核心作用 SCAN 的主要功能是基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key。 它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。 SCAN 的设计目标包括： 避免阻塞 Redis 主线程 分批、渐进扫描大规模 key 集合 灵活配合模式匹配（MATCH） 控制每次返回 key 的数量（COUNT） 在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描 SCAN 命令是完整游标遍历族的一部分，还包括： HSCAN：遍历哈希表 field/value SSCAN：遍历 set 元素 ZSCAN：遍历有序集合 为了完成后面的示例演示，这里准备一个测试数据批量生产脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/bin/bash# 脚本名称：import_unified_data.sh# 运行方法：sh $0 &lt;type&gt; [count]# &lt;type&gt;: string, hash, list, set, 或 zset# [count]: 导入的数据量 (可选，默认为 100)# ----------------------------------------# --- 1. 参数校验与配置 ---SUPPORTED_TYPES=&quot;string hash list set zset&quot;# 定义每个集合/列表/有序集合要添加的成员数量MEMBERS_PER_KEY=5# 检查是否提供了类型参数if [ $# -lt 1 ]; then echo &quot;❌ 错误：请指定导入类型。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; echo &quot;用法: sh $0 &lt;type&gt; [count]&quot; exit 1fi# 获取类型参数 (第一个参数)DATA_TYPE=$(echo &quot;$1&quot; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)# 获取数据量参数 (第二个参数)，不存在则默认为 1000if [ $# -ge 2 ]; then DATA_COUNT=$2else DATA_COUNT=100fi# 检查类型是否有效if [[ ! &quot; $&#123;SUPPORTED_TYPES&#125; &quot; =~ &quot; $&#123;DATA_TYPE&#125; &quot; ]]; then echo &quot;❌ 错误：不支持的类型 &#x27;$DATA_TYPE&#x27;。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; exit 1fi# Redis 连接配置REDIS_HOST=&quot;127.0.0.1&quot;REDIS_PORT=&quot;6379&quot;REDIS_PASSWORD=&quot;password&quot; # 替换为你的实际密码或留空KEY_PREFIX=&quot;test_data&quot;# ----------------------------------------# --- 2. 命令生成主逻辑 ---# ----------------------------------------echo &quot;⏳ 正在生成 $&#123;DATA_COUNT&#125; 条 Redis [$&#123;DATA_TYPE&#125;] 命令...&quot;# 构建 RESP 命令流i=1while [ $i -le $DATA_COUNT ]do case &quot;$DATA_TYPE&quot; in # --- String 类型导入 (SET key value) --- string) KEY=&quot;$&#123;KEY_PREFIX&#125;:string:$&#123;i&#125;&quot; VALUE=&quot;value_of_$&#123;i&#125;_$(date +%s%N)&quot; # SET 命令 RESP 协议: *3 (SET, key, value) printf &quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$$&#123;#KEY&#125;\\r\\n$&#123;KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; ;; # --- Hash 类型导入 (HSET key field1 value1 field2 value2) --- hash) HASH_KEY=&quot;$&#123;KEY_PREFIX&#125;:hash:$&#123;i&#125;&quot; FIELD1=&quot;name&quot; VALUE1=&quot;User_Name_$&#123;i&#125;&quot; FIELD2=&quot;age&quot; VALUE2=$(( (i % 50) + 20 )) # HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2) printf &quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$$&#123;#HASH_KEY&#125;\\r\\n$&#123;HASH_KEY&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD1&#125;\\r\\n$&#123;FIELD1&#125;\\r\\n\\$$&#123;#VALUE1&#125;\\r\\n$&#123;VALUE1&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD2&#125;\\r\\n$&#123;FIELD2&#125;\\r\\n\\$$&#123;#VALUE2&#125;\\r\\n$&#123;VALUE2&#125;\\r\\n&quot; ;; # --- List 类型导入 (LPUSH key value) --- list) LIST_KEY=&quot;$&#123;KEY_PREFIX&#125;:list:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do VALUE=&quot;list_element_$&#123;i&#125;_$&#123;j&#125;&quot; # LPUSH 命令 RESP 协议: *3 (LPUSH, key, value) printf &quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$$&#123;#LIST_KEY&#125;\\r\\n$&#123;LIST_KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; done ;; # --- Set 类型导入 (SADD key member) --- set) SET_KEY=&quot;$&#123;KEY_PREFIX&#125;:set:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do MEMBER=&quot;set_member_$&#123;i&#125;_$&#123;j&#125;&quot; # SADD 命令 RESP 协议: *3 (SADD, key, member) printf &quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$$&#123;#SET_KEY&#125;\\r\\n$&#123;SET_KEY&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; # --- Sorted Set 类型导入 (ZADD key score member) --- zset) ZSET_KEY=&quot;$&#123;KEY_PREFIX&#125;:zset:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do SCORE=&quot;$&#123;i&#125;$&#123;j&#125;&quot; # 生成唯一分数：例如 key 1 的分数是 11, 12... MEMBER=&quot;zset_member_$&#123;i&#125;_$&#123;j&#125;&quot; # ZADD 命令 RESP 协议: *4 (ZADD, key, score, member) printf &quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$$&#123;#ZSET_KEY&#125;\\r\\n$&#123;ZSET_KEY&#125;\\r\\n\\$$&#123;#SCORE&#125;\\r\\n$&#123;SCORE&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; esac i=$((i+1))done | ( # ---------------------------------------- # --- 3. 管道导入到 Redis --- # ---------------------------------------- echo &quot;📤 正在通过 redis-cli --pipe 导入数据...&quot; # 构建 redis-cli 命令 REDIS_CLI_CMD=&quot;redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;REDIS_PORT&#125;&quot; # 如果设置了密码，则添加 -a 参数 if [ -n &quot;$&#123;REDIS_PASSWORD&#125;&quot; ]; then REDIS_CLI_CMD=&quot;$&#123;REDIS_CLI_CMD&#125; -a $&#123;REDIS_PASSWORD&#125;&quot; fi # 执行导入 $&#123;REDIS_CLI_CMD&#125; --pipe # 检查命令是否执行成功 if [ $? -eq 0 ]; then echo &quot;✅ 数据导入成功！共导入 $&#123;DATA_COUNT&#125; 条 [$&#123;DATA_TYPE&#125;] 记录。&quot; else echo &quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot; fi) SCAN 的基本用法 SCAN 的基本语法如下： 1SCAN cursor [MATCH pattern] [COUNT count] [TYPE type] 参数解释： 参数 说明 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 TYPE type 匹配的 key 类型（可选） 示例： 为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据 1sh import_unified_data.sh string 100 获取所有 key： 1234567891011121314151617181920212223242526272829303132333435363738394041# 游标初始值为0127.0.0.1:6379&gt; scan 01) &quot;88&quot; # 游标2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;## 说明# 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key## 扫描结果中：# 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束# 第二个元素是匹配的 key列表# 接着上面给出的游标，继续扫描：127.0.0.1:6379&gt; scan 881) &quot;92&quot; # 不为0就表示还有更多的 key 可以继续扫描2) 1) &quot;test_data:string:63&quot; 2) &quot;test_data:string:2&quot; 3) &quot;test_data:string:4&quot; 4) &quot;test_data:string:20&quot; 5) &quot;test_data:string:57&quot; 6) &quot;test_data:string:78&quot; 7) &quot;test_data:string:71&quot; 8) &quot;test_data:string:35&quot; 9) &quot;test_data:string:86&quot; 10) &quot;test_data:string:6&quot; 11) &quot;test_data:string:47&quot;……………………………………127.0.0.1:6379&gt; scan 871) &quot;0&quot; # 扫描结束 游标为02) 1) &quot;test_data:68&quot; 2) &quot;test_data:79&quot; 3) &quot;test_data:41&quot; 控制每次获取的 key 数量 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; scan 0 count 201) &quot;92&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot;# 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。# 本示例就返回了21条，比 count 还多了 1 条# 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。 扫描以 test_data:string 开头的 key 123456789101112127.0.0.1:6379&gt; scan 0 match test_data:string*1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 扫描以 test_data:string 开头的 key，并返回 30 条 123456789101112131415161718192021222324252627282930313233343536127.0.0.1:6379&gt; scan 0 match test_data:string* count 301) &quot;10&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot; 22) &quot;test_data:string:48&quot; 23) &quot;test_data:string:74&quot; 24) &quot;test_data:string:67&quot; 25) &quot;test_data:string:26&quot; 26) &quot;test_data:string:60&quot; 27) &quot;test_data:string:36&quot; 28) &quot;test_data:string:49&quot; 29) &quot;test_data:string:3&quot; 30) &quot;test_data:string:44&quot; 31) &quot;test_data:string:68&quot;# 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个# 也有可能比 count 少，甚至为 0 个 扫描以 h_key 开头的 key，并返回 30 条 1234567891011121314151617181920212223242526272829303132333435# 先插入一条记录127.0.0.1:6379&gt; set h_key:1 1OK127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)# 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个# 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回# 并且此时返回的游标也不为0，说明我们还需要继续扫描# 完整的扫描过程如下：127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array) # empty array 也不能说明一定没有127.0.0.1:6379&gt; scan 124 match h_key* count 301) &quot;9&quot;2) (empty array)127.0.0.1:6379&gt; scan 9 match h_key* count 301) &quot;43&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 43 match h_key* count 301) &quot;0&quot; # 只有游标为0时才算扫描结束2) (empty array)# 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)127.0.0.1:6379&gt; scan 124 match h_key* count 601) &quot;75&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 75 match h_key* count 601) &quot;0&quot;2) (empty array) 扫描指定类型的key 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; scan 0 type string1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;# 支持的类型有：# string list set zset hash stream# 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。# 例如，ZSET 和 GEOHASH 都是 zset 类型。127.0.0.1:6379&gt; GEOADD geokey 0 0 value(integer) 1127.0.0.1:6379&gt; type geokeyzset127.0.0.1:6379&gt; ZADD zkey 1000 value(integer) 1127.0.0.1:6379&gt; SCAN 0 TYPE zset count 10001) &quot;0&quot;2) 1) &quot;zkey&quot; 2) &quot;geokey&quot; HSCAN 的基本使用方法 HSCAN 的基本语法如下： 1HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES] 参数解释： 参数 说明 key 键名 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 NOVALUES redis8+增加的属性，只返回key，不返回 value（可选） 为了测试 HSCAN，我们先插入一些数据： 1sh import_unified_data.sh hash 100 使用示例 获取所有 field 和 value： 123456789101112131415127.0.0.1:6379&gt; scan 0 type hash1) &quot;48&quot;2) 1) &quot;test_data:hash:42&quot; 2) &quot;test_data:hash:71&quot; 3) &quot;test_data:hash:54&quot; 4) &quot;test_data:hash:87&quot; 5) &quot;test_data:hash:96&quot; 6) &quot;test_data:hash:49&quot;# 获取 test_data:hash:42 的所有 field 和 value127.0.0.1:6379&gt; hscan test_data:hash:42 01) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 模糊匹配 field： 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 match age*1) &quot;0&quot;2) 1) &quot;age&quot; 2) &quot;62&quot; 模糊匹配 field，并返回 10 条数据： 123456127.0.0.1:6379&gt; hscan test_data:hash:42 0 match *e* count 101) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 不显示value(需要redis8+) 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 novalues1) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;age&quot; SSCAN 的基本使用方法 SSCAN 的基本语法如下： 1SSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 123456789101112131415127.0.0.1:6379&gt; scan 0 type set1) &quot;112&quot;2) 1) &quot;test_data:set:43&quot; 2) &quot;test_data:set:33&quot; 3) &quot;test_data:set:98&quot; 4) &quot;test_data:set:61&quot; 5) &quot;test_data:set:2&quot; 6) &quot;test_data:set:70&quot;127.0.0.1:6379&gt; sscan test_data:set:43 01) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; 模糊匹配元素： 123127.0.0.1:6379&gt; sscan test_data:set:43 0 match *_3*1) &quot;0&quot;2) 1) &quot;set_member_43_3&quot; 返回 1 个元素: 实际上控制不住，大概率会返回所有元素 1234567127.0.0.1:6379&gt; sscan test_data:set:43 0 count 11) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; ZSCAN 的基本使用方法 ZSCAN 的基本语法如下： 1ZSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 1234567891011121314151617181920127.0.0.1:6379&gt; scan 0 type zset1) &quot;112&quot;2) 1) &quot;test_data:zset:89&quot; 2) &quot;test_data:zset:81&quot; 3) &quot;test_data:zset:73&quot; 4) &quot;test_data:zset:79&quot; 5) &quot;test_data:zset:15&quot;127.0.0.1:6379&gt; zscan test_data:zset:89 01) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot; 模糊匹配元素： 1234127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*1) &quot;0&quot;2) 1) &quot;zset_member_89_3&quot; 2) &quot;893&quot; 获取指定key的所有元素，并返回 1 个元素，同样控制不住 123456789101112127.0.0.1:6379&gt; zscan test_data:zset:89 0 count 11) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot;","summary":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-10T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","url":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","title":"Maven 新一代构建工具 mvnd","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Maven 新一代构建工具 mvnd</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/maven-mvnd\">mvnd GitHub</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文安装的是 mvnd 1.0.3。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"mvnd-简介\">mvnd 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p>\n</li>\n</ul>\n<h3 id=\"架构概述\">架构概述</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际构建发生在一个长驻后台进程中，又名守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种架构带来了以下优点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">不需要每次构建重新启动 JVM，大大节省时间。</li>\n<li class=\"lvl-6\">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li>\n<li class=\"lvl-6\">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p>\n</li>\n</ul>\n<h2 id=\"mvnd-安装\">mvnd 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 安装包下载地址：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><a href=\"https://github.com/apache/maven-mvnd/releases\">mvnd Github Release</a></li>\n<li class=\"lvl-6\"><a href=\"https://maven.apache.org/download.cgi\">maven 官网下载页</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>本文以 macOS 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 mvnd 对应的安装包</span></span><br><span class=\"line\">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class=\"line\"><span class=\"comment\"># 添加 mvnd 到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br><span class=\"line\"><span class=\"comment\"># 检查 mvnd 是否安装成功</span></span><br><span class=\"line\">mvnd --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"variable\">$MVND_HOME</span>/conf/mvnd.properties <span class=\"variable\">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>默认值</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>mvnd.noBuffering</strong> <code>[*]</code></td>\n<td>false</td>\n<td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td>\n</tr>\n<tr>\n<td><strong>mvnd.rollingWindowSize</strong></td>\n<td>0</td>\n<td>构建并行模块时，每个模块显示的日志行数</td>\n</tr>\n<tr>\n<td><strong>mvnd.logPurgePeriod</strong></td>\n<td>7d</td>\n<td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.noDaemon</strong></td>\n<td>false</td>\n<td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td>\n</tr>\n<tr>\n<td><strong>mvnd.debug</strong></td>\n<td>false</td>\n<td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.idleTimeout</strong></td>\n<td>3 hours</td>\n<td>守护进程在空闲多久后自动关闭</td>\n</tr>\n<tr>\n<td><strong>mvnd.keepAlive</strong></td>\n<td>100 ms</td>\n<td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxLostKeepAlive</strong></td>\n<td>30</td>\n<td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td>\n</tr>\n<tr>\n<td><strong>mvnd.minThreads</strong></td>\n<td>1</td>\n<td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td>\n</tr>\n<tr>\n<td><strong>mvnd.threads</strong> <code>[*]</code></td>\n<td>未设置</td>\n<td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td>\n</tr>\n<tr>\n<td><strong>mvnd.builder</strong></td>\n<td>smart</td>\n<td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td>\n</tr>\n<tr>\n<td><strong>mvnd.minHeapSize</strong></td>\n<td>128M</td>\n<td>守护进程 JVM 的最小堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td>\n<td>2G</td>\n<td>守护进程 JVM 的最大堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.threadStackSize</strong></td>\n<td>1M</td>\n<td>守护进程线程栈大小</td>\n</tr>\n<tr>\n<td><strong>mvnd.jvmArgs</strong></td>\n<td>未设置</td>\n<td>传递给 daemon 的额外 JVM 参数</td>\n</tr>\n<tr>\n<td><strong>mvnd.enableAssertions</strong></td>\n<td>false</td>\n<td>是否为 daemon 启用 JVM 断言（-ea）</td>\n</tr>\n<tr>\n<td><strong>mvnd.expirationCheckDelay</strong></td>\n<td>10 seconds</td>\n<td>守护进程检测自身是否需要过期的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.duplicateDaemonGracePeriod</strong></td>\n<td>10 seconds</td>\n<td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td>\n</tr>\n<tr>\n<td><strong>mvnd.home</strong></td>\n<td>自动设置</td>\n<td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td>\n</tr>\n<tr>\n<td><strong>java.home</strong></td>\n<td>使用环境变量</td>\n<td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td>\n</tr>\n<tr>\n<td><strong>maven.settings</strong> <code>[*]</code></td>\n<td>~/.m2/settings.xml</td>\n<td>maven 的 settings.xml 路径</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"mvnd-使用\">mvnd 使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行使用方式与 mvn 一样，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvnd clean install</span><br><span class=\"line\">mvnd clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 还有些特殊用法，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class=\"line\">mvnd --status</span><br><span class=\"line\"><span class=\"comment\"># 手动停止所有运行的守护进程</span></span><br><span class=\"line\">mvnd --stop</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"mvnd-与-mvnw-的区别\">mvnd 与 mvnw 的区别</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class=\"line\">mvnw： linux 脚本文件</span><br><span class=\"line\">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>mvnw</code>使用方式如下:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>mvnd</th>\n<th>mvnw（Maven Wrapper）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是什么</td>\n<td>一个「常驻的 Maven 守护进程」</td>\n<td>一个「Maven 启动脚本」</td>\n</tr>\n<tr>\n<td>是否常驻</td>\n<td>✅ 是（daemon）</td>\n<td>❌ 否（一次性）</td>\n</tr>\n<tr>\n<td>是否下载 Maven</td>\n<td>❌ 不下载，自己就是程序</td>\n<td>✅ 会自动下载指定版本</td>\n</tr>\n<tr>\n<td>主要目的</td>\n<td>加速构建</td>\n<td>保证版本一致</td>\n</tr>\n<tr>\n<td>是否推荐在 CI</td>\n<td>一般不建议</td>\n<td>✅ 非常推荐</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td><code>mvnd clean install</code></td>\n<td><code>./mvnw clean install</code></td>\n</tr>\n<tr>\n<td>是否与项目绑定</td>\n<td>❌ 全局使用</td>\n<td>✅ 和项目绑定</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。 mvnd 简介 mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。 mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。 架构概述 mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。 实际构建发生在一个长驻后台进程中，又名守护程序。 一个守护程序实例可以服务来自mvnd客户端的多个连续请求。 mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。 如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。 这种架构带来了以下优点： 不需要每次构建重新启动 JVM，大大节省时间。 持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。 JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。 默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: availableProcessors - 1 mvnd 安装 mvnd 安装包下载地址： mvnd Github Release maven 官网下载页 本文以 macOS 为例 123456789# 下载 mvnd 对应的安装包curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xzln -s mvnd-1.0.3-darwin-amd64 mvnd# 添加 mvnd 到环境变量echo &#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27; &gt;&gt; ~/.zshrcecho &#x27;export PATH=$MVND_HOME/bin:$PATH&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc# 检查 mvnd 是否安装成功mvnd --version mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 ~/.m2/settings.xml ，由于本机之前安装过 Maven，所以这一步就省略了。 [推荐]将 mvnd 的配置文件拷贝到 ~/.m2 目录下 12# 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`cp $MVND_HOME/conf/mvnd.properties $HOME/.m2/mvnd.properties mvnd 配置项说明，一般不需要修改，可能会修改的我用 [*] 做了标注 配置项 默认值 中文解释 mvnd.noBuffering [*] false 是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 -B 或 --batch-mode 也会启用此行为 mvnd.rollingWindowSize 0 构建并行模块时，每个模块显示的日志行数 mvnd.logPurgePeriod 7d 自动清理日志的周期（如：7天），日志保存路径： $HOME/.m2/mvnd/registry/1.0.3/ mvnd.noDaemon false 禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效 mvnd.debug false 使用调试模式启动 daemon，JVM 参数为：-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000 mvnd.idleTimeout 3 hours 守护进程在空闲多久后自动关闭 mvnd.keepAlive 100 ms 如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔 mvnd.maxLostKeepAlive 30 允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败 mvnd.minThreads 1 构建时要使用的最少线程数量。如果显式指定了 -T、--threads 或 mvnd.threads，该值将被忽略 mvnd.threads [*] 未设置 传递给 daemon 的线程数，与 Maven 的 -T / --threads 语法一致 mvnd.builder smart 指定使用的 Maven 构建器名称（等同于 -b 或 --builder） mvnd.minHeapSize 128M 守护进程 JVM 的最小堆内存 mvnd.maxHeapSize [*] 2G 守护进程 JVM 的最大堆内存 mvnd.threadStackSize 1M 守护进程线程栈大小 mvnd.jvmArgs 未设置 传递给 daemon 的额外 JVM 参数 mvnd.enableAssertions false 是否为 daemon 启用 JVM 断言（-ea） mvnd.expirationCheckDelay 10 seconds 守护进程检测自身是否需要过期的时间间隔 mvnd.duplicateDaemonGracePeriod 10 seconds 多个 daemon 存在时，多余 daemon 的宽限退出时间 mvnd.home 自动设置 mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置 java.home 使用环境变量 启动 daemon 的 Java 目录（等同 JAVA_HOME） maven.settings [*] ~/.m2/settings.xml maven 的 settings.xml 路径 mvnd 使用 命令行使用方式与 mvn 一样，比如： 12mvnd clean installmvnd clean package -Dmaven.test.skip=true mvnd 的 daemon 缓存了一切，所以运行 mvnd clean install 后，之后再次运行 mvnd clean install 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。 mvnd 还有些特殊用法，比如： 1234# 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭mvnd --status# 手动停止所有运行的守护进程mvnd --stop 在IDEA中使用mvnd，在Maven设置中将mvnd的安装目录添加到 Maven Home Path 中 mvnd 与 mvnw 的区别 我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件 123.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明 mvn 的 urlmvnw： linux 脚本文件mvnw.cmd： windows 脚本文件 实际上 mvnw 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。 第一次使用mvnw时会通过wrapper/maven-wrapper.properties 文件中的声明自动下载maven，并保存在 ~/.m2/wrapper/dists/ 目录下 mvnw使用方式如下: 1./mvnw clean install 运行速度： mvnd &gt;&gt; mvnw ≈ mvn 对比项 mvnd mvnw（Maven Wrapper） 是什么 一个「常驻的 Maven 守护进程」 一个「Maven 启动脚本」 是否常驻 ✅ 是（daemon） ❌ 否（一次性） 是否下载 Maven ❌ 不下载，自己就是程序 ✅ 会自动下载指定版本 主要目的 加速构建 保证版本一致 是否推荐在 CI 一般不建议 ✅ 非常推荐 使用方式 mvnd clean install ./mvnw clean install 是否与项目绑定 ❌ 全局使用 ✅ 和项目绑定","summary":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。","date_published":"2025-12-07T14:30:05.000Z","tags":["技术","maven","mvnd","mavne","mvnd"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","url":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","title":"Redis 7 + ACL 简介","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 简介</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Redis-ACL-简介\">Redis ACL 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ACL 可以控制的维度包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">谁能登录（用户、密码）</li>\n<li class=\"lvl-5\">可以执行哪些命令</li>\n<li class=\"lvl-5\">可以访问哪些 key（按前缀 / 正则）</li>\n<li class=\"lvl-5\">可否通过网络访问</li>\n<li class=\"lvl-5\">是否启用 / 禁用某个用户</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p>\n</li>\n</ul>\n<h2 id=\"Redis-ACL-的使用\">Redis ACL 的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>redis.conf</code> 中添加如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 ACL 文件</span></span><br><span class=\"line\">aclfile /etc/redis/users.acl</span><br><span class=\"line\"><span class=\"comment\"># 关闭 密码</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p>\n</li>\n</ul>\n<h3 id=\"ACL-的配置方式\">ACL 的配置方式</h3>\n<h4 id=\"直接编辑-aclfile\">直接编辑 aclfile</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置一个管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个应用用户</span></span><br><span class=\"line\">user appuser on  ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span> &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个只读用户</span></span><br><span class=\"line\">user <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p>\n</li>\n<li class=\"lvl-2\">\n<p>格式说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用 off: 禁用</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+<span class=\"built_in\">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class=\"built_in\">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class=\"built_in\">cat</span> 命令查看，以@开头，比如 @<span class=\"built_in\">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class=\"line\">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上就是一个超级管理员权限</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class=\"line\"><span class=\"comment\"># 如果设置了 requirepass 密码</span></span><br><span class=\"line\">user default on sanitize-payload <span class=\"comment\">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 连接时直接登录, --pass == -a</span></span><br><span class=\"line\">redis-cli --user username --pass password -h host -p port</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"><span class=\"comment\"># 本机登录</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@</span><br><span class=\"line\"><span class=\"comment\"># 本机登录时端口不是默认的6379时</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@:6380</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先连接后登录</span></span><br><span class=\"line\">redis-cli -h host -p port</span><br><span class=\"line\">&gt; auth username password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ACL 规则中文说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>规则 / 语法</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>on</code></td>\n<td>启用用户：可以使用该用户进行认证登录</td>\n</tr>\n<tr>\n<td><code>off</code></td>\n<td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td>\n</tr>\n<tr>\n<td><code>skip-sanitize-payload</code></td>\n<td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td>\n</tr>\n<tr>\n<td><code>sanitize-payload</code></td>\n<td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;</code></td>\n<td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td>\n</tr>\n<tr>\n<td><code>-&lt;command&gt;</code></td>\n<td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td>\n</tr>\n<tr>\n<td><code>+@&lt;category&gt;</code></td>\n<td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td>\n</tr>\n<tr>\n<td><code>@all</code></td>\n<td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;|first-arg</code></td>\n<td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td>\n</tr>\n<tr>\n<td><code>allcommands</code></td>\n<td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td>\n</tr>\n<tr>\n<td><code>nocommands</code></td>\n<td><code>-@all</code> 的别名，禁止所有命令</td>\n</tr>\n<tr>\n<td><code>~&lt;pattern&gt;</code></td>\n<td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td>\n</tr>\n<tr>\n<td><code>%R~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许读取</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>%W~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许写入</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>allkeys</code></td>\n<td><code>~*</code> 的别名，允许所有 key</td>\n</tr>\n<tr>\n<td><code>resetkeys</code></td>\n<td>清空允许访问的 key 模式</td>\n</tr>\n<tr>\n<td><code>&amp;&lt;pattern&gt;</code></td>\n<td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td>\n</tr>\n<tr>\n<td><code>allchannels</code></td>\n<td><code>&amp;*</code> 的别名，允许所有 channel</td>\n</tr>\n<tr>\n<td><code>resetchannels</code></td>\n<td>清空 Pub/Sub channel 模式列表</td>\n</tr>\n<tr>\n<td><code>&gt;&lt;password&gt;</code></td>\n<td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;password&gt;</code></td>\n<td>移除指定密码</td>\n</tr>\n<tr>\n<td><code>nopass</code></td>\n<td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td>\n</tr>\n<tr>\n<td><code>resetpass</code></td>\n<td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td>\n</tr>\n<tr>\n<td><code>(&lt;options&gt;)</code></td>\n<td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td>\n</tr>\n<tr>\n<td><code>clearselectors</code></td>\n<td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通过-ACL-命令\">通过 ACL 命令</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png\" alt=\"\"></p>\n<h5 id=\"ACL-SETUSER\">ACL SETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建/修改用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 default 用户</span></span><br><span class=\"line\">ACL SETUSER default off</span><br><span class=\"line\"><span class=\"comment\"># 创建一个管理员</span></span><br><span class=\"line\">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 创建一个普通用户</span></span><br><span class=\"line\">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个只读用户</span></span><br><span class=\"line\">ACL SETUSER <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一次执行</span></span><br><span class=\"line\">ACL SETUSER testuser on ~* -@all +@<span class=\"built_in\">read</span> +ping  &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 第二次执行，只添加新的权限</span></span><br><span class=\"line\">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行后的结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"修改用户权限\">修改用户权限</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重置权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重置所有权限</span></span><br><span class=\"line\">ACL SETUSER testuser reset</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>取消密码，但保留权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser nopass</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：取消密码</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有频道</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LIST\">ACL LIST</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以通过如下命令查看当前 Redis 中所有的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LIST</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用</span><br><span class=\"line\">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class=\"line\">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOAD\">ACL LOAD</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SAVE</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p>\n</li>\n</ul>\n<h5 id=\"ACL-SAVE\">ACL SAVE</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOAD</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-USERS\">ACL USERS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>列出所有已创建的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL USERS</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;appuser&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;default&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-GETUSER\">ACL GETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取指定用户的权限信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL GETUSER appuser</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;flags&quot;</span></span><br><span class=\"line\"> 2) 1) <span class=\"string\">&quot;on&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;sanitize-payload&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;passwords&quot;</span></span><br><span class=\"line\"> 4) 1) <span class=\"string\">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;commands&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;-@all +get +set&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;keys&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;~cache:*&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;channels&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;&amp;app:*&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;selectors&quot;</span></span><br><span class=\"line\">12) (empty array)</span><br></pre></td></tr></table></figure>\n<h6 id=\"selectors-选择器规则\">selectors(选择器规则)</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以前 = 一个用户一条规则</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根权限（全局规则）</span></span><br><span class=\"line\">ACL SETUSER selectoruser on ~cache:* +get +<span class=\"built_in\">set</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>现在 = 一个用户可以有多个“权限分身”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 选择器规则</span></span><br><span class=\"line\"><span class=\"comment\"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class=\"line\">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class=\"built_in\">set</span>) &gt;123456</span><br><span class=\"line\"><span class=\"comment\">## 翻译后的结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DELUSER\">ACL DELUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除一个用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-WHOAMI\">ACL WHOAMI</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取当前登录的用户名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL WHOAMI</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-CAT\">ACL CAT</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取所有权限类别</p>\n</li>\n<li class=\"lvl-2\">\n<p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有权限类别</span></span><br><span class=\"line\">ACL CAT</span><br><span class=\"line\"><span class=\"comment\"># 获取指定类别中的命令列表</span></span><br><span class=\"line\">ACL CAT 分类名称</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DRYRUN\">ACL DRYRUN</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 7.0.0 新增。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class=\"line\"><span class=\"string\">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOG\">ACL LOG</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOG          <span class=\"comment\"># 查看默认最新的 ACL 日志条目</span></span><br><span class=\"line\">ACL LOG RESET    <span class=\"comment\"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>日志格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) <span class=\"string\">&quot;count&quot;</span> =&gt; 1</span><br><span class=\"line\">   2) <span class=\"string\">&quot;reason&quot;</span> =&gt; <span class=\"string\">&quot;command&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;context&quot;</span> =&gt; <span class=\"string\">&quot;toplevel&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;object&quot;</span> =&gt; <span class=\"string\">&quot;acl|log&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;username&quot;</span> =&gt; <span class=\"string\">&quot;selectoruser&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class=\"line\">   7) <span class=\"string\">&quot;client-info&quot;</span> =&gt; <span class=\"string\">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class=\"line\">   8) <span class=\"string\">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class=\"line\">   9) <span class=\"string\">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class=\"line\">   10) <span class=\"string\">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>count</code></td>\n<td>触发该日志的次数。比如同一事件触发 1 次就是 1</td>\n</tr>\n<tr>\n<td><code>reason</code></td>\n<td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td>\n</tr>\n<tr>\n<td><code>object</code></td>\n<td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td>触发事件的用户</td>\n</tr>\n<tr>\n<td><code>age-seconds</code></td>\n<td>事件距离当前的时间（秒），越大表示越久远</td>\n</tr>\n<tr>\n<td><code>client-info</code></td>\n<td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td>\n</tr>\n<tr>\n<td><code>entry-id</code></td>\n<td>日志条目 ID</td>\n</tr>\n<tr>\n<td><code>timestamp-created</code></td>\n<td>日志创建时间（毫秒）</td>\n</tr>\n<tr>\n<td><code>timestamp-last-updated</code></td>\n<td>日志最后更新时间（毫秒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"ACL-GENPASS\">ACL GENPASS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成一个随机的 ACL 密码</p>\n</li>\n<li class=\"lvl-2\">\n<p>生成复杂密码的工具有很多，没必要用这玩意。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class=\"line\">&gt; ACL GENPASS</span><br><span class=\"line\"><span class=\"string\">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，32/4 = 8</span></span><br><span class=\"line\">&gt; ACL GENPASS 32</span><br><span class=\"line\"><span class=\"string\">&quot;355ef3dd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class=\"line\">&gt; ACL GENPASS 5</span><br><span class=\"line\"><span class=\"string\">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis ACL 简介 从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。 ACL 可以控制的维度包括： 谁能登录（用户、密码） 可以执行哪些命令 可以访问哪些 key（按前缀 / 正则） 可否通过网络访问 是否启用 / 禁用某个用户 一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离 Redis ACL 的使用 在 redis.conf 中添加如下内容： 1234# 指定 ACL 文件aclfile /etc/redis/users.acl# 关闭 密码# requirepass foobared 也可以不配置 aclfile，而是将用户信息直接编写在 redis.conf 中，但不建议这样做。 ACL 的配置方式 直接编辑 aclfile 创建一个 users.acl 文件，并写入如下内容： 123456# 配置一个管理员user admin on ~* &amp;* +@all &gt;password# 配置一个应用用户user appuser on ~cache:* &amp;app:* +get +set &gt;password# 配置一个只读用户user readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。 格式说明 1234567user: 固定前缀username: 用户名on: 启用 off: 禁用~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格 为了兼容以前的版本，Redis 提供了一个默认的用户：default，不指定用户名的时候，默认使用的就是 default 用户，其对应的acl权限为 1234# 实际上就是一个超级管理员权限user default on nopass sanitize-payload ~* &amp;* +@all# 如果设置了 requirepass 密码user default on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all 开启ACL后，推荐关闭 default 用户。 12# 关闭默认用户，禁止匿名访问user default off 登录redis 12345678910111213# 连接时直接登录, --pass == -aredis-cli --user username --pass password -h host -p port# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 本机登录redis-cli -u redis://admin:123456@# 本机登录时端口不是默认的6379时redis-cli -u redis://admin:123456@:6380# 先连接后登录redis-cli -h host -p port&gt; auth username password Redis ACL 规则中文说明 规则 / 语法 中文说明 on 启用用户：可以使用该用户进行认证登录 off 禁用用户：无法再使用该用户认证，但已认证的连接仍然有效 skip-sanitize-payload 跳过对 RESTORE 命令的 dump 数据载荷过滤（跳过安全检查） sanitize-payload 对 RESTORE 命令的 dump 数据载荷进行过滤（默认） +&lt;command&gt; 允许执行指定命令；可以指定子命令，例如：+config | get -&lt;command&gt; 禁止执行指定命令；可以指定子命令，例如：-config | set +@&lt;category&gt; 允许一个命令分类的所有命令，如：@admin, @set, @sortedset 等。完整分类在 server.c 的命令表中 @all 特殊分类，表示所有当前已有命令 + 未来模块加载的命令 +&lt;command&gt;|first-arg 只允许使用某命令的第一个参数（已废弃，将可能移除）；只支持新增，不支持禁止（如 -SELECT|1 不允许） allcommands +@all 的别名，允许所有命令（包括将来可能加载的模块命令） nocommands -@all 的别名，禁止所有命令 ~&lt;pattern&gt; 添加允许访问的 key 模式（glob 风格），如：~user:*；可以有多个 %R~&lt;pattern&gt; 添加允许读取的 key 模式 %W~&lt;pattern&gt; 添加允许写入的 key 模式 allkeys ~* 的别名，允许所有 key resetkeys 清空允许访问的 key 模式 &amp;&lt;pattern&gt; 添加可访问的 Pub/Sub channel 模式（glob 风格），可多个 allchannels &amp;* 的别名，允许所有 channel resetchannels 清空 Pub/Sub channel 模式列表 &gt;&lt;password&gt; 添加密码，例如：&gt;mypass；此指令会清除 nopass 标志 &lt;&lt;password&gt; 移除指定密码 nopass 移除所有密码，且任何密码都可登录。如果用于 default 用户，则新连接无需 AUTH 即自动登录为 default resetpass 清空所有密码，并移除 nopass 状态。此后没有密码将无法认证 reset 重置所有设置：包括 resetpass、resetkeys、resetchannels、allchannels（如果开启 acl-pubsub-default）、off、clearseletors、-@all (&lt;options&gt;) 创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则 clearselectors 删除所有 selector，但不会影响根权限（直接赋给用户的权限） 通过 ACL 命令 ACL SETUSER 创建/修改用户 12345678# 关闭 default 用户ACL SETUSER default off# 创建一个管理员ACL SETUSER admin on ~* &amp;* +@all &gt;password# 创建一个普通用户ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +set# 创建一个只读用户ACL SETUSER readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 可以看的出来，ACL SETUSER 后面的命令格式与直接编辑 users.acl 文件是一样的 这里要注意 ACL SETUSER 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如： 1234# 第一次执行ACL SETUSER testuser on ~* -@all +@read +ping &gt;password# 第二次执行，只添加新的权限ACL SETUSER testuser +info +client +config|get 运行后的结果 1&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 修改用户权限 重置权限 1234# 重置所有权限ACL SETUSER testuser reset## 运行结果：去除所有频道和命令权限，禁止登录&quot;user testuser off sanitize-payload resetchannels -@all&quot; 取消密码，但保留权限 123ACL SETUSER testuser nopass## 运行结果：取消密码&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot; 去除所有频道 1ACL SETUSER testuser resetchannels 去除所有selectors，关于selectors后面会详细介绍 1ACL SETUSER testuser clearselectors ACL LIST 可以通过如下命令查看当前 Redis 中所有的用户 123456ACL LIST## 输出1) &quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;2) &quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;3) &quot;user default off sanitize-payload resetchannels -@all&quot;4) &quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式 123456789user: 固定前缀username: 用户名on: 启用sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 keyresetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令 ACL LOAD 当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 users.acl 文件中 1ACL SAVE 此时保存的文件内容就是 ACL LIST 命令的输出 ACL SAVE 当修改了 users.acl 文件后，可以通过如下命令将其重新加载到 Redis 中 1ACL LOAD ACL USERS 列出所有已创建的用户 123456ACL USERS## 输出1) &quot;admin&quot;2) &quot;appuser&quot;3) &quot;default&quot;4) &quot;readonly&quot; ACL GETUSER 获取指定用户的权限信息 123456789101112131415ACL GETUSER appuser## 输出1) &quot;flags&quot; 2) 1) &quot;on&quot; 2) &quot;sanitize-payload&quot; 3) &quot;passwords&quot; 4) 1) &quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot; 5) &quot;commands&quot; 6) &quot;-@all +get +set&quot; 7) &quot;keys&quot; 8) &quot;~cache:*&quot; 9) &quot;channels&quot;10) &quot;&amp;app:*&quot;11) &quot;selectors&quot;12) (empty array) selectors(选择器规则) 这里看到最后有一个selectors，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。 以前 = 一个用户一条规则 12# 根权限（全局规则）ACL SETUSER selectoruser on ~cache:* +get +set 现在 = 一个用户可以有多个“权限分身” 12345# 选择器规则# 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +set) &gt;123456## 翻译后的结果&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot; &gt;123456 如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。 ACL DELUSER 删除一个用户 1ACL DELUSER 用户名 ACL WHOAMI 获取当前登录的用户名 1ACL WHOAMI ACL CAT 获取所有权限类别 前面我们在为用户授权时介绍过，@ 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。 ACL CAT 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。 1234# 获取所有权限类别ACL CAT# 获取指定类别中的命令列表ACL CAT 分类名称 这里有一个特殊的权限类别 @all 并不在列出的权限类别中，其表示所有命令。 ACL DRYRUN ACL DRYRUN 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。 Redis 7.0.0 新增。 123456&gt; ACL SETUSER VIRGINIA +SET ~*&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA SET foo bar&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA GET foo&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot; ACL LOG ACL LOG 命令可以查看 ACL 命令执行日志。 它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。 12ACL LOG # 查看默认最新的 ACL 日志条目ACL LOG RESET # 清空 ACL 日志 日志格式 123456789101) &quot;count&quot; =&gt; 1 2) &quot;reason&quot; =&gt; &quot;command&quot; 3) &quot;context&quot; =&gt; &quot;toplevel&quot; 4) &quot;object&quot; =&gt; &quot;acl|log&quot; 5) &quot;username&quot; =&gt; &quot;selectoruser&quot; 6) &quot;age-seconds&quot; =&gt; 1589.819 7) &quot;client-info&quot; =&gt; &quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot; 8) &quot;entry-id&quot; =&gt; 3 9) &quot;timestamp-created&quot; =&gt; 1765089007352 10) &quot;timestamp-last-updated&quot; =&gt; 1765089007352 字段 含义 count 触发该日志的次数。比如同一事件触发 1 次就是 1 reason 日志触发的原因，通常是 command 表示某个命令被执行或被 ACL 检查 context 执行命令的上下文，toplevel 表示直接在客户端执行 object 触发事件的对象，例如 acl|log表示执行了ACL LOG 命令，acl|list表示执行了ACL LIST username 触发事件的用户 age-seconds 事件距离当前的时间（秒），越大表示越久远 client-info 客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等 entry-id 日志条目 ID timestamp-created 日志创建时间（毫秒） timestamp-last-updated 日志最后更新时间（毫秒） ACL GENPASS 生成一个随机的 ACL 密码 生成复杂密码的工具有很多，没必要用这玩意。 该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。 123456789# 默认64个十六进制字符，相当于 ACL GENPASS 256&gt; ACL GENPASS&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;# 指定长度，32/4 = 8&gt; ACL GENPASS 32&quot;355ef3dd&quot;# 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2&gt; ACL GENPASS 5&quot;90&quot;","summary":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-07T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","url":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","title":"Redis 7 + ACL 单节点、主从、哨兵、集群构建方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">传统的非ACL版本，可以参考 <a href=\"/2022/09/09/redis5-config/\" title=\"Redis单节点、主从、哨兵、集群构建方法\">Redis单节点、主从、哨兵、集群构建方法</a></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"redis安装\">redis安装</h2>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载到指定目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft</span><br><span class=\"line\">tar -zxvf redis-7.4.7.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install gcc gcc-c++ -y</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-7.4.7</span><br><span class=\"line\"><span class=\"comment\"># 编译，会将编译好的可执行文件放在src目录下</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir</span><br><span class=\"line\">make install PREFIX=$(<span class=\"built_in\">pwd</span>)/build_dir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> redis.conf redis-6379.conf</span><br><span class=\"line\">vim redis-6379.conf <span class=\"comment\">#见下面的配置信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">redis-cli --version</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">redis-cli 7.4.7</span><br></pre></td></tr></table></figure>\n<h2 id=\"单节点\">单节点</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>redis-6379.conf</code> 的主要配置</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认 6379</span></span><br><span class=\"line\">port 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动，默认 no</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yes: 当没有 bind / requirepass / ACL 时，只允许本机访问</span></span><br><span class=\"line\"><span class=\"comment\"># no: 允许任意访问</span></span><br><span class=\"line\"><span class=\"comment\"># 这里会启用ACL，所以设置为 yes，默认 yes</span></span><br><span class=\"line\">protected-mode <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置</span></span><br><span class=\"line\"><span class=\"comment\">#bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 可以配置为，本机IP 内网IP 外网IP</span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1 10.250.0.103 18.163.188.20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照</span></span><br><span class=\"line\"><span class=\"comment\"># 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件</span></span><br><span class=\"line\">save <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no</span></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复</span></span><br><span class=\"line\"><span class=\"comment\"># 生成环境必须开启</span></span><br><span class=\"line\">appendonly <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># aof文件名称，默认 appendonly.aof</span></span><br><span class=\"line\">appendfilename <span class=\"string\">&quot;appendonly.aof&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir</span></span><br><span class=\"line\"><span class=\"comment\"># redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.incr.aof：记录每个写操作命令</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)</span></span><br><span class=\"line\">appenddirname <span class=\"string\">&quot;appendonlydir&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysec</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令</span></span><br><span class=\"line\"><span class=\"comment\"># 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令</span></span><br><span class=\"line\"><span class=\"comment\"># 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mb</span></span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br><span class=\"line\"><span class=\"comment\"># aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aof</span></span><br><span class=\"line\">aof-use-rdb-preamble <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 防止 AOF 意外截断导致 Redis 起不来，默认 yes</span></span><br><span class=\"line\">aof-load-truncated <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径，默认 /var/run/redis_6379.pid</span></span><br><span class=\"line\">pidfile <span class=\"string\">&quot;redis_6379.pid&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称，默认 &quot;&quot;</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;6379.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定最大内存，单位bytes，这里设置4G</span></span><br><span class=\"line\"><span class=\"comment\"># 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降</span></span><br><span class=\"line\">maxmemory 4294967296</span><br><span class=\"line\"><span class=\"comment\"># 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间</span></span><br><span class=\"line\"><span class=\"comment\"># volatile-lru: 只会淘汰「设置了过期时间」的 key</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的</span></span><br><span class=\"line\"><span class=\"comment\"># noeviction: 不淘汰，默认</span></span><br><span class=\"line\">maxmemory-policy allkeys-lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 慢查询日志</span></span><br><span class=\"line\"><span class=\"comment\"># 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来</span></span><br><span class=\"line\">slowlog-log-slower-than 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录</span></span><br><span class=\"line\">slowlog-max-len 1024</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 性能优化</span></span><br><span class=\"line\"><span class=\"comment\"># Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了</span></span><br><span class=\"line\">io-threads 4</span><br><span class=\"line\"><span class=\"comment\"># 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端</span></span><br><span class=\"line\"><span class=\"comment\"># 推荐&gt;=4核才开启，否则开了反而更慢</span></span><br><span class=\"line\">io-threads-do-reads <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着</span></span><br><span class=\"line\">tcp-keepalive 60</span><br><span class=\"line\"><span class=\"comment\"># 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0</span></span><br><span class=\"line\"><span class=\"comment\"># 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放</span></span><br><span class=\"line\"><span class=\"built_in\">timeout</span> 0</span><br><span class=\"line\"><span class=\"comment\"># 最大客户端连接数，默认 10000</span></span><br><span class=\"line\">maxclients 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令</span></span><br><span class=\"line\">rename-command FLUSHALL <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">rename-command FLUSHDB <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SHUTDOWN &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command CONFIG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command KEYS &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command BGSAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command DEBUG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command EVAL &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SCRIPT &quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。</span></span><br><span class=\"line\">lazyfree-lazy-eviction <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。</span></span><br><span class=\"line\">lazyfree-lazy-expire <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：</span></span><br><span class=\"line\"><span class=\"comment\">#    RENAME 替换旧 key 时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    SET 操作覆盖旧值时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    重写函数、脚本时删除旧对象</span></span><br><span class=\"line\"><span class=\"comment\"># 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。</span></span><br><span class=\"line\">lazyfree-lazy-server-del <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。</span></span><br><span class=\"line\"><span class=\"comment\"># 此配置只影响副本不会影响主节点。</span></span><br><span class=\"line\">replica-lazy-flush <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。</span></span><br><span class=\"line\"><span class=\"comment\"># 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。</span></span><br><span class=\"line\"><span class=\"comment\"># 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。</span></span><br><span class=\"line\">lazyfree-lazy-user-del no</span><br><span class=\"line\"><span class=\"comment\"># FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行</span></span><br><span class=\"line\"><span class=\"comment\"># 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。</span></span><br><span class=\"line\">lazyfree-lazy-user-flush no</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启 ACL 文件</span></span><br><span class=\"line\">aclfile /usr/local/soft/redis-7.4.7/users.acl</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 7 支持的淘汰策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>是否只淘汰带 TTL 的 key</th>\n<th>淘汰规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>noeviction</strong></td>\n<td>❌ 不淘汰</td>\n<td>不删任何 key</td>\n<td>内存满了直接返回错误（默认）</td>\n</tr>\n<tr>\n<td><strong>allkeys-lru</strong></td>\n<td>❌ 所有 key</td>\n<td>最近最久未使用</td>\n<td>✅ 最常用</td>\n</tr>\n<tr>\n<td><strong>allkeys-lfu</strong></td>\n<td>❌ 所有 key</td>\n<td>访问频率最少</td>\n<td>✅ 热点场景最好</td>\n</tr>\n<tr>\n<td><strong>allkeys-random</strong></td>\n<td>❌ 所有 key</td>\n<td>随机删除</td>\n<td>❌ 很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-lru</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>最近最久未使用</td>\n<td>你之前用的</td>\n</tr>\n<tr>\n<td><strong>volatile-lfu</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>访问频率最少</td>\n<td>较少使用</td>\n</tr>\n<tr>\n<td><strong>volatile-random</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>随机删除</td>\n<td>很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-ttl</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>TTL 最小（马上过期的）</td>\n<td>特殊场景用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>users.acl</code> 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 <a href=\"/2025/12/07/redis7-acl/\" title=\"Redis 7 + ACL 简介\">Redis 7 + ACL 简介</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br><span class=\"line\"><span class=\"comment\"># 超级管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis 服务启动与关闭</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">redis-server redis-6379.conf</span><br><span class=\"line\"><span class=\"comment\"># 登录服务，本机访问可以省略 -h -p</span></span><br><span class=\"line\">redis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭服务</span></span><br><span class=\"line\"><span class=\"comment\"># shutdown == shutdown save</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown</span><br><span class=\"line\"><span class=\"comment\"># 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正常下线（生产）</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>已开 AOF</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>数据很大</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>单机调试</td>\n<td><code>shutdown</code></td>\n</tr>\n<tr>\n<td>确定要生成快照</td>\n<td><code>shutdown save</code></td>\n</tr>\n<tr>\n<td>强制杀死(redis卡死)</td>\n<td><code>kill -9</code>（极端情况）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"单节点优点\">单节点优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单机部署简单方便</p>\n</li>\n</ul>\n<h3 id=\"单节点缺点\">单节点缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不保证数据的可靠性，不适用于数据可靠性要求高的场景</p>\n</li>\n<li class=\"lvl-2\">\n<p>单点故障导致无法提供服务，或者硬盘损坏导致数据丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流</p>\n</li>\n</ul>\n<h2 id=\"主从\">主从</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从配置时，主节点不需要做任何修改</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点配置文件增加同步主节点信息，其余配置与主节点相同</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号</span></span><br><span class=\"line\">replicaof 10.250.0.235 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致</span></span><br><span class=\"line\">replica-read-only <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时启动从节点<code>redis-server redis-6379.conf</code>，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时登录master的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master     <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">connected_slaves:1 <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 <span class=\"comment\"># 从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点切换状态，无</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:56  <span class=\"comment\"># 主节点复制的偏移量</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1  <span class=\"comment\"># 是否开启复制回放</span></span><br><span class=\"line\">repl_backlog_size:1048576 <span class=\"comment\"># 复制回放缓冲区大小</span></span><br><span class=\"line\">repl_backlog_first_byte_offset:1 <span class=\"comment\"># 复制回放缓冲区第一个字节的偏移量</span></span><br><span class=\"line\">repl_backlog_histlen:56 <span class=\"comment\"># 复制回放缓冲区历史长度</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时登录从节点的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave               <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">master_host:10.250.0.235 <span class=\"comment\"># 主节点的ip</span></span><br><span class=\"line\">master_port:6379         <span class=\"comment\"># 主节点的端口</span></span><br><span class=\"line\">master_link_status:up    <span class=\"comment\"># 主从节点连接状态，up 表示已经连接上主节点</span></span><br><span class=\"line\">master_last_io_seconds_ago:6 <span class=\"comment\"># 主从节点最后一次io操作时间</span></span><br><span class=\"line\">master_sync_in_progress:0 <span class=\"comment\"># 主从节点是否正在同步数据，0表示已完成</span></span><br><span class=\"line\">slave_read_repl_offset:112 <span class=\"comment\"># 从节点已经读取的复制偏移量</span></span><br><span class=\"line\">slave_repl_offset:112   <span class=\"comment\"># 从节点已经写入的复制偏移量</span></span><br><span class=\"line\">slave_priority:100      <span class=\"comment\"># 从节点的优先级</span></span><br><span class=\"line\">slave_read_only:1       <span class=\"comment\"># 从节点是否只读</span></span><br><span class=\"line\">replica_announced:1     <span class=\"comment\"># 从节点是否被其他节点所代理</span></span><br><span class=\"line\">connected_slaves:0      <span class=\"comment\"># 从节点所代理的从节点数量</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点的故障转移状态，no-failover表示没有进行故障转移</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:112  <span class=\"comment\"># 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:15</span><br><span class=\"line\">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从数据同步是否完成判断规则，在从节点上执行命令<code>info replication</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>正常值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>role</code></td>\n<td>slave</td>\n<td>表示当前是从节点</td>\n</tr>\n<tr>\n<td><code>master_link_status</code></td>\n<td>up</td>\n<td>表示已经连上主库</td>\n</tr>\n<tr>\n<td><code>master_sync_in_progress</code></td>\n<td>0</td>\n<td>同步不在进行中 = 已完成</td>\n</tr>\n<tr>\n<td><code>slave_read_repl_offset</code> ≈ <code>master_repl_offset</code></td>\n<td>接近</td>\n<td>说明数据已追上</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参照上面的配置，再添加一个从节点后，在主节点执行命令 <code>info replication</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2  <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0</span><br><span class=\"line\">slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0  <span class=\"comment\"># 第二个从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover</span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67</span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:4313</span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:1</span><br><span class=\"line\">repl_backlog_histlen:4313</span><br></pre></td></tr></table></figure>\n<h3 id=\"主从优点\">主从优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对请求进行读写分离，提高处理效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以提供多个副本，提高数据安全性</p>\n</li>\n</ul>\n<h3 id=\"主从缺点\">主从缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p>\n</li>\n</ul>\n<h2 id=\"哨兵\">哨兵</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br><span class=\"line\">sentinel1 10.250.0.71</span><br><span class=\"line\">sentinel2 10.250.0.131</span><br><span class=\"line\">sentinel3 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别编辑各自的 <code>sentinel.conf</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口号</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir，需要提前创建好</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/sentinel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径</span></span><br><span class=\"line\">pidfile redis-sentinel.pid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;sentinel.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1</span></span><br><span class=\"line\">sentinel monitor mymaster 10.250.0.235 6379 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主观下线时间（5秒），默认30秒</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 故障转移超时时间 60秒，默认180秒</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 60000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每次允许多少个slave重新同步，默认就是 1</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># acl用户名和密码，这里为了方便也是用的管理员帐号</span></span><br><span class=\"line\">sentinel auth-user mymaster admin</span><br><span class=\"line\">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动三个哨兵节点<code>redis-sentinel sentinel.conf</code>，此时登录哨兵节点<code>redis-cli -p 26379</code>，并执行<code>info Sentinel</code>命令，查看其是否正确识别了主从</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sentinel</span></span><br><span class=\"line\">sentinel_masters:1      <span class=\"comment\"># 哨兵集群中主从节点的数量</span></span><br><span class=\"line\">sentinel_tilt:0         <span class=\"comment\"># 是否处于 tilt 状态</span></span><br><span class=\"line\">sentinel_tilt_since_seconds:-1 <span class=\"comment\"># tilt 状态的开始时间</span></span><br><span class=\"line\">sentinel_running_scripts:0 <span class=\"comment\"># 正在运行的脚本数量</span></span><br><span class=\"line\">sentinel_scripts_queue_length:0 <span class=\"comment\"># 脚本队列长度</span></span><br><span class=\"line\">sentinel_simulate_failure_flags:0 <span class=\"comment\"># 模拟故障的标志</span></span><br><span class=\"line\">master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 <span class=\"comment\"># 主节点的地址，从节点数量和哨兵数量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>sentinel.conf</code>可以在文件最后看到从节点信息和其它的哨兵节点信息(<em><strong>但实测无法感知其它哨兵节点</strong></em>)，类似于</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9  <span class=\"comment\"># 延迟追踪信息百分比</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all <span class=\"comment\"># 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码</span></span><br><span class=\"line\">sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 <span class=\"comment\"># 本节点的id</span></span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br><span class=\"line\">sentinel current-epoch 0</span><br><span class=\"line\"><span class=\"comment\"># 一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.58 6379</span><br><span class=\"line\"><span class=\"comment\"># 另一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.36 6379</span><br><span class=\"line\"><span class=\"comment\"># 一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a</span><br><span class=\"line\"><span class=\"comment\"># 另一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看<code>info Sentinel</code>，就会发现master节点变成了从节点其中的一个了</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9</span><br><span class=\"line\">replicaof 10.250.0.36 6379</span><br><span class=\"line\">save 3600 1</span><br><span class=\"line\">save 300 100</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>顺便说一下，关闭哨兵服务的命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -p 26379 shutdown</span><br></pre></td></tr></table></figure>\n<h3 id=\"哨兵优点\">哨兵优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主节点故障，可以自动在从节点中重新选主</p>\n</li>\n</ul>\n<h3 id=\"哨兵缺点\">哨兵缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离</p>\n</li>\n</ul>\n<h2 id=\"集群\">集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>搭建6个redis的集群，3主3从</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis1 10.250.0.235</span><br><span class=\"line\">redis2 10.250.0.58</span><br><span class=\"line\">redis3 10.250.0.36</span><br><span class=\"line\">redis4 10.250.0.71</span><br><span class=\"line\">redis5 10.250.0.131</span><br><span class=\"line\">redis6 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ACL认证，所有节点都要配置</span></span><br><span class=\"line\">masteruser <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">masterauth <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动集群模式</span></span><br><span class=\"line\">cluster-enabled <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点信息文件，这里最好和port对应上</span></span><br><span class=\"line\">cluster-config-file nodes-6379.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰</span></span><br><span class=\"line\">cluster-node-timeout 15000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置</span></span><br><span class=\"line\"><span class=\"comment\"># 开启这个配置可以预防集群脑裂问题，默认为3</span></span><br><span class=\"line\">min-replicas-to-write 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能</span></span><br><span class=\"line\"><span class=\"comment\"># 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败</span></span><br><span class=\"line\">cluster-require-full-coverage <span class=\"built_in\">yes</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动6个redis服务</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(<em><strong>删除dir配置的目录中的所有文件即可</strong></em>)，然后在任意一个redis执行</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># --cluster create：创建集群</span></span><br><span class=\"line\"><span class=\"comment\"># --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点</span></span><br><span class=\"line\"><span class=\"comment\"># 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时会列出集群内主从和槽位的分配方案，输入<code>yes</code>即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: Using a password with <span class=\"string\">&#x27;-a&#x27;</span> or <span class=\"string\">&#x27;-u&#x27;</span> option on the <span class=\"built_in\">command</span> line interface may not be safe.</span><br><span class=\"line\">&gt;&gt;&gt; Performing <span class=\"built_in\">hash</span> slots allocation on 6 nodes...</span><br><span class=\"line\">Master[0] -&gt; Slots 0 - 5460</span><br><span class=\"line\">Master[1] -&gt; Slots 5461 - 10922</span><br><span class=\"line\">Master[2] -&gt; Slots 10923 - 16383</span><br><span class=\"line\">Adding replica 10.250.0.131:6379 to 10.250.0.235:6379</span><br><span class=\"line\">Adding replica 10.250.0.63:6379 to 10.250.0.58:6379</span><br><span class=\"line\">Adding replica 10.250.0.71:6379 to 10.250.0.36:6379</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">Can I <span class=\"built_in\">set</span> the above configuration? (<span class=\"built_in\">type</span> <span class=\"string\">&#x27;yes&#x27;</span> to accept): <span class=\"built_in\">yes</span></span><br><span class=\"line\">&gt;&gt;&gt; Nodes configuration updated</span><br><span class=\"line\">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class=\"line\">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class=\"built_in\">join</span> the cluster</span><br><span class=\"line\">Waiting <span class=\"keyword\">for</span> the cluster to <span class=\"built_in\">join</span></span><br><span class=\"line\">.</span><br><span class=\"line\">&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">[OK] All nodes agree about slots configuration.</span><br><span class=\"line\">&gt;&gt;&gt; Check <span class=\"keyword\">for</span> open slots...</span><br><span class=\"line\">&gt;&gt;&gt; Check slots coverage...</span><br><span class=\"line\">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录集群并查询集群配置信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -c 表示以集群模式登录，-h 集群内任意ip</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456 -c -h 10.250.0.235</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster info</span><br><span class=\"line\"><span class=\"comment\"># 输出集群状态</span></span><br><span class=\"line\">cluster_state:ok                                <span class=\"comment\"># 集群整体状态：ok 表示集群当前可用、健康</span></span><br><span class=\"line\">cluster_slots_assigned:16384                    <span class=\"comment\"># 已分配的哈希槽数量（总槽数固定为 16384）</span></span><br><span class=\"line\">cluster_slots_ok:16384                          <span class=\"comment\"># 正常工作的槽数量（等于已分配槽，说明全部正常）</span></span><br><span class=\"line\">cluster_slots_pfail:0                           <span class=\"comment\"># 处于“疑似失败(pfail)”状态的槽数量</span></span><br><span class=\"line\">cluster_slots_fail:0                            <span class=\"comment\"># 被判定为失败(fail)的槽数量</span></span><br><span class=\"line\">cluster_known_nodes:6                           <span class=\"comment\"># 当前节点已知的集群节点总数（主节点 + 从节点）</span></span><br><span class=\"line\">cluster_size:3                                  <span class=\"comment\"># 主节点数量（3 主节点，典型的 3 主 3 从结构）</span></span><br><span class=\"line\">cluster_current_epoch:6                         <span class=\"comment\"># 集群当前的全局纪元（用于选举和配置同步）</span></span><br><span class=\"line\">cluster_my_epoch:1                              <span class=\"comment\"># 当前这个节点所在的纪元</span></span><br><span class=\"line\">cluster_stats_messages_ping_sent:159           <span class=\"comment\"># 当前节点已发送的 PING 消息数量（心跳）</span></span><br><span class=\"line\">cluster_stats_messages_pong_sent:156           <span class=\"comment\"># 当前节点已发送的 PONG 消息数量（心跳响应）</span></span><br><span class=\"line\">cluster_stats_messages_sent:315                <span class=\"comment\"># 当前节点发送的所有集群消息总数</span></span><br><span class=\"line\">cluster_stats_messages_ping_received:151       <span class=\"comment\"># 当前节点收到的 PING 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_pong_received:159       <span class=\"comment\"># 当前节点收到的 PONG 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_meet_received:5         <span class=\"comment\"># 当前节点收到的 MEET 消息数量（新节点加入发现）</span></span><br><span class=\"line\">cluster_stats_messages_received:315            <span class=\"comment\"># 当前节点收到的所有集群消息总数</span></span><br><span class=\"line\">total_cluster_links_buffer_limit_exceeded:0    <span class=\"comment\"># 因输出缓冲区超限被强制断开的集群连接数（0 = 正常）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看节点列表</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\"># 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）</span></span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）</span></span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）</span></span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 10923-16383（集群中第三段槽位）</span></span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 5461-10922（集群中第二段槽位）</span></span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>nodes-6379.conf</code>也会看到和上面一样的节点信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时关闭其中一个master节点，比如<code>10.250.0.36</code>，则其对应的slave节点<code>10.250.0.71</code>会切换为新的master节点，此时<code>10.250.0.36</code>的状态最终变为<code>fail</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再次启动<code>10.250.0.36</code>，其会变成<code>10.250.0.71</code>的slave节点</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>若此时还是希望 <code>10.250.0.36</code> 做为主节点，则需要先登录<code>10.250.0.36</code>，再执行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意要加 -c</span></span><br><span class=\"line\">redis-cli -c --user admin --pass 123456 -h 10.250.0.36</span><br><span class=\"line\">10.250.0.36:6379&gt; cluster failover <span class=\"comment\"># 安全版（等待复制同步）</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER <span class=\"comment\"># TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐)</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HASH_SLOT=CRC16(key) mod 16384</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 跳转重定位</span></span><br><span class=\"line\">10.250.0.235:6379&gt; <span class=\"built_in\">set</span> name zhangsan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">-&gt; Redirected to slot [5798] located at 10.250.0.58:6379</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关闭集群，6个redis分别关闭</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启集群，6个redis分别启动即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- <code>&#123;xxx&#125;</code>，其必须用<code>&#123;&#125;</code>括起来，<code>xxx</code>可以是任意字符串，计算slot时，只会根据<code>xxx</code>来计算hash值，这样就保证了所有key中包含<code>&#123;xxx&#125;</code>的key都会落到同一个slot，<code>&#123;xxx&#125;</code>可以放在key的任意位置</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; mset name1 lisi name2 wangwu</span><br><span class=\"line\">(error) CROSSSLOT Keys <span class=\"keyword\">in</span> request don<span class=\"string\">&#x27;t hash to the same slot</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwu</span></span><br><span class=\"line\"><span class=\"string\">OK</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2</span></span><br><span class=\"line\"><span class=\"string\">-&gt; Redirected to slot [5474] located at 10.250.0.58:6379</span></span><br><span class=\"line\"><span class=\"string\">1) &quot;lisi&quot;</span></span><br><span class=\"line\"><span class=\"string\">2) &quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意:<br>\n{…} 让多个 key 落在同一个 slot，支持跨 key 原子操作<br>\n只有 第一个匹配的 {…} 会被当做 tag<br>\n{} 不能嵌套<br>\n空标签 {} 是非法的<br>\n{abc} 和 {def} 就落不同 slot</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何判断 key 落在哪个节点?</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster keyslot name1</span><br><span class=\"line\"><span class=\"comment\"># 输出的数值就表示 slot</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5461 <span class=\"comment\"># slot值</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何查看指定的slot中有多少个key?</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster countkeysinslot 5461</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 表示slot中key的个数，这里显示只有1个key</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群通过<code>10000+port</code>这个端口号进行集群间通信，所以除了要开放<code>prot</code>这个端口，还要开放<code>10000+port</code>这个端口</p>\n</li>\n<li class=\"lvl-2\">\n<p>有关redis集群及其水平扩展的进一步说明，可以参看<a href=\"/2018/12/27/redis-cluster/\" title=\"Redis集群\">Redis集群</a></p>\n</li>\n</ul>\n<h3 id=\"集群优点\">集群优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无中心架构，集群内部自行维护数据的分片和主从的切换</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据分片存储，提供很高的访问效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>高可用性，可实现部分节点不可用时，集群仍可用</p>\n</li>\n<li class=\"lvl-2\">\n<p>高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持</p>\n</li>\n</ul>\n<h3 id=\"集群缺点\">集群缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据通过异步复制，不保证数据的强一致性</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能</p>\n</li>\n<li class=\"lvl-2\">\n<p>不建议使用pipeline和multi-keys操作</p>\n</li>\n</ul>\n<h3 id=\"redis-cli-的-Cluster-管理命令（用于管理-创建-调整集群）\">redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>redis-cli --cluster create host1:port host2:port ...</code></td>\n<td>创建 Redis Cluster 集群（自动分配 slots）</td>\n<td><code>redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster check host:port</code></td>\n<td>检查集群状态、健壮性</td>\n<td><code>redis-cli --cluster check 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster info host:port</code></td>\n<td>显示集群结构、节点、slots 分布</td>\n<td><code>redis-cli --cluster info 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster fix host:port</code></td>\n<td>修复 slots 移动、节点中断等异常状态</td>\n<td><code>redis-cli --cluster fix 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster rebalance host:port</code></td>\n<td>重新分布 slots（自动均衡负载）</td>\n<td><code>redis-cli --cluster rebalance 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port</code></td>\n<td>手动设置 rebalance 阈值；低于此阈值才会调整（百分比）</td>\n<td><code>redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster add-node newHost:newPort existingHost:existingPort</code></td>\n<td>将新节点加入集群</td>\n<td><code>redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port</code></td>\n<td>将新节点作为某主节点的 slave 加入</td>\n<td><code>redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster del-node host:port node_id</code></td>\n<td>从集群删除某节点（必须无 slots）</td>\n<td><code>redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt;</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster call host:port command ...</code></td>\n<td>在所有节点上批量执行命令</td>\n<td><code>redis-cli --cluster call 10.0.0.1:7000 PING</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster help</code></td>\n<td>显示 cluster 子命令帮助</td>\n<td><code>redis-cli --cluster help</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Redis-内置的-Cluster-操作命令\">Redis 内置的 Cluster 操作命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>CLUSTER INFO</code></td>\n<td>查看集群状态、failover 状态、slot 分布统计</td>\n<td><code>CLUSTER INFO</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER NODES</code></td>\n<td>显示所有节点和角色（master/slave）</td>\n<td><code>CLUSTER NODES</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER MYID</code></td>\n<td>输出本节点 ID</td>\n<td><code>CLUSTER MYID</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td>\n<td>将当前节点设置为某个 master 的 slave</td>\n<td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER</code></td>\n<td>主动 failover（slave 升级为 master）</td>\n<td>从节点执行：<code>CLUSTER FAILOVER</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER FORCE</code></td>\n<td>不等待复制同步，立刻切主</td>\n<td><code>CLUSTER FAILOVER FORCE</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER TAKEOVER</code></td>\n<td>强制接管 slot（完全覆盖 master）（危险）</td>\n<td><code>CLUSTER FAILOVER TAKEOVER</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER ADDSLOTS &lt;slot...&gt;</code></td>\n<td>将 slots 分配给当前 master</td>\n<td><code>CLUSTER ADDSLOTS 0 1 2</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER DELSLOTS &lt;slot...&gt;</code></td>\n<td>从当前节点移除 slots</td>\n<td><code>CLUSTER DELSLOTS 0 1 2</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code></td>\n<td>直接指定某个 slot 属于某个节点</td>\n<td><code>CLUSTER SETSLOT 0 NODE &lt;id&gt;</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt;</code></td>\n<td>设定迁移 key 的源节点（用于 slot 迁移）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt;</code></td>\n<td>设定迁移 key 的目标节点（用于 slot 迁移）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER KEYSLOT key</code></td>\n<td>返回 key 所属 slot</td>\n<td><code>CLUSTER KEYSLOT mykey</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt;</code></td>\n<td>查看某节点的 fail 票数</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER RESET</code></td>\n<td>删除节点全部集群信息（用来重置为 standalone）</td>\n<td><code>CLUSTER RESET HARD</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/ redis安装 1234567891011121314151617181920212223242526272829# 下载到指定目录mkdir -p /usr/local/softwget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft# 解压cd /usr/local/softtar -zxvf redis-7.4.7.tar.gz# 编译sudo yum install gcc gcc-c++ -ycd redis-7.4.7# 编译，会将编译好的可执行文件放在src目录下make# 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下mkdir build_dirmake install PREFIX=$(pwd)/build_dir# 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件cp redis.conf redis-6379.confvim redis-6379.conf #见下面的配置信息# 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析echo &#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27; &gt;&gt; /etc/bashrcsource /etc/bashrc# 验证redis-cli --version# 输出redis-cli 7.4.7 单节点 redis-6379.conf 的主要配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# 端口，默认 6379port 6379# 后台启动，默认 nodaemonize yes# yes: 当没有 bind / requirepass / ACL 时，只允许本机访问# no: 允许任意访问# 这里会启用ACL，所以设置为 yes，默认 yesprotected-mode yes# 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置#bind 127.0.0.1# 可以配置为，本机IP 内网IP 外网IP# bind 127.0.0.1 10.250.0.103 18.163.188.20# 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照# 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件save &quot;&quot;# 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录dir /usr/local/soft/dir-redis7/6379# 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no# 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复# 生成环境必须开启appendonly yes# aof文件名称，默认 appendonly.aofappendfilename &quot;appendonly.aof&quot;# aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir# redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：# appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件# appendonly.aof.N.incr.aof：记录每个写操作命令# appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)appenddirname &quot;appendonlydir&quot;# aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysecappendfsync everysec# 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令# 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb# 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令# 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb# aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mbauto-aof-rewrite-min-size 64mb# aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100auto-aof-rewrite-percentage 100# 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes# 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aofaof-use-rdb-preamble yes# 防止 AOF 意外截断导致 Redis 起不来，默认 yesaof-load-truncated yes# pid文件路径，默认 /var/run/redis_6379.pidpidfile &quot;redis_6379.pid&quot;# 日志文件名称，默认 &quot;&quot;logfile &quot;6379.log&quot;# 指定最大内存，单位bytes，这里设置4G# 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降maxmemory 4294967296# 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间# volatile-lru: 只会淘汰「设置了过期时间」的 key# allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的# allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的# noeviction: 不淘汰，默认maxmemory-policy allkeys-lru# 慢查询日志# 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来slowlog-log-slower-than 10000# 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录slowlog-max-len 1024# 性能优化# Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了io-threads 4# 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端# 推荐&gt;=4核才开启，否则开了反而更慢io-threads-do-reads yes# 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着tcp-keepalive 60# 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0# 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放timeout 0# 最大客户端连接数，默认 10000maxclients 10000# 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;# rename-command SHUTDOWN &quot;&quot;# rename-command CONFIG &quot;&quot;# rename-command KEYS &quot;&quot;# rename-command SAVE &quot;&quot;# rename-command BGSAVE &quot;&quot;# rename-command DEBUG &quot;&quot;# rename-command EVAL &quot;&quot;# rename-command SCRIPT &quot;&quot;# Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。# 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。lazyfree-lazy-eviction yes# 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。lazyfree-lazy-expire yes# 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：# RENAME 替换旧 key 时删除旧 value# SET 操作覆盖旧值时删除旧 value# SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value# 重写函数、脚本时删除旧对象# 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。lazyfree-lazy-server-del yes# 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。# 此配置只影响副本不会影响主节点。replica-lazy-flush yes# 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。# 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。# 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。lazyfree-lazy-user-del no# FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行# 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。lazyfree-lazy-user-flush no# 开启 ACL 文件aclfile /usr/local/soft/redis-7.4.7/users.acl Redis 7 支持的淘汰策略 策略 是否只淘汰带 TTL 的 key 淘汰规则 说明 noeviction ❌ 不淘汰 不删任何 key 内存满了直接返回错误（默认） allkeys-lru ❌ 所有 key 最近最久未使用 ✅ 最常用 allkeys-lfu ❌ 所有 key 访问频率最少 ✅ 热点场景最好 allkeys-random ❌ 所有 key 随机删除 ❌ 很少用 volatile-lru ✅ 只淘汰有 TTL 的 最近最久未使用 你之前用的 volatile-lfu ✅ 只淘汰有 TTL 的 访问频率最少 较少使用 volatile-random ✅ 只淘汰有 TTL 的 随机删除 很少用 volatile-ttl ✅ 只淘汰有 TTL 的 TTL 最小（马上过期的） 特殊场景用 users.acl 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 Redis 7 + ACL 简介 1234# 关闭默认用户，禁止匿名访问user default off# 超级管理员user admin on ~* &amp;* +@all &gt;123456 redis 服务启动与关闭 123456789101112# 启动服务redis-server redis-6379.conf# 登录服务，本机访问可以省略 -h -predis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 关闭服务# shutdown == shutdown saveredis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown# 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave 场景 推荐命令 正常下线（生产） shutdown nosave 已开 AOF shutdown nosave 数据很大 shutdown nosave 单机调试 shutdown 确定要生成快照 shutdown save 强制杀死(redis卡死) kill -9（极端情况） 单节点优点 单机部署简单方便 单节点缺点 不保证数据的可靠性，不适用于数据可靠性要求高的场景 单点故障导致无法提供服务，或者硬盘损坏导致数据丢失 redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流 主从 规划 123master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36 主从配置时，主节点不需要做任何修改 从节点配置文件增加同步主节点信息，其余配置与主节点相同 123456789# 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号replicaof 10.250.0.235 6379# 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致replica-read-only yes# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 此时启动从节点redis-server redis-6379.conf，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步 主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点 主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点 从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式 此时登录master的redis并执行info replication命令 12345678910111213# Replicationrole:master # 表示当前是从节点connected_slaves:1 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 # 从节点信息master_failover_state:no-failover # 主节点切换状态，无master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:56 # 主节点复制的偏移量second_repl_offset:-1repl_backlog_active:1 # 是否开启复制回放repl_backlog_size:1048576 # 复制回放缓冲区大小repl_backlog_first_byte_offset:1 # 复制回放缓冲区第一个字节的偏移量repl_backlog_histlen:56 # 复制回放缓冲区历史长度 此时登录从节点的redis并执行info replication命令 12345678910111213141516171819202122# Replicationrole:slave # 表示当前是从节点master_host:10.250.0.235 # 主节点的ipmaster_port:6379 # 主节点的端口master_link_status:up # 主从节点连接状态，up 表示已经连接上主节点master_last_io_seconds_ago:6 # 主从节点最后一次io操作时间master_sync_in_progress:0 # 主从节点是否正在同步数据，0表示已完成slave_read_repl_offset:112 # 从节点已经读取的复制偏移量slave_repl_offset:112 # 从节点已经写入的复制偏移量slave_priority:100 # 从节点的优先级slave_read_only:1 # 从节点是否只读replica_announced:1 # 从节点是否被其他节点所代理connected_slaves:0 # 从节点所代理的从节点数量master_failover_state:no-failover # 主节点的故障转移状态，no-failover表示没有进行故障转移master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112 # 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:15repl_backlog_histlen:98 主从数据同步是否完成判断规则，在从节点上执行命令info replication 字段 正常值 说明 role slave 表示当前是从节点 master_link_status up 表示已经连上主库 master_sync_in_progress 0 同步不在进行中 = 已完成 slave_read_repl_offset ≈ master_repl_offset 接近 说明数据已追上 参照上面的配置，再添加一个从节点后，在主节点执行命令 info replication 1234567891011121314# Replicationrole:masterconnected_slaves:2 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0 # 第二个从节点信息master_failover_state:no-failovermaster_replid:93e564c18d27418e52fc40254c764d76c1dc3f67master_replid2:0000000000000000000000000000000000000000master_repl_offset:4313second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:4313 主从优点 对请求进行读写分离，提高处理效率 可以提供多个副本，提高数据安全性 主从缺点 不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预 哨兵 创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵 规划 123456master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36sentinel1 10.250.0.71sentinel2 10.250.0.131sentinel3 10.250.0.63 分别编辑各自的 sentinel.conf 123456789101112131415161718192021222324252627282930# 端口号port 26379# 后台启动daemonize yes# dir，需要提前创建好dir /usr/local/soft/dir-redis7/sentinel# pid文件路径pidfile redis-sentinel.pid# 日志文件名称logfile &quot;sentinel.log&quot;# 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1sentinel monitor mymaster 10.250.0.235 6379 2# 主观下线时间（5秒），默认30秒sentinel down-after-milliseconds mymaster 5000# 故障转移超时时间 60秒，默认180秒sentinel failover-timeout mymaster 60000# 每次允许多少个slave重新同步，默认就是 1sentinel parallel-syncs mymaster 1# acl用户名和密码，这里为了方便也是用的管理员帐号sentinel auth-user mymaster adminsentinel auth-pass mymaster 123456 分别启动三个哨兵节点redis-sentinel sentinel.conf，此时登录哨兵节点redis-cli -p 26379，并执行info Sentinel命令，查看其是否正确识别了主从 12345678# Sentinelsentinel_masters:1 # 哨兵集群中主从节点的数量sentinel_tilt:0 # 是否处于 tilt 状态sentinel_tilt_since_seconds:-1 # tilt 状态的开始时间sentinel_running_scripts:0 # 正在运行的脚本数量sentinel_scripts_queue_length:0 # 脚本队列长度sentinel_simulate_failure_flags:0 # 模拟故障的标志master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 # 主节点的地址，从节点数量和哨兵数量 此时查看sentinel.conf可以在文件最后看到从节点信息和其它的哨兵节点信息(但实测无法感知其它哨兵节点)，类似于 123456789101112131415# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9 # 延迟追踪信息百分比user default on nopass sanitize-payload ~* &amp;* +@all # 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 # 本节点的idsentinel config-epoch mymaster 0sentinel leader-epoch mymaster 0sentinel current-epoch 0# 一个从节点信息sentinel known-replica mymaster 10.250.0.58 6379# 另一个从节点信息sentinel known-replica mymaster 10.250.0.36 6379# 一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a# 另一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8 此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看info Sentinel，就会发现master节点变成了从节点其中的一个了 此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更 123456# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9replicaof 10.250.0.36 6379save 3600 1save 300 100save 60 10000 这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave 123# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 顺便说一下，关闭哨兵服务的命令如下： 1redis-cli -p 26379 shutdown 哨兵优点 主节点故障，可以自动在从节点中重新选主 哨兵缺点 哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载 从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离 集群 搭建6个redis的集群，3主3从 规划 123456redis1 10.250.0.235redis2 10.250.0.58redis3 10.250.0.36redis4 10.250.0.71redis5 10.250.0.131redis6 10.250.0.63 还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息 123456789101112131415161718192021# ACL认证，所有节点都要配置masteruser &quot;admin&quot;masterauth &quot;123456&quot;# 启动集群模式cluster-enabled yes# 集群节点信息文件，这里最好和port对应上cluster-config-file nodes-6379.conf# 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰cluster-node-timeout 15000# 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，# 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置# 开启这个配置可以预防集群脑裂问题，默认为3min-replicas-to-write 1# 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能# 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败cluster-require-full-coverage yes 分别启动6个redis服务 1redis-server redis-6379.conf 创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(删除dir配置的目录中的所有文件即可)，然后在任意一个redis执行 12345redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379# 参数说明：# --cluster create：创建集群# --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点# 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从 此时会列出集群内主从和槽位的分配方案，输入yes即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 10.250.0.131:6379 to 10.250.0.235:6379Adding replica 10.250.0.63:6379 to 10.250.0.58:6379Adding replica 10.250.0.71:6379 to 10.250.0.36:6379M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) masterM: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) masterM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) masterS: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceS: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 replicates 2527142b7cffaf6bb92608550c919a0db0607c39Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 slots: (0 slots) slave replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 slots: (0 slots) slave replicates 2527142b7cffaf6bb92608550c919a0db0607c39S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 slots: (0 slots) slave replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 登录集群并查询集群配置信息 12# -c 表示以集群模式登录，-h 集群内任意ipredis-cli --user admin --pass 123456 -c -h 10.250.0.235 查看集群信息 1234567891011121314151617181910.250.0.235:6379&gt; cluster info# 输出集群状态cluster_state:ok # 集群整体状态：ok 表示集群当前可用、健康cluster_slots_assigned:16384 # 已分配的哈希槽数量（总槽数固定为 16384）cluster_slots_ok:16384 # 正常工作的槽数量（等于已分配槽，说明全部正常）cluster_slots_pfail:0 # 处于“疑似失败(pfail)”状态的槽数量cluster_slots_fail:0 # 被判定为失败(fail)的槽数量cluster_known_nodes:6 # 当前节点已知的集群节点总数（主节点 + 从节点）cluster_size:3 # 主节点数量（3 主节点，典型的 3 主 3 从结构）cluster_current_epoch:6 # 集群当前的全局纪元（用于选举和配置同步）cluster_my_epoch:1 # 当前这个节点所在的纪元cluster_stats_messages_ping_sent:159 # 当前节点已发送的 PING 消息数量（心跳）cluster_stats_messages_pong_sent:156 # 当前节点已发送的 PONG 消息数量（心跳响应）cluster_stats_messages_sent:315 # 当前节点发送的所有集群消息总数cluster_stats_messages_ping_received:151 # 当前节点收到的 PING 消息数量cluster_stats_messages_pong_received:159 # 当前节点收到的 PONG 消息数量cluster_stats_messages_meet_received:5 # 当前节点收到的 MEET 消息数量（新节点加入发现）cluster_stats_messages_received:315 # 当前节点收到的所有集群消息总数total_cluster_links_buffer_limit_exceeded:0 # 因输出缓冲区超限被强制断开的集群连接数（0 = 正常） 查看节点列表 1234567891011121310.250.0.235:6379&gt; cluster nodes# 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460# 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected# 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected# 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected# 主节点（master），负责槽位 10923-16383（集群中第三段槽位）88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383# 主节点（master），负责槽位 5461-10922（集群中第二段槽位）2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922 此时查看nodes-6379.conf也会看到和上面一样的节点信息 此时关闭其中一个master节点，比如10.250.0.36，则其对应的slave节点10.250.0.71会切换为新的master节点，此时10.250.0.36的状态最终变为fail 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922 再次启动10.250.0.36，其会变成10.250.0.71的slave节点 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922 若此时还是希望 10.250.0.36 做为主节点，则需要先登录10.250.0.36，再执行如下命令 12345# 注意要加 -credis-cli -c --user admin --pass 123456 -h 10.250.0.3610.250.0.36:6379&gt; cluster failover # 安全版（等待复制同步）# 或者10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER # TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐) redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot 1234567HASH_SLOT=CRC16(key) mod 16384# 跳转重定位10.250.0.235:6379&gt; set name zhangsan# 输出-&gt; Redirected to slot [5798] located at 10.250.0.58:6379OK 关闭集群，6个redis分别关闭 1redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown 重启集群，6个redis分别启动即可 1redis-server redis-6379.conf mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- &#123;xxx&#125;，其必须用&#123;&#125;括起来，xxx可以是任意字符串，计算slot时，只会根据xxx来计算hash值，这样就保证了所有key中包含&#123;xxx&#125;的key都会落到同一个slot，&#123;xxx&#125;可以放在key的任意位置 1234567891010.250.0.235:6379&gt; mset name1 lisi name2 wangwu(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwuOK10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2-&gt; Redirected to slot [5474] located at 10.250.0.58:63791) &quot;lisi&quot;2) &quot;wangwu&quot; 注意: {…} 让多个 key 落在同一个 slot，支持跨 key 原子操作 只有 第一个匹配的 {…} 会被当做 tag {} 不能嵌套 空标签 {} 是非法的 {abc} 和 {def} 就落不同 slot 如何判断 key 落在哪个节点? 12310.250.0.235:6379&gt; cluster keyslot name1# 输出的数值就表示 slot(integer) 5461 # slot值 如何查看指定的slot中有多少个key? 12310.250.0.235:6379&gt; cluster countkeysinslot 5461# 输出(integer) 1 # 表示slot中key的个数，这里显示只有1个key 集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源 集群通过10000+port这个端口号进行集群间通信，所以除了要开放prot这个端口，还要开放10000+port这个端口 有关redis集群及其水平扩展的进一步说明，可以参看Redis集群 集群优点 无中心架构，集群内部自行维护数据的分片和主从的切换 数据分片存储，提供很高的访问效率 高可用性，可实现部分节点不可用时，集群仍可用 高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持 集群缺点 数据通过异步复制，不保证数据的强一致性 不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0 不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作 Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点 Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能 不建议使用pipeline和multi-keys操作 redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群） 命令 作用 示例 redis-cli --cluster create host1:port host2:port ... 创建 Redis Cluster 集群（自动分配 slots） redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1 redis-cli --cluster check host:port 检查集群状态、健壮性 redis-cli --cluster check 10.0.0.1:7000 redis-cli --cluster info host:port 显示集群结构、节点、slots 分布 redis-cli --cluster info 10.0.0.1:7000 redis-cli --cluster fix host:port 修复 slots 移动、节点中断等异常状态 redis-cli --cluster fix 10.0.0.1:7000 redis-cli --cluster rebalance host:port 重新分布 slots（自动均衡负载） redis-cli --cluster rebalance 10.0.0.1:7000 redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port 手动设置 rebalance 阈值；低于此阈值才会调整（百分比） redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000 redis-cli --cluster add-node newHost:newPort existingHost:existingPort 将新节点加入集群 redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000 redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port 将新节点作为某主节点的 slave 加入 redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000 redis-cli --cluster del-node host:port node_id 从集群删除某节点（必须无 slots） redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt; redis-cli --cluster call host:port command ... 在所有节点上批量执行命令 redis-cli --cluster call 10.0.0.1:7000 PING redis-cli --cluster help 显示 cluster 子命令帮助 redis-cli --cluster help Redis 内置的 Cluster 操作命令 命令 作用 示例 CLUSTER INFO 查看集群状态、failover 状态、slot 分布统计 CLUSTER INFO CLUSTER NODES 显示所有节点和角色（master/slave） CLUSTER NODES CLUSTER MYID 输出本节点 ID CLUSTER MYID CLUSTER REPLICATE &lt;node-id&gt; 将当前节点设置为某个 master 的 slave CLUSTER REPLICATE &lt;node-id&gt; CLUSTER FAILOVER 主动 failover（slave 升级为 master） 从节点执行：CLUSTER FAILOVER CLUSTER FAILOVER FORCE 不等待复制同步，立刻切主 CLUSTER FAILOVER FORCE CLUSTER FAILOVER TAKEOVER 强制接管 slot（完全覆盖 master）（危险） CLUSTER FAILOVER TAKEOVER CLUSTER ADDSLOTS &lt;slot...&gt; 将 slots 分配给当前 master CLUSTER ADDSLOTS 0 1 2 CLUSTER DELSLOTS &lt;slot...&gt; 从当前节点移除 slots CLUSTER DELSLOTS 0 1 2 CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt; 直接指定某个 slot 属于某个节点 CLUSTER SETSLOT 0 NODE &lt;id&gt; CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt; 设定迁移 key 的源节点（用于 slot 迁移） - CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt; 设定迁移 key 的目标节点（用于 slot 迁移） - CLUSTER KEYSLOT key 返回 key 所属 slot CLUSTER KEYSLOT mykey CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt; 查看某节点的 fail 票数 - CLUSTER RESET 删除节点全部集群信息（用来重置为 standalone） CLUSTER RESET HARD","summary":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/","date_published":"2025-12-05T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","url":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","title":"brew -- 创建自己的 Formula","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n-->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://brew.sh\">brew</a>是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如<code>git</code>、<code>node</code>、<code>python</code>等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文介绍如何在macos下创建自己的 Formula</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。</p>\n</li>\n<li class=\"lvl-2\">\n<p>关于 brew 的安装及使用可以参考 <a href=\"/2024/11/28/brew/\" title=\"MacOS软件包管理器--brew\">MacOS软件包管理器--brew</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"从一个简单示例开始\">从一个简单示例开始</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看<a href=\"https://github.com/hanqunfeng/color_echo/blob/main/bin/color_echo\">color_echo</a>，这是一个用于终端打印彩色文本的命令。</p>\n</li>\n</ul>\n<h3 id=\"创建一个Github仓库，用于存储-color-echo-命令\">创建一个Github仓库，用于存储 color_echo 命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 <code>color_echo</code> 命令文件，仓库名称: <code>hanqunfeng/color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>编写命令文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> color_echo_dir</span><br><span class=\"line\"><span class=\"built_in\">cd</span> color_echo_dir</span><br><span class=\"line\"><span class=\"comment\"># 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了</span></span><br><span class=\"line\"><span class=\"comment\"># 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到</span></span><br><span class=\"line\">bin/color_echo</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提交代码并打Tag</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 color_echo_dir 目录下初始化仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Initial commit&quot;</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\"># 创建Tag</span></span><br><span class=\"line\">git tag v1.0.0</span><br><span class=\"line\"><span class=\"comment\"># 推送Tag</span></span><br><span class=\"line\">git push --tags</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取tag的sha256值</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz</span><br><span class=\"line\">shasum -a 256 v1.0.0.tar.gz</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d  v1.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"发布-color-echo\">发布 color_echo</h3>\n<blockquote>\n<p><code>brew create</code> 命令已经失效，需要手工创建</p>\n</blockquote>\n<h4 id=\"创建-tap-仓库\">创建 tap 仓库</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap-new hanqunfeng/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Warning: tap-new is a developer <span class=\"built_in\">command</span>, so Homebrew<span class=\"string\">&#x27;s</span></span><br><span class=\"line\"><span class=\"string\">developer mode has been automatically turned on.      # 提示开发者模式已自动打开</span></span><br><span class=\"line\"><span class=\"string\">To turn developer mode off, run:</span></span><br><span class=\"line\"><span class=\"string\">  brew developer off  # 如后续需要关闭开发者模式可以运行该命令</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 初始化仓库</span></span><br><span class=\"line\"><span class=\"string\">Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/</span></span><br><span class=\"line\"><span class=\"string\">[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap</span></span><br><span class=\"line\"><span class=\"string\"> 3 files changed, 107 insertions(+)</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/publish.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/tests.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 README.md</span></span><br><span class=\"line\"><span class=\"string\">==&gt; Created hanqunfeng/color_echo</span></span><br><span class=\"line\"><span class=\"string\">/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">When a pull request making changes to a formula (or formulae) becomes green</span></span><br><span class=\"line\"><span class=\"string\">(all checks passed), then you can publish the built bottles.</span></span><br><span class=\"line\"><span class=\"string\">To do so, label your PR as `pr-pull` and the workflow will be triggered.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"手写一个-Formula-文件\">手写一个 Formula 文件</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formula</span><br><span class=\"line\"><span class=\"built_in\">touch</span> color_echo.rb</span><br></pre></td></tr></table></figure>\n<p>写入内容（模板）：模板格式后面会详细介绍</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\">  desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span></span><br><span class=\"line\">  homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span></span><br><span class=\"line\">  url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span></span><br><span class=\"line\">  sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span></span><br><span class=\"line\">  license <span class=\"string\">&quot;MIT&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  def install</span><br><span class=\"line\">    bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">test</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交-Formula-文件到Github仓库\">提交 Formula 文件到Github仓库</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 Formula 文件: <code>hanqunfeng/homebrew-color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>添加 Formula 文件到仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> $(brew --repo hanqunfeng/color_echo)</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add color_echo 1.0.0&quot;</span></span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)</span><br><span class=\"line\">error: failed to push some refs to <span class=\"string\">&#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限<code>repo</code> 和 <code>workflow</code>，重新推送</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥</span></span><br><span class=\"line\">git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">* [new branch]      main -&gt; main</span><br><span class=\"line\">branch <span class=\"string\">&#x27;main&#x27;</span> <span class=\"built_in\">set</span> up to track <span class=\"string\">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-Formula\">安装 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echo</span></span><br><span class=\"line\">brew tap hanqunfeng/color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索</span></span><br><span class=\"line\">brew search color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">hanqunfeng/color_echo/color_echo              color-code</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整包名搜索</span></span><br><span class=\"line\">brew search hanqunfeng/color_echo/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">brew install color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Fetching downloads <span class=\"keyword\">for</span>: color_echo</span><br><span class=\"line\">✔︎ Formula color_echo (1.0.0)                                   [Verifying     2.1KB/  2.1KB]</span><br><span class=\"line\">==&gt; Installing color_echo from hanqunfeng/color_echo</span><br><span class=\"line\">🍺  /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built <span class=\"keyword\">in</span> 5 seconds</span><br><span class=\"line\">==&gt; Running `brew cleanup color_echo`...</span><br><span class=\"line\">Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.</span><br><span class=\"line\">Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`).</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试-Formula\">测试 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color_echo --<span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">用法: color_echo [参数] 内容</span><br><span class=\"line\"></span><br><span class=\"line\">参数说明:</span><br><span class=\"line\">  -c, --color &lt;color&gt;        设置前景色（文字颜色）</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">  -b, --<span class=\"built_in\">bg</span> &lt;color&gt;           设置背景色</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">      --bold                 加粗字体</span><br><span class=\"line\">      --underline            下划线</span><br><span class=\"line\">      --italic               斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持）</span><br><span class=\"line\"></span><br><span class=\"line\">  -n                         不换行输出，兼容 <span class=\"built_in\">echo</span> 的 -n 参数</span><br><span class=\"line\"></span><br><span class=\"line\">  -h, --<span class=\"built_in\">help</span>                 显示帮助信息</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\">  color_echo --color green <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\">  color_echo -c red -b yellow --bold <span class=\"string\">&quot;Error Message&quot;</span></span><br><span class=\"line\">  color_echo --underline <span class=\"string\">&quot;This is underlined&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"formula-文件模板\">formula 文件模板</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ruby语法，定义一个Formula的子类</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class 子类 &lt; 父类</span></span><br><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加属性</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span>  <span class=\"comment\"># 描述</span></span><br><span class=\"line\">homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span>  <span class=\"comment\"># 项目地址</span></span><br><span class=\"line\">url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span>  <span class=\"comment\"># 下载地址，安装时会自动下载并解压</span></span><br><span class=\"line\">sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span>  <span class=\"comment\"># sha256，校验v1.0.0.tar.gz</span></span><br><span class=\"line\">license <span class=\"string\">&quot;MIT&quot;</span>   <span class=\"comment\"># 许可</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加安装方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def install  <span class=\"comment\"># Homebrew 会执行的安装步骤，工作目录为解压后的文件目录</span></span><br><span class=\"line\">  <span class=\"comment\"># 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install</span></span><br><span class=\"line\">  bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span> <span class=\"comment\"># 将 bin/color_echo 安装到 /usr/local/bin/color_echo</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果要指定安装后的命令名称，可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 如果需要执行系统命令可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># system &quot;echo&quot;, &quot;hello world&quot;</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加测试方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"keyword\">do</span>  <span class=\"comment\"># Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码</span></span><br><span class=\"line\">  <span class=\"comment\"># system 指令用于执行系统命令，逗号分隔相当于空格</span></span><br><span class=\"line\">  system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span>  <span class=\"comment\"># 相当于执行 color_echo --help</span></span><br><span class=\"line\">  <span class=\"comment\"># 断言测试</span></span><br><span class=\"line\">  <span class=\"comment\"># assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>#{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>系统 / 架构</th>\n<th>实际路径示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Intel Mac</td>\n<td><code>/usr/local/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Apple Silicon</td>\n<td><code>/opt/homebrew/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Linuxbrew</td>\n<td><code>/home/linuxbrew/.linuxbrew/Cellar/.../bin</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放在 def install 方法之前</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> <span class=\"comment\"># 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :build   <span class=\"comment\"># 只在构建时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :<span class=\"built_in\">test</span>    <span class=\"comment\"># 测试时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; [:build, :<span class=\"built_in\">test</span>] <span class=\"comment\"># 构建和测试都需要</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境约束</span></span><br><span class=\"line\">depends_on macos: :sonoma          <span class=\"comment\"># 仅 macOS Sonoma</span></span><br><span class=\"line\">depends_on <span class=\"built_in\">arch</span>: :x86_64           <span class=\"comment\"># 仅 x86_64</span></span><br><span class=\"line\">depends_on xcode: [<span class=\"string\">&quot;9.3&quot;</span>, :build]  <span class=\"comment\"># 仅当 Xcode≥9.3 且用于 build</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 依赖第三方库中的命令要用完整包名</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;hanqunfeng/color_echo/color_echo&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于更多的 Formula 文件模板，可以参考：<a href=\"https://docs.brew.sh/Formula-Cookbook\">https://docs.brew.sh/Formula-Cookbook</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>同时也可以通过 <code>brew edit xxx</code> 命令查看该 Formula 文件的内容进行学习</p>\n</li>\n</ul>\n","content_text":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew 从一个简单示例开始 这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看color_echo，这是一个用于终端打印彩色文本的命令。 创建一个Github仓库，用于存储 color_echo 命令 创建一个Github仓库，用于存储 color_echo 命令文件，仓库名称: hanqunfeng/color_echo 编写命令文件 12345mkdir color_echo_dircd color_echo_dir# 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了# 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到bin/color_echo 提交代码并打Tag 1234567891011# 在 color_echo_dir 目录下初始化仓库git initgit add .git commit -m &quot;Initial commit&quot;git branch -M maingit remote add origin https://github.com/hanqunfeng/color_echo.gitgit push -u origin main# 创建Taggit tag v1.0.0# 推送Taggit push --tags 获取tag的sha256值 1234wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gzshasum -a 256 v1.0.0.tar.gz## 输出9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d v1.0.0.tar.gz 发布 color_echo brew create 命令已经失效，需要手工创建 创建 tap 仓库 1234567891011121314151617181920brew tap-new hanqunfeng/color_echo## 输出Warning: tap-new is a developer command, so Homebrew&#x27;sdeveloper mode has been automatically turned on. # 提示开发者模式已自动打开To turn developer mode off, run: brew developer off # 如后续需要关闭开发者模式可以运行该命令## 初始化仓库Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap 3 files changed, 107 insertions(+) create mode 100644 .github/workflows/publish.yml create mode 100644 .github/workflows/tests.yml create mode 100644 README.md==&gt; Created hanqunfeng/color_echo/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echoWhen a pull request making changes to a formula (or formulae) becomes green(all checks passed), then you can publish the built bottles.To do so, label your PR as `pr-pull` and the workflow will be triggered. 手写一个 Formula 文件 12cd /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formulatouch color_echo.rb 写入内容（模板）：模板格式后面会详细介绍 123456789101112131415class ColorEcho &lt; Formula desc &quot;Print colorful text in terminal&quot; homepage &quot;https://github.com/hanqunfeng/color_echo&quot; url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; license &quot;MIT&quot; def install bin.install &quot;bin/color_echo&quot; end test do system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; endend 提交 Formula 文件到Github仓库 创建一个Github仓库，用于存储 Formula 文件: hanqunfeng/homebrew-color_echo 添加 Formula 文件到仓库 123456789101112131415cd $(brew --repo hanqunfeng/color_echo)git add .git commit -m &quot;Add color_echo 1.0.0&quot;git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)error: failed to push some refs to &#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27; 提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限repo 和 workflow，重新推送 12345678910111213# 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git* [new branch] main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 安装 Formula 12345678910111213141516171819202122232425# 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echobrew tap hanqunfeng/color_echo# 搜索brew search color_echo## 输出==&gt; Formulaehanqunfeng/color_echo/color_echo color-code# 完整包名搜索brew search hanqunfeng/color_echo/color_echo## 输出==&gt; Formulaecolor_echo# 安装brew install color_echo## 输出==&gt; Fetching downloads for: color_echo✔︎ Formula color_echo (1.0.0) [Verifying 2.1KB/ 2.1KB]==&gt; Installing color_echo from hanqunfeng/color_echo🍺 /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built in 5 seconds==&gt; Running `brew cleanup color_echo`...Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`). 测试 Formula 1234567891011121314151617181920212223color_echo --help## 输出用法: color_echo [参数] 内容参数说明: -c, --color &lt;color&gt; 设置前景色（文字颜色） 可选颜色: black red green yellow blue magenta cyan white -b, --bg &lt;color&gt; 设置背景色 可选颜色: black red green yellow blue magenta cyan white --bold 加粗字体 --underline 下划线 --italic 斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持） -n 不换行输出，兼容 echo 的 -n 参数 -h, --help 显示帮助信息示例: color_echo --color green &quot;Hello World&quot; color_echo -c red -b yellow --bold &quot;Error Message&quot; color_echo --underline &quot;This is underlined&quot; formula 文件模板 Ruby语法，定义一个Formula的子类 1234# class 子类 &lt; 父类class ColorEcho &lt; Formulaend 添加属性 12345desc &quot;Print colorful text in terminal&quot; # 描述homepage &quot;https://github.com/hanqunfeng/color_echo&quot; # 项目地址url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; # 下载地址，安装时会自动下载并解压sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; # sha256，校验v1.0.0.tar.gzlicense &quot;MIT&quot; # 许可 添加安装方法 123456789def install # Homebrew 会执行的安装步骤，工作目录为解压后的文件目录 # 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install bin.install &quot;bin/color_echo&quot; # 将 bin/color_echo 安装到 /usr/local/bin/color_echo # 如果要指定安装后的命令名称，可以使用如下方式 # bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot; # 如果需要执行系统命令可以使用如下方式 # system &quot;echo&quot;, &quot;hello world&quot;end 添加测试方法 123456test do # Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码 # system 指令用于执行系统命令，逗号分隔相当于空格 system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; # 相当于执行 color_echo --help # 断言测试 # assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)end #{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同 系统 / 架构 实际路径示例 Intel Mac /usr/local/Cellar/color_echo/1.0.0/bin Apple Silicon /opt/homebrew/Cellar/color_echo/1.0.0/bin Linuxbrew /home/linuxbrew/.linuxbrew/Cellar/.../bin 如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖 123456789101112131415# 放在 def install 方法之前depends_on &quot;jq&quot; # 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用depends_on &quot;jq&quot; =&gt; :build # 只在构建时需要depends_on &quot;jq&quot; =&gt; :test # 测试时需要depends_on &quot;jq&quot; =&gt; [:build, :test] # 构建和测试都需要# 环境约束depends_on macos: :sonoma # 仅 macOS Sonomadepends_on arch: :x86_64 # 仅 x86_64depends_on xcode: [&quot;9.3&quot;, :build] # 仅当 Xcode≥9.3 且用于 build# 依赖第三方库中的命令要用完整包名depends_on &quot;hanqunfeng/color_echo/color_echo&quot; 后记 关于更多的 Formula 文件模板，可以参考：https://docs.brew.sh/Formula-Cookbook 同时也可以通过 brew edit xxx 命令查看该 Formula 文件的内容进行学习","summary":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew","date_published":"2025-12-02T13:55:05.000Z","tags":["macos","macos","brew"]},{"id":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","url":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","title":"Linux常用命令--lsof","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 lsof 命令的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于CentOS8。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"lsof-是什么？\">lsof 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>lsof = list open files</p>\n</li>\n<li class=\"lvl-2\">\n<p>它用来查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">当前系统中所有进程打开的文件</li>\n<li class=\"lvl-4\">包含普通文件、目录、socket、管道、网络连接、设备等</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>在 Linux 中：“一切皆文件”</p>\n</li>\n<li class=\"lvl-2\">\n<p>所以你可以用 lsof 查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">谁在占用你的端口？</li>\n<li class=\"lvl-4\">哪个进程正在读/写某个文件？</li>\n<li class=\"lvl-4\">为什么文件删除了却还占磁盘？</li>\n<li class=\"lvl-4\">哪个文件被锁住？</li>\n<li class=\"lvl-4\">哪些程序在访问某个目录？</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install lsof -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"lsof-的基本用法\">lsof 的基本用法</h2>\n<h3 id=\"查看被删除但仍被占用的文件\">查看被删除但仍被占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了<code>rm</code>命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> 中看不到</span><br><span class=\"line\"><span class=\"built_in\">du</span> 不会统计空间</span><br><span class=\"line\">只有 lsof 能看到，这是典型的 “deleted but still open” 状态。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时可以通过如下命令查询哪些被删除的文件还被占用：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有 link count 小于 1 的（deleted）文件</span></span><br><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\"># 列出所有被删除的文件</span></span><br><span class=\"line\">lsof | grep deleted</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果查询到这种文件，则需要停止进程，才能真正删除文件。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>记一次线上服务器磁盘空间告警问题排查</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">监控系统告警磁盘空间小于15%，通过如下命令查看确实如此</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">df</span> -hT</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Filesystem Type  Size Used Avail Use% Mounted on</span><br><span class=\"line\">/dev/xvda1 ext4  7.9G 3.3G 4.6G  42%  /</span><br><span class=\"line\">tmpfs      tmpfs 2.0G 0    2.0G  0%   /dev/shm</span><br><span class=\"line\">/dev/xvdf1 ext4  99G  80G  15G   85%  /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">du</span> -sh /usr/local/boss/logs</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">2.3G    /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\">## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄</span></span><br><span class=\"line\">COMMAND    PID      USER    FD      TYPE    DEVICE  SIZE/OFF      NLINK   NODE    NAME</span><br><span class=\"line\">java       1836     boss    1w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br><span class=\"line\">java       1836     boss    2w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。</li>\n</ul>\n</div>\n<h3 id=\"查端口被哪个进程占用\">查端口被哪个进程占用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出指定端口对应的进程</span></span><br><span class=\"line\">lsof -i tcp:8080</span><br><span class=\"line\"><span class=\"comment\"># 协议可以省略</span></span><br><span class=\"line\">lsof -i :8080</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:webcache (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将服务名称替换为端口</span></span><br><span class=\"line\">lsof -i :8080 -P</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:8080 (LISTEN)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看某个进程打开的所有文件\">查看某个进程打开的所有文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -p &lt;PID&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE  SIZE/OFF       NODE NAME</span><br><span class=\"line\">java    18548 boss  cwd    DIR      202,1      4096      35377 /home/boss</span><br><span class=\"line\">java    18548 boss  rtd    DIR      202,1      4096          2 /</span><br><span class=\"line\">java    18548 boss  mem    REG      202,1 106065056      60671 /usr/lib/locale/locale-archive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能看到这个进程：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">打开的日志文件</li>\n<li class=\"lvl-4\">使用的 jar 文件</li>\n<li class=\"lvl-4\">使用的 socket</li>\n<li class=\"lvl-4\">使用的 config 文件</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>输出结果字段说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COMMAND</td>\n<td>程序名（java）</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>进程号（18548）</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>运行用户（boss）</td>\n</tr>\n<tr>\n<td>FD</td>\n<td>文件描述符</td>\n</tr>\n<tr>\n<td>TYPE</td>\n<td>文件类型</td>\n</tr>\n<tr>\n<td>DEVICE</td>\n<td>所在磁盘分区 ID</td>\n</tr>\n<tr>\n<td>SIZE/OFF</td>\n<td>文件大小（字节）</td>\n</tr>\n<tr>\n<td>NODE</td>\n<td>inode 编号</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>文件名（或网络连接信息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看指定用户占用的文件\">查看指定用户占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出用户 boss 所有进程打开的文件</span></span><br><span class=\"line\">lsof -u &lt;USER&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看指定程序-COMMAND-打开的文件\">查看指定程序(COMMAND)打开的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -c &lt;<span class=\"built_in\">command</span>&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查某个目录或文件正在被哪些进程占用\">查某个目录或文件正在被哪些进程占用</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录 +D</span></span><br><span class=\"line\"><span class=\"comment\"># 能显示所有正在访问该目录中文件的进程</span></span><br><span class=\"line\">lsof +D /home/boss/logs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件</span></span><br><span class=\"line\">lsof /home/boss/logs/access.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只列出 nginx 用户占用的文件目录中的哪些文件</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u nginx +D /usr/local/nginx/logs</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看网络连接\">查看网络连接</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 过滤协议</span></span><br><span class=\"line\">lsof -i tcp</span><br><span class=\"line\">lsof -i udp</span><br><span class=\"line\"><span class=\"comment\"># 过滤状态</span></span><br><span class=\"line\">lsof -i -s tcp:listen</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有监听端口，</span></span><br><span class=\"line\"><span class=\"comment\"># -i: 显示网络相关的文件</span></span><br><span class=\"line\"><span class=\"comment\"># -P: 显示端口(不加-P则显示的是服务名)</span></span><br><span class=\"line\"><span class=\"comment\"># -n: 不将 IP 映射成主机名（禁用 DNS 查询）</span></span><br><span class=\"line\"><span class=\"comment\"># -s: 过滤显示连接状态</span></span><br><span class=\"line\">lsof -i -P -n -s tcp:listen</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">mongod     1782     root    5u  IPv4       8697      0t0  TCP *:27017 (LISTEN)</span><br><span class=\"line\">java       1808     boss   36u  IPv6       9221      0t0  TCP *:8082 (LISTEN)</span><br><span class=\"line\">java       1808     boss   39u  IPv6       9230      0t0  TCP 127.0.0.1:7093 (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出用户 boss 的网络连接</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u boss -i</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用参数详解\">常用参数详解</h2>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-i</code></td>\n<td>查看网络相关文件/端口</td>\n<td><code>lsof -i</code></td>\n</tr>\n<tr>\n<td><code>-i :端口</code></td>\n<td>查看指定端口</td>\n<td><code>lsof -i :8080</code></td>\n</tr>\n<tr>\n<td><code>-p PID</code></td>\n<td>查看某个进程所有打开文件</td>\n<td><code>lsof -p 1836</code></td>\n</tr>\n<tr>\n<td><code>-u 用户名</code></td>\n<td>查看某个用户进程的打开文件</td>\n<td><code>lsof -u nginx</code></td>\n</tr>\n<tr>\n<td><code>-c 进程名关键字</code></td>\n<td>查看某个进程名相关的文件</td>\n<td><code>lsof -c java</code></td>\n</tr>\n<tr>\n<td><code>+D 目录</code></td>\n<td>查看目录中所有被访问的文件</td>\n<td><code>lsof +D /usr/local/netqin/boss/netqin/logs</code></td>\n</tr>\n<tr>\n<td><code>+L1</code></td>\n<td>查找已删除但仍被打开的文件</td>\n<td><code>lsof +L1</code>（=查找“(deleted)”占盘问题）</td>\n</tr>\n<tr>\n<td><code>-d FD</code></td>\n<td>查看指定文件描述符</td>\n<td><code>lsof -d 1 -p 1836</code>（看进程 stdout）</td>\n</tr>\n<tr>\n<td><code>-n</code></td>\n<td>不做 DNS 解析，提高速度</td>\n<td><code>lsof -i -n</code></td>\n</tr>\n<tr>\n<td><code>-P</code></td>\n<td>显示端口号（不解析为服务名）</td>\n<td><code>lsof -i -P</code></td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>按连接状态过滤（TCP/UDP）</td>\n<td><code>lsof -i -sTCP:LISTEN</code></td>\n</tr>\n<tr>\n<td><code>-r</code></td>\n<td>持续输出（实时监控）</td>\n<td><code>lsof -i -r 1</code>（每秒刷新网络连接）</td>\n</tr>\n<tr>\n<td><code>-a</code></td>\n<td>逻辑 AND，不加 -a 都是 逻辑 OR</td>\n<td><code>lsof -u boss -i</code>（列出用户 boss 的网络连接）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-FD-字段详细解释\">lsof 文件 FD 字段详细解释</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FD（文件描述符）格式总规则：数字 + 标志位</p>\n</li>\n<li class=\"lvl-2\">\n<p>lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10r   → FD=10，<span class=\"built_in\">read</span> only（只读）</span><br><span class=\"line\">1w    → FD=1，write only（只写）</span><br><span class=\"line\">36u   → FD=36，<span class=\"built_in\">read</span>/write（可读可写）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解释</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>部分</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数字（0、1、2、3、10、36…）</strong></td>\n<td>文件描述符编号</td>\n</tr>\n<tr>\n<td><strong>字母（r / w / u）</strong></td>\n<td>访问模式：读/写/读写</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>FD 编号</th>\n<th>标准含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td>stdin（标准输入）</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td>stdout（标准输出）</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>stderr（标准错误输出）</td>\n</tr>\n<tr>\n<td><strong>3</strong> 及以上</td>\n<td>进程打开的普通文件、日志、socket、管道等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>特殊 FD 类型（没有数字）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cwd</code></td>\n<td>当前工作目录，说明进程在这个目录下运行</td>\n</tr>\n<tr>\n<td><code>rtd</code></td>\n<td>进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs</td>\n</tr>\n<tr>\n<td><code>txt</code></td>\n<td>可执行文件本体</td>\n</tr>\n<tr>\n<td><code>mem</code></td>\n<td>内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-TYPE-字段详细解释\">lsof 文件 TYPE 字段详细解释</h2>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>全称</th>\n<th>含义</th>\n<th>常见场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>REG</strong></td>\n<td>Regular file</td>\n<td>普通文件</td>\n<td>日志、配置、可执行程序等</td>\n</tr>\n<tr>\n<td><strong>DIR</strong></td>\n<td>Directory</td>\n<td>目录</td>\n<td>进程访问的目录，例如当前工作目录</td>\n</tr>\n<tr>\n<td><strong>CHR</strong></td>\n<td>Character special file</td>\n<td>字符设备文件</td>\n<td><code>/dev/null</code>、<code>/dev/tty</code>、串口、键盘等</td>\n</tr>\n<tr>\n<td><strong>BLK</strong></td>\n<td>Block special file</td>\n<td>块设备文件</td>\n<td><code>/dev/sda</code>、硬盘、分区等</td>\n</tr>\n<tr>\n<td><strong>FIFO</strong></td>\n<td>Named pipe</td>\n<td>命名管道</td>\n<td>Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信</td>\n</tr>\n<tr>\n<td><strong>sock</strong></td>\n<td>Socket</td>\n<td>套接字（Unix 域 socket）</td>\n<td><code>/var/run/docker.sock</code>、MySQL UNix socket</td>\n</tr>\n<tr>\n<td><strong>IPv4</strong></td>\n<td>IPv4 socket</td>\n<td>IPv4 网络连接/监听</td>\n<td><code>TCP *:80</code>、<code>UDP 127.0.0.1:53</code></td>\n</tr>\n<tr>\n<td><strong>IPv6</strong></td>\n<td>IPv6 socket</td>\n<td>IPv6 网络连接/监听</td>\n<td><code>TCP [::]:22</code></td>\n</tr>\n<tr>\n<td><strong>unix</strong></td>\n<td>Unix domain socket</td>\n<td>本地进程通信</td>\n<td><code>/run/systemd/journal/stdout</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。 lsof 是什么？ lsof = list open files 它用来查看： 当前系统中所有进程打开的文件 包含普通文件、目录、socket、管道、网络连接、设备等 在 Linux 中：“一切皆文件” 所以你可以用 lsof 查看： 谁在占用你的端口？ 哪个进程正在读/写某个文件？ 为什么文件删除了却还占磁盘？ 哪个文件被锁住？ 哪些程序在访问某个目录？ CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装 1yum install lsof -y lsof 的基本用法 查看被删除但仍被占用的文件 如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了rm命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。 文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在： 123ls 中看不到du 不会统计空间只有 lsof 能看到，这是典型的 “deleted but still open” 状态。 此时可以通过如下命令查询哪些被删除的文件还被占用： 1234# 列出所有 link count 小于 1 的（deleted）文件lsof +L1# 列出所有被删除的文件lsof | grep deleted 如果查询到这种文件，则需要停止进程，才能真正删除文件。 记一次线上服务器磁盘空间告警问题排查 监控系统告警磁盘空间小于15%，通过如下命令查看确实如此 123456$ df -hT# 输出Filesystem Type Size Used Avail Use% Mounted on/dev/xvda1 ext4 7.9G 3.3G 4.6G 42% /tmpfs tmpfs 2.0G 0 2.0G 0% /dev/shm/dev/xvdf1 ext4 99G 80G 15G 85% /usr/local/boss/logs 但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多 123$ du -sh /usr/local/boss/logs# 输出2.3G /usr/local/boss/logs 此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看： 12345lsof +L1## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄COMMAND PID USER FD TYPE DEVICE SIZE/OFF NLINK NODE NAMEjava 1836 boss 1w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted)java 1836 boss 2w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted) 结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。 查端口被哪个进程占用 通过如下命令查询： 1234567891011121314# 列出指定端口对应的进程lsof -i tcp:8080# 协议可以省略lsof -i :8080## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:webcache (LISTEN)# 将服务名称替换为端口lsof -i :8080 -P## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:8080 (LISTEN) 查看某个进程打开的所有文件 通过如下命令查询： 12345678lsof -p &lt;PID&gt;## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss cwd DIR 202,1 4096 35377 /home/bossjava 18548 boss rtd DIR 202,1 4096 2 /java 18548 boss mem REG 202,1 106065056 60671 /usr/lib/locale/locale-archive 能看到这个进程： 打开的日志文件 使用的 jar 文件 使用的 socket 使用的 config 文件 输出结果字段说明 字段 含义 COMMAND 程序名（java） PID 进程号（18548） USER 运行用户（boss） FD 文件描述符 TYPE 文件类型 DEVICE 所在磁盘分区 ID SIZE/OFF 文件大小（字节） NODE inode 编号 NAME 文件名（或网络连接信息） 查看指定用户占用的文件 通过如下命令查询： 12# 列出用户 boss 所有进程打开的文件lsof -u &lt;USER&gt; 查看指定程序(COMMAND)打开的文件 通过如下命令查询： 1lsof -c &lt;command&gt; 查某个目录或文件正在被哪些进程占用 1234567891011# 目录 +D# 能显示所有正在访问该目录中文件的进程lsof +D /home/boss/logs# 文件lsof /home/boss/logs/access.log# 只列出 nginx 用户占用的文件目录中的哪些文件# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u nginx +D /usr/local/nginx/logs 查看网络连接 12345678910111213141516171819202122lsof -i# 过滤协议lsof -i tcplsof -i udp# 过滤状态lsof -i -s tcp:listen# 列出所有监听端口，# -i: 显示网络相关的文件# -P: 显示端口(不加-P则显示的是服务名)# -n: 不将 IP 映射成主机名（禁用 DNS 查询）# -s: 过滤显示连接状态lsof -i -P -n -s tcp:listen## 输出示例mongod 1782 root 5u IPv4 8697 0t0 TCP *:27017 (LISTEN)java 1808 boss 36u IPv6 9221 0t0 TCP *:8082 (LISTEN)java 1808 boss 39u IPv6 9230 0t0 TCP 127.0.0.1:7093 (LISTEN)# 列出用户 boss 的网络连接# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u boss -i 常用参数详解 参数 作用 示例 -i 查看网络相关文件/端口 lsof -i -i :端口 查看指定端口 lsof -i :8080 -p PID 查看某个进程所有打开文件 lsof -p 1836 -u 用户名 查看某个用户进程的打开文件 lsof -u nginx -c 进程名关键字 查看某个进程名相关的文件 lsof -c java +D 目录 查看目录中所有被访问的文件 lsof +D /usr/local/netqin/boss/netqin/logs +L1 查找已删除但仍被打开的文件 lsof +L1（=查找“(deleted)”占盘问题） -d FD 查看指定文件描述符 lsof -d 1 -p 1836（看进程 stdout） -n 不做 DNS 解析，提高速度 lsof -i -n -P 显示端口号（不解析为服务名） lsof -i -P -s 按连接状态过滤（TCP/UDP） lsof -i -sTCP:LISTEN -r 持续输出（实时监控） lsof -i -r 1（每秒刷新网络连接） -a 逻辑 AND，不加 -a 都是 逻辑 OR lsof -u boss -i（列出用户 boss 的网络连接） lsof 文件 FD 字段详细解释 FD（文件描述符）格式总规则：数字 + 标志位 lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。 示例 12310r → FD=10，read only（只读）1w → FD=1，write only（只写）36u → FD=36，read/write（可读可写） 解释 部分 含义 数字（0、1、2、3、10、36…） 文件描述符编号 字母（r / w / u） 访问模式：读/写/读写 FD 编号 标准含义 0 stdin（标准输入） 1 stdout（标准输出） 2 stderr（标准错误输出） 3 及以上 进程打开的普通文件、日志、socket、管道等 特殊 FD 类型（没有数字） 字段 含义 cwd 当前工作目录，说明进程在这个目录下运行 rtd 进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs txt 可执行文件本体 mem 内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件 lsof 文件 TYPE 字段详细解释 文件类型 全称 含义 常见场景 REG Regular file 普通文件 日志、配置、可执行程序等 DIR Directory 目录 进程访问的目录，例如当前工作目录 CHR Character special file 字符设备文件 /dev/null、/dev/tty、串口、键盘等 BLK Block special file 块设备文件 /dev/sda、硬盘、分区等 FIFO Named pipe 命名管道 Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信 sock Socket 套接字（Unix 域 socket） /var/run/docker.sock、MySQL UNix socket IPv4 IPv4 socket IPv4 网络连接/监听 TCP *:80、UDP 127.0.0.1:53 IPv6 IPv6 socket IPv6 网络连接/监听 TCP [::]:22 unix Unix domain socket 本地进程通信 /run/systemd/journal/stdout","summary":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。","date_published":"2025-11-26T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2025/11/20/utc/","url":"https://blog.hanqunfeng.com/2025/11/20/utc/","title":"什么是 UTC？一篇人人都能看懂的科普文章","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"一、为什么世界需要统一时间？\">一、为什么世界需要统一时间？</h2>\n<p>早期，每个城市甚至每个乡镇都根据 <strong>太阳位置</strong>确定时间：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>太阳在头顶就是 12 点</p>\n</li>\n<li class=\"lvl-2\">\n<p>不同地方经度不同，每地时间都不同</p>\n</li>\n</ul>\n<p>这种方法在本地没问题，但到了 <strong>跨区域铁路、通信、航海、航空、互联网时代</strong>，问题巨大：</p>\n<blockquote>\n<p>两地时间不统一，火车、舰队、订单、通信都没法同步记录。</p>\n</blockquote>\n<p>因此世界需要：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 <strong>全球统一、精确的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>所有人、所有系统都能对齐使用</p>\n</li>\n</ul>\n<p>UTC 就是在这个背景下诞生的。</p>\n<hr>\n<h2 id=\"二、UTC-是什么？\">二、UTC 是什么？</h2>\n<p>UTC 的全称：</p>\n<blockquote>\n<p><strong>Coordinated Universal Time（协调世界时）</strong></p>\n</blockquote>\n<p>它是当今全球使用的 <strong>标准时间系统</strong>。</p>\n<p>它的主要特点：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不是某个国家的时间</p>\n</li>\n<li class=\"lvl-2\">\n<p>是国际组织共同维护</p>\n</li>\n<li class=\"lvl-2\">\n<p>全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准</p>\n</li>\n</ul>\n<p>一句话：</p>\n<blockquote>\n<p><strong>UTC 是现代世界共同使用的“世界时间”。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"三、UTC-和-GMT-的关系\">三、UTC 和 GMT 的关系</h2>\n<p>很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>GMT</th>\n<th>UTC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>出现年代</td>\n<td>19 世纪</td>\n<td>1972 年</td>\n</tr>\n<tr>\n<td>基准</td>\n<td>地球自转（天文时间）</td>\n<td>原子钟（更精确）</td>\n</tr>\n<tr>\n<td>是否仍是标准</td>\n<td>已被替代</td>\n<td>当前唯一标准</td>\n</tr>\n</tbody>\n</table>\n<p>但在日常使用中：</p>\n<blockquote>\n<p><strong>UTC ≈ GMT（同为零时区）</strong></p>\n</blockquote>\n<p>所以：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>英国冬季使用 GMT（UTC+0）</p>\n</li>\n<li class=\"lvl-2\">\n<p>技术系统使用 UTC（UTC+0）</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、UTC-是如何确定的？\">四、UTC 是如何确定的？</h2>\n<p>UTC 并不是按太阳走，而是：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>由全世界 <strong>原子钟网络统一生成</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>每秒误差小于 <strong>十亿分之一秒</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>然后根据地球自转误差偶尔加“闰秒”</p>\n</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-12-31 23:59:60 UTC   ← 曾经加过闰秒</span><br></pre></td></tr></table></figure>\n<p>这样：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>保证时间极其准确</p>\n</li>\n<li class=\"lvl-2\">\n<p>又不会与地球真实昼夜偏离太多</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"五、UTC-与时区\">五、UTC 与时区</h2>\n<p>UTC 是 0 时区。</p>\n<p>所有时区都是 <strong>在 UTC 基础上加减偏移</strong>：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>北京时间：UTC + 8</p>\n</li>\n<li class=\"lvl-2\">\n<p>纽约时间：UTC – 5（冬季）或 –4（夏令时）</p>\n</li>\n<li class=\"lvl-2\">\n<p>日本时间：UTC + 9</p>\n</li>\n</ul>\n<p>所以你常看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8 或 UTC-5</span><br></pre></td></tr></table></figure>\n<p>表示该地区比 UTC 早或晚多少小时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8  &gt;  UTC+0  &gt;  UTC−5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>换成生活语言：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC+8（例如北京时间）比 UTC 早 8 小时</li>\n<li class=\"lvl-4\">UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>举例：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC(即UTC+0) 时间是 12:00</li>\n<li class=\"lvl-4\">UTC+8 = 20:00（已经晚上）</li>\n<li class=\"lvl-4\">UTC−5 = 07:00（还在早上）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"六、UTC-在计算机世界的重要性\">六、UTC 在计算机世界的重要性</h2>\n<p>几乎所有 IT 系统都推荐：</p>\n<blockquote>\n<p><strong>存储用 UTC，展示给用户再转换成当地时区。</strong></p>\n</blockquote>\n<p>原因很简单：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>全球一致，不会混乱</p>\n</li>\n<li class=\"lvl-2\">\n<p>不受时区或夏令时影响</p>\n</li>\n<li class=\"lvl-2\">\n<p>跨国系统日志可对齐分析</p>\n</li>\n</ul>\n<p>你在日志里经常见到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2025-11-20T08:30:00Z</span><br></pre></td></tr></table></figure>\n<p>结尾的 <code>Z</code> 就表示：</p>\n<blockquote>\n<p><strong>这是 UTC 时间</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"七、UTC、GMT、CST-总结对比\">七、UTC、GMT、CST 总结对比</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>全称</th>\n<th>现在地位</th>\n<th>是否标准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTC</td>\n<td>Coordinated Universal Time</td>\n<td>全球标准</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>GMT</td>\n<td>Greenwich Mean Time</td>\n<td>被 UTC 替代</td>\n<td>✖（历史含义）</td>\n</tr>\n<tr>\n<td>CST</td>\n<td>China Standard Time（中国）或 Central Standard Time（美国）</td>\n<td>本地时区</td>\n<td>不是世界统一基准</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<blockquote>\n<p>“CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。</p>\n</blockquote>\n<hr>\n<h2 id=\"八、一句话总结\">八、一句话总结</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>UTC 是现代全球统一的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>所有时区都是相对于 UTC 偏移</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>计算机领域普遍使用 UTC 存储时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>GMT 是 UTC 的历史前身</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>北京时间 = UTC + 8</strong></p>\n</li>\n</ul>\n<p>只要理解这几点，你已经掌握了世界时间体系的核心。</p>\n","content_text":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。 一、为什么世界需要统一时间？ 早期，每个城市甚至每个乡镇都根据 太阳位置确定时间： 太阳在头顶就是 12 点 不同地方经度不同，每地时间都不同 这种方法在本地没问题，但到了 跨区域铁路、通信、航海、航空、互联网时代，问题巨大： 两地时间不统一，火车、舰队、订单、通信都没法同步记录。 因此世界需要： 一个 全球统一、精确的标准时间 所有人、所有系统都能对齐使用 UTC 就是在这个背景下诞生的。 二、UTC 是什么？ UTC 的全称： Coordinated Universal Time（协调世界时） 它是当今全球使用的 标准时间系统。 它的主要特点： 不是某个国家的时间 是国际组织共同维护 全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准 一句话： UTC 是现代世界共同使用的“世界时间”。 三、UTC 和 GMT 的关系 很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。 项目 GMT UTC 出现年代 19 世纪 1972 年 基准 地球自转（天文时间） 原子钟（更精确） 是否仍是标准 已被替代 当前唯一标准 但在日常使用中： UTC ≈ GMT（同为零时区） 所以： 英国冬季使用 GMT（UTC+0） 技术系统使用 UTC（UTC+0） 四、UTC 是如何确定的？ UTC 并不是按太阳走，而是： 由全世界 原子钟网络统一生成 每秒误差小于 十亿分之一秒 然后根据地球自转误差偶尔加“闰秒” 例如： 12016-12-31 23:59:60 UTC ← 曾经加过闰秒 这样： 保证时间极其准确 又不会与地球真实昼夜偏离太多 五、UTC 与时区 UTC 是 0 时区。 所有时区都是 在 UTC 基础上加减偏移： 北京时间：UTC + 8 纽约时间：UTC – 5（冬季）或 –4（夏令时） 日本时间：UTC + 9 所以你常看到： 1UTC+8 或 UTC-5 表示该地区比 UTC 早或晚多少小时。 1UTC+8 &gt; UTC+0 &gt; UTC−5 换成生活语言： UTC+8（例如北京时间）比 UTC 早 8 小时 UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时 举例： UTC(即UTC+0) 时间是 12:00 UTC+8 = 20:00（已经晚上） UTC−5 = 07:00（还在早上） 六、UTC 在计算机世界的重要性 几乎所有 IT 系统都推荐： 存储用 UTC，展示给用户再转换成当地时区。 原因很简单： 全球一致，不会混乱 不受时区或夏令时影响 跨国系统日志可对齐分析 你在日志里经常见到： 12025-11-20T08:30:00Z 结尾的 Z 就表示： 这是 UTC 时间 七、UTC、GMT、CST 总结对比 名称 全称 现在地位 是否标准 UTC Coordinated Universal Time 全球标准 ✔ GMT Greenwich Mean Time 被 UTC 替代 ✖（历史含义） CST China Standard Time（中国）或 Central Standard Time（美国） 本地时区 不是世界统一基准 注意： “CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。 八、一句话总结 UTC 是现代全球统一的标准时间 所有时区都是相对于 UTC 偏移 计算机领域普遍使用 UTC 存储时间 GMT 是 UTC 的历史前身 北京时间 = UTC + 8 只要理解这几点，你已经掌握了世界时间体系的核心。","summary":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。","date_published":"2025-11-20T14:30:05.000Z","tags":["技术","UTC","UTC"]},{"id":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","url":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","title":"RocketMQ ACL 2.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-2-0-简介\">ACL 2.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href=\"https://rocketmq.apache.org/zh/docs/bestPractice/03access\">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在阿里云上找到一篇参考资料：<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a></p>\n</li>\n</ul>\n<h2 id=\"配置步骤\">配置步骤</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 认证配置</span></span><br><span class=\"line\">authenticationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class=\"line\">initAuthenticationUser = &#123;<span class=\"string\">&quot;username&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;password&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">innerClientAuthenticationCredentials = &#123;<span class=\"string\">&quot;accessKey&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;secretKey&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class=\"line\"><span class=\"comment\"># 授权配置</span></span><br><span class=\"line\">authorizationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class=\"line\">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数定义</th>\n<th style=\"text-align:left\">参数名称</th>\n<th style=\"text-align:left\">参数描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationEnabled</strong></td>\n<td style=\"text-align:left\">是否打开认证开关</td>\n<td style=\"text-align:left\">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationProvider</strong></td>\n<td style=\"text-align:left\">认证方式提供者</td>\n<td style=\"text-align:left\">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>initAuthenticationUser</strong></td>\n<td style=\"text-align:left\">系统初始化用户</td>\n<td style=\"text-align:left\">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>innerClientAuthenticationCredentials</strong></td>\n<td style=\"text-align:left\">组件间认证用户</td>\n<td style=\"text-align:left\">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationMetadataProvider</strong></td>\n<td style=\"text-align:left\">认证元数据提供者</td>\n<td style=\"text-align:left\">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationStrategy</strong></td>\n<td style=\"text-align:left\">认证策略</td>\n<td style=\"text-align:left\">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启启动所有 Broker</p>\n</li>\n</ul>\n<h2 id=\"命令行管理用户\">命令行管理用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"用户管理\">用户管理</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口定义</th>\n<th style=\"text-align:left\">接口名称</th>\n<th style=\"text-align:left\">接口参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>createUser</strong></td>\n<td style=\"text-align:left\">创建用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>updateUser</strong></td>\n<td style=\"text-align:left\">更新用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>deleteUser</strong></td>\n<td style=\"text-align:left\">删除用户</td>\n<td style=\"text-align:left\">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>getUser</strong></td>\n<td style=\"text-align:left\">查询用户详情</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>listUser</strong></td>\n<td style=\"text-align:left\">查询用户列表</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 创建用户，指定用户类型</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class=\"line\"><span class=\"comment\"># 更新用户</span></span><br><span class=\"line\">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class=\"line\"><span class=\"comment\"># 删除用户</span></span><br><span class=\"line\">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户详情</span></span><br><span class=\"line\">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure>\n<h3 id=\"权限管理\">权限管理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令名称</th>\n<th style=\"text-align:left\">操作定义</th>\n<th style=\"text-align:left\">命令参数及解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><code>createAcl</code></strong></td>\n<td style=\"text-align:left\">创建授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>updateAcl</code></strong></td>\n<td style=\"text-align:left\">更新授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>deleteAcl</code></strong></td>\n<td style=\"text-align:left\">删除授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>listAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权列表</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>getAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权详情</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建授权</span></span><br><span class=\"line\">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class=\"line\"><span class=\"comment\"># 更新授权</span></span><br><span class=\"line\">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class=\"line\"><span class=\"comment\"># 删除授权</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 删除授权，指定资源</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权详情</span></span><br><span class=\"line\">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n<li class=\"lvl-2\">\n<p>按照这篇文章<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;innerClientAuthenticationCredentials&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>异常信息如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.zcw159357.com/article/1/2025-03-15-0048.html\">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.csdn.net/icebamboo2015/article/details/152118732\">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p>\n</li>\n</ul>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 2.0 简介 在 RocketMQ官网 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: https://rocketmq.apache.org/zh/docs/bestPractice/03access。 在阿里云上找到一篇参考资料：Apache RocketMQ ACL 2.0 全新升级 配置步骤 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 2.0。 在所有 Broker 的配置文件broker.conf中增加认证与授权配置: 1234567891011# broker.conf# 认证配置authenticationEnabled = trueauthenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProviderinitAuthenticationUser = &#123;&quot;username&quot;:&quot;mqadmin&quot;,&quot;password&quot;:&quot;1234567&quot;&#125;innerClientAuthenticationCredentials = &#123;&quot;accessKey&quot;:&quot;mqadmin&quot;,&quot;secretKey&quot;:&quot;1234567&quot;&#125;authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider# 授权配置authorizationEnabled = trueauthorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProviderauthorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider 参数定义 参数名称 参数描述 authenticationEnabled 是否打开认证开关 用于判断认证是否打开。可选值：• true – 是• false – 否 authenticationProvider 认证方式提供者 用于提供请求访问时的认证方式。可选值：• org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider – 默认的认证方式 initAuthenticationUser 系统初始化用户 用于系统初始化时自动创建的用户账号。示例：&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125; innerClientAuthenticationCredentials 组件间认证用户 用于设置集群内组件之间的访问凭证。示例：&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125; authenticationMetadataProvider 认证元数据提供者 用于提供认证相关的元数据（如用户）。可选值：• org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider – 本地认证元数据提供者• org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider – Proxy认证元数据提供者 authenticationStrategy 认证策略 用于指定请求访问时的认证策略。可选值：• org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy – 每次请求认证策略• org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy – 首次请求认证策略 重启启动所有 Broker 命令行管理用户 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 用户管理 接口定义 接口名称 接口参数 createUser 创建用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） updateUser 更新用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） deleteUser 删除用户 -b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 getUser 查询用户详情 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 listUser 查询用户列表 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-f 过滤条件（支持用户名称模糊查询，可选） 示例 1234567891011121314# 创建用户sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq# 创建用户，指定用户类型sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super# 更新用户sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678# 删除用户sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户详情sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户列表sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster# 查询用户列表，带过滤条件sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq 权限管理 管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。 命令名称 操作定义 命令参数及解释 createAcl 创建授权 -n 127.0.0.1:9876：NameServer 地址（多个以 ; 分隔）-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户（User:rocketmq 表示给用户 rocketmq 授权）-r Topic:*,Group:：资源类型与名称，* 表示所有 Topic 和 Group-a Pub,Sub：授权操作类型，Pub 表示发布权限，Sub 表示订阅权限-i 192.168.1.0/24：授权的 IP 地址范围-d Allow：授权类型，Allow 允许，Deny 拒绝 updateAcl 更新授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:*,Group:：资源类型与名称-a Pub,Sub：授权操作类型-i 192.168.1.0/24：IP 地址范围-d Deny：授权类型，更新为 Deny deleteAcl 删除授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定删除某个资源（如 Topic）授权 listAcl 查询授权列表 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定资源类型（如 Topic） getAcl 查询授权详情 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户 示例 1234567891011121314# 创建授权sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow# 更新授权sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny# 删除授权sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq# 删除授权，指定资源sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权列表sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster# 查询授权列表，带过滤条件sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权详情sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。 12345678910111213# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 按照这篇文章Apache RocketMQ ACL 2.0 全新升级的介绍，在所有 Proxy 的配置文件rmq-proxy.json中增加认证与授权配置依旧没有解决该问题。 123456789&#123; &quot;authenticationEnabled&quot;: true, &quot;authenticationProvider&quot;: &quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;, &quot;authenticationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;, &quot;innerClientAuthenticationCredentials&quot;: &quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;, &quot;authorizationEnabled&quot;: true, &quot;authorizationProvider&quot;: &quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;, &quot;authorizationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;&#125; 异常信息如下： 1Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again. 之后通过这篇文章 rocketmq部署踩坑(二) acl配置 的介绍，需要在 rmq-proxy.json 中增加如下配置： 1&quot;enableAclRpcHookForClusterMode&quot;: true 配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。 之后通过这篇文章 关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理 的说明，将所有 broker.conf 中 authorizationEnabled 配置改为 false，重启 Broker，问题解决。 后记 笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。","summary":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-31T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","url":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","title":"RocketMQ ACL 1.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 1.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-1-0-简介\">ACL 1.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。</p>\n</li>\n</ul>\n<h2 id=\"ACL-1-0-使用方法\">ACL 1.0 使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 1.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>首先需要在 Broker 节点开启 ACL 权限，在 <code>broker.conf</code> 文件中添加如下配置，并重启 Broker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aclEnable=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限配置文件为 <code>conf/plain_acl.yml</code>，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 白名单内的 IP 都可以访问，无需配置帐号</span></span><br><span class=\"line\"><span class=\"attr\">globalWhiteRemoteAddresses:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10.10</span><span class=\"number\">.103</span><span class=\"string\">.*</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"string\">.*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局白名单外的IP,需要账号访问</span></span><br><span class=\"line\"><span class=\"comment\"># 账号配置，数组形式</span></span><br><span class=\"line\"><span class=\"attr\">accounts:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">RocketMQ</span> <span class=\"comment\"># 用户名</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span> <span class=\"comment\"># 密码</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"comment\"># 当前帐号的白名单</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">false</span>        <span class=\"comment\"># 是否是管理员</span></span><br><span class=\"line\">    <span class=\"attr\">defaultTopicPerm:</span> <span class=\"string\">DENY</span> <span class=\"comment\"># 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">defaultGroupPerm:</span> <span class=\"string\">SUB</span>  <span class=\"comment\"># 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">topicPerms:</span>            <span class=\"comment\"># 特定的 topic 权限</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicA=DENY</span>        <span class=\"comment\"># topicName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicC=SUB</span></span><br><span class=\"line\">    <span class=\"attr\">groupPerms:</span>            <span class=\"comment\"># 特定的 ConsumerGroup 权限</span></span><br><span class=\"line\">      <span class=\"comment\"># the group should convert to retry topic</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupA=DENY</span>        <span class=\"comment\"># groupName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupC=SUB</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">rocketmq2</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"string\">.*</span></span><br><span class=\"line\">    <span class=\"comment\"># if it is admin, it could access all resources</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">true</span>         <span class=\"comment\"># 是否是管理员,true 表示管理员,管理员可以访问所有资源</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限定义</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限值</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>DENY</strong></td>\n<td style=\"text-align:left\">拒绝</td>\n<td style=\"text-align:left\">禁止对该 Topic 的任何操作（无论是发送还是订阅）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>ANY</strong></td>\n<td style=\"text-align:left\">任意权限</td>\n<td style=\"text-align:left\">具有发布（PUB）和订阅（SUB）双重权限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>PUB</strong></td>\n<td style=\"text-align:left\">发送权限</td>\n<td style=\"text-align:left\">允许生产者向该 Topic 发送消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SUB</strong></td>\n<td style=\"text-align:left\">订阅权限</td>\n<td style=\"text-align:left\">允许消费者订阅并消费该 Topic 的消息</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>defaultGroupPerm: SUB</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。</li>\n</ul>\n</div>\n<h3 id=\"命令行配置-ACL\">命令行配置 ACL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以下命令执行后会自动修改 <code>conf/plain_acl.yml</code> 文件</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加白名单</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*,10.252.*.*,10.20.0.31</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Broker 地址</strong></td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Cluster 名称</strong>，集群内所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要设置的全局白名单地址列表，支持通配符</td>\n<td style=\"text-align:left\"><code>&quot;10.10.103.*,192.168.0.*&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 ACL 配置文件路径（Broker 端对应的配置文件路径）</td>\n<td style=\"text-align:left\"><code>/home/rocketmq/conf/plain_acl.yml</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建管理员</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin \\</span><br><span class=\"line\">    -s 1234567 \\</span><br><span class=\"line\">    -m <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建普通用户</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">  -c DefaultCluster \\</span><br><span class=\"line\">  -a rocketmq_user \\</span><br><span class=\"line\">  -s 12345678 \\</span><br><span class=\"line\">  -i <span class=\"string\">&quot;PUB|SUB&quot;</span> \\</span><br><span class=\"line\">  -u SUB \\</span><br><span class=\"line\">  -t <span class=\"string\">&quot;topicA=PUB|SUB,topicB=DENY&quot;</span> \\</span><br><span class=\"line\">  -g <span class=\"string\">&quot;groupA=SUB,groupB=DENY&quot;</span> \\</span><br><span class=\"line\">  -w <span class=\"string\">&quot;192.168.0.*&quot;</span> \\</span><br><span class=\"line\">  -n 127.0.0.1:9876</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">密码（secretKey）</td>\n<td style=\"text-align:left\"><code>12345678</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称，集群中所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Group 权限列表</td>\n<td style=\"text-align:left\"><code>groupA=SUB,groupB=DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Topic 权限列表</td>\n<td style=\"text-align:left\">`topicA=PUB</td>\n<td>SUB,topicB=DENY`</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Group 权限</td>\n<td style=\"text-align:left\"><code>SUB</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Topic 权限</td>\n<td style=\"text-align:left\"><code>DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置 IP 白名单</td>\n<td style=\"text-align:left\"><code>&quot;10.10.10.*,192.168.1.*&quot;</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">是否设置为管理员账号</td>\n<td style=\"text-align:left\"><code>true</code> 或 <code>false</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteAccessConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要删除的用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称（删除整个集群上的该账号）</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n</ul>\n<h3 id=\"目前有两种没什么意义的解决方法：\">目前有两种没什么意义的解决方法：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">为 Proxy 开启 <code>enableAclRpcHookForClusterMode</code></li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/rmq-proxy.json</code>文件，添加<code>enableAclRpcHookForClusterMode</code>参数</li>\n</ul>\n  <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/tools.yml</code>文件，配置帐号信息：</li>\n</ul>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">重新启动Proxy即可</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 1.0 简介 ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。 一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。 ACL 1.0 使用方法 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 1.0。 首先需要在 Broker 节点开启 ACL 权限，在 broker.conf 文件中添加如下配置，并重启 Broker 1aclEnable=true 权限配置文件为 conf/plain_acl.yml，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下： 123456789101112131415161718192021222324252627282930# 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1# 白名单内的 IP 都可以访问，无需配置帐号globalWhiteRemoteAddresses: - 10.10.103.* - 192.168.0.*# 全局白名单外的IP,需要账号访问# 账号配置，数组形式accounts: - accessKey: RocketMQ # 用户名 secretKey: 12345678 # 密码 whiteRemoteAddress: # 当前帐号的白名单 admin: false # 是否是管理员 defaultTopicPerm: DENY # 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB defaultGroupPerm: SUB # 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB topicPerms: # 特定的 topic 权限 - topicA=DENY # topicName=perm - topicB=PUB|SUB - topicC=SUB groupPerms: # 特定的 ConsumerGroup 权限 # the group should convert to retry topic - groupA=DENY # groupName=perm - groupB=PUB|SUB - groupC=SUB - accessKey: rocketmq2 secretKey: 12345678 whiteRemoteAddress: 192.168.1.* # if it is admin, it could access all resources admin: true # 是否是管理员,true 表示管理员,管理员可以访问所有资源 权限定义 权限值 含义 说明 DENY 拒绝 禁止对该 Topic 的任何操作（无论是发送还是订阅） ANY 任意权限 具有发布（PUB）和订阅（SUB）双重权限 PUB 发送权限 允许生产者向该 Topic 发送消息 SUB 订阅权限 允许消费者订阅并消费该 Topic 的消息 defaultGroupPerm: SUB 表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。 命令行配置 ACL 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 以下命令执行后会自动修改 conf/plain_acl.yml 文件 添加白名单 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.*,10.252.*.*,10.20.0.31 参数 是否必填 含义 示例 -b 二选一必填 指定要更新白名单的 Broker 地址 127.0.0.1:10911 -c 二选一必填 指定要更新白名单的 Cluster 名称，集群内所有 Broker 都会被更新 DefaultCluster -g ✅ 必填 要设置的全局白名单地址列表，支持通配符 &quot;10.10.103.*,192.168.0.*&quot; -n 可选 NameServer 地址 127.0.0.1:9876 -p 可选 指定 ACL 配置文件路径（Broker 端对应的配置文件路径） /home/rocketmq/conf/plain_acl.yml -h 否 打印帮助信息 — 创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位 1234567891011121314151617181920# 创建管理员sh bin/mqadmin updateAclConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin \\ -s 1234567 \\ -m true# 创建普通用户sh bin/mqadmin updateAclConfig \\ -c DefaultCluster \\ -a rocketmq_user \\ -s 12345678 \\ -i &quot;PUB|SUB&quot; \\ -u SUB \\ -t &quot;topicA=PUB|SUB,topicB=DENY&quot; \\ -g &quot;groupA=SUB,groupB=DENY&quot; \\ -w &quot;192.168.0.*&quot; \\ -n 127.0.0.1:9876 参数 是否必填 含义 示例 -a ✅ 必填 用户名（accessKey） rocketmq_user -s ✅ 必填 密码（secretKey） 12345678 -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称，集群中所有 Broker 都会被更新 DefaultCluster -g 可选 指定 Group 权限列表 groupA=SUB,groupB=DENY -t 可选 指定 Topic 权限列表 `topicA=PUB SUB,topicB=DENY` -u 可选 设置默认 Group 权限 SUB -i 可选 设置默认 Topic 权限 DENY -w 可选 设置 IP 白名单 &quot;10.10.10.*,192.168.1.*&quot; -m 可选 是否设置为管理员账号 true 或 false -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — 删除用户 1234sh bin/mqadmin deleteAccessConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin 参数 是否必填 含义 示例 -a ✅ 必填 要删除的用户名（accessKey） rocketmq_user -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称（删除整个集群上的该账号） DefaultCluster -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。 1234567891011121314# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 目前有两种没什么意义的解决方法： 将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.* 为 Proxy 开启 enableAclRpcHookForClusterMode 修改conf/rmq-proxy.json文件，添加enableAclRpcHookForClusterMode参数 1&quot;enableAclRpcHookForClusterMode&quot;: true 修改conf/tools.yml文件，配置帐号信息： 12accessKey: mqadminsecretKey: 1234567 重新启动Proxy即可 两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息 但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置","summary":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-29T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","title":"RocketMQ Admin Tool","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Admin Tool 的常用命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RocketMQ-Admin-Tool-简介\">RocketMQ Admin Tool 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool\">RocketMQ Admin Tool</a> 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。</p>\n</li>\n</ul>\n<h2 id=\"Topic-相关命令\">Topic 相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新 Topic</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全称</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">可选值 / 格式</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\"><code>-t MyTopic</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的 Broker 地址（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>ip:port</code></td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-b 192.168.1.10:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的集群名（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-c DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址列表</td>\n<td style=\"text-align:left\">多个地址用 <code>;</code> 分隔</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-n 192.168.1.1:9876;192.168.1.2:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--readQueueNums</code></td>\n<td style=\"text-align:left\">读队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-r 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--writeQueueNums</code></td>\n<td style=\"text-align:left\">写队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-w 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--perm</code></td>\n<td style=\"text-align:left\">Topic 权限，默认为6</td>\n<td style=\"text-align:left\">2：写（W）<br>4：读（R）<br>6：读写（RW）</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-p 6</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--order</code></td>\n<td style=\"text-align:left\">是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO”</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-o false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unit</code></td>\n<td style=\"text-align:left\">是否为单元（Unit）Topic（用于多租户隔离）</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-u false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--hasUnitSub</code></td>\n<td style=\"text-align:left\">是否有 Unit 订阅</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-s false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">额外属性设置，用 <code>+</code> 表示添加、<code>-</code> 表示删除</td>\n<td style=\"text-align:left\">例：<code>+a=b,+c=d,-e</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-a &quot;+message.type=NORMAL&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><code>-h</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topic</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic  -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic</span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMAL</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a <span class=\"string\">&quot;+message.type=NORMAL&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a <span class=\"string\">&quot;+message.type=FIFO&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定权限，默认为 6：读写</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看与删除 Topic</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，此时只打印 topic 列表</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Group</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876 -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 Topic，删除指定集群下的指定Topic</span></span><br><span class=\"line\">sh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其它 Topic 命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Topic 路由信息</span></span><br><span class=\"line\">sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;brokerDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.188:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.31:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.31:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.188:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">&quot;filterServerTable&quot;</span>:&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"string\">&quot;queueDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Topic 消息队列offset</span></span><br><span class=\"line\">sh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Min Offset           #Max Offset             #Last Updated</span></span><br><span class=\"line\">broker-a                          0     0                     3                       2025-10-27 03:08:43,112</span><br><span class=\"line\">broker-a                          1     0                     4                       2025-10-27 06:13:21,968</span><br><span class=\"line\">broker-a                          2     0                     2                       2025-10-27 06:13:34,685</span><br><span class=\"line\">broker-a                          3     0                     2                       2025-10-26 05:44:17,222</span><br><span class=\"line\">broker-a                          4     0                     1                       2025-10-26 05:44:45,513</span><br><span class=\"line\">broker-a                          5     0                     1                       2025-10-26 06:13:10,541</span><br><span class=\"line\">broker-a                          6     0                     2                       2025-10-26 02:58:34,393</span><br><span class=\"line\">broker-a                          7     0                     1                       2025-10-25 12:42:41,189</span><br><span class=\"line\">broker-b                          0     0                     1                       2025-10-25 14:01:24,836</span><br><span class=\"line\">broker-b                          1     0                     2                       2025-10-26 06:14:24,411</span><br><span class=\"line\">broker-b                          2     0                     0</span><br><span class=\"line\">broker-b                          3     0                     0</span><br><span class=\"line\">broker-b                          4     0                     0</span><br><span class=\"line\">broker-b                          5     0                     1                       2025-10-25 12:30:57,672</span><br><span class=\"line\">broker-b                          6     0                     1                       2025-10-26 06:19:47,051</span><br><span class=\"line\">broker-b                          7     0                     1                       2025-10-26 06:14:49,216</span><br></pre></td></tr></table></figure>\n<h2 id=\"集群相关命令\">集群相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群信息</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               2.60(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.03         0.3300          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                1     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  67.03         0.3200         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.80(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3200          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                1     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3300         <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\"><span class=\"comment\">#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)</span></span><br><span class=\"line\"><span class=\"comment\">#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)</span></span><br><span class=\"line\"><span class=\"comment\">#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计</span></span><br><span class=\"line\"><span class=\"comment\">#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好</span></span><br><span class=\"line\"><span class=\"comment\">#Hour: 表示 Broker 已运行的时长</span></span><br><span class=\"line\"><span class=\"comment\">#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%</span></span><br><span class=\"line\"><span class=\"comment\">#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群统计信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name     #Broker Name                       #InTotalYest  #OutTotalYest  #InTotalToday #OutTotalToday</span></span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0            369              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0              0              0              0</span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"消息相关\">消息相关</h2>\n<h3 id=\"发送消息\">发送消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">消息要发送的 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必须指定目标 Topic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--body</code></td>\n<td style=\"text-align:left\">消息体内容（UTF-8 字符串）</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>&quot;Hello RocketMQ&quot;</code></td>\n<td style=\"text-align:left\">实际消息内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">不指定则用默认配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--broker</code></td>\n<td style=\"text-align:left\">指定发送到哪个 broker</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">一般用于测试 Broker 状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--qid</code></td>\n<td style=\"text-align:left\">指定发送到的队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">一般不需要设置，RocketMQ 会自动选择</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--tags</code></td>\n<td style=\"text-align:left\">消息的标签（tag）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>testTag</code></td>\n<td style=\"text-align:left\">用于消息过滤</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k</code></td>\n<td style=\"text-align:left\"><code>--key</code></td>\n<td style=\"text-align:left\">消息的业务键（key）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>order123</code></td>\n<td style=\"text-align:left\">可用于追踪消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--msgTraceEnable</code></td>\n<td style=\"text-align:left\">是否开启消息轨迹</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">默认 <code>false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送消息</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Send Result            #MsgId</span></span><br><span class=\"line\">broker-b                          2     SEND_OK                 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\"><span class=\"comment\">## 输出解释</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name: Broker 名称</span></span><br><span class=\"line\"><span class=\"comment\">#QID: 队列 ID</span></span><br><span class=\"line\"><span class=\"comment\">#Send Result: 发送结果，SEND_OK 表示成功</span></span><br><span class=\"line\"><span class=\"comment\">#MsgId: 消息 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 tags、key</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span> -c testTag -k order123</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费消息\">消费消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议填写以避免默认配置不生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">可指定消费组（影响消费位点）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerName</code></td>\n<td style=\"text-align:left\">Broker 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">指定从哪个 broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--queueId</code></td>\n<td style=\"text-align:left\">队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">默认从 0 号队列开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--offset</code></td>\n<td style=\"text-align:left\">队列起始偏移量（offset）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">指定从哪个位置开始消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--MessageNumber</code></td>\n<td style=\"text-align:left\">消费消息数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10</code></td>\n<td style=\"text-align:left\">默认通常为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--beginTimestamp</code></td>\n<td style=\"text-align:left\">起始时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#10:00:00:000</code></td>\n<td style=\"text-align:left\">格式或时间戳均可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e</code></td>\n<td style=\"text-align:left\"><code>--endTimestamp</code></td>\n<td style=\"text-align:left\">结束时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#12:00:00:000</code></td>\n<td style=\"text-align:left\">与 <code>-s</code> 一起使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认从队列 0 开始消费，拉取全部消息</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic</span><br><span class=\"line\"><span class=\"comment\"># 拉取指定条数的消息，-c 指定拉取条数</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10</span><br><span class=\"line\"><span class=\"comment\"># 指定偏移量，此时必须同时指定 brokerName、queueId、offset</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3</span><br><span class=\"line\"><span class=\"comment\"># 指定消费者组</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup</span><br><span class=\"line\"><span class=\"comment\"># 指定时间范围</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000</span><br></pre></td></tr></table></figure>\n<h4 id=\"消费结果\">消费结果</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consume ok</span><br><span class=\"line\">MSGID: 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0,</span><br><span class=\"line\">  bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362,</span><br><span class=\"line\">  storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011,</span><br><span class=\"line\">  msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881,</span><br><span class=\"line\">  bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0,</span><br><span class=\"line\">  toString()=Message&#123;topic=<span class=\"string\">&#x27;TestTopic&#x27;</span>, flag=0,</span><br><span class=\"line\">    properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000,</span><br><span class=\"line\">      CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>, MAX_OFFSET=1&#125;,</span><br><span class=\"line\">    body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81],</span><br><span class=\"line\">    transactionId=<span class=\"string\">&#x27;null&#x27;</span>&#125;]</span><br><span class=\"line\">BODY: Hello RocketMQ</span><br><span class=\"line\"></span><br><span class=\"line\">MessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] <span class=\"built_in\">print</span> msg finished. status=NO_NEW_MSG, offset=1</span><br><span class=\"line\">The older -1 message of the 2 queue will be provided</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📘 字段解析表格</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>MSGID</strong></td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">消息唯一标识（客户端生成）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>brokerName</strong></td>\n<td style=\"text-align:left\"><code>broker-b</code></td>\n<td style=\"text-align:left\">消息存储在哪个 Broker 上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueId</strong></td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">存储的队列编号（TestTopic 有多个队列时的第 3 个）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">队列中的偏移量（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeSize</strong></td>\n<td style=\"text-align:left\"><code>228</code></td>\n<td style=\"text-align:left\">消息在磁盘中的存储字节大小</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>sysFlag</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">消息系统标志位（内部用途）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706671</code></td>\n<td style=\"text-align:left\">消息在生产者端创建的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者客户端的 IP 和端口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706691</code></td>\n<td style=\"text-align:left\">消息被 Broker 存储的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">Broker 的存储节点地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>msgId</strong></td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">消息在 Broker 存储系统生成的唯一 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>commitLogOffset</strong></td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">消息在 commitLog 文件中的偏移量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bodyCRC</strong></td>\n<td style=\"text-align:left\"><code>1774740973</code></td>\n<td style=\"text-align:left\">消息体的 CRC 校验码（用于校验数据一致性）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>reconsumeTimes</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">被重新消费的次数（0 表示第一次消费）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>preparedTransactionOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">如果是事务消息，这里会记录预提交偏移量；普通消息为 0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>topic</strong></td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>properties</strong></td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125;</code></td>\n<td style=\"text-align:left\">消息属性，包括系统属性与用户属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>body</strong></td>\n<td style=\"text-align:left\"><code>[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81]</code></td>\n<td style=\"text-align:left\">消息体的字节数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BODY（解码后）</strong></td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">实际消息内容（UTF-8 字符串）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚙️ 消息状态说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">输出信息</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>Consume ok</code></td>\n<td style=\"text-align:left\">表示成功从 Broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>status=NO_NEW_MSG</code></td>\n<td style=\"text-align:left\">当前队列（queueId=2）中已经没有比 offset=1 更新的消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>offset=1</code></td>\n<td style=\"text-align:left\">当前队列消费到 offset=1（下次消费从此开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>The older -1 message of the 2 queue will be provided</code></td>\n<td style=\"text-align:left\">这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查询消息\">查询消息</h3>\n<h4 id=\"根据消息-ID-查询消息-queryMsgById\">根据消息 ID 查询消息(queryMsgById)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--msgId</code></td>\n<td style=\"text-align:left\">要查询的消息 ID</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">必填，用于精确定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--cluster</code></td>\n<td style=\"text-align:left\">集群名称或 LMQ 父 Topic</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">在多集群场景下使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">当用于消费者关联查询时可指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--clientId</code></td>\n<td style=\"text-align:left\">消费者客户端 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>192.168.0.1@12345</code></td>\n<td style=\"text-align:left\">辅助定位消费实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-f</code></td>\n<td style=\"text-align:left\"><code>--bodyFormat</code></td>\n<td style=\"text-align:left\">消息体输出格式</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>UTF-8</code> / <code>HEX</code> / <code>BASE64</code></td>\n<td style=\"text-align:left\">默认 UTF-8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--sendMessage</code></td>\n<td style=\"text-align:left\">是否重新发送消息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">调试时可使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unitName</code></td>\n<td style=\"text-align:left\">单元名（多单元部署时使用）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>unit01</code></td>\n<td style=\"text-align:left\">一般场景可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">OffsetID:            0AFA00BC00002B0300000000000CA1E9</span><br><span class=\"line\">Topic:               TestTopic</span><br><span class=\"line\">Tags:                [null]</span><br><span class=\"line\">Keys:                [null]</span><br><span class=\"line\">Queue ID:            2</span><br><span class=\"line\">Queue Offset:        0</span><br><span class=\"line\">CommitLog Offset:    827881</span><br><span class=\"line\">Reconsume Times:     0</span><br><span class=\"line\">Born Timestamp:      2025-10-28 08:05:06,671</span><br><span class=\"line\">Store Timestamp:     2025-10-28 08:05:06,691</span><br><span class=\"line\">Born Host:           10.250.0.175:41362</span><br><span class=\"line\">Store Host:          10.250.0.188:11011</span><br><span class=\"line\">System Flag:         0</span><br><span class=\"line\">Properties:          &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">Message Body Path:   /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">Message Body:        Hello RocketMQ</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>输出字段详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段名</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>OffsetID</strong></td>\n<td style=\"text-align:left\">消息在 CommitLog 中的偏移标识（内部定位使用）</td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">可用于 broker 内部追踪定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Topic</strong></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属的主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Tags</strong></td>\n<td style=\"text-align:left\">消息标签</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">若生产消息时未设置 tag，则为 null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Keys</strong></td>\n<td style=\"text-align:left\">消息键</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">通常可用于业务层索引查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue ID</strong></td>\n<td style=\"text-align:left\">消息所在的队列编号</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">对应 topic 的第 3 个队列（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue Offset</strong></td>\n<td style=\"text-align:left\">队列偏移量</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示是该队列的第一条消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>CommitLog Offset</strong></td>\n<td style=\"text-align:left\">消息在 commitlog 文件中的偏移量</td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">broker 存储层位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Reconsume Times</strong></td>\n<td style=\"text-align:left\">被重新消费的次数</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示未重试消费过</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Timestamp</strong></td>\n<td style=\"text-align:left\">消息生成时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,671</code></td>\n<td style=\"text-align:left\">生产者发送消息的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Timestamp</strong></td>\n<td style=\"text-align:left\">消息存储时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,691</code></td>\n<td style=\"text-align:left\">broker 写入消息的时间（通常相差几毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Host</strong></td>\n<td style=\"text-align:left\">生产者客户端 IP:端口</td>\n<td style=\"text-align:left\"><code>10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者所在机器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Host</strong></td>\n<td style=\"text-align:left\">broker 存储该消息的地址</td>\n<td style=\"text-align:left\"><code>10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">对应的 broker 服务端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>System Flag</strong></td>\n<td style=\"text-align:left\">系统标志位</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用（标识压缩/事务等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Properties</strong></td>\n<td style=\"text-align:left\">消息属性</td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;</code></td>\n<td style=\"text-align:left\">包含 RocketMQ 自动附加的元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body Path</strong></td>\n<td style=\"text-align:left\">消息体在本地保存的文件路径</td>\n<td style=\"text-align:left\"><code>/tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body</strong></td>\n<td style=\"text-align:left\">消息内容</td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">消息内容</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"根据消息-Key-查询消息-queryMsgByKey\">根据消息 Key 查询消息(queryMsgByKey)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t, --topic</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">要查询的主题名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k, --msgKey</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>order_10001</code></td>\n<td style=\"text-align:left\">发送消息时设置的业务 Key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n, --namesrvAddr</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c, --cluster</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">指定集群名称（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b, --beginTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730083200000</code></td>\n<td style=\"text-align:left\">查询起始时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e, --endTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730173200000</code></td>\n<td style=\"text-align:left\">查询结束时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m, --maxNum</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>64</code></td>\n<td style=\"text-align:left\">返回的最大消息数，默认 64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h, --help</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123</span><br><span class=\"line\"><span class=\"comment\">## 查询结果</span></span><br><span class=\"line\"><span class=\"comment\">#Message ID                                        #QID                                  #Offset</span></span><br><span class=\"line\">0AFA00AFCF781EB44E468CC902A30000                      7                                        1</span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者\">消费者</h2>\n<h4 id=\"创建或更新消费者订阅组-updateSubGroup\">创建或更新消费者订阅组(updateSubGroup)</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">消费顺序（顺序/并发）</li>\n<li class=\"lvl-6\">广播模式</li>\n<li class=\"lvl-6\">消费使能</li>\n<li class=\"lvl-6\">消费重试策略</li>\n<li class=\"lvl-6\">延迟消费队列等</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--groupName</code></td>\n<td style=\"text-align:left\">消费者组名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestConsumerGroup</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定 Broker 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10.250.0.188:10911</code></td>\n<td style=\"text-align:left\">仅对单 Broker 更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定 Cluster 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">对整个集群更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--consumeBroadcastEnable</code></td>\n<td style=\"text-align:left\">是否广播消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">true 表示广播，false 表示集群模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--consumeMessageOrderly</code></td>\n<td style=\"text-align:left\">是否顺序消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">顺序消费只在同队列中生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--brokerId</code></td>\n<td style=\"text-align:left\">从哪个 Broker 获取订阅信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部用途，通常不用设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--consumeFromMinEnable</code></td>\n<td style=\"text-align:left\">是否从最小 offset 消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">新组首次消费时生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--groupRetryPolicy</code></td>\n<td style=\"text-align:left\">消费组重试策略 JSON</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;</code></td>\n<td style=\"text-align:left\">可以自定义重试间隔</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-q</code></td>\n<td style=\"text-align:left\"><code>--retryQueueNums</code></td>\n<td style=\"text-align:left\">重试队列数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1</code> ~ <code>16</code></td>\n<td style=\"text-align:left\">默认为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--retryMaxTimes</code></td>\n<td style=\"text-align:left\">最大重试次数</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>16</code></td>\n<td style=\"text-align:left\">默认 16 次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--consumeEnable</code></td>\n<td style=\"text-align:left\">是否使能消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">false 表示暂停消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--whichBrokerWhenConsumeSlowly</code></td>\n<td style=\"text-align:left\">慢消费选择 Broker ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--notifyConsumerIdsChanged</code></td>\n<td style=\"text-align:left\">通知 ConsumerId 改变</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可触发消费者刷新订阅信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">其他自定义属性</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>attr1=val1,attr2=val2</code></td>\n<td style=\"text-align:left\">可设置自定义配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">显示命令帮助</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建普通消费者组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 创建顺序消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建广播消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建自定义属性的消费者组，这里配置了重试策略</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d <span class=\"literal\">true</span> -o <span class=\"literal\">true</span> -m <span class=\"literal\">true</span> -p <span class=\"string\">&#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27;</span> -q 1 -r 16 -s <span class=\"literal\">true</span> -w 0 -a <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"删除消费者订阅组-deleteSubGroup\">删除消费者订阅组(deleteSubGroup)</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要说明\">重要说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ Admin Tool 简介 RocketMQ Admin Tool 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。 Topic 相关命令 创建或更新 Topic 参数 全称 说明 可选值 / 格式 是否必填 示例 -t --topic 主题名称 字符串 ✅ 必填 -t MyTopic -b --brokerAddr 指定创建 Topic 的 Broker 地址（与 -c 二选一） ip:port ✅ 必填（与 -c 二选一） -b 192.168.1.10:10911 -c --clusterName 指定创建 Topic 的集群名（与 -b 二选一） 字符串 ✅ 必填（与 -b 二选一） -c DefaultCluster -n --namesrvAddr NameServer 地址列表 多个地址用 ; 分隔 可选 -n 192.168.1.1:9876;192.168.1.2:9876 -r --readQueueNums 读队列数量，默认为8，始终保持 r == w 整数 可选 -r 4 -w --writeQueueNums 写队列数量，默认为8，始终保持 r == w 整数 可选 -w 4 -p --perm Topic 权限，默认为6 2：写（W）4：读（R）6：读写（RW） 可选 -p 6 -o --order 是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO” true / false 可选 -o false -u --unit 是否为单元（Unit）Topic（用于多租户隔离） true / false 可选 -u false -s --hasUnitSub 是否有 Unit 订阅 true / false 可选 -s false -a --attributes 额外属性设置，用 + 表示添加、- 表示删除 例：+a=b,+c=d,-e 可选 -a &quot;+message.type=NORMAL&quot; -h --help 打印帮助信息 无 否 -h 示例 12345678910# 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topicsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster# 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic# 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMALsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a &quot;+message.type=NORMAL&quot;# 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a &quot;+message.type=FIFO&quot;# 指定权限，默认为 6：读写sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6 查看与删除 Topic 1234567# 查看所有 Topic，此时只打印 topic 列表sh bin/mqadmin topicList -n 127.0.0.1:9876# 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Groupsh bin/mqadmin topicList -n 127.0.0.1:9876 -c# 删除 Topic，删除指定集群下的指定Topicsh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster 其它 Topic 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 查看 Topic 路由信息sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic## 输出&#123; &quot;brokerDatas&quot;:[ &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.188:11011&quot;,1:&quot;10.250.0.31:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125;, &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.31:11011&quot;,1:&quot;10.250.0.188:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125; ], &quot;filterServerTable&quot;:&#123;&#125;, &quot;queueDatas&quot;:[ &#123; &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125;, &#123; &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125; ]&#125;# 查看 Topic 消息队列offsetsh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic## 输出#Broker Name #QID #Min Offset #Max Offset #Last Updatedbroker-a 0 0 3 2025-10-27 03:08:43,112broker-a 1 0 4 2025-10-27 06:13:21,968broker-a 2 0 2 2025-10-27 06:13:34,685broker-a 3 0 2 2025-10-26 05:44:17,222broker-a 4 0 1 2025-10-26 05:44:45,513broker-a 5 0 1 2025-10-26 06:13:10,541broker-a 6 0 2 2025-10-26 02:58:34,393broker-a 7 0 1 2025-10-25 12:42:41,189broker-b 0 0 1 2025-10-25 14:01:24,836broker-b 1 0 2 2025-10-26 06:14:24,411broker-b 2 0 0broker-b 3 0 0broker-b 4 0 0broker-b 5 0 1 2025-10-25 12:30:57,672broker-b 6 0 1 2025-10-26 06:19:47,051broker-b 7 0 1 2025-10-26 06:14:49,216 集群相关命令 查看集群信息，集群、BrokerName、BrokerId、TPS等信息 123456789101112131415161718# 集群信息sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster## 输出#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 2.60(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.03 0.3300 trueDefaultCluster broker-a 1 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 67.03 0.3200 falseDefaultCluster broker-b 0 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.80(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3200 trueDefaultCluster broker-b 1 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3300 false## Broker 统计信息#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好#Hour: 表示 Broker 已运行的时长#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master 查看集群统计信息 123456789101112sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m## 输出#Cluster Name #Broker Name #InTotalYest #OutTotalYest #InTotalToday #OutTotalTodayDefaultCluster broker-a 0 0 0 0DefaultCluster broker-a 0 0 0 0DefaultCluster broker-b 0 369 0 0DefaultCluster broker-b 0 0 0 0## Broker 统计信息#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数 消息相关 发送消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 消息要发送的 Topic 名称 ✅ TestTopic 必须指定目标 Topic -p --body 消息体内容（UTF-8 字符串） ✅ &quot;Hello RocketMQ&quot; 实际消息内容 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 不指定则用默认配置 -b --broker 指定发送到哪个 broker ❌ broker-a 一般用于测试 Broker 状态 -i --qid 指定发送到的队列 ID ❌ 2 一般不需要设置，RocketMQ 会自动选择 -c --tags 消息的标签（tag） ❌ testTag 用于消息过滤 -k --key 消息的业务键（key） ❌ order123 可用于追踪消息 -m --msgTraceEnable 是否开启消息轨迹 ❌ true 默认 false -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 1234567891011121314# 发送消息sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot;## 输出#Broker Name #QID #Send Result #MsgIdbroker-b 2 SEND_OK 0AFA00AFCF171EB44E468CC7D5EE0000## 输出解释#Broker Name: Broker 名称#QID: 队列 ID#Send Result: 发送结果，SEND_OK 表示成功#MsgId: 消息 ID# 指定 tags、keysh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot; -c testTag -k order123 消费消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议填写以避免默认配置不生效 -g --consumerGroup 消费组名称 ❌ TestGroup 可指定消费组（影响消费位点） -b --brokerName Broker 名称 ❌ broker-a 指定从哪个 broker 拉取消息 -i --queueId 队列 ID ❌ 0 默认从 0 号队列开始 -o --offset 队列起始偏移量（offset） ❌ 0 指定从哪个位置开始消费 -c --MessageNumber 消费消息数量 ❌ 10 默认通常为 1 -s --beginTimestamp 起始时间 ❌ 2025-10-28#10:00:00:000 格式或时间戳均可 -e --endTimestamp 结束时间 ❌ 2025-10-28#12:00:00:000 与 -s 一起使用 -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 12345678910# 默认从队列 0 开始消费，拉取全部消息sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic# 拉取指定条数的消息，-c 指定拉取条数sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10# 指定偏移量，此时必须同时指定 brokerName、queueId、offsetsh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3# 指定消费者组sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup# 指定时间范围sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000 消费结果 12345678910111213141516Consume okMSGID: 0AFA00AFCF171EB44E468CC7D5EE0000MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0, bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362, storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011, msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881, bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TestTopic&#x27;, flag=0, properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=true, TRACE_ON=true, MAX_OFFSET=1&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81], transactionId=&#x27;null&#x27;&#125;]BODY: Hello RocketMQMessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] print msg finished. status=NO_NEW_MSG, offset=1The older -1 message of the 2 queue will be provided 📘 字段解析表格 字段 示例值 说明 MSGID 0AFA00AFCF171EB44E468CC7D5EE0000 消息唯一标识（客户端生成） brokerName broker-b 消息存储在哪个 Broker 上 queueId 2 存储的队列编号（TestTopic 有多个队列时的第 3 个） queueOffset 0 队列中的偏移量（从 0 开始） storeSize 228 消息在磁盘中的存储字节大小 sysFlag 0 消息系统标志位（内部用途） bornTimestamp 1761638706671 消息在生产者端创建的时间（毫秒） bornHost /10.250.0.175:41362 生产者客户端的 IP 和端口 storeTimestamp 1761638706691 消息被 Broker 存储的时间（毫秒） storeHost /10.250.0.188:11011 Broker 的存储节点地址 msgId 0AFA00BC00002B0300000000000CA1E9 消息在 Broker 存储系统生成的唯一 ID commitLogOffset 827881 消息在 commitLog 文件中的偏移量 bodyCRC 1774740973 消息体的 CRC 校验码（用于校验数据一致性） reconsumeTimes 0 被重新消费的次数（0 表示第一次消费） preparedTransactionOffset 0 如果是事务消息，这里会记录预提交偏移量；普通消息为 0 topic TestTopic 消息所属主题 properties &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125; 消息属性，包括系统属性与用户属性 body [72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81] 消息体的字节数组 BODY（解码后） Hello RocketMQ 实际消息内容（UTF-8 字符串） ⚙️ 消息状态说明 输出信息 含义 Consume ok 表示成功从 Broker 拉取消息 status=NO_NEW_MSG 当前队列（queueId=2）中已经没有比 offset=1 更新的消息 offset=1 当前队列消费到 offset=1（下次消费从此开始） The older -1 message of the 2 queue will be provided 这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息） 查询消息 根据消息 ID 查询消息(queryMsgById) 参数 全写 说明 是否必填 示例值 备注 -i --msgId 要查询的消息 ID ✅ 0AFA00AFCF171EB44E468CC7D5EE0000 必填，用于精确定位消息 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -c --cluster 集群名称或 LMQ 父 Topic ❌ DefaultCluster 在多集群场景下使用 -g --consumerGroup 消费组名称 ❌ TestGroup 当用于消费者关联查询时可指定 -d --clientId 消费者客户端 ID ❌ 192.168.0.1@12345 辅助定位消费实例 -f --bodyFormat 消息体输出格式 ❌ UTF-8 / HEX / BASE64 默认 UTF-8 -s --sendMessage 是否重新发送消息 ❌ true 调试时可使用 -u --unitName 单元名（多单元部署时使用） ❌ unit01 一般场景可忽略 -h --help 打印帮助信息 ❌ 无 显示命令说明 示例 123456789101112131415161718sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8## 输出OffsetID: 0AFA00BC00002B0300000000000CA1E9Topic: TestTopicTags: [null]Keys: [null]Queue ID: 2Queue Offset: 0CommitLog Offset: 827881Reconsume Times: 0Born Timestamp: 2025-10-28 08:05:06,671Store Timestamp: 2025-10-28 08:05:06,691Born Host: 10.250.0.175:41362Store Host: 10.250.0.188:11011System Flag: 0Properties: &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;Message Body Path: /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000Message Body: Hello RocketMQ 输出字段详解 字段名 含义 示例 说明 OffsetID 消息在 CommitLog 中的偏移标识（内部定位使用） 0AFA00BC00002B0300000000000CA1E9 可用于 broker 内部追踪定位消息 Topic 主题名称 TestTopic 消息所属的主题 Tags 消息标签 [null] 若生产消息时未设置 tag，则为 null Keys 消息键 [null] 通常可用于业务层索引查询 Queue ID 消息所在的队列编号 2 对应 topic 的第 3 个队列（从 0 开始） Queue Offset 队列偏移量 0 表示是该队列的第一条消息 CommitLog Offset 消息在 commitlog 文件中的偏移量 827881 broker 存储层位置 Reconsume Times 被重新消费的次数 0 表示未重试消费过 Born Timestamp 消息生成时间 2025-10-28 08:05:06,671 生产者发送消息的时间 Store Timestamp 消息存储时间 2025-10-28 08:05:06,691 broker 写入消息的时间（通常相差几毫秒） Born Host 生产者客户端 IP:端口 10.250.0.175:41362 生产者所在机器 Store Host broker 存储该消息的地址 10.250.0.188:11011 对应的 broker 服务端 System Flag 系统标志位 0 内部使用（标识压缩/事务等） Properties 消息属性 &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125; 包含 RocketMQ 自动附加的元数据 Message Body Path 消息体在本地保存的文件路径 /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000 RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看 Message Body 消息内容 Hello RocketMQ 消息内容 根据消息 Key 查询消息(queryMsgByKey) 参数 必填 示例 说明 -t, --topic ✅ TestTopic 要查询的主题名称 -k, --msgKey ✅ order_10001 发送消息时设置的业务 Key -n, --namesrvAddr ❌ 127.0.0.1:9876 NameServer 地址 -c, --cluster ❌ DefaultCluster 指定集群名称（可选） -b, --beginTimestamp ❌ 1730083200000 查询起始时间戳（ms） -e, --endTimestamp ❌ 1730173200000 查询结束时间戳（ms） -m, --maxNum ❌ 64 返回的最大消息数，默认 64 -h, --help ❌ - 打印帮助信息 示例 1234sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123## 查询结果#Message ID #QID #Offset0AFA00AFCF781EB44E468CC902A30000 7 1 消费者 创建或更新消费者订阅组(updateSubGroup) 消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如： 消费顺序（顺序/并发） 广播模式 消费使能 消费重试策略 延迟消费队列等 参数 全写 说明 是否必填 示例值 备注 -g --groupName 消费者组名称 ✅ TestConsumerGroup 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -b --brokerAddr 指定 Broker 地址 ❌ 10.250.0.188:10911 仅对单 Broker 更新 -c --clusterName 指定 Cluster 名称 ❌ DefaultCluster 对整个集群更新 -d --consumeBroadcastEnable 是否广播消费 ❌ true / false true 表示广播，false 表示集群模式 -o --consumeMessageOrderly 是否顺序消费 ❌ true / false 顺序消费只在同队列中生效 -i --brokerId 从哪个 Broker 获取订阅信息 ❌ 0 内部用途，通常不用设置 -m --consumeFromMinEnable 是否从最小 offset 消费 ❌ true / false 新组首次消费时生效 -p --groupRetryPolicy 消费组重试策略 JSON ❌ &#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125; 可以自定义重试间隔 -q --retryQueueNums 重试队列数量 ❌ 1 ~ 16 默认为 1 -r --retryMaxTimes 最大重试次数 ❌ 16 默认 16 次 -s --consumeEnable 是否使能消费 ❌ true / false false 表示暂停消费 -w --whichBrokerWhenConsumeSlowly 慢消费选择 Broker ID ❌ 0 内部使用 -a --notifyConsumerIdsChanged 通知 ConsumerId 改变 ❌ true / false 可触发消费者刷新订阅信息 --attributes --attributes 其他自定义属性 ❌ attr1=val1,attr2=val2 可设置自定义配置 -h --help 打印帮助 ❌ - 显示命令帮助 示例 12345678910# 创建普通消费者组sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876# 创建顺序消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o true# 创建广播消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d true# 创建自定义属性的消费者组，这里配置了重试策略sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d true -o true -m true -p &#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27; -q 1 -r 16 -s true -w 0 -a true 删除消费者订阅组(deleteSubGroup) 1sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster 重要说明 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567","summary":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","title":"RocketMQ Proxy 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Proxy 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外在源码 <code>rocketmq-all-5.3.2-source-release/proxy</code> 的启动类 <code>org.apache.rocketmq.proxy.ProxyStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.rocketmq.proxy.config.ProxyConfig</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">优化建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础信息</strong></td>\n<td style=\"text-align:left\"><code>rocketMQClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Broker 集群名称（Proxy 用于关联 RocketMQ 集群）</td>\n<td style=\"text-align:left\">若有多个集群，应唯一命名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Proxy 所属集群名称（与 brokerClusterName 可不同）</td>\n<td style=\"text-align:left\">✅建议独立命名，区分 Proxy 集群</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyName</code></td>\n<td style=\"text-align:left\">主机名（例：<code>ip-10-250-0-175...</code>）</td>\n<td style=\"text-align:left\">Proxy 实例名称，用于唯一标识</td>\n<td style=\"text-align:left\">✅建议设置唯一名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>localServeAddr</code></td>\n<td style=\"text-align:left\">本地 IP</td>\n<td style=\"text-align:left\">Proxy 本地服务地址（Remoting 通信使用）</td>\n<td style=\"text-align:left\">✅建议显式指定 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Namesrv</strong></td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\">多个地址（分号分隔）</td>\n<td style=\"text-align:left\">NameServer 地址，Proxy 通过它同步路由</td>\n<td style=\"text-align:left\">✅推荐配置为可访问的内网地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomain</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">NameServer 域名（可用于动态解析）</td>\n<td style=\"text-align:left\">可选，DNS 方式时使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomainSubgroup</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">子域分组（多集群域名发现用）</td>\n<td style=\"text-align:left\">一般可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TLS 配置</strong></td>\n<td style=\"text-align:left\"><code>tlsTestModeEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">测试模式下跳过验证（仅用于本地测试）</td>\n<td style=\"text-align:left\">❗生产应设为 false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsKeyPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.key</code></td>\n<td style=\"text-align:left\">TLS 私钥路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsCertPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.crt</code></td>\n<td style=\"text-align:left\">TLS 证书路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>gRPC 基础</strong></td>\n<td style=\"text-align:left\"><code>proxyMode</code></td>\n<td style=\"text-align:left\"><code>CLUSTER</code></td>\n<td style=\"text-align:left\">Proxy 模式：CLUSTER / LOCAL / REMOTING</td>\n<td style=\"text-align:left\">✅生产推荐 CLUSTER</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcServerPort</code></td>\n<td style=\"text-align:left\">8081</td>\n<td style=\"text-align:left\">gRPC 服务端监听端口</td>\n<td style=\"text-align:left\">若冲突可修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcShutdownTimeSeconds</code></td>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\">优雅关闭等待时间</td>\n<td style=\"text-align:left\">可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableGrpcEpoll</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用 Linux epoll I/O 模型</td>\n<td style=\"text-align:left\">✅Linux 建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcMaxInboundMessageSize</code></td>\n<td style=\"text-align:left\">136314880 (~130MB)</td>\n<td style=\"text-align:left\">最大入站消息大小</td>\n<td style=\"text-align:left\">根据消息大小调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息限制</strong></td>\n<td style=\"text-align:left\"><code>maxMessageSize</code></td>\n<td style=\"text-align:left\">4194304 (4MB)</td>\n<td style=\"text-align:left\">最大消息体大小</td>\n<td style=\"text-align:left\">✅应与 Broker 一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableMessageBodyEmptyCheck</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">校验消息体是否为空</td>\n<td style=\"text-align:left\">保持默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxUserPropertySize</code></td>\n<td style=\"text-align:left\">16384 (16KB)</td>\n<td style=\"text-align:left\">用户属性最大长度</td>\n<td style=\"text-align:left\">根据业务复杂度调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>userPropertyMaxNum</code></td>\n<td style=\"text-align:left\">128</td>\n<td style=\"text-align:left\">单条消息最大属性数量</td>\n<td style=\"text-align:left\">可适当调低防止性能损耗</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxMessageGroupSize</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">最大消息组大小（批量 pop 使用）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息可见性与延迟</strong></td>\n<td style=\"text-align:left\"><code>defaultInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">60000 (60s)</td>\n<td style=\"text-align:left\">pop 消息默认不可见时间</td>\n<td style=\"text-align:left\">✅高并发时可调低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">43200000 (12h)</td>\n<td style=\"text-align:left\">最大不可见时长</td>\n<td style=\"text-align:left\">✅可根据业务降低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxDelayTimeMills</code></td>\n<td style=\"text-align:left\">86400000 (1d)</td>\n<td style=\"text-align:left\">最大延迟时间</td>\n<td style=\"text-align:left\">与 Broker 保持一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useDelayLevel</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否使用延迟等级模式</td>\n<td style=\"text-align:left\">若 Broker 启用等级延迟则开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>messageDelayLevel</code></td>\n<td style=\"text-align:left\"><code>&quot;1s 5s 10s ... 2h&quot;</code></td>\n<td style=\"text-align:left\">延迟等级配置表</td>\n<td style=\"text-align:left\">✅需与 broker.conf 对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（gRPC 模块）</strong></td>\n<td style=\"text-align:left\"><code>grpcBossLoopNum</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">Netty boss 线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcWorkerLoopNum</code></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">gRPC worker 线程</td>\n<td style=\"text-align:left\">✅CPU&gt;4 时可调高至核数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">gRPC 业务线程数</td>\n<td style=\"text-align:left\">✅建议 ≈ CPU 核数×2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolQueueCapacity</code></td>\n<td style=\"text-align:left\">100000</td>\n<td style=\"text-align:left\">队列容量</td>\n<td style=\"text-align:left\">⚠️建议 ≤20000，防 OOM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（内部模块）</strong></td>\n<td style=\"text-align:left\"><code>producerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">生产者处理线程</td>\n<td style=\"text-align:left\">✅可根据QPS调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>consumerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">消费者处理线程</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicRouteServiceThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">路由服务线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>renewThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">自动续期线程</td>\n<td style=\"text-align:left\">高并发时可调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>缓存配置</strong></td>\n<td style=\"text-align:left\"><code>topicRouteServiceCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">路由缓存有效期</td>\n<td style=\"text-align:left\">✅可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">Topic 配置缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>subscriptionGroupConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">订阅组缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>aclCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">ACL 缓存有效期</td>\n<td style=\"text-align:left\">✅同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>事务与心跳</strong></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳线程数</td>\n<td style=\"text-align:left\">✅根据事务量调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatPeriodSecond</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳周期</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionDataExpireMillis</code></td>\n<td style=\"text-align:left\">30000</td>\n<td style=\"text-align:left\">事务数据过期时间</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>指标与监控</strong></td>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">DISABLE</td>\n<td style=\"text-align:left\">指标导出方式：DISABLE / PROM / GRPC / LOG</td>\n<td style=\"text-align:left\">✅建议启用 PROM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">Prometheus 导出端口</td>\n<td style=\"text-align:left\">✅建议暴露监控</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsInDelta</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否按增量导出指标</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Remoting 模式</strong></td>\n<td style=\"text-align:left\"><code>enableRemotingLocalProxyGrpc</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">启用本地 Proxy gRPC 转发</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>remotingListenPort</code></td>\n<td style=\"text-align:left\">8080</td>\n<td style=\"text-align:left\">Remoting 通信端口</td>\n<td style=\"text-align:left\">若冲突修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>sendLatencyEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用发送延迟探测（LoadBalance 优化）</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>startDetectorEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用启动探测功能</td>\n<td style=\"text-align:left\">可选，测试阶段使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可观测性</strong></td>\n<td style=\"text-align:left\"><code>traceOn</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用链路追踪</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enablePrintJstack</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">打印线程堆栈（用于诊断）</td>\n<td style=\"text-align:left\">✅可延长周期减少日志</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>综合优化建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方向</th>\n<th style=\"text-align:left\">建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>性能调优</strong></td>\n<td style=\"text-align:left\">启用 <code>enableGrpcEpoll=true</code>；合理配置线程池（如减少队列长度）；设置合适的 <code>grpcThreadPoolNums</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可靠性</strong></td>\n<td style=\"text-align:left\">开启 <code>traceOn</code> 与 <code>sendLatencyEnable</code> 监控；使用 Prometheus 指标导出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全性</strong></td>\n<td style=\"text-align:left\">禁用 <code>tlsTestModeEnable</code>，使用真实 TLS 证书。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>资源管理</strong></td>\n<td style=\"text-align:left\">限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可维护性</strong></td>\n<td style=\"text-align:left\">使用独立的 <code>proxyClusterName</code>，并在配置文件 <code>rmq-proxy.json</code> 中明确各项端口和路径。</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 配置项项目源码简介 当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。 另外在源码 rocketmq-all-5.3.2-source-release/proxy 的启动类 org.apache.rocketmq.proxy.ProxyStartup中 可以看到其启动时会初始化如下配置项的类 1org.apache.rocketmq.proxy.config.ProxyConfig 配置项说明 Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式 分类 参数名 默认值 说明 优化建议 基础信息 rocketMQClusterName DefaultCluster Broker 集群名称（Proxy 用于关联 RocketMQ 集群） 若有多个集群，应唯一命名 proxyClusterName DefaultCluster Proxy 所属集群名称（与 brokerClusterName 可不同） ✅建议独立命名，区分 Proxy 集群 proxyName 主机名（例：ip-10-250-0-175...） Proxy 实例名称，用于唯一标识 ✅建议设置唯一名称 localServeAddr 本地 IP Proxy 本地服务地址（Remoting 通信使用） ✅建议显式指定 IP Namesrv namesrvAddr 多个地址（分号分隔） NameServer 地址，Proxy 通过它同步路由 ✅推荐配置为可访问的内网地址 namesrvDomain 空 NameServer 域名（可用于动态解析） 可选，DNS 方式时使用 namesrvDomainSubgroup 空 子域分组（多集群域名发现用） 一般可忽略 TLS 配置 tlsTestModeEnable true 测试模式下跳过验证（仅用于本地测试） ❗生产应设为 false tlsKeyPath /conf/tls/rocketmq.key TLS 私钥路径 ✅根据证书路径调整 tlsCertPath /conf/tls/rocketmq.crt TLS 证书路径 ✅根据证书路径调整 gRPC 基础 proxyMode CLUSTER Proxy 模式：CLUSTER / LOCAL / REMOTING ✅生产推荐 CLUSTER grpcServerPort 8081 gRPC 服务端监听端口 若冲突可修改 grpcShutdownTimeSeconds 30 优雅关闭等待时间 可适当调大 enableGrpcEpoll false 启用 Linux epoll I/O 模型 ✅Linux 建议开启 grpcMaxInboundMessageSize 136314880 (~130MB) 最大入站消息大小 根据消息大小调整 消息限制 maxMessageSize 4194304 (4MB) 最大消息体大小 ✅应与 Broker 一致 enableMessageBodyEmptyCheck true 校验消息体是否为空 保持默认即可 maxUserPropertySize 16384 (16KB) 用户属性最大长度 根据业务复杂度调整 userPropertyMaxNum 128 单条消息最大属性数量 可适当调低防止性能损耗 maxMessageGroupSize 64 最大消息组大小（批量 pop 使用） 默认即可 消息可见性与延迟 defaultInvisibleTimeMills 60000 (60s) pop 消息默认不可见时间 ✅高并发时可调低 maxInvisibleTimeMills 43200000 (12h) 最大不可见时长 ✅可根据业务降低 maxDelayTimeMills 86400000 (1d) 最大延迟时间 与 Broker 保持一致 useDelayLevel false 是否使用延迟等级模式 若 Broker 启用等级延迟则开启 messageDelayLevel &quot;1s 5s 10s ... 2h&quot; 延迟等级配置表 ✅需与 broker.conf 对齐 线程池（gRPC 模块） grpcBossLoopNum 1 Netty boss 线程 默认即可 grpcWorkerLoopNum 4 gRPC worker 线程 ✅CPU&gt;4 时可调高至核数 grpcThreadPoolNums 20 gRPC 业务线程数 ✅建议 ≈ CPU 核数×2 grpcThreadPoolQueueCapacity 100000 队列容量 ⚠️建议 ≤20000，防 OOM 线程池（内部模块） producerProcessorThreadPoolNums 2 生产者处理线程 ✅可根据QPS调整 consumerProcessorThreadPoolNums 2 消费者处理线程 同上 topicRouteServiceThreadPoolNums 2 路由服务线程 默认即可 renewThreadPoolNums 2 自动续期线程 高并发时可调大 缓存配置 topicRouteServiceCacheExpiredSeconds 300 路由缓存有效期 ✅可适当调大 topicConfigCacheExpiredSeconds 300 Topic 配置缓存有效期 同上 subscriptionGroupConfigCacheExpiredSeconds 300 订阅组缓存有效期 同上 aclCacheExpiredSeconds 300 ACL 缓存有效期 ✅同上 事务与心跳 transactionHeartbeatThreadPoolNums 20 事务心跳线程数 ✅根据事务量调整 transactionHeartbeatPeriodSecond 20 事务心跳周期 默认即可 transactionDataExpireMillis 30000 事务数据过期时间 默认即可 指标与监控 metricsExporterType DISABLE 指标导出方式：DISABLE / PROM / GRPC / LOG ✅建议启用 PROM metricsPromExporterPort 5557 Prometheus 导出端口 ✅建议暴露监控 metricsInDelta false 是否按增量导出指标 默认即可 Remoting 模式 enableRemotingLocalProxyGrpc true 启用本地 Proxy gRPC 转发 默认即可 remotingListenPort 8080 Remoting 通信端口 若冲突修改 sendLatencyEnable false 启用发送延迟探测（LoadBalance 优化） ✅建议开启 startDetectorEnable false 启用启动探测功能 可选，测试阶段使用 可观测性 traceOn false 启用链路追踪 ✅建议开启 enablePrintJstack true 打印线程堆栈（用于诊断） ✅可延长周期减少日志 综合优化建议 方向 建议 性能调优 启用 enableGrpcEpoll=true；合理配置线程池（如减少队列长度）；设置合适的 grpcThreadPoolNums。 可靠性 开启 traceOn 与 sendLatencyEnable 监控；使用 Prometheus 指标导出。 安全性 禁用 tlsTestModeEnable，使用真实 TLS 证书。 资源管理 限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。 可维护性 使用独立的 proxyClusterName，并在配置文件 rmq-proxy.json 中明确各项端口和路径。","summary":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:33:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/","title":"RocketMQ Controller 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Controller 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-Controller-配置项\">查看 Controller 配置项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看全部默认配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全部默认配置项</span></span><br><span class=\"line\">sh bin/mqcontroller -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class=\"line\">sh bin/mqcontroller -p -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/controller</code> 的启动类 <code>org.apache.rocketmq.controller.ControllerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ControllerConfig</span> <span class=\"variable\">controllerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControllerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">JraftConfig</span> <span class=\"variable\">jraftConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JraftConfig</span>();</span><br><span class=\"line\">controllerConfig.setJraftConfig(jraftConfig);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyServerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyClientConfig</span>();</span><br><span class=\"line\">nettyServerConfig.setListenPort(<span class=\"number\">19876</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Controller 配置参数说明与优化建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础信息</strong></td>\n<td style=\"text-align:left\"><code>rocketmqHome</code></td>\n<td style=\"text-align:left\">/usr/local/soft/rocketmq/rocketmq5</td>\n<td style=\"text-align:left\">RocketMQ 根路径</td>\n<td style=\"text-align:left\">保持默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>configStorePath</code></td>\n<td style=\"text-align:left\">/root/controller/controller.properties</td>\n<td style=\"text-align:left\">Controller 配置文件路径</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/controller/controller.properties</code>，避免使用 <code>/root</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerType</code></td>\n<td style=\"text-align:left\">DLedger</td>\n<td style=\"text-align:left\">Controller 类型（DLedger / STANDALONE）</td>\n<td style=\"text-align:left\">✅ 建议使用 DLedger（高可用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerStorePath</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Controller 元数据存储路径</td>\n<td style=\"text-align:left\">✅ 建议 <code>/data/rocketmq/controller/store</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>DLedger 选举配置</strong></td>\n<td style=\"text-align:left\"><code>controllerDLegerGroup</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Controller 集群组名</td>\n<td style=\"text-align:left\">✅ 必填，例如：<code>controllerGroup01</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerDLegerPeers</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">集群节点列表，格式：<code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td>\n<td style=\"text-align:left\">✅ 必填（3 节点推荐）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerDLegerSelfId</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">当前节点 ID，如 <code>n0</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>mappedFileSize</code></td>\n<td style=\"text-align:left\">1073741824</td>\n<td style=\"text-align:left\">DLedger 存储文件大小 (1GB)</td>\n<td style=\"text-align:left\">可保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>electMasterMaxRetryCount</code></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Master 选举最大重试次数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableElectUncleanMaster</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否允许选举非同步 Master</td>\n<td style=\"text-align:left\">✅ 建议保持 false（避免数据丢失）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Broker 管理</strong></td>\n<td style=\"text-align:left\"><code>scanNotActiveBrokerInterval</code></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">扫描不活跃 Broker 的间隔(ms)</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>scanInactiveMasterInterval</code></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">检测失活 Master 间隔(ms)</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>notifyBrokerRoleChanged</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否通知 Broker 角色变更</td>\n<td style=\"text-align:left\">✅ 建议开启（保持同步）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>isProcessReadEvent</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否处理读事件</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程与性能</strong></td>\n<td style=\"text-align:left\"><code>controllerThreadPoolNums</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">控制线程池大小</td>\n<td style=\"text-align:left\">可调至 8–32 视规模而定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerRequestThreadPoolQueueCapacity</code></td>\n<td style=\"text-align:left\">50000</td>\n<td style=\"text-align:left\">控制线程池队列容量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Metrics 监控</strong></td>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">DISABLE</td>\n<td style=\"text-align:left\">指标输出方式（DISABLE / PROM / GRPC / LOG）</td>\n<td style=\"text-align:left\">✅ 建议设为 <code>PROM</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">Prometheus 端口</td>\n<td style=\"text-align:left\">✅ 若启用监控，可用默认 5557</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterHost</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Prometheus 绑定主机</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricLoggingExporterIntervalInMills</code></td>\n<td style=\"text-align:left\">10000</td>\n<td style=\"text-align:left\">日志输出指标间隔</td>\n<td style=\"text-align:left\">可调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsGrpcExporterTarget</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">gRPC 监控目标</td>\n<td style=\"text-align:left\">可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsInDelta</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否以增量输出指标</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>JRaft 配置（底层一致性协议）</strong></td>\n<td style=\"text-align:left\"><code>jRaftGroupId</code></td>\n<td style=\"text-align:left\">jRaft-Controller</td>\n<td style=\"text-align:left\">Raft 组名</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftServerId</code></td>\n<td style=\"text-align:left\">localhost:9880</td>\n<td style=\"text-align:left\">当前节点 ID</td>\n<td style=\"text-align:left\">✅ 修改为实际 IP，例如 <code>10.0.0.1:9880</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftInitConf</code></td>\n<td style=\"text-align:left\">localhost:9880,localhost:9881,localhost:9882</td>\n<td style=\"text-align:left\">集群配置</td>\n<td style=\"text-align:left\">✅ 修改为实际节点 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftControllerRPCAddr</code></td>\n<td style=\"text-align:left\">localhost:9770,localhost:9771,localhost:9772</td>\n<td style=\"text-align:left\">Controller RPC 地址</td>\n<td style=\"text-align:left\">✅ 修改为实际节点 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftElectionTimeoutMs</code></td>\n<td style=\"text-align:left\">1000</td>\n<td style=\"text-align:left\">选举超时（ms）</td>\n<td style=\"text-align:left\">默认即可（过低可能频繁选举）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftScanWaitTimeoutMs</code></td>\n<td style=\"text-align:left\">1000</td>\n<td style=\"text-align:left\">扫描等待超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftSnapshotIntervalSecs</code></td>\n<td style=\"text-align:left\">3600</td>\n<td style=\"text-align:left\">快照间隔时间（秒）</td>\n<td style=\"text-align:left\">✅ 可设为 600（10分钟）加快日志压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络配置</strong></td>\n<td style=\"text-align:left\"><code>bindAddress</code></td>\n<td style=\"text-align:left\">0.0.0.0</td>\n<td style=\"text-align:left\">绑定监听地址</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>listenPort</code></td>\n<td style=\"text-align:left\">19876</td>\n<td style=\"text-align:left\">Controller 服务端口</td>\n<td style=\"text-align:left\">✅ 确保未冲突</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverWorkerThreads</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">Netty 工作线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverSelectorThreads</code></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Selector 线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverSocketBacklog</code></td>\n<td style=\"text-align:left\">1024</td>\n<td style=\"text-align:left\">Socket backlog 队列</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否使用 Epoll</td>\n<td style=\"text-align:left\">✅ Linux 环境建议 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">优雅停机</td>\n<td style=\"text-align:left\">✅ 建议 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>客户端通信</strong></td>\n<td style=\"text-align:left\"><code>clientWorkerThreads</code></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">客户端工作线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>clientAsyncSemaphoreValue</code></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">异步请求信号量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>clientCloseSocketIfTimeout</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">连接超时关闭</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>connectTimeoutMillis</code></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">连接超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useTLS</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 TLS</td>\n<td style=\"text-align:left\">✅ 若生产环境有安全要求，建议启用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>其他</strong></td>\n<td style=\"text-align:left\"><code>configBlackList</code></td>\n<td style=\"text-align:left\">configBlackList;configStorePath</td>\n<td style=\"text-align:left\">配置黑名单项</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxReconnectIntervalTimeSeconds</code></td>\n<td style=\"text-align:left\">60</td>\n<td style=\"text-align:left\">最大重连间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableReconnectForGoAway</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否为 GOAWAY 连接启用重连</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">项目</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>controllerType</code></td>\n<td style=\"text-align:left\">DLedger</td>\n<td style=\"text-align:left\">高可用模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerGroup</code></td>\n<td style=\"text-align:left\">controllerGroup01</td>\n<td style=\"text-align:left\">集群分组名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerPeers</code></td>\n<td style=\"text-align:left\"><code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td>\n<td style=\"text-align:left\">三节点推荐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerSelfId</code></td>\n<td style=\"text-align:left\">n0 / n1 / n2</td>\n<td style=\"text-align:left\">对应节点 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>enableElectUncleanMaster</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止脏主选举</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>notifyBrokerRoleChanged</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">保持集群一致性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">PROM</td>\n<td style=\"text-align:left\">便于 Prometheus 监控</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">Linux 性能优化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">优雅停机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerStorePath</code></td>\n<td style=\"text-align:left\">/data/rocketmq/controller/store</td>\n<td style=\"text-align:left\">避免使用 <code>/root</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>jRaftSnapshotIntervalSecs</code></td>\n<td style=\"text-align:left\">600</td>\n<td style=\"text-align:left\">提高快照频率</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Controller 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 Controller 配置项 查看全部默认配置项 1234# 查看全部默认配置项sh bin/mqcontroller -p# 查看加载了指定配置文件后的全部配置项sh bin/mqcontroller -p -c conf/broker.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/controller 的启动类 org.apache.rocketmq.controller.ControllerStartup中 可以看到其启动时会初始化如下配置项的类 123456final ControllerConfig controllerConfig = new ControllerConfig();final JraftConfig jraftConfig = new JraftConfig();controllerConfig.setJraftConfig(jraftConfig);final NettyServerConfig nettyServerConfig = new NettyServerConfig();final NettyClientConfig nettyClientConfig = new NettyClientConfig();nettyServerConfig.setListenPort(19876); 配置项说明 Controller 配置参数说明与优化建议 分类 参数名 默认值 说明 优化 / 建议 基础信息 rocketmqHome /usr/local/soft/rocketmq/rocketmq5 RocketMQ 根路径 保持默认即可 configStorePath /root/controller/controller.properties Controller 配置文件路径 ✅ 改为 /data/rocketmq/controller/controller.properties，避免使用 /root controllerType DLedger Controller 类型（DLedger / STANDALONE） ✅ 建议使用 DLedger（高可用） controllerStorePath (空) Controller 元数据存储路径 ✅ 建议 /data/rocketmq/controller/store DLedger 选举配置 controllerDLegerGroup (空) Controller 集群组名 ✅ 必填，例如：controllerGroup01 controllerDLegerPeers (空) 集群节点列表，格式：n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876 ✅ 必填（3 节点推荐） controllerDLegerSelfId (空) 当前节点 ID，如 n0 ✅ 必填 mappedFileSize 1073741824 DLedger 存储文件大小 (1GB) 可保持默认 electMasterMaxRetryCount 3 Master 选举最大重试次数 默认即可 enableElectUncleanMaster false 是否允许选举非同步 Master ✅ 建议保持 false（避免数据丢失） Broker 管理 scanNotActiveBrokerInterval 5000 扫描不活跃 Broker 的间隔(ms) 默认即可 scanInactiveMasterInterval 5000 检测失活 Master 间隔(ms) 默认即可 notifyBrokerRoleChanged true 是否通知 Broker 角色变更 ✅ 建议开启（保持同步） isProcessReadEvent false 是否处理读事件 默认即可 线程与性能 controllerThreadPoolNums 16 控制线程池大小 可调至 8–32 视规模而定 controllerRequestThreadPoolQueueCapacity 50000 控制线程池队列容量 默认即可 Metrics 监控 metricsExporterType DISABLE 指标输出方式（DISABLE / PROM / GRPC / LOG） ✅ 建议设为 PROM metricsPromExporterPort 5557 Prometheus 端口 ✅ 若启用监控，可用默认 5557 metricsPromExporterHost (空) Prometheus 绑定主机 默认即可 metricLoggingExporterIntervalInMills 10000 日志输出指标间隔 可调整 metricsGrpcExporterTarget (空) gRPC 监控目标 可忽略 metricsInDelta false 是否以增量输出指标 默认即可 JRaft 配置（底层一致性协议） jRaftGroupId jRaft-Controller Raft 组名 默认即可 jRaftServerId localhost:9880 当前节点 ID ✅ 修改为实际 IP，例如 10.0.0.1:9880 jRaftInitConf localhost:9880,localhost:9881,localhost:9882 集群配置 ✅ 修改为实际节点 IP jRaftControllerRPCAddr localhost:9770,localhost:9771,localhost:9772 Controller RPC 地址 ✅ 修改为实际节点 IP jRaftElectionTimeoutMs 1000 选举超时（ms） 默认即可（过低可能频繁选举） jRaftScanWaitTimeoutMs 1000 扫描等待超时 默认即可 jRaftSnapshotIntervalSecs 3600 快照间隔时间（秒） ✅ 可设为 600（10分钟）加快日志压缩 网络配置 bindAddress 0.0.0.0 绑定监听地址 默认即可 listenPort 19876 Controller 服务端口 ✅ 确保未冲突 serverWorkerThreads 8 Netty 工作线程 默认即可 serverSelectorThreads 3 Selector 线程数 默认即可 serverSocketBacklog 1024 Socket backlog 队列 默认即可 useEpollNativeSelector false 是否使用 Epoll ✅ Linux 环境建议 true enableShutdownGracefully false 优雅停机 ✅ 建议 true 客户端通信 clientWorkerThreads 4 客户端工作线程 默认即可 clientAsyncSemaphoreValue 65535 异步请求信号量 默认即可 clientCloseSocketIfTimeout true 连接超时关闭 默认即可 connectTimeoutMillis 3000 连接超时 默认即可 useTLS false 是否启用 TLS ✅ 若生产环境有安全要求，建议启用 其他 configBlackList configBlackList;configStorePath 配置黑名单项 默认即可 maxReconnectIntervalTimeSeconds 60 最大重连间隔 默认即可 enableReconnectForGoAway true 是否为 GOAWAY 连接启用重连 默认即可 推荐重点优化的关键项 项目 推荐值 说明 controllerType DLedger 高可用模式 controllerDLegerGroup controllerGroup01 集群分组名 controllerDLegerPeers n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876 三节点推荐 controllerDLegerSelfId n0 / n1 / n2 对应节点 ID enableElectUncleanMaster false 防止脏主选举 notifyBrokerRoleChanged true 保持集群一致性 metricsExporterType PROM 便于 Prometheus 监控 metricsPromExporterPort 5557 默认即可 useEpollNativeSelector true Linux 性能优化 enableShutdownGracefully true 优雅停机 controllerStorePath /data/rocketmq/controller/store 避免使用 /root jRaftSnapshotIntervalSecs 600 提高快照频率","summary":"摘要 本文介绍 RocketMQ Controller 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:32:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/","title":"RocketMQ Broker 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Broker 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-Broker-配置项\">查看 Broker 配置项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看全部默认配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全部默认配置项</span></span><br><span class=\"line\">sh bin/mqbroker -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class=\"line\">sh bin/mqbroker -p -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看重要的配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看重要的默认配置项</span></span><br><span class=\"line\">sh bin/mqbroker -m</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的重要配置项</span></span><br><span class=\"line\">sh bin/mqbroker -m -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/broker</code> 的启动类 <code>org.apache.rocketmq.broker.BrokerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">BrokerConfig</span> <span class=\"variable\">brokerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BrokerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyServerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyClientConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">MessageStoreConfig</span> <span class=\"variable\">messageStoreConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageStoreConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">AuthConfig</span> <span class=\"variable\">authConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AuthConfig</span>();</span><br><span class=\"line\">nettyServerConfig.setListenPort(<span class=\"number\">10911</span>);</span><br><span class=\"line\">messageStoreConfig.setHaListenPort(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker的全部配置项非常多，这里仅列出了重要的配置项。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">参数说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础配置</strong></td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">NameServer 地址列表（多个用 <code>;</code> 分隔）</td>\n<td style=\"text-align:left\">✅ <strong>必须设置</strong>，否则 broker 无法注册到 nameserver。例：<code>namesrvAddr=10.250.0.10:9876;10.250.0.11:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>listenPort</code></td>\n<td style=\"text-align:left\">6888</td>\n<td style=\"text-align:left\">Broker 监听客户端连接的端口</td>\n<td style=\"text-align:left\">✅ 建议保持默认或显式设置为 10911（经典端口）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>brokerIP1</code></td>\n<td style=\"text-align:left\">10.250.0.188</td>\n<td style=\"text-align:left\">Broker 对外通信 IP</td>\n<td style=\"text-align:left\">✅ 在多网卡环境务必指定公网/内网 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>recoverConcurrently</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否并发恢复 CommitLog</td>\n<td style=\"text-align:left\">默认即可（高安全性）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Topic &amp; 订阅</strong></td>\n<td style=\"text-align:left\"><code>autoCreateTopicEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否允许自动创建 Topic</td>\n<td style=\"text-align:left\">✅ 生产建议设为 <strong>false</strong>，防止误创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>autoCreateSubscriptionGroup</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否自动创建订阅组</td>\n<td style=\"text-align:left\">✅ 同上，建议 <strong>false</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>msgTraceTopicName</code></td>\n<td style=\"text-align:left\">RMQ_SYS_TRACE_TOPIC</td>\n<td style=\"text-align:left\">消息轨迹主题名</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>traceTopicEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启消息轨迹功能</td>\n<td style=\"text-align:left\">✅ 建议设为 <strong>true</strong> 以便问题排查</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>事务消息</strong></td>\n<td style=\"text-align:left\"><code>rejectTransactionMessage</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否拒绝事务消息</td>\n<td style=\"text-align:left\">若不使用事务可设为 true 减少负担</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionTimeOut</code></td>\n<td style=\"text-align:left\">6000</td>\n<td style=\"text-align:left\">事务超时时间（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionCheckMax</code></td>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">事务最大回查次数</td>\n<td style=\"text-align:left\">可调高（20）提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionCheckInterval</code></td>\n<td style=\"text-align:left\">30000</td>\n<td style=\"text-align:left\">事务回查间隔（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>访问控制</strong></td>\n<td style=\"text-align:left\"><code>aclEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 ACL 权限验证</td>\n<td style=\"text-align:left\">✅ 生产环境 <strong>必须 true</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>存储路径</strong></td>\n<td style=\"text-align:left\"><code>storePathRootDir</code></td>\n<td style=\"text-align:left\">/root/store</td>\n<td style=\"text-align:left\">消息存储根目录</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/store</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathCommitLog</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">CommitLog 存储路径</td>\n<td style=\"text-align:left\">若为空则使用上面的根目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathDLedgerCommitLog</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">DLedger 模式存储路径</td>\n<td style=\"text-align:left\">DLedger 模式才需要</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathEpochFile</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">epoch 文件路径</td>\n<td style=\"text-align:left\">Controller 模式使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathBrokerIdentity</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Broker 身份文件路径</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>disappearTimeAfterStart</code></td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">Broker 启动后失效等待时间</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storeType</code></td>\n<td style=\"text-align:left\">default</td>\n<td style=\"text-align:left\">存储类型（default / dledger）</td>\n<td style=\"text-align:left\">✅ 多副本部署建议 dledger</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>刷盘与写入</strong></td>\n<td style=\"text-align:left\"><code>flushIntervalCommitLog</code></td>\n<td style=\"text-align:left\">500</td>\n<td style=\"text-align:left\">异步 flush 周期（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>commitIntervalCommitLog</code></td>\n<td style=\"text-align:left\">200</td>\n<td style=\"text-align:left\">commit 间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>flushCommitLogTimed</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否定时 flush</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>文件清理</strong></td>\n<td style=\"text-align:left\"><code>deleteWhen</code></td>\n<td style=\"text-align:left\">04</td>\n<td style=\"text-align:left\">删除过期文件时间点</td>\n<td style=\"text-align:left\">每天凌晨 4 点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>fileReservedTime</code></td>\n<td style=\"text-align:left\">72</td>\n<td style=\"text-align:left\">文件保留时间（小时）</td>\n<td style=\"text-align:left\">✅ 可改为 48 减少磁盘压力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>deleteFileBatchMax</code></td>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">删除文件批量数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息访问性能</strong></td>\n<td style=\"text-align:left\"><code>maxTransferBytesOnMessageInMemory</code></td>\n<td style=\"text-align:left\">262144</td>\n<td style=\"text-align:left\">内存消息读取最大字节</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferCountOnMessageInMemory</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">内存消息读取最大条数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferBytesOnMessageInDisk</code></td>\n<td style=\"text-align:left\">65536</td>\n<td style=\"text-align:left\">磁盘消息读取最大字节</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferCountOnMessageInDisk</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">磁盘消息读取最大条数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>accessMessageInMemoryMaxRatio</code></td>\n<td style=\"text-align:left\">40</td>\n<td style=\"text-align:left\">内存访问比例阈值</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>索引管理</strong></td>\n<td style=\"text-align:left\"><code>messageIndexEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用消息索引</td>\n<td style=\"text-align:left\">✅ 建议开启（提高按 key 查询性能）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>messageIndexSafe</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否安全模式索引</td>\n<td style=\"text-align:left\">若磁盘可靠性差可设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>主从复制</strong></td>\n<td style=\"text-align:left\"><code>haMasterAddress</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Master 地址（Slave 模式使用）</td>\n<td style=\"text-align:left\">仅从节点配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>brokerRole</code></td>\n<td style=\"text-align:left\">ASYNC_MASTER</td>\n<td style=\"text-align:left\">Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE）</td>\n<td style=\"text-align:left\">✅ 主节点建议 SYNC_MASTER 提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>flushDiskType</code></td>\n<td style=\"text-align:left\">ASYNC_FLUSH</td>\n<td style=\"text-align:left\">刷盘策略（SYNC_FLUSH / ASYNC_FLUSH）</td>\n<td style=\"text-align:left\">✅ 高可靠建议 SYNC_FLUSH</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>cleanFileForciblyEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否强制清理文件</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transientStorePoolEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 transient pool（堆外内存）</td>\n<td style=\"text-align:left\">✅ 可设为 true 提升性能（需足够内存）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>dispatchFromSenderThread</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否由发送线程分发</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>wakeCommitWhenPutMessage</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否在消息写入时唤醒 commit</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>wakeFlushWhenPutMessage</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否写入后立即 flush</td>\n<td style=\"text-align:left\">✅ 对延迟敏感业务可设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消费进度清理</strong></td>\n<td style=\"text-align:left\"><code>enableCleanExpiredOffset</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 offset 清理</td>\n<td style=\"text-align:left\">默认 false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>副本参数</strong></td>\n<td style=\"text-align:left\"><code>totalReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">副本总数</td>\n<td style=\"text-align:left\">✅ 多节点建议设为 3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>inSyncReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">同步副本数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>minInSyncReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">最小同步副本</td>\n<td style=\"text-align:left\">✅ 建议设为 2 提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>allAckInSyncStateSet</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否要求所有 ISR 确认</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableAutoInSyncReplicas</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否自动管理 ISR</td>\n<td style=\"text-align:left\">可保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>HA 与流控</strong></td>\n<td style=\"text-align:left\"><code>haFlowControlEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启主从流控</td>\n<td style=\"text-align:left\">✅ 多副本建议 true</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">注册</td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\">必填</td>\n<td style=\"text-align:left\">Broker 必须向 NameServer 注册</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>aclEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">启用访问控制</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自动创建</td>\n<td style=\"text-align:left\"><code>autoCreateTopicEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止误创建 topic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自动订阅</td>\n<td style=\"text-align:left\"><code>autoCreateSubscriptionGroup</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止误消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">刷盘策略</td>\n<td style=\"text-align:left\"><code>flushDiskType</code></td>\n<td style=\"text-align:left\">SYNC_FLUSH</td>\n<td style=\"text-align:left\">保证可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">主从</td>\n<td style=\"text-align:left\"><code>brokerRole</code></td>\n<td style=\"text-align:left\">SYNC_MASTER（主） / SLAVE（从）</td>\n<td style=\"text-align:left\">提升可用性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">存储路径</td>\n<td style=\"text-align:left\"><code>storePathRootDir</code></td>\n<td style=\"text-align:left\"><code>/data/rocketmq/store</code></td>\n<td style=\"text-align:left\">避免 <code>/root</code> 权限问题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">延迟优化</td>\n<td style=\"text-align:left\"><code>transientStorePoolEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">堆外内存加速写入</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理</td>\n<td style=\"text-align:left\"><code>fileReservedTime</code></td>\n<td style=\"text-align:left\">48</td>\n<td style=\"text-align:left\">减少磁盘占用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息轨迹</td>\n<td style=\"text-align:left\"><code>traceTopicEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">便于追踪消息链路</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Broker 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 Broker 配置项 查看全部默认配置项 1234# 查看全部默认配置项sh bin/mqbroker -p# 查看加载了指定配置文件后的全部配置项sh bin/mqbroker -p -c conf/broker.conf 查看重要的配置项 1234# 查看重要的默认配置项sh bin/mqbroker -m# 查看加载了指定配置文件后的重要配置项sh bin/mqbroker -m -c conf/broker.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/broker 的启动类 org.apache.rocketmq.broker.BrokerStartup中 可以看到其启动时会初始化如下配置项的类 1234567final BrokerConfig brokerConfig = new BrokerConfig();final NettyServerConfig nettyServerConfig = new NettyServerConfig();final NettyClientConfig nettyClientConfig = new NettyClientConfig();final MessageStoreConfig messageStoreConfig = new MessageStoreConfig();final AuthConfig authConfig = new AuthConfig();nettyServerConfig.setListenPort(10911);messageStoreConfig.setHaListenPort(0); 配置项说明 Broker的全部配置项非常多，这里仅列出了重要的配置项。 分类 参数名 默认值 参数说明 优化 / 建议 基础配置 namesrvAddr (空) NameServer 地址列表（多个用 ; 分隔） ✅ 必须设置，否则 broker 无法注册到 nameserver。例：namesrvAddr=10.250.0.10:9876;10.250.0.11:9876 listenPort 6888 Broker 监听客户端连接的端口 ✅ 建议保持默认或显式设置为 10911（经典端口） brokerIP1 10.250.0.188 Broker 对外通信 IP ✅ 在多网卡环境务必指定公网/内网 IP recoverConcurrently false 是否并发恢复 CommitLog 默认即可（高安全性） Topic &amp; 订阅 autoCreateTopicEnable true 是否允许自动创建 Topic ✅ 生产建议设为 false，防止误创建 autoCreateSubscriptionGroup true 是否自动创建订阅组 ✅ 同上，建议 false msgTraceTopicName RMQ_SYS_TRACE_TOPIC 消息轨迹主题名 默认即可 traceTopicEnable false 是否开启消息轨迹功能 ✅ 建议设为 true 以便问题排查 事务消息 rejectTransactionMessage false 是否拒绝事务消息 若不使用事务可设为 true 减少负担 transactionTimeOut 6000 事务超时时间（ms） 默认即可 transactionCheckMax 15 事务最大回查次数 可调高（20）提高可靠性 transactionCheckInterval 30000 事务回查间隔（ms） 默认即可 访问控制 aclEnable false 是否启用 ACL 权限验证 ✅ 生产环境 必须 true 存储路径 storePathRootDir /root/store 消息存储根目录 ✅ 改为 /data/rocketmq/store storePathCommitLog (空) CommitLog 存储路径 若为空则使用上面的根目录 storePathDLedgerCommitLog (空) DLedger 模式存储路径 DLedger 模式才需要 storePathEpochFile (空) epoch 文件路径 Controller 模式使用 storePathBrokerIdentity (空) Broker 身份文件路径 默认即可 disappearTimeAfterStart -1 Broker 启动后失效等待时间 默认即可 storeType default 存储类型（default / dledger） ✅ 多副本部署建议 dledger 刷盘与写入 flushIntervalCommitLog 500 异步 flush 周期（ms） 默认即可 commitIntervalCommitLog 200 commit 间隔 默认即可 flushCommitLogTimed true 是否定时 flush 默认即可 文件清理 deleteWhen 04 删除过期文件时间点 每天凌晨 4 点 fileReservedTime 72 文件保留时间（小时） ✅ 可改为 48 减少磁盘压力 deleteFileBatchMax 10 删除文件批量数 默认即可 消息访问性能 maxTransferBytesOnMessageInMemory 262144 内存消息读取最大字节 默认即可 maxTransferCountOnMessageInMemory 32 内存消息读取最大条数 默认即可 maxTransferBytesOnMessageInDisk 65536 磁盘消息读取最大字节 默认即可 maxTransferCountOnMessageInDisk 8 磁盘消息读取最大条数 默认即可 accessMessageInMemoryMaxRatio 40 内存访问比例阈值 默认即可 索引管理 messageIndexEnable true 是否启用消息索引 ✅ 建议开启（提高按 key 查询性能） messageIndexSafe false 是否安全模式索引 若磁盘可靠性差可设为 true 主从复制 haMasterAddress (空) Master 地址（Slave 模式使用） 仅从节点配置 brokerRole ASYNC_MASTER Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE） ✅ 主节点建议 SYNC_MASTER 提高可靠性 flushDiskType ASYNC_FLUSH 刷盘策略（SYNC_FLUSH / ASYNC_FLUSH） ✅ 高可靠建议 SYNC_FLUSH cleanFileForciblyEnable true 是否强制清理文件 默认即可 transientStorePoolEnable false 是否启用 transient pool（堆外内存） ✅ 可设为 true 提升性能（需足够内存） dispatchFromSenderThread false 是否由发送线程分发 默认即可 wakeCommitWhenPutMessage true 是否在消息写入时唤醒 commit 默认即可 wakeFlushWhenPutMessage false 是否写入后立即 flush ✅ 对延迟敏感业务可设为 true 消费进度清理 enableCleanExpiredOffset false 是否启用 offset 清理 默认 false 副本参数 totalReplicas 1 副本总数 ✅ 多节点建议设为 3 inSyncReplicas 1 同步副本数 默认即可 minInSyncReplicas 1 最小同步副本 ✅ 建议设为 2 提高可靠性 allAckInSyncStateSet false 是否要求所有 ISR 确认 默认即可 enableAutoInSyncReplicas false 是否自动管理 ISR 可保持默认 HA 与流控 haFlowControlEnable false 是否开启主从流控 ✅ 多副本建议 true 推荐重点优化的关键项 类别 参数 推荐值 原因 注册 namesrvAddr 必填 Broker 必须向 NameServer 注册 安全 aclEnable true 启用访问控制 自动创建 autoCreateTopicEnable false 防止误创建 topic 自动订阅 autoCreateSubscriptionGroup false 防止误消费 刷盘策略 flushDiskType SYNC_FLUSH 保证可靠性 主从 brokerRole SYNC_MASTER（主） / SLAVE（从） 提升可用性 存储路径 storePathRootDir /data/rocketmq/store 避免 /root 权限问题 延迟优化 transientStorePoolEnable true 堆外内存加速写入 清理 fileReservedTime 48 减少磁盘占用 消息轨迹 traceTopicEnable true 便于追踪消息链路","summary":"摘要 本文介绍 RocketMQ Broker 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:31:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/","title":"RocketMQ NameServer 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ NameServer 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-NameServer-配置项\">查看 NameServer 配置项</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看默认配置项</span></span><br><span class=\"line\">sh bin/mqnamesrv -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项</span></span><br><span class=\"line\">sh bin/mqnamesrv -p -c conf/namesvr.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/namesrv</code> 的启动类 <code>org.apache.rocketmq.namesrv.NamesrvStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NamesrvConfig</span> <span class=\"variable\">namesrvConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ControllerConfig</span> <span class=\"variable\">controllerConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NameServer 配置项说明与建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">参数说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>rocketmqHome</strong></td>\n<td style=\"text-align:left\">/usr/local/soft/rocketmq/rocketmq5</td>\n<td style=\"text-align:left\">RocketMQ 安装目录</td>\n<td style=\"text-align:left\">不建议修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>kvConfigPath</strong></td>\n<td style=\"text-align:left\">/root/namesrv/kvConfig.json</td>\n<td style=\"text-align:left\">KV 配置存储路径</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/namesrv/kvConfig.json</code> 更规范</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>configStorePath</strong></td>\n<td style=\"text-align:left\">/root/namesrv/namesrv.properties</td>\n<td style=\"text-align:left\">NameServer 启动配置文件路径</td>\n<td style=\"text-align:left\">✅ 放在非 root 路径下 <code>/etc/rocketmq/namesrv.properties</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>productEnvName</strong></td>\n<td style=\"text-align:left\">center</td>\n<td style=\"text-align:left\">产品环境名称标识</td>\n<td style=\"text-align:left\">可用于区分环境（dev/test/prod）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clusterTest</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用集群测试模式</td>\n<td style=\"text-align:left\">默认 false，生产勿启用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>orderMessageEnable</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启顺序消息功能</td>\n<td style=\"text-align:left\">NameServer 一般无需开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>returnOrderTopicConfigToBroker</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否返回顺序消息主题配置给 broker</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientRequestThreadPoolNums</strong></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">客户端请求线程数</td>\n<td style=\"text-align:left\">✅ 若 NameServer 负载高可增至 16~32</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>defaultThreadPoolNums</strong></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">默认线程池线程数</td>\n<td style=\"text-align:left\">视 CPU 核心数调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientRequestThreadPoolQueueCapacity</strong></td>\n<td style=\"text-align:left\">50000</td>\n<td style=\"text-align:left\">客户端请求队列长度</td>\n<td style=\"text-align:left\">✅ 高并发环境可调高至 100000</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>defaultThreadPoolQueueCapacity</strong></td>\n<td style=\"text-align:left\">10000</td>\n<td style=\"text-align:left\">默认任务队列长度</td>\n<td style=\"text-align:left\">适度提高防止拒绝任务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>scanNotActiveBrokerInterval</strong></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">扫描失效 Broker 的间隔（ms）</td>\n<td style=\"text-align:left\">默认 5s，可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>unRegisterBrokerQueueCapacity</strong></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">Broker 注销队列容量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>supportActingMaster</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否支持 ActingMaster 功能</td>\n<td style=\"text-align:left\">✅ 若启用 controller 建议设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableAllTopicList</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用所有主题列表接口</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableTopicList</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否允许主题列表查询</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>notifyMinBrokerIdChanged</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否通知最小 brokerId 变化</td>\n<td style=\"text-align:left\">一般无需开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableControllerInNamesrv</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否在 NameServer 中启用 Controller 模块</td>\n<td style=\"text-align:left\">✅ 若部署简化集群可考虑 true（测试环境）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>needWaitForService</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否等待服务就绪再启动</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>waitSecondsForService</strong></td>\n<td style=\"text-align:left\">45</td>\n<td style=\"text-align:left\">启动等待时间</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>deleteTopicWithBrokerRegistration</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">注册时是否删除 topic</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>configBlackList</strong></td>\n<td style=\"text-align:left\">configBlackList;configStorePath;kvConfigPath</td>\n<td style=\"text-align:left\">黑名单配置项</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bindAddress</strong></td>\n<td style=\"text-align:left\">0.0.0.0</td>\n<td style=\"text-align:left\">绑定的监听地址</td>\n<td style=\"text-align:left\">✅ 生产环境建议绑定内网 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>listenPort</strong></td>\n<td style=\"text-align:left\">9876</td>\n<td style=\"text-align:left\">NameServer 监听端口</td>\n<td style=\"text-align:left\">✅ 可通过防火墙限制外部访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverWorkerThreads</strong></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">服务端业务处理线程数</td>\n<td style=\"text-align:left\">可根据负载调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverCallbackExecutorThreads</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">回调执行线程数</td>\n<td style=\"text-align:left\">0 表示自动设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSelectorThreads</strong></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Selector 线程数</td>\n<td style=\"text-align:left\">一般 2~4 即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverOnewaySemaphoreValue</strong></td>\n<td style=\"text-align:left\">256</td>\n<td style=\"text-align:left\">单向请求并发限制</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverAsyncSemaphoreValue</strong></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">异步请求并发限制</td>\n<td style=\"text-align:left\">可保持或略增</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverChannelMaxIdleTimeSeconds</strong></td>\n<td style=\"text-align:left\">120</td>\n<td style=\"text-align:left\">连接空闲关闭时间</td>\n<td style=\"text-align:left\">可调大到 300 提高容错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketSndBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">TCP 发送缓冲区大小</td>\n<td style=\"text-align:left\">0 表示使用系统默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketRcvBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">TCP 接收缓冲区大小</td>\n<td style=\"text-align:left\">建议 131072（128KB）以上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>writeBufferHighWaterMark</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">写缓冲高水位标记</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>writeBufferLowWaterMark</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">写缓冲低水位标记</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketBacklog</strong></td>\n<td style=\"text-align:left\">1024</td>\n<td style=\"text-align:left\">TCP 连接等待队列</td>\n<td style=\"text-align:left\">✅ 高并发场景可调大至 2048</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverNettyWorkerGroupEnable</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 Netty worker 线程组</td>\n<td style=\"text-align:left\">默认 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverPooledByteBufAllocatorEnable</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 Netty 池化内存</td>\n<td style=\"text-align:left\">建议保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableShutdownGracefully</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否优雅关闭</td>\n<td style=\"text-align:left\">✅ 建议设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>shutdownWaitTimeSeconds</strong></td>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\">优雅关闭等待时间</td>\n<td style=\"text-align:left\">建议 30~60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>useEpollNativeSelector</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 Linux Epoll</td>\n<td style=\"text-align:left\">✅ Linux 环境建议设为 true 提高性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientWorkerThreads</strong></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">客户端 worker 线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientCallbackExecutorThreads</strong></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">客户端回调线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientOnewaySemaphoreValue</strong></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">客户端单向请求并发限制</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientAsyncSemaphoreValue</strong></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">客户端异步请求并发限制</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>connectTimeoutMillis</strong></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">连接超时（ms）</td>\n<td style=\"text-align:left\">✅ 可提高至 5000 增加容错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>channelNotActiveInterval</strong></td>\n<td style=\"text-align:left\">60000</td>\n<td style=\"text-align:left\">检查通道非活动间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>isScanAvailableNameSrv</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否扫描可用 NameServer</td>\n<td style=\"text-align:left\">保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientChannelMaxIdleTimeSeconds</strong></td>\n<td style=\"text-align:left\">120</td>\n<td style=\"text-align:left\">客户端空闲连接超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientSocketSndBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">客户端 TCP 发送缓冲区</td>\n<td style=\"text-align:left\">建议 131072</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientSocketRcvBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">客户端 TCP 接收缓冲区</td>\n<td style=\"text-align:left\">建议 131072</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientPooledByteBufAllocatorEnable</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">客户端是否启用池化</td>\n<td style=\"text-align:left\">✅ 建议设为 true 提高性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientCloseSocketIfTimeout</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">超时是否关闭 socket</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>useTLS</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 TLS 通信</td>\n<td style=\"text-align:left\">✅ 若公网部署强烈建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>socksProxyConfig</strong></td>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">SOCKS 代理配置</td>\n<td style=\"text-align:left\">内网部署无需设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>disableCallbackExecutor</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否禁用回调执行器</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>disableNettyWorkerGroup</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否禁用 Netty worker group</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>maxReconnectIntervalTimeSeconds</strong></td>\n<td style=\"text-align:left\">60</td>\n<td style=\"text-align:left\">最大重连间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableReconnectForGoAway</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 goaway 自动重连</td>\n<td style=\"text-align:left\">保持 true 增强健壮性</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">Linux 性能显著提升</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>bindAddress</code></td>\n<td style=\"text-align:left\">内网 IP</td>\n<td style=\"text-align:left\">防止暴露公网</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>useTLS</code></td>\n<td style=\"text-align:left\">true（公网）</td>\n<td style=\"text-align:left\">启用加密传输</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">健壮性</td>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">防止强制关闭导致状态不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">负载</td>\n<td style=\"text-align:left\"><code>clientRequestThreadPoolNums</code></td>\n<td style=\"text-align:left\">16~32</td>\n<td style=\"text-align:left\">提高并发能力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">网络</td>\n<td style=\"text-align:left\"><code>serverSocketBacklog</code></td>\n<td style=\"text-align:left\">2048</td>\n<td style=\"text-align:left\">减少连接拒绝</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">缓冲</td>\n<td style=\"text-align:left\"><code>serverSocketSndBufSize</code> / <code>RcvBufSize</code></td>\n<td style=\"text-align:left\">131072</td>\n<td style=\"text-align:left\">提高网络吞吐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件路径</td>\n<td style=\"text-align:left\"><code>kvConfigPath</code> / <code>configStorePath</code></td>\n<td style=\"text-align:left\">非 root 路径</td>\n<td style=\"text-align:left\">避免权限问题</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ NameServer 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 NameServer 配置项 1234# 查看默认配置项sh bin/mqnamesrv -p# 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项sh bin/mqnamesrv -p -c conf/namesvr.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/namesrv 的启动类 org.apache.rocketmq.namesrv.NamesrvStartup中 可以看到其启动时会初始化如下配置项的类 1234private static NamesrvConfig namesrvConfig = null;private static NettyServerConfig nettyServerConfig = null;private static NettyClientConfig nettyClientConfig = null;private static ControllerConfig controllerConfig = null; 配置项说明 NameServer 配置项说明与建议 参数名 默认值 参数说明 优化 / 建议 rocketmqHome /usr/local/soft/rocketmq/rocketmq5 RocketMQ 安装目录 不建议修改 kvConfigPath /root/namesrv/kvConfig.json KV 配置存储路径 ✅ 改为 /data/rocketmq/namesrv/kvConfig.json 更规范 configStorePath /root/namesrv/namesrv.properties NameServer 启动配置文件路径 ✅ 放在非 root 路径下 /etc/rocketmq/namesrv.properties productEnvName center 产品环境名称标识 可用于区分环境（dev/test/prod） clusterTest false 是否启用集群测试模式 默认 false，生产勿启用 orderMessageEnable false 是否开启顺序消息功能 NameServer 一般无需开启 returnOrderTopicConfigToBroker true 是否返回顺序消息主题配置给 broker 保持默认 clientRequestThreadPoolNums 8 客户端请求线程数 ✅ 若 NameServer 负载高可增至 16~32 defaultThreadPoolNums 16 默认线程池线程数 视 CPU 核心数调整 clientRequestThreadPoolQueueCapacity 50000 客户端请求队列长度 ✅ 高并发环境可调高至 100000 defaultThreadPoolQueueCapacity 10000 默认任务队列长度 适度提高防止拒绝任务 scanNotActiveBrokerInterval 5000 扫描失效 Broker 的间隔（ms） 默认 5s，可保持 unRegisterBrokerQueueCapacity 3000 Broker 注销队列容量 默认即可 supportActingMaster false 是否支持 ActingMaster 功能 ✅ 若启用 controller 建议设为 true enableAllTopicList true 是否启用所有主题列表接口 可保持 enableTopicList true 是否允许主题列表查询 可保持 notifyMinBrokerIdChanged false 是否通知最小 brokerId 变化 一般无需开启 enableControllerInNamesrv false 是否在 NameServer 中启用 Controller 模块 ✅ 若部署简化集群可考虑 true（测试环境） needWaitForService false 是否等待服务就绪再启动 可保持 waitSecondsForService 45 启动等待时间 可保持 deleteTopicWithBrokerRegistration false 注册时是否删除 topic 默认即可 configBlackList configBlackList;configStorePath;kvConfigPath 黑名单配置项 保持默认 bindAddress 0.0.0.0 绑定的监听地址 ✅ 生产环境建议绑定内网 IP listenPort 9876 NameServer 监听端口 ✅ 可通过防火墙限制外部访问 serverWorkerThreads 8 服务端业务处理线程数 可根据负载调整 serverCallbackExecutorThreads 0 回调执行线程数 0 表示自动设置 serverSelectorThreads 3 Selector 线程数 一般 2~4 即可 serverOnewaySemaphoreValue 256 单向请求并发限制 可保持 serverAsyncSemaphoreValue 64 异步请求并发限制 可保持或略增 serverChannelMaxIdleTimeSeconds 120 连接空闲关闭时间 可调大到 300 提高容错 serverSocketSndBufSize 0 TCP 发送缓冲区大小 0 表示使用系统默认 serverSocketRcvBufSize 0 TCP 接收缓冲区大小 建议 131072（128KB）以上 writeBufferHighWaterMark 0 写缓冲高水位标记 默认即可 writeBufferLowWaterMark 0 写缓冲低水位标记 默认即可 serverSocketBacklog 1024 TCP 连接等待队列 ✅ 高并发场景可调大至 2048 serverNettyWorkerGroupEnable true 是否启用 Netty worker 线程组 默认 true serverPooledByteBufAllocatorEnable true 是否启用 Netty 池化内存 建议保持 enableShutdownGracefully false 是否优雅关闭 ✅ 建议设为 true shutdownWaitTimeSeconds 30 优雅关闭等待时间 建议 30~60 useEpollNativeSelector false 是否启用 Linux Epoll ✅ Linux 环境建议设为 true 提高性能 clientWorkerThreads 4 客户端 worker 线程数 默认即可 clientCallbackExecutorThreads 2 客户端回调线程数 默认即可 clientOnewaySemaphoreValue 65535 客户端单向请求并发限制 默认即可 clientAsyncSemaphoreValue 65535 客户端异步请求并发限制 默认即可 connectTimeoutMillis 3000 连接超时（ms） ✅ 可提高至 5000 增加容错 channelNotActiveInterval 60000 检查通道非活动间隔 默认即可 isScanAvailableNameSrv true 是否扫描可用 NameServer 保持 clientChannelMaxIdleTimeSeconds 120 客户端空闲连接超时 默认即可 clientSocketSndBufSize 0 客户端 TCP 发送缓冲区 建议 131072 clientSocketRcvBufSize 0 客户端 TCP 接收缓冲区 建议 131072 clientPooledByteBufAllocatorEnable false 客户端是否启用池化 ✅ 建议设为 true 提高性能 clientCloseSocketIfTimeout true 超时是否关闭 socket 保持默认 useTLS false 是否启用 TLS 通信 ✅ 若公网部署强烈建议开启 socksProxyConfig {} SOCKS 代理配置 内网部署无需设置 disableCallbackExecutor false 是否禁用回调执行器 默认即可 disableNettyWorkerGroup false 是否禁用 Netty worker group 默认即可 maxReconnectIntervalTimeSeconds 60 最大重连间隔 默认即可 enableReconnectForGoAway true 是否启用 goaway 自动重连 保持 true 增强健壮性 推荐重点优化的关键项 类别 参数 推荐值 原因 性能 useEpollNativeSelector true Linux 性能显著提升 安全 bindAddress 内网 IP 防止暴露公网 安全 useTLS true（公网） 启用加密传输 健壮性 enableShutdownGracefully true 防止强制关闭导致状态不一致 负载 clientRequestThreadPoolNums 16~32 提高并发能力 网络 serverSocketBacklog 2048 减少连接拒绝 缓冲 serverSocketSndBufSize / RcvBufSize 131072 提高网络吞吐 文件路径 kvConfigPath / configStorePath 非 root 路径 避免权限问题","summary":"摘要 本文介绍 RocketMQ NameServer 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/","url":"https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/","title":"RocketMQ Dashboard 的安装及使用","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RocketMQ-Dashboard-简介\">RocketMQ Dashboard 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>功能概览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>面板</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>运维</strong></td>\n<td>修改 <strong>NameServer 地址</strong>；选择 <strong>VIPChannel</strong> 等运维配置。</td>\n</tr>\n<tr>\n<td><strong>驾驶舱</strong></td>\n<td>查看 <strong>Broker、Topic 消息量</strong> 等运行总览信息。</td>\n</tr>\n<tr>\n<td><strong>集群</strong></td>\n<td>查看 <strong>集群分布</strong>、Broker 配置、运行状态及详细信息。</td>\n</tr>\n<tr>\n<td><strong>主题（Topic）</strong></td>\n<td>搜索、筛选、删除、更新/新增主题；查看 <strong>消息路由</strong>；执行 <strong>发送消息</strong>、<strong>重置消费位点</strong> 等操作。</td>\n</tr>\n<tr>\n<td><strong>消费者（Consumer）</strong></td>\n<td>搜索、删除、新增/更新消费者组；查看 <strong>终端信息、消费详情、配置项</strong>。</td>\n</tr>\n<tr>\n<td><strong>消息（Message）</strong></td>\n<td>查看 <strong>消息记录、死信消息、消息轨迹</strong> 等消息级详情。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>系统要求 与 网络配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>系统要求</strong></td>\n<td>操作系统</td>\n<td>Linux / Unix / macOS</td>\n</tr>\n<tr>\n<td></td>\n<td>JDK</td>\n<td>64 位 JDK, 1.x 版本需要<strong>1.8+</strong>，2.x版本需要 <strong>17+</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>构建工具</td>\n<td><strong>Maven 3.2.x</strong> 或更高版本</td>\n</tr>\n<tr>\n<td></td>\n<td>启动项</td>\n<td>启动 <strong>RocketMQ</strong>（包括 NameServer 与 Broker）</td>\n</tr>\n<tr>\n<td><strong>网络配置</strong></td>\n<td>网络访问</td>\n<td>云服务器需可远程访问，或本地虚拟机需可 <strong>PING 通外网</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RocketMQ-Dashboard-的安装\">RocketMQ Dashboard 的安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>部署 RocketMQ Dashboard 2.x，需要安装 JDK17</p>\n</li>\n<li class=\"lvl-2\">\n<p>源码安装，<a href=\"https://github.com/apache/rocketmq-dashboard\">源码下载</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载源码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq</span><br><span class=\"line\">wget https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-2.1.0.tar.gz</span><br><span class=\"line\">tar -zxvf rocketmq-dashboard-2.1.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s rocketmq-dashboard-rocketmq-dashboard-2.1.0 rocketmq-dashboard</span><br><span class=\"line\"><span class=\"built_in\">cd</span> rocketmq-dashboard</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>bug 修复，当前<code>2.1.0</code>版本存在bug，只能通过<code>http://localhost:8082</code>访问，如果需要ip或域名访问，则需要修改源码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> frontend-new/src/api/remoteApi</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s|apiBaseUrl: &#x27;</span>\\&#x27;<span class=\"string\">&#x27;http://localhost:8082&#x27;</span>\\&#x27;<span class=\"string\">&#x27;|apiBaseUrl: process.env.REACT_APP_API_BASE_URL \\|\\| window.location.origin|&#x27;</span> remoteApi.js.bck</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 替换前：</span></span><br><span class=\"line\">const appConfig = &#123;</span><br><span class=\"line\">    apiBaseUrl: <span class=\"string\">&#x27;http://localhost:8082&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\"># 替换后：</span></span><br><span class=\"line\">const appConfig = &#123;</span><br><span class=\"line\">    apiBaseUrl: process.env.REACT_APP_API_BASE_URL || window.location.origin</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>环境</th>\n<th>环境变量值</th>\n<th>结果 (<code>appConfig.apiBaseUrl</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发环境</td>\n<td><code>REACT_APP_API_BASE_URL=http://localhost:8080</code></td>\n<td><code>http://localhost:8080</code></td>\n</tr>\n<tr>\n<td>测试环境</td>\n<td><code>REACT_APP_API_BASE_URL=https://api.test.example.com</code></td>\n<td><code>https://api.test.example.com</code></td>\n</tr>\n<tr>\n<td>未设置变量</td>\n<td><em>(无该环境变量)</em> 则使用默认的 <code>window.location.origin</code>，其表示 当前网页的 协议 + 域名 + 端口号</td>\n<td>自动使用当前网站地址，如 <code>https://myapp.example.com</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>目前<code>2.1.0</code>版本的bug还比较多，GitHub仓库中的代码已经修复了包括该bug在内的部分bug，不过还没有发布到 release。<br>\n着急的小伙伴可以通过 <code>git clone</code> 项目，编译并运行，或者等待作者发布新版本。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/apache/rocketmq-dashboard.git</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq/rocketmq-dashboard</span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/jdk/jdk17 mvn clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 将jar包复制到run目录下，以避免重新编译时被覆盖</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> run</span><br><span class=\"line\"><span class=\"built_in\">cp</span> target/rocketmq-dashboard-2.1.0.jar run/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按需替换配置，</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\"><span class=\"comment\">#    accessKey: mqadmin</span></span><br><span class=\"line\"><span class=\"comment\">#    secretKey: 1234567</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>users.properties</code> 文件格式如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class=\"line\"><span class=\"comment\"># 格式， 每行定义一个用户， username=password[,N]  #N是可选项，可以为0 (普通用户)； 1 （管理员）</span></span><br><span class=\"line\"><span class=\"comment\"># 定义管理员，管理员拥有全部权限</span></span><br><span class=\"line\">super=passwd,1</span><br><span class=\"line\"><span class=\"comment\"># 定义普通用户，普通用户的权限需要在 dataPath 下的 role-permission.yml 文件中定义，如果该目录下不存在此文件，则默认使用resources/role-permission.yml文件</span></span><br><span class=\"line\">user1=passwd</span><br><span class=\"line\">user2=passwd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>role-permission.yml</code> 文件格式如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class=\"line\"><span class=\"comment\"># 格式，如果增加和删除接口权限，直接在列表中增加和删除接口地址即可。</span></span><br><span class=\"line\"><span class=\"comment\"># 接口路径配置支持通配符</span></span><br><span class=\"line\"><span class=\"comment\"># * 表示匹配0或多个不是/的字符</span></span><br><span class=\"line\"><span class=\"comment\"># ** 表示匹配0或多个任意字符</span></span><br><span class=\"line\"><span class=\"comment\"># ? 表示匹配1个任意字符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rolePerms:</span></span><br><span class=\"line\">  <span class=\"comment\"># 普通用户，以下权限为默认权限，基本上就只是查询的权限</span></span><br><span class=\"line\">  <span class=\"attr\">Normal:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/rocketmq/nsaddr</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/ops/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/dashboard/**</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/topic/*.query</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/topic/sendTopicMessage.do</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/producer/*.query</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/message/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/messageTrace/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/monitor/*</span></span><br><span class=\"line\">    <span class=\"string\">....</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> run</span><br><span class=\"line\"><span class=\"comment\"># 启动，默认会加载与jar包同级目录下的application.yaml文件</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> /usr/local/jdk/jdk17/bin/java -jar rocketmq-dashboard-2.1.0.jar 1&gt;dashboard.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\"><span class=\"built_in\">tail</span> -f dashboard.log</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/9F26eh.png\" alt=\"\" width=\"1400\" height=\"800\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/rocketmq-dashboard/blob/master/docs/1_0_0/UserGuide_CN.md\">Dashboard 使用手册</a></p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ Dashboard 简介 官方文档 RocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。 功能概览 面板 功能说明 运维 修改 NameServer 地址；选择 VIPChannel 等运维配置。 驾驶舱 查看 Broker、Topic 消息量 等运行总览信息。 集群 查看 集群分布、Broker 配置、运行状态及详细信息。 主题（Topic） 搜索、筛选、删除、更新/新增主题；查看 消息路由；执行 发送消息、重置消费位点 等操作。 消费者（Consumer） 搜索、删除、新增/更新消费者组；查看 终端信息、消费详情、配置项。 消息（Message） 查看 消息记录、死信消息、消息轨迹 等消息级详情。 系统要求 与 网络配置 类别 项目 说明 系统要求 操作系统 Linux / Unix / macOS JDK 64 位 JDK, 1.x 版本需要1.8+，2.x版本需要 17+ 构建工具 Maven 3.2.x 或更高版本 启动项 启动 RocketMQ（包括 NameServer 与 Broker） 网络配置 网络访问 云服务器需可远程访问，或本地虚拟机需可 PING 通外网 RocketMQ Dashboard 的安装 部署 RocketMQ Dashboard 2.x，需要安装 JDK17 源码安装，源码下载 123456# 下载源码cd /usr/local/soft/rocketmqwget https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-2.1.0.tar.gztar -zxvf rocketmq-dashboard-2.1.0.tar.gzln -s rocketmq-dashboard-rocketmq-dashboard-2.1.0 rocketmq-dashboardcd rocketmq-dashboard bug 修复，当前2.1.0版本存在bug，只能通过http://localhost:8082访问，如果需要ip或域名访问，则需要修改源码 1234567891011cd frontend-new/src/api/remoteApised -i &#x27;s|apiBaseUrl: &#x27;\\&#x27;&#x27;http://localhost:8082&#x27;\\&#x27;&#x27;|apiBaseUrl: process.env.REACT_APP_API_BASE_URL \\|\\| window.location.origin|&#x27; remoteApi.js.bck# 替换前：const appConfig = &#123; apiBaseUrl: &#x27;http://localhost:8082&#x27;&#125;;# 替换后：const appConfig = &#123; apiBaseUrl: process.env.REACT_APP_API_BASE_URL || window.location.origin&#125;; 环境 环境变量值 结果 (appConfig.apiBaseUrl) 开发环境 REACT_APP_API_BASE_URL=http://localhost:8080 http://localhost:8080 测试环境 REACT_APP_API_BASE_URL=https://api.test.example.com https://api.test.example.com 未设置变量 (无该环境变量) 则使用默认的 window.location.origin，其表示 当前网页的 协议 + 域名 + 端口号 自动使用当前网站地址，如 https://myapp.example.com 目前2.1.0版本的bug还比较多，GitHub仓库中的代码已经修复了包括该bug在内的部分bug，不过还没有发布到 release。 着急的小伙伴可以通过 git clone 项目，编译并运行，或者等待作者发布新版本。 1git clone https://github.com/apache/rocketmq-dashboard.git 编译 123456cd /usr/local/soft/rocketmq/rocketmq-dashboard# 编译JAVA_HOME=/usr/local/jdk/jdk17 mvn clean package -Dmaven.test.skip=true# 将jar包复制到run目录下，以避免重新编译时被覆盖mkdir runcp target/rocketmq-dashboard-2.1.0.jar run/ 按需替换配置， 12345678910111213# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey# accessKey: mqadmin# secretKey: 1234567 users.properties 文件格式如下： 1234567# 该文件支持热修改，即添加和修改用户时，不需要重新启动console# 格式， 每行定义一个用户， username=password[,N] #N是可选项，可以为0 (普通用户)； 1 （管理员）# 定义管理员，管理员拥有全部权限super=passwd,1# 定义普通用户，普通用户的权限需要在 dataPath 下的 role-permission.yml 文件中定义，如果该目录下不存在此文件，则默认使用resources/role-permission.yml文件user1=passwduser2=passwd role-permission.yml 文件格式如下： 1234567891011121314151617181920# 该文件支持热修改，即添加和修改用户时，不需要重新启动console# 格式，如果增加和删除接口权限，直接在列表中增加和删除接口地址即可。# 接口路径配置支持通配符# * 表示匹配0或多个不是/的字符# ** 表示匹配0或多个任意字符# ? 表示匹配1个任意字符rolePerms: # 普通用户，以下权限为默认权限，基本上就只是查询的权限 Normal: - /rocketmq/nsaddr - /ops/* - /dashboard/** - /topic/*.query - /topic/sendTopicMessage.do - /producer/*.query - /message/* - /messageTrace/* - /monitor/* .... 启动 123456cd run# 启动，默认会加载与jar包同级目录下的application.yaml文件nohup /usr/local/jdk/jdk17/bin/java -jar rocketmq-dashboard-2.1.0.jar 1&gt;dashboard.log 2&gt;&amp;1 &amp;# 查看日志tail -f dashboard.log Dashboard 使用手册","summary":"摘要 本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-24T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/","url":"https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/","title":"RocketMQ 的安装及使用","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 RocketMQ 的安装与使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Apache-RocketMQ-简介\">Apache RocketMQ 简介</h2>\n<h3 id=\"一、RocketMQ-是什么？\">一、RocketMQ 是什么？</h3>\n<p>RocketMQ 是一个<strong>分布式、队列模型的消息中间件</strong>。它由阿里巴巴在2012年开源，并于2017年正式成为 Apache 基金会的顶级项目。</p>\n<p>你可以把它想象成一个在分布式系统中负责可靠传递消息的“邮局”或“快递系统”。当系统A需要发送数据给系统B，但它们之间不直接通信时，就可以通过 RocketMQ 来中转，确保消息不丢失、不重复，并且能按顺序送达。</p>\n<p><strong>RocketMQ 是一个高性能、高可靠、高实时的分布式消息中间件</strong>。它就像分布式系统的“中枢神经系统”，负责在各个服务之间可靠、高效地传递数据，是现代互联网架构中不可或缺的基础组件之一。</p>\n<p><strong>RocketMQ 5.x 通过引入 Proxy 模式，极大地提升了架构的灵活性、多语言支持能力和云原生亲和力</strong>，是其在消息中间件领域持续演进的重要里程碑。</p>\n<p>它与 Kafka、RabbitMQ 等都是业界顶级的消息队列，但各有侧重。RocketMQ 在事务消息、顺序消息和对在线业务的稳定性支持方面表现尤为出色。</p>\n<hr>\n<h3 id=\"二、核心特点与优势\">二、核心特点与优势</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">典型场景</th>\n<th style=\"text-align:left\">主要作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>1</strong></td>\n<td style=\"text-align:left\"><strong>削峰填谷</strong></td>\n<td style=\"text-align:left\">电商秒杀、大促活动时大量下单请求瞬间涌入</td>\n<td style=\"text-align:left\">将突发请求先缓存为消息，后端系统按自身能力平稳消费，避免系统过载崩溃</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>2</strong></td>\n<td style=\"text-align:left\"><strong>异步解耦</strong></td>\n<td style=\"text-align:left\">用户注册后触发多系统任务（邮件、优惠券、积分）</td>\n<td style=\"text-align:left\">主流程只负责发送消息，其他系统独立异步处理，降低系统间耦合、提高扩展性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>3</strong></td>\n<td style=\"text-align:left\"><strong>顺序消息</strong></td>\n<td style=\"text-align:left\">订单状态变更（创建 → 付款 → 发货 → 收货）</td>\n<td style=\"text-align:left\">同一业务键（如订单ID）的消息按顺序发送和消费，保证业务逻辑正确性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>4</strong></td>\n<td style=\"text-align:left\"><strong>持久化与高可靠性</strong></td>\n<td style=\"text-align:left\">关键业务消息必须不丢失（交易、支付、日志）</td>\n<td style=\"text-align:left\">所有消息写入磁盘并支持主从复制，即使服务器重启也能恢复，保证高可用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>5</strong></td>\n<td style=\"text-align:left\"><strong>消息回溯</strong></td>\n<td style=\"text-align:left\">消费逻辑出错、数据重算、补偿任务</td>\n<td style=\"text-align:left\">支持重置消费位点，重新消费历史消息，实现业务补偿与追溯</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>6</strong></td>\n<td style=\"text-align:left\"><strong>海量消息堆积能力</strong></td>\n<td style=\"text-align:left\">大规模异步日志收集、IoT 数据汇聚、埋点分析</td>\n<td style=\"text-align:left\">支持万亿级消息堆积，性能稳定不衰减，适用于大规模数据场景</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"三、核心架构与概念\">三、核心架构与概念</h3>\n<p>要理解 RocketMQ，需要知道几个关键角色：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/frTwo1.png\" alt=\"\"></p>\n<h4 id=\"经典核心组件\">经典核心组件</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:left\">组件名称</th>\n<th style=\"text-align:left\">主要作用</th>\n<th style=\"text-align:left\">说明 / 特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>1</strong></td>\n<td style=\"text-align:left\"><strong>Producer（生产者）</strong></td>\n<td style=\"text-align:left\">发送消息的客户端</td>\n<td style=\"text-align:left\">负责将业务系统的消息发送到指定的 <strong>Topic</strong>，支持同步、异步、单向三种发送方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>2</strong></td>\n<td style=\"text-align:left\"><strong>Consumer（消费者）</strong></td>\n<td style=\"text-align:left\">接收并消费消息的客户端</td>\n<td style=\"text-align:left\">从 Broker 拉取消息并进行业务处理，可分为 <strong>Push</strong> 和 <strong>Pull</strong> 两种消费模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>3</strong></td>\n<td style=\"text-align:left\"><strong>Consumer Group（消费者组）</strong></td>\n<td style=\"text-align:left\">实现负载均衡与高可用消费</td>\n<td style=\"text-align:left\">多个消费者订阅同一 Topic 时组成消费者组，一个分区只会被组内一个消费者消费</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>4</strong></td>\n<td style=\"text-align:left\"><strong>Broker（消息服务器）</strong></td>\n<td style=\"text-align:left\">存储和转发消息</td>\n<td style=\"text-align:left\">RocketMQ 的核心组件，负责消息的持久化、转发、主从复制和高可用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>5</strong></td>\n<td style=\"text-align:left\"><strong>Topic（主题）</strong></td>\n<td style=\"text-align:left\">消息的分类与路由单元</td>\n<td style=\"text-align:left\">Producer 发送消息到指定 Topic，Consumer 订阅 Topic 消费消息；一个 Topic 可包含多个消息队列（分区）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>6</strong></td>\n<td style=\"text-align:left\"><strong>Name Server（名字服务）</strong></td>\n<td style=\"text-align:left\">管理 Broker 地址信息</td>\n<td style=\"text-align:left\">类似轻量级注册中心，维护 Broker 元数据，帮助 Producer 和 Consumer 定位消息存储位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>7</strong></td>\n<td style=\"text-align:left\"><strong>Controller（控制器）</strong></td>\n<td style=\"text-align:left\">主从自动切换与高可用控制</td>\n<td style=\"text-align:left\">RocketMQ 5.x 引入，基于 Raft（DLedger）协议实现 Broker 自动选主和元数据管理</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>8</strong></td>\n<td style=\"text-align:left\"><strong>Proxy（代理层）</strong></td>\n<td style=\"text-align:left\">客户端访问入口与协议转换</td>\n<td style=\"text-align:left\">RocketMQ 5.x 新组件，无状态，可横向扩展；统一接入层，支持多协议（如 HTTP、gRPC），隔离客户端与 Broker</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>引入 Proxy 模式的优势：</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**架构解耦与语言无关**：Proxy 作为通用代理，将复杂的 Broker 协议封装成更简单的接口（如 gRPC），使得用不同编程语言（如 Go, Python, C++ 等）开发的客户端更容易接入，而无需实现复杂的原生协议。</span><br><span class=\"line\">**简化客户端**：客户端不再需要感知 Name Server 和 Broker 的地址变化，只需连接固定的 Proxy 地址即可，大大降低了客户端的复杂度。</span><br><span class=\"line\">**增强安全性**：可以在 Proxy 层统一实现安全认证、限流、审计等策略，作为Broker集群的安全屏障。</span><br><span class=\"line\">**云原生友好**：无状态的 Proxy 非常适合在 Kubernetes 等容器化环境中进行部署和弹性伸缩。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"消息中间件功能对比表（ActiveMQ-vs-Kafka-vs-RabbitMQ-vs-RocketMQ）\">消息中间件功能对比表（ActiveMQ vs Kafka vs RabbitMQ vs RocketMQ）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://support.huaweicloud.com/intl/zh-cn/productdesc-hrm/hrm_pd_012.html\">参考资料</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能项</th>\n<th style=\"text-align:left\">ActiveMQ</th>\n<th style=\"text-align:left\">Kafka</th>\n<th style=\"text-align:left\">RabbitMQ</th>\n<th style=\"text-align:left\">RocketMQ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">客户端 SDK</td>\n<td style=\"text-align:left\">Java、.NET、C++ 等</td>\n<td style=\"text-align:left\">Java、Scala 等</td>\n<td style=\"text-align:left\">Java、.NET、Go、Python、C 等</td>\n<td style=\"text-align:left\">Java、C++、Go</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通信协议与规范</td>\n<td style=\"text-align:left\">推送模型（Push），支持 OpenWire、STOMP、AMQP、MQTT、JMS</td>\n<td style=\"text-align:left\">拉取模型（Pull），支持 TCP</td>\n<td style=\"text-align:left\">推送模型（Push），支持 AMQP、MQTT、STOMP、HTTP、WebSocket</td>\n<td style=\"text-align:left\">拉取模型（Pull），支持 TCP、JMS、OpenMessaging</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息有序性</td>\n<td style=\"text-align:left\">通过独占消费者（Exclusive Consumer）或独占队列（Exclusive Queues）保证顺序</td>\n<td style=\"text-align:left\">保证分区内消息顺序</td>\n<td style=\"text-align:left\">单队列内消息天然有序</td>\n<td style=\"text-align:left\">严格顺序消息，可平滑扩展</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">定时/延迟消息</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（使用延迟插件）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">批量消息</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（异步生产者）</td>\n<td style=\"text-align:left\">支持（Publisher Confirms 模式下）</td>\n<td style=\"text-align:left\">支持（同步模式可避免消息丢失）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">广播消息</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（Fanout 交换机）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息过滤</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（可用 Kafka Streams 实现）</td>\n<td style=\"text-align:left\">支持（基于 Exchange 的路由键或 Header）</td>\n<td style=\"text-align:left\">支持（基于 SQL92 属性过滤）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">服务器端触发重投递</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（Nack 或 TTL+DLX）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息存储</td>\n<td style=\"text-align:left\">支持高性能持久化（JDBC + LevelDB/KahaDB）</td>\n<td style=\"text-align:left\">高性能文件存储</td>\n<td style=\"text-align:left\">内存+磁盘混合存储（Mnesia/基于 Erlang 的日志）</td>\n<td style=\"text-align:left\">高性能、低延迟文件存储</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息回溯（历史消息查询）</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（通过 offset）</td>\n<td style=\"text-align:left\">不支持（消息被消费后无法回溯）</td>\n<td style=\"text-align:left\">支持（时间戳与 offset）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息优先级</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（优先级队列）</td>\n<td style=\"text-align:left\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">高可用与故障转移</td>\n<td style=\"text-align:left\">依赖存储，如 LevelDB 需 ZooKeeper</td>\n<td style=\"text-align:left\">需要 ZooKeeper</td>\n<td style=\"text-align:left\">支持镜像队列（Classic / Quorum 模式）</td>\n<td style=\"text-align:left\">支持主从模式（无需额外组件）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息轨迹（Message Track）</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持（可通过插件扩展）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置复杂度</td>\n<td style=\"text-align:left\">默认配置较低，需手动优化</td>\n<td style=\"text-align:left\">配置为键值对，可文件或代码提供</td>\n<td style=\"text-align:left\">开箱即用，配置灵活但选项较多</td>\n<td style=\"text-align:left\">开箱即用，仅需关注少量配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">管理与运维工具</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（命令行监控）</td>\n<td style=\"text-align:left\">支持（Web 管理控制台、CLI）</td>\n<td style=\"text-align:left\">支持（丰富的 Web 与命令行工具）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RocketMQ-的安装\">RocketMQ 的安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5.x 依赖 JDK 1.8+。</p>\n</li>\n</ul>\n<h3 id=\"单机安装\">单机安装</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/quickStart/01quickstart\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>下载RocketMQ</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/rocketmq/</span><br><span class=\"line\">wget https://dist.apache.org/repos/dist/release/rocketmq/5.3.2/rocketmq-all-5.3.2-bin-release.zip</span><br><span class=\"line\">unzip rocketmq-all-5.3.2-bin-release.zip</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s rocketmq-all-5.3.2-bin-release rocketmq5</span><br><span class=\"line\"><span class=\"built_in\">cd</span> rocketmq5</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">默认脚本中，NameServer需要4G内存，Broker 需要8G内存，如果内存不够，可以进入bin目录，对其中的<code>runserver.sh</code>和<code>runbroker.sh</code>两个脚本进行一下修改</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用vi runserver.sh指令，编辑这个脚本，找到下面的一行配置，调整Java进程的内存大小。</span></span><br><span class=\"line\"><span class=\"comment\"># NameServer,Controller,Proxy 都使用这个脚本启动</span></span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\">修改为：</span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接下来，同样调整runbroker.sh中的内存大小。Broker 使用这个脚本启动</span></span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms8g -Xmx8g&quot;</span></span><br><span class=\"line\">修改为：</span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g&quot;</span></span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 NameServer</p>\n</li>\n</ul>\n<blockquote>\n<p>安装完RocketMQ包后，我们启动NameServer</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 启动namesrv</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class=\"line\"><span class=\"comment\">## 指定配置文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqnamesrv -c namesrv.conf &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 验证namesrv是否启动成功</span></span><br><span class=\"line\">$ <span class=\"built_in\">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\"><span class=\"comment\"># 我们可以在namesrv.log 中看到 &#x27;The Name Server boot success..&#x27;， 表示NameServer 已成功启动。</span></span><br><span class=\"line\">The Name Server boot success. serializeType=JSON, address 0.0.0.0:9876</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>namesrv.conf 示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The port of nameserver</span></span><br><span class=\"line\">listenPort = 9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Broker+Proxy</p>\n</li>\n</ul>\n<blockquote>\n<p>NameServer成功启动后，我们启动Broker和Proxy。这里我们使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 先启动broker</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;</span><br><span class=\"line\"><span class=\"comment\"># 指定配置文件， 默认就是 conf/broker.conf</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqbroker -n localhost:9876 -c conf/broker.conf --enable-proxy &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上面的启动方式与下面的启动方式效果一样</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqproxy -n localhost:9876 -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json -bc /usr/local/soft/rocketmq/rocketmq5/conf/broker.conf -pm <span class=\"built_in\">local</span> &amp;</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># -n, --namesrvAddr NameServer 的地址</span></span><br><span class=\"line\"><span class=\"comment\"># -pc, --proxyConfigPath Proxy 配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -bc, --brokerConfigPath Broker 配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -pm, --proxyMode Proxy 模式，local or cluster</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span><br><span class=\"line\">$ <span class=\"built_in\">tail</span> -f ~/logs/rocketmqlogs/proxy.log</span><br><span class=\"line\"><span class=\"comment\"># 我们可以在 proxy.log 中看到“The broker[brokerName,ip:port] boot success..”，这表明 broker 已成功启动。</span></span><br><span class=\"line\">The broker[broker-a, 10.250.0.175:10911] boot success. serializeType=JSON and name server is localhost:9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关闭服务器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先停止 Broker</span></span><br><span class=\"line\">$ sh bin/mqshutdown broker</span><br><span class=\"line\"><span class=\"comment\"># 停止 NameServer</span></span><br><span class=\"line\">$ sh bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群安装-多节点（集群）多副本模式-异步复制\">集群安装:多节点（集群）多副本模式-异步复制</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/01deploy\">官网文档</a> 对集群安装的方式介绍了多种，本文仅实战一种：<code>多节点（集群）多副本模式-异步复制</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>每个Master配置一个Slave，有多组 Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>\n<li class=\"lvl-6\">缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>该模式下，Master 节点和 Slave 节点之间是异步复制的，Master 节点挂掉后，Slave 节点不会自动切换为 Master 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># NameServer 3 台</span></span><br><span class=\"line\">NameServer1 10.250.0.175</span><br><span class=\"line\">NameServer2 10.250.0.188</span><br><span class=\"line\">NameServer3 10.250.0.31</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Broker 2 Master 2 Replicas</span></span><br><span class=\"line\">Broker1 10.250.0.188 broker-a,broker-b-s</span><br><span class=\"line\">Broker2 10.250.0.31  broker-b,broker-a-s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Proxy 3 台</span></span><br><span class=\"line\">Proxy1 10.250.0.175</span><br><span class=\"line\">Proxy2 10.250.0.188</span><br><span class=\"line\">Proxy3 10.250.0.31</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署-NameServer\">部署 NameServer</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在三台服务器上分别启动RocketMQ NameServer</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq/rocketmq5</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署Broker\">部署Broker</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-a.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-a              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=0                       <span class=\"comment\"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class=\"line\">deleteWhen=04                    <span class=\"comment\"># 表示凌晨 4 点清理</span></span><br><span class=\"line\">fileReservedTime=48              <span class=\"comment\"># 表示保存 48 小时的数据</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER          <span class=\"comment\"># 角色，表示异步复制的主节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH        <span class=\"comment\"># 表示异步刷盘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径，后面会介绍</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=10911</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-a-s.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-a              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=1                       <span class=\"comment\"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE                 <span class=\"comment\"># 角色，表示异步复制的从节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=11011</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-b.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-b              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=0                       <span class=\"comment\"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class=\"line\">deleteWhen=04                    <span class=\"comment\"># 表示凌晨 4 点清理</span></span><br><span class=\"line\">fileReservedTime=48              <span class=\"comment\"># 表示保存 48 小时的数据</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER          <span class=\"comment\"># 角色，表示异步复制的主节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH        <span class=\"comment\"># 表示异步刷盘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=10911</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-b-s.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-b              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=1                       <span class=\"comment\"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE                 <span class=\"comment\"># 角色，表示异步复制的从节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=11011</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Broker1 10.250.0.188 上启动 broker-a 和 broker-b-s</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动 broker-a</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class=\"line\"><span class=\"comment\"># 启动 broker-b-s</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## nohup.out 中的输出类似与下面这种就表示启动成功</span></span><br><span class=\"line\">The broker[broker-a, 10.250.0.31:11011] boot success. serializeType=JSON and name server is 10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Broker2 10.250.0.31 上启动 broker-b 和 broker-a-s</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动 broker-b</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class=\"line\"><span class=\"comment\"># 启动 broker-a-s</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动成功后，可以通过如下命令检查机器状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                1     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                1     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900         <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置-Proxy\">配置 Proxy</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在三台服务器上分别启动RocketMQ NameServer</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqproxy -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 指定配置文件，这里要注意，集群的名称要与 conf/rmq-proxy.json 中配置的集群名称必须一致，默认是 DefaultCluster</span></span><br><span class=\"line\"><span class=\"comment\">## 默认的配置文件就是 conf/rmq-proxy.json，但如果通过 -pc 指定配置文件，则必须使用绝对路径</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqproxy -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 查看日志，输出如下内容就表示启动成功，tail -f nohup.out</span></span><br><span class=\"line\">rocketmq-proxy startup successfully</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rmq-proxy.json 示例</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;rocketMQClusterName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;DefaultCluster&quot;</span><span class=\"punctuation\">,</span> # 集群名称</span><br><span class=\"line\">  <span class=\"attr\">&quot;remotingListenPort&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">8080</span><span class=\"punctuation\">,</span>              # 监听端口，默认 <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;grpcServerPort&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">8081</span>                   # grpc 监听端口，默认 <span class=\"number\">8081</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>停止Proxy</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止 Proxy</span></span><br><span class=\"line\">sh bin/mqshutdown proxy</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群安装-主备自动切换模式部署\">集群安装:主备自动切换模式部署</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5.x 提供了一种新的部署方式 <code>Controller</code>，可以在主从模式下实现主备自动切换，当主节点挂掉时，自动切换到从节点上运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/03autofailover\">官方文档:主备自动切换模式部署</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 组件提供选主能力，若需要保证 Controller 具备容错能力，Controller 部署需要三副本及以上（遵循 Raft 的多数派协议）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文在上文“集群安装:多节点（集群）多副本模式-异步复制”的基础上进行修改</p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 部署有两种方式。一种是嵌入于 NameServer 进行部署，另一种是独立部署，本文采用独立部署 Controller 组件的方式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Controller 3 台</span></span><br><span class=\"line\">Controller1 10.250.0.175</span><br><span class=\"line\">Controller2 10.250.0.188</span><br><span class=\"line\">Controller3 10.250.0.31</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别在每台机器上创建<code>controller.conf</code>配置文件，内容如下(注意修改节点Id)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># controller.conf</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># DLedger Raft Group 的名字，同一集群保持一致</span></span><br><span class=\"line\">controllerDLegerGroup = group1</span><br><span class=\"line\"><span class=\"comment\"># 集群中三个节点的成员定义，每个节点都必须一致</span></span><br><span class=\"line\">controllerDLegerPeers = n0-10.250.0.175:9877;n1-10.250.0.188:9877;n2-10.250.0.31:9877</span><br><span class=\"line\"><span class=\"comment\"># 节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一</span></span><br><span class=\"line\">controllerDLegerSelfId = n0</span><br><span class=\"line\"><span class=\"comment\"># Controller 数据存储路径（非常关键！不要删除）</span></span><br><span class=\"line\">controllerStorePath = /usr/local/soft/rocketmq/data/DledgerController</span><br><span class=\"line\"><span class=\"comment\"># 是否允许从 SyncStateSet 外选举 Master</span></span><br><span class=\"line\"><span class=\"comment\"># true 会加快选举但可能丢消息，建议生产保持 false</span></span><br><span class=\"line\">enableElectUncleanMaster = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 当 Broker 副本角色变化时是否主动通知（建议开启）</span></span><br><span class=\"line\">notifyBrokerRoleChanged = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 启动端口，端口不能与 NameServer、Broker、Proxy 端口冲突</span></span><br><span class=\"line\">listenPort = 9877</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动每台机器上的 Controller</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqcontroller -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/controller.conf &amp;</span><br><span class=\"line\"><span class=\"comment\">## 启动成功后，查看 nohup.out 文件，输出如下内容就表示启动成功</span></span><br><span class=\"line\">load config properties file OK, conf/controller.conf</span><br><span class=\"line\">The Controller Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改 broker 配置文件，以 <code>broker-a.properties</code> 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 去掉如下配置，Controller 模式下 会自动分配</span></span><br><span class=\"line\"><span class=\"comment\"># brokerId=1                       # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\"><span class=\"comment\"># brokerRole=ASYNC_MASTER          # 角色，表示异步复制的主节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加如下配置</span></span><br><span class=\"line\"><span class=\"comment\"># 启用 Controller 模式（自动主从切换模式的总开关）</span></span><br><span class=\"line\">enableControllerMode = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># Controller 集群地址列表（建议与 Controller 集群保持一致）</span></span><br><span class=\"line\">controllerAddr = 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>RocketMQ 5 Broker Controller 模式配置参数表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">备注 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>enableControllerMode</strong></td>\n<td style=\"text-align:left\">是否启用 Controller 模式（自动主从切换总开关）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">必须设为 <code>true</code> 才能启用自动主从切换</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>controllerAddr</strong></td>\n<td style=\"text-align:left\">Controller 集群地址列表（以分号分隔）</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:left\">所有 Broker 配置应一致，例如 <code>10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncBrokerMetadataPeriod</strong></td>\n<td style=\"text-align:left\">向 Controller 同步 Broker 副本信息的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>5000</code> (5s)</td>\n<td style=\"text-align:left\">保持默认即可；用于上报心跳与元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>checkSyncStateSetPeriod</strong></td>\n<td style=\"text-align:left\">检查同步状态集（SyncStateSet）的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>5000</code> (5s)</td>\n<td style=\"text-align:left\">Controller 会定期剔除落后副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncControllerMetadataPeriod</strong></td>\n<td style=\"text-align:left\">同步 Controller 元数据的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>10000</code> (10s)</td>\n<td style=\"text-align:left\">Broker 定期从集群获取当前活跃 Controller 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>haMaxTimeSlaveNotCatchup</strong></td>\n<td style=\"text-align:left\">Slave 未跟上 Master 的最大时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>15000</code> (15s)</td>\n<td style=\"text-align:left\">超过该时间将 Slave 移出 SyncStateSet</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathEpochFile</strong></td>\n<td style=\"text-align:left\">Epoch 文件存储路径</td>\n<td style=\"text-align:center\"><code>store/epochFile</code></td>\n<td style=\"text-align:left\">非常重要！不要删除；存储主从任期、epoch 等元信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>allAckInSyncStateSet</strong></td>\n<td style=\"text-align:left\">是否要求所有同步副本都 ACK 后才返回成功</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\"><code>true</code> 可保证强一致但性能下降；建议保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncFromLastFile</strong></td>\n<td style=\"text-align:left\">Slave 是否从最后一个文件开始复制（空盘启动时）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">若历史日志很大且 Slave 新建，可设为 <code>true</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>asyncLearner</strong></td>\n<td style=\"text-align:left\">是否为异步 learner 副本（不参与选主）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">用于远程灾备副本，不会被选举为 Master</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>inSyncReplicas</strong></td>\n<td style=\"text-align:left\">需保持同步的副本组数量</td>\n<td style=\"text-align:center\"><code>1</code></td>\n<td style=\"text-align:left\">若 <code>allAckInSyncStateSet=true</code>，该参数无效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>minInSyncReplicas</strong></td>\n<td style=\"text-align:left\">最小同步副本数量，低于该值则拒绝写入</td>\n<td style=\"text-align:center\"><code>1</code></td>\n<td style=\"text-align:left\">防止写入过多未同步副本导致数据丢失风险</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重新启动 Broker，为保证主从数据一致性在重启时不被破坏，启动顺序应为先重新原Master，再重启原Slave</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动成功后，可以通过如下命令检查机器状态，可以看到集群内部自动分配了主从</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  2-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                2     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900         <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>验证主备自动切换，此时关闭 <code>broker-b</code> 的 Master，并查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下，可以看到`broker-b`原来的 Slave 被切换为 Master</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  489268.58     0.2700         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重新启动刚才关闭的 <code>broker-b</code> ，节点会自动加入集群，角色为 Slave</p>\n</li>\n<li class=\"lvl-2\">\n<p>停止 Controller</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止 PrControlleroxy</span></span><br><span class=\"line\">sh bin/mqshutdown controller</span><br></pre></td></tr></table></figure>\n<h2 id=\"端口说明\">端口说明</h2>\n<table>\n<thead>\n<tr>\n<th>端口号</th>\n<th>协议</th>\n<th>组件/服务</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>9876</strong></td>\n<td>TCP</td>\n<td><strong>NameServer</strong></td>\n<td>RocketMQ 集群的 <strong>NameServer</strong> 服务端口。<br>用于 Broker 注册、客户端路由发现。<br>Producer/Consumer 连接此端口以获取 Broker 地址。</td>\n</tr>\n<tr>\n<td><strong>8080</strong></td>\n<td>TCP</td>\n<td><strong>Proxy (gRPC / HTTP)</strong></td>\n<td>RocketMQ 5 引入的 <strong>Proxy 服务</strong> 默认端口之一。<br>用于 <strong>HTTP/gRPC 客户端接入</strong>，例如 RocketMQ Proxy REST API、异步消息接口等。</td>\n</tr>\n<tr>\n<td><strong>8081</strong></td>\n<td>TCP</td>\n<td><strong>Proxy Admin / Dashboard / gRPC Alt</strong></td>\n<td>通常是 Proxy 的 <strong>管理接口</strong> 或 <strong>gRPC 辅助端口</strong>（依配置而定）。<br>也可能是控制面接口，用于与 Console 或控制工具通信。</td>\n</tr>\n<tr>\n<td><strong>10909</strong></td>\n<td>TCP</td>\n<td><strong>Broker HA (High Availability)</strong></td>\n<td>Broker <strong>主从同步端口</strong>（Master ↔ Slave 之间的数据复制）。<br>用于消息数据与元数据的同步。</td>\n</tr>\n<tr>\n<td><strong>10911</strong></td>\n<td>TCP</td>\n<td><strong>Broker 服务端口</strong></td>\n<td>Broker 的 <strong>主通信端口</strong>，客户端连接发送消息、消费消息、心跳等。<br>Producer 和 Consumer 通过 NameServer 获取该端口地址后进行通信。</td>\n</tr>\n<tr>\n<td><strong>10912</strong></td>\n<td>TCP</td>\n<td><strong>Broker HA 客户端端口</strong></td>\n<td>Broker <strong>主从复制中的 Slave 连接 Master</strong> 时使用的 <strong>客户端监听端口</strong>。<br>通常与 10909 配合使用，一主多从模式中 Slave 主动连接 Master。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"日志及数据存储路径\">日志及数据存储路径</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5 主要有三类服务组件需要关注它们的存储目录</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">组件</th>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">默认存储内容</th>\n<th style=\"text-align:left\">默认路径（Linux 环境）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>NameServer</strong></td>\n<td style=\"text-align:left\">路由服务（注册中心）</td>\n<td style=\"text-align:left\">各个组件的的注册</td>\n<td style=\"text-align:left\">日志文件：<code>~/logs/rocketmqlogs/namesrv.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.namesrv.logback.xml</code> <br> 配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/namesrv.conf</code>（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Broker</strong></td>\n<td style=\"text-align:left\">核心消息存储与转发服务</td>\n<td style=\"text-align:left\">消息数据（CommitLog、ConsumeQueue、Index、Config）<br><strong>目录结构：</strong><br>├── <code>commitlog/</code> → 消息物理文件<br>├── <code>consumequeue/</code> → 消费队列索引<br>├── <code>index/</code> → 消息索引<br>├── <code>config/</code> → topic、offset、subscription 信息<br>├── <code>checkpoint</code> → 存储校验点<br>├── <code>abort</code> → 异常退出标志</td>\n<td style=\"text-align:left\"><strong>数据目录</strong>：<code>~/store</code><br>日志文件：<code>~/logs/rocketmqlogs/broker.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.broker.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/broker.conf</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Proxy</strong></td>\n<td style=\"text-align:left\">客户端访问入口层（无状态代理）<br>（5.x 新引入组件）</td>\n<td style=\"text-align:left\">转发日志、访问日志</td>\n<td style=\"text-align:left\">日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.proxy.logback.xml</code><br>日志文件：<code>~/logs/rocketmqlogs/proxy.log</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq-proxy.json</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Controller</strong></td>\n<td style=\"text-align:left\"><strong>Broker 主从协调与高可用管理</strong><br>（5.x 新引入组件）</td>\n<td style=\"text-align:left\">- 集群主从元数据（主从关系、broker注册信息）<br>- Controller 自身运行状态与选举元数据</td>\n<td style=\"text-align:left\"><strong>数据目录</strong>：<code>~/store/controller</code><br>日志文件：<code>~/logs/rocketmqlogs/controller.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.controller.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/controller.conf</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NameServer 和 Proxy 都是无状态（stateless）组件，不会持久化业务数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Broker 数据路径说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置项</th>\n<th style=\"text-align:left\">默认路径</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">主要作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>storePathRootDir</strong></td>\n<td style=\"text-align:left\"><code>/home/rocketmq/store</code><br>（默认）</td>\n<td style=\"text-align:left\">消息存储的根目录</td>\n<td style=\"text-align:left\">作为所有存储文件的父级目录，其他路径若未单独配置，则在此目录下创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathCommitLog</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/commitlog</code></td>\n<td style=\"text-align:left\">CommitLog 文件存放路径</td>\n<td style=\"text-align:left\">存储消息主体内容，是最核心的数据文件（顺序写入）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathConsumeQueue</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/consumequeue</code></td>\n<td style=\"text-align:left\">消费队列文件存放路径</td>\n<td style=\"text-align:left\">存储消息在队列中的索引（逻辑队列），指向 CommitLog 的物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathIndex</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/index</code></td>\n<td style=\"text-align:left\">索引文件存放路径</td>\n<td style=\"text-align:left\">提供按 Key 查询消息的索引结构，便于通过 Message Key 快速检索消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathConfig</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/config</code></td>\n<td style=\"text-align:left\">Broker 运行时配置存储路径</td>\n<td style=\"text-align:left\">存储运行时生成的配置文件，如 topic、consumerOffset、subscriptionGroup 等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeCheckpoint</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/checkpoint</code></td>\n<td style=\"text-align:left\">Checkpoint 文件路径</td>\n<td style=\"text-align:left\">记录 CommitLog、ConsumeQueue、Index 三者的刷盘进度，用于崩溃恢复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>abortFile</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/abort</code></td>\n<td style=\"text-align:left\">异常退出标志文件路径</td>\n<td style=\"text-align:left\">用于标识 Broker 是否异常退出，启动时据此判断是否执行恢复流程</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"安装过程中遇到的问题\">安装过程中遇到的问题</h2>\n<h3 id=\"1-启动-Proxy-失败\">1.启动 Proxy 失败</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无论是 <code>Broker+Proxy</code> 启动，还是 单独启动 <code>Proxy</code>，都报如下错误：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 错误会在 nohup.out 中输出</span></span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.UnsatisfiedLinkError: failed to load the required native library</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64_fedora, netty_tcnative_linux_x86_64, netty_tcnative_x86_64, netty_tcnative]</span><br><span class=\"line\"></span><br><span class=\"line\">Suppressed: java.lang.UnsatisfiedLinkError: /tmp/libnetty_tcnative_linux_x86_642308675901892111861.so: libcrypt.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>原因分析</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">\n<ol>\n<li class=\"lvl-7\">Netty-tcnative 的编译依赖：RocketMQ 使用的 Netty 的 tcnative 模块是在较旧的环境中编译的，而动态链接的版本锁定：编译时链接的是 libcrypt.so.1，运行时必须找到相同主版本号的库</li>\n</ol>\n</li>\n<li class=\"lvl-4\">\n<ol start=\"2\">\n<li class=\"lvl-7\">而我当前使用的系统为 Amazon Linux 2023，基于更新的 glibc，其加密功能已经迁移到 libcrypt.so.2。（Amazon Linux 2：基于较旧的 glibc 版本，libcrypt.so.1 是主要的加密库）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检查 libcrypt 是否存在</span></span><br><span class=\"line\">$ ldconfig -p | grep libcrypt</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class=\"line\">\tlibcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class=\"line\">\tlibcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class=\"line\">\tlibcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class=\"line\">\tlibcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决办法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装兼容性包</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install libxcrypt-compat</span><br><span class=\"line\"><span class=\"comment\"># 检查 libcrypt 是否存在</span></span><br><span class=\"line\">$ ldconfig -p | grep libcrypt</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class=\"line\">\tlibcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class=\"line\">\tlibcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class=\"line\">\tlibcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class=\"line\">\tlibcrypt.so.1 (libc6,x86-64) =&gt; /lib64/libcrypt.so.1</span><br><span class=\"line\">\tlibcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-写入消息失败，并报如下错误\">2.写入消息失败，并报如下错误</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.rocketmq.client.exception.MQBrokerException: CODE: 14 DESC: service not available now. It may be caused by one of the following reasons: the broker<span class=\"string\">&#x27;s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00], messages are put to the slave, message store has been shut down, etc. BROKER: 10.250.0.175:10911</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>错误原因</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">RocketMQ 返回的 CODE: 14 表示：Broker 当前 不接受消息写入（服务暂不可用）。</li>\n<li class=\"lvl-4\">the broker’s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00]: Broker 的磁盘已满</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CL: 0.95 → CommitLog 95% 已使用</span><br><span class=\"line\">CQ: 0.95 → ConsumeQueue 95% 已使用</span><br><span class=\"line\">INDEX: -1.00 → 索引异常或未采集</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>含义</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>diskMaxUsedSpaceRatio</code></td>\n<td>Broker 磁盘最大可用比例（超过后禁止写入）</td>\n<td><strong>75%</strong></td>\n</tr>\n<tr>\n<td><code>storePathCommitLog</code></td>\n<td>消息存储路径（CommitLog）</td>\n<td><code>~/store/commitlog</code></td>\n</tr>\n<tr>\n<td><code>storePathConsumeQueue</code></td>\n<td>消费队列路径（ConsumeQueue）</td>\n<td><code>~/store/consumequeue</code></td>\n</tr>\n<tr>\n<td><code>storePathIndex</code></td>\n<td>索引路径</td>\n<td><code>~/store/index</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-4\">\n<p>总结：可以确认是 磁盘使用率过高 导致 Broker 自动进入 “写保护” 模式。</p>\n</li>\n</ul>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<ol>\n<li class=\"lvl-9\">清理磁盘：确认磁盘使用率过高，并清理磁盘空间，既降低磁盘使用率</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"2\">\n<li class=\"lvl-9\">磁盘扩容：如果清理磁盘空间后，磁盘使用率依然过高，则需要扩容磁盘</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"3\">\n<li class=\"lvl-9\">配置调整：调整 Broker 配置(<code>broker.conf</code>)，将 <code>diskMaxUsedSpaceRatio</code> 配置适当提高，如 96%(<code>diskMaxUsedSpaceRatio=96</code>)，调整后重启 Broker。仅建议在紧急情况下临时解决。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 RocketMQ 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 Apache RocketMQ 简介 一、RocketMQ 是什么？ RocketMQ 是一个分布式、队列模型的消息中间件。它由阿里巴巴在2012年开源，并于2017年正式成为 Apache 基金会的顶级项目。 你可以把它想象成一个在分布式系统中负责可靠传递消息的“邮局”或“快递系统”。当系统A需要发送数据给系统B，但它们之间不直接通信时，就可以通过 RocketMQ 来中转，确保消息不丢失、不重复，并且能按顺序送达。 RocketMQ 是一个高性能、高可靠、高实时的分布式消息中间件。它就像分布式系统的“中枢神经系统”，负责在各个服务之间可靠、高效地传递数据，是现代互联网架构中不可或缺的基础组件之一。 RocketMQ 5.x 通过引入 Proxy 模式，极大地提升了架构的灵活性、多语言支持能力和云原生亲和力，是其在消息中间件领域持续演进的重要里程碑。 它与 Kafka、RabbitMQ 等都是业界顶级的消息队列，但各有侧重。RocketMQ 在事务消息、顺序消息和对在线业务的稳定性支持方面表现尤为出色。 二、核心特点与优势 序号 特性 典型场景 主要作用 1 削峰填谷 电商秒杀、大促活动时大量下单请求瞬间涌入 将突发请求先缓存为消息，后端系统按自身能力平稳消费，避免系统过载崩溃 2 异步解耦 用户注册后触发多系统任务（邮件、优惠券、积分） 主流程只负责发送消息，其他系统独立异步处理，降低系统间耦合、提高扩展性 3 顺序消息 订单状态变更（创建 → 付款 → 发货 → 收货） 同一业务键（如订单ID）的消息按顺序发送和消费，保证业务逻辑正确性 4 持久化与高可靠性 关键业务消息必须不丢失（交易、支付、日志） 所有消息写入磁盘并支持主从复制，即使服务器重启也能恢复，保证高可用 5 消息回溯 消费逻辑出错、数据重算、补偿任务 支持重置消费位点，重新消费历史消息，实现业务补偿与追溯 6 海量消息堆积能力 大规模异步日志收集、IoT 数据汇聚、埋点分析 支持万亿级消息堆积，性能稳定不衰减，适用于大规模数据场景 三、核心架构与概念 要理解 RocketMQ，需要知道几个关键角色： 经典核心组件 序号 组件名称 主要作用 说明 / 特点 1 Producer（生产者） 发送消息的客户端 负责将业务系统的消息发送到指定的 Topic，支持同步、异步、单向三种发送方式 2 Consumer（消费者） 接收并消费消息的客户端 从 Broker 拉取消息并进行业务处理，可分为 Push 和 Pull 两种消费模式 3 Consumer Group（消费者组） 实现负载均衡与高可用消费 多个消费者订阅同一 Topic 时组成消费者组，一个分区只会被组内一个消费者消费 4 Broker（消息服务器） 存储和转发消息 RocketMQ 的核心组件，负责消息的持久化、转发、主从复制和高可用 5 Topic（主题） 消息的分类与路由单元 Producer 发送消息到指定 Topic，Consumer 订阅 Topic 消费消息；一个 Topic 可包含多个消息队列（分区） 6 Name Server（名字服务） 管理 Broker 地址信息 类似轻量级注册中心，维护 Broker 元数据，帮助 Producer 和 Consumer 定位消息存储位置 7 Controller（控制器） 主从自动切换与高可用控制 RocketMQ 5.x 引入，基于 Raft（DLedger）协议实现 Broker 自动选主和元数据管理 8 Proxy（代理层） 客户端访问入口与协议转换 RocketMQ 5.x 新组件，无状态，可横向扩展；统一接入层，支持多协议（如 HTTP、gRPC），隔离客户端与 Broker 引入 Proxy 模式的优势： 1234**架构解耦与语言无关**：Proxy 作为通用代理，将复杂的 Broker 协议封装成更简单的接口（如 gRPC），使得用不同编程语言（如 Go, Python, C++ 等）开发的客户端更容易接入，而无需实现复杂的原生协议。**简化客户端**：客户端不再需要感知 Name Server 和 Broker 的地址变化，只需连接固定的 Proxy 地址即可，大大降低了客户端的复杂度。**增强安全性**：可以在 Proxy 层统一实现安全认证、限流、审计等策略，作为Broker集群的安全屏障。**云原生友好**：无状态的 Proxy 非常适合在 Kubernetes 等容器化环境中进行部署和弹性伸缩。 消息中间件功能对比表（ActiveMQ vs Kafka vs RabbitMQ vs RocketMQ） 参考资料 功能项 ActiveMQ Kafka RabbitMQ RocketMQ 客户端 SDK Java、.NET、C++ 等 Java、Scala 等 Java、.NET、Go、Python、C 等 Java、C++、Go 通信协议与规范 推送模型（Push），支持 OpenWire、STOMP、AMQP、MQTT、JMS 拉取模型（Pull），支持 TCP 推送模型（Push），支持 AMQP、MQTT、STOMP、HTTP、WebSocket 拉取模型（Pull），支持 TCP、JMS、OpenMessaging 消息有序性 通过独占消费者（Exclusive Consumer）或独占队列（Exclusive Queues）保证顺序 保证分区内消息顺序 单队列内消息天然有序 严格顺序消息，可平滑扩展 定时/延迟消息 支持 不支持 支持（使用延迟插件） 支持 批量消息 不支持 支持（异步生产者） 支持（Publisher Confirms 模式下） 支持（同步模式可避免消息丢失） 广播消息 支持 不支持 支持（Fanout 交换机） 支持 消息过滤 支持 支持（可用 Kafka Streams 实现） 支持（基于 Exchange 的路由键或 Header） 支持（基于 SQL92 属性过滤） 服务器端触发重投递 不支持 不支持 支持（Nack 或 TTL+DLX） 支持 消息存储 支持高性能持久化（JDBC + LevelDB/KahaDB） 高性能文件存储 内存+磁盘混合存储（Mnesia/基于 Erlang 的日志） 高性能、低延迟文件存储 消息回溯（历史消息查询） 支持 支持（通过 offset） 不支持（消息被消费后无法回溯） 支持（时间戳与 offset） 消息优先级 支持 不支持 支持（优先级队列） 不支持 高可用与故障转移 依赖存储，如 LevelDB 需 ZooKeeper 需要 ZooKeeper 支持镜像队列（Classic / Quorum 模式） 支持主从模式（无需额外组件） 消息轨迹（Message Track） 不支持 不支持 不支持（可通过插件扩展） 支持 配置复杂度 默认配置较低，需手动优化 配置为键值对，可文件或代码提供 开箱即用，配置灵活但选项较多 开箱即用，仅需关注少量配置 管理与运维工具 支持 支持（命令行监控） 支持（Web 管理控制台、CLI） 支持（丰富的 Web 与命令行工具） RocketMQ 的安装 RocketMQ 5.x 依赖 JDK 1.8+。 单机安装 官方文档 下载RocketMQ 12345mkdir -p /usr/local/soft/rocketmq/wget https://dist.apache.org/repos/dist/release/rocketmq/5.3.2/rocketmq-all-5.3.2-bin-release.zipunzip rocketmq-all-5.3.2-bin-release.zipln -s rocketmq-all-5.3.2-bin-release rocketmq5cd rocketmq5 小贴士 默认脚本中，NameServer需要4G内存，Broker 需要8G内存，如果内存不够，可以进入bin目录，对其中的runserver.sh和runbroker.sh两个脚本进行一下修改 12345678910# 使用vi runserver.sh指令，编辑这个脚本，找到下面的一行配置，调整Java进程的内存大小。# NameServer,Controller,Proxy 都使用这个脚本启动JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;修改为：JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;# 接下来，同样调整runbroker.sh中的内存大小。Broker 使用这个脚本启动JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot;修改为：JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g&quot; 启动 NameServer 安装完RocketMQ包后，我们启动NameServer 123456789### 启动namesrv$ nohup sh bin/mqnamesrv &amp;## 指定配置文件$ nohup sh bin/mqnamesrv -c namesrv.conf &amp;### 验证namesrv是否启动成功$ tail -f ~/logs/rocketmqlogs/namesrv.log# 我们可以在namesrv.log 中看到 &#x27;The Name Server boot success..&#x27;， 表示NameServer 已成功启动。The Name Server boot success. serializeType=JSON, address 0.0.0.0:9876 namesrv.conf 示例 12# The port of nameserverlistenPort = 9876 启动 Broker+Proxy NameServer成功启动后，我们启动Broker和Proxy。这里我们使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。 1234567891011121314151617### 先启动broker$ nohup sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;# 指定配置文件， 默认就是 conf/broker.conf$ nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf --enable-proxy &amp;# 上面的启动方式与下面的启动方式效果一样$ nohup sh bin/mqproxy -n localhost:9876 -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json -bc /usr/local/soft/rocketmq/rocketmq5/conf/broker.conf -pm local &amp;## 参数说明# -n, --namesrvAddr NameServer 的地址# -pc, --proxyConfigPath Proxy 配置文件路径# -bc, --brokerConfigPath Broker 配置文件路径# -pm, --proxyMode Proxy 模式，local or cluster### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a$ tail -f ~/logs/rocketmqlogs/proxy.log# 我们可以在 proxy.log 中看到“The broker[brokerName,ip:port] boot success..”，这表明 broker 已成功启动。The broker[broker-a, 10.250.0.175:10911] boot success. serializeType=JSON and name server is localhost:9876 关闭服务器 1234# 先停止 Broker$ sh bin/mqshutdown broker# 停止 NameServer$ sh bin/mqshutdown namesrv 集群安装:多节点（集群）多副本模式-异步复制 官网文档 对集群安装的方式介绍了多种，本文仅实战一种：多节点（集群）多副本模式-异步复制 每个Master配置一个Slave，有多组 Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下： 优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样； 缺点：Master宕机，磁盘损坏情况下会丢失少量消息。 该模式下，Master 节点和 Slave 节点之间是异步复制的，Master 节点挂掉后，Slave 节点不会自动切换为 Master 节点。 集群规划 12345678910111213# NameServer 3 台NameServer1 10.250.0.175NameServer2 10.250.0.188NameServer3 10.250.0.31# Broker 2 Master 2 ReplicasBroker1 10.250.0.188 broker-a,broker-b-sBroker2 10.250.0.31 broker-b,broker-a-s# Proxy 3 台Proxy1 10.250.0.175Proxy2 10.250.0.188Proxy3 10.250.0.31 部署 NameServer 在三台服务器上分别启动RocketMQ NameServer 12cd /usr/local/soft/rocketmq/rocketmq5nohup sh bin/mqnamesrv &amp; 部署Broker broker-a.properties 12345678910111213141516171819brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-a # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=0 # brokerId 必须唯一 ，且 master 的 brokerId 必须为 0deleteWhen=04 # 表示凌晨 4 点清理fileReservedTime=48 # 表示保存 48 小时的数据brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点flushDiskType=ASYNC_FLUSH # 表示异步刷盘# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径，后面会介绍storePathRootDir=/usr/local/soft/rocketmq/data/store-astorePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-a/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-a/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpointabortFile=/usr/local/soft/rocketmq/data/store-a/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=10911 broker-a-s.properties 12345678910111213141516171819brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-a # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0deleteWhen=04fileReservedTime=48brokerRole=SLAVE # 角色，表示异步复制的从节点flushDiskType=ASYNC_FLUSH# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-astorePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-a/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-a/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpointabortFile=/usr/local/soft/rocketmq/data/store-a/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=11011 broker-b.properties 1234567891011121314151617181920brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-b # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=0 # brokerId 必须唯一 ，且 master 的 brokerId 必须为 0deleteWhen=04 # 表示凌晨 4 点清理fileReservedTime=48 # 表示保存 48 小时的数据brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点flushDiskType=ASYNC_FLUSH # 表示异步刷盘# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-bstorePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-b/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-b/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpointabortFile=/usr/local/soft/rocketmq/data/store-b/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=10911 broker-b-s.properties 1234567891011121314151617181920brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-b # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0deleteWhen=04fileReservedTime=48brokerRole=SLAVE # 角色，表示异步复制的从节点flushDiskType=ASYNC_FLUSH# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-bstorePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-b/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-b/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpointabortFile=/usr/local/soft/rocketmq/data/store-b/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=11011 在 Broker1 10.250.0.188 上启动 broker-a 和 broker-b-s 1234567# 启动 broker-anohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-a.properties &amp;# 启动 broker-b-snohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-b-s.properties &amp;## nohup.out 中的输出类似与下面这种就表示启动成功The broker[broker-a, 10.250.0.31:11011] boot success. serializeType=JSON and name server is 10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876 在 Broker2 10.250.0.31 上启动 broker-b 和 broker-a-s 1234# 启动 broker-bnohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-b.properties &amp;# 启动 broker-a-snohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-a-s.properties &amp; 启动成功后，可以通过如下命令检查机器状态 12345678# 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489250.72 0.2900 trueDefaultCluster broker-a 1 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489250.72 0.2600 falseDefaultCluster broker-b 0 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489250.72 0.2600 trueDefaultCluster broker-b 1 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489250.72 0.2900 false 配置 Proxy 在三台服务器上分别启动RocketMQ NameServer 12345678nohup sh bin/mqproxy -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; &amp;## 指定配置文件，这里要注意，集群的名称要与 conf/rmq-proxy.json 中配置的集群名称必须一致，默认是 DefaultCluster## 默认的配置文件就是 conf/rmq-proxy.json，但如果通过 -pc 指定配置文件，则必须使用绝对路径nohup sh bin/mqproxy -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json &amp;## 查看日志，输出如下内容就表示启动成功，tail -f nohup.outrocketmq-proxy startup successfully rmq-proxy.json 示例 12345&#123; &quot;rocketMQClusterName&quot;: &quot;DefaultCluster&quot;, # 集群名称 &quot;remotingListenPort&quot;: 8080, # 监听端口，默认 8080 &quot;grpcServerPort&quot;: 8081 # grpc 监听端口，默认 8081&#125; 停止Proxy 12# 停止 Proxysh bin/mqshutdown proxy 集群安装:主备自动切换模式部署 RocketMQ 5.x 提供了一种新的部署方式 Controller，可以在主从模式下实现主备自动切换，当主节点挂掉时，自动切换到从节点上运行。 官方文档:主备自动切换模式部署 Controller 组件提供选主能力，若需要保证 Controller 具备容错能力，Controller 部署需要三副本及以上（遵循 Raft 的多数派协议）。 本文在上文“集群安装:多节点（集群）多副本模式-异步复制”的基础上进行修改 Controller 部署有两种方式。一种是嵌入于 NameServer 进行部署，另一种是独立部署，本文采用独立部署 Controller 组件的方式。 集群规划 1234# Controller 3 台Controller1 10.250.0.175Controller2 10.250.0.188Controller3 10.250.0.31 分别在每台机器上创建controller.conf配置文件，内容如下(注意修改节点Id) 1234567891011121314151617# controller.conf# ---------------------------------------------------------# DLedger Raft Group 的名字，同一集群保持一致controllerDLegerGroup = group1# 集群中三个节点的成员定义，每个节点都必须一致controllerDLegerPeers = n0-10.250.0.175:9877;n1-10.250.0.188:9877;n2-10.250.0.31:9877# 节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一controllerDLegerSelfId = n0# Controller 数据存储路径（非常关键！不要删除）controllerStorePath = /usr/local/soft/rocketmq/data/DledgerController# 是否允许从 SyncStateSet 外选举 Master# true 会加快选举但可能丢消息，建议生产保持 falseenableElectUncleanMaster = false# 当 Broker 副本角色变化时是否主动通知（建议开启）notifyBrokerRoleChanged = true# 启动端口，端口不能与 NameServer、Broker、Proxy 端口冲突listenPort = 9877 分别启动每台机器上的 Controller 1234nohup sh bin/mqcontroller -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/controller.conf &amp;## 启动成功后，查看 nohup.out 文件，输出如下内容就表示启动成功load config properties file OK, conf/controller.confThe Controller Server boot success. serializeType=JSON 修改 broker 配置文件，以 broker-a.properties 为例 123456789# 去掉如下配置，Controller 模式下 会自动分配# brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0# brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点# 添加如下配置# 启用 Controller 模式（自动主从切换模式的总开关）enableControllerMode = true# Controller 集群地址列表（建议与 Controller 集群保持一致）controllerAddr = 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877 RocketMQ 5 Broker Controller 模式配置参数表 参数名 说明 默认值 备注 / 建议 enableControllerMode 是否启用 Controller 模式（自动主从切换总开关） false 必须设为 true 才能启用自动主从切换 controllerAddr Controller 集群地址列表（以分号分隔） 无 所有 Broker 配置应一致，例如 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877 syncBrokerMetadataPeriod 向 Controller 同步 Broker 副本信息的时间间隔（毫秒） 5000 (5s) 保持默认即可；用于上报心跳与元数据 checkSyncStateSetPeriod 检查同步状态集（SyncStateSet）的时间间隔（毫秒） 5000 (5s) Controller 会定期剔除落后副本 syncControllerMetadataPeriod 同步 Controller 元数据的时间间隔（毫秒） 10000 (10s) Broker 定期从集群获取当前活跃 Controller 地址 haMaxTimeSlaveNotCatchup Slave 未跟上 Master 的最大时间间隔（毫秒） 15000 (15s) 超过该时间将 Slave 移出 SyncStateSet storePathEpochFile Epoch 文件存储路径 store/epochFile 非常重要！不要删除；存储主从任期、epoch 等元信息 allAckInSyncStateSet 是否要求所有同步副本都 ACK 后才返回成功 false true 可保证强一致但性能下降；建议保持默认 syncFromLastFile Slave 是否从最后一个文件开始复制（空盘启动时） false 若历史日志很大且 Slave 新建，可设为 true asyncLearner 是否为异步 learner 副本（不参与选主） false 用于远程灾备副本，不会被选举为 Master inSyncReplicas 需保持同步的副本组数量 1 若 allAckInSyncStateSet=true，该参数无效 minInSyncReplicas 最小同步副本数量，低于该值则拒绝写入 1 防止写入过多未同步副本导致数据丢失风险 重新启动 Broker，为保证主从数据一致性在重启时不被破坏，启动顺序应为先重新原Master，再重启原Slave 启动成功后，可以通过如下命令检查机器状态，可以看到集群内部自动分配了主从 12345678# 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.48 0.2900 trueDefaultCluster broker-a 2 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 2-0(0.0w, 0.0, 0.0) 0 489268.48 0.2700 falseDefaultCluster broker-b 0 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.48 0.2700 trueDefaultCluster broker-b 2 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489268.48 0.2900 false 验证主备自动切换，此时关闭 broker-b 的 Master，并查看集群状态 123456sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下，可以看到`broker-b`原来的 Slave 被切换为 Master#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.58 0.2900 trueDefaultCluster broker-a 2 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 489268.58 0.2700 falseDefaultCluster broker-b 0 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.58 0.2900 true 重新启动刚才关闭的 broker-b ，节点会自动加入集群，角色为 Slave 停止 Controller 12# 停止 PrControlleroxysh bin/mqshutdown controller 端口说明 端口号 协议 组件/服务 作用说明 9876 TCP NameServer RocketMQ 集群的 NameServer 服务端口。用于 Broker 注册、客户端路由发现。Producer/Consumer 连接此端口以获取 Broker 地址。 8080 TCP Proxy (gRPC / HTTP) RocketMQ 5 引入的 Proxy 服务 默认端口之一。用于 HTTP/gRPC 客户端接入，例如 RocketMQ Proxy REST API、异步消息接口等。 8081 TCP Proxy Admin / Dashboard / gRPC Alt 通常是 Proxy 的 管理接口 或 gRPC 辅助端口（依配置而定）。也可能是控制面接口，用于与 Console 或控制工具通信。 10909 TCP Broker HA (High Availability) Broker 主从同步端口（Master ↔ Slave 之间的数据复制）。用于消息数据与元数据的同步。 10911 TCP Broker 服务端口 Broker 的 主通信端口，客户端连接发送消息、消费消息、心跳等。Producer 和 Consumer 通过 NameServer 获取该端口地址后进行通信。 10912 TCP Broker HA 客户端端口 Broker 主从复制中的 Slave 连接 Master 时使用的 客户端监听端口。通常与 10909 配合使用，一主多从模式中 Slave 主动连接 Master。 日志及数据存储路径 RocketMQ 5 主要有三类服务组件需要关注它们的存储目录 组件 功能 默认存储内容 默认路径（Linux 环境） NameServer 路由服务（注册中心） 各个组件的的注册 日志文件：~/logs/rocketmqlogs/namesrv.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.namesrv.logback.xml 配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/namesrv.conf（可选） Broker 核心消息存储与转发服务 消息数据（CommitLog、ConsumeQueue、Index、Config）目录结构：├── commitlog/ → 消息物理文件├── consumequeue/ → 消费队列索引├── index/ → 消息索引├── config/ → topic、offset、subscription 信息├── checkpoint → 存储校验点├── abort → 异常退出标志 数据目录：~/store日志文件：~/logs/rocketmqlogs/broker.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.broker.logback.xml配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/broker.conf Proxy 客户端访问入口层（无状态代理）（5.x 新引入组件） 转发日志、访问日志 日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.proxy.logback.xml日志文件：~/logs/rocketmqlogs/proxy.log配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/rmq-proxy.json Controller Broker 主从协调与高可用管理（5.x 新引入组件） - 集群主从元数据（主从关系、broker注册信息）- Controller 自身运行状态与选举元数据 数据目录：~/store/controller日志文件：~/logs/rocketmqlogs/controller.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.controller.logback.xml配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/controller.conf NameServer 和 Proxy 都是无状态（stateless）组件，不会持久化业务数据。 Broker 数据路径说明 配置项 默认路径 说明 主要作用 storePathRootDir /home/rocketmq/store（默认） 消息存储的根目录 作为所有存储文件的父级目录，其他路径若未单独配置，则在此目录下创建 storePathCommitLog $&#123;storePathRootDir&#125;/commitlog CommitLog 文件存放路径 存储消息主体内容，是最核心的数据文件（顺序写入） storePathConsumeQueue $&#123;storePathRootDir&#125;/consumequeue 消费队列文件存放路径 存储消息在队列中的索引（逻辑队列），指向 CommitLog 的物理位置 storePathIndex $&#123;storePathRootDir&#125;/index 索引文件存放路径 提供按 Key 查询消息的索引结构，便于通过 Message Key 快速检索消息 storePathConfig $&#123;storePathRootDir&#125;/config Broker 运行时配置存储路径 存储运行时生成的配置文件，如 topic、consumerOffset、subscriptionGroup 等 storeCheckpoint $&#123;storePathRootDir&#125;/checkpoint Checkpoint 文件路径 记录 CommitLog、ConsumeQueue、Index 三者的刷盘进度，用于崩溃恢复 abortFile $&#123;storePathRootDir&#125;/abort 异常退出标志文件路径 用于标识 Broker 是否异常退出，启动时据此判断是否执行恢复流程 安装过程中遇到的问题 1.启动 Proxy 失败 无论是 Broker+Proxy 启动，还是 单独启动 Proxy，都报如下错误： 123456# 错误会在 nohup.out 中输出Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: failed to load the required native libraryCaused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64_fedora, netty_tcnative_linux_x86_64, netty_tcnative_x86_64, netty_tcnative]Suppressed: java.lang.UnsatisfiedLinkError: /tmp/libnetty_tcnative_linux_x86_642308675901892111861.so: libcrypt.so.1: cannot open shared object file: No such file or directory 原因分析 Netty-tcnative 的编译依赖：RocketMQ 使用的 Netty 的 tcnative 模块是在较旧的环境中编译的，而动态链接的版本锁定：编译时链接的是 libcrypt.so.1，运行时必须找到相同主版本号的库 而我当前使用的系统为 Amazon Linux 2023，基于更新的 glibc，其加密功能已经迁移到 libcrypt.so.2。（Amazon Linux 2：基于较旧的 glibc 版本，libcrypt.so.1 是主要的加密库） 12345678# 检查 libcrypt 是否存在$ ldconfig -p | grep libcrypt## 输出 libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12 libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3 libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2 libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so 解决办法 1234567891011# 安装兼容性包sudo yum install libxcrypt-compat# 检查 libcrypt 是否存在$ ldconfig -p | grep libcrypt## 输出 libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12 libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3 libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2 libcrypt.so.1 (libc6,x86-64) =&gt; /lib64/libcrypt.so.1 libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so 2.写入消息失败，并报如下错误 1Caused by: org.apache.rocketmq.client.exception.MQBrokerException: CODE: 14 DESC: service not available now. It may be caused by one of the following reasons: the broker&#x27;s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00], messages are put to the slave, message store has been shut down, etc. BROKER: 10.250.0.175:10911 错误原因 RocketMQ 返回的 CODE: 14 表示：Broker 当前 不接受消息写入（服务暂不可用）。 the broker’s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00]: Broker 的磁盘已满 123CL: 0.95 → CommitLog 95% 已使用CQ: 0.95 → ConsumeQueue 95% 已使用INDEX: -1.00 → 索引异常或未采集 配置项 含义 默认值 diskMaxUsedSpaceRatio Broker 磁盘最大可用比例（超过后禁止写入） 75% storePathCommitLog 消息存储路径（CommitLog） ~/store/commitlog storePathConsumeQueue 消费队列路径（ConsumeQueue） ~/store/consumequeue storePathIndex 索引路径 ~/store/index 总结：可以确认是 磁盘使用率过高 导致 Broker 自动进入 “写保护” 模式。 解决方法 清理磁盘：确认磁盘使用率过高，并清理磁盘空间，既降低磁盘使用率 磁盘扩容：如果清理磁盘空间后，磁盘使用率依然过高，则需要扩容磁盘 配置调整：调整 Broker 配置(broker.conf)，将 diskMaxUsedSpaceRatio 配置适当提高，如 96%(diskMaxUsedSpaceRatio=96)，调整后重启 Broker。仅建议在紧急情况下临时解决。","summary":"摘要 本文介绍 CentOS9 中 RocketMQ 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-23T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/","url":"https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/","title":"Kafka 从 Zookeeper 迁移到 KRaft","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org/39/documentation.html#kraft_zk_migration\">官方文档：ZooKeeper到KRaft迁移</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"从-Zookeeper-模式迁移到-KRaft-模式（平滑迁移）\">从 Zookeeper 模式迁移到 KRaft 模式（平滑迁移）</h2>\n<p><em><strong>！！！迁移后将无法再恢复到 ZooKeeper 模式！！！</strong></em></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 官方在 3.4+ 引入了完整的 Zookeeper → KRaft 平滑迁移机制，称为 <code>ZK to KRaft (ZkMigration)</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>迁移背景与前提</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">项目</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">支持版本</td>\n<td style=\"text-align:left\">Kafka <strong>3.4.0+</strong>（建议至少使用 <strong>3.6.x ，目前最新版为 3.9.x</strong>）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迁移目的</td>\n<td style=\"text-align:left\">摆脱 ZooKeeper，完全切换为 KRaft 自管理模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迁移模式</td>\n<td style=\"text-align:left\"><strong>在线迁移</strong>（无停机或最小停机）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">最终目标</td>\n<td style=\"text-align:left\">Kafka 的控制器与元数据完全由 KRaft 管理，不再依赖 ZooKeeper。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>整体迁移流程概览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>控制器类型</th>\n<th>Broker 模式</th>\n<th>ZooKeeper 角色</th>\n<th>KRaft 角色</th>\n<th>特征说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>初始阶段</strong></td>\n<td>ZooKeeper 控制器</td>\n<td>全部为 ZK 模式</td>\n<td>管理所有元数据</td>\n<td>尚未启用</td>\n<td>所有 Broker 都运行在 ZK 模式下，由 ZK 控制器管理集群。</td>\n</tr>\n<tr>\n<td><strong>初始元数据加载阶段</strong></td>\n<td>KRaft 控制器开始加载</td>\n<td>部分（或全部）仍为 ZK 模式</td>\n<td>提供元数据源</td>\n<td>从 ZK 加载元数据</td>\n<td>KRaft 法定节点（controller.quorum.voters）从 ZK 中读取并同步当前集群元数据。</td>\n</tr>\n<tr>\n<td><strong>混合阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>部分 ZK 模式，部分 KRaft 模式</td>\n<td>保留只读元数据</td>\n<td>管理并更新元数据</td>\n<td>KRaft 控制器成为主控，ZK 仍存在但只提供读取，Broker 可处于不同模式（混合状态）。</td>\n</tr>\n<tr>\n<td><strong>双写阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>全部为 KRaft 模式</td>\n<td>接收 KRaft 同步写入</td>\n<td>管理元数据并写入 ZK</td>\n<td>所有 Broker 都运行在 KRaft 模式，控制器将元数据同时写入 ZK 和 KRaft 日志。</td>\n</tr>\n<tr>\n<td><strong>迁移完成阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>全部为 KRaft 模式</td>\n<td>不再使用</td>\n<td>独立运行</td>\n<td>停止向 ZK 写入元数据，ZK 可安全关闭，Kafka 完全运行在无 Zookeeper 的 KRaft 模式下。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"开始迁移\">开始迁移</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里以前文 <a href=\"/2025/10/13/kafka-01-install-zookeeper/\" title=\"Kafka 的安装：基于 Zookeeper\">Kafka 的安装：基于 Zookeeper</a> 中的3个节点的集群为例。</p>\n</li>\n</ul>\n<h3 id=\"启动一个-Controller-节点\">启动一个 Controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在任意一个节点上启动一个 Controller 节点，这里为 worker1</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动前需要先获取当前 Kafka 集群的 Cluster ID</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ zookeeper-shell.sh localhost:2181 get /cluster/id</span><br><span class=\"line\">Connecting to localhost:2181</span><br><span class=\"line\"></span><br><span class=\"line\">WATCHER::</span><br><span class=\"line\"></span><br><span class=\"line\">WatchedEvent state:SyncConnected <span class=\"built_in\">type</span>:None path:null</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;version&quot;</span>:<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"string\">&quot;hp_Q0pihQ0ORcIvXlfHobQ&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>准备好 Controller 节点的配置文件，这里可以用 <code>config/kraft/controller.properties</code> 为模板进行修改</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色，这里只能是controller</span></span><br><span class=\"line\">process.roles=controller</span><br><span class=\"line\"><span class=\"comment\"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class=\"line\">node.id=3000</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点，因为我们当前只启动了一个controller节点，所以只能配置一个投票节点</span></span><br><span class=\"line\">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class=\"line\"><span class=\"comment\"># 配置监听器，注意端口不能重复</span></span><br><span class=\"line\">listeners=CONTROLLER://:9098</span><br><span class=\"line\">advertised.listeners=CONTROLLER://worker1:9098</span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"><span class=\"comment\"># 日志存放目录，这里存放的是元数据，在格式化时这个目录必须为空目录</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\">zookeeper.metadata.migration.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ZooKeeper client 连接</span></span><br><span class=\"line\">zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 其它参数尽量保持与旧集群的配置一致</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Controller 节点</p>\n</li>\n</ul>\n<blockquote>\n<p>千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 <a href=\"http://kafka-storage.sh\">kafka-storage.sh</a> format ，那会把原有数据结构重置或踩坏。<br>\n必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式化元数据目录，log.dirs 参数指定元数据存放目录，首次运行前必须为空目录</span></span><br><span class=\"line\"><span class=\"comment\"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class=\"line\">kafka-storage.sh format --standalone -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br><span class=\"line\"><span class=\"comment\"># 启动，这里没有后台启动是为了方便观察日志输出</span></span><br><span class=\"line\">kafka-server-start.sh /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>format 命令</th>\n<th>quorum 状态</th>\n<th>是否从 ZK 加载</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>迁移阶段（standalone）</td>\n<td><code>--standalone</code></td>\n<td>无（单节点）</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>正式 KRaft 模式</td>\n<td>无 <code>--standalone</code></td>\n<td>✅ 多节点</td>\n<td>❌ 否（独立运行）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将原先的三个节点作为-Broker-节点重新启动\">将原先的三个节点作为 Broker 节点重新启动</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改原先的配置文件 <code>server.properties</code>，只需要修改如下内容即可</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在最后加入 CONTROLLER:PLAINTEXT</span></span><br><span class=\"line\">listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,CONTROLLER:PLAINTEXT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 以下是新加入的 配置项</span></span><br><span class=\"line\"><span class=\"comment\"># Set the IBP，当前 kafka 版本是 3.9.1，所以这里设置为 3.9</span></span><br><span class=\"line\">inter.broker.protocol.version=3.9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\">zookeeper.metadata.migration.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># KRaft controller quorum configuration，因为目前只启动了一个 controller 节点，所以只能配置一个投票节点</span></span><br><span class=\"line\">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class=\"line\"><span class=\"comment\"># 控制器监听器名称，要与 contreller 节点配置文件 controller.properties 中的配置一致</span></span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别重新启动三个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 kafka</span></span><br><span class=\"line\">kafka-server-stop.sh</span><br><span class=\"line\"><span class=\"comment\"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class=\"line\">ps -ef | grep kafka | grep  <span class=\"string\">&quot;server\\.properties&quot;</span> | grep -v grep | awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span> -9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新启动 kafka</span></span><br><span class=\"line\">kafka-server-start.sh /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当三个节点都以必要的配置重新启动后，迁移将自动开始。迁移完成后，可以在 Controller(worker1)节点 上看到类似如下日志：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ✅ 意味：从 ZooKeeper 到 KRaft 的初始元数据迁移已成功，共写入 62 条记录，当前 KRaft metadata offset 为 3179。这是迁移成功的明确证据。</span></span><br><span class=\"line\">Completed migration of metadata from ZooKeeper to KRaft. 62 records were generated <span class=\"keyword\">in</span> 300 ms across 1 batches. The average time spent waiting on a batch was 97.00 ms. The record types were &#123;TOPIC_RECORD=3, PARTITION_RECORD=56, CONFIG_RECORD=3&#125;. The current metadata offset is now 3179 with an epoch of 2. Saw 3 brokers <span class=\"keyword\">in</span> the migrated metadata [1, 2, 3]. (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：控制器已加载并生效新元数据与 feature set（与 offset 3179 对应）。</span></span><br><span class=\"line\">Loaded new metadata Features(metadataVersion=3.9-IV0, finalizedFeatures=&#123;metadata.version=21&#125;, finalizedFeaturesEpoch=3179). (org.apache.kafka.metadata.publisher.FeaturesPublisher)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：内部迁移状态已更新，KRaft 上有了写入位置记录。</span></span><br><span class=\"line\">Finished initial migration of ZK metadata to KRaft <span class=\"keyword\">in</span> 3486479 ns. Transitioned migration state from ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=-1, kraftMetadataEpoch=-1, lastUpdatedTimeMs=1760682050169, migrationZkVersion=1, controllerZkEpoch=3, controllerZkVersion=3&#125; to ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=3179, kraftMetadataEpoch=2, lastUpdatedTimeMs=1760682050169, migrationZkVersion=2, controllerZkEpoch=3, controllerZkVersion=3&#125; (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：迁移流程按预期推进：先把 KRaft 的元数据与 ZK 对齐（sync），然后与 brokers 建立通信，最终进入 DUAL_WRITE（双写）。DUAL_WRITE 阶段表示控制器在写入 KRaft metadata log 的同时，仍然会把必要的写操作也写回 ZooKeeper（双写）——直到迁移完全完成并确认可以停止写 ZK 为止。</span></span><br><span class=\"line\">3000 transitioning from ZK_MIGRATION to SYNC_KRAFT_TO_ZK state</span><br><span class=\"line\">...</span><br><span class=\"line\">Performing a full metadata <span class=\"built_in\">sync</span> from KRaft to ZK.</span><br><span class=\"line\">Did not make any ZK writes when reconciling with KRaft state.</span><br><span class=\"line\">3000 transitioning ... to KRAFT_CONTROLLER_TO_BROKER_COMM</span><br><span class=\"line\">...</span><br><span class=\"line\">Sending RPCs to broker before moving to dual-write mode using at offset and epoch OffsetAndEpoch(offset=3179, epoch=2)</span><br><span class=\"line\">...</span><br><span class=\"line\">3000 transitioning ... to DUAL_WRITE state</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面的日志总体上表明，元数据迁移已成功完成并且控制器进入了双写（DUAL_WRITE）阶段。</p>\n</li>\n</ul>\n<h3 id=\"将三个Broker节点的配置修改为-KRaft-模式的-broker-节点\">将三个Broker节点的配置修改为 KRaft 模式的 broker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改三个节点的配置文件 <code>server.properties</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加process.roles=broker</span></span><br><span class=\"line\">process.roles=broker</span><br><span class=\"line\"><span class=\"comment\"># 用 node.id 替换 broker.id，注意，node.id 需要与 broker.id 一致</span></span><br><span class=\"line\"><span class=\"comment\"># broker.id=1</span></span><br><span class=\"line\">node.id=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 去掉 zookeeper 相关配置</span></span><br><span class=\"line\"><span class=\"comment\"># Don&#x27;t set the IBP, KRaft uses &quot;metadata.version&quot; feature flag</span></span><br><span class=\"line\"><span class=\"comment\"># inter.broker.protocol.version=3.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Remove the migration enabled flag</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.metadata.migration.enable=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Remove ZooKeeper client configuration</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别重新启动三个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 kafka</span></span><br><span class=\"line\">kafka-server-stop.sh</span><br><span class=\"line\"><span class=\"comment\"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class=\"line\">ps -ef | grep kafka | grep  <span class=\"string\">&quot;server\\.properties&quot;</span> | grep -v grep | awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span> -9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新启动 kafka</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n<h3 id=\"将-Controller-节点的配置修改为-KRaft-模式的-controller-节点\">将 Controller 节点的配置修改为 KRaft 模式的 controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改 controller 节点的配置文件 <code>controller.properties</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 去掉去下内容</span></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.metadata.migration.enable=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ZooKeeper client 连接</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启启动 controller 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭后重新启动</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时你可以关闭 zookeeper 集群了，新的 kafka 集群将不再使用 ZooKeeper，也无法在恢复到 ZooKeeper 模式。</p>\n</li>\n</ul>\n<h3 id=\"加入新的-Controller-节点\">加入新的 Controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Controller 尽量保持 奇数个节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之前已经在 <code>worker1</code> 节点上启动了 controller ，现在 <code>worker2</code> 和 <code>worker3</code> 上也来启动 controller 节点，并将它们加入到 kafka 集群中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在开始配置前，先将上面的 controller 节点 和 三个 broker 节点 的如下配置进行修改，并重启启动。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 controller.quorum.bootstrap.servers 替换为 controller.quorum.voters</span></span><br><span class=\"line\">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.bootstrap.servers=worker1:9098</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.voters = 谁是正式投票成员（固定配置）</span></span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.bootstrap.servers = 临时找谁引导连接（迁移或初始化用）</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n<th>适用阶段</th>\n<th>是否必需</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>controller.quorum.voters</code></strong></td>\n<td>定义 <strong>正式的 KRaft 控制器投票成员列表（voter set）</strong></td>\n<td>集群正常运行时</td>\n<td>✅ 是</td>\n<td>所有节点必须配置相同的值</td>\n</tr>\n<tr>\n<td><strong><code>controller.quorum.bootstrap.servers</code></strong></td>\n<td>定义 <strong>迁移阶段或初始化阶段的控制器连接地址（bootstrap controller endpoint）</strong></td>\n<td><strong>ZK → KRaft 迁移阶段</strong> 或 <strong>KRaft 集群初次启动</strong></td>\n<td>⚙️ 可选（仅特定阶段）</td>\n<td>用于在 controller quorum 尚未形成时的临时发现</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参考 worker1 上的 controller 节点的配置文件 <code>controller.properties</code>，配置 woker2 的 controller 节点配置文件<code>controller.properties</code> ，worker3 也是类似的。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色，这里只能是controller</span></span><br><span class=\"line\">process.roles=controller</span><br><span class=\"line\"><span class=\"comment\"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class=\"line\">node.id=3001</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点</span></span><br><span class=\"line\">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># 配置监听器，注意端口不能重复</span></span><br><span class=\"line\">listeners=CONTROLLER://:9098</span><br><span class=\"line\">advertised.listeners=CONTROLLER://worker2:9098</span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"><span class=\"comment\"># 日志存放目录，这里存放的是元数据</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>初始化日志目录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只有 Controller 节点才需要初始化日志目录</span></span><br><span class=\"line\"><span class=\"comment\"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class=\"line\">kafka-storage.sh format -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动 worker2 和 worker3 上的 controller 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时新的 controller 节点不会立刻加入选举队列，新节点初始状态默认是 observer，需要执行下面的命令将节点加入选举队列</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 worker2 和 worker3 上执行</span></span><br><span class=\"line\">kafka-metadata-quorum.sh --bootstrap-server localhost:9092 --command-config /usr/local/kafka/kafka3/config/kraft/controller.properties add-controller</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群节点状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --replication</span><br><span class=\"line\">NodeId\tDirectoryId           \tLogEndOffset\tLag\tLastFetchTimestamp\tLastCaughtUpTimestamp\tStatus</span><br><span class=\"line\">3000  \tRJ4oOPGgTw-KxHFNn4SmiQ\t27820       \t0  \t1760696136345     \t1760696136345        \tLeader</span><br><span class=\"line\">3001  \tzGnWA7zYmRHG6bcTlFV2qA\t27820       \t0  \t1760696136259     \t1760696136259        \tFollower</span><br><span class=\"line\">3002  \tgIDkhOQJEHqg-GJBdezU1Q\t27820       \t0  \t1760696136257     \t1760696136257        \tFollower</span><br><span class=\"line\">2     \t9KeeAYKEQHT92DxqNSwYuA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\">1     \tQ8lr8JQ2vrDS35_DrI1MxA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\">3     \trgQR5wd_i5hLgU97dCKIvA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\"></span><br><span class=\"line\">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --status</span><br><span class=\"line\">ClusterId:              hp_Q0pihQ0ORcIvXlfHobQ</span><br><span class=\"line\">LeaderId:               3000</span><br><span class=\"line\">LeaderEpoch:            5</span><br><span class=\"line\">HighWatermark:          30094</span><br><span class=\"line\">MaxFollowerLag:         0</span><br><span class=\"line\">MaxFollowerLagTimeMs:   0</span><br><span class=\"line\">CurrentVoters:          [&#123;<span class=\"string\">&quot;id&quot;</span>: 3000, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;RJ4oOPGgTw-KxHFNn4SmiQ&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker1:9098&quot;</span>]&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3001, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;zGnWA7zYmRHG6bcTlFV2qA&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker2:9098&quot;</span>]&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3002, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;gIDkhOQJEHqg-GJBdezU1Q&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker3:9098&quot;</span>]&#125;]</span><br><span class=\"line\">CurrentObservers:       [&#123;<span class=\"string\">&quot;id&quot;</span>: 2, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;9KeeAYKEQHT92DxqNSwYuA&quot;</span>&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 1, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;Q8lr8JQ2vrDS35_DrI1MxA&quot;</span>&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;rgQR5wd_i5hLgU97dCKIvA&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"加入-新的-Broker-节点\">加入 新的 Broker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建新的 Broker 节点时，参考其它 Broker 节点 配置好配置文件 <code>server.properties</code>，并启动 Broker 节点即可。</p>\n</li>\n<li class=\"lvl-2\">\n<p>无需运行日志目录初始化命令，因为 Broker 节点只存放 消息 数据。</p>\n</li>\n</ul>\n<h2 id=\"迁移后注意事项\">迁移后注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>迁移完成后，Kafka 客户端（Producer / Consumer / AdminClient）依然连接的是 Broker 节点，而不是 Controller 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 在 ZooKeeper 模式与 KRaft 模式下的区别主要在于：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">控制平面（Control Plane）：ZK 模式下由 ZooKeeper + Controller Broker 共同管理；KRaft 模式下由 独立的 Controller 进程或角色 管理（通过 Raft 协议同步元数据）。</li>\n<li class=\"lvl-4\">数据平面（Data Plane）：无论是哪个模式，客户端发送、消费消息仍然是通过 Broker 节点 完成的。</li>\n<li class=\"lvl-4\">也就是说，Controller 管理集群元数据（主题、分区、副本、Leader 选举等），而 Broker 节点处理实际的消息流。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 官方文档：ZooKeeper到KRaft迁移 从 Zookeeper 模式迁移到 KRaft 模式（平滑迁移） ！！！迁移后将无法再恢复到 ZooKeeper 模式！！！ Kafka 官方在 3.4+ 引入了完整的 Zookeeper → KRaft 平滑迁移机制，称为 ZK to KRaft (ZkMigration)。 迁移背景与前提 项目 说明 支持版本 Kafka 3.4.0+（建议至少使用 3.6.x ，目前最新版为 3.9.x） 迁移目的 摆脱 ZooKeeper，完全切换为 KRaft 自管理模式 迁移模式 在线迁移（无停机或最小停机） 最终目标 Kafka 的控制器与元数据完全由 KRaft 管理，不再依赖 ZooKeeper。 整体迁移流程概览 阶段 控制器类型 Broker 模式 ZooKeeper 角色 KRaft 角色 特征说明 初始阶段 ZooKeeper 控制器 全部为 ZK 模式 管理所有元数据 尚未启用 所有 Broker 都运行在 ZK 模式下，由 ZK 控制器管理集群。 初始元数据加载阶段 KRaft 控制器开始加载 部分（或全部）仍为 ZK 模式 提供元数据源 从 ZK 加载元数据 KRaft 法定节点（controller.quorum.voters）从 ZK 中读取并同步当前集群元数据。 混合阶段 KRaft 控制器 部分 ZK 模式，部分 KRaft 模式 保留只读元数据 管理并更新元数据 KRaft 控制器成为主控，ZK 仍存在但只提供读取，Broker 可处于不同模式（混合状态）。 双写阶段 KRaft 控制器 全部为 KRaft 模式 接收 KRaft 同步写入 管理元数据并写入 ZK 所有 Broker 都运行在 KRaft 模式，控制器将元数据同时写入 ZK 和 KRaft 日志。 迁移完成阶段 KRaft 控制器 全部为 KRaft 模式 不再使用 独立运行 停止向 ZK 写入元数据，ZK 可安全关闭，Kafka 完全运行在无 Zookeeper 的 KRaft 模式下。 开始迁移 这里以前文 Kafka 的安装：基于 Zookeeper 中的3个节点的集群为例。 启动一个 Controller 节点 在任意一个节点上启动一个 Controller 节点，这里为 worker1 启动前需要先获取当前 Kafka 集群的 Cluster ID 1234567$ zookeeper-shell.sh localhost:2181 get /cluster/idConnecting to localhost:2181WATCHER::WatchedEvent state:SyncConnected type:None path:null&#123;&quot;version&quot;:&quot;1&quot;,&quot;id&quot;:&quot;hp_Q0pihQ0ORcIvXlfHobQ&quot;&#125; 准备好 Controller 节点的配置文件，这里可以用 config/kraft/controller.properties 为模板进行修改 123456789101112131415161718192021222324# 配置当前节点的角色，这里只能是controllerprocess.roles=controller# 节点ID，不能与现有Broker节点的ID一致node.id=3000# 配置集群的投票节点，因为我们当前只启动了一个controller节点，所以只能配置一个投票节点controller.quorum.bootstrap.servers=worker1:9098# 配置监听器，注意端口不能重复listeners=CONTROLLER://:9098advertised.listeners=CONTROLLER://worker1:9098controller.listener.names=CONTROLLER# 日志存放目录，这里存放的是元数据，在格式化时这个目录必须为空目录log.dirs=/usr/local/kafka/dataDir/kraft-meta# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程zookeeper.metadata.migration.enable=true# ZooKeeper client 连接zookeeper.connect=worker1:2181,worker2:2181,worker3:2181# 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。# 注意这里要与原先的 server.properties 中配置的监听器名称一致inter.broker.listener.name=PLAINTEXT# 其它参数尽量保持与旧集群的配置一致 启动 Controller 节点 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。 12345# 格式化元数据目录，log.dirs 参数指定元数据存放目录，首次运行前必须为空目录# -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster IDkafka-storage.sh format --standalone -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties# 启动，这里没有后台启动是为了方便观察日志输出kafka-server-start.sh /usr/local/kafka/kafka3/config/kraft/controller.properties 模式 format 命令 quorum 状态 是否从 ZK 加载 迁移阶段（standalone） --standalone 无（单节点） ✅ 是 正式 KRaft 模式 无 --standalone ✅ 多节点 ❌ 否（独立运行） 将原先的三个节点作为 Broker 节点重新启动 修改原先的配置文件 server.properties，只需要修改如下内容即可 1234567891011121314# 在最后加入 CONTROLLER:PLAINTEXTlistener.security.protocol.map=PLAINTEXT:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,CONTROLLER:PLAINTEXT## 以下是新加入的 配置项# Set the IBP，当前 kafka 版本是 3.9.1，所以这里设置为 3.9inter.broker.protocol.version=3.9# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程zookeeper.metadata.migration.enable=true# KRaft controller quorum configuration，因为目前只启动了一个 controller 节点，所以只能配置一个投票节点controller.quorum.bootstrap.servers=worker1:9098# 控制器监听器名称，要与 contreller 节点配置文件 controller.properties 中的配置一致controller.listener.names=CONTROLLER 分别重新启动三个节点 1234567# 关闭 kafkakafka-server-stop.sh# 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.propertiesps -ef | grep kafka | grep &quot;server\\.properties&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9# 重新启动 kafkakafka-server-start.sh /usr/local/kafka/kafka3/config/server.properties 当三个节点都以必要的配置重新启动后，迁移将自动开始。迁移完成后，可以在 Controller(worker1)节点 上看到类似如下日志： 1234567891011121314151617181920# ✅ 意味：从 ZooKeeper 到 KRaft 的初始元数据迁移已成功，共写入 62 条记录，当前 KRaft metadata offset 为 3179。这是迁移成功的明确证据。Completed migration of metadata from ZooKeeper to KRaft. 62 records were generated in 300 ms across 1 batches. The average time spent waiting on a batch was 97.00 ms. The record types were &#123;TOPIC_RECORD=3, PARTITION_RECORD=56, CONFIG_RECORD=3&#125;. The current metadata offset is now 3179 with an epoch of 2. Saw 3 brokers in the migrated metadata [1, 2, 3]. (org.apache.kafka.metadata.migration.KRaftMigrationDriver)# ✅ 意味：控制器已加载并生效新元数据与 feature set（与 offset 3179 对应）。Loaded new metadata Features(metadataVersion=3.9-IV0, finalizedFeatures=&#123;metadata.version=21&#125;, finalizedFeaturesEpoch=3179). (org.apache.kafka.metadata.publisher.FeaturesPublisher)# ✅ 意味：内部迁移状态已更新，KRaft 上有了写入位置记录。Finished initial migration of ZK metadata to KRaft in 3486479 ns. Transitioned migration state from ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=-1, kraftMetadataEpoch=-1, lastUpdatedTimeMs=1760682050169, migrationZkVersion=1, controllerZkEpoch=3, controllerZkVersion=3&#125; to ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=3179, kraftMetadataEpoch=2, lastUpdatedTimeMs=1760682050169, migrationZkVersion=2, controllerZkEpoch=3, controllerZkVersion=3&#125; (org.apache.kafka.metadata.migration.KRaftMigrationDriver)# ✅ 意味：迁移流程按预期推进：先把 KRaft 的元数据与 ZK 对齐（sync），然后与 brokers 建立通信，最终进入 DUAL_WRITE（双写）。DUAL_WRITE 阶段表示控制器在写入 KRaft metadata log 的同时，仍然会把必要的写操作也写回 ZooKeeper（双写）——直到迁移完全完成并确认可以停止写 ZK 为止。3000 transitioning from ZK_MIGRATION to SYNC_KRAFT_TO_ZK state...Performing a full metadata sync from KRaft to ZK.Did not make any ZK writes when reconciling with KRaft state.3000 transitioning ... to KRAFT_CONTROLLER_TO_BROKER_COMM...Sending RPCs to broker before moving to dual-write mode using at offset and epoch OffsetAndEpoch(offset=3179, epoch=2)...3000 transitioning ... to DUAL_WRITE state 上面的日志总体上表明，元数据迁移已成功完成并且控制器进入了双写（DUAL_WRITE）阶段。 将三个Broker节点的配置修改为 KRaft 模式的 broker 节点 修改三个节点的配置文件 server.properties 123456789101112131415# 添加process.roles=brokerprocess.roles=broker# 用 node.id 替换 broker.id，注意，node.id 需要与 broker.id 一致# broker.id=1node.id=1# 去掉 zookeeper 相关配置# Don&#x27;t set the IBP, KRaft uses &quot;metadata.version&quot; feature flag# inter.broker.protocol.version=3.9# Remove the migration enabled flag# zookeeper.metadata.migration.enable=true# Remove ZooKeeper client configuration# zookeeper.connect=worker1:2181,worker2:2181,worker3:2181 分别重新启动三个节点 1234567# 关闭 kafkakafka-server-stop.sh# 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.propertiesps -ef | grep kafka | grep &quot;server\\.properties&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9# 重新启动 kafkakafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties 将 Controller 节点的配置修改为 KRaft 模式的 controller 节点 修改 controller 节点的配置文件 controller.properties 123456## 去掉去下内容# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程# zookeeper.metadata.migration.enable=true# ZooKeeper client 连接# zookeeper.connect=worker1:2181,worker2:2181,worker3:2181 重启启动 controller 节点 12# 关闭后重新启动kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties 此时你可以关闭 zookeeper 集群了，新的 kafka 集群将不再使用 ZooKeeper，也无法在恢复到 ZooKeeper 模式。 加入新的 Controller 节点 Controller 尽量保持 奇数个节点。 之前已经在 worker1 节点上启动了 controller ，现在 worker2 和 worker3 上也来启动 controller 节点，并将它们加入到 kafka 集群中。 在开始配置前，先将上面的 controller 节点 和 三个 broker 节点 的如下配置进行修改，并重启启动。 123456# 将 controller.quorum.bootstrap.servers 替换为 controller.quorum.voterscontroller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098# controller.quorum.bootstrap.servers=worker1:9098# controller.quorum.voters = 谁是正式投票成员（固定配置）# controller.quorum.bootstrap.servers = 临时找谁引导连接（迁移或初始化用） 配置项 作用 适用阶段 是否必需 说明 controller.quorum.voters 定义 正式的 KRaft 控制器投票成员列表（voter set） 集群正常运行时 ✅ 是 所有节点必须配置相同的值 controller.quorum.bootstrap.servers 定义 迁移阶段或初始化阶段的控制器连接地址（bootstrap controller endpoint） ZK → KRaft 迁移阶段 或 KRaft 集群初次启动 ⚙️ 可选（仅特定阶段） 用于在 controller quorum 尚未形成时的临时发现 参考 worker1 上的 controller 节点的配置文件 controller.properties，配置 woker2 的 controller 节点配置文件controller.properties ，worker3 也是类似的。 12345678910111213141516# 配置当前节点的角色，这里只能是controllerprocess.roles=controller# 节点ID，不能与现有Broker节点的ID一致node.id=3001# 配置集群的投票节点controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098# 配置监听器，注意端口不能重复listeners=CONTROLLER://:9098advertised.listeners=CONTROLLER://worker2:9098controller.listener.names=CONTROLLER# 日志存放目录，这里存放的是元数据log.dirs=/usr/local/kafka/dataDir/kraft-meta# 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。# 注意这里要与原先的 server.properties 中配置的监听器名称一致inter.broker.listener.name=PLAINTEXT 初始化日志目录 123# 只有 Controller 节点才需要初始化日志目录# -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster IDkafka-storage.sh format -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties 分别启动 worker2 和 worker3 上的 controller 节点 1kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties 此时新的 controller 节点不会立刻加入选举队列，新节点初始状态默认是 observer，需要执行下面的命令将节点加入选举队列 12# 分别在 worker2 和 worker3 上执行kafka-metadata-quorum.sh --bootstrap-server localhost:9092 --command-config /usr/local/kafka/kafka3/config/kraft/controller.properties add-controller 查看集群节点状态 123456789101112131415161718$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --replicationNodeId DirectoryId LogEndOffset Lag LastFetchTimestamp LastCaughtUpTimestamp Status3000 RJ4oOPGgTw-KxHFNn4SmiQ 27820 0 1760696136345 1760696136345 Leader3001 zGnWA7zYmRHG6bcTlFV2qA 27820 0 1760696136259 1760696136259 Follower3002 gIDkhOQJEHqg-GJBdezU1Q 27820 0 1760696136257 1760696136257 Follower2 9KeeAYKEQHT92DxqNSwYuA 27820 0 1760696136257 1760696136257 Observer1 Q8lr8JQ2vrDS35_DrI1MxA 27820 0 1760696136257 1760696136257 Observer3 rgQR5wd_i5hLgU97dCKIvA 27820 0 1760696136257 1760696136257 Observer$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --statusClusterId: hp_Q0pihQ0ORcIvXlfHobQLeaderId: 3000LeaderEpoch: 5HighWatermark: 30094MaxFollowerLag: 0MaxFollowerLagTimeMs: 0CurrentVoters: [&#123;&quot;id&quot;: 3000, &quot;directoryId&quot;: &quot;RJ4oOPGgTw-KxHFNn4SmiQ&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker1:9098&quot;]&#125;, &#123;&quot;id&quot;: 3001, &quot;directoryId&quot;: &quot;zGnWA7zYmRHG6bcTlFV2qA&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker2:9098&quot;]&#125;, &#123;&quot;id&quot;: 3002, &quot;directoryId&quot;: &quot;gIDkhOQJEHqg-GJBdezU1Q&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker3:9098&quot;]&#125;]CurrentObservers: [&#123;&quot;id&quot;: 2, &quot;directoryId&quot;: &quot;9KeeAYKEQHT92DxqNSwYuA&quot;&#125;, &#123;&quot;id&quot;: 1, &quot;directoryId&quot;: &quot;Q8lr8JQ2vrDS35_DrI1MxA&quot;&#125;, &#123;&quot;id&quot;: 3, &quot;directoryId&quot;: &quot;rgQR5wd_i5hLgU97dCKIvA&quot;&#125;] 加入 新的 Broker 节点 创建新的 Broker 节点时，参考其它 Broker 节点 配置好配置文件 server.properties，并启动 Broker 节点即可。 无需运行日志目录初始化命令，因为 Broker 节点只存放 消息 数据。 迁移后注意事项 迁移完成后，Kafka 客户端（Producer / Consumer / AdminClient）依然连接的是 Broker 节点，而不是 Controller 节点。 Kafka 在 ZooKeeper 模式与 KRaft 模式下的区别主要在于： 控制平面（Control Plane）：ZK 模式下由 ZooKeeper + Controller Broker 共同管理；KRaft 模式下由 独立的 Controller 进程或角色 管理（通过 Raft 协议同步元数据）。 数据平面（Data Plane）：无论是哪个模式，客户端发送、消费消息仍然是通过 Broker 节点 完成的。 也就是说，Controller 管理集群元数据（主题、分区、副本、Leader 选举等），而 Broker 节点处理实际的消息流。","summary":"摘要 本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 官方文档：ZooKeeper到KRaft迁移","date_published":"2025-10-16T14:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/","url":"https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/","title":"Kafka 的安装：基于 KRaft 模式","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"KRaft-简介\">KRaft 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kraft 是 Kafka 从 2.8.0 版本 开始⽀持的⼀种新的集群架构⽅式。其⽬的主要是为了摆脱Kafka对Zookeeper的依赖。因为以往基于Zookeeper搭建的集群，增加了Kafka演进与运维的难度，逐渐开始成为Kakfa拥抱云原⽣的⼀种障碍。使⽤Kraft集群后，Kafka集群就不再需要依赖Zookeeper，将之前基于Zookeeper管理的集群数据，转为由Kafka集群⾃⼰管理。</p>\n</li>\n<li class=\"lvl-2\">\n<p>传统的Kafka集群，会将每个节点的状态信息统一保存在Zookeeper中，并通过Zookeeper动态选举产生一个Controller节点，通过Controller节点来管理Kafka集群，比如触发Partition的选举。而在Kraft集群中，会固定配置几台Broker节点来共同担任Controller的角色，各组Partition的Leader节点就会由这些Controller选举产生。原本保存在Zookeeper中的元数据也转而保存到Controller节点中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>🧭 Kafka KRaft 模式 vs Zookeeper 模式 对比表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对比项</th>\n<th style=\"text-align:left\"><strong>KRaft 模式（Kafka Raft 模式）</strong></th>\n<th style=\"text-align:left\"><strong>Zookeeper 模式（传统模式）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>架构结构</strong></td>\n<td style=\"text-align:left\">去中心化架构，Kafka 自身内置控制平面，不依赖外部 Zookeeper。</td>\n<td style=\"text-align:left\">控制平面依赖外部 Zookeeper 集群，Kafka Broker 只负责数据平面。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>组件数量</strong></td>\n<td style=\"text-align:left\">无需部署 Zookeeper，只有 Kafka Broker 节点。</td>\n<td style=\"text-align:left\">需要单独维护 Zookeeper 集群。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>元数据存储</strong></td>\n<td style=\"text-align:left\">元数据存储在 Kafka 自身的内置日志中（<code>__cluster_metadata</code> topic）。</td>\n<td style=\"text-align:left\">元数据存储在 Zookeeper 的 znode 树结构中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>一致性协议</strong></td>\n<td style=\"text-align:left\">使用 Kafka 自己实现的 Raft 协议（KRaft）来保证元数据一致性。</td>\n<td style=\"text-align:left\">使用 ZAB（Zookeeper Atomic Broadcast）协议保证一致性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>启动速度</strong></td>\n<td style=\"text-align:left\">更快，控制器内嵌于 Broker 中，不需要等待外部 Zookeeper 启动。</td>\n<td style=\"text-align:left\">启动依赖 Zookeeper，启动顺序和连通性要求更严格。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>容错性</strong></td>\n<td style=\"text-align:left\">Raft 控制器具备日志复制机制，容错性与 Kafka 数据副本一致。</td>\n<td style=\"text-align:left\">容错性由 Zookeeper 决定，Zookeeper 挂掉可能导致 Kafka 控制面不可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>扩展性</strong></td>\n<td style=\"text-align:left\">元数据存储在 Kafka 主题中，水平扩展能力更强。</td>\n<td style=\"text-align:left\">Zookeeper 在高分区数场景下易成为性能瓶颈。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>运维复杂度</strong></td>\n<td style=\"text-align:left\">无需维护 Zookeeper 集群，统一运维 Kafka 即可。</td>\n<td style=\"text-align:left\">需要额外维护 Zookeeper 集群（监控、扩容、升级）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据恢复</strong></td>\n<td style=\"text-align:left\">元数据恢复与 Kafka 主题一致，可通过日志回放恢复。</td>\n<td style=\"text-align:left\">Zookeeper 数据恢复相对复杂，依赖快照和事务日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全机制</strong></td>\n<td style=\"text-align:left\">统一 Kafka 的安全机制（SASL、SSL、ACL 等）。</td>\n<td style=\"text-align:left\">Zookeeper 有独立的安全配置体系，需单独管理。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>性能表现</strong></td>\n<td style=\"text-align:left\">元数据操作延迟更低（控制器与 Broker 本地通信）。</td>\n<td style=\"text-align:left\">元数据操作需要跨进程网络通信，延迟更高。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>控制器角色</strong></td>\n<td style=\"text-align:left\">由 Broker 中的控制器 quorum 选举产生（支持多控制器候选）。</td>\n<td style=\"text-align:left\">由 Zookeeper 选举控制器（单点控制器）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>分区与副本管理</strong></td>\n<td style=\"text-align:left\">全部元数据存储在 Kafka 自身，可实现更快的分区变更和扩容。</td>\n<td style=\"text-align:left\">分区、副本元数据同步依赖 Zookeeper，性能相对较低。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>版本支持</strong></td>\n<td style=\"text-align:left\">从 Kafka 2.8 开始引入，Kafka 3.3+ 已经非常稳定，Kafka 3.5+ 默认推荐。</td>\n<td style=\"text-align:left\">Kafka 3.5 开始标记为“Legacy”，未来版本计划移除支持。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>兼容性</strong></td>\n<td style=\"text-align:left\">可通过元数据迁移工具从 Zookeeper 模式平滑迁移。</td>\n<td style=\"text-align:left\">不能直接迁移到 KRaft，需要工具辅助。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>运维监控</strong></td>\n<td style=\"text-align:left\">单一系统可监控（Kafka 自带的 JMX、Prometheus 等）。</td>\n<td style=\"text-align:left\">Kafka 与 Zookeeper 各自需要独立监控体系。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>未来发展方向</strong></td>\n<td style=\"text-align:left\">官方推荐和默认模式（Zookeeper 模式将逐步淘汰）。</td>\n<td style=\"text-align:left\">官方已不再建议新集群使用。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Kafka-的-KRaft-集群配置\">Kafka 的 KRaft 集群配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在Kafka的config目录下，提供了一个kraft的文件夹，在这里面提供了三个Kraft协议的参考配置文件</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">broker.properties: 数据节点，client连接时只连接broker数据节点</li>\n<li class=\"lvl-4\">controller.properties: Controller控制节点</li>\n<li class=\"lvl-4\">server.properties: 即可以是数据节点，又可以是Controller控制节点。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>实际上这些配置文件中的配置项基本与 serrver.properties 一致，只是去除了与 zookeeper 相关的配置项，同时增加了一些 Kraft 模式下的配置项。关于 server.properties 的配置项，请参考 <a href=\"https://kafka.apache.org/39/documentation/#brokerconfigs\">Kafka 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>这里以 <code>kraft/serrver.properties</code> 为例进行修改，配置三个节点的Kafka集群，每个节点即是 controller 节点，也可以是 broker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下面这四个配置项是 kraft 模式下新增加的</span></span><br><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色。Controller相当于Zookeeper的功能，负责集群管理。Broker提供具体的消息转发服务。</span></span><br><span class=\"line\"><span class=\"comment\"># 一个节点可以即是 Controller 又是 Broker，也可以只是 Controller 或 Broker。</span></span><br><span class=\"line\">process.roles=broker,controller</span><br><span class=\"line\"><span class=\"comment\"># 配置当前节点的id。与普通集群一样，要求集群内每个节点的ID不能重复。</span></span><br><span class=\"line\">node.id=1</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点。其中@前面的是节点的id，后面是节点的地址和端口，这个端口跟客户端访问的端口是不一样的，要与 CONTROLLER 协议对应的端口一致，这里配置为 9098</span></span><br><span class=\"line\"><span class=\"comment\"># 通常将集群内的所有Controllor节点都配置进去。</span></span><br><span class=\"line\">controller.quorum.voters=1@worker1:9098,2@worker2:9098,3@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># Controller服务协议的别名。默认就是CONTROLLER</span></span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下配置项与之前一样，按需进行配置即可</span></span><br><span class=\"line\"><span class=\"comment\"># 集群间通信仍使用内网</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 配置监听服务。不同的服务可以绑定不同的接口。这种配置方式在端口前面是省略了一个主机IP的，主机IP默认是使用的java.net.InetAddress.getCanonicalHostName()，这里同时开启外网访问，关于 sasl_plaintext 、sasl_ssl协议 的配置方式参考前文 kafka 通信协议</span></span><br><span class=\"line\">listeners=PLAINTEXT://:9092,CONTROLLER://:9098,EXTERNAL://0.0.0.0:9093</span><br><span class=\"line\"><span class=\"comment\"># Broker对客户端暴露的服务地址。基于PLAINTEXT协议。这里要替换为各个节点的IP地址</span></span><br><span class=\"line\">advertised.listeners=PLAINTEXT://worker1:9092,CONTROLLER://worker1:9098,EXTERNAL://161.189.227.200:9093</span><br><span class=\"line\"><span class=\"comment\"># 将监听器名称映射到安全协议类型，这里 CONTROLLER 协议对应的安全协议类型为 PLAINTEXT</span></span><br><span class=\"line\">listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,EXTERNAL:PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 数据文件地址。默认配置在/tmp目录下。</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-logs</span><br><span class=\"line\"><span class=\"comment\"># topic默认的partition分区数。</span></span><br><span class=\"line\">num.partitions=2</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动Kafka集群\">启动Kafka集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动前要对日志目录进行格式化</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在worker1节点上生成集群ID</span></span><br><span class=\"line\">$ kafka-storage.sh random-uuid</span><br><span class=\"line\">oGwJsVANRDKYwE7Lhn2zIA</span><br><span class=\"line\"><span class=\"comment\"># 然后在集群的每个节点上执行如下命令，格式化日志目录，注意 --cluster-id 必须一致</span></span><br><span class=\"line\"><span class=\"comment\"># 必须在第一次启动前执行</span></span><br><span class=\"line\"><span class=\"comment\"># 不可以重复执行，否则会清空数据目录并破坏已有元数据</span></span><br><span class=\"line\"><span class=\"comment\"># 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。</span></span><br><span class=\"line\"><span class=\"comment\"># 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</span></span><br><span class=\"line\">$ kafka-storage.sh format --cluster-id oGwJsVANRDKYwE7Lhn2zIA --config /usr/local/kafka/kafka3/config/kraft/server.properties</span><br><span class=\"line\"><span class=\"comment\">## 格式化后会在日志目录下生成两个文件</span></span><br><span class=\"line\"><span class=\"comment\"># bootstrap.checkpoint # 存储元数据日志（Metadata Log）对应的初始快照偏移量（snapshot offset）。用于控制器在启动时恢复状态的起点。</span></span><br><span class=\"line\"><span class=\"comment\"># meta.properties # 存储节点元信息：cluster.id、node.id、version 等</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动集群，所以节点启动 kafka 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/server.properties</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\">注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 集群的启动顺序不能乱，必须先启动 Controller 节点，再启动 Broker 节点，我们这里是将节点同时做为Controller 和 Broker ，实际生产环境建议分开。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 节点至少3个，建议配置为奇数个。Broker 节点数量任意，但建议至少2个以上，以保证分区的备份可以分开存储。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Client 仅能与 Broker 节点通信，不能与 Controller 节点通信。</p>\n</li>\n</ul>\n<h2 id=\"Kafka-4-0-的新特性\">Kafka 4.0 的新特性</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>彻底以 KRaft（Kafka Raft）取代 ZooKeeper（KRaft 成为默认且唯一的元数据管理）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：4.x 系列标志性变化是完全移除 ZooKeeper，元数据由 KRaft 管理（Controller 与 Broker 更紧密集成）。对运维而言：不再部署/维护 ZooKeeper 集群、元数据迁移/格式化步骤是升级时的关键。</li>\n<li class=\"lvl-4\">影响/提示：必须按官方迁移流程把元数据从 ZK 导入 KRaft（若从旧版本升级）。测试迁移/备份元数据是必须项。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>新的 consumer-group 协议（更高效的 rebalance/群组管理）与消费模型改进（包括“Queues/Shared Group”支持）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：引入/稳定了新的 Consumer Group 协议（相关 KIP），显著改善大群组下的重平衡延迟与稳定性；同时引入了类似“队列/共享组（Queues for Kafka）”的消费模式（用例：点对点消费），允许多消费者同时处理同一分区消息。</li>\n<li class=\"lvl-4\">影响/提示：如果你有大规模消费者群组或依赖旧 rebalance 行为，需要测试新协议行为；某些客户端配置/行为可能需要调整。</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标类别</th>\n<th>旧协议（Eager Rebalance）</th>\n<th>新协议（Incremental / Cooperative Rebalance）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重平衡延迟（大规模群组）</td>\n<td>约 <strong>60 秒</strong>（万级消费者规模）</td>\n<td>小于 <strong>1 秒</strong>（测试显示在千级任务时可在一分钟内完成） (<a href=\"https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/?utm_source=chatgpt.com\" title=\"Incremental Cooperative Rebalancing in Apache Kafka\">Confluent</a>)</td>\n</tr>\n<tr>\n<td>资源消耗（CPU）</td>\n<td>较高（在重平衡期间系统停止或大规模迁移资源）</td>\n<td>据称可降低约 <strong>70%</strong> 的 CPU／系统中断负荷（社区经验）</td>\n</tr>\n<tr>\n<td>消费者群组扩展上限</td>\n<td>适用于“千级消费者”规模</td>\n<td>可扩展至“十万级消费者”规模（理论/社区宣称）</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>传统消费者组（Consumer Group）</strong></th>\n<th><strong>共享组（Shared Group / Queues for Kafka）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>并行消费模型</strong></td>\n<td>分区数 = 消费者数（一个分区只能被一个消费者消费）</td>\n<td>消费者数 &gt; 分区数（同一分区可由多个消费者并行处理）</td>\n</tr>\n<tr>\n<td><strong>消息确认机制</strong></td>\n<td>通过提交偏移量（Offset Commit）实现确认</td>\n<td>每条消息单独确认（ACK/NACK 机制）</td>\n</tr>\n<tr>\n<td><strong>投递语义</strong></td>\n<td><strong>At-Least-Once</strong>（至少一次投递）</td>\n<td><strong>Exactly-Once（可选）</strong>，支持精确一次处理</td>\n</tr>\n<tr>\n<td><strong>典型场景</strong></td>\n<td>流式日志、监控、顺序性要求高的场景</td>\n<td>任务队列、并行计算、高吞吐任务处理</td>\n</tr>\n<tr>\n<td><strong>实现方式</strong></td>\n<td>基于 Topic-Partition 分配与偏移管理</td>\n<td>基于共享队列模型，允许多消费者竞争消费同一分区</td>\n</tr>\n<tr>\n<td><strong>Kafka 版本支持</strong></td>\n<td>Kafka ≤ 3.x</td>\n<td>Kafka 4.x 引入（KIP-932 “Queues for Kafka”）</td>\n</tr>\n<tr>\n<td><strong>优势</strong></td>\n<td>顺序保证强、模型成熟稳定</td>\n<td>并行能力强、吞吐提升、支持精确一次语义</td>\n</tr>\n<tr>\n<td><strong>劣势</strong></td>\n<td>分区限制吞吐，扩展受限</td>\n<td>顺序性可能减弱，实现更复杂</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除长期弃用的旧 API / 协议（向后不兼容的清理）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：4.x 移除了那些已弃用 ≥12 个月的接口/协议，旨在简化代码库并鼓励采用新功能。</li>\n<li class=\"lvl-4\">影响/提示：升级前务必检查你使用到的 Broker/Client/Streams/Connect API 是否依赖被移除的功能；测试客户端与第三方 Connector/插件兼容性。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Java 运行环境最低版本更新：Clients/Streams 与 Broker/Tools 的 JDK 要求提高</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：Kafka 4.x 将客户端（Kafka Clients、Kafka Streams）与 Broker/Connect/工具分别提出了更高的 Java baseline（Clients/Streams 最低 Java 11，Broker/Connect/Tools 最低 Java 17 等）。</li>\n<li class=\"lvl-4\">影响/提示：升级集群前先统一平台 JDK 版本，CI/CD/容器镜像也要对应更新。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>许多新的 KIP（功能增强）与性能/可观测性改进</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：包含改进的 Streams rebalance、更多 Admin/运维命令、节点注册/列举能力、插件/指标扩展点等（多项 KIP 在 4.0/4.1 陆续落地）。这些改进覆盖 Broker、Controller、Producer、Consumer、Admin 和 Streams 子系统。</li>\n<li class=\"lvl-4\">影响/提示：运维与监控面板可能受益（新增可观测指标/API）；如果你有自定义插件或监控接入，需要检查新的插件/metrics 注册机制。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。 KRaft 简介 Kraft 是 Kafka 从 2.8.0 版本 开始⽀持的⼀种新的集群架构⽅式。其⽬的主要是为了摆脱Kafka对Zookeeper的依赖。因为以往基于Zookeeper搭建的集群，增加了Kafka演进与运维的难度，逐渐开始成为Kakfa拥抱云原⽣的⼀种障碍。使⽤Kraft集群后，Kafka集群就不再需要依赖Zookeeper，将之前基于Zookeeper管理的集群数据，转为由Kafka集群⾃⼰管理。 传统的Kafka集群，会将每个节点的状态信息统一保存在Zookeeper中，并通过Zookeeper动态选举产生一个Controller节点，通过Controller节点来管理Kafka集群，比如触发Partition的选举。而在Kraft集群中，会固定配置几台Broker节点来共同担任Controller的角色，各组Partition的Leader节点就会由这些Controller选举产生。原本保存在Zookeeper中的元数据也转而保存到Controller节点中。 🧭 Kafka KRaft 模式 vs Zookeeper 模式 对比表 对比项 KRaft 模式（Kafka Raft 模式） Zookeeper 模式（传统模式） 架构结构 去中心化架构，Kafka 自身内置控制平面，不依赖外部 Zookeeper。 控制平面依赖外部 Zookeeper 集群，Kafka Broker 只负责数据平面。 组件数量 无需部署 Zookeeper，只有 Kafka Broker 节点。 需要单独维护 Zookeeper 集群。 元数据存储 元数据存储在 Kafka 自身的内置日志中（__cluster_metadata topic）。 元数据存储在 Zookeeper 的 znode 树结构中。 一致性协议 使用 Kafka 自己实现的 Raft 协议（KRaft）来保证元数据一致性。 使用 ZAB（Zookeeper Atomic Broadcast）协议保证一致性。 启动速度 更快，控制器内嵌于 Broker 中，不需要等待外部 Zookeeper 启动。 启动依赖 Zookeeper，启动顺序和连通性要求更严格。 容错性 Raft 控制器具备日志复制机制，容错性与 Kafka 数据副本一致。 容错性由 Zookeeper 决定，Zookeeper 挂掉可能导致 Kafka 控制面不可用。 扩展性 元数据存储在 Kafka 主题中，水平扩展能力更强。 Zookeeper 在高分区数场景下易成为性能瓶颈。 运维复杂度 无需维护 Zookeeper 集群，统一运维 Kafka 即可。 需要额外维护 Zookeeper 集群（监控、扩容、升级）。 数据恢复 元数据恢复与 Kafka 主题一致，可通过日志回放恢复。 Zookeeper 数据恢复相对复杂，依赖快照和事务日志。 安全机制 统一 Kafka 的安全机制（SASL、SSL、ACL 等）。 Zookeeper 有独立的安全配置体系，需单独管理。 性能表现 元数据操作延迟更低（控制器与 Broker 本地通信）。 元数据操作需要跨进程网络通信，延迟更高。 控制器角色 由 Broker 中的控制器 quorum 选举产生（支持多控制器候选）。 由 Zookeeper 选举控制器（单点控制器）。 分区与副本管理 全部元数据存储在 Kafka 自身，可实现更快的分区变更和扩容。 分区、副本元数据同步依赖 Zookeeper，性能相对较低。 版本支持 从 Kafka 2.8 开始引入，Kafka 3.3+ 已经非常稳定，Kafka 3.5+ 默认推荐。 Kafka 3.5 开始标记为“Legacy”，未来版本计划移除支持。 兼容性 可通过元数据迁移工具从 Zookeeper 模式平滑迁移。 不能直接迁移到 KRaft，需要工具辅助。 运维监控 单一系统可监控（Kafka 自带的 JMX、Prometheus 等）。 Kafka 与 Zookeeper 各自需要独立监控体系。 未来发展方向 官方推荐和默认模式（Zookeeper 模式将逐步淘汰）。 官方已不再建议新集群使用。 Kafka 的 KRaft 集群配置 在Kafka的config目录下，提供了一个kraft的文件夹，在这里面提供了三个Kraft协议的参考配置文件 broker.properties: 数据节点，client连接时只连接broker数据节点 controller.properties: Controller控制节点 server.properties: 即可以是数据节点，又可以是Controller控制节点。 实际上这些配置文件中的配置项基本与 serrver.properties 一致，只是去除了与 zookeeper 相关的配置项，同时增加了一些 Kraft 模式下的配置项。关于 server.properties 的配置项，请参考 Kafka 官方文档 这里以 kraft/serrver.properties 为例进行修改，配置三个节点的Kafka集群，每个节点即是 controller 节点，也可以是 broker 节点 12345678910111213141516171819202122232425# 下面这四个配置项是 kraft 模式下新增加的# 配置当前节点的角色。Controller相当于Zookeeper的功能，负责集群管理。Broker提供具体的消息转发服务。# 一个节点可以即是 Controller 又是 Broker，也可以只是 Controller 或 Broker。process.roles=broker,controller# 配置当前节点的id。与普通集群一样，要求集群内每个节点的ID不能重复。node.id=1# 配置集群的投票节点。其中@前面的是节点的id，后面是节点的地址和端口，这个端口跟客户端访问的端口是不一样的，要与 CONTROLLER 协议对应的端口一致，这里配置为 9098# 通常将集群内的所有Controllor节点都配置进去。controller.quorum.voters=1@worker1:9098,2@worker2:9098,3@worker3:9098# Controller服务协议的别名。默认就是CONTROLLERcontroller.listener.names=CONTROLLER# 以下配置项与之前一样，按需进行配置即可# 集群间通信仍使用内网inter.broker.listener.name=PLAINTEXT# 配置监听服务。不同的服务可以绑定不同的接口。这种配置方式在端口前面是省略了一个主机IP的，主机IP默认是使用的java.net.InetAddress.getCanonicalHostName()，这里同时开启外网访问，关于 sasl_plaintext 、sasl_ssl协议 的配置方式参考前文 kafka 通信协议listeners=PLAINTEXT://:9092,CONTROLLER://:9098,EXTERNAL://0.0.0.0:9093# Broker对客户端暴露的服务地址。基于PLAINTEXT协议。这里要替换为各个节点的IP地址advertised.listeners=PLAINTEXT://worker1:9092,CONTROLLER://worker1:9098,EXTERNAL://161.189.227.200:9093# 将监听器名称映射到安全协议类型，这里 CONTROLLER 协议对应的安全协议类型为 PLAINTEXTlistener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,EXTERNAL:PLAINTEXT# 数据文件地址。默认配置在/tmp目录下。log.dirs=/usr/local/kafka/dataDir/kraft-logs# topic默认的partition分区数。num.partitions=2 启动Kafka集群 启动前要对日志目录进行格式化 123456789101112# 在worker1节点上生成集群ID$ kafka-storage.sh random-uuidoGwJsVANRDKYwE7Lhn2zIA# 然后在集群的每个节点上执行如下命令，格式化日志目录，注意 --cluster-id 必须一致# 必须在第一次启动前执行# 不可以重复执行，否则会清空数据目录并破坏已有元数据# 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。# 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。$ kafka-storage.sh format --cluster-id oGwJsVANRDKYwE7Lhn2zIA --config /usr/local/kafka/kafka3/config/kraft/server.properties## 格式化后会在日志目录下生成两个文件# bootstrap.checkpoint # 存储元数据日志（Metadata Log）对应的初始快照偏移量（snapshot offset）。用于控制器在启动时恢复状态的起点。# meta.properties # 存储节点元信息：cluster.id、node.id、version 等 启动集群，所以节点启动 kafka 服务 1kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/server.properties 注意事项 Kafka 集群的启动顺序不能乱，必须先启动 Controller 节点，再启动 Broker 节点，我们这里是将节点同时做为Controller 和 Broker ，实际生产环境建议分开。 Controller 节点至少3个，建议配置为奇数个。Broker 节点数量任意，但建议至少2个以上，以保证分区的备份可以分开存储。 Client 仅能与 Broker 节点通信，不能与 Controller 节点通信。 Kafka 4.0 的新特性 彻底以 KRaft（Kafka Raft）取代 ZooKeeper（KRaft 成为默认且唯一的元数据管理） 说明：4.x 系列标志性变化是完全移除 ZooKeeper，元数据由 KRaft 管理（Controller 与 Broker 更紧密集成）。对运维而言：不再部署/维护 ZooKeeper 集群、元数据迁移/格式化步骤是升级时的关键。 影响/提示：必须按官方迁移流程把元数据从 ZK 导入 KRaft（若从旧版本升级）。测试迁移/备份元数据是必须项。 新的 consumer-group 协议（更高效的 rebalance/群组管理）与消费模型改进（包括“Queues/Shared Group”支持） 说明：引入/稳定了新的 Consumer Group 协议（相关 KIP），显著改善大群组下的重平衡延迟与稳定性；同时引入了类似“队列/共享组（Queues for Kafka）”的消费模式（用例：点对点消费），允许多消费者同时处理同一分区消息。 影响/提示：如果你有大规模消费者群组或依赖旧 rebalance 行为，需要测试新协议行为；某些客户端配置/行为可能需要调整。 指标类别 旧协议（Eager Rebalance） 新协议（Incremental / Cooperative Rebalance） 重平衡延迟（大规模群组） 约 60 秒（万级消费者规模） 小于 1 秒（测试显示在千级任务时可在一分钟内完成） (Confluent) 资源消耗（CPU） 较高（在重平衡期间系统停止或大规模迁移资源） 据称可降低约 70% 的 CPU／系统中断负荷（社区经验） 消费者群组扩展上限 适用于“千级消费者”规模 可扩展至“十万级消费者”规模（理论/社区宣称） 特性 传统消费者组（Consumer Group） 共享组（Shared Group / Queues for Kafka） 并行消费模型 分区数 = 消费者数（一个分区只能被一个消费者消费） 消费者数 &gt; 分区数（同一分区可由多个消费者并行处理） 消息确认机制 通过提交偏移量（Offset Commit）实现确认 每条消息单独确认（ACK/NACK 机制） 投递语义 At-Least-Once（至少一次投递） Exactly-Once（可选），支持精确一次处理 典型场景 流式日志、监控、顺序性要求高的场景 任务队列、并行计算、高吞吐任务处理 实现方式 基于 Topic-Partition 分配与偏移管理 基于共享队列模型，允许多消费者竞争消费同一分区 Kafka 版本支持 Kafka ≤ 3.x Kafka 4.x 引入（KIP-932 “Queues for Kafka”） 优势 顺序保证强、模型成熟稳定 并行能力强、吞吐提升、支持精确一次语义 劣势 分区限制吞吐，扩展受限 顺序性可能减弱，实现更复杂 删除长期弃用的旧 API / 协议（向后不兼容的清理） 说明：4.x 移除了那些已弃用 ≥12 个月的接口/协议，旨在简化代码库并鼓励采用新功能。 影响/提示：升级前务必检查你使用到的 Broker/Client/Streams/Connect API 是否依赖被移除的功能；测试客户端与第三方 Connector/插件兼容性。 Java 运行环境最低版本更新：Clients/Streams 与 Broker/Tools 的 JDK 要求提高 说明：Kafka 4.x 将客户端（Kafka Clients、Kafka Streams）与 Broker/Connect/工具分别提出了更高的 Java baseline（Clients/Streams 最低 Java 11，Broker/Connect/Tools 最低 Java 17 等）。 影响/提示：升级集群前先统一平台 JDK 版本，CI/CD/容器镜像也要对应更新。 许多新的 KIP（功能增强）与性能/可观测性改进 说明：包含改进的 Streams rebalance、更多 Admin/运维命令、节点注册/列举能力、插件/指标扩展点等（多项 KIP 在 4.0/4.1 陆续落地）。这些改进覆盖 Broker、Controller、Producer、Consumer、Admin 和 Streams 子系统。 影响/提示：运维与监控面板可能受益（新增可观测指标/API）；如果你有自定义插件或监控接入，需要检查新的插件/metrics 注册机制。","summary":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。","date_published":"2025-10-16T13:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/","url":"https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/","title":"Kafka 的 常用命令","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Kafka 的 常用命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/kafka-3-demo\">Java-Client 代码示例</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"topic\">topic</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 topic</span></span><br><span class=\"line\">kafka-topics.sh --create --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --partitions 3 --replication-factor 2</span><br><span class=\"line\"><span class=\"comment\"># --bootstrap-server 指定 kafka 集群地址</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 创建的 topic 名称</span></span><br><span class=\"line\"><span class=\"comment\"># --partitions 指定分区数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class=\"line\"><span class=\"comment\"># --replication-factor 指定副本数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出 topic</span></span><br><span class=\"line\">kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class=\"line\"><span class=\"comment\"># 查看 topic 详情</span></span><br><span class=\"line\">kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Topic: <span class=\"built_in\">test</span>\tTopicId: Ru0tWQJ4RMWcjjGsKAdWQg\tPartitionCount: 3\tReplicationFactor: 3\tConfigs:</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 0\tLeader: 3\tReplicas: 3,1,2\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 1\tLeader: 1\tReplicas: 1,2,3\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 2\tLeader: 2\tReplicas: 2,3,1\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\"><span class=\"comment\">## 输出说明</span></span><br><span class=\"line\"><span class=\"comment\"># 总体信息（Topic 概览）Topic: test\tTopicId: Ru0tWQJ4RMWcjjGsKAdWQg\tPartitionCount: 3\tReplicationFactor: 3\tConfigs:</span></span><br><span class=\"line\">| 字段                                  | 含义                                                            |</span><br><span class=\"line\">| ----------------------------------- | ------------------------------------------------------------- |</span><br><span class=\"line\">| **Topic: disTopic**                 | Topic 名称，即当前描述的主题。                                            |</span><br><span class=\"line\">| **TopicId: VUK7Mc9oQdS1mjGG7OhQzQ** | Kafka 内部自动生成的唯一标识符（UUID），Kafka 3.x 之后引入，用于区分同名但不同生命周期的 topic。 |</span><br><span class=\"line\">| **PartitionCount: 3**               | 该主题有 3 个分区（partition）。每个分区存储一部分消息。                            |</span><br><span class=\"line\">| **ReplicationFactor:**              | 副本因子。这里虽然输出中没显示具体值，但可从每行分区配置推断是 **3**（每个分区有 3 个副本）。           |</span><br><span class=\"line\">| **Configs:**                        | topic 的配置项（例如清理策略、压缩类型等），如果为空，说明使用默认配置。                       |</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分区详情（每个 Partition 一行）</span></span><br><span class=\"line\"></span><br><span class=\"line\">| 字段                                | 含义                                                          |</span><br><span class=\"line\">| --------------------------------- | ----------------------------------------------------------- |</span><br><span class=\"line\">| **Partition: 0**                  | 第 0 号分区。                                                    |</span><br><span class=\"line\">| **Leader: 2**                     | 该分区当前的 **Leader Broker 是 broker ID = 2**，只有 Leader 才处理读写请求。 |</span><br><span class=\"line\">| **Replicas: 2,3,1**               | 该分区的所有副本存放在哪些 Broker 上（即副本分布,AR），分别是 broker 2、3、1。             |</span><br><span class=\"line\">| **Isr (In-Sync Replicas): 2,3,1** | 当前与 Leader 保持同步的副本集合。这里所有副本都在同步中（健康状态 👍）。                  |</span><br><span class=\"line\">| **Elr / LastKnownElr**            | Kafka 新版本中引入的 <span class=\"string\">&quot;Enhanced Leader Replica&quot;</span> 状态，目前未启用（N/A）。      |</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 topic</span></span><br><span class=\"line\">kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"consumer\">consumer</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 consumer</span></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --group <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 指定 topic</span></span><br><span class=\"line\"><span class=\"comment\"># --group 指定 consumer 组</span></span><br><span class=\"line\"></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span>  --from-beginning</span><br><span class=\"line\"><span class=\"comment\"># --from-beginning 从 topic 的最开始消费</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"consumer-group\">consumer-group</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出 consumer 组</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class=\"line\"><span class=\"comment\"># --bootstrap-server 集群地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 consumer 组详情</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">GROUP  TOPIC  PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG  CONSUMER-ID                                             HOST         CLIENT-ID</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   0          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   1          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   2          1               1               0    console-consumer-9ac45b29-d8f3-4649-ab09-7b567aa2ba53  /10.250.0.108 console-consumer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 输出说明</span></span><br><span class=\"line\"><span class=\"comment\"># GROUP       消费组名称</span></span><br><span class=\"line\"><span class=\"comment\"># TOPIC       topic 名称</span></span><br><span class=\"line\"><span class=\"comment\"># PARTITION   分区编号</span></span><br><span class=\"line\"><span class=\"comment\"># CURRENT-OFFSET  当前消费的 offset</span></span><br><span class=\"line\"><span class=\"comment\"># LOG-END-OFFSET   topic 中最大的 offset</span></span><br><span class=\"line\"><span class=\"comment\"># LAG         当前消费的 offset 与 topic 中最大的 offset 的差值，即剩余未消费的 消息数量</span></span><br><span class=\"line\"><span class=\"comment\"># CONSUMER-ID  当前消费的 consumer 的 id</span></span><br><span class=\"line\"><span class=\"comment\"># HOST        当前消费的 consumer 的主机名</span></span><br><span class=\"line\"><span class=\"comment\"># CLIENT-ID   当前消费的 consumer 的客户端名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 consumer 组</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"producer\">producer</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 producer</span></span><br><span class=\"line\">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 指定 topic</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"手动触发-Kafka-Partitoin-的-Leader-选举-自平衡\">手动触发 Kafka Partitoin 的 Leader 选举(自平衡)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>kafka的自平衡默认开启，每隔 300秒扫描一次，如果需要平衡的比例高于 10%，则会触发一次</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启自动平衡</span></span><br><span class=\"line\">auto.leader.rebalance.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 间隔扫描时间 默认 300 秒</span></span><br><span class=\"line\">eader.imbalance.check.interval.seconds=300</span><br><span class=\"line\"><span class=\"comment\"># 触发比例，即扫描的 broker 上需要平衡的 partition 占当前 broker 全部 partition 的比例，默认 10%</span></span><br><span class=\"line\">leader.imbalance.per.broker.percentage=10</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>建议关闭，改为业务低峰时手动触发</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动平衡</span></span><br><span class=\"line\">kafka-leader-election.sh --bootstrap-server localhost:9092  --election-type preferred --topic <span class=\"built_in\">test</span> --partition 0</span><br><span class=\"line\"><span class=\"comment\"># --topic 指定要触发的 topic</span></span><br><span class=\"line\"><span class=\"comment\"># --partition 0 触发 partition 0 的 leader 选举</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>🧩 参数说明：–election-type</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数值</th>\n<th>含义</th>\n<th>触发条件</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>preferred</code></strong></td>\n<td><strong>首选 Leader 选举</strong>（Preferred Leader Election）<br>Kafka 会尝试将分区的 leader 重新切换为「首选副本」（通常是第一个副本）。</td>\n<td>只有当前 leader <strong>不是</strong> 首选副本时才执行。</td>\n<td>某些副本被自动选举成 leader 后，希望恢复原有「首选 leader」结构，以实现负载均衡。</td>\n</tr>\n<tr>\n<td><strong><code>unclean</code></strong></td>\n<td><strong>非干净 Leader 选举</strong>（Unclean Leader Election）<br>允许从不同步的副本中选举新的 leader。</td>\n<td>仅在分区 <strong>没有可用 leader</strong> 时执行。</td>\n<td>在紧急恢复场景下（比如所有 ISR 副本都下线），为了恢复服务可用性，即使会导致数据丢失。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Leader Partition⾃动平衡机制</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Leader Partitoin选举机制能够保证每⼀个Partition同⼀时刻有且仅有⼀个Leader Partition。但是，是不是只要分配好了Leader Partition就够了呢？</li>\n<li class=\"lvl-6\">在⼀组Partiton中，Leader Partition通常是⽐较繁忙的节点，因为他要负责与客户端的数据交互，以及向Follower同步数据。默认情况下，Kafka会尽量将Leader Partition分配到不同的Broker节点上，⽤以保证整个集群的性能压⼒能够⽐较平均。</li>\n<li class=\"lvl-6\">但是，经过Leader Partition选举后，这种平衡就有可能会被打破，让Leader Partition过多的集中到同⼀个Broker上。这样，这个Broker的压⼒就会明显⾼于其他Broker，从⽽影响到集群的整体性能。</li>\n<li class=\"lvl-6\">为此，Kafka设计了Leader Partition⾃动平衡机制，当发现Leader分配不均衡时，⾃动进⾏Leader Partition调整。</li>\n<li class=\"lvl-6\">Kafka在进⾏Leader Partition⾃平衡时的逻辑是这样的：他会认为AR(Replicas副本集)当中的第⼀个节点就应该是Leader节点。这种选举结果成为preferred election 理想选举结果。</li>\n<li class=\"lvl-6\">Controller会定期检测集群的Partition平衡情况，在开始检测时，Controller会依次检查所有的Broker。当发现这个Broker上的不平衡的Partition⽐例⾼于<code>leader.imbalance.per.broker.percentage</code>阈值时，就会触发⼀次Leader Partiton的⾃平衡。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Kafka 的 常用命令 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Java-Client 代码示例 topic 12345678910111213141516171819202122232425262728293031323334353637383940# 创建 topickafka-topics.sh --create --bootstrap-server localhost:9092 --topic test --partitions 3 --replication-factor 2# --bootstrap-server 指定 kafka 集群地址# --topic 创建的 topic 名称# --partitions 指定分区数，不设置则默认使用 server.properties 中设置的默认值# --replication-factor 指定副本数，不设置则默认使用 server.properties 中设置的默认值# 列出 topickafka-topics.sh --list --bootstrap-server localhost:9092# 查看 topic 详情kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test## 输出Topic: test TopicId: Ru0tWQJ4RMWcjjGsKAdWQg PartitionCount: 3 ReplicationFactor: 3 Configs: Topic: test Partition: 0 Leader: 3 Replicas: 3,1,2 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A Topic: test Partition: 1 Leader: 1 Replicas: 1,2,3 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A Topic: test Partition: 2 Leader: 2 Replicas: 2,3,1 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A## 输出说明# 总体信息（Topic 概览）Topic: test TopicId: Ru0tWQJ4RMWcjjGsKAdWQg PartitionCount: 3 ReplicationFactor: 3 Configs:| 字段 | 含义 || ----------------------------------- | ------------------------------------------------------------- || **Topic: disTopic** | Topic 名称，即当前描述的主题。 || **TopicId: VUK7Mc9oQdS1mjGG7OhQzQ** | Kafka 内部自动生成的唯一标识符（UUID），Kafka 3.x 之后引入，用于区分同名但不同生命周期的 topic。 || **PartitionCount: 3** | 该主题有 3 个分区（partition）。每个分区存储一部分消息。 || **ReplicationFactor:** | 副本因子。这里虽然输出中没显示具体值，但可从每行分区配置推断是 **3**（每个分区有 3 个副本）。 || **Configs:** | topic 的配置项（例如清理策略、压缩类型等），如果为空，说明使用默认配置。 |# 分区详情（每个 Partition 一行）| 字段 | 含义 || --------------------------------- | ----------------------------------------------------------- || **Partition: 0** | 第 0 号分区。 || **Leader: 2** | 该分区当前的 **Leader Broker 是 broker ID = 2**，只有 Leader 才处理读写请求。 || **Replicas: 2,3,1** | 该分区的所有副本存放在哪些 Broker 上（即副本分布,AR），分别是 broker 2、3、1。 || **Isr (In-Sync Replicas): 2,3,1** | 当前与 Leader 保持同步的副本集合。这里所有副本都在同步中（健康状态 👍）。 || **Elr / LastKnownElr** | Kafka 新版本中引入的 &quot;Enhanced Leader Replica&quot; 状态，目前未启用（N/A）。 |# 删除 topickafka-topics.sh --delete --bootstrap-server localhost:9092 --topic test consumer 1234567# 创建 consumerkafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --group test# --topic 指定 topic# --group 指定 consumer 组kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning# --from-beginning 从 topic 的最开始消费 consumer-group 12345678910111213141516171819202122232425# 列出 consumer 组kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list# --bootstrap-server 集群地址# 查看 consumer 组详情kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group test## 输出GROUP TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST CLIENT-IDtest test 0 2 2 0 console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1 /10.250.0.7 console-consumertest test 1 2 2 0 console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1 /10.250.0.7 console-consumertest test 2 1 1 0 console-consumer-9ac45b29-d8f3-4649-ab09-7b567aa2ba53 /10.250.0.108 console-consumer## 输出说明# GROUP 消费组名称# TOPIC topic 名称# PARTITION 分区编号# CURRENT-OFFSET 当前消费的 offset# LOG-END-OFFSET topic 中最大的 offset# LAG 当前消费的 offset 与 topic 中最大的 offset 的差值，即剩余未消费的 消息数量# CONSUMER-ID 当前消费的 consumer 的 id# HOST 当前消费的 consumer 的主机名# CLIENT-ID 当前消费的 consumer 的客户端名称# 删除 consumer 组kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group test producer 123# 创建 producerkafka-console-producer.sh --bootstrap-server localhost:9092 --topic test# --topic 指定 topic 手动触发 Kafka Partitoin 的 Leader 选举(自平衡) kafka的自平衡默认开启，每隔 300秒扫描一次，如果需要平衡的比例高于 10%，则会触发一次 123456# 开启自动平衡auto.leader.rebalance.enable=true# 间隔扫描时间 默认 300 秒eader.imbalance.check.interval.seconds=300# 触发比例，即扫描的 broker 上需要平衡的 partition 占当前 broker 全部 partition 的比例，默认 10%leader.imbalance.per.broker.percentage=10 建议关闭，改为业务低峰时手动触发 1234# 自动平衡kafka-leader-election.sh --bootstrap-server localhost:9092 --election-type preferred --topic test --partition 0# --topic 指定要触发的 topic# --partition 0 触发 partition 0 的 leader 选举 🧩 参数说明：–election-type 参数值 含义 触发条件 典型使用场景 preferred 首选 Leader 选举（Preferred Leader Election）Kafka 会尝试将分区的 leader 重新切换为「首选副本」（通常是第一个副本）。 只有当前 leader 不是 首选副本时才执行。 某些副本被自动选举成 leader 后，希望恢复原有「首选 leader」结构，以实现负载均衡。 unclean 非干净 Leader 选举（Unclean Leader Election）允许从不同步的副本中选举新的 leader。 仅在分区 没有可用 leader 时执行。 在紧急恢复场景下（比如所有 ISR 副本都下线），为了恢复服务可用性，即使会导致数据丢失。 Leader Partition⾃动平衡机制 Leader Partitoin选举机制能够保证每⼀个Partition同⼀时刻有且仅有⼀个Leader Partition。但是，是不是只要分配好了Leader Partition就够了呢？ 在⼀组Partiton中，Leader Partition通常是⽐较繁忙的节点，因为他要负责与客户端的数据交互，以及向Follower同步数据。默认情况下，Kafka会尽量将Leader Partition分配到不同的Broker节点上，⽤以保证整个集群的性能压⼒能够⽐较平均。 但是，经过Leader Partition选举后，这种平衡就有可能会被打破，让Leader Partition过多的集中到同⼀个Broker上。这样，这个Broker的压⼒就会明显⾼于其他Broker，从⽽影响到集群的整体性能。 为此，Kafka设计了Leader Partition⾃动平衡机制，当发现Leader分配不均衡时，⾃动进⾏Leader Partition调整。 Kafka在进⾏Leader Partition⾃平衡时的逻辑是这样的：他会认为AR(Replicas副本集)当中的第⼀个节点就应该是Leader节点。这种选举结果成为preferred election 理想选举结果。 Controller会定期检测集群的Partition平衡情况，在开始检测时，Controller会依次检查所有的Broker。当发现这个Broker上的不平衡的Partition⽐例⾼于leader.imbalance.per.broker.percentage阈值时，就会触发⼀次Leader Partiton的⾃平衡。","summary":"摘要 本文介绍 Kafka 的 常用命令 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Java-Client 代码示例","date_published":"2025-10-15T12:30:05.000Z","tags":["技术","kafka","分布式","kafka"]}]}