{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/","url":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/","title":"Docker Swarm 之 网络(Overlay)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 网络(Overlay)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Overlay-简介\">Overlay 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>overlay 网络特点</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。</li>\n<li class=\"lvl-4\">内置服务发现：容器之间可以通过服务名称直接通信。</li>\n<li class=\"lvl-4\">支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。</li>\n<li class=\"lvl-4\">自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Swarm-中的-overlay-网络\">Swarm 中的 overlay 网络</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：<code>docker_gwbridge</code> ，一个是 overlay network：<code>ingress</code>。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class=\"line\">6b7aadbbd180   bridge            bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">5ddadf5d0608   docker_gwbridge   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">21c6f5b1bedd   host              host      <span class=\"built_in\">local</span></span><br><span class=\"line\">idx465x3jg68   ingress           overlay   swarm</span><br><span class=\"line\">a770c5ad4b13   none              null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-gwbridge\"><code>docker_gwbridge</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 <code>docker_gwbridge</code> 详情，其网段为 <code>172.18.0.0/16</code>，网关为 <code>172.18.0.1</code>，内部有一个容器 <code>ingress-sbox</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect docker_gwbridge</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;docker_gwbridge&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Id&quot;</span>: <span class=\"string\">&quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Created&quot;</span>: <span class=\"string\">&quot;2025-06-08T07:29:52.119033035-04:00&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Scope&quot;</span>: <span class=\"string\">&quot;local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;EnableIPv6&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;IPAM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Options&quot;</span>: null,</span><br><span class=\"line\">            <span class=\"string\">&quot;Config&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;Subnet&quot;</span>: <span class=\"string\">&quot;172.18.0.0/16&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;Gateway&quot;</span>: <span class=\"string\">&quot;172.18.0.1&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Internal&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Attachable&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ingress&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Network&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigOnly&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Containers&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;gateway_ingress-sbox&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.18.0.2/16&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Options&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class=\"string\">&quot;false&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class=\"string\">&quot;true&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.name&quot;</span>: <span class=\"string\">&quot;docker_gwbridge&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先来看这个网段 <code>172.18.0.0/16</code>，我们查看主机的网络和路由表，可以看到 <code>261: docker_gwbridge</code>，其IP地址为 <code>172.18.0.1</code>，所以这里我们就可以知道 <code>docker_gwbridge</code> 就是连接到<code>261: docker_gwbridge</code>这块网卡上的，另外当前还有一个<code>263: veth3176100@if262</code>虚拟网络接口也连接到<code>261: docker_gwbridge</code>上，通过路由表我们得知其最终连接到<code>2: enp0s5</code>上，也就是这台主机的网卡。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute</span><br><span class=\"line\">       valid_lft 2591886sec preferred_lft 604686sec</span><br><span class=\"line\">    inet6 fe80::21c:42ff:fe49:1282/64 scope <span class=\"built_in\">link</span> noprefixroute</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:5c:31:<span class=\"built_in\">cd</span>:30 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:5cff:fe31:cd30/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:feff:fee3:caf7/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class=\"line\">    inet6 fe80::944b:c1ff:fed9:83c5/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看路由表</span></span><br><span class=\"line\">route -n</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上</span></span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         10.211.55.1     0.0.0.0         UG    100    0        0 enp0s5</span><br><span class=\"line\">10.211.55.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s5</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class=\"line\">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker_gwbridge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100</span></span><br><span class=\"line\">brctl show docker_gwbridge</span><br><span class=\"line\">bridge name     bridge <span class=\"built_in\">id</span>               STP enabled     interfaces</span><br><span class=\"line\">docker_gwbridge         8000.0242fee3caf7       no              veth3176100</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按理说<code>263: veth3176100@if262</code>虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 <code>ingress-sbox</code>，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的<code>/var/run/docker/netns/</code>下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /var/run/docker/netns/</span><br><span class=\"line\"><span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线</span></span><br><span class=\"line\">1-idx465x3jg  ingress_sbox</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：<code>262: eth1@if263</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=ingress_sbox ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class=\"line\">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里还有一个网络接口 <code>259: eth0@if260</code>，它又是与谁对接的呢？别着急，我们接着往下看。</p>\n</li>\n</ul>\n<h3 id=\"ingress\"><code>ingress</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 <code>ingress</code> 详情，其网段为 <code>10.0.0.0/24</code>，网关为 <code>10.0.0.1</code>，内部有一个容器 <code>ingress-sbox</code>，另外其有一个<code>Peers</code>属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network inspect ingress</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ingress&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Id&quot;</span>: <span class=\"string\">&quot;idx465x3jg682fmceumsio297&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Created&quot;</span>: <span class=\"string\">&quot;2025-06-08T07:29:51.734714967-04:00&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Scope&quot;</span>: <span class=\"string\">&quot;swarm&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;overlay&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;EnableIPv6&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;IPAM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Options&quot;</span>: null,</span><br><span class=\"line\">            <span class=\"string\">&quot;Config&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;Subnet&quot;</span>: <span class=\"string\">&quot;10.0.0.0/24&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;Gateway&quot;</span>: <span class=\"string\">&quot;10.0.0.1&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Internal&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Attachable&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ingress&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Network&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigOnly&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Containers&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ingress-endpoint&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:0a:00:00:02&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;10.0.0.2/24&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Options&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.driver.overlay.vxlanid_list&quot;</span>: <span class=\"string\">&quot;4096&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Peers&quot;</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;4969a4611607&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.10&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ae3756658a26&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.14&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;f12309731131&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.13&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;de5000b11067&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.12&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;377001904d63&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.11&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们还是先来看这个网关<code>10.0.0.1</code>，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从<code>/var/run/docker/netns</code>中查看一下，这里还有一个名称为 <code>1-idx465x3jg</code> 的网络命名空间，我们进去看看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.0.0.1/24 brd 10.0.0.255 scope global br0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 8a:d3:52:ac:7d:<span class=\"built_in\">cd</span> brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在这里我们找到了<code>2: br0</code>，其IP地址为<code>10.0.0.1</code>，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 <code>260: veth0@if259</code>，这个就是与<code>ingress_sbox</code> 中<code>259: eth0@if260</code>对应的网络接口 ，另一个是 <code>258: vxlan0@if258</code>，其基于<code>vxlan</code>协议，负责集群跨主机通信。</p>\n</li>\n</ul>\n<h3 id=\"overlay总结\">overlay总结</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker_gwbridge</code>中的容器<code>ingress-sbox</code>，其有两块网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当请求到达宿主机时，会通过<code>enp0s5</code>转发到<code>docker_gwbridge</code>，然后先被转到<code>ingress-sbox</code>容器，然后再经过其转发到<code>br0</code>网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过<code>vxlan0</code>网络接口转发到其它节点进行查找。</p>\n</li>\n</ul>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/YvRbJE.png\" alt=\"\"></p>\n<h2 id=\"查看overlay网络中的负载均衡\">查看overlay网络中的负载均衡</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动一个service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create --name my-nginx --replicas 5 --publish 80:80 nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看<code>ingress_sbox</code>的<code>iptables</code>数据链</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261</span></span><br><span class=\"line\">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\">    0     0 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 MARK <span class=\"built_in\">set</span> 0x105</span><br><span class=\"line\"></span><br><span class=\"line\">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\">    0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.0.33            MARK <span class=\"built_in\">set</span> 0x105</span><br><span class=\"line\"></span><br><span class=\"line\">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\"></span><br><span class=\"line\">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\"></span><br><span class=\"line\">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过<code>ipvsadm</code>查看ipvs信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果没有ipvsadm，则安装</span></span><br><span class=\"line\">dnf install ipvsadm -y</span><br><span class=\"line\"><span class=\"comment\"># 查看ipvs信息</span></span><br><span class=\"line\">nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 FWM 261 rr，这里rr表示轮询</span></span><br><span class=\"line\">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class=\"line\">Prot LocalAddress:Port Scheduler Flags</span><br><span class=\"line\">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class=\"line\">FWM  261 rr</span><br><span class=\"line\">  -&gt; 10.0.0.34:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.35:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.36:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.37:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.38:0                  Masq    1      0          0</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker Swarm 的 网络(Overlay) Docker官方文档 Docker Swarm 官方文档 Overlay 简介 在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。 当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。 overlay 网络特点 跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。 内置服务发现：容器之间可以通过服务名称直接通信。 支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。 自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。 Swarm 中的 overlay 网络 当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：docker_gwbridge ，一个是 overlay network：ingress。 1234567docker network lsNETWORK ID NAME DRIVER SCOPE6b7aadbbd180 bridge bridge local5ddadf5d0608 docker_gwbridge bridge local21c6f5b1bedd host host localidx465x3jg68 ingress overlay swarma770c5ad4b13 none null local docker_gwbridge 查看 docker_gwbridge 详情，其网段为 172.18.0.0/16，网关为 172.18.0.1，内部有一个容器 ingress-sbox 12345678910111213141516171819202122232425262728293031323334353637383940414243docker inspect docker_gwbridge[ &#123; &quot;Name&quot;: &quot;docker_gwbridge&quot;, &quot;Id&quot;: &quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;, &quot;Created&quot;: &quot;2025-06-08T07:29:52.119033035-04:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;ingress-sbox&quot;: &#123; &quot;Name&quot;: &quot;gateway_ingress-sbox&quot;, &quot;EndpointID&quot;: &quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.enable_icc&quot;: &quot;false&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker_gwbridge&quot; &#125;, &quot;Labels&quot;: &#123;&#125; &#125;] 先来看这个网段 172.18.0.0/16，我们查看主机的网络和路由表，可以看到 261: docker_gwbridge，其IP地址为 172.18.0.1，所以这里我们就可以知道 docker_gwbridge 就是连接到261: docker_gwbridge这块网卡上的，另外当前还有一个263: veth3176100@if262虚拟网络接口也连接到261: docker_gwbridge上，通过路由表我们得知其最终连接到2: enp0s5上，也就是这台主机的网卡。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ip a## 输出结果1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5 valid_lft forever preferred_lft forever inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute valid_lft 2591886sec preferred_lft 604686sec inet6 fe80::21c:42ff:fe49:1282/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:5c:31:cd:30 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:5cff:fe31:cd30/64 scope link valid_lft forever preferred_lft forever261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge valid_lft forever preferred_lft forever inet6 fe80::42:feff:fee3:caf7/64 scope link valid_lft forever preferred_lft forever263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default link/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::944b:c1ff:fed9:83c5/64 scope link valid_lft forever preferred_lft forever# 查看路由表route -n## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.211.55.1 0.0.0.0 UG 100 0 0 enp0s510.211.55.0 0.0.0.0 255.255.255.0 U 100 0 0 enp0s5172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0172.18.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker_gwbridge# 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100brctl show docker_gwbridgebridge name bridge id STP enabled interfacesdocker_gwbridge 8000.0242fee3caf7 no veth3176100 按理说263: veth3176100@if262虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 ingress-sbox，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的/var/run/docker/netns/下 1234cd /var/run/docker/netns/ls## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线1-idx465x3jg ingress_sbox 进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：262: eth1@if263 12345678910111213141516nsenter --net=ingress_sbox ip a## 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default link/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0 valid_lft forever preferred_lft forever262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1 valid_lft forever preferred_lft forever 这里还有一个网络接口 259: eth0@if260，它又是与谁对接的呢？别着急，我们接着往下看。 ingress 查看 ingress 详情，其网段为 10.0.0.0/24，网关为 10.0.0.1，内部有一个容器 ingress-sbox，另外其有一个Peers属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364docker network inspect ingress## 输出[ &#123; &quot;Name&quot;: &quot;ingress&quot;, &quot;Id&quot;: &quot;idx465x3jg682fmceumsio297&quot;, &quot;Created&quot;: &quot;2025-06-08T07:29:51.734714967-04:00&quot;, &quot;Scope&quot;: &quot;swarm&quot;, &quot;Driver&quot;: &quot;overlay&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;10.0.0.0/24&quot;, &quot;Gateway&quot;: &quot;10.0.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: true, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;ingress-sbox&quot;: &#123; &quot;Name&quot;: &quot;ingress-endpoint&quot;, &quot;EndpointID&quot;: &quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;, &quot;MacAddress&quot;: &quot;02:42:0a:00:00:02&quot;, &quot;IPv4Address&quot;: &quot;10.0.0.2/24&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4096&quot; &#125;, &quot;Labels&quot;: &#123;&#125;, &quot;Peers&quot;: [ &#123; &quot;Name&quot;: &quot;4969a4611607&quot;, &quot;IP&quot;: &quot;10.211.55.10&quot; &#125;, &#123; &quot;Name&quot;: &quot;ae3756658a26&quot;, &quot;IP&quot;: &quot;10.211.55.14&quot; &#125;, &#123; &quot;Name&quot;: &quot;f12309731131&quot;, &quot;IP&quot;: &quot;10.211.55.13&quot; &#125;, &#123; &quot;Name&quot;: &quot;de5000b11067&quot;, &quot;IP&quot;: &quot;10.211.55.12&quot; &#125;, &#123; &quot;Name&quot;: &quot;377001904d63&quot;, &quot;IP&quot;: &quot;10.211.55.11&quot; &#125; ] &#125;] 我们还是先来看这个网关10.0.0.1，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从/var/run/docker/netns中查看一下，这里还有一个名称为 1-idx465x3jg 的网络命名空间，我们进去看看 12345678910111213141516nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a## 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default link/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 02: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default link/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff inet 10.0.0.1/24 brd 10.0.0.255 scope global br0 valid_lft forever preferred_lft forever260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default link/ether 8a:d3:52:ac:7d:cd brd ff:ff:ff:ff:ff:ff link-netnsid 1 在这里我们找到了2: br0，其IP地址为10.0.0.1，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 260: veth0@if259，这个就是与ingress_sbox 中259: eth0@if260对应的网络接口 ，另一个是 258: vxlan0@if258，其基于vxlan协议，负责集群跨主机通信。 overlay总结 docker_gwbridge中的容器ingress-sbox，其有两块网卡，一块对接宿主机上的 261: docker_gwbridge，另一块对接/var/run/docker/netns/1-idx465x3jg中的 2: br0。 实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 261: docker_gwbridge，另一块对接/var/run/docker/netns/1-idx465x3jg中的 2: br0。 当请求到达宿主机时，会通过enp0s5转发到docker_gwbridge，然后先被转到ingress-sbox容器，然后再经过其转发到br0网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过vxlan0网络接口转发到其它节点进行查找。 查看overlay网络中的负载均衡 启动一个service 1docker service create --name my-nginx --replicas 5 --publish 80:80 nginx 查看ingress_sbox的iptables数据链 123456789101112131415161718nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 MARK tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 MARK set 0x105Chain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 MARK all -- * * 0.0.0.0/0 10.0.0.33 MARK set 0x105Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destinationChain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destinationChain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 通过ipvsadm查看ipvs信息 1234567891011121314# 如果没有ipvsadm，则安装dnf install ipvsadm -y# 查看ipvs信息nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln## 输出，可以看到 FWM 261 rr，这里rr表示轮询IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnFWM 261 rr -&gt; 10.0.0.34:0 Masq 1 0 0 -&gt; 10.0.0.35:0 Masq 1 0 0 -&gt; 10.0.0.36:0 Masq 1 0 0 -&gt; 10.0.0.37:0 Masq 1 0 0 -&gt; 10.0.0.38:0 Masq 1 0 0","summary":"摘要 本文介绍 Docker Swarm 的 网络(Overlay) Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-11T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/","url":"https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/","title":"Docker Swarm 之 服务(Service)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 服务管理</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Service-与-Task\">Service 与 Task</h2>\n<h3 id=\"什么是-Service？\">什么是 Service？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。</p>\n</li>\n</ul>\n<h3 id=\"什么是-Task？\">什么是 Task？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。</p>\n</li>\n</ul>\n<h3 id=\"示例\">示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create --name nginx --replicas 3 nginx:latest</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>Service</th>\n<th>Task</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义</td>\n<td>用户定义的服务配置</td>\n<td>服务配置生成的执行单元</td>\n</tr>\n<tr>\n<td>数量关系</td>\n<td>一个 Service 包含多个 Task</td>\n<td>一个 Task 属于一个 Service</td>\n</tr>\n<tr>\n<td>状态</td>\n<td>描述“期望状态”</td>\n<td>代表“实际状态”</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>可以更新</td>\n<td>不可变，更新意味着重新创建</td>\n</tr>\n<tr>\n<td>管理者</td>\n<td>由用户管理</td>\n<td>完全由 Swarm 调度和管理</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Service-相关命令\">Service 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>创建一个新的服务</td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>显示一个或多个服务的详细信息</td>\n</tr>\n<tr>\n<td>logs</td>\n<td>获取服务或任务的日志</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出所有服务</td>\n</tr>\n<tr>\n<td>ps</td>\n<td>列出一个或多个服务的任务（Task）</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除一个或多个服务</td>\n</tr>\n<tr>\n<td>rollback</td>\n<td>回滚服务的配置更改</td>\n</tr>\n<tr>\n<td>scale</td>\n<td>扩缩一个或多个可复制服务的副本数量</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新服务配置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-service-create-创建服务\"><code>docker service create</code>:  创建服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例命令（含说明）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--name</code></td>\n<td>指定服务名称</td>\n<td><code>docker service create --name my-web nginx</code><br>→ 创建一个名为 <code>my-web</code> 的 nginx 服务</td>\n</tr>\n<tr>\n<td><code>--replicas</code></td>\n<td>设置副本数量（仅适用于 replicated 模式）</td>\n<td><code>docker service create --replicas 3 nginx</code><br>→ 启动 3 个 nginx 副本</td>\n</tr>\n<tr>\n<td><code>--publish</code> 或 <code>-p</code></td>\n<td>映射端口（格式如 <code>80:80</code>）</td>\n<td><code>docker service create -p 8080:80 nginx</code><br>→ 将容器的 80 端口映射到主机 8080</td>\n</tr>\n<tr>\n<td><code>--env</code> 或 <code>-e</code></td>\n<td>设置环境变量</td>\n<td><code>docker service create -e ENV=prod nginx</code><br>→ 设置环境变量 <code>ENV=prod</code></td>\n</tr>\n<tr>\n<td><code>--mount</code></td>\n<td>设置数据卷挂载</td>\n<td><code>docker service create --mount type=bind,src=/data,target=/app nginx</code><br>→ 将主机的 <code>/data</code> 目录挂载到容器内 <code>/app</code></td>\n</tr>\n<tr>\n<td><code>--constraint</code></td>\n<td>设置部署约束（如指定节点）</td>\n<td><code>docker service create --constraint 'node.labels.type == web' nginx</code><br>→ 仅部署在带标签 <code>type=web</code> 的节点上</td>\n</tr>\n<tr>\n<td><code>--network</code></td>\n<td>指定服务所属的网络（通常使用 overlay 网络）</td>\n<td><code>docker service create --network my-net nginx</code><br>→ 将服务连接到自定义网络 <code>my-net</code></td>\n</tr>\n<tr>\n<td><code>--detach</code> 或 <code>-d</code></td>\n<td>后台运行服务（默认行为）</td>\n<td><code>docker service create -d nginx</code><br>→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行</td>\n</tr>\n<tr>\n<td><code>--limit-cpu</code> / <code>--limit-memory</code></td>\n<td>设置资源限制</td>\n<td><code>docker service create --limit-cpu 0.5 --limit-memory 256M nginx</code><br>→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存</td>\n</tr>\n<tr>\n<td><code>--restart-condition</code></td>\n<td>设置重启策略（如 on-failure、any、none）</td>\n<td><code>docker service create --restart-condition on-failure nginx</code><br>→ 仅当容器失败时自动重启</td>\n</tr>\n<tr>\n<td><code>--mode</code></td>\n<td>指定服务运行模式，支持：<code>replicated</code>、<code>global</code>、<code>replicated-job</code>、<code>global-job</code></td>\n<td><code>docker service create --mode global nginx</code><br>→ 在集群每个节点上运行一个 nginx 实例</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务运行模式（–mode）详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>模式名称</th>\n<th>说明</th>\n<th>使用场景示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>replicated</code></td>\n<td>默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。</td>\n<td>典型的 Web 服务，如 nginx、Node.js、Java 应用等</td>\n</tr>\n<tr>\n<td><code>global</code></td>\n<td>每个可用节点只部署一个任务实例，不需要用户指定副本数。</td>\n<td>系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter）</td>\n</tr>\n<tr>\n<td><code>replicated-job</code></td>\n<td>在多个节点上<strong>按副本数</strong>运行一次性任务，任务完成后即退出。</td>\n<td>数据处理、批处理任务，如转换文件或跑 ETL</td>\n</tr>\n<tr>\n<td><code>global-job</code></td>\n<td>在<strong>所有节点上各运行一次</strong>的短暂任务，执行完毕即退出。</td>\n<td>初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。<br>\nreplicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务重启策略（–restart-condition）详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>none</code></td>\n<td>不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。</td>\n</tr>\n<tr>\n<td><code>on-failure</code></td>\n<td><strong>仅在任务异常失败时</strong>（exit code 非 0）自动重启。常用于可能偶发失败的服务。</td>\n</tr>\n<tr>\n<td><code>any</code>（默认）</td>\n<td><strong>无论任务如何退出</strong>（包括正常退出或失败），都会尝试重启。适用于持续运行服务。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>情景总结</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>情景</th>\n<th><code>none</code></th>\n<th><code>on-failure</code></th>\n<th><code>any</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务运行时崩溃（exit code ≠ 0）</td>\n<td>❌ 不重启</td>\n<td>✅ 自动重启</td>\n<td>✅ 自动重启</td>\n</tr>\n<tr>\n<td>服务正常结束（exit code = 0）</td>\n<td>❌ 不重启</td>\n<td>❌ 不重启</td>\n<td>✅ 自动重启</td>\n</tr>\n<tr>\n<td>持续运行型服务（如 nginx）</td>\n<td>❌ 不推荐</td>\n<td>可用</td>\n<td>✅ 推荐</td>\n</tr>\n<tr>\n<td>一次性任务（如批处理、数据初始化）</td>\n<td>✅ 推荐</td>\n<td>可用</td>\n<td>❌ 不推荐</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"docker-service-create-使用示例\"><code>docker service create</code> 使用示例</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  --publish 80:80 \\</span><br><span class=\"line\">  nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># global</span></span><br><span class=\"line\">docker service create --name log-agent --mode global fluentd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name web-app \\</span><br><span class=\"line\">  --<span class=\"built_in\">env</span> NODE_ENV=production \\</span><br><span class=\"line\">  --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,src=/data,target=/app/data \\</span><br><span class=\"line\">  --replicas 2 \\</span><br><span class=\"line\">  node:18 node server.js</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建数据卷</span></span><br><span class=\"line\">docker volume create db-data</span><br><span class=\"line\"><span class=\"comment\"># 创建服务</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name db \\</span><br><span class=\"line\">  --constraint <span class=\"string\">&#x27;node.labels.role == db&#x27;</span> \\</span><br><span class=\"line\">  --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=db-data,target=/var/lib/mysql \\</span><br><span class=\"line\">  mysql:8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用 on-failure 策略，仅在失败时自动重启</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name unstable-worker \\</span><br><span class=\"line\">  --restart-condition on-failure \\</span><br><span class=\"line\">  my-worker-image</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指定网络，网络驱动类型为 overlay</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）</span></span><br><span class=\"line\">docker network create --driver overlay my-overlay-net</span><br><span class=\"line\"><span class=\"comment\"># 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建服务并加入该网络</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name web-service \\</span><br><span class=\"line\">  --network my-overlay-net \\</span><br><span class=\"line\">  --replicas 5 \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\">  <span class=\"comment\"># --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class=\"line\">6b7aadbbd180   bridge            bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">5ddadf5d0608   docker_gwbridge   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">21c6f5b1bedd   host              host      <span class=\"built_in\">local</span></span><br><span class=\"line\">idx465x3jg68   ingress           overlay   swarm</span><br><span class=\"line\">a770c5ad4b13   none              null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。</li>\n<li class=\"lvl-2\">但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。</li>\n<li class=\"lvl-2\">默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。</li>\n<li class=\"lvl-2\">另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发\n<ul class=\"lvl-3\">\n<li class=\"lvl-4\">当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。</li>\n<li class=\"lvl-4\">节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"docker-service-ls-列出所有服务\"><code>docker service ls</code>: 列出所有服务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID             NAME       MODE         REPLICAS   IMAGE          PORTS</span><br><span class=\"line\">dmnztimv3pb8   my-nginx   replicated   2/2        nginx:latest   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-inspect-查看服务详情\"><code>docker service inspect</code>: 查看服务详情</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service inspect my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-log-查看服务日志\"><code>docker service log</code>: 查看服务日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定服务下所有任务的日志</span></span><br><span class=\"line\">docker service logs my-nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看指定任务的日志，指定任务ID，不支持任务名称</span></span><br><span class=\"line\">docker service logs p4tats0f9npk</span><br><span class=\"line\"><span class=\"comment\"># 滚动查看日志</span></span><br><span class=\"line\">docker service logs -f my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-ps-列出服务任务\"><code>docker service ps</code>: 列出服务任务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 13 minutes ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 15 minutes ago</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-scale-扩容-缩容服务\"><code>docker service scale</code>: 扩容/缩容服务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个服务</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  --publish 80:80 \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 14 seconds ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 2 minutes ago</span><br><span class=\"line\">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running 4 seconds ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 扩容到5个任务</span></span><br><span class=\"line\">docker service scale my-nginx=5</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running about a minute ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 3 minutes ago</span><br><span class=\"line\">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">ksbeflwg3mcj   my-nginx.4   nginx:latest   worker1    Running         Running less than a second ago</span><br><span class=\"line\">iw4zlm56n1x8   my-nginx.5   nginx:latest   manager3   Running         Running less than a second ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 缩容到2个人任务</span></span><br><span class=\"line\">docker service scale my-nginx=2</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE           ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 2 minutes ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 4 minutes ago</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 还可以使用如下命令进行扩缩容</span></span><br><span class=\"line\">docker service update --replicas=5 my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-update-更新服务\"><code>docker service update</code>: 更新服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>支持的参数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--image</code></td>\n<td>更新服务使用的镜像</td>\n<td><code>--image nginx:1.25</code></td>\n</tr>\n<tr>\n<td><code>--replicas</code></td>\n<td>设置服务的副本数量（仅适用于 replicated 模式）</td>\n<td><code>--replicas 5</code></td>\n</tr>\n<tr>\n<td><code>--env-add</code></td>\n<td>添加环境变量</td>\n<td><code>--env-add DEBUG=true</code></td>\n</tr>\n<tr>\n<td><code>--env-rm</code></td>\n<td>移除环境变量</td>\n<td><code>--env-rm OLD_VAR</code></td>\n</tr>\n<tr>\n<td><code>--publish-add</code></td>\n<td>添加端口映射</td>\n<td><code>--publish-add published=8080,target=80</code></td>\n</tr>\n<tr>\n<td><code>--publish-rm</code></td>\n<td>移除端口映射</td>\n<td><code>--publish-rm 80</code></td>\n</tr>\n<tr>\n<td><code>--mount-add</code></td>\n<td>添加挂载</td>\n<td><code>--mount-add type=bind,src=/data,dst=/data</code></td>\n</tr>\n<tr>\n<td><code>--mount-rm</code></td>\n<td>移除挂载</td>\n<td><code>--mount-rm /data</code></td>\n</tr>\n<tr>\n<td><code>--constraint-add</code></td>\n<td>添加部署约束</td>\n<td><code>--constraint-add 'node.labels.zone==east'</code></td>\n</tr>\n<tr>\n<td><code>--constraint-rm</code></td>\n<td>移除部署约束</td>\n<td><code>--constraint-rm 'node.labels.zone==east'</code></td>\n</tr>\n<tr>\n<td><code>--limit-cpu</code></td>\n<td>设置 CPU 限制</td>\n<td><code>--limit-cpu 0.5</code></td>\n</tr>\n<tr>\n<td><code>--limit-memory</code></td>\n<td>设置内存限制</td>\n<td><code>--limit-memory 256M</code></td>\n</tr>\n<tr>\n<td><code>--restart-condition</code></td>\n<td>设置重启策略（none、on-failure、any）</td>\n<td><code>--restart-condition on-failure</code></td>\n</tr>\n<tr>\n<td><code>--update-delay</code></td>\n<td>设置任务更新之间的延迟</td>\n<td><code>--update-delay 10s</code></td>\n</tr>\n<tr>\n<td><code>--update-parallelism</code></td>\n<td>设置并发更新任务的数量</td>\n<td><code>--update-parallelism 2</code></td>\n</tr>\n<tr>\n<td><code>--update-order</code></td>\n<td>设置更新顺序（start-first 或 stop-first）</td>\n<td><code>--update-order start-first</code></td>\n</tr>\n<tr>\n<td><code>--update-failure-action</code></td>\n<td>更新失败后的动作（pause、continue、rollback）</td>\n<td><code>--update-failure-action rollback</code></td>\n</tr>\n<tr>\n<td><code>--rollback</code></td>\n<td>回滚到上一次成功配置</td>\n<td><code>--rollback</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service update \\</span><br><span class=\"line\">  --image nginx:1.25 \\</span><br><span class=\"line\">  --replicas 4 \\</span><br><span class=\"line\">  --env-add ENV=prod \\</span><br><span class=\"line\">  --limit-memory 512M \\</span><br><span class=\"line\">  --limit-cpu 1.0 \\</span><br><span class=\"line\">  --update-delay 10s \\</span><br><span class=\"line\">  --update-parallelism 2 \\</span><br><span class=\"line\">  --update-failure-action rollback \\</span><br><span class=\"line\">  my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-rollback-回滚服务\"><code>docker service rollback</code>: 回滚服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker service rollback &lt;service_name&gt;</span></span><br><span class=\"line\">docker service rollback my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-rm-删除服务\"><code>docker service rm</code>: 删除服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除服务会停止服务并删除服务。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker service rm &lt;service_name&gt;</span></span><br><span class=\"line\">docker service <span class=\"built_in\">rm</span> my-nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"经验技巧\">经验技巧</h2>\n<h3 id=\"如何让任务运行在指定的节点上？\">如何让任务运行在指定的节点上？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建服务时，可以使用 <code>--constraint</code> 参数指定节点的标签，使其运行在具有指定标签的节点上。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给结点加标签</span></span><br><span class=\"line\">docker node update --label-add <span class=\"built_in\">env</span>=prod worker1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=prod</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">--name my-nginx \\</span><br><span class=\"line\">--replicas 2 \\</span><br><span class=\"line\">--constraint <span class=\"string\">&#x27;node.labels.env == prod&#x27;</span> \\</span><br><span class=\"line\">nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只能运行在管理节点上</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name manager-only-service \\</span><br><span class=\"line\">  --constraint <span class=\"string\">&#x27;node.role == manager&#x27;</span> \\</span><br><span class=\"line\">  nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 内置属性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>示例值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>node.id</code></td>\n<td><code>node.id == abcd1234</code></td>\n<td>节点的唯一 ID（可用 <code>docker node ls</code> 查看）</td>\n</tr>\n<tr>\n<td><code>node.hostname</code></td>\n<td><code>node.hostname == manager-1</code></td>\n<td>节点主机名</td>\n</tr>\n<tr>\n<td><code>node.role</code></td>\n<td><code>node.role == manager</code> 或 <code>node.role == worker</code></td>\n<td>节点在 Swarm 中的角色（管理/工作）</td>\n</tr>\n<tr>\n<td><code>engine.labels.*</code></td>\n<td><code>engine.labels.disk == ssd</code></td>\n<td>Docker 引擎级别的标签（需手动设置）</td>\n</tr>\n<tr>\n<td><code>node.platform.os</code></td>\n<td><code>node.platform.os == linux</code></td>\n<td>节点操作系统类型</td>\n</tr>\n<tr>\n<td><code>node.platform.arch</code></td>\n<td><code>node.platform.arch == x86_64</code></td>\n<td>节点架构类型（如 <code>arm64</code>, <code>x86_64</code>）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何访问Service服务？\">如何访问Service服务？</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostname</span></span><br><span class=\"line\">docker service create --name <span class=\"built_in\">whoami</span> \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  -p 80:80 \\</span><br><span class=\"line\">  traefik/whoami</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看service服务运行在哪些节点上，看到这里只有 manager1\\manager2\\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器ID</span></span><br><span class=\"line\">docker service ps <span class=\"built_in\">whoami</span></span><br><span class=\"line\">ID             NAME       IMAGE                   NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">u1elzp22hyvm   whoami.1   traefik/whoami:latest   manager2   Running         Running 2 minutes ago</span><br><span class=\"line\">4cent1kfgghb   whoami.2   traefik/whoami:latest   worker2    Running         Running 17 seconds ago</span><br><span class=\"line\">lu6u6j8ji0uq   whoami.3   traefik/whoami:latest   manager1   Running         Running 40 seconds ago</span><br><span class=\"line\"><span class=\"comment\"># 如果希望查询某个Service的所有容器的ID，可以执行如下命令</span></span><br><span class=\"line\">docker service ps <span class=\"built_in\">whoami</span> -q | xargs docker inspect --format <span class=\"string\">&#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27;</span> | <span class=\"built_in\">cut</span> -c 1-12</span><br><span class=\"line\">a3fb63bde8e7</span><br><span class=\"line\">a14e30a02987</span><br><span class=\"line\">549610f3a1e9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 <code>curl 10.211.55.12</code>，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># docker_service_container</span></span><br><span class=\"line\"><span class=\"comment\"># 用法提示</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -z <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: <span class=\"variable\">$0</span> &lt;SERVICE_NAME&gt;&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">SERVCIE_NAME=<span class=\"variable\">$1</span></span><br><span class=\"line\"></span><br><span class=\"line\">d1=$(<span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot;</span> | awk <span class=\"string\">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span> ;\\</span><br><span class=\"line\">docker service ps <span class=\"variable\">$SERVCIE_NAME</span> -q | xargs docker inspect --format <span class=\"string\">&#x27;&#123;&#123;.ServiceID&#125;&#125;    &#123;&#123;.ID&#125;&#125;    &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;    &#123;&#123;.NodeID&#125;&#125;&#x27;</span> \\</span><br><span class=\"line\">| awk <span class=\"string\">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#echo &quot;$d1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">d2=$(docker service ps <span class=\"variable\">$SERVCIE_NAME</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#echo &quot;$d2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">NR==FNR &amp;&amp; FNR &gt; 1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">  id = $1</span></span><br><span class=\"line\"><span class=\"string\">  name = $2</span></span><br><span class=\"line\"><span class=\"string\">  node = $4</span></span><br><span class=\"line\"><span class=\"string\">  desired = $5</span></span><br><span class=\"line\"><span class=\"string\">  # 拼接 CURRENT STATE（从第6列开始的所有字段）</span></span><br><span class=\"line\"><span class=\"string\">  current = &quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">  for (i=6; i&lt;=NF; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    current = current $i &quot; &quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  current = substr(current, 1, length(current)-1)  # 去掉最后空格</span></span><br><span class=\"line\"><span class=\"string\">  info[id] = name &quot;\\t&quot; node &quot;\\t&quot; desired &quot;\\t&quot; current</span></span><br><span class=\"line\"><span class=\"string\">  next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">FNR==1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">  print $0 &quot;\\tTASK-NAME\\tNODE\\tDESIRED_STATE\\tCURRENT_STATE&quot;</span></span><br><span class=\"line\"><span class=\"string\">  next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  print $0 &quot;\\t&quot; info[$2]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span> &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$d2</span>&quot;</span>) &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$d1</span>&quot;</span>) | <span class=\"built_in\">tail</span> -n +2 | column -t</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-swarm-service</span><br><span class=\"line\"><span class=\"comment\"># 执行脚本</span></span><br><span class=\"line\">docker-swarm-service <span class=\"built_in\">whoami</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">SERVICE-ID    TASK-ID       CONTAINER-ID  NODE-ID       TASK-NAME  NODE      DESIRED_STATE  CURRENT_STATE</span><br><span class=\"line\">q5cs78qnynfv  u1elzp22hyvm  a3fb63bde8e7  oymi74epagdq  whoami.1   manager2  Running        Running        2  hours  ago</span><br><span class=\"line\">q5cs78qnynfv  4cent1kfgghb  a14e30a02987  hvzkh3ip5ef8  whoami.2   worker2   Running        Running        2  hours  ago</span><br><span class=\"line\">q5cs78qnynfv  lu6u6j8ji0uq  549610f3a1e9  kp2zerd28xgz  whoami.3   manager1  Running        Running        2  hours  ago</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker Swarm 的 服务管理 Docker官方文档 Docker Swarm 官方文档 Service 与 Task 什么是 Service？ Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。 它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。 可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。 什么是 Task？ Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。 Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。 Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。 当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。 Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。 示例 创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。 1docker service create --name nginx --replicas 3 nginx:latest 这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。 项目 Service Task 定义 用户定义的服务配置 服务配置生成的执行单元 数量关系 一个 Service 包含多个 Task 一个 Task 属于一个 Service 状态 描述“期望状态” 代表“实际状态” 生命周期 可以更新 不可变，更新意味着重新创建 管理者 由用户管理 完全由 Swarm 调度和管理 Service 相关命令 命令 中文说明 create 创建一个新的服务 inspect 显示一个或多个服务的详细信息 logs 获取服务或任务的日志 ls 列出所有服务 ps 列出一个或多个服务的任务（Task） rm 删除一个或多个服务 rollback 回滚服务的配置更改 scale 扩缩一个或多个可复制服务的副本数量 update 更新服务配置 docker service create: 创建服务 常用参数说明 参数 说明 示例命令（含说明） --name 指定服务名称 docker service create --name my-web nginx→ 创建一个名为 my-web 的 nginx 服务 --replicas 设置副本数量（仅适用于 replicated 模式） docker service create --replicas 3 nginx→ 启动 3 个 nginx 副本 --publish 或 -p 映射端口（格式如 80:80） docker service create -p 8080:80 nginx→ 将容器的 80 端口映射到主机 8080 --env 或 -e 设置环境变量 docker service create -e ENV=prod nginx→ 设置环境变量 ENV=prod --mount 设置数据卷挂载 docker service create --mount type=bind,src=/data,target=/app nginx→ 将主机的 /data 目录挂载到容器内 /app --constraint 设置部署约束（如指定节点） docker service create --constraint 'node.labels.type == web' nginx→ 仅部署在带标签 type=web 的节点上 --network 指定服务所属的网络（通常使用 overlay 网络） docker service create --network my-net nginx→ 将服务连接到自定义网络 my-net --detach 或 -d 后台运行服务（默认行为） docker service create -d nginx→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行 --limit-cpu / --limit-memory 设置资源限制 docker service create --limit-cpu 0.5 --limit-memory 256M nginx→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存 --restart-condition 设置重启策略（如 on-failure、any、none） docker service create --restart-condition on-failure nginx→ 仅当容器失败时自动重启 --mode 指定服务运行模式，支持：replicated、global、replicated-job、global-job docker service create --mode global nginx→ 在集群每个节点上运行一个 nginx 实例 服务运行模式（–mode）详解 模式名称 说明 使用场景示例 replicated 默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。 典型的 Web 服务，如 nginx、Node.js、Java 应用等 global 每个可用节点只部署一个任务实例，不需要用户指定副本数。 系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter） replicated-job 在多个节点上按副本数运行一次性任务，任务完成后即退出。 数据处理、批处理任务，如转换文件或跑 ETL global-job 在所有节点上各运行一次的短暂任务，执行完毕即退出。 初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等 job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。 replicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。 服务重启策略（–restart-condition）详解 值 含义说明 none 不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。 on-failure 仅在任务异常失败时（exit code 非 0）自动重启。常用于可能偶发失败的服务。 any（默认） 无论任务如何退出（包括正常退出或失败），都会尝试重启。适用于持续运行服务。 情景总结 情景 none on-failure any 服务运行时崩溃（exit code ≠ 0） ❌ 不重启 ✅ 自动重启 ✅ 自动重启 服务正常结束（exit code = 0） ❌ 不重启 ❌ 不重启 ✅ 自动重启 持续运行型服务（如 nginx） ❌ 不推荐 可用 ✅ 推荐 一次性任务（如批处理、数据初始化） ✅ 推荐 可用 ❌ 不推荐 docker service create 使用示例 创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像 123456# 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能docker service create \\ --name my-nginx \\ --replicas 3 \\ --publish 80:80 \\ nginx 创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器 12# globaldocker service create --name log-agent --mode global fluentd 创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js 123456docker service create \\ --name web-app \\ --env NODE_ENV=production \\ --mount type=bind,src=/data,target=/app/data \\ --replicas 2 \\ node:18 node server.js 创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据 12345678# 创建数据卷docker volume create db-data# 创建服务docker service create \\ --name db \\ --constraint &#x27;node.labels.role == db&#x27; \\ --mount type=volume,source=db-data,target=/var/lib/mysql \\ mysql:8 使用 on-failure 策略，仅在失败时自动重启 1234docker service create \\ --name unstable-worker \\ --restart-condition on-failure \\ my-worker-image 指定网络，网络驱动类型为 overlay 1234567891011# 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）docker network create --driver overlay my-overlay-net# 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点# 创建服务并加入该网络docker service create \\ --name web-service \\ --network my-overlay-net \\ --replicas 5 \\ nginx # --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。 小贴士 1234567docker network lsNETWORK ID NAME DRIVER SCOPE6b7aadbbd180 bridge bridge local5ddadf5d0608 docker_gwbridge bridge local21c6f5b1bedd host host localidx465x3jg68 ingress overlay swarma770c5ad4b13 none null local 初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。 但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。 默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。 另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发 当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。 节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。 docker service ls: 列出所有服务 123docker service lsID NAME MODE REPLICAS IMAGE PORTSdmnztimv3pb8 my-nginx replicated 2/2 nginx:latest *:80-&gt;80/tcp docker service inspect: 查看服务详情 1docker service inspect my-nginx docker service log: 查看服务日志 123456# 查看指定服务下所有任务的日志docker service logs my-nginx# 查看指定任务的日志，指定任务ID，不支持任务名称docker service logs p4tats0f9npk# 滚动查看日志docker service logs -f my-nginx docker service ps: 列出服务任务 1234docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 13 minutes agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 15 minutes ago docker service scale: 扩容/缩容服务 12345678910111213141516171819202122232425262728293031323334353637# 启动一个服务docker service create \\ --name my-nginx \\ --replicas 3 \\ --publish 80:80 \\ nginx# 查看服务任务docker service ps my-nginx## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 14 seconds agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 2 minutes agow0sm5ixvi6eb my-nginx.3 nginx:latest worker2 Running Running 4 seconds ago# 扩容到5个任务docker service scale my-nginx=5# 查看服务任务docker service ps my-nginx## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running about a minute agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 3 minutes agow0sm5ixvi6eb my-nginx.3 nginx:latest worker2 Running Running about a minute agoksbeflwg3mcj my-nginx.4 nginx:latest worker1 Running Running less than a second agoiw4zlm56n1x8 my-nginx.5 nginx:latest manager3 Running Running less than a second ago# 缩容到2个人任务docker service scale my-nginx=2# 查看服务任务docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 2 minutes agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 4 minutes ago# 还可以使用如下命令进行扩缩容docker service update --replicas=5 my-nginx docker service update: 更新服务 支持的参数 参数 说明 示例 --image 更新服务使用的镜像 --image nginx:1.25 --replicas 设置服务的副本数量（仅适用于 replicated 模式） --replicas 5 --env-add 添加环境变量 --env-add DEBUG=true --env-rm 移除环境变量 --env-rm OLD_VAR --publish-add 添加端口映射 --publish-add published=8080,target=80 --publish-rm 移除端口映射 --publish-rm 80 --mount-add 添加挂载 --mount-add type=bind,src=/data,dst=/data --mount-rm 移除挂载 --mount-rm /data --constraint-add 添加部署约束 --constraint-add 'node.labels.zone==east' --constraint-rm 移除部署约束 --constraint-rm 'node.labels.zone==east' --limit-cpu 设置 CPU 限制 --limit-cpu 0.5 --limit-memory 设置内存限制 --limit-memory 256M --restart-condition 设置重启策略（none、on-failure、any） --restart-condition on-failure --update-delay 设置任务更新之间的延迟 --update-delay 10s --update-parallelism 设置并发更新任务的数量 --update-parallelism 2 --update-order 设置更新顺序（start-first 或 stop-first） --update-order start-first --update-failure-action 更新失败后的动作（pause、continue、rollback） --update-failure-action rollback --rollback 回滚到上一次成功配置 --rollback 示例 12345678910docker service update \\ --image nginx:1.25 \\ --replicas 4 \\ --env-add ENV=prod \\ --limit-memory 512M \\ --limit-cpu 1.0 \\ --update-delay 10s \\ --update-parallelism 2 \\ --update-failure-action rollback \\ my-nginx docker service rollback: 回滚服务 会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。 12# docker service rollback &lt;service_name&gt;docker service rollback my-nginx docker service rm: 删除服务 删除服务会停止服务并删除服务。 12# docker service rm &lt;service_name&gt;docker service rm my-nginx 经验技巧 如何让任务运行在指定的节点上？ 创建服务时，可以使用 --constraint 参数指定节点的标签，使其运行在具有指定标签的节点上。 1234567891011# 给结点加标签docker node update --label-add env=prod worker1# node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=proddocker service create \\--name my-nginx \\--replicas 2 \\--constraint &#x27;node.labels.env == prod&#x27; \\nginx:latest# 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。 只能运行在管理节点上 12345# node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。docker service create \\ --name manager-only-service \\ --constraint &#x27;node.role == manager&#x27; \\ nginx Swarm 内置属性 属性名 示例值 说明 node.id node.id == abcd1234 节点的唯一 ID（可用 docker node ls 查看） node.hostname node.hostname == manager-1 节点主机名 node.role node.role == manager 或 node.role == worker 节点在 Swarm 中的角色（管理/工作） engine.labels.* engine.labels.disk == ssd Docker 引擎级别的标签（需手动设置） node.platform.os node.platform.os == linux 节点操作系统类型 node.platform.arch node.platform.arch == x86_64 节点架构类型（如 arm64, x86_64） 如何访问Service服务？ 1234567891011121314151617# 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostnamedocker service create --name whoami \\ --replicas 3 \\ -p 80:80 \\ traefik/whoami# 查看service服务运行在哪些节点上，看到这里只有 manager1\\manager2\\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器IDdocker service ps whoamiID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSu1elzp22hyvm whoami.1 traefik/whoami:latest manager2 Running Running 2 minutes ago4cent1kfgghb whoami.2 traefik/whoami:latest worker2 Running Running 17 seconds agolu6u6j8ji0uq whoami.3 traefik/whoami:latest manager1 Running Running 40 seconds ago# 如果希望查询某个Service的所有容器的ID，可以执行如下命令docker service ps whoami -q | xargs docker inspect --format &#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27; | cut -c 1-12a3fb63bde8e7a14e30a02987549610f3a1e9 此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 curl 10.211.55.12，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。 在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。 可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# docker_service_container# 用法提示if [ -z &quot;$1&quot; ]; then echo &quot;用法: $0 &lt;SERVICE_NAME&gt;&quot; exit 1fiSERVCIE_NAME=$1d1=$(echo -e &quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot; | awk &#x27;&#123;printf &quot;%-12s %-12s %-12s %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27; ;\\docker service ps $SERVCIE_NAME -q | xargs docker inspect --format &#x27;&#123;&#123;.ServiceID&#125;&#125; &#123;&#123;.ID&#125;&#125; &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125; &#123;&#123;.NodeID&#125;&#125;&#x27; \\| awk &#x27;&#123;printf &quot;%-12s %-12s %-12s %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;)#echo &quot;$d1&quot;d2=$(docker service ps $SERVCIE_NAME)#echo &quot;$d2&quot;awk &#x27;NR==FNR &amp;&amp; FNR &gt; 1 &#123; id = $1 name = $2 node = $4 desired = $5 # 拼接 CURRENT STATE（从第6列开始的所有字段） current = &quot;&quot; for (i=6; i&lt;=NF; i++) &#123; current = current $i &quot; &quot; &#125; current = substr(current, 1, length(current)-1) # 去掉最后空格 info[id] = name &quot;\\t&quot; node &quot;\\t&quot; desired &quot;\\t&quot; current next&#125;FNR==1 &#123; print $0 &quot;\\tTASK-NAME\\tNODE\\tDESIRED_STATE\\tCURRENT_STATE&quot; next&#125;&#123; print $0 &quot;\\t&quot; info[$2]&#125;&#x27; &lt;(echo &quot;$d2&quot;) &lt;(echo &quot;$d1&quot;) | tail -n +2 | column -t 12345678chmod +x /usr/local/bin/docker-swarm-service# 执行脚本docker-swarm-service whoami## 输出SERVICE-ID TASK-ID CONTAINER-ID NODE-ID TASK-NAME NODE DESIRED_STATE CURRENT_STATEq5cs78qnynfv u1elzp22hyvm a3fb63bde8e7 oymi74epagdq whoami.1 manager2 Running Running 2 hours agoq5cs78qnynfv 4cent1kfgghb a14e30a02987 hvzkh3ip5ef8 whoami.2 worker2 Running Running 2 hours agoq5cs78qnynfv lu6u6j8ji0uq 549610f3a1e9 kp2zerd28xgz whoami.3 manager1 Running Running 2 hours ago","summary":"摘要 本文介绍 Docker Swarm 的 服务管理 Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-10T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/","url":"https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/","title":"Docker Swarm 之 节点(Node)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 节点管理</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Docker-Swarm-简介\">Docker Swarm 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。</p>\n</li>\n<li class=\"lvl-2\">\n<p>从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/KwTed9.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性/功能</th>\n<th>管理节点（Manager Node）</th>\n<th>工作节点（Worker Node）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>角色</td>\n<td>负责集群管理和决策</td>\n<td>执行分配的服务任务</td>\n</tr>\n<tr>\n<td>是否参与服务运行</td>\n<td>可以运行服务任务，也可以只做管理（可配置）</td>\n<td>仅运行服务任务，不参与管理决策</td>\n</tr>\n<tr>\n<td>集群状态维护</td>\n<td>维护整个 Swarm 的状态（使用 Raft 协议）</td>\n<td>不维护集群状态</td>\n</tr>\n<tr>\n<td>调度任务</td>\n<td>决定将服务任务分配给哪个节点</td>\n<td>不负责调度，只执行接收到的任务</td>\n</tr>\n<tr>\n<td>管理命令处理</td>\n<td>接收并处理 Swarm 管理命令（如创建服务、扩缩容等）</td>\n<td>不处理管理命令</td>\n</tr>\n<tr>\n<td>数据一致性</td>\n<td>需要保持一致性（至少 3 个管理节点形成高可用）</td>\n<td>不涉及一致性</td>\n</tr>\n<tr>\n<td>资源要求</td>\n<td>相对较高，需要承担管理和协调开销</td>\n<td>相对较低，专注于运行容器</td>\n</tr>\n<tr>\n<td>可用性要求</td>\n<td>通常配置奇数个（3、5、7…）以保障高可用</td>\n<td>可根据需要自由扩展或缩减</td>\n</tr>\n<tr>\n<td>节点加入方式</td>\n<td>通过 manager token 加入 Swarm</td>\n<td>通过 worker token 加入 Swarm</td>\n</tr>\n<tr>\n<td>故障影响</td>\n<td>多个管理节点故障可能影响整个 Swarm 的控制能力</td>\n<td>部分工作节点故障通常不会影响 Swarm 的管理能力</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。</p>\n</li>\n</ul>\n<h2 id=\"搭建Swarm集群\">搭建Swarm集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。</p>\n</li>\n<li class=\"lvl-2\">\n<p>其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>IP 地址</th>\n<th>HostName</th>\n<th>角色类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10.211.55.10</td>\n<td>manager1</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.11</td>\n<td>manager2</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.12</td>\n<td>manager3</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.13</td>\n<td>worker1</td>\n<td>工作节点</td>\n</tr>\n<tr>\n<td>10.211.55.14</td>\n<td>worker2</td>\n<td>工作节点</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口号</th>\n<th>协议</th>\n<th>用途说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2377</td>\n<td>TCP</td>\n<td>管理器节点之间通信（管理指令和加入集群）</td>\n</tr>\n<tr>\n<td>7946</td>\n<td>TCP/UDP</td>\n<td>节点发现和通信（集群内部发现机制）</td>\n</tr>\n<tr>\n<td>4789</td>\n<td>UDP</td>\n<td>覆盖网络流量（VXLAN，用于容器间网络）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开放 Swarm 管理节点通信端口</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=2377/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 节点发现（cluster communication）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=7946/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=7946/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overlay 网络流量（容器间通信）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用更改</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看防火墙状态</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>所有主机必须时间一致</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同步系统时间</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart chronyd</span><br><span class=\"line\">chronyc tracking</span><br><span class=\"line\"><span class=\"comment\"># 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）</span></span><br><span class=\"line\"><span class=\"comment\"># 设置时区为中国上海时间（CST）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\"><span class=\"comment\"># 查看时间和时区</span></span><br><span class=\"line\">timedatectl</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集群\">创建集群</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 manager1 节点上执行如下命令来创建一个新的swarm集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前docker的swarm模式是否开启</span></span><br><span class=\"line\">docker info | grep <span class=\"string\">&quot;Swarm&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出， inactive 表示没有开启swarm集群</span></span><br><span class=\"line\"> Swarm: inactive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群初始化</span></span><br><span class=\"line\"><span class=\"comment\"># docker swarm init --advertise-addr &lt;MANAGER-IP&gt;</span></span><br><span class=\"line\">docker swarm init --advertise-addr 10.211.55.10</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377</span></span><br><span class=\"line\"><span class=\"comment\"># 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leader</span></span><br><span class=\"line\">Swarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.</span><br><span class=\"line\"><span class=\"comment\"># 将一个worker node加入集群请运行下面的命令</span></span><br><span class=\"line\">To add a worker to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取</span></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\"># 添加一个manager node需要执行下面的命令获取 manager token</span></span><br><span class=\"line\">To add a manager to this swarm, run <span class=\"string\">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看当前docker的swarm模式是否开启</span></span><br><span class=\"line\">docker info | grep Swarm</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"> Swarm: active</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点</span></span><br><span class=\"line\">docker info --format <span class=\"string\">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class=\"string\">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">LocalNodeState: active         <span class=\"comment\"># 节点状态</span></span><br><span class=\"line\">NodeID: kp2zerd28xgz5mmglnje0jp22 <span class=\"comment\"># 节点ID</span></span><br><span class=\"line\">NodeAddr: 10.211.55.10           <span class=\"comment\"># 节点IP</span></span><br><span class=\"line\">RemoteManagers: [                <span class=\"comment\"># 节点管理节点信息</span></span><br><span class=\"line\">  - NodeID: kp2zerd28xgz5mmglnje0jp22 <span class=\"comment\"># 节点管理节点ID</span></span><br><span class=\"line\">    Addr: 10.211.55.10:2377       <span class=\"comment\"># 节点管理节点地址</span></span><br><span class=\"line\">Nodes: 1                          <span class=\"comment\"># 节点数量</span></span><br><span class=\"line\">Managers: 1                       <span class=\"comment\"># 管理节点数量</span></span><br><span class=\"line\">ControlAvailable: <span class=\"literal\">true</span>            <span class=\"comment\"># 是否有控制节点</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>安装 yq 工具</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">yq 是 yaml 的命令行处理工具，具体参考<a href=\"https://github.com/mikefarah/yq\">yq</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 yq 最新版本</span></span><br><span class=\"line\">VERSION=v4.45.4</span><br><span class=\"line\">ARCH=amd64</span><br><span class=\"line\">wget https://github.com/mikefarah/yq/releases/download/<span class=\"variable\">$&#123;VERSION&#125;</span>/yq_linux_<span class=\"variable\">$&#123;ARCH&#125;</span> -O /usr/local/bin/yq</span><br><span class=\"line\"><span class=\"comment\"># 添加执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x /usr/local/bin/yq</span><br><span class=\"line\"><span class=\"comment\"># 验证安装</span></span><br><span class=\"line\">yq --version</span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"添加-manager-节点\">添加 manager 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 manager 节点的 token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行</span></span><br><span class=\"line\">docker swarm join-token manager</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">To add a manager to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 manager2 和 manager3 加入 swarm 集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 manager2 和 manager3 上运行如下命令，</span></span><br><span class=\"line\">docker swarm <span class=\"built_in\">join</span> \\</span><br><span class=\"line\">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \\</span><br><span class=\"line\">10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加-worker-节点\">添加 worker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 worker 节点的 token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行</span></span><br><span class=\"line\">docker swarm join-token worker</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">To add a worker to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 worker1 和 worker2 加入 swarm 集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 worker1 和 worker2 上运行如下命令，</span></span><br><span class=\"line\">docker swarm <span class=\"built_in\">join</span> \\</span><br><span class=\"line\">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \\</span><br><span class=\"line\">10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看集群状态\">查看集群状态</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 manager1 上执行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info --format <span class=\"string\">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class=\"string\">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class=\"line\"><span class=\"comment\">## 结果</span></span><br><span class=\"line\">LocalNodeState: active</span><br><span class=\"line\">NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class=\"line\">NodeAddr: 10.211.55.10</span><br><span class=\"line\">RemoteManagers:</span><br><span class=\"line\">  - NodeID: oymi74epagdqeprah7s81tsa2</span><br><span class=\"line\">    Addr: 10.211.55.11:2377</span><br><span class=\"line\">  - NodeID: r7388xl84nczjtnf53pwh7hla</span><br><span class=\"line\">    Addr: 10.211.55.12:2377</span><br><span class=\"line\">  - NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class=\"line\">    Addr: 10.211.55.10:2377</span><br><span class=\"line\">Nodes: 5</span><br><span class=\"line\">Managers: 3</span><br><span class=\"line\">ControlAvailable: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看集群内节点信息\">查看集群内节点信息</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 任意 manager 节点上运行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">lsxj50x8ftqw8etvz5y37xc5q     worker2    Ready     Active                          26.1.3</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>示例值</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ID</strong></td>\n<td><code>kp2zerd28xgz5mmglnje0jp22</code></td>\n<td>节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符）</td>\n</tr>\n<tr>\n<td><strong>HOSTNAME</strong></td>\n<td><code>manager1</code></td>\n<td>节点的主机名（即加入 swarm 集群时该节点的 <code>hostname</code>）</td>\n</tr>\n<tr>\n<td><strong>STATUS</strong></td>\n<td><code>Ready</code></td>\n<td>节点的状态：<br>• <code>Ready</code>：节点正常运行中<br>• <code>Down</code>：节点离线或无法通信<br>• <code>Paused</code>：暂停<br>• <code>Drain</code>：排空，正在迁移任务</td>\n</tr>\n<tr>\n<td><strong>AVAILABILITY</strong></td>\n<td><code>Active</code></td>\n<td>节点的可用性设置：<br>• <code>Active</code>：节点可以调度任务（默认）<br>• <code>Pause</code>：暂停调度新任务<br>• <code>Drain</code>：迁移任务并不再调度</td>\n</tr>\n<tr>\n<td><strong>MANAGER STATUS</strong></td>\n<td><code>Leader</code> / <code>Reachable</code> / 空</td>\n<td>仅适用于管理节点：<br>• <code>Leader</code>：当前 swarm 的主节点（负责协调）<br>• <code>Reachable</code>：集群中可通信的管理节点<br>• 空：表示这是一个工作节点（非管理节点）</td>\n</tr>\n<tr>\n<td><strong>ENGINE VERSION</strong></td>\n<td><code>26.1.3</code></td>\n<td>Docker 引擎的版本号（即该节点上运行的 Docker 版本）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-swarm集群管理\"><code>docker swarm</code>集群管理</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ca</code></td>\n<td>显示和轮换 Swarm 的根证书（CA）</td>\n</tr>\n<tr>\n<td><code>init</code></td>\n<td>初始化一个新的 Swarm 集群</td>\n</tr>\n<tr>\n<td><code>join</code></td>\n<td>将当前节点加入到 Swarm 中，作为工作节点或管理节点</td>\n</tr>\n<tr>\n<td><code>join-token</code></td>\n<td>管理用于加入 Swarm 的令牌（查看或重新生成）</td>\n</tr>\n<tr>\n<td><code>leave</code></td>\n<td>当前节点离开 Swarm 集群</td>\n</tr>\n<tr>\n<td><code>unlock</code></td>\n<td>解锁被加密的 Swarm（用于恢复 Manager 节点）</td>\n</tr>\n<tr>\n<td><code>unlock-key</code></td>\n<td>管理 Swarm 的解锁密钥（查看、备份等）</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>更新 Swarm 集群的全局配置（如加密、日志等）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm init</code>: 初始化 Swarm 集群（只在首次创建时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm init --advertise-addr 10.211.55.10</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm join-token</code>:  生成加入集群的令牌</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成 worker 节点的令牌</span></span><br><span class=\"line\">docker swarm join-token worker</span><br><span class=\"line\"><span class=\"comment\"># 生成 manager 节点的令牌</span></span><br><span class=\"line\">docker swarm join-token manager</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm join</code>: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm <span class=\"built_in\">join</span> --token &lt;token&gt; 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm leave</code>: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># worker 节点离开集群</span></span><br><span class=\"line\">docker swarm leave</span><br><span class=\"line\"><span class=\"comment\"># manager 节点必须先降级为 worker节点，或者加上 --force 强制离开</span></span><br><span class=\"line\">docker swarm leave --force</span><br><span class=\"line\"><span class=\"comment\"># 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点</span></span><br><span class=\"line\"><span class=\"comment\"># 集群中至少需要一个Manager节点，否则无法运行服务</span></span><br><span class=\"line\"><span class=\"comment\"># 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 down</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">lsxj50x8ftqw8etvz5y37xc5q     worker2    Down      Active                          26.1.3</span><br><span class=\"line\"><span class=\"comment\"># 如需彻底删除需要运行</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> worker2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm update</code>: 更新 Swarm 集群配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看</span></span><br><span class=\"line\">docker swarm update --autolock=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Swarm updated.</span><br><span class=\"line\">To unlock a swarm manager after it restarts, run the `docker swarm unlock`</span><br><span class=\"line\"><span class=\"built_in\">command</span> and provide the following key:</span><br><span class=\"line\"></span><br><span class=\"line\">    SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4</span><br><span class=\"line\"></span><br><span class=\"line\">Please remember to store this key <span class=\"keyword\">in</span> a password manager, since without it you</span><br><span class=\"line\">will not be able to restart the manager.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭Swarm集群锁定</span></span><br><span class=\"line\">docker swarm update --autolock=<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm unlock-key</code>: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取Swarm集群的解锁密钥</span></span><br><span class=\"line\">docker swarm unlock-key</span><br><span class=\"line\"><span class=\"comment\"># 轮换Swarm集群的解锁密钥</span></span><br><span class=\"line\">docker swarm unlock-key --rotate</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm unlock</code>: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class=\"string\">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class=\"line\"><span class=\"comment\"># 需要先解锁才可以运行节点管理命令</span></span><br><span class=\"line\">docker swarm unlock</span><br><span class=\"line\"><span class=\"comment\">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class=\"line\">Please enter unlock key:</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-node节点管理\"><code>docker node</code>节点管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点管理相关命令，只能在 管理节点 上执行</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>demote</code></td>\n<td>将一个或多个管理节点降级为工作节点</td>\n</tr>\n<tr>\n<td><code>inspect</code></td>\n<td>显示一个或多个节点的详细信息</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列出 swarm 集群中的所有节点</td>\n</tr>\n<tr>\n<td><code>promote</code></td>\n<td>将一个或多个工作节点提升为管理节点</td>\n</tr>\n<tr>\n<td><code>ps</code></td>\n<td>查看一个或多个节点上正在运行的任务（默认当前节点）</td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>从 swarm 集群中移除一个或多个节点</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>更新节点的元数据（如标签、可用性等）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node ls</code>: 列出 swarm 集群中的所有节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node inspect &lt;node_id&gt;/&lt;hostname&gt;</code>: 查看指定节点的详细信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node inspect --pretty manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;</code>: 更新节点的元数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置节点为不可用</span></span><br><span class=\"line\">docker node update --availability drain manager1</span><br><span class=\"line\"><span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">docker node update --label-add foo=bar manager1</span><br><span class=\"line\"><span class=\"comment\"># 删除标签</span></span><br><span class=\"line\">docker node update --label-rm foo manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node demote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将管理节点降级为工作节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node demote manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker note promote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将工作节点升级为管理节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node promote worker1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node rm &lt;node_id&gt;/&lt;hostname&gt;</code>: 从 swarm 集群中移除一个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">rm</span> manager1</span><br></pre></td></tr></table></figure>\n<h2 id=\"节点管理常见情况\">节点管理常见情况</h2>\n<h3 id=\"如何正确的删除一个节点\">如何正确的删除一个节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.如果是 manager 节点，先将 manager 节点降级为 worker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node demote manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.退出集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在要退出集群的节点上执行</span></span><br><span class=\"line\">docker swarm leave</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.删除节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">rm</span> manager1</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点被退群或删除后，其上运行的service会怎样？\">节点被退群或删除后，其上运行的service会怎样？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用一个示例来说明，先在 manager1 节点上创建一个 service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --publish 8080:80 \\</span><br><span class=\"line\">  --replicas 10 \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以看到每个节点上都启动了2个nginx容器</span></span><br><span class=\"line\">ID             NAME          IMAGE          NODE       DESIRED STATE   CURRENT STATE                ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4    nginx:latest   manager1   Running         Running about a minute ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class=\"line\">i6mieuodbrtg   my-nginx.6    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">2yohffzzsrrl   my-nginx.7    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class=\"line\">f3lusxoflqn2   my-nginx.8    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">xovzfmzsjlet   my-nginx.9    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10   nginx:latest   manager1   Running         Running about a minute ago</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这时将 worker2 从集群中退群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在worker2节点执行</span></span><br><span class=\"line\">docker swarm leave</span><br><span class=\"line\"><span class=\"comment\"># 在manager节点查看集群节点</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再次查看service状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\"># 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class=\"line\">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4       nginx:latest   manager1   Running         Running 6 minutes ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class=\"line\">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2   Running         Running 43 seconds ago</span><br><span class=\"line\">i6mieuodbrtg    \\_ my-nginx.6   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class=\"line\">2yohffzzsrrl   my-nginx.7       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class=\"line\">34km8mzg3xat   my-nginx.8       nginx:latest   manager3   Running         Running 43 seconds ago</span><br><span class=\"line\">f3lusxoflqn2    \\_ my-nginx.8   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class=\"line\">xovzfmzsjlet   my-nginx.9       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1   Running         Running 6 minutes ago</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果不退群直接删除节点呢？这次我们直接删除 worker1 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 worker1 节点</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> worker1</span><br><span class=\"line\"><span class=\"comment\"># 输出，提示 worker1 节点不是 down 状态，不能删除</span></span><br><span class=\"line\"><span class=\"comment\"># Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着我们强制删除</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> -f worker1</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 输出，可以看到worker1节点已经删除了</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看service状态</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME             IMAGE          NODE                        DESIRED STATE   CURRENT STATE                 ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4       nginx:latest   manager1                    Running         Running 12 minutes ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class=\"line\">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2                    Running         Running 6 minutes ago</span><br><span class=\"line\">i6mieuodbrtg    \\_ my-nginx.6   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class=\"line\">3t4qvpvrzpg3   my-nginx.7       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class=\"line\">2yohffzzsrrl    \\_ my-nginx.7   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class=\"line\">34km8mzg3xat   my-nginx.8       nginx:latest   manager3                    Running         Running 6 minutes ago</span><br><span class=\"line\">f3lusxoflqn2    \\_ my-nginx.8   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class=\"line\">4w5zfpfye3t8   my-nginx.9       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class=\"line\">xovzfmzsjlet    \\_ my-nginx.9   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1                    Running         Running 12 minutes ago</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点被退群或删除后是否可以重新加入集群\">节点被退群或删除后是否可以重新加入集群</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点被退群或删除后，可以通过 <code>docker swarm join</code> 命令重新加入集群</p>\n</li>\n<li class=\"lvl-2\">\n<p>若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 <code>docker swarm leave</code> 命令退群后再加入集群</p>\n</li>\n</ul>\n<h3 id=\"如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法\">如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里重启一个manager节点的docker服务</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class=\"string\">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class=\"line\"><span class=\"comment\"># 需要先解锁才可以运行节点管理命令</span></span><br><span class=\"line\">docker swarm unlock</span><br><span class=\"line\"><span class=\"comment\">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class=\"line\">Please enter unlock key:</span><br><span class=\"line\"><span class=\"comment\">## 如果忘记了密钥，可以在其它manager节点通过如下命令查看</span></span><br><span class=\"line\">docker swarm unlock-key</span><br><span class=\"line\"><span class=\"comment\"># 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Swarm-集群锁定功能的作用及使用场景\">Swarm 集群锁定功能的作用及使用场景</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>作用</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>✅ 作用</th>\n<th>📋 说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>加密保护管理密钥</td>\n<td>管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。</td>\n</tr>\n<tr>\n<td>防止节点被非法重启后加入集群</td>\n<td>如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景类型</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 适合场景</td>\n<td>对安全性要求高的生产环境</td>\n</tr>\n<tr>\n<td></td>\n<td>部署在不可信或共享物理环境中</td>\n</tr>\n<tr>\n<td></td>\n<td>云服务器、数据中心有专人运维管理解锁过程</td>\n</tr>\n<tr>\n<td></td>\n<td>希望防止物理/远程入侵者恢复管理器角色的公司</td>\n</tr>\n<tr>\n<td>❌ 不适合场景</td>\n<td>需要自动化部署或重启的 CI/CD 系统</td>\n</tr>\n<tr>\n<td></td>\n<td>测试环境或开发集群</td>\n</tr>\n<tr>\n<td></td>\n<td>无人值守、要求高可用自动恢复的部署系统</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>总结</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>是否推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>安全性</td>\n<td>✅ 强烈推荐启用（尤其在生产环境）</td>\n</tr>\n<tr>\n<td>自动化</td>\n<td>❌ 不推荐（增加人工干预步骤）</td>\n</tr>\n<tr>\n<td>解锁方式</td>\n<td>解锁命令 + unlock key</td>\n</tr>\n<tr>\n<td>unlock key 丢失后果</td>\n<td>可能需要重建 Swarm（除非提前备份）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-swarm-ca-是做什么用的？\"><code>docker swarm ca</code> 是做什么用的？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm ca</code> 命令是用来 <strong>管理 Swarm 集群中的根证书颁发机构（CA）</strong> 的工具。具体功能包括：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>子命令/参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker swarm ca</code></td>\n<td>查看当前 Swarm 的根 CA 公钥（PEM 格式）</td>\n</tr>\n<tr>\n<td><code>docker swarm ca --rotate</code></td>\n<td>轮换根 CA，用于安全更新</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 中的证书是干什么用的？</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 节点身份验证</td>\n<td>每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。</td>\n</tr>\n<tr>\n<td>🔐 通信加密</td>\n<td>节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。</td>\n</tr>\n<tr>\n<td>🔄 自动轮换</td>\n<td>Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/docker/swarm/certificates</span><br><span class=\"line\">tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── swarm-node.crt      <span class=\"comment\"># 节点证书</span></span><br><span class=\"line\">├── swarm-node.key      <span class=\"comment\"># 节点密钥</span></span><br><span class=\"line\">└── swarm-root-ca.crt   <span class=\"comment\"># 根CA证书</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"只让-Manager-做管理，不运行服务\">只让 Manager 做管理，不运行服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点的<code>AVAILABILITY</code>有三种：<code>active</code>、<code>pause</code>、<code>drain</code>。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>active</code></td>\n<td>可调度，Swarm 可以在此节点上运行服务任务（默认）</td>\n</tr>\n<tr>\n<td><code>pause</code></td>\n<td>暂停调度，不会分配新任务，但保留已有任务</td>\n</tr>\n<tr>\n<td><code>drain</code></td>\n<td>排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置 manager1 节点为“不可调度”，即 排空模式</span></span><br><span class=\"line\">docker node update --availability drain manager1</span><br><span class=\"line\"><span class=\"comment\"># 查看节点状态</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，manager1 节点状态变为 排空</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Drain          Reachable        26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">xkww4853bbdgv7bv8771xibob     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">hvzkh3ip5ef8gx973z1ywahbu     worker2    Ready     Active                          26.1.3</span><br><span class=\"line\"><span class=\"comment\"># 查看服务状态</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。</span></span><br><span class=\"line\">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class=\"line\">23m03nj54mzo   my-nginx.1       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class=\"line\">9xi83bnh4fus   my-nginx.2       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class=\"line\">wos8tbk449lk   my-nginx.3       nginx:latest   manager2   Running         Running 28 seconds ago</span><br><span class=\"line\">uosmuh6bvwm0    \\_ my-nginx.3   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class=\"line\">yeqhqc3f735y   my-nginx.4       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">g8rduix7s74v   my-nginx.5       nginx:latest   worker2    Running         Running less than a second ago</span><br><span class=\"line\">wuxilgpv9f50    \\_ my-nginx.5   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class=\"line\">3bxtn9boit28   my-nginx.6       nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class=\"line\">57kdggaf8sag   my-nginx.7       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">uugi506p74s8   my-nginx.8       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class=\"line\">yifwpqjnts9l   my-nginx.9       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class=\"line\">yv4p6su7aom5   my-nginx.10      nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复运行任务能力</span></span><br><span class=\"line\">docker node update --availability active manager1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止接收新的任务但保留运行中的任务</span></span><br><span class=\"line\">docker node update --availability pause manager1</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker Swarm 的 节点管理 Docker官方文档 Docker Swarm 官方文档 Docker Swarm 简介 Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。 从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。 Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。 Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。 以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比 特性/功能 管理节点（Manager Node） 工作节点（Worker Node） 角色 负责集群管理和决策 执行分配的服务任务 是否参与服务运行 可以运行服务任务，也可以只做管理（可配置） 仅运行服务任务，不参与管理决策 集群状态维护 维护整个 Swarm 的状态（使用 Raft 协议） 不维护集群状态 调度任务 决定将服务任务分配给哪个节点 不负责调度，只执行接收到的任务 管理命令处理 接收并处理 Swarm 管理命令（如创建服务、扩缩容等） 不处理管理命令 数据一致性 需要保持一致性（至少 3 个管理节点形成高可用） 不涉及一致性 资源要求 相对较高，需要承担管理和协调开销 相对较低，专注于运行容器 可用性要求 通常配置奇数个（3、5、7…）以保障高可用 可根据需要自由扩展或缩减 节点加入方式 通过 manager token 加入 Swarm 通过 worker token 加入 Swarm 故障影响 多个管理节点故障可能影响整个 Swarm 的控制能力 部分工作节点故障通常不会影响 Swarm 的管理能力 manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。 worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。 默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。 manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。 搭建Swarm集群 本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。 其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。 IP 地址 HostName 角色类型 10.211.55.10 manager1 管理节点 10.211.55.11 manager2 管理节点 10.211.55.12 manager3 管理节点 10.211.55.13 worker1 工作节点 10.211.55.14 worker2 工作节点 所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信： 端口号 协议 用途说明 2377 TCP 管理器节点之间通信（管理指令和加入集群） 7946 TCP/UDP 节点发现和通信（集群内部发现机制） 4789 UDP 覆盖网络流量（VXLAN，用于容器间网络） 123456789101112131415# 开放 Swarm 管理节点通信端口sudo firewall-cmd --permanent --add-port=2377/tcp# 节点发现（cluster communication）sudo firewall-cmd --permanent --add-port=7946/tcpsudo firewall-cmd --permanent --add-port=7946/udp# overlay 网络流量（容器间通信）sudo firewall-cmd --permanent --add-port=4789/udp# 应用更改sudo firewall-cmd --reload# 查看防火墙状态sudo firewall-cmd --list-all 所有主机必须时间一致 12345678# 同步系统时间sudo systemctl restart chronydchronyc tracking# 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）# 设置时区为中国上海时间（CST）sudo timedatectl set-timezone Asia/Shanghai# 查看时间和时区timedatectl 创建集群 在 manager1 节点上执行如下命令来创建一个新的swarm集群 1234567891011121314151617181920212223242526272829303132333435363738# 查看当前docker的swarm模式是否开启docker info | grep &quot;Swarm&quot;## 输出， inactive 表示没有开启swarm集群 Swarm: inactive# 集群初始化# docker swarm init --advertise-addr &lt;MANAGER-IP&gt;docker swarm init --advertise-addr 10.211.55.10## 参数说明# --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377# 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址## 输出# swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leaderSwarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.# 将一个worker node加入集群请运行下面的命令To add a worker to this swarm, run the following command: # 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取 docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377# 添加一个manager node需要执行下面的命令获取 manager tokenTo add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.# 再次查看当前docker的swarm模式是否开启docker info | grep Swarm## 输出 Swarm: active# 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点docker info --format &#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27; | jq &#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27; | yq -P## 输出LocalNodeState: active # 节点状态NodeID: kp2zerd28xgz5mmglnje0jp22 # 节点IDNodeAddr: 10.211.55.10 # 节点IPRemoteManagers: [ # 节点管理节点信息 - NodeID: kp2zerd28xgz5mmglnje0jp22 # 节点管理节点ID Addr: 10.211.55.10:2377 # 节点管理节点地址Nodes: 1 # 节点数量Managers: 1 # 管理节点数量ControlAvailable: true # 是否有控制节点 安装 yq 工具 yq 是 yaml 的命令行处理工具，具体参考yq 12345678# 下载 yq 最新版本VERSION=v4.45.4ARCH=amd64wget https://github.com/mikefarah/yq/releases/download/$&#123;VERSION&#125;/yq_linux_$&#123;ARCH&#125; -O /usr/local/bin/yq# 添加执行权限chmod +x /usr/local/bin/yq# 验证安装yq --version 添加 manager 节点 获取 manager 节点的 token 123456# 在 manager1 上运行docker swarm join-token manager## 输出结果To add a manager to this swarm, run the following command: docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377 将 manager2 和 manager3 加入 swarm 集群 1234567# 分别在 manager2 和 manager3 上运行如下命令，docker swarm join \\--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \\10.211.55.10:2377## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11## 运行结果This node joined a swarm as a manager. 添加 worker 节点 获取 worker 节点的 token 123456# 在 manager1 上运行docker swarm join-token worker## 输出结果To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377 将 worker1 和 worker2 加入 swarm 集群 1234567# 分别在 worker1 和 worker2 上运行如下命令，docker swarm join \\--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \\10.211.55.10:2377## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13## 运行结果This node joined a swarm as a worker. 查看集群状态 在 manager1 上执行如下命令 123456789101112131415docker info --format &#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27; | jq &#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27; | yq -P## 结果LocalNodeState: activeNodeID: kp2zerd28xgz5mmglnje0jp22NodeAddr: 10.211.55.10RemoteManagers: - NodeID: oymi74epagdqeprah7s81tsa2 Addr: 10.211.55.11:2377 - NodeID: r7388xl84nczjtnf53pwh7hla Addr: 10.211.55.12:2377 - NodeID: kp2zerd28xgz5mmglnje0jp22 Addr: 10.211.55.10:2377Nodes: 5Managers: 3ControlAvailable: true 查看集群内节点信息 在 任意 manager 节点上运行如下命令 123456789# 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令docker node ls## 运行结果ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3lsxj50x8ftqw8etvz5y37xc5q worker2 Ready Active 26.1.3 字段名 示例值 中文含义 ID kp2zerd28xgz5mmglnje0jp22 节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符） HOSTNAME manager1 节点的主机名（即加入 swarm 集群时该节点的 hostname） STATUS Ready 节点的状态：• Ready：节点正常运行中• Down：节点离线或无法通信• Paused：暂停• Drain：排空，正在迁移任务 AVAILABILITY Active 节点的可用性设置：• Active：节点可以调度任务（默认）• Pause：暂停调度新任务• Drain：迁移任务并不再调度 MANAGER STATUS Leader / Reachable / 空 仅适用于管理节点：• Leader：当前 swarm 的主节点（负责协调）• Reachable：集群中可通信的管理节点• 空：表示这是一个工作节点（非管理节点） ENGINE VERSION 26.1.3 Docker 引擎的版本号（即该节点上运行的 Docker 版本） docker swarm集群管理 命令 中文含义 ca 显示和轮换 Swarm 的根证书（CA） init 初始化一个新的 Swarm 集群 join 将当前节点加入到 Swarm 中，作为工作节点或管理节点 join-token 管理用于加入 Swarm 的令牌（查看或重新生成） leave 当前节点离开 Swarm 集群 unlock 解锁被加密的 Swarm（用于恢复 Manager 节点） unlock-key 管理 Swarm 的解锁密钥（查看、备份等） update 更新 Swarm 集群的全局配置（如加密、日志等） docker swarm init: 初始化 Swarm 集群（只在首次创建时使用） 1docker swarm init --advertise-addr 10.211.55.10 docker swarm join-token: 生成加入集群的令牌 1234# 生成 worker 节点的令牌docker swarm join-token worker# 生成 manager 节点的令牌docker swarm join-token manager docker swarm join: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用） 1docker swarm join --token &lt;token&gt; 10.211.55.10:2377 docker swarm leave: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用） 12345678910111213141516# worker 节点离开集群docker swarm leave# manager 节点必须先降级为 worker节点，或者加上 --force 强制离开docker swarm leave --force# 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点# 集群中至少需要一个Manager节点，否则无法运行服务# 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 downdocker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3lsxj50x8ftqw8etvz5y37xc5q worker2 Down Active 26.1.3# 如需彻底删除需要运行docker node rm worker2 docker swarm update: 更新 Swarm 集群配置 1234567891011121314# 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看docker swarm update --autolock=true## 输出Swarm updated.To unlock a swarm manager after it restarts, run the `docker swarm unlock`command and provide the following key: SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4Please remember to store this key in a password manager, since without it youwill not be able to restart the manager.# 关闭Swarm集群锁定docker swarm update --autolock=false docker swarm unlock-key: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定 1234# 获取Swarm集群的解锁密钥docker swarm unlock-key# 轮换Swarm集群的解锁密钥docker swarm unlock-key --rotate docker swarm unlock: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能 12345678910# 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令systemctl restart docker# 查看节点列表docker node ls## 输出Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use &quot;docker swarm unlock&quot; to unlock it.# 需要先解锁才可以运行节点管理命令docker swarm unlock## 会提示输入解锁密钥，解锁后就恢复正常了Please enter unlock key: docker node节点管理 节点管理相关命令，只能在 管理节点 上执行 命令 中文含义 demote 将一个或多个管理节点降级为工作节点 inspect 显示一个或多个节点的详细信息 ls 列出 swarm 集群中的所有节点 promote 将一个或多个工作节点提升为管理节点 ps 查看一个或多个节点上正在运行的任务（默认当前节点） rm 从 swarm 集群中移除一个或多个节点 update 更新节点的元数据（如标签、可用性等） docker node ls: 列出 swarm 集群中的所有节点 1docker node ls docker node inspect &lt;node_id&gt;/&lt;hostname&gt;: 查看指定节点的详细信息 1docker node inspect --pretty manager1 docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;: 更新节点的元数据 123456# 设置节点为不可用docker node update --availability drain manager1# 添加标签docker node update --label-add foo=bar manager1# 删除标签docker node update --label-rm foo manager1 docker node demote &lt;node_id&gt;/&lt;hostname&gt;: 将管理节点降级为工作节点 1docker node demote manager1 docker note promote &lt;node_id&gt;/&lt;hostname&gt;: 将工作节点升级为管理节点 1docker node promote worker1 docker node rm &lt;node_id&gt;/&lt;hostname&gt;: 从 swarm 集群中移除一个节点 1docker node rm manager1 节点管理常见情况 如何正确的删除一个节点 1.如果是 manager 节点，先将 manager 节点降级为 worker 节点 1docker node demote manager1 2.退出集群 12# 在要退出集群的节点上执行docker swarm leave 3.删除节点 1docker node rm manager1 节点被退群或删除后，其上运行的service会怎样？ 用一个示例来说明，先在 manager1 节点上创建一个 service 123456# --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器docker service create \\ --name my-nginx \\ --publish 8080:80 \\ --replicas 10 \\ nginx:latest 查看service状态 12345678910111213docker service ps my-nginx## 输出结果，可以看到每个节点上都启动了2个nginx容器ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running about a minute agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running about a minute agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 2 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running about a minute agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 2 minutes agoi6mieuodbrtg my-nginx.6 nginx:latest worker2 Running Running about a minute ago2yohffzzsrrl my-nginx.7 nginx:latest worker1 Running Running 2 minutes agof3lusxoflqn2 my-nginx.8 nginx:latest worker2 Running Running about a minute agoxovzfmzsjlet my-nginx.9 nginx:latest worker1 Running Running 2 minutes agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running about a minute ago 这时将 worker2 从集群中退群 12345678910# 在worker2节点执行docker swarm leave# 在manager节点查看集群节点docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3x87lfn4pzorahpr9zehv9ag3f worker2 Down Active 26.1.3 再次查看service状态 123456789101112131415docker service ps my-nginx# 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running 6 minutes agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running 6 minutes agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 6 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running 6 minutes agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 6 minutes agouz7wam5ul4aa my-nginx.6 nginx:latest manager2 Running Running 43 seconds agoi6mieuodbrtg \\_ my-nginx.6 nginx:latest worker2 Shutdown Running 6 minutes ago2yohffzzsrrl my-nginx.7 nginx:latest worker1 Running Running 6 minutes ago34km8mzg3xat my-nginx.8 nginx:latest manager3 Running Running 43 seconds agof3lusxoflqn2 \\_ my-nginx.8 nginx:latest worker2 Shutdown Running 6 minutes agoxovzfmzsjlet my-nginx.9 nginx:latest worker1 Running Running 6 minutes agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running 6 minutes ago 如果不退群直接删除节点呢？这次我们直接删除 worker1 节点 1234567891011121314151617181920212223242526272829303132333435# 删除 worker1 节点docker node rm worker1# 输出，提示 worker1 节点不是 down 状态，不能删除# Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed# 接着我们强制删除docker node rm -f worker1# 查看节点列表docker node ls# 输出，可以看到worker1节点已经删除了ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3x87lfn4pzorahpr9zehv9ag3f worker2 Down Active 26.1.3# 再次查看service状态docker service ps my-nginx## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running 12 minutes agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running 12 minutes agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 12 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running 12 minutes agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 12 minutes agouz7wam5ul4aa my-nginx.6 nginx:latest manager2 Running Running 6 minutes agoi6mieuodbrtg \\_ my-nginx.6 nginx:latest worker2 Shutdown Running 12 minutes ago3t4qvpvrzpg3 my-nginx.7 nginx:latest manager1 Running Running about a minute ago2yohffzzsrrl \\_ my-nginx.7 nginx:latest v31visfparkcsr9hswkb6v09u Shutdown Orphaned about a minute ago34km8mzg3xat my-nginx.8 nginx:latest manager3 Running Running 6 minutes agof3lusxoflqn2 \\_ my-nginx.8 nginx:latest worker2 Shutdown Running 12 minutes ago4w5zfpfye3t8 my-nginx.9 nginx:latest manager1 Running Running about a minute agoxovzfmzsjlet \\_ my-nginx.9 nginx:latest v31visfparkcsr9hswkb6v09u Shutdown Orphaned about a minute agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running 12 minutes ago 节点被退群或删除后是否可以重新加入集群 节点被退群或删除后，可以通过 docker swarm join 命令重新加入集群 若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 docker swarm leave 命令退群后再加入集群 如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法 12345678910111213# 这里重启一个manager节点的docker服务systemctl restart docker# 查看节点列表docker node ls## 输出Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use &quot;docker swarm unlock&quot; to unlock it.# 需要先解锁才可以运行节点管理命令docker swarm unlock## 会提示输入解锁密钥，解锁后就恢复正常了Please enter unlock key:## 如果忘记了密钥，可以在其它manager节点通过如下命令查看docker swarm unlock-key# 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了 Swarm 集群锁定功能的作用及使用场景 作用 ✅ 作用 📋 说明 加密保护管理密钥 管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。 防止节点被非法重启后加入集群 如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。 场景 场景类型 具体描述 ✅ 适合场景 对安全性要求高的生产环境 部署在不可信或共享物理环境中 云服务器、数据中心有专人运维管理解锁过程 希望防止物理/远程入侵者恢复管理器角色的公司 ❌ 不适合场景 需要自动化部署或重启的 CI/CD 系统 测试环境或开发集群 无人值守、要求高可用自动恢复的部署系统 总结 项目 是否推荐 安全性 ✅ 强烈推荐启用（尤其在生产环境） 自动化 ❌ 不推荐（增加人工干预步骤） 解锁方式 解锁命令 + unlock key unlock key 丢失后果 可能需要重建 Swarm（除非提前备份） docker swarm ca 是做什么用的？ docker swarm ca 命令是用来 管理 Swarm 集群中的根证书颁发机构（CA） 的工具。具体功能包括： 子命令/参数 说明 docker swarm ca 查看当前 Swarm 的根 CA 公钥（PEM 格式） docker swarm ca --rotate 轮换根 CA，用于安全更新 Swarm 中的证书是干什么用的？ 用途 说明 ✅ 节点身份验证 每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。 🔐 通信加密 节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。 🔄 自动轮换 Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。 Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置： 123456cd /var/lib/docker/swarm/certificatestree.├── swarm-node.crt # 节点证书├── swarm-node.key # 节点密钥└── swarm-root-ca.crt # 根CA证书 只让 Manager 做管理，不运行服务 节点的AVAILABILITY有三种：active、pause、drain。 状态 说明 active 可调度，Swarm 可以在此节点上运行服务任务（默认） pause 暂停调度，不会分配新任务，但保留已有任务 drain 排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点 如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。 123456789101112131415161718192021222324252627282930313233# 设置 manager1 节点为“不可调度”，即 排空模式docker node update --availability drain manager1# 查看节点状态docker node ls## 输出，manager1 节点状态变为 排空ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Drain Reachable 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Leader 26.1.3xkww4853bbdgv7bv8771xibob worker1 Ready Active 26.1.3hvzkh3ip5ef8gx973z1ywahbu worker2 Ready Active 26.1.3# 查看服务状态docker service ps my-nginx## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS23m03nj54mzo my-nginx.1 nginx:latest worker2 Running Running 35 seconds ago9xi83bnh4fus my-nginx.2 nginx:latest worker2 Running Running 35 seconds agowos8tbk449lk my-nginx.3 nginx:latest manager2 Running Running 28 seconds agouosmuh6bvwm0 \\_ my-nginx.3 nginx:latest manager1 Shutdown Shutdown 7 seconds agoyeqhqc3f735y my-nginx.4 nginx:latest manager2 Running Running about a minute agog8rduix7s74v my-nginx.5 nginx:latest worker2 Running Running less than a second agowuxilgpv9f50 \\_ my-nginx.5 nginx:latest manager1 Shutdown Shutdown 7 seconds ago3bxtn9boit28 my-nginx.6 nginx:latest manager3 Running Running 28 seconds ago57kdggaf8sag my-nginx.7 nginx:latest manager2 Running Running about a minute agouugi506p74s8 my-nginx.8 nginx:latest worker1 Running Running 28 seconds agoyifwpqjnts9l my-nginx.9 nginx:latest worker1 Running Running 28 seconds agoyv4p6su7aom5 my-nginx.10 nginx:latest manager3 Running Running 28 seconds ago# 恢复运行任务能力docker node update --availability active manager1# 停止接收新的任务但保留运行中的任务docker node update --availability pause manager1","summary":"摘要 本文介绍 Docker Swarm 的 节点管理 Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-09T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/","url":"https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/","title":"Docker 命令 之 Dockerfile 多平台构建","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/reference/builder/\">Dockerfile官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/build/building/multi-platform/\">Multi-platform builds</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Dockerfile-多平台构建？\">什么是Dockerfile 多平台构建？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在没有安装 <code>docker-buildx-plugin</code> 的情况下，<code>docker build</code> 命令是不支持使用 <code>--platform</code> 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。</p>\n</li>\n<li class=\"lvl-2\">\n<p>要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>docker-buildx-plugin</code> 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 <code>docker build</code> 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。</p>\n</li>\n</ul>\n<h2 id=\"安装-docker-buildx-plugin\">安装 docker-buildx-plugin</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>随docker服务一起安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单独安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install docker-buildx-plugin</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx version</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-buildx-基本命令\"><code>docker buildx</code> 基本命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以下命令在后面的示例中都有使用</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker buildx create</code></td>\n<td>创建一个新的构建器实例</td>\n</tr>\n<tr>\n<td><code>docker buildx use</code></td>\n<td>设置当前使用的构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx inspect</code></td>\n<td>查看构建器状态和支持的平台</td>\n</tr>\n<tr>\n<td><code>docker buildx build</code></td>\n<td>构建镜像（增强版），等同于 <code>docker build</code></td>\n</tr>\n<tr>\n<td><code>docker buildx ls</code></td>\n<td>列出所有构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx rm</code></td>\n<td>删除构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx du</code></td>\n<td>查看构建器使用的磁盘空间</td>\n</tr>\n<tr>\n<td><code>docker buildx prune</code></td>\n<td>删除构建过程中产生的缓存</td>\n</tr>\n<tr>\n<td><code>docker buildx version</code></td>\n<td>查看 Docker Buildx 的版本信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"要让Docker支持多平台构建，需要满足以下几个条件：\">要让Docker支持多平台构建，需要满足以下几个条件：</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Linux内核开启多处理器架构支持</p>\n</li>\n<li class=\"lvl-2\">\n<p>构建时使用基于<code>docker-container</code>驱动的Buildx实例</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>–platform</code>参数</p>\n</li>\n</ul>\n<h2 id=\"Linux内核开启多处理器架构支持\">Linux内核开启多处理器架构支持</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">default          docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启多处理器架构支持</span></span><br><span class=\"line\">docker run --privileged --<span class=\"built_in\">rm</span> tonistiigi/binfmt --install all</span><br><span class=\"line\"><span class=\"comment\"># 这个镜像用完就可以删除了</span></span><br><span class=\"line\">docker rmi tonistiigi/binfmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次列出所有构建器</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，此时可以看到PLATFORMS中有多个平台</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">default*         docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建时使用基于docker-container驱动的Buildx实例\">构建时使用基于<code>docker-container</code>驱动的Buildx实例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前默认的构建器default</span></span><br><span class=\"line\">docker buildx inspect default</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Name:          default</span><br><span class=\"line\">Driver:        docker</span><br><span class=\"line\">Last Activity: 2025-06-06 07:42:42 +0000 UTC</span><br><span class=\"line\"></span><br><span class=\"line\">Nodes:</span><br><span class=\"line\">Name:             default</span><br><span class=\"line\">Endpoint:         default</span><br><span class=\"line\">Status:           running</span><br><span class=\"line\">BuildKit version: v0.13.2</span><br><span class=\"line\">Platforms:        linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\">Labels:</span><br><span class=\"line\"> org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建基于 <code>docker-container</code> 驱动的Buildx实例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建并切换到名为mybuilder的构建器实例</span></span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container</span><br><span class=\"line\"><span class=\"comment\"># 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了</span></span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Name:          mybuilder</span><br><span class=\"line\">Driver:        docker-container</span><br><span class=\"line\">……………………………………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                           COMMAND                   CREATED             STATUS                       PORTS                    NAMES</span><br><span class=\"line\">0ab9cab9ec9b   moby/buildkit:buildx-stable-1   <span class=\"string\">&quot;buildkitd --allow-i…&quot;</span>   About an hour ago   Up About an hour                                      buildx_buildkit_mybuilder0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>buildx_buildkit_xxx</code>这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为<code>moby/buildkit:buildx-stable-1</code>，容器会在执行<code>docker buildx build</code> 或 <code>docker buildx inspect --bootstrap</code> 时启动</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>👷 执行构建任务</td>\n<td>真正执行 <code>buildx build</code> 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等</td>\n</tr>\n<tr>\n<td>📦 拉取镜像</td>\n<td>拉取 <code>Dockerfile</code> 中的基础镜像</td>\n</tr>\n<tr>\n<td>📤 上传/导出镜像</td>\n<td>支持导出为 <code>docker image</code>, <code>tar</code>, 推送到远程 registry</td>\n</tr>\n<tr>\n<td>🪣 管理缓存</td>\n<td>管理构建缓存（中间镜像、层等）以加速后续构建</td>\n</tr>\n<tr>\n<td>🌍 支持多平台</td>\n<td>通过 QEMU 或交叉编译器支持跨平台（如构建 <code>arm64</code> 镜像）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在<code>/etc/docker/daemon.json</code>中配置了国内的镜像源也不行，这是因为<code>docker buildx</code> 使用的是 BuildKit，它的行为不同于传统的 <code>docker build</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>docker build</code>（传统）</th>\n<th><code>docker buildx</code>（BuildKit）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否使用本地镜像缓存</td>\n<td>✅ 是</td>\n<td>⚠️ <strong>不是</strong></td>\n</tr>\n<tr>\n<td>是否需要联网拉取元数据（即使镜像已存在）</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>构建网络隔离</td>\n<td>不隔离</td>\n<td>隔离构建，无法直接访问宿主镜像缓存</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法为构建器配置镜像源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 BuildKit 配置文件 buildkitd.toml</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF &gt; buildkitd.toml</span></span><br><span class=\"line\"><span class=\"string\">[registry.&quot;docker.io&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  mirrors = [&quot;https://docker.1ms.run&quot;]</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[worker.oci]</span></span><br><span class=\"line\"><span class=\"string\">  gc = true</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 BuildKit 构建器，并指定配置文件</span></span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果存在同名的构建器，则删除它后再创建</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">rm</span> mybuilder</span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看构建器列表</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">mybuilder*       docker-container</span><br><span class=\"line\"> \\_ mybuilder0    \\_ unix:///var/run/docker.sock   running   v0.21.1    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\">default          docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果要切换回默认的构建器，请执行以下命令</span></span><br><span class=\"line\">docker buildx use default</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用docker-buildx-build命令构建镜像，构建命令必须指定-platform参数\">使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>--platform</code>参数</h2>\n<h3 id=\"示例一：单阶段构建\">示例一：单阶段构建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们依旧以一个springboot项目为例，其Dockerfile如下：</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> JAR_FILE=app.jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像元信息</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> version=<span class=\"string\">&quot;1.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> description=<span class=\"string\">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开始构建镜像，<code>docker buildx build == docker build</code>，构建多平台架构时需要使用<code>--platform</code>指定构建平台</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --platform inux/arm64 :构建arm64镜像</span></span><br><span class=\"line\"><span class=\"comment\"># -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest</span></span><br><span class=\"line\"><span class=\"comment\"># --load :构建后加载到本地</span></span><br><span class=\"line\"><span class=\"comment\"># . :当前目录查找Dockerfile文件</span></span><br><span class=\"line\"><span class=\"comment\"># -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称</span></span><br><span class=\"line\">docker buildx build --platform linux/arm64 -t <span class=\"string\">&quot;app.arm64&quot;</span> --load .</span><br><span class=\"line\"><span class=\"comment\">## 此时会遇到如下错误</span></span><br><span class=\"line\">ERROR: failed to solve: openjdk:17-alpine: failed to resolve <span class=\"built_in\">source</span> metadata <span class=\"keyword\">for</span> docker.io/library/openjdk:17-alpine: no match <span class=\"keyword\">for</span> platform <span class=\"keyword\">in</span> manifest: not found</span><br><span class=\"line\"><span class=\"comment\">## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询镜像支持的平台，不过国内依旧是不支持</span></span><br><span class=\"line\">docker buildx imagetools inspect nginx:latest |  grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\"># 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/nginx:latest |  grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">  Platform:    linux/386</span><br><span class=\"line\">  Platform:    linux/amd64</span><br><span class=\"line\">  Platform:    linux/arm64/v8</span><br><span class=\"line\">  Platform:    linux/arm/v5</span><br><span class=\"line\">  Platform:    linux/arm/v7</span><br><span class=\"line\">  Platform:    linux/mips64le</span><br><span class=\"line\">  Platform:    linux/ppc64le</span><br><span class=\"line\">  Platform:    linux/s390x</span><br><span class=\"line\">  Platform:    unknown/unknown</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着我们查看openjdk:17-alpine这个镜像</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果，其确实不支持 linux/arm64</span></span><br><span class=\"line\">  Platform:  linux/amd64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 我们换一个openjdk镜像试试</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以看到这个镜像同时支持amd64和arm64架构</span></span><br><span class=\"line\">  Platform:  linux/amd64</span><br><span class=\"line\">  Platform:  linux/arm64/v8</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用skopeo容器的方式进行查询</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r <span class=\"string\">&#x27;.manifests[].platform | &quot;\\(.os)/\\(.architecture)/\\(.variant)&quot;&#x27;</span> | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span> | sed <span class=\"string\">&#x27;s/\\/null//&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">linux/amd64</span><br><span class=\"line\">linux/arm64/v8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>替换支持多架构的镜像后重新构建镜像就会成功</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx build --platform linux/arm64 -t <span class=\"string\">&quot;app.arm64&quot;</span> --load .</span><br><span class=\"line\">docker buildx build --platform linux/amd64 -t <span class=\"string\">&quot;app.amd64&quot;</span> --load .</span><br><span class=\"line\"><span class=\"comment\"># 列出镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class=\"line\">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看构建后镜像的架构</span></span><br><span class=\"line\">docker inspect app.amd64 | jq <span class=\"string\">&#x27;.[0].Architecture&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;amd64&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 我们也可以将构建后的镜像输出到本地目录</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64 -t <span class=\"string\">&quot;app.amd64&quot;</span> --output <span class=\"built_in\">type</span>=docker,dest=./app.amd64.tar .</span><br><span class=\"line\"><span class=\"comment\"># 然后再将镜像导入到本地镜像仓库中</span></span><br><span class=\"line\">docker load -i app.amd64.tar</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--load</code>和 <code>--output</code>都不支持一个镜像多种架构，要构建像<code>openjdk:17-slim</code>这种支持多架构的镜像可以使用<code>--push</code>，一步就推送到远程仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。</span></span><br><span class=\"line\"><span class=\"comment\"># 这里以推送到 docker hub 为例</span></span><br><span class=\"line\"><span class=\"comment\"># 登录 docker hup</span></span><br><span class=\"line\">docker login -u hanqunfeng</span><br><span class=\"line\"><span class=\"comment\"># 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push .</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/WdmJx0.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>镜像拉取</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像</span></span><br><span class=\"line\">docker pull --platform=linux/arm64 hanqunfeng/app:latest</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例二：多阶段构建\">示例二：多阶段构建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>要求每个阶段中的基础镜像都要支持多架构</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段：获取代码</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine/git AS fetcher</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_BRANCH=master</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;GIT_BRANCH&#125;</span> <span class=\"variable\">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段：使用Maven环境进行构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> maven:<span class=\"number\">3.8</span>.<span class=\"number\">4</span>-openjdk-<span class=\"number\">17</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段复制代码</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=fetcher /workspace/application .</span></span><br><span class=\"line\"><span class=\"comment\"># 使用Maven清理并打包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> mvn clean package -DskipTests</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三阶段：创建最终的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建多平台镜像并发布到dockerhub</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push .</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何将构建好的多个单平台镜像发布为一个多平台镜像\">如何将构建好的多个单平台镜像发布为一个多平台镜像</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你已经分别构建好单平台镜像，也可以用 <code>docker buildx imagetools create</code> 来合并</p>\n</li>\n<li class=\"lvl-2\">\n<p>以上面创建的两个单平台镜像为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class=\"line\">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一定要推送单平台镜像到远程仓库，否则无法完成合并</span></span><br><span class=\"line\">docker tag app.amd64 hanqunfeng/app:amd64</span><br><span class=\"line\">docker push hanqunfeng/app:amd64</span><br><span class=\"line\"></span><br><span class=\"line\">docker tag app.arm64 hanqunfeng/app:arm64</span><br><span class=\"line\">docker push hanqunfeng/app:arm64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并，创建多平台镜像指向（manifest list）</span></span><br><span class=\"line\">docker buildx imagetools create \\</span><br><span class=\"line\">  --tag hanqunfeng/app:latest \\</span><br><span class=\"line\">   hanqunfeng/app:amd64 \\</span><br><span class=\"line\">   hanqunfeng/app:arm64</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/5azhzj.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果不需要单平台镜像，可以在dockerhub上删除即可。</p>\n</li>\n</ul>\n<h2 id=\"移除-BuildKit（Buildx）构建过程中产生的缓存数据\">移除 BuildKit（Buildx）构建过程中产生的缓存数据</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以通过该命令查看缓存占用磁盘空间的大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx <span class=\"built_in\">du</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker buildx prune</code> 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx prune [OPTIONS]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>OPTIONS</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-a</code>, <code>--all</code></td>\n<td><strong>包括内部/前端镜像</strong>。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。</td>\n</tr>\n<tr>\n<td><code>--builder string</code></td>\n<td>指定使用哪个 builder 实例（可通过 <code>docker buildx ls</code> 查看当前有哪些 builder）。</td>\n</tr>\n<tr>\n<td><code>--filter filter</code></td>\n<td>设定清理条件，例如：<code>until=24h</code> 表示只删除 24 小时前的缓存。</td>\n</tr>\n<tr>\n<td><code>-f</code>, <code>--force</code></td>\n<td><strong>不提示确认，直接执行清理操作</strong>。常用于脚本中。</td>\n</tr>\n<tr>\n<td><code>--keep-storage bytes</code></td>\n<td>保留指定大小的缓存空间，其余删除（如：<code>--keep-storage 5GB</code>）。</td>\n</tr>\n<tr>\n<td><code>--verbose</code></td>\n<td>输出更详细的清理信息。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未使用的缓存，并跳过确认提示</span></span><br><span class=\"line\">docker buildx prune -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只删除 24 小时前的缓存，保留 10GB 的缓存空间</span></span><br><span class=\"line\">docker buildx prune --filter <span class=\"string\">&quot;until=24h&quot;</span> --keep-storage 10GB</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法 Docker官方文档 Dockerfile官方文档 Multi-platform builds 什么是Dockerfile 多平台构建？ Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。 在没有安装 docker-buildx-plugin 的情况下，docker build 命令是不支持使用 --platform 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。 要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。 docker-buildx-plugin 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 docker build 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。 安装 docker-buildx-plugin 随docker服务一起安装 1sudo dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 单独安装 1sudo dnf -y install docker-buildx-plugin 查看版本 1docker buildx version docker buildx 基本命令 以下命令在后面的示例中都有使用 命令 说明 docker buildx create 创建一个新的构建器实例 docker buildx use 设置当前使用的构建器 docker buildx inspect 查看构建器状态和支持的平台 docker buildx build 构建镜像（增强版），等同于 docker build docker buildx ls 列出所有构建器 docker buildx rm 删除构建器 docker buildx du 查看构建器使用的磁盘空间 docker buildx prune 删除构建过程中产生的缓存 docker buildx version 查看 Docker Buildx 的版本信息 要让Docker支持多平台构建，需要满足以下几个条件： Linux内核开启多处理器架构支持 构建时使用基于docker-container驱动的Buildx实例 使用docker buildx build命令构建镜像，构建命令必须指定–platform参数 Linux内核开启多处理器架构支持 123456789101112131415161718# 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器docker buildx ls## 输出NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSdefault docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386# 开启多处理器架构支持docker run --privileged --rm tonistiigi/binfmt --install all# 这个镜像用完就可以删除了docker rmi tonistiigi/binfmt# 再次列出所有构建器docker buildx ls## 输出，此时可以看到PLATFORMS中有多个平台NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSdefault* docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6 构建时使用基于docker-container驱动的Buildx实例 Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。 多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。 123456789101112131415# 查看当前默认的构建器defaultdocker buildx inspect default# 输出Name: defaultDriver: dockerLast Activity: 2025-06-06 07:42:42 +0000 UTCNodes:Name: defaultEndpoint: defaultStatus: runningBuildKit version: v0.13.2Platforms: linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6Labels: org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1 创建基于 docker-container 驱动的Buildx实例 12345678910111213# 创建并切换到名为mybuilder的构建器实例docker buildx create --name mybuilder --use --driver docker-container# 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了docker buildx inspect --bootstrap## 输出Name: mybuilderDriver: docker-container……………………………………# 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0ab9cab9ec9b moby/buildkit:buildx-stable-1 &quot;buildkitd --allow-i…&quot; About an hour ago Up About an hour buildx_buildkit_mybuilder0 buildx_buildkit_xxx这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为moby/buildkit:buildx-stable-1，容器会在执行docker buildx build 或 docker buildx inspect --bootstrap 时启动 功能 说明 👷 执行构建任务 真正执行 buildx build 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等 📦 拉取镜像 拉取 Dockerfile 中的基础镜像 📤 上传/导出镜像 支持导出为 docker image, tar, 推送到远程 registry 🪣 管理缓存 管理构建缓存（中间镜像、层等）以加速后续构建 🌍 支持多平台 通过 QEMU 或交叉编译器支持跨平台（如构建 arm64 镜像） 在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在/etc/docker/daemon.json中配置了国内的镜像源也不行，这是因为docker buildx 使用的是 BuildKit，它的行为不同于传统的 docker build 特性 docker build（传统） docker buildx（BuildKit） 是否使用本地镜像缓存 ✅ 是 ⚠️ 不是 是否需要联网拉取元数据（即使镜像已存在） 否 是 构建网络隔离 不隔离 隔离构建，无法直接访问宿主镜像缓存 解决方法为构建器配置镜像源 1234567891011121314151617181920212223242526272829# 创建 BuildKit 配置文件 buildkitd.tomlcat &lt;&lt;EOF &gt; buildkitd.toml[registry.&quot;docker.io&quot;] mirrors = [&quot;https://docker.1ms.run&quot;][worker.oci] gc = trueEOF# 创建 BuildKit 构建器，并指定配置文件docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.tomldocker buildx inspect --bootstrap# 如果存在同名的构建器，则删除它后再创建docker buildx rm mybuilderdocker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.tomldocker buildx inspect --bootstrap# 查看构建器列表docker buildx ls## 输出NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSmybuilder* docker-container \\_ mybuilder0 \\_ unix:///var/run/docker.sock running v0.21.1 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6default docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6# 如果要切换回默认的构建器，请执行以下命令docker buildx use default 使用docker buildx build命令构建镜像，构建命令必须指定--platform参数 示例一：单阶段构建 我们依旧以一个springboot项目为例，其Dockerfile如下： 1234567891011121314151617181920212223242526272829303132333435# 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用FROM openjdk:17-alpine# 设置构建时变量，默认使用构建好的 jar 文件ARG JAR_FILE=app.jar# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;ENV TZ=Asia/Shanghai# 镜像元信息LABEL maintainer=&quot;yourname@example.com&quot;LABEL version=&quot;1.0.0&quot;LABEL description=&quot;用于部署 Spring Boot 应用的生产级镜像&quot;# 设置工作目录WORKDIR /app# 复制 Spring Boot 构建生成的 jar 包COPY $&#123;JAR_FILE&#125; app.jar# 声明暴露的应用端口（Spring Boot 默认是 8080）EXPOSE 8080# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;] 开始构建镜像，docker buildx build == docker build，构建多平台架构时需要使用--platform指定构建平台 123456789# --platform inux/arm64 :构建arm64镜像# -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest# --load :构建后加载到本地# . :当前目录查找Dockerfile文件# -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称docker buildx build --platform linux/arm64 -t &quot;app.arm64&quot; --load .## 此时会遇到如下错误ERROR: failed to solve: openjdk:17-alpine: failed to resolve source metadata for docker.io/library/openjdk:17-alpine: no match for platform in manifest: not found## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像 如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令 1234567891011121314151617181920212223242526272829303132# 查询镜像支持的平台，不过国内依旧是不支持docker buildx imagetools inspect nginx:latest | grep Platform | sort | uniq# 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：docker buildx imagetools inspect docker.1ms.run/nginx:latest | grep Platform | sort | uniq## 输出结果 Platform: linux/386 Platform: linux/amd64 Platform: linux/arm64/v8 Platform: linux/arm/v5 Platform: linux/arm/v7 Platform: linux/mips64le Platform: linux/ppc64le Platform: linux/s390x Platform: unknown/unknown# 接着我们查看openjdk:17-alpine这个镜像docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | sort | uniq## 输出结果，其确实不支持 linux/arm64 Platform: linux/amd64# 我们换一个openjdk镜像试试docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | sort | uniq## 输出结果，可以看到这个镜像同时支持amd64和arm64架构 Platform: linux/amd64 Platform: linux/arm64/v8# 也可以使用skopeo容器的方式进行查询docker run --rm quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r &#x27;.manifests[].platform | &quot;\\(.os)/\\(.architecture)/\\(.variant)&quot;&#x27; | sort | uniq | sed &#x27;s/\\/null//&#x27;## 输出结果linux/amd64linux/arm64/v8 替换支持多架构的镜像后重新构建镜像就会成功 123456789101112131415161718docker buildx build --platform linux/arm64 -t &quot;app.arm64&quot; --load .docker buildx build --platform linux/amd64 -t &quot;app.amd64&quot; --load .# 列出镜像docker images## 输出结果REPOSITORY TAG IMAGE ID CREATED SIZEapp.amd64 latest 859162438372 2 hours ago 431MBapp.arm64 latest 0058c70dd16e 2 hours ago 426MB# 查看构建后镜像的架构docker inspect app.amd64 | jq &#x27;.[0].Architecture&#x27;## 输出&quot;amd64&quot;# 我们也可以将构建后的镜像输出到本地目录docker buildx build --platform linux/amd64 -t &quot;app.amd64&quot; --output type=docker,dest=./app.amd64.tar .# 然后再将镜像导入到本地镜像仓库中docker load -i app.amd64.tar --load和 --output都不支持一个镜像多种架构，要构建像openjdk:17-slim这种支持多架构的镜像可以使用--push，一步就推送到远程仓库 123456# 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。# 这里以推送到 docker hub 为例# 登录 docker hupdocker login -u hanqunfeng# 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push . 镜像拉取 12# 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像docker pull --platform=linux/arm64 hanqunfeng/app:latest 示例二：多阶段构建 要求每个阶段中的基础镜像都要支持多架构 12345678910111213141516171819202122232425262728293031323334# 第一阶段：获取代码FROM alpine/git AS fetcherWORKDIR /workspace/application# 将替换为实际的Git仓库URL和分支/标签ARG GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.gitARG GIT_BRANCH=masterRUN git clone -b $&#123;GIT_BRANCH&#125; $&#123;GIT_REPOSITORY&#125; .# 第二阶段：使用Maven环境进行构建FROM maven:3.8.4-openjdk-17 AS builderWORKDIR /workspace/application# 从第一阶段复制代码COPY --from=fetcher /workspace/application .# 使用Maven清理并打包RUN mvn clean package -DskipTests# 第三阶段：创建最终的运行环境FROM openjdk:17-slimWORKDIR /app# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;# 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jarCOPY --from=builder /workspace/application/target/app.jar app.jar# 暴露端口（如果需要的话）。请根据实际情况修改端口号EXPOSE 8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;]# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080 构建镜像 12# 构建多平台镜像并发布到dockerhubdocker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push . 如何将构建好的多个单平台镜像发布为一个多平台镜像 如果你已经分别构建好单平台镜像，也可以用 docker buildx imagetools create 来合并 以上面创建的两个单平台镜像为例 12345678910111213141516171819# 列出镜像docker images## 输出结果REPOSITORY TAG IMAGE ID CREATED SIZEapp.amd64 latest 859162438372 2 hours ago 431MBapp.arm64 latest 0058c70dd16e 2 hours ago 426MB# 一定要推送单平台镜像到远程仓库，否则无法完成合并docker tag app.amd64 hanqunfeng/app:amd64docker push hanqunfeng/app:amd64docker tag app.arm64 hanqunfeng/app:arm64docker push hanqunfeng/app:arm64# 合并，创建多平台镜像指向（manifest list）docker buildx imagetools create \\ --tag hanqunfeng/app:latest \\ hanqunfeng/app:amd64 \\ hanqunfeng/app:arm64 如果不需要单平台镜像，可以在dockerhub上删除即可。 移除 BuildKit（Buildx）构建过程中产生的缓存数据 BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。 可以通过该命令查看缓存占用磁盘空间的大小 1docker buildx du docker buildx prune 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。 命令语法 1docker buildx prune [OPTIONS] OPTIONS 作用 -a, --all 包括内部/前端镜像。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。 --builder string 指定使用哪个 builder 实例（可通过 docker buildx ls 查看当前有哪些 builder）。 --filter filter 设定清理条件，例如：until=24h 表示只删除 24 小时前的缓存。 -f, --force 不提示确认，直接执行清理操作。常用于脚本中。 --keep-storage bytes 保留指定大小的缓存空间，其余删除（如：--keep-storage 5GB）。 --verbose 输出更详细的清理信息。 示例 12345# 删除所有未使用的缓存，并跳过确认提示docker buildx prune -f# 只删除 24 小时前的缓存，保留 10GB 的缓存空间docker buildx prune --filter &quot;until=24h&quot; --keep-storage 10GB","summary":"摘要 本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法 Docker官方文档 Dockerfile官方文档 Multi-platform builds","date_published":"2025-06-06T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/","url":"https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/","title":"Docker 之 远程连接","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何远程连接Docker</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"远程连接Docker有如下三种方式\">远程连接Docker有如下三种方式</h2>\n<h3 id=\"方式一：开启-TCP（不带-TLS，仅用于内网调试）\">方式一：开启 TCP（不带 TLS，仅用于内网调试）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在docker服务端编辑 <code>/etc/docker/daemon.json</code>，加上：</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hosts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;unix:///var/run/docker.sock&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;tcp://0.0.0.0:2375&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时通过<code>sudo systemctl restart docker</code>重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 <code>-H fd://</code>，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 <code>-H fd://</code> 意思是：“不用自己打开 socket，去 systemd 那里拿吧。”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.service</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status docker</span><br><span class=\"line\"><span class=\"comment\"># 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到  -H fd://</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 另外可以在与 docker.service 同目录下找到  docker.socket 文件，可以看到如下内容</span></span><br><span class=\"line\">ListenStream=/run/docker.sock <span class=\"comment\"># /run 目录是被软连接到 /var/run/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock</span></span><br><span class=\"line\"><span class=\"comment\"># 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了</span></span><br><span class=\"line\"><span class=\"comment\"># 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dockerd --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://`</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方式一: 去掉 `-H fd://` 参数</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /usr/lib/systemd/system/docker.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class=\"line\"><span class=\"comment\"># 填入</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，</span></span><br><span class=\"line\"><span class=\"comment\"># 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。</span></span><br><span class=\"line\"><span class=\"comment\"># Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启 docker daemon</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端测试连接</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H tcp://远程IP:2375 ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端加入环境变量后就不需要每次都加上 -H 参数了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># zsh 就换成 ~/.zshrc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=tcp://远程IP:2375&quot;</span>  &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>❗不要开启无认证的 <code>tcp://0.0.0.0:2375</code> 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。</p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ 推荐方式是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">使用 <code>tcp://0.0.0.0:2376 + --tlsverify</code></li>\n<li class=\"lvl-6\">或通过 <code>ssh:// 隧道</code> 访问 Docker</li>\n</ul>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">通过上面的介绍你应该搞明白一件事，就是我们可以不用在 <code>/etc/docker/daemon.json</code> 中配置远程连接，而是通过 systemd 来配置，即在 <code>/usr/lib/systemd/system/docker.service</code> 或者 <code>/etc/systemd/system/docker.service.d/override.conf</code>中配置。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">那么问题来了：既然 systemd 就能搞定一切，那还要 <code>/etc/docker/daemon.json</code> 有什么用？答案是：可读性、可维护性、工具兼容性更强。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>daemon.json</code></th>\n<th><code>systemd ExecStart</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法</td>\n<td>JSON</td>\n<td>Shell 命令行</td>\n</tr>\n<tr>\n<td>适合设置</td>\n<td>Hosts、日志、registry、镜像驱动等</td>\n<td>启动命令、资源限制等</td>\n</tr>\n<tr>\n<td>可读性</td>\n<td>👍 结构化</td>\n<td>👎 较长、容易出错</td>\n</tr>\n<tr>\n<td>自动化支持</td>\n<td>👍 工具友好</td>\n<td>👎 需要 patch systemd</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"方式二：开启-TCP-TLS-安全访问（推荐用于公网）\">方式二：开启 TCP + TLS 安全访问（推荐用于公网）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 TLS 证书，通过一个脚本实现，脚本名称 <code>generate-docker-certs.sh</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"></span><br><span class=\"line\">SERVER_IP=166.189.9.114  <span class=\"comment\"># 🚨 修改为你的 Docker 服务器 IP 或域名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建 CA...&quot;</span></span><br><span class=\"line\">openssl genrsa -out ca-key.pem 4096</span><br><span class=\"line\">openssl req -new -x509 -days 365 \\</span><br><span class=\"line\">  -key ca-key.pem -subj <span class=\"string\">&quot;/CN=docker-ca&quot;</span> -out ca.pem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建服务器私钥...&quot;</span></span><br><span class=\"line\">openssl genrsa -out server-key.pem 4096</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建 OpenSSL 配置文件...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; extfile.cnf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[req]</span></span><br><span class=\"line\"><span class=\"string\">distinguished_name = req_distinguished_name</span></span><br><span class=\"line\"><span class=\"string\">x509_extensions = v3_req</span></span><br><span class=\"line\"><span class=\"string\">prompt = no</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[req_distinguished_name]</span></span><br><span class=\"line\"><span class=\"string\">CN = $&#123;SERVER_IP&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[v3_req]</span></span><br><span class=\"line\"><span class=\"string\">keyUsage = keyEncipherment, dataEncipherment</span></span><br><span class=\"line\"><span class=\"string\">extendedKeyUsage = serverAuth</span></span><br><span class=\"line\"><span class=\"string\">subjectAltName = @alt_names</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[alt_names]</span></span><br><span class=\"line\"><span class=\"string\">IP.1 = $&#123;SERVER_IP&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建服务器证书签名请求 (CSR)...&quot;</span></span><br><span class=\"line\">openssl req -new -key server-key.pem \\</span><br><span class=\"line\">  -out server.csr -config extfile.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 签发服务器证书...&quot;</span></span><br><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> server.csr \\</span><br><span class=\"line\">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\</span><br><span class=\"line\">  -out server-cert.pem -extensions v3_req -extfile extfile.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建客户端私钥...&quot;</span></span><br><span class=\"line\">openssl genrsa -out key.pem 4096</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建客户端 CSR...&quot;</span></span><br><span class=\"line\">openssl req -new -key key.pem -subj <span class=\"string\">&quot;/CN=client&quot;</span> -out client.csr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 签发客户端证书...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; client-ext.cnf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">extendedKeyUsage = clientAuth</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> client.csr \\</span><br><span class=\"line\">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\</span><br><span class=\"line\">  -out cert.pem -extfile client-ext.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[✓] 所有证书生成完成！&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; 服务器证书: server-cert.pem, server-key.pem&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; 客户端证书: cert.pem, key.pem&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; CA根证书:   ca.pem&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>执行脚本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x generate-docker-certs.sh</span><br><span class=\"line\">./generate-docker-certs.sh</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将以下证书文件部署到docker服务端</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 服务端：server-cert.pem, server-key.pem, ca.pem</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> server-cert.pem /etc/docker/server-cert.pem</span><br><span class=\"line\"><span class=\"built_in\">cp</span> server-key.pem /etc/docker/server-key.pem</span><br><span class=\"line\"><span class=\"built_in\">cp</span> ca.pem /etc/docker/ca.pem</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将以下证书文件部署到docker客户端</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cert.pem, key.pem, ca.pem</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在docker服务端编辑 <code>/etc/docker/daemon.json</code></p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;hosts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;unix:///var/run/docker.sock&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;tcp://0.0.0.0:2376&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlsverify&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlscacert&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/ca.pem&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlscert&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/server-cert.pem&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlskey&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/server-key.pem&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class=\"line\"><span class=\"comment\"># 填入</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启 docker daemon</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端测试连接</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker \\</span><br><span class=\"line\">  --tlsverify \\</span><br><span class=\"line\">  --tlscacert=ca.pem \\</span><br><span class=\"line\">  --tlscert=cert.pem \\</span><br><span class=\"line\">  --tlskey=key.pem \\</span><br><span class=\"line\">  -H tcp://166.189.9.114:2376 \\</span><br><span class=\"line\">  ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOT &gt;&gt; ~/.bashrc</span></span><br><span class=\"line\"><span class=\"string\"># 远程Docker IP和端口</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_HOST=tcp://166.189.9.114:2376</span></span><br><span class=\"line\"><span class=\"string\"># 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverify</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_TLS_VERIFY=1</span></span><br><span class=\"line\"><span class=\"string\"># 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pem</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_CERT_PATH=/path/to/certs</span></span><br><span class=\"line\"><span class=\"string\">EOT</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式三：ssh-隧道访问\">方式三：ssh:// 隧道访问</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 <span class=\"string\">&quot;docker ps&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于免密认证，如何配置免密登录可以参考 <a href=\"/2023/02/28/linux-command02-ssh/\" title=\"Linux常用命令--ssh、scp与免密登录\">Linux常用命令--ssh、scp与免密登录</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22</span></span><br><span class=\"line\"><span class=\"comment\"># 要求登录用户必须拥有docker的运行权限（加入 docker group）</span></span><br><span class=\"line\">docker -H ssh://centos@166.189.9.114 ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于<code>config</code>配置(推荐)</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">这种方式的优点是可以配置证书和端口</li>\n<li class=\"lvl-6\">在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group）</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host mydocker</span><br><span class=\"line\">HostName 166.189.9.114</span><br><span class=\"line\">User centos</span><br><span class=\"line\">Port 22</span><br><span class=\"line\">IdentityFile ~/.ssh/my_docker_key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">测试</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H ssh://mydocker ps</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>添加环境变量避免每次都加上 <code>-H</code> 参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 基于免密认证</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=ssh://user@host&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\">## 或者基于config的方式</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=ssh://mydocker&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-context-同时连接多个远程docker\"><code>docker context</code>: 同时连接多个远程docker</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面介绍的三种方式，为了简化连接，都加上了<code>DOCKER_HOST</code>环境变量，但是<code>DOCKER_HOST</code>只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换<code>DOCKER_HOST</code>环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 <code>context</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TCP</span></span><br><span class=\"line\">docker context create remote-tcp \\</span><br><span class=\"line\">    --docker <span class=\"string\">&quot;host=tcp://166.189.9.114:2375&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># TCP + TLS</span></span><br><span class=\"line\">docker context create remote-tls \\</span><br><span class=\"line\">  --docker <span class=\"string\">&quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssh隧道</span></span><br><span class=\"line\">docker context create remote-ssh --docker <span class=\"string\">&quot;host=ssh://mydocker&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用</span></span><br><span class=\"line\">docker context <span class=\"built_in\">ls</span> <span class=\"comment\"># 列出所有context</span></span><br><span class=\"line\">docker context use remote-ssh <span class=\"comment\"># 切换到指定的context</span></span><br><span class=\"line\">docker ps <span class=\"comment\"># 查看容器</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker context</code> 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">本地 Docker（默认）</li>\n<li class=\"lvl-6\">远程主机的 Docker（通过 SSH 或 TCP/TLS）</li>\n<li class=\"lvl-6\">Docker Desktop</li>\n<li class=\"lvl-6\">Docker Swarm 或 Kubernetes（部分支持）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>就像你用 <code>kubectl config use-context</code> 切换 Kubernetes 集群，<code>docker context</code> 也允许你在多个 Docker 后端之间切换，而无需反复设置 <code>DOCKER_HOST</code> 环境变量或写繁琐的 SSH 隧道命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>常用命令一览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker context ls</code></td>\n<td>列出所有上下文</td>\n</tr>\n<tr>\n<td><code>docker context use &lt;name&gt;</code></td>\n<td>切换到指定 context</td>\n</tr>\n<tr>\n<td><code>docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td>\n<td>创建一个新的 context</td>\n</tr>\n<tr>\n<td><code>docker context rm &lt;name&gt;</code></td>\n<td>删除 context</td>\n</tr>\n<tr>\n<td><code>docker context inspect &lt;name&gt;</code></td>\n<td>查看 context 详情</td>\n</tr>\n<tr>\n<td><code>docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td>\n<td>更新 context 参数（Docker 24+ 支持）</td>\n</tr>\n<tr>\n<td><code>docker context show</code></td>\n<td>显示当前 context</td>\n</tr>\n<tr>\n<td><code>docker context export &lt;name&gt; &lt;file.tar&gt;</code></td>\n<td>导出 context 到tar文件</td>\n</tr>\n<tr>\n<td><code>docker context import &lt;name&gt; &lt;file.tar&gt;</code></td>\n<td>导入 context 从tar文件</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker endpoint config</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>from</code></td>\n<td>复制指定 context 名称 的 Docker 端点配置</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>要连接的 Docker 端点地址</td>\n</tr>\n<tr>\n<td><code>ca</code></td>\n<td>CA 签名的证书的路径</td>\n</tr>\n<tr>\n<td><code>cert</code></td>\n<td>TLS 证书文件的路径</td>\n</tr>\n<tr>\n<td><code>key</code></td>\n<td>TLS 密钥文件的路径</td>\n</tr>\n<tr>\n<td><code>skip-tls-verify</code></td>\n<td>跳过 TLS 证书验证（⚠️ 不建议用于生产环境）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三种远程连接-Docker-的方式及其优缺点总结\">三种远程连接 Docker 的方式及其优缺点总结</h2>\n<table>\n<thead>\n<tr>\n<th>连接方式</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1. SSH 方式 (<code>ssh://</code>)</strong></td>\n<td>- 配置简单，无需额外开启 Docker TCP 端口和 TLS<br>- 安全性高，基于 SSH 加密和认证<br>- 不用开放额外端口，防火墙友好<br>- 易于用 SSH 代理和密钥管理</td>\n<td>- 需要远程用户有 Docker 权限（如属于 <code>docker</code> 组）<br>- 连接速度可能受 SSH 连接影响<br>- 需要在本地安装并配置 SSH</td>\n<td>开发环境、内网管理、小规模远程操作</td>\n</tr>\n<tr>\n<td><strong>2. TCP + TLS 方式</strong></td>\n<td>- 标准的远程 Docker API 访问<br>- 支持证书认证，安全性高<br>- 可以配置多个客户端和权限控制<br>- 适合自动化脚本、CI/CD 访问</td>\n<td>- 配置较复杂，需要生成和管理 CA、服务器和客户端证书<br>- 需要开放 TCP 端口（如 2376），增加安全风险<br>- 证书配置错误容易导致连接失败</td>\n<td>生产环境、自动化集成、需要高安全认证</td>\n</tr>\n<tr>\n<td><strong>3. TCP 明文访问（无 TLS）</strong></td>\n<td>- 配置最简单，只需监听 TCP 端口<br>- 方便快速测试和调试</td>\n<td>- 极度不安全，数据明文传输<br>- 任何人都可访问 Docker API，极易被攻击<br>- 生产环境严重不建议使用</td>\n<td>仅限局域网内测试或极简环境</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍如何远程连接Docker Docker官方文档 远程连接Docker有如下三种方式 方式一：开启 TCP（不带 TLS，仅用于内网调试） 在docker服务端编辑 /etc/docker/daemon.json，加上： 123&#123; &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;]&#125; 此时通过sudo systemctl restart docker重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 -H fd://，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 -H fd:// 意思是：“不用自己打开 socket，去 systemd 那里拿吧。” 123456789101112# 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.servicesudo systemctl status docker# 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到 -H fd://ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock# 另外可以在与 docker.service 同目录下找到 docker.socket 文件，可以看到如下内容ListenStream=/run/docker.sock # /run 目录是被软连接到 /var/run/# 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock# 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了# 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 dockersudo dockerd --containerd=/run/containerd/containerd.sock# 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://` 禁用 -H fd://（systemd 与 daemon.json 冲突的根源） 12345678910111213# 方式一: 去掉 `-H fd://` 参数sudo vi /usr/lib/systemd/system/docker.service# 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数sudo mkdir -p /etc/systemd/system/docker.service.dsudo vi /etc/systemd/system/docker.service.d/override.conf# 填入[Service]ExecStart=ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock# 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，# 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。# Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。 重启 docker daemon 12sudo systemctl daemon-reloadsudo systemctl restart docker 在客户端测试连接 1docker -H tcp://远程IP:2375 ps 在客户端加入环境变量后就不需要每次都加上 -H 参数了 12345# zsh 就换成 ~/.zshrcecho &quot;export DOCKER_HOST=tcp://远程IP:2375&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc# 测试docker ps ❗不要开启无认证的 tcp://0.0.0.0:2375 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。 ✅ 推荐方式是： 使用 tcp://0.0.0.0:2376 + --tlsverify 或通过 ssh:// 隧道 访问 Docker 小贴士 通过上面的介绍你应该搞明白一件事，就是我们可以不用在 /etc/docker/daemon.json 中配置远程连接，而是通过 systemd 来配置，即在 /usr/lib/systemd/system/docker.service 或者 /etc/systemd/system/docker.service.d/override.conf中配置。 1ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock 那么问题来了：既然 systemd 就能搞定一切，那还要 /etc/docker/daemon.json 有什么用？答案是：可读性、可维护性、工具兼容性更强。 项目 daemon.json systemd ExecStart 语法 JSON Shell 命令行 适合设置 Hosts、日志、registry、镜像驱动等 启动命令、资源限制等 可读性 👍 结构化 👎 较长、容易出错 自动化支持 👍 工具友好 👎 需要 patch systemd 方式二：开启 TCP + TLS 安全访问（推荐用于公网） 创建 TLS 证书，通过一个脚本实现，脚本名称 generate-docker-certs.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bashset -eSERVER_IP=166.189.9.114 # 🚨 修改为你的 Docker 服务器 IP 或域名echo &quot;[+] 创建 CA...&quot;openssl genrsa -out ca-key.pem 4096openssl req -new -x509 -days 365 \\ -key ca-key.pem -subj &quot;/CN=docker-ca&quot; -out ca.pemecho &quot;[+] 创建服务器私钥...&quot;openssl genrsa -out server-key.pem 4096echo &quot;[+] 创建 OpenSSL 配置文件...&quot;cat &gt; extfile.cnf &lt;&lt;EOF[req]distinguished_name = req_distinguished_namex509_extensions = v3_reqprompt = no[req_distinguished_name]CN = $&#123;SERVER_IP&#125;[v3_req]keyUsage = keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]IP.1 = $&#123;SERVER_IP&#125;EOFecho &quot;[+] 创建服务器证书签名请求 (CSR)...&quot;openssl req -new -key server-key.pem \\ -out server.csr -config extfile.cnfecho &quot;[+] 签发服务器证书...&quot;openssl x509 -req -days 365 -in server.csr \\ -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\ -out server-cert.pem -extensions v3_req -extfile extfile.cnfecho &quot;[+] 创建客户端私钥...&quot;openssl genrsa -out key.pem 4096echo &quot;[+] 创建客户端 CSR...&quot;openssl req -new -key key.pem -subj &quot;/CN=client&quot; -out client.csrecho &quot;[+] 签发客户端证书...&quot;cat &gt; client-ext.cnf &lt;&lt;EOFextendedKeyUsage = clientAuthEOFopenssl x509 -req -days 365 -in client.csr \\ -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\ -out cert.pem -extfile client-ext.cnfecho &quot;[✓] 所有证书生成完成！&quot;echoecho &quot; 服务器证书: server-cert.pem, server-key.pem&quot;echo &quot; 客户端证书: cert.pem, key.pem&quot;echo &quot; CA根证书: ca.pem&quot; 执行脚本 12chmod +x generate-docker-certs.sh./generate-docker-certs.sh 将以下证书文件部署到docker服务端 1234# 服务端：server-cert.pem, server-key.pem, ca.pemcp server-cert.pem /etc/docker/server-cert.pemcp server-key.pem /etc/docker/server-key.pemcp ca.pem /etc/docker/ca.pem 将以下证书文件部署到docker客户端 1cert.pem, key.pem, ca.pem 在docker服务端编辑 /etc/docker/daemon.json 1234567&#123; &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2376&quot;], &quot;tlsverify&quot;: true, &quot;tlscacert&quot;: &quot;/etc/docker/ca.pem&quot;, &quot;tlscert&quot;: &quot;/etc/docker/server-cert.pem&quot;, &quot;tlskey&quot;: &quot;/etc/docker/server-key.pem&quot;&#125; 禁用 -H fd://（systemd 与 daemon.json 冲突的根源） 123456sudo mkdir -p /etc/systemd/system/docker.service.dsudo vi /etc/systemd/system/docker.service.d/override.conf# 填入[Service]ExecStart=ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock 重启 docker daemon 12sudo systemctl daemon-reloadsudo systemctl restart docker 在客户端测试连接 1234567docker \\ --tlsverify \\ --tlscacert=ca.pem \\ --tlscert=cert.pem \\ --tlskey=key.pem \\ -H tcp://166.189.9.114:2376 \\ ps 在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了 1234567891011cat &lt;&lt;EOT &gt;&gt; ~/.bashrc# 远程Docker IP和端口export DOCKER_HOST=tcp://166.189.9.114:2376# 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverifyexport DOCKER_TLS_VERIFY=1# 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pemexport DOCKER_CERT_PATH=/path/to/certsEOTsource ~/.bashrc# 测试docker ps 方式三：ssh:// 隧道访问 最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。 1ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 &quot;docker ps&quot; 基于免密认证，如何配置免密登录可以参考 Linux常用命令--ssh、scp与免密登录 123# docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22# 要求登录用户必须拥有docker的运行权限（加入 docker group）docker -H ssh://centos@166.189.9.114 ps 基于config配置(推荐) 这种方式的优点是可以配置证书和端口 在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group） 12345Host mydockerHostName 166.189.9.114User centosPort 22IdentityFile ~/.ssh/my_docker_key 测试 1docker -H ssh://mydocker ps 添加环境变量避免每次都加上 -H 参数 123456## 基于免密认证echo &quot;export DOCKER_HOST=ssh://user@host&quot; &gt;&gt; ~/.bashrc## 或者基于config的方式echo &quot;export DOCKER_HOST=ssh://mydocker&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcdocker ps docker context: 同时连接多个远程docker 上面介绍的三种方式，为了简化连接，都加上了DOCKER_HOST环境变量，但是DOCKER_HOST只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换DOCKER_HOST环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 context 123456789101112131415# TCPdocker context create remote-tcp \\ --docker &quot;host=tcp://166.189.9.114:2375&quot;# TCP + TLSdocker context create remote-tls \\ --docker &quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;# ssh隧道docker context create remote-ssh --docker &quot;host=ssh://mydocker&quot;# 使用docker context ls # 列出所有contextdocker context use remote-ssh # 切换到指定的contextdocker ps # 查看容器 docker context 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如： 本地 Docker（默认） 远程主机的 Docker（通过 SSH 或 TCP/TLS） Docker Desktop Docker Swarm 或 Kubernetes（部分支持） 就像你用 kubectl config use-context 切换 Kubernetes 集群，docker context 也允许你在多个 Docker 后端之间切换，而无需反复设置 DOCKER_HOST 环境变量或写繁琐的 SSH 隧道命令。 常用命令一览 命令 说明 docker context ls 列出所有上下文 docker context use &lt;name&gt; 切换到指定 context docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot; 创建一个新的 context docker context rm &lt;name&gt; 删除 context docker context inspect &lt;name&gt; 查看 context 详情 docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot; 更新 context 参数（Docker 24+ 支持） docker context show 显示当前 context docker context export &lt;name&gt; &lt;file.tar&gt; 导出 context 到tar文件 docker context import &lt;name&gt; &lt;file.tar&gt; 导入 context 从tar文件 Docker endpoint config 参数名 中文描述 from 复制指定 context 名称 的 Docker 端点配置 host 要连接的 Docker 端点地址 ca CA 签名的证书的路径 cert TLS 证书文件的路径 key TLS 密钥文件的路径 skip-tls-verify 跳过 TLS 证书验证（⚠️ 不建议用于生产环境） 三种远程连接 Docker 的方式及其优缺点总结 连接方式 优点 缺点 适用场景 1. SSH 方式 (ssh://) - 配置简单，无需额外开启 Docker TCP 端口和 TLS- 安全性高，基于 SSH 加密和认证- 不用开放额外端口，防火墙友好- 易于用 SSH 代理和密钥管理 - 需要远程用户有 Docker 权限（如属于 docker 组）- 连接速度可能受 SSH 连接影响- 需要在本地安装并配置 SSH 开发环境、内网管理、小规模远程操作 2. TCP + TLS 方式 - 标准的远程 Docker API 访问- 支持证书认证，安全性高- 可以配置多个客户端和权限控制- 适合自动化脚本、CI/CD 访问 - 配置较复杂，需要生成和管理 CA、服务器和客户端证书- 需要开放 TCP 端口（如 2376），增加安全风险- 证书配置错误容易导致连接失败 生产环境、自动化集成、需要高安全认证 3. TCP 明文访问（无 TLS） - 配置最简单，只需监听 TCP 端口- 方便快速测试和调试 - 极度不安全，数据明文传输- 任何人都可访问 Docker API，极易被攻击- 生产环境严重不建议使用 仅限局域网内测试或极简环境","summary":"摘要 本文介绍如何远程连接Docker Docker官方文档","date_published":"2025-06-05T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/04/docker-compose/","url":"https://blog.hanqunfeng.com/2025/06/04/docker-compose/","title":"Docker 命令 之 docker compose","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 <code>docker compose</code> 的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/compose/\">docker compose</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/\">Compose file reference</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"docker-compose-是什么？\"><code>docker compose</code> 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Compose是一个用于定义和运行多容器应用程序的工具。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Compose简化了对整个应用程序堆栈的控制，便于在单个YAML配置文件中管理服务、网络和卷。然后，通过一个命令，您从配置文件中创建并启动所有服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Compose 的优势：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简化控制</td>\n<td>Docker Compose 允许在单个 YAML 文件中定义和管理多容器应用程序，简化了服务编排与协调，使环境管理和复制更容易。</td>\n</tr>\n<tr>\n<td>高效的协作</td>\n<td>配置文件易于共享，促进开发人员、运营团队和其他利益相关者之间的协作，从而提升工作流程效率和问题解决速度。</td>\n</tr>\n<tr>\n<td>快速应用程序开发</td>\n<td>Compose 利用缓存重复使用未更改服务的容器，加快环境变更速度，提高开发效率。</td>\n</tr>\n<tr>\n<td>跨环境的可移植性</td>\n<td>支持在 Compose 文件中使用变量，使配置能根据不同环境或用户进行自定义，增强了可移植性。</td>\n</tr>\n<tr>\n<td>广泛的社区和支持</td>\n<td>拥有活跃的社区，提供丰富的资源、教程和技术支持，有助于持续改进与高效排障。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-compose-安装\"><code>docker compose</code> 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同docker一起安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装docker同时安装docker compose，这里 docker-compose-plugin 就是docker compose</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单独安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 若安装docker时没有安装 docker-compose-plugin ，则需要单独安装</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-compose-plugin -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker compose version</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>直接下载docker-compose的命令文件</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> curl -L <span class=\"string\">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class=\"subst\">$(uname -s)</span>-<span class=\"subst\">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"comment\"># Make the docker-compose command available</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"comment\"># Check Docker Compose version</span></span><br><span class=\"line\">docker-compose version</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"docker-compose-命令\"><code>docker compose</code> 命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>attach</td>\n<td>连接到服务的运行中容器的标准输入、输出和错误流</td>\n<td><code>docker compose attach web</code></td>\n</tr>\n<tr>\n<td>build</td>\n<td>构建或重新构建服务</td>\n<td><code>docker compose build</code></td>\n</tr>\n<tr>\n<td>config</td>\n<td>解析并标准化 Compose 文件</td>\n<td><code>docker compose config</code></td>\n</tr>\n<tr>\n<td>cp</td>\n<td>在服务容器与本地文件系统之间复制文件/文件夹</td>\n<td><code>docker compose cp web:/app/file.txt ./file.txt</code></td>\n</tr>\n<tr>\n<td>create</td>\n<td>为服务创建容器，但不启动</td>\n<td><code>docker compose create</code></td>\n</tr>\n<tr>\n<td>down</td>\n<td>停止并移除容器、网络等资源</td>\n<td><code>docker compose down</code></td>\n</tr>\n<tr>\n<td>events</td>\n<td>实时接收容器事件</td>\n<td><code>docker compose events</code></td>\n</tr>\n<tr>\n<td>exec</td>\n<td>在运行中的容器中执行命令</td>\n<td><code>docker compose exec web ls /app</code></td>\n</tr>\n<tr>\n<td>images</td>\n<td>列出已创建容器所使用的镜像</td>\n<td><code>docker compose images</code></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>强制停止服务容器</td>\n<td><code>docker compose kill</code></td>\n</tr>\n<tr>\n<td>logs</td>\n<td>查看服务容器的日志输出</td>\n<td><code>docker compose logs</code></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出当前运行的 Compose 项目</td>\n<td><code>docker compose ls</code></td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停服务容器</td>\n<td><code>docker compose pause</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td>显示某端口映射的公网地址</td>\n<td><code>docker compose port web 80</code></td>\n</tr>\n<tr>\n<td>ps</td>\n<td>列出服务的容器</td>\n<td><code>docker compose ps</code></td>\n</tr>\n<tr>\n<td>pull</td>\n<td>拉取服务使用的镜像</td>\n<td><code>docker compose pull</code></td>\n</tr>\n<tr>\n<td>push</td>\n<td>推送服务镜像到仓库</td>\n<td><code>docker compose push</code></td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重启服务容器</td>\n<td><code>docker compose restart</code></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>移除已停止的服务容器</td>\n<td><code>docker compose rm</code></td>\n</tr>\n<tr>\n<td>run</td>\n<td>在服务上运行一次性命令</td>\n<td><code>docker compose run web echo Hello</code></td>\n</tr>\n<tr>\n<td>scale</td>\n<td>扩展服务实例数量</td>\n<td><code>docker compose up --scale web=3</code></td>\n</tr>\n<tr>\n<td>start</td>\n<td>启动已存在但已停止的服务容器</td>\n<td><code>docker compose start</code></td>\n</tr>\n<tr>\n<td>stats</td>\n<td>实时显示容器资源使用情况</td>\n<td><code>docker compose stats</code></td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止运行中的服务容器</td>\n<td><code>docker compose stop</code></td>\n</tr>\n<tr>\n<td>top</td>\n<td>显示容器内的运行进程</td>\n<td><code>docker compose top</code></td>\n</tr>\n<tr>\n<td>unpause</td>\n<td>取消暂停服务容器</td>\n<td><code>docker compose unpause</code></td>\n</tr>\n<tr>\n<td>up</td>\n<td>创建并启动服务容器</td>\n<td><code>docker compose up</code></td>\n</tr>\n<tr>\n<td>version</td>\n<td>显示 Docker Compose 版本信息</td>\n<td><code>docker compose version</code></td>\n</tr>\n<tr>\n<td>wait</td>\n<td>阻塞直到第一个服务容器停止</td>\n<td><code>docker compose wait</code></td>\n</tr>\n<tr>\n<td>watch</td>\n<td>监听服务构建上下文变更并重新构建/刷新容器</td>\n<td><code>docker compose watch</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-compose-常用命令\"><code>docker compose</code> 常用命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动与关闭</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动并运行，默认使用当前目录的 docker-compose.yml 文件</span></span><br><span class=\"line\">docker compose up</span><br><span class=\"line\"><span class=\"comment\"># 后台运行</span></span><br><span class=\"line\">docker compose up -d</span><br><span class=\"line\"><span class=\"comment\"># 指定compose文件</span></span><br><span class=\"line\">docker compose -f docker-compose.yml up -d</span><br><span class=\"line\"><span class=\"comment\"># 启动时重建服务，当修改了 compose 文件时</span></span><br><span class=\"line\">docker compose up --build</span><br><span class=\"line\"><span class=\"comment\"># 停止service</span></span><br><span class=\"line\">docker compose stop</span><br><span class=\"line\"><span class=\"comment\"># 强制停止service，当 stop 命令无法停止时</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">kill</span></span><br><span class=\"line\"><span class=\"comment\"># 重启service</span></span><br><span class=\"line\">docker compose restart</span><br><span class=\"line\"><span class=\"comment\"># 删除service，-s 参数表示删除前先停止容器</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">rm</span> -s</span><br><span class=\"line\"><span class=\"comment\"># 停止并删除service，同时删除网络，但不会删除卷</span></span><br><span class=\"line\">docker compose down</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>监控</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前运行的 Compose 项目</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看service状态，-a 显示所有service</span></span><br><span class=\"line\">docker compose ps -a</span><br><span class=\"line\"><span class=\"comment\"># 解析并标准化 compose 文件，这个命令可以检查 docker-compose.yml 文件语法是否正确</span></span><br><span class=\"line\">docker compose config</span><br><span class=\"line\"><span class=\"comment\"># 查看使用的镜像</span></span><br><span class=\"line\">docker compose images</span><br><span class=\"line\"><span class=\"comment\"># 查看进程</span></span><br><span class=\"line\">docker compose top</span><br><span class=\"line\"><span class=\"comment\"># 查看service资源使用情况</span></span><br><span class=\"line\">docker compose stats</span><br><span class=\"line\"><span class=\"comment\"># 查看service日志，-f 表示持续跟踪</span></span><br><span class=\"line\">docker compose logs -f</span><br><span class=\"line\"><span class=\"comment\"># 查看指定service的日志</span></span><br><span class=\"line\">docker compose logs -f service_name</span><br><span class=\"line\"><span class=\"comment\"># 进入指定的service容器</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">exec</span> service_name bash</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>升级镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先停止所有service</span></span><br><span class=\"line\">docker compose down</span><br><span class=\"line\"><span class=\"comment\"># 拉取最新镜像</span></span><br><span class=\"line\">docker compose pull</span><br><span class=\"line\"><span class=\"comment\"># 启动service</span></span><br><span class=\"line\">docker compose up -d --build</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-compose-yml-的语法\"><code>docker-compose.yml</code> 的语法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用指令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: <span class=\"string\">&quot;3.8&quot;</span> <span class=\"comment\"># 定义版本，表示当前使用的 docker compose 语法的版本，已过时 ，新版 Docker 会使用最新的 Compose Specification 自动解析</span></span><br><span class=\"line\">name: <span class=\"string\">&quot;project_name&quot;</span> <span class=\"comment\">#  项目名，默认 docker-compose.yml 文件所在的目录名，不推荐设置</span></span><br><span class=\"line\">services: <span class=\"comment\"># 服务列表</span></span><br><span class=\"line\">  servicename: <span class=\"comment\"># 服务名字，只能包含小写字母、数字、下划线、中划线，必须以字母或数字开头</span></span><br><span class=\"line\">    build: <span class=\"comment\"># 基于Dockerfile构建目录，如果同时设置了 image 选项，则image指定的就是构建后的镜像名称</span></span><br><span class=\"line\">    image: <span class=\"comment\"># 镜像的名字，默认从远程仓库拉取，如果配置了 build 选项，则image指定的就是构建后的镜像名称</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span>: <span class=\"comment\"># 可选，如果设置，则会覆盖默认镜像里的 CMD 命令</span></span><br><span class=\"line\">    environment: <span class=\"comment\"># 可选，等价于 docker container run 里的 --env 选项设置环境变量</span></span><br><span class=\"line\">    volumes: <span class=\"comment\"># 可选，等价于 docker container run 里的 -v 选项 绑定数据卷</span></span><br><span class=\"line\">    networks: <span class=\"comment\"># 可选，等价于 docker container run 里的 --network 选项指定网络</span></span><br><span class=\"line\">    ports: <span class=\"comment\"># 可选，等价于 docker container run 里的 -p 选项指定端口映射</span></span><br><span class=\"line\">    expose: <span class=\"comment\"># 可选，指定容器暴露的端口</span></span><br><span class=\"line\">    depends_on: <span class=\"comment\"># 服务依赖的其它服务</span></span><br><span class=\"line\">    env_file: <span class=\"comment\"># 环境变量文件，生产环境更推荐这种方式</span></span><br><span class=\"line\">  servicename2:</span><br><span class=\"line\">    image:</span><br><span class=\"line\">    <span class=\"built_in\">command</span>:</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">  servicename3:</span><br><span class=\"line\">    <span class=\"comment\">#...</span></span><br><span class=\"line\"></span><br><span class=\"line\">volumes: <span class=\"comment\"># 可选，等价于 docker volume create</span></span><br><span class=\"line\">networks: <span class=\"comment\"># 可选，等价于 docker network create</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"volumes\">volumes</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>卷是由容器引擎实现的持久数据存储。Compose 为服务提供了一种中立的挂载卷的方式，并通过配置参数将卷分配给基础架构。顶级volumes声明允许您配置可在多个服务之间重复使用的命名卷。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/database</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 挂载卷映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/etc/data</span> <span class=\"comment\"># 挂载到容器的/etc/data目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">backup:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">backup-service</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/backup/data</span> <span class=\"comment\"># 一个卷可以被多个服务使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 存储卷配置</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span>  <span class=\"comment\"># 创建一个名为db-data的卷，实际的网络名称是 容器组名称_这里的名称</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"volumes-的属性\">volumes 的属性</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver: 卷类型，默认为local，指定应使用哪个卷驱动程序。如果该驱动程序不可用，Compose 将返回错误并且不会部署该应用程序。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span> <span class=\"comment\"># 声明一个名为db-data的卷</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span> <span class=\"comment\"># 指定卷类型，这个是默认值，可以不配置</span></span><br><span class=\"line\">  <span class=\"attr\">db-data2:</span> <span class=\"comment\"># 声明一个名为db-data2的卷，这是最简单的 volumes 配置</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver_opts: 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span> <span class=\"comment\"># 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">&quot;nfs&quot;</span> <span class=\"comment\"># 卷类型，指定应使用哪个卷驱动程序，这里是nfs</span></span><br><span class=\"line\">      <span class=\"attr\">o:</span> <span class=\"string\">&quot;addr=10.40.0.199,nolock,soft,rw&quot;</span> <span class=\"comment\"># nfs参数，addr为nfs服务器地址，nolock为不锁定文件，soft为软链接，rw为读写权限</span></span><br><span class=\"line\">      <span class=\"attr\">device:</span> <span class=\"string\">&quot;:/docker/example&quot;</span> <span class=\"comment\"># nfs挂载路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>external: 卷是否为外部卷，默认为false</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># true 表示不会创建，而是使用已存在的，即会去volumes中查找(docker volume ls) 容器组名称_da-data ，默认为false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>name: 卷的名称，默认为 容器组名称_声明的名称</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">db-data</span> <span class=\"comment\"># 创建一个名为db-data的卷，实际的卷名称就是 db-data，不会再加上容器组名称前缀</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>labels: 用于向卷添加元数据，可以添加任意的键值对</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Database volume&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;IT/Ops&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"networks\">networks</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>网络使服务能够相互通信。默认情况下，Compose 会为您的应用设置单个网络。服务的每个容器都会加入默认网络，并且该网络上的其他容器都可以访问，并且可以通过服务名称发现。顶级networks元素允许您配置可在多个服务之间重复使用的命名网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span>  <span class=\"comment\">#  网络映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">front-tier</span> <span class=\"comment\">#  加入front-tier网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">back-tier</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span>    <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">  <span class=\"attr\">front-tier:</span> <span class=\"comment\"># 创建一个名为front-tier的网络，实际的网络名称是 容器组名称_front-tier</span></span><br><span class=\"line\">  <span class=\"attr\">back-tier:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 Compose 文件未显式声明网络，Compose 将使用隐式default网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这个例子实际上等同于：</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"attr\">default:</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">default:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"networks-的属性\">networks 的属性</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver: 网络类型，默认为bridge</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver_opts: 网络类型参数，指定要传递给此网络驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span></span><br><span class=\"line\">      <span class=\"attr\">com.docker.network.bridge.host_binding_ipv4:</span> <span class=\"string\">&quot;127.0.0.1&quot;</span> <span class=\"comment\"># 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地）</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>driver_opts 常见配置项（针对 bridge 网络驱动）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项键名（<code>driver_opts</code>）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>com.docker.network.bridge.name</code></td>\n<td>指定桥接网络的名称（默认是随机生成，如 <code>br-xxxxx</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.enable_icc</code></td>\n<td>是否允许容器之间的通信（<code>true</code> 或 <code>false</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.enable_ip_masquerade</code></td>\n<td>是否启用 IP 假冒（NAT，通常用于外网访问）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.host_binding_ipv4</code></td>\n<td>设置容器端口绑定到主机的哪个 IP（如 <code>&quot;127.0.0.1&quot;</code>，绑定到本地）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.default_bridge</code></td>\n<td>是否将该网络设置为默认 bridge 网络（<code>true</code> 或 <code>false</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.driver.mtu</code></td>\n<td>设置网络的最大传输单元（MTU，例如 <code>&quot;1500&quot;</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.allow_non_default_bridge</code></td>\n<td>是否允许容器加入非默认的 bridge 网络（较少使用）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>attachable: 如果为true，则允许将其它独立容器也加入到此网络。默认值为false。如果独立容器连接到此网络，它可以与同样连接到此网络的服务和其他独立容器进行通信。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">attachable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>external: true 表示不会创建新的网络，回去networks中查找（docker network ls），默认为false</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>name: 网络名称，不会再加上容器组名称前缀</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">gitea</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>labels: 用于向网络添加元数据，可以添加任意的键值对</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">mynet1:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Financial transaction network&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;Finance&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>internal: 默认情况下，Compose 提供网络的外部连接。internal当设置为 时true，可让您创建与外部隔离的网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">internal:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"services\">services</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展或替换。服务由一组容器支持，由平台根据复制要求和布局约束运行。由于服务由容器支持，因此它们由 Docker 镜像和一组运行时参数定义。服务中的所有容器都使用这些参数以相同的方式创建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>service 包含的属性非常多，具体请参考<a href=\"https://docs.docker.com/reference/compose-file/services/\">services顶级元素</a>，这里只介绍比较常用的属性，以<code>gitea</code>的<code>docker-compose.yml</code>为例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version: &#x27;3.8&#x27; # 配置文件版本，已过时，配置上会告警但不会报错</span></span><br><span class=\"line\"><span class=\"comment\"># name: gitea # 容器组名称，默认使用所在目录的名称，不推荐使用</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span> <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span> <span class=\"comment\"># 创建一个名为gitea的网络，实际的网络名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 如果为true，则表示此网络不会由compose创建，而是使用已有的网络，默认为false</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>  <span class=\"comment\"># 网络类型，默认为bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 存储卷配置</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span> <span class=\"comment\"># 创建一个名为gitea的存储卷，实际的卷名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span> <span class=\"comment\"># 存储卷类型，默认为local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span> <span class=\"comment\"># 服务配置，这里可以定义一组容器</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span> <span class=\"comment\"># 定义一个名为server的服务，注意这个不是容器名称</span></span><br><span class=\"line\">    <span class=\"comment\"># build: . # 构建镜像，使用当前目录下的Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">gitea/gitea:latest</span> <span class=\"comment\"># 镜像名称</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: gitea #  容器名称，默认为 “容器组名称-服务名称-索引”，不推荐配置，因为 水平扩展(--scale) 时,容器名称不能重复</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span> <span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_UID=1000</span> <span class=\"comment\"># key=value</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_GID=1000</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_TYPE=mysql</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db:3306</span> <span class=\"comment\"># 这里配置的 db 就是 下面的服务名称，相同 network 下的服务名称，docker compose会自动解析为容器的ip地址</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_NAME=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PASSWD=gitea</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file: .gitea.env # 从 .gitea.env 文件读取环境变量，生产环境更推荐</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 容器启动时，自动重启</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 网络关联</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span> <span class=\"comment\"># 网络名称，就是上面创建的gitea网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\">#  数据卷关联</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea:/data</span> <span class=\"comment\"># volume映射，数据卷名称:/容器路径</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/timezone:/etc/timezone:ro</span> <span class=\"comment\"># 路径映射，宿主机路径:/容器路径:读写权限</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/localtime:/etc/localtime:ro</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span> <span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span> <span class=\"comment\"># 宿主机端口:容器端口</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span> <span class=\"comment\"># 启动依赖，就是依赖的服务启动后才能启动本服务</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span> <span class=\"comment\"># 启动db服务</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 服务通过健康检查，也可以配置为 service_started：服务启动，这个是默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8</span> <span class=\"comment\"># 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span> <span class=\"comment\"># 环境变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=gitea</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 启动策略</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 网络映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span> <span class=\"comment\"># 映射到gitea网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 卷映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./mysql:/var/lib/mysql</span> <span class=\"comment\"># 宿主机路径:/容器路径，这里宿主机支持相对路径</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD-SHELL&quot;</span>, <span class=\"string\">&quot;mysql -u root -pgitea&quot;</span>, <span class=\"string\">&quot;-e &#x27;SELECT 1;&#x27;&quot;</span>] <span class=\"comment\"># 执行命令，如果返回0，则健康检查通过，这里不支持上面的环境变量，test只支持  CMD-SHELL 和 CMD</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 健康检查间隔</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 健康检查超时时间</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span> <span class=\"comment\"># 健康检查重试次数</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>build</code>: 构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span> <span class=\"comment\"># Dockerfile的目录，“.” 表示使用当前目录下的Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span> <span class=\"comment\"># 镜像名称，如果有build，则该名称就是build后的镜像名称，如果没有build，则就会从远程仓库拉取</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./webapp</span> <span class=\"comment\"># Dockerfile的目录，默认是当前目录</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 构建镜像的Dockerfile名称，默认是Dockerfile</span></span><br><span class=\"line\">      <span class=\"attr\">platforms:</span> <span class=\"comment\"># 构建镜像的架构</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">linux/amd64</span> <span class=\"comment\"># 构建镜像的架构，默认是当前架构</span></span><br><span class=\"line\">      <span class=\"attr\">args:</span> <span class=\"comment\"># 构建镜像的参数</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">FOO=bar</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span> <span class=\"comment\"># 构建镜像的标签</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Accounting webapp&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;Finance&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>command</code>: 覆盖容器映像声明的默认命令</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>entrypoint</code>: 声明服务容器的默认入口点，这覆盖了服务Dockerfile中的ENTRYPOINT指令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">entrypoint:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">php</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-d</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-d</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">memory_limit=-1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vendor/bin/phpunit</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果值为null，则使用图像的默认入口点。 entrypoint: null</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果值是 []（空列表）或 &#x27;&#x27;（空字符串），图像声明的默认入口点被忽略，或者换句话说，被覆盖为空。 entrypoint: []</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>depends_on</code>: 服务启动依赖，就是依赖的服务启动后才能启动本服务</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span> <span class=\"comment\"># 短语法</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span>  <span class=\"comment\"># 长语法</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 满足的条件</span></span><br><span class=\"line\">        <span class=\"attr\">restart:</span> <span class=\"literal\">true</span>      <span class=\"comment\"># 当设置为true，Compose在更新依赖服务后重新启动此服务。</span></span><br><span class=\"line\">      <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_started</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## condition：设置依赖性被视为满足的条件</span></span><br><span class=\"line\"><span class=\"comment\">#   service_started：相当于之前描述的简短语法</span></span><br><span class=\"line\"><span class=\"comment\">#   service_healthy：指定在启动依赖服务之前，依赖预期为“健康”（如healthcheck所示）。</span></span><br><span class=\"line\"><span class=\"comment\">#   service_completed_successfully：指定在启动依赖服务之前，依赖项预计将运行到成功完成。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>environment</code>: 定义环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">FOO=bar</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">BAZ=qux</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">FOO:</span> <span class=\"string\">bar</span></span><br><span class=\"line\">      <span class=\"attr\">BAZ:</span> <span class=\"string\">qux</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>env_file</code>: 用于指定一个或多个包含要传递到容器的环境变量的文件。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./a.env</span> <span class=\"comment\"># 列表中的文件是从上到下处理的。对于两个环境文件中指定的相同变量，列表中最后一个文件的值是有效的。</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./b.env</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">./default.env</span></span><br><span class=\"line\">        <span class=\"attr\">required:</span> <span class=\"literal\">true</span> <span class=\"comment\"># default</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">./override.env</span></span><br><span class=\"line\">        <span class=\"attr\">required:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 当required设置为false且.env文件缺失时，Compose会忽略</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>restart</code>: 定义平台在容器终止时适用的策略</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">&quot;no&quot;</span>            <span class=\"comment\"># 默认重启策略。在任何情况下，它都不会重新启动容器。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: always        # 策略总是重新启动容器，直到它被移除。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure    # 如果退出代码表明错误，策略将重新启动容器。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure:3  # 如果退出代码表明错误，策略将重新启动容器。但仅尝试重启3次。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: unless-stopped # 无论退出代码如何，策略都会重新启动容器，但当服务停止或删除时，策略会停止重新启动。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>healthcheck</code>: 健康检查。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span>  <span class=\"comment\"># 健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost&quot;</span>] <span class=\"comment\"># 监控检查时执行的命令</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">1m30s</span> <span class=\"comment\"># 健康检查的间隔，默认值为 30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span>    <span class=\"comment\">#  健康检查的超时时间，默认值为 30s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>      <span class=\"comment\"># 健康检查的尝试次数，默认值为 3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">40s</span> <span class=\"comment\"># 启动宽限期：在此期间，失败不会计入重试次数（仅用于判断服务是否启动完毕）</span></span><br><span class=\"line\">      <span class=\"attr\">start_interval:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 启动宽限期内检查的频率，本示例为在前 40 秒内每 5 秒检查一次</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>test定义Compose运行的命令来检查容器运行状况。它可以是字符串，也可以是列表。如果是列表，第一个项目必须是NONE、CMD或CMD-SHELL。如果它是一个字符串，它等同于指定CMD-SHELL后跟该字符串。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 使用CMD-SHELL运行配置为字符串的命令，使用容器的默认外壳（Linux的/bin/sh）。以下两种形式是等价的</span></span><br><span class=\"line\"><span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD-SHELL&quot;</span>, <span class=\"string\">&quot;curl -f http://localhost || exit 1&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">test:</span> <span class=\"string\">curl</span> <span class=\"string\">-f</span> <span class=\"string\">https://localhost</span> <span class=\"string\">||</span> <span class=\"string\">exit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>test 中的 CMD 和 CMD-SHELL 是两种不同的执行方式，它们的主要区别在于：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>CMD</code></th>\n<th><code>CMD-SHELL</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ <strong>用途</strong></td>\n<td>直接执行命令（不通过 shell）</td>\n<td>通过 shell（如 <code>/bin/sh -c</code>）执行命令</td>\n</tr>\n<tr>\n<td>🧾 <strong>写法格式</strong></td>\n<td><code>[&quot;CMD&quot;, &quot;executable&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</code></td>\n<td><code>[&quot;CMD-SHELL&quot;, &quot;command string&quot;]</code></td>\n</tr>\n<tr>\n<td>🔧 <strong>是否使用 shell</strong></td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>🧠 <strong>是否支持 shell 语法</strong></td>\n<td>❌ 否<br>（不能使用 <code>&amp;&amp;</code>、 <code>||</code>、<code>\\$VAR</code> 等）</td>\n<td>✅ 是<br>（支持管道、重定向、变量、命令组合）</td>\n</tr>\n<tr>\n<td>🛡️ <strong>安全性/可移植性</strong></td>\n<td>✅ 更安全，执行更明确</td>\n<td>⚠ 依赖容器中存在 shell（如 <code>/bin/sh</code>）</td>\n</tr>\n<tr>\n<td>⚙️ <strong>执行效率</strong></td>\n<td>✅ 稍快，因无需 shell 解析</td>\n<td>⚠ 稍慢，需通过 shell 启动</td>\n</tr>\n<tr>\n<td>📦 <strong>推荐使用场景</strong></td>\n<td>- 简单健康检查命令<br>- 安全环境<br>- 精简镜像</td>\n<td>- 需要使用逻辑控制（<code>||</code>, <code>&amp;&amp;</code>）<br>- 复杂检查逻辑</td>\n</tr>\n<tr>\n<td>📌 <strong>示例</strong></td>\n<td><code>[&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</code></td>\n<td><code>[&quot;CMD-SHELL&quot;, &quot;curl -f http\\://localhost || exit 1&quot;]</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>volumes</code>: 挂载数据卷。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 长语法格式</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/backend</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">volume</span>   <span class=\"comment\"># 安装类型。可以是是volume、bind、tmpfs、image、npipe、cluster</span></span><br><span class=\"line\">        <span class=\"attr\">source:</span> <span class=\"string\">db-data</span> <span class=\"comment\"># 挂载的源、绑定挂载的主机上的路径、映像挂载的Docker映像引用或顶层volumes键中定义的卷名称。不适用于tmpfs支架。</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/data</span> <span class=\"comment\"># 容器中装载卷的路径。</span></span><br><span class=\"line\">        <span class=\"attr\">volume:</span>  <span class=\"comment\"># 配置其他卷选项</span></span><br><span class=\"line\">          <span class=\"attr\">nocopy:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 在创建卷时禁用从容器复制数据的标志，默认值为false。</span></span><br><span class=\"line\">          <span class=\"attr\">subpath:</span> <span class=\"string\">sub</span> <span class=\"comment\"># 挂载卷的子目录。即 db-data/sub</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">bind</span> <span class=\"comment\"># bind 表示挂载主机上的路径</span></span><br><span class=\"line\">        <span class=\"attr\">source:</span> <span class=\"string\">/var/run/postgres/postgres.sock</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/var/run/postgres/postgres.sock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 声明数据卷</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">######################################################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 短语法格式</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/backend</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/data</span> <span class=\"comment\"># 这种语法不支持 subpath 和 nocopy</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>networks</code>: 配置网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span>  <span class=\"comment\"># 配置网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">some-network</span> <span class=\"comment\"># 关联网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">other-network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span> <span class=\"comment\"># 声明网络</span></span><br><span class=\"line\">  <span class=\"attr\">some-network:</span></span><br><span class=\"line\">  <span class=\"attr\">other-network:</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 docker compose 的使用方法 Docker官方文档 docker compose Compose file reference docker compose 是什么？ Docker Compose是一个用于定义和运行多容器应用程序的工具。 Compose简化了对整个应用程序堆栈的控制，便于在单个YAML配置文件中管理服务、网络和卷。然后，通过一个命令，您从配置文件中创建并启动所有服务。 Docker Compose 的优势： 优点 描述 简化控制 Docker Compose 允许在单个 YAML 文件中定义和管理多容器应用程序，简化了服务编排与协调，使环境管理和复制更容易。 高效的协作 配置文件易于共享，促进开发人员、运营团队和其他利益相关者之间的协作，从而提升工作流程效率和问题解决速度。 快速应用程序开发 Compose 利用缓存重复使用未更改服务的容器，加快环境变更速度，提高开发效率。 跨环境的可移植性 支持在 Compose 文件中使用变量，使配置能根据不同环境或用户进行自定义，增强了可移植性。 广泛的社区和支持 拥有活跃的社区，提供丰富的资源、教程和技术支持，有助于持续改进与高效排障。 docker compose 安装 同docker一起安装 12# 安装docker同时安装docker compose，这里 docker-compose-plugin 就是docker composesudo dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y 单独安装 12# 若安装docker时没有安装 docker-compose-plugin ，则需要单独安装sudo dnf install docker-compose-plugin -y 查看版本 1docker compose version 直接下载docker-compose的命令文件 123456# Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# Make the docker-compose command availablesudo chmod +x /usr/local/bin/docker-compose# Check Docker Compose versiondocker-compose version docker compose 命令 命令 中文说明 示例 attach 连接到服务的运行中容器的标准输入、输出和错误流 docker compose attach web build 构建或重新构建服务 docker compose build config 解析并标准化 Compose 文件 docker compose config cp 在服务容器与本地文件系统之间复制文件/文件夹 docker compose cp web:/app/file.txt ./file.txt create 为服务创建容器，但不启动 docker compose create down 停止并移除容器、网络等资源 docker compose down events 实时接收容器事件 docker compose events exec 在运行中的容器中执行命令 docker compose exec web ls /app images 列出已创建容器所使用的镜像 docker compose images kill 强制停止服务容器 docker compose kill logs 查看服务容器的日志输出 docker compose logs ls 列出当前运行的 Compose 项目 docker compose ls pause 暂停服务容器 docker compose pause port 显示某端口映射的公网地址 docker compose port web 80 ps 列出服务的容器 docker compose ps pull 拉取服务使用的镜像 docker compose pull push 推送服务镜像到仓库 docker compose push restart 重启服务容器 docker compose restart rm 移除已停止的服务容器 docker compose rm run 在服务上运行一次性命令 docker compose run web echo Hello scale 扩展服务实例数量 docker compose up --scale web=3 start 启动已存在但已停止的服务容器 docker compose start stats 实时显示容器资源使用情况 docker compose stats stop 停止运行中的服务容器 docker compose stop top 显示容器内的运行进程 docker compose top unpause 取消暂停服务容器 docker compose unpause up 创建并启动服务容器 docker compose up version 显示 Docker Compose 版本信息 docker compose version wait 阻塞直到第一个服务容器停止 docker compose wait watch 监听服务构建上下文变更并重新构建/刷新容器 docker compose watch docker compose 常用命令 启动与关闭 123456789101112131415161718# 启动并运行，默认使用当前目录的 docker-compose.yml 文件docker compose up# 后台运行docker compose up -d# 指定compose文件docker compose -f docker-compose.yml up -d# 启动时重建服务，当修改了 compose 文件时docker compose up --build# 停止servicedocker compose stop# 强制停止service，当 stop 命令无法停止时docker compose kill# 重启servicedocker compose restart# 删除service，-s 参数表示删除前先停止容器docker compose rm -s# 停止并删除service，同时删除网络，但不会删除卷docker compose down 监控 123456789101112131415161718# 列出当前运行的 Compose 项目docker compose ls# 查看service状态，-a 显示所有servicedocker compose ps -a# 解析并标准化 compose 文件，这个命令可以检查 docker-compose.yml 文件语法是否正确docker compose config# 查看使用的镜像docker compose images# 查看进程docker compose top# 查看service资源使用情况docker compose stats# 查看service日志，-f 表示持续跟踪docker compose logs -f# 查看指定service的日志docker compose logs -f service_name# 进入指定的service容器docker compose exec service_name bash 升级镜像 123456# 先停止所有servicedocker compose down# 拉取最新镜像docker compose pull# 启动servicedocker compose up -d --build docker-compose.yml 的语法 常用指令 123456789101112131415161718192021222324version: &quot;3.8&quot; # 定义版本，表示当前使用的 docker compose 语法的版本，已过时 ，新版 Docker 会使用最新的 Compose Specification 自动解析name: &quot;project_name&quot; # 项目名，默认 docker-compose.yml 文件所在的目录名，不推荐设置services: # 服务列表 servicename: # 服务名字，只能包含小写字母、数字、下划线、中划线，必须以字母或数字开头 build: # 基于Dockerfile构建目录，如果同时设置了 image 选项，则image指定的就是构建后的镜像名称 image: # 镜像的名字，默认从远程仓库拉取，如果配置了 build 选项，则image指定的就是构建后的镜像名称 command: # 可选，如果设置，则会覆盖默认镜像里的 CMD 命令 environment: # 可选，等价于 docker container run 里的 --env 选项设置环境变量 volumes: # 可选，等价于 docker container run 里的 -v 选项 绑定数据卷 networks: # 可选，等价于 docker container run 里的 --network 选项指定网络 ports: # 可选，等价于 docker container run 里的 -p 选项指定端口映射 expose: # 可选，指定容器暴露的端口 depends_on: # 服务依赖的其它服务 env_file: # 环境变量文件，生产环境更推荐这种方式 servicename2: image: command: networks: ports: servicename3: #...volumes: # 可选，等价于 docker volume createnetworks: # 可选，等价于 docker network create volumes 卷是由容器引擎实现的持久数据存储。Compose 为服务提供了一种中立的挂载卷的方式，并通过配置参数将卷分配给基础架构。顶级volumes声明允许您配置可在多个服务之间重复使用的命名卷。 12345678910111213services: backend: image: example/database volumes: # 挂载卷映射 - db-data:/etc/data # 挂载到容器的/etc/data目录 backup: image: backup-service volumes: - db-data:/var/lib/backup/data # 一个卷可以被多个服务使用volumes: # 存储卷配置 db-data: # 创建一个名为db-data的卷，实际的网络名称是 容器组名称_这里的名称 volumes 的属性 driver: 卷类型，默认为local，指定应使用哪个卷驱动程序。如果该驱动程序不可用，Compose 将返回错误并且不会部署该应用程序。 1234volumes: db-data: # 声明一个名为db-data的卷 driver: local # 指定卷类型，这个是默认值，可以不配置 db-data2: # 声明一个名为db-data2的卷，这是最简单的 volumes 配置 driver_opts: 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。 123456volumes: db-data: driver_opts: # 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式） type: &quot;nfs&quot; # 卷类型，指定应使用哪个卷驱动程序，这里是nfs o: &quot;addr=10.40.0.199,nolock,soft,rw&quot; # nfs参数，addr为nfs服务器地址，nolock为不锁定文件，soft为软链接，rw为读写权限 device: &quot;:/docker/example&quot; # nfs挂载路径 external: 卷是否为外部卷，默认为false 123volumes: db-data: external: true # true 表示不会创建，而是使用已存在的，即会去volumes中查找(docker volume ls) 容器组名称_da-data ，默认为false name: 卷的名称，默认为 容器组名称_声明的名称 1234volumes: db-data: name: db-data # 创建一个名为db-data的卷，实际的卷名称就是 db-data，不会再加上容器组名称前缀 external: true # name 属性经常与 external: true 一起使用 labels: 用于向卷添加元数据，可以添加任意的键值对 123456volumes: db-data: labels: com.example.description: &quot;Database volume&quot; com.example.department: &quot;IT/Ops&quot; com.example.label-with-empty-value: &quot;&quot; networks 网络使服务能够相互通信。默认情况下，Compose 会为您的应用设置单个网络。服务的每个容器都会加入默认网络，并且该网络上的其他容器都可以访问，并且可以通过服务名称发现。顶级networks元素允许您配置可在多个服务之间重复使用的命名网络。 1234567891011121314services: frontend: image: example/webapp networks: # 网络映射 - front-tier # 加入front-tier网络 - back-tier db: image: postgres networks: - backendnetworks: # 网络配置 front-tier: # 创建一个名为front-tier的网络，实际的网络名称是 容器组名称_front-tier back-tier: 如果 Compose 文件未显式声明网络，Compose 将使用隐式default网络。 123456789101112services: some-service: image: foo# 这个例子实际上等同于：services: some-service: image: foo networks: default: &#123;&#125;networks: default: &#123;&#125; networks 的属性 driver: 网络类型，默认为bridge 123networks: gitea: driver: bridge driver_opts: 网络类型参数，指定要传递给此网络驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。 12345networks: frontend: driver: bridge driver_opts: com.docker.network.bridge.host_binding_ipv4: &quot;127.0.0.1&quot; # 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地） driver_opts 常见配置项（针对 bridge 网络驱动） 选项键名（driver_opts） 说明 com.docker.network.bridge.name 指定桥接网络的名称（默认是随机生成，如 br-xxxxx） com.docker.network.bridge.enable_icc 是否允许容器之间的通信（true 或 false） com.docker.network.bridge.enable_ip_masquerade 是否启用 IP 假冒（NAT，通常用于外网访问） com.docker.network.bridge.host_binding_ipv4 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地） com.docker.network.bridge.default_bridge 是否将该网络设置为默认 bridge 网络（true 或 false） com.docker.network.driver.mtu 设置网络的最大传输单元（MTU，例如 &quot;1500&quot;） com.docker.network.bridge.allow_non_default_bridge 是否允许容器加入非默认的 bridge 网络（较少使用） attachable: 如果为true，则允许将其它独立容器也加入到此网络。默认值为false。如果独立容器连接到此网络，它可以与同样连接到此网络的服务和其他独立容器进行通信。 123networks: gitea: attachable: true external: true 表示不会创建新的网络，回去networks中查找（docker network ls），默认为false 123networks: gitea: external: true name: 网络名称，不会再加上容器组名称前缀 1234networks: gitea: name: gitea external: true # name 属性经常与 external: true 一起使用 labels: 用于向网络添加元数据，可以添加任意的键值对 123456networks: mynet1: labels: com.example.description: &quot;Financial transaction network&quot; com.example.department: &quot;Finance&quot; com.example.label-with-empty-value: &quot;&quot; internal: 默认情况下，Compose 提供网络的外部连接。internal当设置为 时true，可让您创建与外部隔离的网络。 123networks: gitea: internal: true services 服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展或替换。服务由一组容器支持，由平台根据复制要求和布局约束运行。由于服务由容器支持，因此它们由 Docker 镜像和一组运行时参数定义。服务中的所有容器都使用这些参数以相同的方式创建。 service 包含的属性非常多，具体请参考services顶级元素，这里只介绍比较常用的属性，以gitea的docker-compose.yml为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# version: &#x27;3.8&#x27; # 配置文件版本，已过时，配置上会告警但不会报错# name: gitea # 容器组名称，默认使用所在目录的名称，不推荐使用networks: # 网络配置 gitea: # 创建一个名为gitea的网络，实际的网络名称是 gitea_gitea，即 容器组名称_这里的名称 external: false # 如果为true，则表示此网络不会由compose创建，而是使用已有的网络，默认为false driver: bridge # 网络类型，默认为bridgevolumes: # 存储卷配置 gitea: # 创建一个名为gitea的存储卷，实际的卷名称是 gitea_gitea，即 容器组名称_这里的名称 driver: local # 存储卷类型，默认为localservices: # 服务配置，这里可以定义一组容器 server: # 定义一个名为server的服务，注意这个不是容器名称 # build: . # 构建镜像，使用当前目录下的Dockerfile image: gitea/gitea:latest # 镜像名称 # container_name: gitea # 容器名称，默认为 “容器组名称-服务名称-索引”，不推荐配置，因为 水平扩展(--scale) 时,容器名称不能重复 environment: # 定义环境变量 - USER_UID=1000 # key=value - USER_GID=1000 - DB_TYPE=mysql - DB_HOST=db:3306 # 这里配置的 db 就是 下面的服务名称，相同 network 下的服务名称，docker compose会自动解析为容器的ip地址 - DB_NAME=gitea - DB_USER=gitea - DB_PASSWD=gitea # env_file: .gitea.env # 从 .gitea.env 文件读取环境变量，生产环境更推荐 restart: always # 容器启动时，自动重启 networks: # 网络关联 - gitea # 网络名称，就是上面创建的gitea网络 volumes: # 数据卷关联 - gitea:/data # volume映射，数据卷名称:/容器路径 - /etc/timezone:/etc/timezone:ro # 路径映射，宿主机路径:/容器路径:读写权限 - /etc/localtime:/etc/localtime:ro ports: # 端口映射 - &quot;3000:3000&quot; # 宿主机端口:容器端口 depends_on: # 启动依赖，就是依赖的服务启动后才能启动本服务 db: # 启动db服务 condition: service_healthy # 服务通过健康检查，也可以配置为 service_started：服务启动，这个是默认值 db: # 数据库服务 image: mysql:8 # 镜像 environment: # 环境变量 - MYSQL_ROOT_PASSWORD=gitea - MYSQL_USER=gitea - MYSQL_PASSWORD=gitea - MYSQL_DATABASE=gitea restart: always # 启动策略 networks: # 网络映射 - gitea # 映射到gitea网络 volumes: # 卷映射 - ./mysql:/var/lib/mysql # 宿主机路径:/容器路径，这里宿主机支持相对路径 healthcheck: # 健康检查 test: [&quot;CMD-SHELL&quot;, &quot;mysql -u root -pgitea&quot;, &quot;-e &#x27;SELECT 1;&#x27;&quot;] # 执行命令，如果返回0，则健康检查通过，这里不支持上面的环境变量，test只支持 CMD-SHELL 和 CMD interval: 10s # 健康检查间隔 timeout: 5s # 健康检查超时时间 retries: 3 # 健康检查重试次数 build: 构建镜像 1234services: server: build: . # Dockerfile的目录，“.” 表示使用当前目录下的Dockerfile image: example/webapp # 镜像名称，如果有build，则该名称就是build后的镜像名称，如果没有build，则就会从远程仓库拉取 12345678910111213services: server: build: context: ./webapp # Dockerfile的目录，默认是当前目录 dockerfile: Dockerfile # 构建镜像的Dockerfile名称，默认是Dockerfile platforms: # 构建镜像的架构 - linux/amd64 # 构建镜像的架构，默认是当前架构 args: # 构建镜像的参数 - FOO=bar labels: # 构建镜像的标签 com.example.description: &quot;Accounting webapp&quot; com.example.department: &quot;Finance&quot; com.example.label-with-empty-value: &quot;&quot; command: 覆盖容器映像声明的默认命令 1234services: server: command: [&quot;python&quot;, &quot;app.py&quot;] image: example/webapp entrypoint: 声明服务容器的默认入口点，这覆盖了服务Dockerfile中的ENTRYPOINT指令。 123456789101112services: server: image: example/webapp entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit # 如果值为null，则使用图像的默认入口点。 entrypoint: null # 如果值是 []（空列表）或 &#x27;&#x27;（空字符串），图像声明的默认入口点被忽略，或者换句话说，被覆盖为空。 entrypoint: [] depends_on: 服务启动依赖，就是依赖的服务启动后才能启动本服务 12345678910services: web: build: . depends_on: - db # 短语法 - redis redis: image: redis db: image: postgres 12345678910111213141516171819services: web: build: . depends_on: db: # 长语法 condition: service_healthy # 满足的条件 restart: true # 当设置为true，Compose在更新依赖服务后重新启动此服务。 redis: condition: service_started redis: image: redis db: image: postgres## condition：设置依赖性被视为满足的条件# service_started：相当于之前描述的简短语法# service_healthy：指定在启动依赖服务之前，依赖预期为“健康”（如healthcheck所示）。# service_completed_successfully：指定在启动依赖服务之前，依赖项预计将运行到成功完成。 environment: 定义环境变量 12345678910111213services: server: image: example/webapp environment: - FOO=bar - BAZ=qux# 或者services: server: image: example/webapp environment: FOO: bar BAZ: qux env_file: 用于指定一个或多个包含要传递到容器的环境变量的文件。 123456services: server: image: example/webapp env_file: - ./a.env # 列表中的文件是从上到下处理的。对于两个环境文件中指定的相同变量，列表中最后一个文件的值是有效的。 - ./b.env 12345678services: server: image: example/webapp env_file: - path: ./default.env required: true # default - path: ./override.env required: false # 当required设置为false且.env文件缺失时，Compose会忽略 restart: 定义平台在容器终止时适用的策略 12345678services: server: image: example/webapp restart: &quot;no&quot; # 默认重启策略。在任何情况下，它都不会重新启动容器。 # restart: always # 策略总是重新启动容器，直到它被移除。 # restart: on-failure # 如果退出代码表明错误，策略将重新启动容器。 # restart: on-failure:3 # 如果退出代码表明错误，策略将重新启动容器。但仅尝试重启3次。 # restart: unless-stopped # 无论退出代码如何，策略都会重新启动容器，但当服务停止或删除时，策略会停止重新启动。 healthcheck: 健康检查。 12345678910services: server: image: example/webapp healthcheck: # 健康检查 test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 监控检查时执行的命令 interval: 1m30s # 健康检查的间隔，默认值为 30s timeout: 10s # 健康检查的超时时间，默认值为 30s retries: 3 # 健康检查的尝试次数，默认值为 3 start_period: 40s # 启动宽限期：在此期间，失败不会计入重试次数（仅用于判断服务是否启动完毕） start_interval: 5s # 启动宽限期内检查的频率，本示例为在前 40 秒内每 5 秒检查一次 test定义Compose运行的命令来检查容器运行状况。它可以是字符串，也可以是列表。如果是列表，第一个项目必须是NONE、CMD或CMD-SHELL。如果它是一个字符串，它等同于指定CMD-SHELL后跟该字符串。 1234test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]# 使用CMD-SHELL运行配置为字符串的命令，使用容器的默认外壳（Linux的/bin/sh）。以下两种形式是等价的test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;]test: curl -f https://localhost || exit 1 test 中的 CMD 和 CMD-SHELL 是两种不同的执行方式，它们的主要区别在于： 项目 CMD CMD-SHELL ✅ 用途 直接执行命令（不通过 shell） 通过 shell（如 /bin/sh -c）执行命令 🧾 写法格式 [&quot;CMD&quot;, &quot;executable&quot;, &quot;arg1&quot;, &quot;arg2&quot;] [&quot;CMD-SHELL&quot;, &quot;command string&quot;] 🔧 是否使用 shell 否 是 🧠 是否支持 shell 语法 ❌ 否（不能使用 &amp;&amp;、 ||、\\$VAR 等） ✅ 是（支持管道、重定向、变量、命令组合） 🛡️ 安全性/可移植性 ✅ 更安全，执行更明确 ⚠ 依赖容器中存在 shell（如 /bin/sh） ⚙️ 执行效率 ✅ 稍快，因无需 shell 解析 ⚠ 稍慢，需通过 shell 启动 📦 推荐使用场景 - 简单健康检查命令- 安全环境- 精简镜像 - 需要使用逻辑控制（||, &amp;&amp;）- 复杂检查逻辑 📌 示例 [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] [&quot;CMD-SHELL&quot;, &quot;curl -f http\\://localhost || exit 1&quot;] volumes: 挂载数据卷。 123456789101112131415161718192021222324252627282930# 长语法格式services: backend: image: example/backend volumes: - type: volume # 安装类型。可以是是volume、bind、tmpfs、image、npipe、cluster source: db-data # 挂载的源、绑定挂载的主机上的路径、映像挂载的Docker映像引用或顶层volumes键中定义的卷名称。不适用于tmpfs支架。 target: /data # 容器中装载卷的路径。 volume: # 配置其他卷选项 nocopy: true # 在创建卷时禁用从容器复制数据的标志，默认值为false。 subpath: sub # 挂载卷的子目录。即 db-data/sub - type: bind # bind 表示挂载主机上的路径 source: /var/run/postgres/postgres.sock target: /var/run/postgres/postgres.sockvolumes: # 声明数据卷 db-data:####################################################################################### 短语法格式services: backend: image: example/backend volumes: - db-data:/data # 这种语法不支持 subpath 和 nocopy - /var/run/postgres/postgres.sock:/var/run/postgres/postgres.sockvolumes: db-data: networks: 配置网络。 123456789services: some-service: networks: # 配置网络 - some-network # 关联网络 - other-networknetworks: # 声明网络 some-network: other-network:","summary":"摘要 本文介绍 Docker 命令 中 docker compose 的使用方法 Docker官方文档 docker compose Compose file reference","date_published":"2025-06-04T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/28/docker-command-network/","url":"https://blog.hanqunfeng.com/2025/05/28/docker-command-network/","title":"Docker 命令 之 网络(Network)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 网络管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Network-网络\">什么是Network(网络)?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Docker 中，<strong>网络（Network）</strong> 是容器之间通信、容器与外部通信的重要机制。Docker 提供了一套灵活的网络模型，使得你可以自由配置容器的网络环境以适配不同场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装docker时，会自动在宿主机上安装一个 <code>docker0</code> 网络设备，它是一个网桥设备，用于 Docker 各容器及宿主机的网络通信。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看宿主机网卡信息，可以找到docker0</span></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 0a:6b:88:11:66:39 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.250.0.205/24 brd 10.250.0.255 scope global dynamic noprefixroute eth0</span><br><span class=\"line\">       valid_lft 3076sec preferred_lft 3076sec</span><br><span class=\"line\">    inet6 fe80::86b:88ff:fe11:6639/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:d6:d5:09:b1 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:d6ff:fed5:9b1/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\">eth0 宿主机的ip地址是 10.250.0.205</span><br><span class=\"line\">docker0 本身的ip地址是 172.17.0.1</span><br><span class=\"line\">docker0 的子网掩码是 255.255.0.0</span><br><span class=\"line\">docker0 的广播地址是 172.17.255.255</span><br><span class=\"line\">docker0 可以为容器分配的ip地址范围是 172.17.0.2-172.17.255.254，总计65534个ip地址</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>既然docker0是一个网桥设备，我们可以通过如下命令来查看网桥的详细信息：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">brctl show</span><br><span class=\"line\">bridge name\t    bridge <span class=\"built_in\">id</span>\t\t      STP enabled\t    interfaces</span><br><span class=\"line\">docker0\t\t    8000.0242d6d509b1\t        no</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动docker服务后，docker就为我们自动创建了三个网络，可以通过如下命令查看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class=\"line\">4182e112bf34   bridge    bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">958daf8a8a0d   host      host      <span class=\"built_in\">local</span></span><br><span class=\"line\">4674a17c6617   none      null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里<code>NAME</code>为<code>bridge</code>的网络就是与<code>docker0</code>设备相对应的网络，其也是docker<code>默认</code>的网络，如果创建的容器没有指定网络，那么容器就会加入这个 <code>bridge</code> 网络。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  启动一个容器，没有指定网络</span></span><br><span class=\"line\">docker run -itd --name ap1 alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时在宿主机上查看网卡信息，会看到多出一个设备</span></span><br><span class=\"line\">ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">10: vethc0e0cc3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether c6:0d:02:c8:<span class=\"built_in\">df</span>:a4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">    inet6 fe80::c40d:2ff:fec8:dfa4/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器的网卡信息</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap1 ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 此时聪明的你已经发现了：宿主机的网卡与容器的网卡是成对出现的，并且基于序号进行关联</span></span><br><span class=\"line\">宿主机: 10 : veth c0e0cc3 @ <span class=\"keyword\">if</span> 9  <span class=\"comment\"># 序号 10 与 容器后缀的 10 匹配，veth 是虚拟网卡，c0e0cc3 是随机字符串，if 是 interface</span></span><br><span class=\"line\">容器:    9 : eth0         @ <span class=\"keyword\">if</span> 10 <span class=\"comment\"># 序号 9 与宿主机的后缀 9 匹配，eth0 是容器的网卡，if 是 interface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时查看宿主机的网桥信息</span></span><br><span class=\"line\">brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以在 interfaces 中看到 vethc0e0cc3，说明 vethc0e0cc3 已经加入到网桥中</span></span><br><span class=\"line\">bridge name\t  bridge <span class=\"built_in\">id</span>\t\t      STP enabled\t  interfaces</span><br><span class=\"line\">docker0\t\t   8000.0242d6d509b1\t      no\t\t  vethc0e0cc3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络中的容器信息，这里 jq 是 json 格式化，可以通过 dnf install jq -y 安装</span></span><br><span class=\"line\">docker network inspect bridge --format <span class=\"string\">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.2/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取容器的 IP 地址</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> ap1 hostname -i</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">172.17.0.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 相同网络设备下的容器可以通过 IP 地址通信</span></span><br><span class=\"line\"><span class=\"comment\"># 我们再创建一个容器，并查看能否正常通信</span></span><br><span class=\"line\">docker run -itd --name ap2 alpine</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap2 ping 172.17.0.2</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，说明可以通过IP地址通信</span></span><br><span class=\"line\">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=0 ttl=64 time=0.137 ms</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=1 ttl=64 time=0.084 ms</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=2 ttl=64 time=0.081 ms</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络中的容器</span></span><br><span class=\"line\">docker network inspect bridge --format <span class=\"string\">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;9d3ed5be1916b14ec9befe3649c08cc9de247c595de248600f8ef8d0fc16c5cb&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;35615a7ec10842401ad8c40187c792555b5089551a8eca39ddff6734aeba549e&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.3/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.2/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试是否可以通过容器名称访问</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap2 ping ap1</span><br><span class=\"line\"><span class=\"comment\">## 输出，不可以通过容器名称访问</span></span><br><span class=\"line\">ping: bad address <span class=\"string\">&#x27;ap1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 如果希望通过容器名称访问，我们可以通过 docker network create 创建一个新的网络</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>如果没有安装 brctl，可以通过如下方式安装</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># centos7:</span></span><br><span class=\"line\">yum install bridge-utils -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># centos8: 不支持yum源安装，需要手动编译安装</span></span><br><span class=\"line\"><span class=\"comment\"># 下载源码安装，目前最新版本为1.7.1</span></span><br><span class=\"line\">wget https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.gz</span><br><span class=\"line\">tar -zxvf bridge-utils-1.7.1.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> bridge-utils-1.7.1</span><br><span class=\"line\"><span class=\"comment\"># 需要先安装编译所需的工具和依赖</span></span><br><span class=\"line\">dnf install autoconf automake libtool make -y</span><br><span class=\"line\"><span class=\"comment\"># 因为源码目录中没有 configure 文件（但有 configure.ac），所以需要先运行如下命令生成 configure 文件</span></span><br><span class=\"line\">autoreconf -i</span><br><span class=\"line\"><span class=\"comment\"># 配置</span></span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"comment\"># 编译 且 安装</span></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"><span class=\"comment\"># 添加到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export PATH=<span class=\"variable\">$PATH</span>:/usr/local/sbin&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\">brctl --version</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">bridge-utils, 1.7</span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/wjWiNA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0负责给连接其上的容器分配ip地址，并且是每个容器的默认网关。当容器需要访问外网时，会通过docker0转到宿主机的eth0上，所以只要宿主机可以访问外网，那么容器也可以访问外网。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看宿主机的路由表</span></span><br><span class=\"line\">$ route -n</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         10.250.0.1      0.0.0.0         UG    100    0        0 eth0</span><br><span class=\"line\">10.250.0.0      0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ap1容器的路由表</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it ap1 route -n</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Container 的 bridge 桥接模式可以参考下图<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/32fupw.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"docker-network-相关命令\"><code>docker network</code> 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>示例</th>\n<th>示例输出（简略）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker network ls</code></td>\n<td>列出所有 Docker 网络</td>\n<td><code>docker network ls</code></td>\n<td><code>bridge</code>, <code>host</code>, <code>none</code> 等网络名称</td>\n</tr>\n<tr>\n<td><code>docker network inspect &lt;网络名&gt;</code></td>\n<td>查看指定网络的详细信息（如 IP 范围、连接容器等）</td>\n<td><code>docker network inspect bridge</code></td>\n<td>显示 JSON，含子网、网关、容器等信息</td>\n</tr>\n<tr>\n<td><code>docker network create &lt;网络名&gt;</code></td>\n<td>创建自定义网络（默认桥接）</td>\n<td><code>docker network create my-net</code></td>\n<td><code>my-net</code> 网络 ID</td>\n</tr>\n<tr>\n<td><code>docker network rm &lt;网络名&gt;</code></td>\n<td>删除网络（不能有容器连接）</td>\n<td><code>docker network rm my-net</code></td>\n<td>成功删除无提示，失败会有错误信息</td>\n</tr>\n<tr>\n<td><code>docker network connect &lt;网络名&gt; &lt;容器名&gt;</code></td>\n<td>将一个容器连接到指定网络</td>\n<td><code>docker network connect my-net my-container</code></td>\n<td>无输出，容器连接成功</td>\n</tr>\n<tr>\n<td><code>docker network disconnect &lt;网络名&gt; &lt;容器名&gt;</code></td>\n<td>将容器从网络中断开连接</td>\n<td><code>docker network disconnect my-net my-container</code></td>\n<td>无输出，断开成功</td>\n</tr>\n<tr>\n<td><code>docker network prune</code></td>\n<td>删除所有未使用的网络（慎用）</td>\n<td><code>docker network prune</code></td>\n<td>会提示是否确认，清理未使用网络</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-network-create-创建网络\"><code>docker network create</code> : 创建网络</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create [OPTIONS] NETWORK_NAME</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--driver</code> 或 <code>-d</code></td>\n<td>指定网络驱动类型，如 <code>bridge</code>, <code>overlay</code>, <code>macvlan</code>, <code>host</code>, <code>none</code></td>\n<td><code>--driver bridge</code></td>\n</tr>\n<tr>\n<td><code>--subnet</code></td>\n<td>指定子网地址范围（CIDR）</td>\n<td><code>--subnet 192.168.100.0/24</code></td>\n</tr>\n<tr>\n<td><code>--gateway</code></td>\n<td>指定网关 IP 地址</td>\n<td><code>--gateway 192.168.100.1</code></td>\n</tr>\n<tr>\n<td><code>--ip-range</code></td>\n<td>指定可分配的 IP 范围</td>\n<td><code>--ip-range 192.168.100.0/25</code></td>\n</tr>\n<tr>\n<td><code>--aux-address</code></td>\n<td>保留某些 IP 地址不被分配</td>\n<td><code>--aux-address=&quot;reserved=192.168.100.254&quot;</code></td>\n</tr>\n<tr>\n<td><code>--internal</code></td>\n<td>创建一个内部网络（不能访问外部）</td>\n<td><code>--internal</code></td>\n</tr>\n<tr>\n<td><code>--attachable</code></td>\n<td>创建可供单独容器连接的网络（Swarm 中）</td>\n<td><code>--attachable</code></td>\n</tr>\n<tr>\n<td><code>--label</code></td>\n<td>添加标签</td>\n<td><code>--label env=dev</code></td>\n</tr>\n<tr>\n<td><code>--opt</code></td>\n<td>提供自定义驱动选项</td>\n<td><code>--opt encrypted=true</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--driver</code> 或 <code>-d</code> : 常见的 Docker 网络驱动类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>是否支持端口映射</th>\n<th>特点与应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bridge</code>（默认）</td>\n<td>默认的桥接网络，容器通过虚拟网桥连接，共享宿主机的网络接口。</td>\n<td>✅ 是</td>\n<td>默认模式，适用于单主机部署、多个容器需要互通的场景。可映射端口对外访问。</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>容器与宿主机共用网络命名空间，容器直接使用宿主机的 IP 和端口。</td>\n<td>❌ 否</td>\n<td>无网络隔离，性能高，适用于高性能、低延迟场景（如游戏服务器）。</td>\n</tr>\n<tr>\n<td><code>none</code></td>\n<td>容器没有网络接口，完全隔离。</td>\n<td>❌ 否</td>\n<td>用于安全性或测试网络不可达场景。</td>\n</tr>\n<tr>\n<td><code>macvlan</code></td>\n<td>为容器分配独立 MAC 和 IP，容器像物理主机一样出现在局域网中。</td>\n<td>✅ 是（少见）</td>\n<td>适用于容器必须直接暴露在物理网络中的场景（如 DHCP 服务、ARP 广播）。</td>\n</tr>\n<tr>\n<td><code>ipvlan</code>（高级）</td>\n<td>类似 macvlan，但不使用虚拟 MAC 地址。</td>\n<td>✅ 是（少见）</td>\n<td>高级网络方案，适用于对网络拓扑精细控制的场景。</td>\n</tr>\n<tr>\n<td><code>overlay</code></td>\n<td>用于多主机之间容器通信，需要 Docker Swarm 支持。</td>\n<td>✅ 是（Swarm）</td>\n<td>跨主机部署服务的必要手段，适合容器编排平台（如 Swarm、Kubernetes）。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>前面我们说过，Docker会自动创建三个网络，即：bridge、host、none。对于单台宿主机的场景，绝大多数情况下我们都只会使用bridge网络。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名为my-network的网络</span></span><br><span class=\"line\">$ docker network create my-network</span><br><span class=\"line\"><span class=\"comment\"># 等同于，因为默认的网络驱动为bridge</span></span><br><span class=\"line\">$ docker network create --driver bridge my-network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络，可以看到新建的网络的驱动为bridge</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -f name=my-network</span><br><span class=\"line\">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class=\"line\">c2dbe1686790   my-network   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看宿主机的网桥信息</span></span><br><span class=\"line\">$ brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到此时有一个网桥设备 br-c2dbe1686790，br: bridge，c2dbe1686790：network id</span></span><br><span class=\"line\">bridge name\t      bridge <span class=\"built_in\">id</span>\t\t          STP enabled\t    interfaces</span><br><span class=\"line\">br-c2dbe1686790\t      8000.02425be81fae\t          no</span><br><span class=\"line\">docker0\t\t      8000.0242d6d509b1\t          no\t\t    vethc0e0cc3</span><br><span class=\"line\">\t\t\t\t\t\t\t            vethf4b7577</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看宿主机的网卡</span></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出，br-c2dbe1686790 网卡名称，其IP网段为 172.18.0.1/16</span></span><br><span class=\"line\">13: br-c2dbe1686790: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:5b:e8:1f:ae brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-c2dbe1686790</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动两个容器并添加到my-network网络中</span></span><br><span class=\"line\">$ docker run -itd --network my-network --name a1 alpine</span><br><span class=\"line\">$ docker run -itd --network my-network --name a2 alpine</span><br><span class=\"line\"></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出,可以看到两个容器都添加到了my-network网络中</span></span><br><span class=\"line\">bridge name\t      bridge <span class=\"built_in\">id</span>\t\t        STP enabled\t    interfaces</span><br><span class=\"line\">br-c2dbe1686790\t\t8000.02425be81fae\t    no\t\t    veth094946c</span><br><span class=\"line\">\t\t\t\t\t\t\t            vetha2ba68a</span><br><span class=\"line\">docker0\t\t        8000.0242d6d509b1\t    no\t\t    vethc0e0cc3</span><br><span class=\"line\">\t\t\t\t\t\t\t            vethf4b7577</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试连通性，可以看到 a1可以ping通 a2，反过来 a2也可以ping通 a1</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping a2</span><br><span class=\"line\">PING a2 (172.18.0.4): 56 data bytes</span><br><span class=\"line\">64 bytes from 172.18.0.4: <span class=\"built_in\">seq</span>=0 ttl=64 time=2.127 ms</span><br><span class=\"line\">64 bytes from 172.18.0.4: <span class=\"built_in\">seq</span>=1 ttl=64 time=0.119 ms</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND     CREATED         STATUS         PORTS     NAMES</span><br><span class=\"line\">e0fb0614591e   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a2</span><br><span class=\"line\">fc6e9477d2b7   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a1</span><br><span class=\"line\">9d3ed5be1916   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap2</span><br><span class=\"line\">c2436a1d750c   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap1</span><br><span class=\"line\"><span class=\"comment\"># 不同网络中的容器之间不能相互ping通</span></span><br><span class=\"line\"><span class=\"comment\">## 通过容器名称无法ping通</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping ap1</span><br><span class=\"line\">ping: bad address <span class=\"string\">&#x27;ap1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 通过ap1容器IP也无法ping通，这就实现了不同网络中的网络隔离</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping 172.17.0.2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果创建网络时没有指定子网，则从<code>docker0</code>的<code>172.17.0.0/16</code>往后排，比如我们上面创建的<code>my-network</code>，其子网就是<code>172.18.0.0/16</code>，如下命令创建一个bridge网络，并指定子网、网关等信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network create \\</span><br><span class=\"line\">  --driver bridge \\</span><br><span class=\"line\">  --subnet 192.168.50.0/24 \\</span><br><span class=\"line\">  --gateway 192.168.50.1 \\</span><br><span class=\"line\">  my-custom-net</span><br></pre></td></tr></table></figure>\n<h4 id=\"bridge-总结\"><code>bridge</code> 总结</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认创建的 <code>docker0</code> 网络，是一个桥接网络，在 docker network 中的名称为 <code>bridge</code>，该网络下的容器可以通过IP地址相互访问，但不能通过容器名称访问</p>\n</li>\n<li class=\"lvl-2\">\n<p>通过<code>docker network create &lt;网络名称&gt;</code>创建的网络也是一个桥接网络，在这个网络下，容器可以通过IP地址相互访问，也能通过容器名称访问。</p>\n</li>\n</ul>\n<h3 id=\"docker-network-ls-列出所有网络\"><code>docker network ls</code> : 列出所有网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 输出指定的信息</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --format <span class=\"string\">&quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.Scope&#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --format <span class=\"string\">&quot;json&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 过滤</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -f <span class=\"string\">&quot;driver=bridge&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 不截断输出</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --no-trunc</span><br><span class=\"line\"><span class=\"comment\"># 只显示network id</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -q</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-inspect-查看网络详情\"><code>docker network inspect</code> : 查看网络详情</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看名称为bridge网络详情</span></span><br><span class=\"line\">$ docker network inspect bridge</span><br><span class=\"line\"><span class=\"comment\"># 查看当前网络下有哪些容器</span></span><br><span class=\"line\">$ docker network inspect bridge --format <span class=\"string\">&quot;&#123;&#123;.Containers&#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">$ docker network inspect bridge --format <span class=\"string\">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-prune-清理没用的网络\"><code>docker network prune</code> : 清理没用的网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未使用的网络</span></span><br><span class=\"line\">$ docker network prune</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的网络，无需确认</span></span><br><span class=\"line\">$ docker network prune -f</span><br><span class=\"line\"><span class=\"comment\"># 清理24小时内未使用的网络</span></span><br><span class=\"line\">$ docker network prune --filter <span class=\"string\">&quot;until=24h&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-rm-删除网络\"><code>docker network rm</code> : 删除网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定的网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> &lt;network-name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除所有网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> $(docker network <span class=\"built_in\">ls</span> -q)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有bridge网络，这里要注意，docker默认创建的3个网络是删除不掉的</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> $(docker network <span class=\"built_in\">ls</span> -q -f driver=bridge)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-connect-将容器连接到网络\"><code>docker network connect</code> : 将容器连接到网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将容器连接到网络，如果容器启动时忘记连接网络，这里可以手动添加</span></span><br><span class=\"line\">$ docker network connect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-disconnect-将容器从网络断开\"><code>docker network disconnect</code> : 将容器从网络断开</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network disconnect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"本文总结\">本文总结</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器与网络是多对多的关系，即一个网络可以有多个容器，一个容器也可以连接到多个网络。</p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0 是 docker 默认创建的网络，不指定网络的情况下所有容器都连接到 docker0 网络。</p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0 是 bridge 网络，该网络中的容器之间可以通过 IP 互相访问，但不能通过容器名称访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>自建的 bridge 网络中的容器可以通过容器名称（或容器ID，但不常用）访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>不同的 bridge 网络中的容器不能互相访问。</p>\n</li>\n</ul>\n<h2 id=\"link-vs-network\"><code>--link</code> vs <code>--network</code></h2>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>--link</code></th>\n<th><code>--network</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>功能</td>\n<td>将一个容器链接到另一个容器，并设置环境变量和主机名映射</td>\n<td>将容器加入到一个自定义网络中，实现灵活、隔离的网络通信</td>\n</tr>\n<tr>\n<td>是否推荐</td>\n<td>❌ 不推荐（已废弃）</td>\n<td>✅ 推荐使用</td>\n</tr>\n<tr>\n<td>网络隔离</td>\n<td>基于默认 <code>bridge</code> 网络，隔离性差</td>\n<td>可以创建自定义网络（bridge、overlay 等），隔离性强</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>只适用于已运行的容器，连接固定</td>\n<td>支持多个容器，灵活组合和动态扩展</td>\n</tr>\n<tr>\n<td>DNS 支持</td>\n<td>仅设置环境变量，不支持自动 DNS</td>\n<td>自定义网络中支持容器名称作为 DNS 名称</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>一方容器关闭，另一方仍保存过时链接</td>\n<td>网络存在即可，容器生命周期不互相影响</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>所有容器共享 bridge，容易相互访问</td>\n<td>自定义网络间默认隔离，安全性更好</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Docker 命令 中 网络管理 相关命令 Docker官方文档 什么是Network(网络)? 在 Docker 中，网络（Network） 是容器之间通信、容器与外部通信的重要机制。Docker 提供了一套灵活的网络模型，使得你可以自由配置容器的网络环境以适配不同场景。 安装docker时，会自动在宿主机上安装一个 docker0 网络设备，它是一个网桥设备，用于 Docker 各容器及宿主机的网络通信。 123456789101112131415161718192021222324252627# 查看宿主机网卡信息，可以找到docker0$ ip addr# 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000 link/ether 0a:6b:88:11:66:39 brd ff:ff:ff:ff:ff:ff inet 10.250.0.205/24 brd 10.250.0.255 scope global dynamic noprefixroute eth0 valid_lft 3076sec preferred_lft 3076sec inet6 fe80::86b:88ff:fe11:6639/64 scope link valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:d6:d5:09:b1 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:d6ff:fed5:9b1/64 scope link valid_lft forever preferred_lft forever## 说明eth0 宿主机的ip地址是 10.250.0.205docker0 本身的ip地址是 172.17.0.1docker0 的子网掩码是 255.255.0.0docker0 的广播地址是 172.17.255.255docker0 可以为容器分配的ip地址范围是 172.17.0.2-172.17.255.254，总计65534个ip地址 既然docker0是一个网桥设备，我们可以通过如下命令来查看网桥的详细信息： 12345$ brctl show## 输出结果brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242d6d509b1 no 启动docker服务后，docker就为我们自动创建了三个网络，可以通过如下命令查看 12345$ docker network lsNETWORK ID NAME DRIVER SCOPE4182e112bf34 bridge bridge local958daf8a8a0d host host local4674a17c6617 none null local 这里NAME为bridge的网络就是与docker0设备相对应的网络，其也是docker默认的网络，如果创建的容器没有指定网络，那么容器就会加入这个 bridge 网络。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 启动一个容器，没有指定网络docker run -itd --name ap1 alpine# 此时在宿主机上查看网卡信息，会看到多出一个设备ip addr## 输出结果10: vethc0e0cc3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether c6:0d:02:c8:df:a4 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::c40d:2ff:fec8:dfa4/64 scope link valid_lft forever preferred_lft forever# 查看容器的网卡信息docker exec -it ap1 ip addr## 输出结果9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever## 此时聪明的你已经发现了：宿主机的网卡与容器的网卡是成对出现的，并且基于序号进行关联宿主机: 10 : veth c0e0cc3 @ if 9 # 序号 10 与 容器后缀的 10 匹配，veth 是虚拟网卡，c0e0cc3 是随机字符串，if 是 interface容器: 9 : eth0 @ if 10 # 序号 9 与宿主机的后缀 9 匹配，eth0 是容器的网卡，if 是 interface# 此时查看宿主机的网桥信息brctl show## 输出结果，可以在 interfaces 中看到 vethc0e0cc3，说明 vethc0e0cc3 已经加入到网桥中bridge name bridge id STP enabled interfacesdocker0 8000.0242d6d509b1 no vethc0e0cc3# 查看网络中的容器信息，这里 jq 是 json 格式化，可以通过 dnf install jq -y 安装docker network inspect bridge --format &#x27;&#123;&#123;json .Containers&#125;&#125;&#x27; | jq## 输出结果&#123; &quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;: &#123; &quot;Name&quot;: &quot;ap1&quot;, &quot;EndpointID&quot;: &quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;&#125;# 获取容器的 IP 地址docker exec ap1 hostname -i## 输出结果172.17.0.2# 相同网络设备下的容器可以通过 IP 地址通信# 我们再创建一个容器，并查看能否正常通信docker run -itd --name ap2 alpinedocker exec -it ap2 ping 172.17.0.2## 输出结果，说明可以通过IP地址通信PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.137 ms64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.084 ms64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.081 ms# 查看网络中的容器docker network inspect bridge --format &#x27;&#123;&#123;json .Containers&#125;&#125;&#x27; | jq&#123; &quot;9d3ed5be1916b14ec9befe3649c08cc9de247c595de248600f8ef8d0fc16c5cb&quot;: &#123; &quot;Name&quot;: &quot;ap2&quot;, &quot;EndpointID&quot;: &quot;35615a7ec10842401ad8c40187c792555b5089551a8eca39ddff6734aeba549e&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;: &#123; &quot;Name&quot;: &quot;ap1&quot;, &quot;EndpointID&quot;: &quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;&#125;# 测试是否可以通过容器名称访问docker exec -it ap2 ping ap1## 输出，不可以通过容器名称访问ping: bad address &#x27;ap1&#x27;## 如果希望通过容器名称访问，我们可以通过 docker network create 创建一个新的网络 如果没有安装 brctl，可以通过如下方式安装 12345678910111213141516171819202122# centos7:yum install bridge-utils -y# centos8: 不支持yum源安装，需要手动编译安装# 下载源码安装，目前最新版本为1.7.1wget https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.gztar -zxvf bridge-utils-1.7.1.tar.gzcd bridge-utils-1.7.1# 需要先安装编译所需的工具和依赖dnf install autoconf automake libtool make -y# 因为源码目录中没有 configure 文件（但有 configure.ac），所以需要先运行如下命令生成 configure 文件autoreconf -i# 配置./configure# 编译 且 安装make &amp;&amp; make install# 添加到环境变量echo &quot;export PATH=$PATH:/usr/local/sbin&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcbrctl --version## 输出结果bridge-utils, 1.7 Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。 docker0负责给连接其上的容器分配ip地址，并且是每个容器的默认网关。当容器需要访问外网时，会通过docker0转到宿主机的eth0上，所以只要宿主机可以访问外网，那么容器也可以访问外网。 1234567891011121314# 查看宿主机的路由表$ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.250.0.1 0.0.0.0 UG 100 0 0 eth010.250.0.0 0.0.0.0 255.255.255.0 U 100 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0# 查看ap1容器的路由表$ docker exec -it ap1 route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 Docker Container 的 bridge 桥接模式可以参考下图 docker network 相关命令 命令 功能说明 示例 示例输出（简略） docker network ls 列出所有 Docker 网络 docker network ls bridge, host, none 等网络名称 docker network inspect &lt;网络名&gt; 查看指定网络的详细信息（如 IP 范围、连接容器等） docker network inspect bridge 显示 JSON，含子网、网关、容器等信息 docker network create &lt;网络名&gt; 创建自定义网络（默认桥接） docker network create my-net my-net 网络 ID docker network rm &lt;网络名&gt; 删除网络（不能有容器连接） docker network rm my-net 成功删除无提示，失败会有错误信息 docker network connect &lt;网络名&gt; &lt;容器名&gt; 将一个容器连接到指定网络 docker network connect my-net my-container 无输出，容器连接成功 docker network disconnect &lt;网络名&gt; &lt;容器名&gt; 将容器从网络中断开连接 docker network disconnect my-net my-container 无输出，断开成功 docker network prune 删除所有未使用的网络（慎用） docker network prune 会提示是否确认，清理未使用网络 docker network create : 创建网络 语法 1docker network create [OPTIONS] NETWORK_NAME 常用参数说明表 参数 说明 示例 --driver 或 -d 指定网络驱动类型，如 bridge, overlay, macvlan, host, none --driver bridge --subnet 指定子网地址范围（CIDR） --subnet 192.168.100.0/24 --gateway 指定网关 IP 地址 --gateway 192.168.100.1 --ip-range 指定可分配的 IP 范围 --ip-range 192.168.100.0/25 --aux-address 保留某些 IP 地址不被分配 --aux-address=&quot;reserved=192.168.100.254&quot; --internal 创建一个内部网络（不能访问外部） --internal --attachable 创建可供单独容器连接的网络（Swarm 中） --attachable --label 添加标签 --label env=dev --opt 提供自定义驱动选项 --opt encrypted=true --driver 或 -d : 常见的 Docker 网络驱动类型 类型 含义 是否支持端口映射 特点与应用场景 bridge（默认） 默认的桥接网络，容器通过虚拟网桥连接，共享宿主机的网络接口。 ✅ 是 默认模式，适用于单主机部署、多个容器需要互通的场景。可映射端口对外访问。 host 容器与宿主机共用网络命名空间，容器直接使用宿主机的 IP 和端口。 ❌ 否 无网络隔离，性能高，适用于高性能、低延迟场景（如游戏服务器）。 none 容器没有网络接口，完全隔离。 ❌ 否 用于安全性或测试网络不可达场景。 macvlan 为容器分配独立 MAC 和 IP，容器像物理主机一样出现在局域网中。 ✅ 是（少见） 适用于容器必须直接暴露在物理网络中的场景（如 DHCP 服务、ARP 广播）。 ipvlan（高级） 类似 macvlan，但不使用虚拟 MAC 地址。 ✅ 是（少见） 高级网络方案，适用于对网络拓扑精细控制的场景。 overlay 用于多主机之间容器通信，需要 Docker Swarm 支持。 ✅ 是（Swarm） 跨主机部署服务的必要手段，适合容器编排平台（如 Swarm、Kubernetes）。 前面我们说过，Docker会自动创建三个网络，即：bridge、host、none。对于单台宿主机的场景，绝大多数情况下我们都只会使用bridge网络。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 创建一个名为my-network的网络$ docker network create my-network# 等同于，因为默认的网络驱动为bridge$ docker network create --driver bridge my-network# 查看网络，可以看到新建的网络的驱动为bridge$ docker network ls -f name=my-networkNETWORK ID NAME DRIVER SCOPEc2dbe1686790 my-network bridge local# 查看宿主机的网桥信息$ brctl show## 输出，可以看到此时有一个网桥设备 br-c2dbe1686790，br: bridge，c2dbe1686790：network idbridge name bridge id STP enabled interfacesbr-c2dbe1686790 8000.02425be81fae nodocker0 8000.0242d6d509b1 no vethc0e0cc3 vethf4b7577# 查看宿主机的网卡$ ip addr## 输出，br-c2dbe1686790 网卡名称，其IP网段为 172.18.0.1/1613: br-c2dbe1686790: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:5b:e8:1f:ae brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global br-c2dbe1686790 valid_lft forever preferred_lft forever# 启动两个容器并添加到my-network网络中$ docker run -itd --network my-network --name a1 alpine$ docker run -itd --network my-network --name a2 alpine$ ip addr## 输出,可以看到两个容器都添加到了my-network网络中bridge name bridge id STP enabled interfacesbr-c2dbe1686790 8000.02425be81fae no veth094946c vetha2ba68adocker0 8000.0242d6d509b1 no vethc0e0cc3 vethf4b7577# 测试连通性，可以看到 a1可以ping通 a2，反过来 a2也可以ping通 a1$ docker exec -it a1 ping a2PING a2 (172.18.0.4): 56 data bytes64 bytes from 172.18.0.4: seq=0 ttl=64 time=2.127 ms64 bytes from 172.18.0.4: seq=1 ttl=64 time=0.119 ms$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe0fb0614591e alpine &quot;/bin/sh&quot; 4 minutes ago Up 4 minutes a2fc6e9477d2b7 alpine &quot;/bin/sh&quot; 4 minutes ago Up 4 minutes a19d3ed5be1916 alpine &quot;/bin/sh&quot; 4 hours ago Up 4 hours ap2c2436a1d750c alpine &quot;/bin/sh&quot; 4 hours ago Up 4 hours ap1# 不同网络中的容器之间不能相互ping通## 通过容器名称无法ping通$ docker exec -it a1 ping ap1ping: bad address &#x27;ap1&#x27;## 通过ap1容器IP也无法ping通，这就实现了不同网络中的网络隔离$ docker exec -it a1 ping 172.17.0.2 如果创建网络时没有指定子网，则从docker0的172.17.0.0/16往后排，比如我们上面创建的my-network，其子网就是172.18.0.0/16，如下命令创建一个bridge网络，并指定子网、网关等信息 12345$ docker network create \\ --driver bridge \\ --subnet 192.168.50.0/24 \\ --gateway 192.168.50.1 \\ my-custom-net bridge 总结 默认创建的 docker0 网络，是一个桥接网络，在 docker network 中的名称为 bridge，该网络下的容器可以通过IP地址相互访问，但不能通过容器名称访问 通过docker network create &lt;网络名称&gt;创建的网络也是一个桥接网络，在这个网络下，容器可以通过IP地址相互访问，也能通过容器名称访问。 docker network ls : 列出所有网络 123456789101112# 列出所有网络$ docker network ls# 输出指定的信息$ docker network ls --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.Scope&#125;&#125;&quot;# 输出json格式$ docker network ls --format &quot;json&quot;# 过滤$ docker network ls -f &quot;driver=bridge&quot;# 不截断输出$ docker network ls --no-trunc# 只显示network id$ docker network ls -q docker network inspect : 查看网络详情 123456# 查看名称为bridge网络详情$ docker network inspect bridge# 查看当前网络下有哪些容器$ docker network inspect bridge --format &quot;&#123;&#123;.Containers&#125;&#125;&quot;# 输出json格式$ docker network inspect bridge --format &quot;json&quot; docker network prune : 清理没用的网络 123456# 删除所有未使用的网络$ docker network prune# 删除所有未使用的网络，无需确认$ docker network prune -f# 清理24小时内未使用的网络$ docker network prune --filter &quot;until=24h&quot; docker network rm : 删除网络 123456# 删除指定的网络$ docker network rm &lt;network-name&gt;# 删除所有网络$ docker network rm $(docker network ls -q)# 删除所有bridge网络，这里要注意，docker默认创建的3个网络是删除不掉的$ docker network rm $(docker network ls -q -f driver=bridge) docker network connect : 将容器连接到网络 12# 将容器连接到网络，如果容器启动时忘记连接网络，这里可以手动添加$ docker network connect &lt;network-name&gt; &lt;container-name&gt; docker network disconnect : 将容器从网络断开 1$ docker network disconnect &lt;network-name&gt; &lt;container-name&gt; 本文总结 容器与网络是多对多的关系，即一个网络可以有多个容器，一个容器也可以连接到多个网络。 docker0 是 docker 默认创建的网络，不指定网络的情况下所有容器都连接到 docker0 网络。 docker0 是 bridge 网络，该网络中的容器之间可以通过 IP 互相访问，但不能通过容器名称访问。 自建的 bridge 网络中的容器可以通过容器名称（或容器ID，但不常用）访问。 不同的 bridge 网络中的容器不能互相访问。 --link vs --network 项目 --link --network 功能 将一个容器链接到另一个容器，并设置环境变量和主机名映射 将容器加入到一个自定义网络中，实现灵活、隔离的网络通信 是否推荐 ❌ 不推荐（已废弃） ✅ 推荐使用 网络隔离 基于默认 bridge 网络，隔离性差 可以创建自定义网络（bridge、overlay 等），隔离性强 可扩展性 只适用于已运行的容器，连接固定 支持多个容器，灵活组合和动态扩展 DNS 支持 仅设置环境变量，不支持自动 DNS 自定义网络中支持容器名称作为 DNS 名称 生命周期 一方容器关闭，另一方仍保存过时链接 网络存在即可，容器生命周期不互相影响 安全性 所有容器共享 bridge，容易相互访问 自定义网络间默认隔离，安全性更好","summary":"摘要 本文介绍 Docker 命令 中 网络管理 相关命令 Docker官方文档","date_published":"2025-05-28T13:40:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/","url":"https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/","title":"Docker 命令 之 数据卷(Volume)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 数据卷管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Volume-数据卷\">什么是Volume(数据卷)?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Volume 是由 Docker 管理的特殊目录，位于宿主机文件系统中(<code>/var/lib/docker/volumes/</code>)，用于存储和共享容器的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当容器被删除后，容器内的文件系统也会一起删除，但挂载在 Volume 中的数据不会丢失，可供多个容器共享。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Volume 的特点</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据持久化</td>\n<td>即使容器删除，数据仍保留在卷中</td>\n</tr>\n<tr>\n<td>多容器共享访问</td>\n<td>多个容器可以挂载同一个卷，实现数据共享</td>\n</tr>\n<tr>\n<td>不依赖容器路径</td>\n<td>卷与容器生命周期解耦，支持灵活的容器重建和升级</td>\n</tr>\n<tr>\n<td>管理简便</td>\n<td>可用 <code>docker volume</code> 命令进行查看、创建、删除等操作</td>\n</tr>\n<tr>\n<td>安全隔离</td>\n<td>Docker 管理的路径比绑定挂载更安全</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-volume-相关命令\"><code>docker volume</code> 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker volume create</code></td>\n<td>创建一个新的卷，名称可选（不指定会自动生成）</td>\n<td><code>docker volume create myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume ls</code></td>\n<td>列出所有已存在的卷</td>\n<td><code>docker volume ls</code></td>\n</tr>\n<tr>\n<td><code>docker volume inspect &lt;name&gt;</code></td>\n<td>查看指定卷的详细信息，包括挂载点、驱动等</td>\n<td><code>docker volume inspect myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume rm &lt;name&gt;</code></td>\n<td>删除一个卷（前提是没有容器正在使用该卷）</td>\n<td><code>docker volume rm myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume prune</code></td>\n<td>删除所有未被使用的卷（会有确认提示）</td>\n<td><code>docker volume prune</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-volume-create-创建一个新的卷\"><code>docker volume create</code> : 创建一个新的卷</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume create [OPTIONS] [VOLUME]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d, --driver string</code></td>\n<td>指定卷驱动程序，默认是 <code>local</code>（本地存储）</td>\n<td><code>-d local</code> 或 第三方驱动名称(需要安装第三方插件)</td>\n</tr>\n<tr>\n<td><code>--label list</code></td>\n<td>给卷添加标签（元数据），可用于分类、过滤</td>\n<td><code>--label env=prod</code></td>\n</tr>\n<tr>\n<td><code>-o, --opt map</code></td>\n<td>设置驱动的特定选项，格式为 <code>key=value</code>，多个选项可重复使用</td>\n<td><code>-o type=tmpfs -o device=tmpfs</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个默认卷（local 驱动）</span></span><br><span class=\"line\">docker volume create myvolume</span><br><span class=\"line\"><span class=\"comment\"># 也可以在启动容器的时候创建默认数据卷，如下命令，若 myvolume 卷不存在，则会自动创建</span></span><br><span class=\"line\">docker run -d -v myvolume:/data nginx</span><br><span class=\"line\">docker run -d --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=myvolume,target=/data nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个带有标签的卷</span></span><br><span class=\"line\">docker volume create --label <span class=\"built_in\">env</span>=dev --label team=backend myvolume</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建匿名卷（不指定名称）</span></span><br><span class=\"line\">docker volume create</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 tmpfs 类型卷（只存于内存中，不落盘）,适用于高速读写但不需要持久化的数据</span></span><br><span class=\"line\">docker volume create \\</span><br><span class=\"line\">  -d <span class=\"built_in\">local</span> \\            <span class=\"comment\"># 指定驱动程序为 local</span></span><br><span class=\"line\">  -o <span class=\"built_in\">type</span>=tmpfs \\       <span class=\"comment\"># 指定底层文件系统类型为 tmpfs（内存文件系统）</span></span><br><span class=\"line\">  -o device=tmpfs \\     <span class=\"comment\"># 设置挂载设备为 tmpfs，用于与 type=tmpfs 配合</span></span><br><span class=\"line\">  -o o=size=100m \\      <span class=\"comment\"># 设置 tmpfs 的最大容量为 100MB</span></span><br><span class=\"line\">  mytmpfs               <span class=\"comment\"># 卷的名称，可通过 docker volume ls 查看</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个自定义驱动的卷（如 nfs）</span></span><br><span class=\"line\">docker volume create \\</span><br><span class=\"line\">  -d <span class=\"built_in\">local</span> \\                    <span class=\"comment\"># 默认驱动程序为 local</span></span><br><span class=\"line\">  -o <span class=\"built_in\">type</span>=nfs \\                 <span class=\"comment\"># 底层文件系统类型为 nfs</span></span><br><span class=\"line\">  -o o=addr=192.168.1.100,rw \\  <span class=\"comment\"># 设置 nfs 的地址和读写权限，若只读为 ro</span></span><br><span class=\"line\">  -o device=:/path/to/share \\   <span class=\"comment\"># 挂载设备为 nfs，格式为：nfs://192.168.1.100:/path/to/share</span></span><br><span class=\"line\">  mynfs                         <span class=\"comment\"># 卷的名称，可通过 docker volume ls 查看</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建的数据卷会保存在 <code>/var/lib/docker/volumes/</code> 目录下，比如我们创建了一个卷 myvolume，那么该卷会保存在 <code>/var/lib/docker/volumes/myvolume/_data</code> 目录下</p>\n</li>\n</ul>\n<h3 id=\"docker-volume-ls-列出所有已存在的卷\"><code>docker volume ls</code> : 列出所有已存在的卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 列出所有卷的ID</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -q</span><br><span class=\"line\"><span class=\"comment\"># 列出指定驱动的卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f driver=<span class=\"built_in\">local</span></span><br><span class=\"line\"><span class=\"comment\"># 列出指定标签的卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f label=<span class=\"built_in\">env</span>=dev</span><br><span class=\"line\"><span class=\"comment\"># 列出所有未使用的卷，包括匿名卷和命名卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f dangling=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-volume-inspect-name-查看指定卷的详细信息\"><code>docker volume inspect &lt;name&gt;</code> : 查看指定卷的详细信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出指定卷的详细信息</span></span><br><span class=\"line\">docker volume inspect myvolume</span><br><span class=\"line\"><span class=\"comment\"># 列出指定卷的详细信息，并使用json格式输出</span></span><br><span class=\"line\">docker volume inspect -f json myvolume</span><br><span class=\"line\"><span class=\"comment\"># 列出指定卷的挂载点</span></span><br><span class=\"line\">docker volume inspect myvolume --format <span class=\"string\">&quot;&#123;&#123;.Mountpoint&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-volume-prune-删除所有未被容器使用的卷\"><code>docker volume prune</code> : 删除所有未被容器使用的卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的匿名数据卷，会提示确认</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的数据卷，会提示确认</span></span><br><span class=\"line\">docker volume prune -a</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的卷，无需确认立刻删除</span></span><br><span class=\"line\">docker volume prune -a -f</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匿名卷 vs 命名卷</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">匿名卷：没有名称，只在 <code>docker run -v /container/path</code> 时自动创建；</li>\n<li class=\"lvl-4\">命名卷：有名称，例如 <code>docker run -v mydata:/container/path</code>；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"docker-volume-rm-name-删除数据卷\"><code>docker volume rm &lt;name&gt;</code> : 删除数据卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> myvolume</span><br><span class=\"line\"><span class=\"comment\"># 删除所有数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -q)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -qf dangling=<span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的数据卷，无需确认</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -qf dangling=<span class=\"literal\">true</span>) -f</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 数据卷管理 相关命令 Docker官方文档 什么是Volume(数据卷)? Volume 是由 Docker 管理的特殊目录，位于宿主机文件系统中(/var/lib/docker/volumes/)，用于存储和共享容器的数据。 当容器被删除后，容器内的文件系统也会一起删除，但挂载在 Volume 中的数据不会丢失，可供多个容器共享。 Volume 的特点 特性 说明 数据持久化 即使容器删除，数据仍保留在卷中 多容器共享访问 多个容器可以挂载同一个卷，实现数据共享 不依赖容器路径 卷与容器生命周期解耦，支持灵活的容器重建和升级 管理简便 可用 docker volume 命令进行查看、创建、删除等操作 安全隔离 Docker 管理的路径比绑定挂载更安全 docker volume 相关命令 命令 作用说明 示例 docker volume create 创建一个新的卷，名称可选（不指定会自动生成） docker volume create myvolume docker volume ls 列出所有已存在的卷 docker volume ls docker volume inspect &lt;name&gt; 查看指定卷的详细信息，包括挂载点、驱动等 docker volume inspect myvolume docker volume rm &lt;name&gt; 删除一个卷（前提是没有容器正在使用该卷） docker volume rm myvolume docker volume prune 删除所有未被使用的卷（会有确认提示） docker volume prune docker volume create : 创建一个新的卷 语法 1docker volume create [OPTIONS] [VOLUME] 参数详解 选项 说明 示例 -d, --driver string 指定卷驱动程序，默认是 local（本地存储） -d local 或 第三方驱动名称(需要安装第三方插件) --label list 给卷添加标签（元数据），可用于分类、过滤 --label env=prod -o, --opt map 设置驱动的特定选项，格式为 key=value，多个选项可重复使用 -o type=tmpfs -o device=tmpfs 示例 12345678910111213141516171819202122232425262728# 创建一个默认卷（local 驱动）docker volume create myvolume# 也可以在启动容器的时候创建默认数据卷，如下命令，若 myvolume 卷不存在，则会自动创建docker run -d -v myvolume:/data nginxdocker run -d --mount type=volume,source=myvolume,target=/data nginx# 创建一个带有标签的卷docker volume create --label env=dev --label team=backend myvolume# 创建匿名卷（不指定名称）docker volume create# 使用 tmpfs 类型卷（只存于内存中，不落盘）,适用于高速读写但不需要持久化的数据docker volume create \\ -d local \\ # 指定驱动程序为 local -o type=tmpfs \\ # 指定底层文件系统类型为 tmpfs（内存文件系统） -o device=tmpfs \\ # 设置挂载设备为 tmpfs，用于与 type=tmpfs 配合 -o o=size=100m \\ # 设置 tmpfs 的最大容量为 100MB mytmpfs # 卷的名称，可通过 docker volume ls 查看# 创建一个自定义驱动的卷（如 nfs）docker volume create \\ -d local \\ # 默认驱动程序为 local -o type=nfs \\ # 底层文件系统类型为 nfs -o o=addr=192.168.1.100,rw \\ # 设置 nfs 的地址和读写权限，若只读为 ro -o device=:/path/to/share \\ # 挂载设备为 nfs，格式为：nfs://192.168.1.100:/path/to/share mynfs # 卷的名称，可通过 docker volume ls 查看 创建的数据卷会保存在 /var/lib/docker/volumes/ 目录下，比如我们创建了一个卷 myvolume，那么该卷会保存在 /var/lib/docker/volumes/myvolume/_data 目录下 docker volume ls : 列出所有已存在的卷 12345678910# 列出所有卷docker volume ls# 列出所有卷的IDdocker volume ls -q# 列出指定驱动的卷docker volume ls -f driver=local# 列出指定标签的卷docker volume ls -f label=env=dev# 列出所有未使用的卷，包括匿名卷和命名卷docker volume ls -f dangling=true docker volume inspect &lt;name&gt; : 查看指定卷的详细信息 123456# 列出指定卷的详细信息docker volume inspect myvolume# 列出指定卷的详细信息，并使用json格式输出docker volume inspect -f json myvolume# 列出指定卷的挂载点docker volume inspect myvolume --format &quot;&#123;&#123;.Mountpoint&#125;&#125;&quot; docker volume prune : 删除所有未被容器使用的卷 123456# 删除所有未被使用的匿名数据卷，会提示确认docker volume prune# 删除所有未被使用的数据卷，会提示确认docker volume prune -a# 删除所有未被使用的卷，无需确认立刻删除docker volume prune -a -f 匿名卷 vs 命名卷 匿名卷：没有名称，只在 docker run -v /container/path 时自动创建； 命名卷：有名称，例如 docker run -v mydata:/container/path； docker volume rm &lt;name&gt; : 删除数据卷 12345678# 删除指定数据卷docker volume rm myvolume# 删除所有数据卷docker volume rm $(docker volume ls -q)# 删除所有未使用的数据卷docker volume rm $(docker volume ls -qf dangling=true)# 删除所有未使用的数据卷，无需确认docker volume rm $(docker volume ls -qf dangling=true) -f","summary":"摘要 本文介绍 Docker 命令 中 数据卷管理 相关命令 Docker官方文档","date_published":"2025-05-28T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/27/docker-command-container/","url":"https://blog.hanqunfeng.com/2025/05/27/docker-command-container/","title":"Docker 命令 之 容器(Container)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 容器管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"容器的生命周期\">容器的生命周期</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器可能处于以下几种状态：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">初建（created）</li>\n<li class=\"lvl-5\">运行（running）</li>\n<li class=\"lvl-5\">暂停（paused）</li>\n<li class=\"lvl-5\">停止（stopped）</li>\n<li class=\"lvl-5\">删除（deleted）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>各生命周期之间的转换关系如图所示：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/19n9NJ.png\" alt=\"\"></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令/情况</th>\n<th>说明</th>\n<th>容器状态变更</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker create</code></td>\n<td>创建容器后，不立即启动运行，容器进入初建状态</td>\n<td>初建状态</td>\n</tr>\n<tr>\n<td><code>docker run</code></td>\n<td>创建容器，并立即启动运行，进入运行状态</td>\n<td>初建 → 运行</td>\n</tr>\n<tr>\n<td><code>docker start</code></td>\n<td>启动已创建的容器，容器转为运行状态</td>\n<td>停止 → 运行</td>\n</tr>\n<tr>\n<td><code>docker stop</code></td>\n<td>停止正在运行的容器，容器转入停止状态</td>\n<td>运行 → 停止</td>\n</tr>\n<tr>\n<td><code>docker kill</code></td>\n<td>强制终止容器，相当于“断电”，容易丢失数据，不建议轻易使用</td>\n<td>运行 → 停止（非正常）</td>\n</tr>\n<tr>\n<td><code>docker restart</code></td>\n<td>重启容器，容器重新进入运行状态</td>\n<td>运行 → 停止 → 运行</td>\n</tr>\n<tr>\n<td><code>docker pause</code></td>\n<td>暂停容器内所有进程，容器进入暂停状态</td>\n<td>运行 → 暂停</td>\n</tr>\n<tr>\n<td><code>docker unpause</code></td>\n<td>取消暂停状态，容器恢复运行</td>\n<td>暂停 → 运行</td>\n</tr>\n<tr>\n<td><code>docker rm</code></td>\n<td>删除容器，容器转入删除状态</td>\n<td>任意 → 删除</td>\n</tr>\n<tr>\n<td>Killed by out-of-memory (OOM)</td>\n<td>宿主机内存耗尽，容器被系统终止，此为非计划终止；建议杀死内存占用最高的容器</td>\n<td>运行 → 停止（异常）</td>\n</tr>\n<tr>\n<td>Container process exited</td>\n<td>容器进程异常终止后，进入“是否重启”判断流程：是则执行 <code>start</code> 进入运行；否则保持停止状态</td>\n<td>异常 → 停止或运行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-container-容器管理\"><code>docker container</code> : 容器管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker container --help</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>别名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>attach</td>\n<td>将本地的标准输入、输出和错误流附加到一个正在运行的容器上</td>\n<td>docker attach</td>\n</tr>\n<tr>\n<td>commit</td>\n<td>根据容器的更改创建一个新的镜像</td>\n<td>docker commit</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>在容器和本地文件系统之间复制文件/文件夹</td>\n<td>docker cp</td>\n</tr>\n<tr>\n<td>create</td>\n<td>创建一个新的容器</td>\n<td>docker create</td>\n</tr>\n<tr>\n<td>diff</td>\n<td>检查容器文件系统上的文件或目录的更改</td>\n<td>docker diff</td>\n</tr>\n<tr>\n<td>exec</td>\n<td>在正在运行的容器中执行命令</td>\n<td>docker exec</td>\n</tr>\n<tr>\n<td>export</td>\n<td>将容器的文件系统导出为 tar 归档文件</td>\n<td>docker export</td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>显示一个或多个容器的详细信息</td>\n<td>可以使用 <code>docker inspect</code></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>终止一个或多个正在运行的容器</td>\n<td>docker kill</td>\n</tr>\n<tr>\n<td>logs</td>\n<td>获取容器的日志</td>\n<td>docker logs</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出容器</td>\n<td>docker ps</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停一个或多个容器内的所有进程</td>\n<td>docker pause</td>\n</tr>\n<tr>\n<td>port</td>\n<td>列出容器的端口映射或特定的端口映射</td>\n<td>docker port</td>\n</tr>\n<tr>\n<td>prune</td>\n<td>删除所有已停止的容器</td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>重命名一个容器</td>\n<td>docker rename</td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重启一个或多个容器</td>\n<td>docker restart</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除一个或多个容器</td>\n<td>docker rm</td>\n</tr>\n<tr>\n<td>run</td>\n<td>根据镜像创建并运行一个新容器</td>\n<td>docker run</td>\n</tr>\n<tr>\n<td>start</td>\n<td>启动一个或多个已停止的容器</td>\n<td>docker start</td>\n</tr>\n<tr>\n<td>stats</td>\n<td>实时显示容器资源使用统计信息</td>\n<td>docker stats</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止一个或多个正在运行的容器</td>\n<td>docker stop</td>\n</tr>\n<tr>\n<td>top</td>\n<td>显示容器中运行的进程</td>\n<td>docker top</td>\n</tr>\n<tr>\n<td>unpause</td>\n<td>取消暂停一个或多个容器内的所有进程</td>\n<td>docker unpause</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新一个或多个容器的配置</td>\n<td>docker update</td>\n</tr>\n<tr>\n<td>wait</td>\n<td>阻塞直到一个或多个容器停止，然后打印其退出代码</td>\n<td>docker wait</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 <code>docker container COMMAND --help</code> 可获取某个命令的更多信息。</p>\n</li>\n</ul>\n<h3 id=\"docker-create-创建容器，但不启动\"><code>docker create</code> : 创建容器，但不启动</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker create \\</span><br><span class=\"line\">    --name my-container \\ <span class=\"comment\"># 容器名</span></span><br><span class=\"line\">    -e MY_ENV_VAR=my-value \\ <span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\">    -p 80:80 \\ <span class=\"comment\"># 映射端口，格式：宿主机端口:容器端口</span></span><br><span class=\"line\">    -v /path/to/my/dir:/path/in/container \\ <span class=\"comment\"># 映射目录，格式：宿主机目录:容器目录，都必须是绝对路径</span></span><br><span class=\"line\">    --restart always \\ <span class=\"comment\"># 设置重启策略</span></span><br><span class=\"line\">    nginx:latest \\ <span class=\"comment\"># 镜像名，镜像不存在时会自动下载</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker create</code> 与 <code>docker run</code> 的参数基本一致，具体查看下面 <code>docker run</code> 中的介绍。</p>\n</li>\n</ul>\n<h3 id=\"docker-start-启动一个容器\"><code>docker start</code> : 启动一个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动一个容器，容器必须已经创建，并且处于停止状态。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 语法：docker start &lt;container_id|container_name&gt;</span></span><br><span class=\"line\">$ docker start my-container</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-run-创建并启动一个容器\"><code>docker run</code> : 创建并启动一个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>相当于<code>docker create</code> + <code>docker start</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>常用参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d</code>, <code>--detach</code></td>\n<td>后台运行容器（即“守护态”），<code>run</code>独有</td>\n<td><code>docker run -d nginx</code></td>\n</tr>\n<tr>\n<td><code>-it</code></td>\n<td>交互式运行容器并分配终端（常用于调试）</td>\n<td><code>docker run -it ubuntu bash</code></td>\n</tr>\n<tr>\n<td><code>--name</code></td>\n<td>指定容器名称</td>\n<td><code>docker run --name my-nginx nginx</code></td>\n</tr>\n<tr>\n<td><code>--rm</code></td>\n<td>容器退出时自动删除</td>\n<td><code>docker run --rm ubuntu</code></td>\n</tr>\n<tr>\n<td><code>-p</code>, <code>--publish</code></td>\n<td>端口映射（宿主机:容器）</td>\n<td><code>docker run -p 8080:80 nginx</code></td>\n</tr>\n<tr>\n<td><code>-P</code>, <code>--publish-all</code></td>\n<td>自动随机映射容器内部所有暴露端口到宿主机端口</td>\n<td><code>docker run -P nginx</code></td>\n</tr>\n<tr>\n<td><code>-v</code>, <code>--volume</code></td>\n<td>挂载卷（宿主机目录:容器目录）</td>\n<td><code>docker run -v /data:/app/data myapp</code></td>\n</tr>\n<tr>\n<td><code>--mount</code></td>\n<td>更灵活的挂载方式（推荐新项目使用）</td>\n<td><code>docker run --mount type=bind,source=/host,target=/container nginx</code></td>\n</tr>\n<tr>\n<td><code>--env</code>, <code>-e</code></td>\n<td>设置环境变量</td>\n<td><code>docker run -e ENV=prod myapp</code></td>\n</tr>\n<tr>\n<td><code>--env-file</code></td>\n<td>从文件中加载多个环境变量</td>\n<td><code>docker run --env-file .env myapp</code></td>\n</tr>\n<tr>\n<td><code>--network</code></td>\n<td>设置容器使用的网络模式</td>\n<td><code>docker run --network host myapp</code></td>\n</tr>\n<tr>\n<td><code>--restart</code></td>\n<td>设置容器的自动重启策略</td>\n<td><code>docker run --restart=always myapp</code></td>\n</tr>\n<tr>\n<td><code>--privileged</code></td>\n<td>给予容器更多的权限（如访问 host 设备）</td>\n<td><code>docker run --privileged myapp</code></td>\n</tr>\n<tr>\n<td><code>--entrypoint</code></td>\n<td>覆盖镜像默认的 ENTRYPOINT</td>\n<td><code>docker run --entrypoint /bin/bash myapp</code></td>\n</tr>\n<tr>\n<td><code>-u</code>, <code>--user</code></td>\n<td>指定容器内运行的用户（格式：UID 或 UID:GID）</td>\n<td><code>docker run --user 1000:1000 myapp</code></td>\n</tr>\n<tr>\n<td><code>-c</code>, <code>--cpu-shares</code></td>\n<td>设置 CPU 权重（相对值）</td>\n<td><code>docker run --cpu-shares=512 myapp</code></td>\n</tr>\n<tr>\n<td><code>-m</code>, <code>--memory</code></td>\n<td>限制容器最大内存（如 <code>512m</code>, <code>1g</code>）</td>\n<td><code>docker run --memory=512m myapp</code></td>\n</tr>\n<tr>\n<td><code>-h</code>,<code> --hostname</code></td>\n<td>设置容器主机名</td>\n<td><code>docker run -h myhost myapp</code></td>\n</tr>\n<tr>\n<td><code>--link</code>(更推荐使用 <code>--network</code>)</td>\n<td>创建链接到其他容器</td>\n<td><code>docker run --link myapp:app myapp2</code></td>\n</tr>\n<tr>\n<td><code>--cpus</code></td>\n<td>限制容器使用的CPU核数</td>\n<td><code>docker run --cpus=&quot;1.5&quot;</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-p</code>, <code>--publish</code> 端口映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p [主机IP:]主机端口:容器端口[/协议]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>示例</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-p 8080:80</code></td>\n<td>将主机的 8080 端口映射到容器的 80 端口（默认 TCP）</td>\n</tr>\n<tr>\n<td><code>-p 127.0.0.1:8080:80</code></td>\n<td>仅将主机本地 IP（127.0.0.1）的 8080 映射到容器的 80 端口（外部无法访问）</td>\n</tr>\n<tr>\n<td><code>-p 8080:80/tcp</code></td>\n<td>显式指定协议为 TCP（等同于不加 <code>/tcp</code>）</td>\n</tr>\n<tr>\n<td><code>-p 8080:80/udp</code></td>\n<td>映射 UDP 协议端口（如 DNS 服务等）</td>\n</tr>\n<tr>\n<td><code>-p 8080</code></td>\n<td>宿主机随机端口映射到容器的8080端口</td>\n</tr>\n<tr>\n<td><code>-p 3000-3006:4000-4006</code></td>\n<td><strong>范围映射</strong>，不能映射非对称范围（如 3000-3006:4000-4006），只能一一对应</td>\n</tr>\n<tr>\n<td>多个 <code>-p</code></td>\n<td>可以多次使用 <code>-p</code>，映射多个端口。例如：<code>-p 80:80 -p 443:443</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-v, --volume</code> 数据卷映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v &lt;本地路径&gt;:&lt;容器路径&gt;[:权限]</span><br><span class=\"line\">  <span class=\"comment\"># &lt;本地路径&gt;\t主机上的路径（绝对路径，或命名卷），目录不存在会自动创建</span></span><br><span class=\"line\">  <span class=\"comment\"># &lt;容器路径&gt;\t容器内的路径，目录不存在会自动创建</span></span><br><span class=\"line\">  <span class=\"comment\"># [:权限]\t可选：ro（只读） 或 rw（读写，默认）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 挂载本地目录到容器</span></span><br><span class=\"line\">docker run -v /data:/app/data myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载为只读</span></span><br><span class=\"line\">docker run -v /data:/app/data:ro myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载多个数据卷</span></span><br><span class=\"line\">docker run -v /data1:/app/data1 -v /data2:/app/data2 myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命名卷</span></span><br><span class=\"line\">docker volume create mydata</span><br><span class=\"line\">docker run -v mydata:/app/data myapp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--mount</code> 挂载卷</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --mount 是 Docker 推荐使用的 现代挂载方式，功能和 -v（或 --volume）类似，但语法更清晰、结构更规范，适用于卷（volume）、绑定挂载（bind）和临时挂载（tmpfs）。</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=&lt;类型&gt;,<span class=\"built_in\">source</span>=&lt;主机路径或卷名&gt;,target=&lt;容器路径&gt;[,<span class=\"built_in\">readonly</span>]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>三种挂载类型对比</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>类型 (<code>type</code>)</th>\n<th>用途</th>\n<th>示例 <code>source</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>volume</code></td>\n<td>使用 Docker 管理的卷</td>\n<td>卷名，如 <code>mydata</code></td>\n</tr>\n<tr>\n<td><code>bind</code></td>\n<td>挂载宿主机的实际路径</td>\n<td>绝对路径，如 <code>/home/user/app/config</code></td>\n</tr>\n<tr>\n<td><code>tmpfs</code></td>\n<td>挂载内存中的临时文件系统</td>\n<td>无需指定 <code>source</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用命名卷挂载（推荐方式）,这里 --target 指定容器内的挂载点，也可以替换为 --destination</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=mydata,target=/app/data myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用本地路径挂载（绑定挂载）,source指定的本地路径必须存在</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,<span class=\"built_in\">source</span>=/home/user/app/config,target=/app/config myapp</span><br><span class=\"line\"><span class=\"comment\"># 只读挂载，readonly 可以简写为 ro</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,<span class=\"built_in\">source</span>=/home/user/app/config,target=/app/config,<span class=\"built_in\">readonly</span> myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用内存中的临时文件系统挂载，数据不会持久化，只存储在容器运行时的内存中</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=tmpfs,target=/app/tmpfs myapp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--link</code> 容器间链接</p>\n</li>\n</ul>\n<blockquote>\n<p>用于在容器之间建立连接，使一个容器可以通过另一个容器的名称访问其网络信息（如 IP、环境变量等）。<br>\n注意：<code>--link</code> 已被弃用，建议使用 <code>--network</code> 来实现容器间链接。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --<span class=\"built_in\">link</span> &lt;目标容器名&gt;:&lt;别名&gt; &lt;其他参数&gt; &lt;镜像名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 场景：一个 web 容器想要连接另一个运行中的 db 容器</span></span><br><span class=\"line\"><span class=\"comment\"># 先启动数据库容器</span></span><br><span class=\"line\">docker run -d --name db mysql</span><br><span class=\"line\"><span class=\"comment\"># 启动 web 容器并连接到 db 容器</span></span><br><span class=\"line\">docker run -it --<span class=\"built_in\">rm</span> --name web --<span class=\"built_in\">link</span> db:mydb ubuntu bash</span><br><span class=\"line\"><span class=\"comment\"># 在 web 容器中，现在你可以用 mydb 来访问 db 容器，但反过来 db 容器无法访问 web 容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> web ping mydb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 改用 --network 实现</span></span><br><span class=\"line\">docker network create mynet</span><br><span class=\"line\">docker run -d --name db --network mynet mysql</span><br><span class=\"line\">docker run -it --<span class=\"built_in\">rm</span> --name web --network mynet ubuntu bash</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> web ping db</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--network</code> 网络模式类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>特点/适用场景</th>\n<th>是否允许端口映射</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bridge</code></td>\n<td>默认网络类型（用户自定义或 Docker 默认桥接网络）</td>\n<td>容器通过虚拟网桥连接，可相互通信；适用于单主机部署</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>容器与宿主机共享网络栈</td>\n<td>没有网络隔离，容器使用宿主机的 IP 和端口，性能高，适合对网络要求高的服务</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><code>none</code></td>\n<td>容器没有网络接口</td>\n<td>完全隔离；适用于需要完全控制网络的场景或测试网络不可达性</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><code>&lt;user-defined&gt;</code></td>\n<td>用户自定义的网络名称，通过 <code>docker network create</code> 创建</td>\n<td>支持容器名称互解析（DNS），适合多容器通信场景，如 Docker Compose</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><code>container:&lt;name|id&gt;</code></td>\n<td>与另一个容器共享网络命名空间</td>\n<td>两个容器共享 IP 和端口，适用于主-辅容器模式，如 sidecar 容器共享主容器网络</td>\n<td>❌ 否</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用默认 bridge 网络</span></span><br><span class=\"line\">docker run -p 8080:80 --network bridge --name my-nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与宿主机共享网络，不能使用-p</span></span><br><span class=\"line\">docker run --network host nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不使用任何网络，不能使用-p</span></span><br><span class=\"line\">docker run --network none nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用已创建的自定义网络，相同网络命名空间下的容器，可以通过容器 名称或ID 互相访问</span></span><br><span class=\"line\">docker network create nginx_net</span><br><span class=\"line\">docker run -p 8080:80 --network nginx_net nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与另一个容器共享网络命名空间，不能使用-p，并且此时新启动的容器占用的端口不能与要连接的容器端口一致，否则将启动失败</span></span><br><span class=\"line\">docker run --network container:my-nginx busybox</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--restart</code> 重启策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>no</code>（默认）</td>\n<td>容器退出后不会自动重启</td>\n</tr>\n<tr>\n<td><code>always</code></td>\n<td>无论退出状态码如何，容器总是自动重启</td>\n</tr>\n<tr>\n<td><code>unless-stopped</code></td>\n<td>容器总是自动重启，除非用户手动停止它</td>\n</tr>\n<tr>\n<td><code>on-failure[:N]</code></td>\n<td>仅在容器非 0 状态码退出时自动重启（可选设置最大重启次数 N）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器非正常退出时自动重启</span></span><br><span class=\"line\">docker run --restart on-failure my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最多重启 5 次</span></span><br><span class=\"line\">docker run --restart on-failure:5 my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 总是重启（即使你重启 Docker 服务后）</span></span><br><span class=\"line\">docker run --restart always my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 除非手动停止，否则一直重启</span></span><br><span class=\"line\">docker run --restart unless-stopped my-app</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--cpu-shares</code> : 设置容器的 CPU 相对权重，即在 CPU 资源竞争时的相对优先级，默认值为 1024。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器1，权重 1024（默认）</span></span><br><span class=\"line\">docker run -d --name c1 --cpu-shares 1024 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器2，权重 512（优先级低）</span></span><br><span class=\"line\">docker run -d --name c2 --cpu-shares 512 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\">  <span class=\"comment\"># c1的权重1024，c2的权重512,不是绝对限制，而是分配比例</span></span><br><span class=\"line\">  <span class=\"comment\"># 该权重表示容器在 CPU 竞争下，权重越高则优先级越高，会尽可能使用 CPU 资源。</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果这两个容器都运行在 CPU 忙碌的环境下(只有在 多容器共享 CPU 且竞争资源 的情况下才生效)：</span></span><br><span class=\"line\">    <span class=\"comment\"># c1 将获得大约 2/3 的 CPU 时间</span></span><br><span class=\"line\">    <span class=\"comment\"># c2 将获得大约 1/3 的 CPU 时间</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果系统 CPU 空闲，所有容器都可以使用 100% 的 CPU。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker run</code> 示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个nginx 容器</span></span><br><span class=\"line\">docker run -d -p 80:80 --name nginx nginx</span><br><span class=\"line\"><span class=\"comment\"># 替换nginx镜像默认的启动命令，nginx 镜像默认启动 nginx 服务，此命令会改为执行 nginx -v 显示版本号</span></span><br><span class=\"line\">docker run --name test_nginx --entrypoint <span class=\"string\">&quot;&quot;</span> nginx nginx -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行脚本或命令，这里添加 --rm 参数，表示运行结束后自动删除容器，这里是安装 ping 命令</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> ubuntu bash -c <span class=\"string\">&quot;apt update &amp;&amp; apt install -y iputils-ping&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 交互式执行 shell 命令，执行命令后会进入容器的shell</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -it ubuntu /bin/bash</span><br><span class=\"line\"><span class=\"comment\"># 这样也可以，因为 ubuntu 的默认启动命令是 /bin/bash</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -it ubuntu</span><br><span class=\"line\"><span class=\"comment\"># 转到后台运行</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -itd ubuntu</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stop-停止容器，容器优雅退出\"><code>docker stop</code> : 停止容器，容器优雅退出</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止容器，通过容器名称</span></span><br><span class=\"line\">docker stop test_nginx</span><br><span class=\"line\"><span class=\"comment\"># 停止容器，通过容器ID</span></span><br><span class=\"line\">docker stop 5d7c0c5d5c0c</span><br><span class=\"line\"><span class=\"comment\"># 停止所有正在运行的容器</span></span><br><span class=\"line\">docker stop $(docker ps -q)</span><br><span class=\"line\"><span class=\"comment\"># 等待5秒后强制关闭</span></span><br><span class=\"line\">docker stop -t 5 test_nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-kill-强制停止容器\"><code>docker kill</code> : 强制停止容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当容器完全卡死、挂起、不响应 <code>stop</code> 命令时使用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> test_nginx</span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> 5d7c0c5d5c0c</span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-restart-重启容器\"><code>docker restart</code> : 重启容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart test_nginx</span><br><span class=\"line\">docker restart 5d7c0c5d5c0c</span><br><span class=\"line\">docker restart $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-pause-暂停容器\"><code>docker pause</code> : 暂停容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暂停后宿主机将不再为容器分配CPU时间片，但内存依然有效，你可以理解为此时为容器保存了快照</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pause test_nginx</span><br><span class=\"line\">docker pause 5d7c0c5d5c0c</span><br><span class=\"line\">docker pause $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-unpause-恢复容器\"><code>docker unpause</code> : 恢复容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker unpause test_nginx</span><br><span class=\"line\">docker unpause 5d7c0c5d5c0c</span><br><span class=\"line\">docker unpause $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-ps-查看容器列表\"><code>docker ps</code> : 查看容器列表</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"><span class=\"comment\"># 显示所有容器</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"><span class=\"comment\"># 显示所有正在运行的容器的ID</span></span><br><span class=\"line\">docker ps -q</span><br><span class=\"line\"><span class=\"comment\"># 不截断输出，此时 COMMAND 列会显示完整的命令</span></span><br><span class=\"line\">docker ps -notrunc</span><br><span class=\"line\"><span class=\"comment\"># 显示最近创建的5条容器</span></span><br><span class=\"line\">docker ps -n 5</span><br><span class=\"line\"><span class=\"comment\"># 过滤器，显示状态为exited的容器</span></span><br><span class=\"line\">docker ps -a --filter <span class=\"string\">&quot;status=exited&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定模板，只显示 ID 和 Names</span></span><br><span class=\"line\">docker ps --format <span class=\"string\">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-inspect-查看容器信息\"><code>docker inspect</code> : 查看容器信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看容器信息</span></span><br><span class=\"line\">docker inspect &lt;container_id&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器名称</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器镜像</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器环境变量</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器状态，前面的 json 表示输出为 json 格式</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .State&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器内存限制</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器label</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的网络信息</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .NetworkSettings&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-logs-获取容器日志\"><code>docker logs</code> : 获取容器日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取容器日志</span></span><br><span class=\"line\">docker logs &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器实时日志</span></span><br><span class=\"line\">docker logs -f &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器最新的 10 行日志</span></span><br><span class=\"line\">docker logs -n 10 &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的带时间戳的日志</span></span><br><span class=\"line\">docker logs -t &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，从 1 小时前开始</span></span><br><span class=\"line\">docker logs --since 1h &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，直到 1 小时前</span></span><br><span class=\"line\">docker logs --<span class=\"keyword\">until</span> 1h &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的详细日志</span></span><br><span class=\"line\">docker logs --details &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，从 2 小时前开始，直到 1 小时前</span></span><br><span class=\"line\">docker logs --since 2h --<span class=\"keyword\">until</span> 1h &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-exec-在已经运行的容器中执行命令\"><code>docker exec</code> : 在已经运行的容器中执行命令</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在已经运行的容器中执行命令</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &lt;container_id | container_name&gt; &lt;<span class=\"built_in\">command</span>&gt;</span><br><span class=\"line\"><span class=\"comment\"># 进入容器shell</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it &lt;container_id | container_name&gt; bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rename-重命名容器\"><code>docker rename</code> : 重命名容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rename &lt;old_container_name&gt; &lt;new_container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-cp-容器与宿主机间复制文件\"><code>docker cp</code> : 容器与宿主机间复制文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 宿主机 -&gt; 容器</span></span><br><span class=\"line\"><span class=\"comment\"># docker cp &lt;host_path&gt; &lt;container_id | container_name&gt;:&lt;container_path&gt;</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> ./docker-command-container.md nginx:/tmp</span><br><span class=\"line\"><span class=\"comment\"># 容器 -&gt; 宿主机</span></span><br><span class=\"line\"><span class=\"comment\"># docker cp &lt;container_id | container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> nginx:/tmp/docker-command-container.md ./</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rm-删除容器\"><code>docker rm</code> : 删除容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-container-prune-删除所有停止的容器\"><code>docker container prune</code> : 删除所有停止的容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-update-更新容器配置\"><code>docker update</code> : 更新容器配置</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更新指定容器的CPU核数和内存大小</span></span><br><span class=\"line\">docker update --cpus=2 --memory=2g &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 更新指定容器自动重启</span></span><br><span class=\"line\">docker update --restart=always &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>并不是所有的配置都支持更新，update 命令只支持如下配置，基本上也就只能调一下cpu和内存，以及自动重启策略，所以制作容器时一定要做好规划。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n<th>示例值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--blkio-weight</code></td>\n<td>设置 Block IO 的相对权重，范围是 10 到 1000，设置为 0 表示禁用（默认值为 0）</td>\n<td><code>--blkio-weight=500</code></td>\n</tr>\n<tr>\n<td><code>--cpu-period</code></td>\n<td>设置 CPU CFS（完全公平调度器）的周期限制（单位：微秒）</td>\n<td><code>--cpu-period=100000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-quota</code></td>\n<td>设置 CPU CFS 的配额限制（单位：微秒）</td>\n<td><code>--cpu-quota=50000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-rt-period</code></td>\n<td>设置实时 CPU 的调度周期（单位：微秒）</td>\n<td><code>--cpu-rt-period=1000000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-rt-runtime</code></td>\n<td>设置实时 CPU 的运行时间限制（单位：微秒）</td>\n<td><code>--cpu-rt-runtime=950000</code></td>\n</tr>\n<tr>\n<td><code>-c</code>, <code>--cpu-shares</code></td>\n<td>设置 CPU 共享权重，默认值为 1024</td>\n<td><code>--cpu-shares=512</code></td>\n</tr>\n<tr>\n<td><code>--cpus</code></td>\n<td>限制容器使用的 CPU 数量（支持小数）</td>\n<td><code>--cpus=1.5</code></td>\n</tr>\n<tr>\n<td><code>--cpuset-cpus</code></td>\n<td>指定容器可以在哪些 CPU 上运行（如 0-3、0,1）</td>\n<td><code>--cpuset-cpus=&quot;0,1&quot;</code></td>\n</tr>\n<tr>\n<td><code>--cpuset-mems</code></td>\n<td>指定容器可以使用哪些内存节点（如 0-3、0,1），适用于 NUMA 系统</td>\n<td><code>--cpuset-mems=&quot;0&quot;</code></td>\n</tr>\n<tr>\n<td><code>-m</code>, <code>--memory</code></td>\n<td>设置内存限制（例如 512m、2g）</td>\n<td><code>--memory=1g</code></td>\n</tr>\n<tr>\n<td><code>--memory-reservation</code></td>\n<td>设置内存软限制（低于 <code>--memory</code> 的值时，允许系统在压力较小时回收）</td>\n<td><code>--memory-reservation=512m</code></td>\n</tr>\n<tr>\n<td><code>--memory-swap</code></td>\n<td>设置 swap 限制（内存 + swap 总和），设为 -1 表示无限制</td>\n<td><code>--memory-swap=2g</code></td>\n</tr>\n<tr>\n<td><code>--pids-limit</code></td>\n<td>设置容器的最大进程数量，设为 -1 表示无限制</td>\n<td><code>--pids-limit=100</code></td>\n</tr>\n<tr>\n<td><code>--restart</code></td>\n<td>设置容器退出后的重启策略</td>\n<td><code>--restart=always</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-stats-显示容器的实时资源使用情况\"><code>docker stats</code> : 显示容器的实时资源使用情况</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有容器的实时资源使用情况</span></span><br><span class=\"line\">docker stats</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">CONTAINER ID   NAME         CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O     PIDS</span><br><span class=\"line\">15caf520e3a5   nginx        0.00%     10.22MiB / 7.752GiB   0.13%     6.38kB / 2.61kB   0B / 28.7kB   13</span><br><span class=\"line\">b680087420b8   dockge       0.01%     199.5MiB / 7.752GiB   2.51%     6.44kB / 1.48kB   94.8MB / 0B   24</span><br><span class=\"line\">861dd9c1475f   remote-api   0.00%     4.188MiB / 7.752GiB   0.05%     2.77kB / 126B     3.31MB / 0B   1</span><br><span class=\"line\"><span class=\"comment\">### CONTAINER ID 与 NAME：容器 ID 与名称。</span></span><br><span class=\"line\"><span class=\"comment\">### CPU % 与 MEM %：容器使用的 CPU 和内存的百分比。</span></span><br><span class=\"line\"><span class=\"comment\">### MEM USAGE / LIMIT：容器正在使用的总内存，以及允许使用的内存总量。</span></span><br><span class=\"line\"><span class=\"comment\">### NET I/O：容器通过其网络接口发送和接收的数据量。</span></span><br><span class=\"line\"><span class=\"comment\">### BLOCK I/O：容器从主机上的块设备读取和写入的数据量。</span></span><br><span class=\"line\"><span class=\"comment\">### PIDs：容器创建的进程或线程数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有容器的资源使用情况，包括运行和停止的</span></span><br><span class=\"line\">docker stats -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 展示当前状态就直接退出了，不再实时更新。</span></span><br><span class=\"line\">docker stats --no-stream</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定输出模板，这里加不加 table 都可以</span></span><br><span class=\"line\">docker stats --no-stream --format <span class=\"string\">&quot;table &#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.CPUPerc&#125;&#125;\\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">docker stats --no-stream --format json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定容器</span></span><br><span class=\"line\">docker stats &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-top-查看正在运行的进程\"><code>docker top</code> :  查看正在运行的进程</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker top &lt;container_id | container_name&gt; [ps options]</span></span><br><span class=\"line\">docker top nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-port-列出指定的容器的端口映射\"><code>docker port</code> : 列出指定的容器的端口映射</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker port &lt;container_id | container_name&gt;</span></span><br><span class=\"line\">$ docker port nginx</span><br><span class=\"line\">80/tcp -&gt; 0.0.0.0:8081</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-diff-列出容器运行时对文件系统的修改\"><code>docker diff</code> : 列出容器运行时对文件系统的修改</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker diff &lt;container_id | container_name&gt;</span></span><br><span class=\"line\">$ docker diff nginx</span><br><span class=\"line\">C /root</span><br><span class=\"line\">A /root/.bash_history</span><br><span class=\"line\">C /run</span><br><span class=\"line\">A /run/nginx.pid</span><br><span class=\"line\">C /tmp</span><br><span class=\"line\">A /tmp/demo.py</span><br><span class=\"line\">C /var</span><br><span class=\"line\">C /var/cache</span><br><span class=\"line\">C /var/cache/nginx</span><br><span class=\"line\">A /var/cache/nginx/client_temp</span><br><span class=\"line\">A /var/cache/nginx/fastcgi_temp</span><br><span class=\"line\">A /var/cache/nginx/proxy_temp</span><br><span class=\"line\">A /var/cache/nginx/scgi_temp</span><br><span class=\"line\">A /var/cache/nginx/uwsgi_temp</span><br><span class=\"line\">C /etc</span><br><span class=\"line\">C /etc/nginx</span><br><span class=\"line\">C /etc/nginx/conf.d</span><br><span class=\"line\">C /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前缀含义说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>A</code></td>\n<td><strong>Added（新增）</strong></td>\n<td>文件或目录是容器运行后新增的</td>\n</tr>\n<tr>\n<td><code>C</code></td>\n<td><strong>Changed（修改）</strong></td>\n<td>文件或目录是已有的，但内容或元数据（如权限、时间戳等）被修改了</td>\n</tr>\n<tr>\n<td><code>D</code></td>\n<td><strong>Deleted（删除）</strong></td>\n<td>文件或目录是存在于原镜像中的，但在容器中被删除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-commit-从容器创建一个新的镜像\"><code>docker commit</code> : 从容器创建一个新的镜像</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker commit &lt;container_id | container_name&gt; [image_name[:tag]]</span></span><br><span class=\"line\">docker commit nginx nginx:v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-export-导出容器内容为-tar-文件\"><code>docker export</code> : 导出容器内容为 tar 文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">export</span> nginx &gt; nginx.tar</span><br><span class=\"line\">dcoker <span class=\"built_in\">export</span> -o nginx.tar nginx</span><br><span class=\"line\">docker <span class=\"built_in\">export</span> nginx | gzip &gt; nginx.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Export / Save / Commit 命令对比与导入方式一览表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作对象</th>\n<th>输出内容</th>\n<th>是否包含历史层（镜像层）</th>\n<th>是否保留元数据（标签、命令等）</th>\n<th>典型用途</th>\n<th>导入命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker export</code></td>\n<td><strong>容器</strong></td>\n<td>容器的文件系统（tar 归档）</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>备份容器文件系统或迁移容器状态</td>\n<td><code>docker import &lt;tar&gt; &lt;image:tag&gt;</code></td>\n</tr>\n<tr>\n<td><code>docker save</code></td>\n<td><strong>镜像</strong></td>\n<td>镜像的完整内容（含所有层的 tar）</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>分发或备份镜像</td>\n<td><code>docker load &lt; &lt;tar&gt;</code></td>\n</tr>\n<tr>\n<td><code>docker commit</code></td>\n<td><strong>容器</strong></td>\n<td>创建一个新的镜像</td>\n<td>✅ 是（但只一层）</td>\n<td>✅ 是</td>\n<td>将当前容器状态打包成新镜像</td>\n<td>不适用（直接生成镜像）</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Docker 命令 中 容器管理 相关命令 Docker官方文档 容器的生命周期 容器可能处于以下几种状态： 初建（created） 运行（running） 暂停（paused） 停止（stopped） 删除（deleted） 各生命周期之间的转换关系如图所示： 命令/情况 说明 容器状态变更 docker create 创建容器后，不立即启动运行，容器进入初建状态 初建状态 docker run 创建容器，并立即启动运行，进入运行状态 初建 → 运行 docker start 启动已创建的容器，容器转为运行状态 停止 → 运行 docker stop 停止正在运行的容器，容器转入停止状态 运行 → 停止 docker kill 强制终止容器，相当于“断电”，容易丢失数据，不建议轻易使用 运行 → 停止（非正常） docker restart 重启容器，容器重新进入运行状态 运行 → 停止 → 运行 docker pause 暂停容器内所有进程，容器进入暂停状态 运行 → 暂停 docker unpause 取消暂停状态，容器恢复运行 暂停 → 运行 docker rm 删除容器，容器转入删除状态 任意 → 删除 Killed by out-of-memory (OOM) 宿主机内存耗尽，容器被系统终止，此为非计划终止；建议杀死内存占用最高的容器 运行 → 停止（异常） Container process exited 容器进程异常终止后，进入“是否重启”判断流程：是则执行 start 进入运行；否则保持停止状态 异常 → 停止或运行 docker container : 容器管理 docker container --help 命令 说明 别名 attach 将本地的标准输入、输出和错误流附加到一个正在运行的容器上 docker attach commit 根据容器的更改创建一个新的镜像 docker commit cp 在容器和本地文件系统之间复制文件/文件夹 docker cp create 创建一个新的容器 docker create diff 检查容器文件系统上的文件或目录的更改 docker diff exec 在正在运行的容器中执行命令 docker exec export 将容器的文件系统导出为 tar 归档文件 docker export inspect 显示一个或多个容器的详细信息 可以使用 docker inspect kill 终止一个或多个正在运行的容器 docker kill logs 获取容器的日志 docker logs ls 列出容器 docker ps pause 暂停一个或多个容器内的所有进程 docker pause port 列出容器的端口映射或特定的端口映射 docker port prune 删除所有已停止的容器 rename 重命名一个容器 docker rename restart 重启一个或多个容器 docker restart rm 删除一个或多个容器 docker rm run 根据镜像创建并运行一个新容器 docker run start 启动一个或多个已停止的容器 docker start stats 实时显示容器资源使用统计信息 docker stats stop 停止一个或多个正在运行的容器 docker stop top 显示容器中运行的进程 docker top unpause 取消暂停一个或多个容器内的所有进程 docker unpause update 更新一个或多个容器的配置 docker update wait 阻塞直到一个或多个容器停止，然后打印其退出代码 docker wait 运行 docker container COMMAND --help 可获取某个命令的更多信息。 docker create : 创建容器，但不启动 1234567$ docker create \\ --name my-container \\ # 容器名 -e MY_ENV_VAR=my-value \\ # 设置环境变量 -p 80:80 \\ # 映射端口，格式：宿主机端口:容器端口 -v /path/to/my/dir:/path/in/container \\ # 映射目录，格式：宿主机目录:容器目录，都必须是绝对路径 --restart always \\ # 设置重启策略 nginx:latest \\ # 镜像名，镜像不存在时会自动下载 docker create 与 docker run 的参数基本一致，具体查看下面 docker run 中的介绍。 docker start : 启动一个容器 启动一个容器，容器必须已经创建，并且处于停止状态。 12# 语法：docker start &lt;container_id|container_name&gt;$ docker start my-container docker run : 创建并启动一个容器 相当于docker create + docker start 常用参数说明 参数 说明 示例 -d, --detach 后台运行容器（即“守护态”），run独有 docker run -d nginx -it 交互式运行容器并分配终端（常用于调试） docker run -it ubuntu bash --name 指定容器名称 docker run --name my-nginx nginx --rm 容器退出时自动删除 docker run --rm ubuntu -p, --publish 端口映射（宿主机:容器） docker run -p 8080:80 nginx -P, --publish-all 自动随机映射容器内部所有暴露端口到宿主机端口 docker run -P nginx -v, --volume 挂载卷（宿主机目录:容器目录） docker run -v /data:/app/data myapp --mount 更灵活的挂载方式（推荐新项目使用） docker run --mount type=bind,source=/host,target=/container nginx --env, -e 设置环境变量 docker run -e ENV=prod myapp --env-file 从文件中加载多个环境变量 docker run --env-file .env myapp --network 设置容器使用的网络模式 docker run --network host myapp --restart 设置容器的自动重启策略 docker run --restart=always myapp --privileged 给予容器更多的权限（如访问 host 设备） docker run --privileged myapp --entrypoint 覆盖镜像默认的 ENTRYPOINT docker run --entrypoint /bin/bash myapp -u, --user 指定容器内运行的用户（格式：UID 或 UID:GID） docker run --user 1000:1000 myapp -c, --cpu-shares 设置 CPU 权重（相对值） docker run --cpu-shares=512 myapp -m, --memory 限制容器最大内存（如 512m, 1g） docker run --memory=512m myapp -h, --hostname 设置容器主机名 docker run -h myhost myapp --link(更推荐使用 --network) 创建链接到其他容器 docker run --link myapp:app myapp2 --cpus 限制容器使用的CPU核数 docker run --cpus=&quot;1.5&quot; -p, --publish 端口映射 1docker run -p [主机IP:]主机端口:容器端口[/协议] 示例 含义说明 -p 8080:80 将主机的 8080 端口映射到容器的 80 端口（默认 TCP） -p 127.0.0.1:8080:80 仅将主机本地 IP（127.0.0.1）的 8080 映射到容器的 80 端口（外部无法访问） -p 8080:80/tcp 显式指定协议为 TCP（等同于不加 /tcp） -p 8080:80/udp 映射 UDP 协议端口（如 DNS 服务等） -p 8080 宿主机随机端口映射到容器的8080端口 -p 3000-3006:4000-4006 范围映射，不能映射非对称范围（如 3000-3006:4000-4006），只能一一对应 多个 -p 可以多次使用 -p，映射多个端口。例如：-p 80:80 -p 443:443 -v, --volume 数据卷映射 123456789101112131415161718docker run -v &lt;本地路径&gt;:&lt;容器路径&gt;[:权限] # &lt;本地路径&gt; 主机上的路径（绝对路径，或命名卷），目录不存在会自动创建 # &lt;容器路径&gt; 容器内的路径，目录不存在会自动创建 # [:权限] 可选：ro（只读） 或 rw（读写，默认）# 示例# 挂载本地目录到容器docker run -v /data:/app/data myapp# 挂载为只读docker run -v /data:/app/data:ro myapp# 挂载多个数据卷docker run -v /data1:/app/data1 -v /data2:/app/data2 myapp# 使用命名卷docker volume create mydatadocker run -v mydata:/app/data myapp --mount 挂载卷 12# --mount 是 Docker 推荐使用的 现代挂载方式，功能和 -v（或 --volume）类似，但语法更清晰、结构更规范，适用于卷（volume）、绑定挂载（bind）和临时挂载（tmpfs）。docker run --mount type=&lt;类型&gt;,source=&lt;主机路径或卷名&gt;,target=&lt;容器路径&gt;[,readonly] 三种挂载类型对比 类型 (type) 用途 示例 source volume 使用 Docker 管理的卷 卷名，如 mydata bind 挂载宿主机的实际路径 绝对路径，如 /home/user/app/config tmpfs 挂载内存中的临时文件系统 无需指定 source 12345678910# 使用命名卷挂载（推荐方式）,这里 --target 指定容器内的挂载点，也可以替换为 --destinationdocker run --mount type=volume,source=mydata,target=/app/data myapp# 使用本地路径挂载（绑定挂载）,source指定的本地路径必须存在docker run --mount type=bind,source=/home/user/app/config,target=/app/config myapp# 只读挂载，readonly 可以简写为 rodocker run --mount type=bind,source=/home/user/app/config,target=/app/config,readonly myapp# 使用内存中的临时文件系统挂载，数据不会持久化，只存储在容器运行时的内存中docker run --mount type=tmpfs,target=/app/tmpfs myapp --link 容器间链接 用于在容器之间建立连接，使一个容器可以通过另一个容器的名称访问其网络信息（如 IP、环境变量等）。 注意：--link 已被弃用，建议使用 --network 来实现容器间链接。 12345678910111213141516docker run --link &lt;目标容器名&gt;:&lt;别名&gt; &lt;其他参数&gt; &lt;镜像名&gt;## 示例# 场景：一个 web 容器想要连接另一个运行中的 db 容器# 先启动数据库容器docker run -d --name db mysql# 启动 web 容器并连接到 db 容器docker run -it --rm --name web --link db:mydb ubuntu bash# 在 web 容器中，现在你可以用 mydb 来访问 db 容器，但反过来 db 容器无法访问 web 容器docker exec web ping mydb## 改用 --network 实现docker network create mynetdocker run -d --name db --network mynet mysqldocker run -it --rm --name web --network mynet ubuntu bashdocker exec web ping db --network 网络模式类型 类型 含义 特点/适用场景 是否允许端口映射 bridge 默认网络类型（用户自定义或 Docker 默认桥接网络） 容器通过虚拟网桥连接，可相互通信；适用于单主机部署 ✅ 是 host 容器与宿主机共享网络栈 没有网络隔离，容器使用宿主机的 IP 和端口，性能高，适合对网络要求高的服务 ❌ 否 none 容器没有网络接口 完全隔离；适用于需要完全控制网络的场景或测试网络不可达性 ❌ 否 &lt;user-defined&gt; 用户自定义的网络名称，通过 docker network create 创建 支持容器名称互解析（DNS），适合多容器通信场景，如 Docker Compose ✅ 是 container:&lt;name|id&gt; 与另一个容器共享网络命名空间 两个容器共享 IP 和端口，适用于主-辅容器模式，如 sidecar 容器共享主容器网络 ❌ 否 123456789101112131415# 使用默认 bridge 网络docker run -p 8080:80 --network bridge --name my-nginx nginx# 与宿主机共享网络，不能使用-pdocker run --network host nginx# 不使用任何网络，不能使用-pdocker run --network none nginx# 使用已创建的自定义网络，相同网络命名空间下的容器，可以通过容器 名称或ID 互相访问docker network create nginx_netdocker run -p 8080:80 --network nginx_net nginx# 与另一个容器共享网络命名空间，不能使用-p，并且此时新启动的容器占用的端口不能与要连接的容器端口一致，否则将启动失败docker run --network container:my-nginx busybox --restart 重启策略 策略 含义 no（默认） 容器退出后不会自动重启 always 无论退出状态码如何，容器总是自动重启 unless-stopped 容器总是自动重启，除非用户手动停止它 on-failure[:N] 仅在容器非 0 状态码退出时自动重启（可选设置最大重启次数 N） 1234567891011# 容器非正常退出时自动重启docker run --restart on-failure my-app# 最多重启 5 次docker run --restart on-failure:5 my-app# 总是重启（即使你重启 Docker 服务后）docker run --restart always my-app# 除非手动停止，否则一直重启docker run --restart unless-stopped my-app --cpu-shares : 设置容器的 CPU 相对权重，即在 CPU 资源竞争时的相对优先级，默认值为 1024。 12345678910111213# 容器1，权重 1024（默认）docker run -d --name c1 --cpu-shares 1024 nginx# 容器2，权重 512（优先级低）docker run -d --name c2 --cpu-shares 512 nginx## 说明： # c1的权重1024，c2的权重512,不是绝对限制，而是分配比例 # 该权重表示容器在 CPU 竞争下，权重越高则优先级越高，会尽可能使用 CPU 资源。 # 如果这两个容器都运行在 CPU 忙碌的环境下(只有在 多容器共享 CPU 且竞争资源 的情况下才生效)： # c1 将获得大约 2/3 的 CPU 时间 # c2 将获得大约 1/3 的 CPU 时间 # 如果系统 CPU 空闲，所有容器都可以使用 100% 的 CPU。 docker run 示例 12345678910111213# 启动一个nginx 容器docker run -d -p 80:80 --name nginx nginx# 替换nginx镜像默认的启动命令，nginx 镜像默认启动 nginx 服务，此命令会改为执行 nginx -v 显示版本号docker run --name test_nginx --entrypoint &quot;&quot; nginx nginx -v# 执行脚本或命令，这里添加 --rm 参数，表示运行结束后自动删除容器，这里是安装 ping 命令docker run --rm ubuntu bash -c &quot;apt update &amp;&amp; apt install -y iputils-ping&quot;# 交互式执行 shell 命令，执行命令后会进入容器的shelldocker run --rm -it ubuntu /bin/bash# 这样也可以，因为 ubuntu 的默认启动命令是 /bin/bashdocker run --rm -it ubuntu# 转到后台运行docker run --rm -itd ubuntu docker stop : 停止容器，容器优雅退出 12345678# 停止容器，通过容器名称docker stop test_nginx# 停止容器，通过容器IDdocker stop 5d7c0c5d5c0c# 停止所有正在运行的容器docker stop $(docker ps -q)# 等待5秒后强制关闭docker stop -t 5 test_nginx docker kill : 强制停止容器 当容器完全卡死、挂起、不响应 stop 命令时使用 123docker kill test_nginxdocker kill 5d7c0c5d5c0cdocker kill $(docker ps -q) docker restart : 重启容器 123docker restart test_nginxdocker restart 5d7c0c5d5c0cdocker restart $(docker ps -q) docker pause : 暂停容器 暂停后宿主机将不再为容器分配CPU时间片，但内存依然有效，你可以理解为此时为容器保存了快照 123docker pause test_nginxdocker pause 5d7c0c5d5c0cdocker pause $(docker ps -q) docker unpause : 恢复容器 123docker unpause test_nginxdocker unpause 5d7c0c5d5c0cdocker unpause $(docker ps -q) docker ps : 查看容器列表 1234567891011121314# 显示所有正在运行的容器docker ps# 显示所有容器docker ps -a# 显示所有正在运行的容器的IDdocker ps -q# 不截断输出，此时 COMMAND 列会显示完整的命令docker ps -notrunc# 显示最近创建的5条容器docker ps -n 5# 过滤器，显示状态为exited的容器docker ps -a --filter &quot;status=exited&quot;# 指定模板，只显示 ID 和 Namesdocker ps --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot; docker inspect : 查看容器信息 12345678910111213141516# 查看容器信息docker inspect &lt;container_id&gt;# 获取容器名称docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器镜像docker inspect --format=&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器环境变量docker inspect --format=&#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器状态，前面的 json 表示输出为 json 格式docker inspect --format=&#x27;&#123;&#123;json .State&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器内存限制docker inspect --format=&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器labeldocker inspect --format=&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器的网络信息docker inspect --format=&#x27;&#123;&#123;json .NetworkSettings&#125;&#125;&#x27; &lt;container_id | container_name&gt; docker logs : 获取容器日志 12345678910111213141516# 获取容器日志docker logs &lt;container_id | container_name&gt;# 获取容器实时日志docker logs -f &lt;container_id | container_name&gt;# 获取容器最新的 10 行日志docker logs -n 10 &lt;container_id | container_name&gt;# 获取容器的带时间戳的日志docker logs -t &lt;container_id | container_name&gt;# 获取容器的日志，从 1 小时前开始docker logs --since 1h &lt;container_id | container_name&gt;# 获取容器的日志，直到 1 小时前docker logs --until 1h &lt;container_id | container_name&gt;# 获取容器的详细日志docker logs --details &lt;container_id | container_name&gt;# 获取容器的日志，从 2 小时前开始，直到 1 小时前docker logs --since 2h --until 1h &lt;container_id | container_name&gt; docker exec : 在已经运行的容器中执行命令 1234# 在已经运行的容器中执行命令docker exec &lt;container_id | container_name&gt; &lt;command&gt;# 进入容器shelldocker exec -it &lt;container_id | container_name&gt; bash docker rename : 重命名容器 1docker rename &lt;old_container_name&gt; &lt;new_container_name&gt; docker cp : 容器与宿主机间复制文件 123456# 宿主机 -&gt; 容器# docker cp &lt;host_path&gt; &lt;container_id | container_name&gt;:&lt;container_path&gt;docker cp ./docker-command-container.md nginx:/tmp# 容器 -&gt; 宿主机# docker cp &lt;container_id | container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;docker cp nginx:/tmp/docker-command-container.md ./ docker rm : 删除容器 1234# 删除指定容器docker rm &lt;container_id | container_name&gt;# 删除所有容器docker rm $(docker ps -aq) docker container prune : 删除所有停止的容器 1docker container prune docker update : 更新容器配置 1234# 更新指定容器的CPU核数和内存大小docker update --cpus=2 --memory=2g &lt;container_id | container_name&gt;# 更新指定容器自动重启docker update --restart=always &lt;container_id | container_name&gt; 并不是所有的配置都支持更新，update 命令只支持如下配置，基本上也就只能调一下cpu和内存，以及自动重启策略，所以制作容器时一定要做好规划。 参数名 说明 示例值 --blkio-weight 设置 Block IO 的相对权重，范围是 10 到 1000，设置为 0 表示禁用（默认值为 0） --blkio-weight=500 --cpu-period 设置 CPU CFS（完全公平调度器）的周期限制（单位：微秒） --cpu-period=100000 --cpu-quota 设置 CPU CFS 的配额限制（单位：微秒） --cpu-quota=50000 --cpu-rt-period 设置实时 CPU 的调度周期（单位：微秒） --cpu-rt-period=1000000 --cpu-rt-runtime 设置实时 CPU 的运行时间限制（单位：微秒） --cpu-rt-runtime=950000 -c, --cpu-shares 设置 CPU 共享权重，默认值为 1024 --cpu-shares=512 --cpus 限制容器使用的 CPU 数量（支持小数） --cpus=1.5 --cpuset-cpus 指定容器可以在哪些 CPU 上运行（如 0-3、0,1） --cpuset-cpus=&quot;0,1&quot; --cpuset-mems 指定容器可以使用哪些内存节点（如 0-3、0,1），适用于 NUMA 系统 --cpuset-mems=&quot;0&quot; -m, --memory 设置内存限制（例如 512m、2g） --memory=1g --memory-reservation 设置内存软限制（低于 --memory 的值时，允许系统在压力较小时回收） --memory-reservation=512m --memory-swap 设置 swap 限制（内存 + swap 总和），设为 -1 表示无限制 --memory-swap=2g --pids-limit 设置容器的最大进程数量，设为 -1 表示无限制 --pids-limit=100 --restart 设置容器退出后的重启策略 --restart=always docker stats : 显示容器的实时资源使用情况 12345678910111213141516171819202122232425262728# 显示所有容器的实时资源使用情况docker stats## 输出CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS15caf520e3a5 nginx 0.00% 10.22MiB / 7.752GiB 0.13% 6.38kB / 2.61kB 0B / 28.7kB 13b680087420b8 dockge 0.01% 199.5MiB / 7.752GiB 2.51% 6.44kB / 1.48kB 94.8MB / 0B 24861dd9c1475f remote-api 0.00% 4.188MiB / 7.752GiB 0.05% 2.77kB / 126B 3.31MB / 0B 1### CONTAINER ID 与 NAME：容器 ID 与名称。### CPU % 与 MEM %：容器使用的 CPU 和内存的百分比。### MEM USAGE / LIMIT：容器正在使用的总内存，以及允许使用的内存总量。### NET I/O：容器通过其网络接口发送和接收的数据量。### BLOCK I/O：容器从主机上的块设备读取和写入的数据量。### PIDs：容器创建的进程或线程数。# 列出所有容器的资源使用情况，包括运行和停止的docker stats -a# 展示当前状态就直接退出了，不再实时更新。docker stats --no-stream# 指定输出模板，这里加不加 table 都可以docker stats --no-stream --format &quot;table &#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.CPUPerc&#125;&#125;\\t&#123;&#123;.MemUsage&#125;&#125;&quot;# 输出json格式docker stats --no-stream --format json# 指定容器docker stats &lt;container_id | container_name&gt; docker top : 查看正在运行的进程 12# docker top &lt;container_id | container_name&gt; [ps options]docker top nginx docker port : 列出指定的容器的端口映射 123# docker port &lt;container_id | container_name&gt;$ docker port nginx80/tcp -&gt; 0.0.0.0:8081 docker diff : 列出容器运行时对文件系统的修改 1234567891011121314151617181920# docker diff &lt;container_id | container_name&gt;$ docker diff nginxC /rootA /root/.bash_historyC /runA /run/nginx.pidC /tmpA /tmp/demo.pyC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_tempC /etcC /etc/nginxC /etc/nginx/conf.dC /etc/nginx/conf.d/default.conf 前缀含义说明： 标志 含义 说明 A Added（新增） 文件或目录是容器运行后新增的 C Changed（修改） 文件或目录是已有的，但内容或元数据（如权限、时间戳等）被修改了 D Deleted（删除） 文件或目录是存在于原镜像中的，但在容器中被删除 docker commit : 从容器创建一个新的镜像 12# docker commit &lt;container_id | container_name&gt; [image_name[:tag]]docker commit nginx nginx:v1.0 docker export : 导出容器内容为 tar 文件 123docker export nginx &gt; nginx.tardcoker export -o nginx.tar nginxdocker export nginx | gzip &gt; nginx.tar.gz Docker Export / Save / Commit 命令对比与导入方式一览表 命令 操作对象 输出内容 是否包含历史层（镜像层） 是否保留元数据（标签、命令等） 典型用途 导入命令 docker export 容器 容器的文件系统（tar 归档） ❌ 否 ❌ 否 备份容器文件系统或迁移容器状态 docker import &lt;tar&gt; &lt;image:tag&gt; docker save 镜像 镜像的完整内容（含所有层的 tar） ✅ 是 ✅ 是 分发或备份镜像 docker load &lt; &lt;tar&gt; docker commit 容器 创建一个新的镜像 ✅ 是（但只一层） ✅ 是 将当前容器状态打包成新镜像 不适用（直接生成镜像）","summary":"摘要 本文介绍 Docker 命令 中 容器管理 相关命令 Docker官方文档","date_published":"2025-05-27T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/","url":"https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/","title":"Docker 命令 之 Dockerfile","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 Dockerfile 的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/reference/builder/\">Dockerfile官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Dockerfile-是什么？\">Dockerfile 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker可以通过读取 <code>Dockerfile</code> 中的指令来自动构建镜像。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Dockerfile</code> 是一个文本文档，其中包含用户可以在命令行上调用以组装镜像的所有指令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以在Dockerfile中使用的指令：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ADD</strong></td>\n<td>将本地或远程的文件/目录添加到镜像中，支持自动解压 <code>.tar</code> 文件和使用 URL 下载远程资源。通常推荐使用 <code>COPY</code>，除非需要这些高级功能。</td>\n</tr>\n<tr>\n<td><strong>ARG</strong></td>\n<td>定义构建阶段使用的变量，可在 <code>docker build</code> 命令中通过 <code>--build-arg</code> 传入，变量仅在构建时有效，不会保留在最终镜像中。</td>\n</tr>\n<tr>\n<td><strong>CMD</strong></td>\n<td>指定容器默认执行的命令和参数，容器运行时若未指定命令，则使用该指令设置的命令。如果配置了多个<code>CMD</code>，则只有最后一个生效。和<code>ENTRYPOINT</code>共同使用时，作为传递给<code>ENTRYPOINT</code>的参数。可被 <code>docker run</code> 提供的命令覆盖。</td>\n</tr>\n<tr>\n<td><strong>COPY</strong></td>\n<td>将构建上下文中的文件或目录复制到镜像中。相比 <code>ADD</code> 更简单、安全，推荐优先使用。</td>\n</tr>\n<tr>\n<td><strong>ENTRYPOINT</strong></td>\n<td>指定容器启动时的主命令，不容易被 <code>docker run</code> 中的命令覆盖。可与 <code>CMD</code> 配合使用，用于提供默认参数。</td>\n</tr>\n<tr>\n<td><strong>ENV</strong></td>\n<td>设置环境变量，变量将在构建和容器运行时均可使用。例如：配置应用参数或系统路径等。</td>\n</tr>\n<tr>\n<td><strong>EXPOSE</strong></td>\n<td>声明容器运行时将开放的端口，仅用于文档说明或与容器编排工具配合，不会自动进行端口映射。</td>\n</tr>\n<tr>\n<td><strong>FROM</strong></td>\n<td>指定基础镜像，是 Dockerfile 的起点。也可以用于多阶段构建，通过多次使用 <code>FROM</code> 指令创建多个构建阶段。</td>\n</tr>\n<tr>\n<td><strong>HEALTHCHECK</strong></td>\n<td>定义容器健康检查命令，用于定期检测容器内部服务的健康状态，可结合容器编排系统实现故障自动恢复。</td>\n</tr>\n<tr>\n<td><strong>LABEL</strong></td>\n<td>为镜像添加键值对形式的元数据，例如版本、维护者、用途说明等，方便镜像管理与自动化处理。</td>\n</tr>\n<tr>\n<td><strong>MAINTAINER</strong></td>\n<td>（已弃用）用于指定镜像维护者信息，推荐改用 <code>LABEL</code> 来设置作者信息。</td>\n</tr>\n<tr>\n<td><strong>ONBUILD</strong></td>\n<td>定义一个触发指令，当当前镜像作为基础镜像被其他 Dockerfile 使用时自动执行。常用于基础镜像的预设行为。</td>\n</tr>\n<tr>\n<td><strong>RUN</strong></td>\n<td>执行一条命令并提交结果作为新镜像层，常用于安装软件包、复制文件、设置权限等构建操作。</td>\n</tr>\n<tr>\n<td><strong>SHELL</strong></td>\n<td>更改 Dockerfile 中后续 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 等指令的默认 shell（如使用 <code>sh</code> 或 <code>powershell</code>）。</td>\n</tr>\n<tr>\n<td><strong>STOPSIGNAL</strong></td>\n<td>设置容器终止时发送的系统信号（如 <code>SIGTERM</code>），用于优雅关闭应用。</td>\n</tr>\n<tr>\n<td><strong>USER</strong></td>\n<td>设置执行后续命令时所使用的用户和用户组，增强容器的安全性，避免使用 root 权限。</td>\n</tr>\n<tr>\n<td><strong>VOLUME</strong></td>\n<td>定义容器内的挂载点，用于持久化数据或与宿主机/其他容器共享数据。运行容器时可指定挂载路径。</td>\n</tr>\n<tr>\n<td><strong>WORKDIR</strong></td>\n<td>设置工作目录，相当于执行 <code>cd</code>，用于简化后续命令中的路径。若目录不存在则自动创建。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建阶段指令：FROM, ARG, ENV, COPY, ADD, RUN, WORKDIR, LABEL, USER, SHELL, ONBUILD</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动配置指令：CMD, ENTRYPOINT, HEALTHCHECK, EXPOSE, VOLUME, STOPSIGNAL</p>\n</li>\n</ul>\n<h2 id=\"Dockerfile-指令介绍\">Dockerfile 指令介绍</h2>\n<h3 id=\"FROM\">FROM</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FROM 指令用于指定基础镜像（base image），是每一个 Dockerfile 中必须的第一条指令。所有后续指令都是基于这个基础镜像构建的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;stage-name&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;image&gt;：镜像名称（可以是本地已有的，也可以是从 Docker Hub 或其他镜像仓库拉取的）</span></span><br><span class=\"line\"><span class=\"comment\">#   [:&lt;tag&gt;]：镜像标签（可选，默认是 latest）</span></span><br><span class=\"line\"><span class=\"comment\">#   [AS &lt;stage-name&gt;]：为该构建阶段指定名称，用于多阶段构建</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用最新版本的镜像（默认标签是 latest）</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node</span><br><span class=\"line\"><span class=\"comment\"># 使用指定的标签</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">16.13</span>.<span class=\"number\">2</span>-alpine</span><br><span class=\"line\"><span class=\"comment\"># 使用私有镜像仓库</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> private.registry.com/my-image:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用多阶段构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.20</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go build -o myapp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /app/myapp /usr/local/bin/myapp</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;myapp&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\">## 这里用了两个阶段：</span></span><br><span class=\"line\"><span class=\"comment\">###   builder 阶段用来编译应用；</span></span><br><span class=\"line\"><span class=\"comment\">###   alpine 阶段用来打包最终镜像，只包含编译好的二进制文件，减少体积。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"WORKDIR\">WORKDIR</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>WORKDIR 指定了工作目录，即后续所有指令（如 RUN、CMD、ENTRYPOINT、COPY、ADD 等）所运行的当前路径（working directory）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果目录不存在，Docker 会自动创建它。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个 WORKDIR 都会创建一层镜像（layer），所以不要重复设置无意义的路径。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &lt;path&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;path&gt;：要切换的工作目录，可以是绝对路径或相对路径。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置绝对路径</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连续设置多个工作目录（逐层嵌套）</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /var</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> www</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> html</span></span><br><span class=\"line\"><span class=\"comment\"># 等同于:</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /var/www/html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 避免在 RUN cd some_dir 后继续执行依赖路径的命令，因为 Docker 每一条指令都是新的 shell 实例，cd 不会跨指令保留，应该改用 WORKDIR。</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> some_dir  <span class=\"comment\"># 错误</span></span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> some_dir <span class=\"comment\"># 正确</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ARG\">ARG</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ARG 用于在 构建镜像时（build-time）传入参数。这些参数只在 构建阶段有效，不会出现在最终镜像中，也不会在容器运行时被保留。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARG &lt;name&gt;[=&lt;default_value&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;name&gt;：参数名称</span></span><br><span class=\"line\"><span class=\"comment\">#   [=&lt;default_value&gt;]：参数的默认值，如果未传入参数，则使用默认值，如果为设置default_value，则构建镜像时必须传递参数，--build-arg</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个参数，在构建镜像时必须传入参数，--build-arg APP_ENV=development</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> APP_ENV</span><br><span class=\"line\"><span class=\"comment\"># 带默认值的 ARG</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> APP_ENV=development</span><br><span class=\"line\"><span class=\"comment\"># 使用参数</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前环境：<span class=\"variable\">$&#123;APP_ENV&#125;</span>&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与 FROM 一起用（从 Docker 17.05 起）</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> BASE=ubuntu</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> $&#123;BASE&#125;:<span class=\"number\">22.04</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ENV\">ENV</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ENV 指令用于在镜像构建过程中定义环境变量（Environment Variables）。这些变量可以在之后的构建步骤（比如 RUN、CMD 等）中使用，也会在容器运行时生效。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两种语法</span></span><br><span class=\"line\">ENV &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">ENV &lt;key&gt;=&lt;value&gt; ...</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;key&gt;：环境变量的名称</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;value&gt;：环境变量的值</span></span><br><span class=\"line\"><span class=\"comment\"># 如果定义多个变量，推荐使用 key=value 的形式。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> APP_ENV=production</span><br><span class=\"line\"><span class=\"comment\"># 定义多个变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> APP_PORT=<span class=\"number\">8080</span> NODE_ENV=production</span><br><span class=\"line\"><span class=\"comment\"># 使用多行格式（提高可读性）</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH=<span class=\"string\">&quot;/usr/local/bin:$&#123;PATH&#125;&quot;</span> \\</span><br><span class=\"line\">    LANG=<span class=\"string\">&quot;en_US.UTF-8&quot;</span> \\</span><br><span class=\"line\">    TZ=<span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 也可以分开定义</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH=<span class=\"string\">&quot;/usr/local/bin:$PATH&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> LANG=<span class=\"string\">&quot;en_US.UTF-8&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=<span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注意：ENV 指令定义的环境变量在构建阶段和运行阶段都会生效，但运行阶段会覆盖构建阶段定义的变量。</p>\n</li>\n</ul>\n<h3 id=\"LABEL\">LABEL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LABEL 用于为镜像添加元数据标签，以 <code>key=value</code> 的形式存在。这些标签可以是作者信息、版本描述、用途说明、构建时间等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>旧的 <code>MAINTAINER</code> 指令现在已被废弃，推荐使用 <code>LABEL</code> 来代替。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个 LABEL 都会创建一层镜像（layer），推荐一次设置多个。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LABEL &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt;...]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;key&gt;：标签的键</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;value&gt;：标签的值</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加一个标签</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\"># 换行格式（推荐）,以下标签符合 OCI（Open Container Initiative） 镜像规范</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.title=<span class=\"string\">&quot;MyApp&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.description=<span class=\"string\">&quot;演示项目&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.version=<span class=\"string\">&quot;1.0.0&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.authors=<span class=\"string\">&quot;zhangsan@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"USER\">USER</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>USER 指令用于指定后续指令（如 RUN、CMD、ENTRYPOINT、COPY 等）以哪个用户身份来执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Docker 容器中的命令以 root 用户运行，这虽然灵活但不安全。使用 USER 可以让我们切换到普通用户，从而提升容器的安全性，防止潜在的权限滥用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">USER &lt;user&gt;[:&lt;group&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;user&gt;：用户名或 UID</span></span><br><span class=\"line\"><span class=\"comment\">#   [:&lt;group&gt;]：可选，用户组名或 GID</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置用户</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser</span><br><span class=\"line\"><span class=\"comment\"># 设置用户组</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser:appgroup</span><br><span class=\"line\"><span class=\"comment\"># 使用 UID 和 GID</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> <span class=\"number\">1000</span>:<span class=\"number\">1000</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果基础镜像中没有你想要的用户，需要在 Dockerfile 中手动创建</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户和组</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> groupadd -r appgroup &amp;&amp; useradd -r -g appgroup appuser</span></span><br><span class=\"line\"><span class=\"comment\"># 切换用户</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser</span><br></pre></td></tr></table></figure>\n<h3 id=\"ADD\">ADD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ADD 用于将本地文件或目录、远程文件（URL） 或 压缩包 复制到镜像中的指定位置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的功能类似于 COPY，但比 COPY 多几个功能（解压、拉取远程文件等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;src&gt;：要复制的文件或目录，可以是本地文件、远程 URL、压缩包等</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从本地文件复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 复制多个</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> app1.jar app2.jar /app/</span></span><br><span class=\"line\"><span class=\"comment\"># 通配符</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets/*.html /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 从远程 URL 复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> https://example.com/app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 从压缩包中复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets.tar.gz /app/public/</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最佳实践是优先使用 COPY，只有在需要 ADD 的额外功能时才使用它。</p>\n</li>\n</ul>\n<h3 id=\"COPY\">COPY</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>COPY 指令用于将主机上的文件或目录复制到镜像的文件系统中。它是构建镜像过程中最常用的数据引入方式之一。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 ADD 类似，但功能更简单、明确、安全</p>\n</li>\n<li class=\"lvl-2\">\n<p>推荐优先使用 COPY，除非你确实需要 ADD 提供的自动解压或远程下载功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;src&gt;：要复制的文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制单个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 复制多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app1.jar app2.jar /app/</span></span><br><span class=\"line\"><span class=\"comment\"># 复制目录</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> static-assets/ /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 通配符</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> static-assets/*.html /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 设置目标文件属主属组</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"built_in\">chown</span>=appuser:appgroup app.jar /app.jar</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RUN\">RUN</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RUN 指令用于在镜像构建阶段执行命令，结果会被打包进镜像层中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它可以用于安装依赖、编译代码、运行命令等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每一条 RUN 指令会创建一层镜像（layer）,合并多个命令成一条 RUN，可以减少镜像层数（例如使用 &amp;&amp; 串联）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一种格式：实际运行的是：/bin/sh -c &quot;&lt;命令字符串&gt;&quot;</span></span><br><span class=\"line\">RUN &lt;命令字符串&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二种格式</span></span><br><span class=\"line\">RUN [<span class=\"string\">&quot;可执行文件&quot;</span>, <span class=\"string\">&quot;参数1&quot;</span>, <span class=\"string\">&quot;参数2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令字符串</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"comment\"># 构建多个命令(用 &amp;&amp; 串联)</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y python3 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可执行文件参数</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;curl https://example.com/app.jar &gt; app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"CMD\">CMD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CMD 用于指定容器启动时默认执行的命令及其参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果用户在运行容器时没有手动指定其他命令，Docker 就会使用 CMD 提供的内容。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它可以定义多个，但只有最后一个会被使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Shell 形式（字符串）</span></span><br><span class=\"line\">CMD <span class=\"built_in\">command</span> param1 param2</span><br><span class=\"line\"><span class=\"comment\"># 等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式（数组）</span></span><br><span class=\"line\">CMD [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 简单 shell 命令</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from container&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 作为 ENTRYPOINT 的参数</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python3&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--host=0.0.0.0&quot;</span>, <span class=\"string\">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用户可以覆盖 CMD：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run &lt;myapp&gt; npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ENTRYPOINT\">ENTRYPOINT</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ENTRYPOINT 定义容器启动时执行的主命令，相比 CMD，它不容易被覆盖，更适合制作“专用型”容器（如 nginx、python 脚本等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>你可以把 ENTRYPOINT 理解为容器的“主程序”，而 CMD 是为它提供的默认“命令行参数”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Shell 形式（字符串）</span></span><br><span class=\"line\">ENTRYPOINT <span class=\"built_in\">command</span> param1 param2</span><br><span class=\"line\"><span class=\"comment\">#  等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式（数组）</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 简单 shell 命令</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from container&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合 CMD 使用</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python3&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--host=0.0.0.0&quot;</span>, <span class=\"string\">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"EXPOSE\">EXPOSE</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>EXPOSE 用于声明容器将会监听的端口，让使用该镜像的人知道应该对外开放哪些端口。</p>\n</li>\n<li class=\"lvl-2\">\n<p>⚠️ 注意：EXPOSE 并不会真的开放端口，只是“声明”这个容器监听了这些端口。</p>\n</li>\n<li class=\"lvl-2\">\n<p>要让端口真正暴露出来，还需要在运行容器时加上 <code>-p</code> 或 <code>--publish</code> 参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;port&gt;：端口号，可以是单个端口号，也可以是范围（如 8080-8085）</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;protocol&gt;：协议，可以是 tcp 或 udp，默认为 tcp</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span>/udp</span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span>-<span class=\"number\">8085</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span> <span class=\"number\">8081</span> <span class=\"number\">8082</span> <span class=\"number\">8083</span> <span class=\"number\">8084</span> <span class=\"number\">8085</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"VOLUME\">VOLUME</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>VOLUME 指令用于声明一个或多个容器中的挂载点（mount point），用于持久化数据或与宿主机/其他容器共享数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VOLUME [<span class=\"string\">&quot;/path/in/container&quot;</span>, ...]</span><br><span class=\"line\"><span class=\"comment\"># 路径必须是容器内部的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\"># 可以一次声明一个，也可以是多个。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 声明一个挂载点</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/public</span></span><br><span class=\"line\"><span class=\"comment\"># 声明多个挂载点</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/public&quot;</span>, <span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当容器运行时，可以将镜像中声明的挂载点映射到宿主机上，从而实现持久化数据。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /host/path:/app/public myimage</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你没有手动绑定挂载，Docker 会自动创建一个匿名卷，卷的内容默认保存在宿主机的 <code>/var/lib/docker/volumes</code> 下。</p>\n</li>\n</ul>\n<h3 id=\"HEALTHCHECK\">HEALTHCHECK</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HEALTHCHECK 用来定义容器运行时的健康检查命令，定期检测容器内服务的状态，帮助编排工具（Docker Swarm、Kubernetes 等）判断容器是否健康。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果健康检查失败，Docker 会将容器标记为 unhealthy，便于自动重启或替换。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HEALTHCHECK &lt;options&gt; CMD &lt;<span class=\"built_in\">command</span>&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;options&gt;：可选项，用于设置健康检查的选项，如超时时间、重试次数等。</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;command&gt;：健康检查命令，可以是任何有效的 shell 命令。</span></span><br><span class=\"line\">            <span class=\"comment\"># 必须返回退出码:</span></span><br><span class=\"line\">              <span class=\"comment\"># 0 表示健康</span></span><br><span class=\"line\">              <span class=\"comment\"># 1 表示不健康</span></span><br><span class=\"line\">              <span class=\"comment\"># 2 表示未知</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可选参数（OPTIONS）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--interval=DURATION</code></td>\n<td>两次健康检查之间的时间间隔</td>\n<td>30s</td>\n</tr>\n<tr>\n<td><code>--timeout=DURATION</code></td>\n<td>单次检测命令的超时时间</td>\n<td>30s</td>\n</tr>\n<tr>\n<td><code>--start-period=DURATION</code></td>\n<td>容器启动后，开始健康检查前的等待时间</td>\n<td>0s</td>\n</tr>\n<tr>\n<td><code>--retries=N</code></td>\n<td>连续失败几次后判定容器不健康</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 curl 检测 Web 服务是否响应</span></span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=5s --<span class=\"built_in\">timeout</span>=3s --retries=3 CMD curl -f http://localhost:8080/health || <span class=\"built_in\">exit</span> 1</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器后，可以用命令查看健康状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果镜像中有健康检查，可以查看容器状态（STATUS）</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\">  <span class=\"comment\"># STATUS 列会显示：</span></span><br><span class=\"line\">  <span class=\"comment\">#   healthy</span></span><br><span class=\"line\">  <span class=\"comment\">#   unhealthy</span></span><br><span class=\"line\">  <span class=\"comment\">#   starting（启动中）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看更详细的信息</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SHELL\">SHELL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SHELL 指令用来自定义后续 RUN、CMD 和 ENTRYPOINT 指令所使用的默认 shell 程序和参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">在 Linux 镜像中，Docker 使用 /bin/sh -c</li>\n<li class=\"lvl-4\">在 Windows 镜像中，使用 cmd /S /C</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>使用 SHELL，你可以替换为其他 shell，如 Bash、PowerShell、zsh 等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHELL [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 bash</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多次切换</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from Bash&quot;</span> <span class=\"comment\"># 在 Bash 中执行</span></span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Now back to sh&quot;</span> <span class=\"comment\">#  在 sh 中执行</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;powershell&quot;</span>, <span class=\"string\">&quot;-Command&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"STOPSIGNAL\">STOPSIGNAL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>STOPSIGNAL 指定当容器收到 <code>docker stop</code> 命令时，发送给容器主进程的信号类型。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Docker 会向容器的主进程发送 <code>SIGTERM</code> 信号，让它有机会优雅地退出（在超时时未退出则发 <code>SIGKILL</code> 强制终止）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况，大多数程序（如 nginx），不需要设置（默认 SIGTERM）</p>\n</li>\n<li class=\"lvl-2\">\n<p>但有些程序可能需要使用不同的信号，比如 SIGINT、SIGHUP，这时你可以通过 STOPSIGNAL 来修改。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STOPSIGNAL &lt;signal&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># 其中 &lt;signal&gt; 可以是：</span></span><br><span class=\"line\"><span class=\"comment\">#   信号名称，例如：SIGTERM、SIGKILL、SIGINT、SIGHUP</span></span><br><span class=\"line\"><span class=\"comment\">#   或信号编号，例如：15（等价于 SIGTERM）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是默认行为，不写也一样。</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGTERM</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改为 SIGINT</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGINT</span><br></pre></td></tr></table></figure>\n<h3 id=\"ONBUILD\">ONBUILD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ONBUILD 用于定义延迟执行的构建指令，即这些命令不会在当前 Dockerfile 构建时执行，而是在 以当前镜像为基础的子镜像中构建时触发执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的典型用途是：构建一个“通用基础镜像”，让使用者在自己的 Dockerfile 中 FROM 它时自动继承一些操作（比如 COPY、RUN 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ONBUILD 是一种设计模式，方便基础镜像作者预先定义“未来子镜像构建时一定要执行的步骤”，而不是在基础镜像中“硬编码”那些步骤。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ONBUILD &lt;INSTRUCTION&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;INSTRUCTION&gt;：必须是一个合法的 Dockerfile 指令，如 RUN、COPY、ADD、CMD 等（但不能是 FROM, ONBUILD, HEALTHCHECK 等）。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础镜像中使用 ONBUILD</span></span><br><span class=\"line\"><span class=\"comment\"># 文件：Dockerfile.base</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建基础镜像</span></span><br><span class=\"line\">docker build -t my-node-base -f Dockerfile.base .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用基础镜像构建子镜像</span></span><br><span class=\"line\"><span class=\"comment\"># 文件：Dockerfile（子镜像）</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> my-node-base</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;node&quot;</span>, <span class=\"string\">&quot;index.js&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 构建子镜像时，等于自动插入了：</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ONBUILD 是一种“构建钩子”机制</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">ONBUILD 可以理解成“钩子”或“触发器”：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">在基础镜像构建时不执行</li>\n<li class=\"lvl-6\">但当某人以这个基础镜像为起点写自己的 Dockerfile，并构建时，这些 ONBUILD 里的指令自动插入执行</li>\n</ul>\n</li>\n<li class=\"lvl-4\">这样：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">基础镜像只负责定义环境（node、npm版本、系统依赖等），保持轻量</li>\n<li class=\"lvl-6\">下游项目可以不用写重复的代码复制和安装指令，自动继承基础镜像预定义的构建步骤</li>\n<li class=\"lvl-6\">代码复制和依赖安装在下游镜像构建时执行，使用自己的上下文（也就是项目代码）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p><code>ONBUILD</code> 总结</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⏱ 延迟执行</td>\n<td>构建基础镜像时不会执行，在子镜像构建时触发</td>\n</tr>\n<tr>\n<td>✅ 支持指令</td>\n<td>例如 <code>RUN</code>, <code>COPY</code>, <code>ADD</code>, <code>CMD</code>, <code>WORKDIR</code>, <code>ENV</code> 等</td>\n</tr>\n<tr>\n<td>❌ 不支持</td>\n<td><code>FROM</code>, <code>ONBUILD</code>, <code>HEALTHCHECK</code>, <code>SHELL</code>, <code>STOPSIGNAL</code></td>\n</tr>\n<tr>\n<td>👎 不推荐滥用</td>\n<td>会隐藏构建行为，降低可维护性</td>\n</tr>\n<tr>\n<td>✅ 推荐场景</td>\n<td>团队共享模板、构建“标准开发镜像”</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dockerfile-哪些-指令-会创建新的层\">Dockerfile 哪些 指令 会创建新的层</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 Dockerfile 中创建新层的指令内容发生变化时，使用 <code>--no-cache</code> 选项可以确保这些变更被正确应用。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ADD</td>\n<td>从 <src> 复制文件并自动解压（如果是一个 tar 文件）到容器的 <dest> 路径。</td>\n</tr>\n<tr>\n<td>COPY</td>\n<td>从 <src> 复制文件到容器的 <dest> 路径，不会自动解压。</td>\n</tr>\n<tr>\n<td>RUN</td>\n<td>执行任意命令并在容器中做出更改。每条 RUN 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>设置环境变量。每一行 ENV 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>WORKDIR</td>\n<td>设置工作目录。每一行 WORKDIR 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>VOLUME</td>\n<td>创建一个挂载点。每一行 VOLUME 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>LABEL</td>\n<td>添加元数据标签。每一行 LABEL 指令都会创建一个新的层。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dockerfile-示例-Spring-Boot-应用\">Dockerfile 示例: Spring Boot 应用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>目录结构</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">springbootweb/</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── target/</span><br><span class=\"line\">│   └── app.jar</span><br><span class=\"line\">├── <span class=\"type\">static</span>-assets.tar.gz</span><br><span class=\"line\">└── ...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Dockerfile: 注意 Dockerfile 中所有关键字都要求大写</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> JAR_FILE=target/app.jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像元信息</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> version=<span class=\"string\">&quot;1.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> description=<span class=\"string\">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例 RUN：安装 curl（用于容器健康检查或调试）</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apk add --no-cache curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压静态资源到容器中（ADD 可以自动解压 tar.gz）</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets.tar.gz /app/public/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器健康检查：访问 actuator 健康端点</span></span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=30s --<span class=\"built_in\">timeout</span>=5s --retries=3 \\</span></span><br><span class=\"line\"><span class=\"language-bash\">  CMD curl -f http://localhost:8080/app/actuator/health || <span class=\"built_in\">exit</span> 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器终止时优雅关闭（Java 推荐 SIGTERM）</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGTERM</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建镜像时用 --build-arg 指定构建参数，如果需要多个，就配置多个 --build-arg</span></span><br><span class=\"line\">docker build --build-arg JAR_FILE=target/app.jar -t springbootweb:latest .</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name springbootweb \\</span><br><span class=\"line\">  -p 8080:8080 \\</span><br><span class=\"line\">  -e JAVA_OPTS=<span class=\"string\">&quot;-Xms512m -Xmx1024m&quot;</span> \\</span><br><span class=\"line\">  -v /home/centos/logs/app/:/app/logs \\</span><br><span class=\"line\">  springbootweb:latest</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dockerfile-示例-多阶段构建\">Dockerfile 示例: 多阶段构建</h2>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段：获取代码</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine/git AS fetcher</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_BRANCH=master</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;GIT_BRANCH&#125;</span> <span class=\"variable\">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段：使用Maven环境进行构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> maven:<span class=\"number\">3.8</span>.<span class=\"number\">4</span>-openjdk-<span class=\"number\">17</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段复制代码</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=fetcher /workspace/application .</span></span><br><span class=\"line\"><span class=\"comment\"># 使用Maven清理并打包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> mvn clean package -DskipTests</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三阶段：创建最终的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建</span></span><br><span class=\"line\">docker build --no-cache -t app:latest .</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name app \\</span><br><span class=\"line\">  -p 8080:8080 \\</span><br><span class=\"line\">  -e JAVA_OPTS=<span class=\"string\">&quot;-Xms512m -Xmx1024m&quot;</span> \\</span><br><span class=\"line\">  -v /home/centos/logs/app/:/app/logs \\</span><br><span class=\"line\">  app:latest</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 Dockerfile 的使用方法 Docker官方文档 Dockerfile官方文档 Dockerfile 是什么？ Docker可以通过读取 Dockerfile 中的指令来自动构建镜像。 Dockerfile 是一个文本文档，其中包含用户可以在命令行上调用以组装镜像的所有指令。 可以在Dockerfile中使用的指令： 指令 中文描述 ADD 将本地或远程的文件/目录添加到镜像中，支持自动解压 .tar 文件和使用 URL 下载远程资源。通常推荐使用 COPY，除非需要这些高级功能。 ARG 定义构建阶段使用的变量，可在 docker build 命令中通过 --build-arg 传入，变量仅在构建时有效，不会保留在最终镜像中。 CMD 指定容器默认执行的命令和参数，容器运行时若未指定命令，则使用该指令设置的命令。如果配置了多个CMD，则只有最后一个生效。和ENTRYPOINT共同使用时，作为传递给ENTRYPOINT的参数。可被 docker run 提供的命令覆盖。 COPY 将构建上下文中的文件或目录复制到镜像中。相比 ADD 更简单、安全，推荐优先使用。 ENTRYPOINT 指定容器启动时的主命令，不容易被 docker run 中的命令覆盖。可与 CMD 配合使用，用于提供默认参数。 ENV 设置环境变量，变量将在构建和容器运行时均可使用。例如：配置应用参数或系统路径等。 EXPOSE 声明容器运行时将开放的端口，仅用于文档说明或与容器编排工具配合，不会自动进行端口映射。 FROM 指定基础镜像，是 Dockerfile 的起点。也可以用于多阶段构建，通过多次使用 FROM 指令创建多个构建阶段。 HEALTHCHECK 定义容器健康检查命令，用于定期检测容器内部服务的健康状态，可结合容器编排系统实现故障自动恢复。 LABEL 为镜像添加键值对形式的元数据，例如版本、维护者、用途说明等，方便镜像管理与自动化处理。 MAINTAINER （已弃用）用于指定镜像维护者信息，推荐改用 LABEL 来设置作者信息。 ONBUILD 定义一个触发指令，当当前镜像作为基础镜像被其他 Dockerfile 使用时自动执行。常用于基础镜像的预设行为。 RUN 执行一条命令并提交结果作为新镜像层，常用于安装软件包、复制文件、设置权限等构建操作。 SHELL 更改 Dockerfile 中后续 RUN、CMD、ENTRYPOINT 等指令的默认 shell（如使用 sh 或 powershell）。 STOPSIGNAL 设置容器终止时发送的系统信号（如 SIGTERM），用于优雅关闭应用。 USER 设置执行后续命令时所使用的用户和用户组，增强容器的安全性，避免使用 root 权限。 VOLUME 定义容器内的挂载点，用于持久化数据或与宿主机/其他容器共享数据。运行容器时可指定挂载路径。 WORKDIR 设置工作目录，相当于执行 cd，用于简化后续命令中的路径。若目录不存在则自动创建。 构建阶段指令：FROM, ARG, ENV, COPY, ADD, RUN, WORKDIR, LABEL, USER, SHELL, ONBUILD 启动配置指令：CMD, ENTRYPOINT, HEALTHCHECK, EXPOSE, VOLUME, STOPSIGNAL Dockerfile 指令介绍 FROM FROM 指令用于指定基础镜像（base image），是每一个 Dockerfile 中必须的第一条指令。所有后续指令都是基于这个基础镜像构建的。 语法 12345FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;stage-name&gt;]# 说明：# &lt;image&gt;：镜像名称（可以是本地已有的，也可以是从 Docker Hub 或其他镜像仓库拉取的）# [:&lt;tag&gt;]：镜像标签（可选，默认是 latest）# [AS &lt;stage-name&gt;]：为该构建阶段指定名称，用于多阶段构建 示例 12345678910111213141516171819# 使用最新版本的镜像（默认标签是 latest）FROM node# 使用指定的标签FROM node:16.13.2-alpine# 使用私有镜像仓库FROM private.registry.com/my-image:latest# 使用多阶段构建FROM golang:1.20 AS builderWORKDIR /appCOPY . .RUN go build -o myappFROM alpine:latestCOPY --from=builder /app/myapp /usr/local/bin/myappENTRYPOINT [&quot;myapp&quot;]## 这里用了两个阶段：### builder 阶段用来编译应用；### alpine 阶段用来打包最终镜像，只包含编译好的二进制文件，减少体积。 WORKDIR WORKDIR 指定了工作目录，即后续所有指令（如 RUN、CMD、ENTRYPOINT、COPY、ADD 等）所运行的当前路径（working directory）。 如果目录不存在，Docker 会自动创建它。 每个 WORKDIR 都会创建一层镜像（layer），所以不要重复设置无意义的路径。 语法 123WORKDIR &lt;path&gt;# 说明：# &lt;path&gt;：要切换的工作目录，可以是绝对路径或相对路径。 示例 12345678910111213# 设置绝对路径WORKDIR /app# 连续设置多个工作目录（逐层嵌套）WORKDIR /varWORKDIR wwwWORKDIR html# 等同于:WORKDIR /var/www/html# 避免在 RUN cd some_dir 后继续执行依赖路径的命令，因为 Docker 每一条指令都是新的 shell 实例，cd 不会跨指令保留，应该改用 WORKDIR。RUN cd some_dir # 错误WORKDIR some_dir # 正确 ARG ARG 用于在 构建镜像时（build-time）传入参数。这些参数只在 构建阶段有效，不会出现在最终镜像中，也不会在容器运行时被保留。 语法 1234ARG &lt;name&gt;[=&lt;default_value&gt;]# 说明：# &lt;name&gt;：参数名称# [=&lt;default_value&gt;]：参数的默认值，如果未传入参数，则使用默认值，如果为设置default_value，则构建镜像时必须传递参数，--build-arg 示例 12345678910# 定义一个参数，在构建镜像时必须传入参数，--build-arg APP_ENV=developmentARG APP_ENV# 带默认值的 ARGARG APP_ENV=development# 使用参数RUN echo &quot;当前环境：$&#123;APP_ENV&#125;&quot;# 与 FROM 一起用（从 Docker 17.05 起）ARG BASE=ubuntuFROM $&#123;BASE&#125;:22.04 ENV ENV 指令用于在镜像构建过程中定义环境变量（Environment Variables）。这些变量可以在之后的构建步骤（比如 RUN、CMD 等）中使用，也会在容器运行时生效。 语法 1234567# 两种语法ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...# 说明：# &lt;key&gt;：环境变量的名称# &lt;value&gt;：环境变量的值# 如果定义多个变量，推荐使用 key=value 的形式。 示例 123456789101112# 定义一个环境变量ENV APP_ENV=production# 定义多个变量ENV APP_PORT=8080 NODE_ENV=production# 使用多行格式（提高可读性）ENV PATH=&quot;/usr/local/bin:$&#123;PATH&#125;&quot; \\ LANG=&quot;en_US.UTF-8&quot; \\ TZ=&quot;Asia/Shanghai&quot;# 也可以分开定义ENV PATH=&quot;/usr/local/bin:$PATH&quot;ENV LANG=&quot;en_US.UTF-8&quot;ENV TZ=&quot;Asia/Shanghai&quot; 注意：ENV 指令定义的环境变量在构建阶段和运行阶段都会生效，但运行阶段会覆盖构建阶段定义的变量。 LABEL LABEL 用于为镜像添加元数据标签，以 key=value 的形式存在。这些标签可以是作者信息、版本描述、用途说明、构建时间等。 旧的 MAINTAINER 指令现在已被废弃，推荐使用 LABEL 来代替。 每个 LABEL 都会创建一层镜像（layer），推荐一次设置多个。 语法 1234LABEL &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt;...]# 说明：# &lt;key&gt;：标签的键# &lt;value&gt;：标签的值 示例 12345678# 添加一个标签LABEL maintainer=&quot;yourname@example.com&quot;# 换行格式（推荐）,以下标签符合 OCI（Open Container Initiative） 镜像规范LABEL \\ org.opencontainers.image.title=&quot;MyApp&quot; \\ org.opencontainers.image.description=&quot;演示项目&quot; \\ org.opencontainers.image.version=&quot;1.0.0&quot; \\ org.opencontainers.image.authors=&quot;zhangsan@example.com&quot; USER USER 指令用于指定后续指令（如 RUN、CMD、ENTRYPOINT、COPY 等）以哪个用户身份来执行。 默认情况下，Docker 容器中的命令以 root 用户运行，这虽然灵活但不安全。使用 USER 可以让我们切换到普通用户，从而提升容器的安全性，防止潜在的权限滥用。 语法 1234USER &lt;user&gt;[:&lt;group&gt;]# 说明：# &lt;user&gt;：用户名或 UID# [:&lt;group&gt;]：可选，用户组名或 GID 示例 123456# 设置用户USER appuser# 设置用户组USER appuser:appgroup# 使用 UID 和 GIDUSER 1000:1000 如果基础镜像中没有你想要的用户，需要在 Dockerfile 中手动创建 1234# 创建用户和组RUN groupadd -r appgroup &amp;&amp; useradd -r -g appgroup appuser# 切换用户USER appuser ADD ADD 用于将本地文件或目录、远程文件（URL） 或 压缩包 复制到镜像中的指定位置。 它的功能类似于 COPY，但比 COPY 多几个功能（解压、拉取远程文件等）。 语法 1234ADD &lt;src&gt;... &lt;dest&gt;# 说明：# &lt;src&gt;：要复制的文件或目录，可以是本地文件、远程 URL、压缩包等# &lt;dest&gt;：目标路径 示例 12345678910# 从本地文件复制ADD app.jar /app.jar# 复制多个ADD app1.jar app2.jar /app/# 通配符ADD static-assets/*.html /app/public/# 从远程 URL 复制ADD https://example.com/app.jar /app.jar# 从压缩包中复制ADD static-assets.tar.gz /app/public/ 最佳实践是优先使用 COPY，只有在需要 ADD 的额外功能时才使用它。 COPY COPY 指令用于将主机上的文件或目录复制到镜像的文件系统中。它是构建镜像过程中最常用的数据引入方式之一。 与 ADD 类似，但功能更简单、明确、安全 推荐优先使用 COPY，除非你确实需要 ADD 提供的自动解压或远程下载功能。 语法 1234COPY &lt;src&gt;... &lt;dest&gt;# 说明：# &lt;src&gt;：要复制的文件或目录# &lt;dest&gt;：目标路径 示例 12345678910# 复制单个文件COPY app.jar /app.jar# 复制多个文件COPY app1.jar app2.jar /app/# 复制目录COPY static-assets/ /app/public/# 通配符COPY static-assets/*.html /app/public/# 设置目标文件属主属组COPY --chown=appuser:appgroup app.jar /app.jar RUN RUN 指令用于在镜像构建阶段执行命令，结果会被打包进镜像层中。 它可以用于安装依赖、编译代码、运行命令等。 每一条 RUN 指令会创建一层镜像（layer）,合并多个命令成一条 RUN，可以减少镜像层数（例如使用 &amp;&amp; 串联）。 语法 12345# 第一种格式：实际运行的是：/bin/sh -c &quot;&lt;命令字符串&gt;&quot;RUN &lt;命令字符串&gt;# 第二种格式RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...] 示例 12345678910# 命令字符串RUN apt-get update &amp;&amp; apt-get install -y curl# 构建多个命令(用 &amp;&amp; 串联)RUN apt-get update &amp;&amp; \\ apt-get install -y python3 &amp;&amp; \\ rm -rf /var/lib/apt/lists/*# 可执行文件参数RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;curl https://example.com/app.jar &gt; app.jar&quot;] CMD CMD 用于指定容器启动时默认执行的命令及其参数。 如果用户在运行容器时没有手动指定其他命令，Docker 就会使用 CMD 提供的内容。 它可以定义多个，但只有最后一个会被使用。 语法 1234567# Shell 形式（字符串）CMD command param1 param2# 等价于 /bin/sh -c &quot;command param1 param2&quot;# Exec 形式（数组）CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789# 简单 shell 命令CMD echo &quot;Hello from container&quot;# Exec 形式CMD [&quot;npm&quot;, &quot;start&quot;]# 作为 ENTRYPOINT 的参数ENTRYPOINT [&quot;python3&quot;, &quot;app.py&quot;]CMD [&quot;--host=0.0.0.0&quot;, &quot;--port=8080&quot;] 用户可以覆盖 CMD： 1docker run &lt;myapp&gt; npm run test ENTRYPOINT ENTRYPOINT 定义容器启动时执行的主命令，相比 CMD，它不容易被覆盖，更适合制作“专用型”容器（如 nginx、python 脚本等）。 你可以把 ENTRYPOINT 理解为容器的“主程序”，而 CMD 是为它提供的默认“命令行参数”。 语法 123456# Shell 形式（字符串）ENTRYPOINT command param1 param2# 等价于 /bin/sh -c &quot;command param1 param2&quot;# Exec 形式（数组）ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789# 简单 shell 命令ENTRYPOINT echo &quot;Hello from container&quot;# Exec 形式ENTRYPOINT [&quot;npm&quot;, &quot;start&quot;]# 结合 CMD 使用ENTRYPOINT [&quot;python3&quot;, &quot;app.py&quot;]CMD [&quot;--host=0.0.0.0&quot;, &quot;--port=8080&quot;] EXPOSE EXPOSE 用于声明容器将会监听的端口，让使用该镜像的人知道应该对外开放哪些端口。 ⚠️ 注意：EXPOSE 并不会真的开放端口，只是“声明”这个容器监听了这些端口。 要让端口真正暴露出来，还需要在运行容器时加上 -p 或 --publish 参数。 语法 1234EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]# 说明：# &lt;port&gt;：端口号，可以是单个端口号，也可以是范围（如 8080-8085）# &lt;protocol&gt;：协议，可以是 tcp 或 udp，默认为 tcp 示例 1234EXPOSE 8080EXPOSE 8080/udpEXPOSE 8080-8085EXPOSE 8080 8081 8082 8083 8084 8085 VOLUME VOLUME 指令用于声明一个或多个容器中的挂载点（mount point），用于持久化数据或与宿主机/其他容器共享数据。 语法： 123VOLUME [&quot;/path/in/container&quot;, ...]# 路径必须是容器内部的绝对路径# 可以一次声明一个，也可以是多个。 示例 1234# 声明一个挂载点VOLUME /app/public# 声明多个挂载点VOLUME [&quot;/app/public&quot;, &quot;/app/logs&quot;] 当容器运行时，可以将镜像中声明的挂载点映射到宿主机上，从而实现持久化数据。 1docker run -v /host/path:/app/public myimage 如果你没有手动绑定挂载，Docker 会自动创建一个匿名卷，卷的内容默认保存在宿主机的 /var/lib/docker/volumes 下。 HEALTHCHECK HEALTHCHECK 用来定义容器运行时的健康检查命令，定期检测容器内服务的状态，帮助编排工具（Docker Swarm、Kubernetes 等）判断容器是否健康。 如果健康检查失败，Docker 会将容器标记为 unhealthy，便于自动重启或替换。 语法 12345678HEALTHCHECK &lt;options&gt; CMD &lt;command&gt;# 说明：# &lt;options&gt;：可选项，用于设置健康检查的选项，如超时时间、重试次数等。# &lt;command&gt;：健康检查命令，可以是任何有效的 shell 命令。 # 必须返回退出码: # 0 表示健康 # 1 表示不健康 # 2 表示未知 可选参数（OPTIONS） 参数 说明 默认值 --interval=DURATION 两次健康检查之间的时间间隔 30s --timeout=DURATION 单次检测命令的超时时间 30s --start-period=DURATION 容器启动后，开始健康检查前的等待时间 0s --retries=N 连续失败几次后判定容器不健康 3 示例 12# 使用 curl 检测 Web 服务是否响应HEALTHCHECK --interval=5s --timeout=3s --retries=3 CMD curl -f http://localhost:8080/health || exit 1 运行容器后，可以用命令查看健康状态 123456789# 如果镜像中有健康检查，可以查看容器状态（STATUS）docker ps # STATUS 列会显示： # healthy # unhealthy # starting（启动中）# 查看更详细的信息docker inspect --format=&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27; &lt;container-id&gt; SHELL SHELL 指令用来自定义后续 RUN、CMD 和 ENTRYPOINT 指令所使用的默认 shell 程序和参数。 默认情况下： 在 Linux 镜像中，Docker 使用 /bin/sh -c 在 Windows 镜像中，使用 cmd /S /C 使用 SHELL，你可以替换为其他 shell，如 Bash、PowerShell、zsh 等。 语法 1SHELL [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789101112# 切换到 bashSHELL [&quot;bash&quot;, &quot;-c&quot;]# 多次切换SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]RUN echo &quot;Hello from Bash&quot; # 在 Bash 中执行SHELL [&quot;/bin/sh&quot;, &quot;-c&quot;]RUN echo &quot;Now back to sh&quot; # 在 sh 中执行# WindowsSHELL [&quot;powershell&quot;, &quot;-Command&quot;] STOPSIGNAL STOPSIGNAL 指定当容器收到 docker stop 命令时，发送给容器主进程的信号类型。 默认情况下，Docker 会向容器的主进程发送 SIGTERM 信号，让它有机会优雅地退出（在超时时未退出则发 SIGKILL 强制终止）。 默认情况，大多数程序（如 nginx），不需要设置（默认 SIGTERM） 但有些程序可能需要使用不同的信号，比如 SIGINT、SIGHUP，这时你可以通过 STOPSIGNAL 来修改。 语法 12345STOPSIGNAL &lt;signal&gt;# 说明：# 其中 &lt;signal&gt; 可以是：# 信号名称，例如：SIGTERM、SIGKILL、SIGINT、SIGHUP# 或信号编号，例如：15（等价于 SIGTERM） 示例 12345# 这是默认行为，不写也一样。STOPSIGNAL SIGTERM# 修改为 SIGINTSTOPSIGNAL SIGINT ONBUILD ONBUILD 用于定义延迟执行的构建指令，即这些命令不会在当前 Dockerfile 构建时执行，而是在 以当前镜像为基础的子镜像中构建时触发执行。 它的典型用途是：构建一个“通用基础镜像”，让使用者在自己的 Dockerfile 中 FROM 它时自动继承一些操作（比如 COPY、RUN 等）。 ONBUILD 是一种设计模式，方便基础镜像作者预先定义“未来子镜像构建时一定要执行的步骤”，而不是在基础镜像中“硬编码”那些步骤。 语法 123ONBUILD &lt;INSTRUCTION&gt;# 说明：# &lt;INSTRUCTION&gt;：必须是一个合法的 Dockerfile 指令，如 RUN、COPY、ADD、CMD 等（但不能是 FROM, ONBUILD, HEALTHCHECK 等）。 示例 1234567891011121314151617# 基础镜像中使用 ONBUILD# 文件：Dockerfile.baseFROM node:18WORKDIR /appONBUILD COPY . /appONBUILD RUN npm install# 构建基础镜像docker build -t my-node-base -f Dockerfile.base .# 使用基础镜像构建子镜像# 文件：Dockerfile（子镜像）FROM my-node-baseCMD [&quot;node&quot;, &quot;index.js&quot;]# 构建子镜像时，等于自动插入了：COPY . /appRUN npm install ONBUILD 是一种“构建钩子”机制 ONBUILD 可以理解成“钩子”或“触发器”： 在基础镜像构建时不执行 但当某人以这个基础镜像为起点写自己的 Dockerfile，并构建时，这些 ONBUILD 里的指令自动插入执行 这样： 基础镜像只负责定义环境（node、npm版本、系统依赖等），保持轻量 下游项目可以不用写重复的代码复制和安装指令，自动继承基础镜像预定义的构建步骤 代码复制和依赖安装在下游镜像构建时执行，使用自己的上下文（也就是项目代码） ONBUILD 总结 特性 说明 ⏱ 延迟执行 构建基础镜像时不会执行，在子镜像构建时触发 ✅ 支持指令 例如 RUN, COPY, ADD, CMD, WORKDIR, ENV 等 ❌ 不支持 FROM, ONBUILD, HEALTHCHECK, SHELL, STOPSIGNAL 👎 不推荐滥用 会隐藏构建行为，降低可维护性 ✅ 推荐场景 团队共享模板、构建“标准开发镜像” Dockerfile 哪些 指令 会创建新的层 当 Dockerfile 中创建新层的指令内容发生变化时，使用 --no-cache 选项可以确保这些变更被正确应用。 指令 描述 ADD 从 复制文件并自动解压（如果是一个 tar 文件）到容器的 路径。 COPY 从 复制文件到容器的 路径，不会自动解压。 RUN 执行任意命令并在容器中做出更改。每条 RUN 指令都会创建一个新的层。 ENV 设置环境变量。每一行 ENV 指令都会创建一个新的层。 WORKDIR 设置工作目录。每一行 WORKDIR 指令都会创建一个新的层。 VOLUME 创建一个挂载点。每一行 VOLUME 指令都会创建一个新的层。 LABEL 添加元数据标签。每一行 LABEL 指令都会创建一个新的层。 Dockerfile 示例: Spring Boot 应用 目录结构 1234567springbootweb/├── Dockerfile├── target/│ └── app.jar├── static-assets.tar.gz└── ... Dockerfile: 注意 Dockerfile 中所有关键字都要求大写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用FROM openjdk:17-alpine# 设置构建时变量，默认使用构建好的 jar 文件ARG JAR_FILE=target/app.jar# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;ENV TZ=Asia/Shanghai# 镜像元信息LABEL maintainer=&quot;yourname@example.com&quot;LABEL version=&quot;1.0.0&quot;LABEL description=&quot;用于部署 Spring Boot 应用的生产级镜像&quot;# 设置工作目录WORKDIR /app# 示例 RUN：安装 curl（用于容器健康检查或调试）RUN apk add --no-cache curl# 复制 Spring Boot 构建生成的 jar 包COPY $&#123;JAR_FILE&#125; app.jar# 解压静态资源到容器中（ADD 可以自动解压 tar.gz）ADD static-assets.tar.gz /app/public/# 声明暴露的应用端口（Spring Boot 默认是 8080）EXPOSE 8080# 容器健康检查：访问 actuator 健康端点HEALTHCHECK --interval=30s --timeout=5s --retries=3 \\ CMD curl -f http://localhost:8080/app/actuator/health || exit 1# 容器终止时优雅关闭（Java 推荐 SIGTERM）STOPSIGNAL SIGTERM# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;] 构建镜像 12# 构建镜像时用 --build-arg 指定构建参数，如果需要多个，就配置多个 --build-argdocker build --build-arg JAR_FILE=target/app.jar -t springbootweb:latest . 运行容器 12345docker run -d --name springbootweb \\ -p 8080:8080 \\ -e JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; \\ -v /home/centos/logs/app/:/app/logs \\ springbootweb:latest Dockerfile 示例: 多阶段构建 12345678910111213141516171819202122232425262728293031323334# 第一阶段：获取代码FROM alpine/git AS fetcherWORKDIR /workspace/application# 将替换为实际的Git仓库URL和分支/标签ARG GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.gitARG GIT_BRANCH=masterRUN git clone -b $&#123;GIT_BRANCH&#125; $&#123;GIT_REPOSITORY&#125; .# 第二阶段：使用Maven环境进行构建FROM maven:3.8.4-openjdk-17 AS builderWORKDIR /workspace/application# 从第一阶段复制代码COPY --from=fetcher /workspace/application .# 使用Maven清理并打包RUN mvn clean package -DskipTests# 第三阶段：创建最终的运行环境FROM openjdk:17-alpineWORKDIR /app# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;# 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jarCOPY --from=builder /workspace/application/target/app.jar app.jar# 暴露端口（如果需要的话）。请根据实际情况修改端口号EXPOSE 8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;]# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080 构建镜像 12# 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建docker build --no-cache -t app:latest . 运行容器 12345docker run -d --name app \\ -p 8080:8080 \\ -e JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; \\ -v /home/centos/logs/app/:/app/logs \\ app:latest","summary":"摘要 本文介绍 Docker 命令 中 Dockerfile 的使用方法 Docker官方文档 Dockerfile官方文档","date_published":"2025-05-26T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/22/docker-command-image/","url":"https://blog.hanqunfeng.com/2025/05/22/docker-command-image/","title":"Docker 命令 之 镜像(Image)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 镜像管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/#application-programming-interfaces-apis\">Application programming interfaces (APIs)</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"docker-search-搜索镜像\"><code>docker search</code> : 搜索镜像</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐在<a href=\"https://hub.docker.com/\">dockerhub</a>上搜索镜像，以获取更详细的镜像信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>国内也可以通过<a href=\"https://1ms.run/\">毫秒镜像</a>,<a href=\"https://dockers.xuanyuan.me\">轩辕 Docker 镜像搜索</a>来搜索镜像。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker search --<span class=\"built_in\">help</span></span><br><span class=\"line\">用法:  docker search [OPTIONS] TERM</span><br><span class=\"line\"></span><br><span class=\"line\">在 Docker Hub 中搜索镜像</span><br><span class=\"line\"></span><br><span class=\"line\">选项:</span><br><span class=\"line\">  -f, --filter filter   根据提供的条件过滤输出，常见的过滤条件包括：stars（星级）、is-official（是否为官方镜像）</span><br><span class=\"line\">      --format string   使用 Go 模板美化输出，不太常用</span><br><span class=\"line\">      --<span class=\"built_in\">limit</span> int       搜索结果的最大数量</span><br><span class=\"line\">      --no-trunc        不截断输出内容，显示完整信息（默认输出中某些字段如描述可能被截断）</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例\">示例</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索名称中包含 nginx 的镜像</span></span><br><span class=\"line\">$ docker search nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索名称中包含 nginx 且星级不少于 100 的镜像。</span></span><br><span class=\"line\">$ docker search -f stars=100 nginx</span><br><span class=\"line\"><span class=\"comment\"># 搜索官方镜像</span></span><br><span class=\"line\">$ docker search -f is-official=<span class=\"literal\">true</span> nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索 nginx，按照指定模板格式化输出</span></span><br><span class=\"line\">$ docker search nginx --format <span class=\"string\">&quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125; stars:  &#123;&#123;.Description&#125;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索nginx镜像，并限制5个结果</span></span><br><span class=\"line\">$ docker search nginx --<span class=\"built_in\">limit</span> 5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 组合使用多个选项</span></span><br><span class=\"line\">$ docker search -f stars=100 --<span class=\"built_in\">limit</span> 5 --no-trunc nginx</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>docker search</code> 命令报错的解决方法</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">目前国内使用<code>docker search</code>时会出现<code>Error response from daemon: Get &quot;https://index.docker.io/v1/search?q=nginx&amp;n=25&quot;: dial tcp 210.56.51.193:443: i/o timeout</code>的错误，即便我们配置了国内的镜像源，这个错误还是会存在。</li>\n<li class=\"lvl-2\">即便为宿主机和docker都配置上DNS也依然会报错。</li>\n<li class=\"lvl-2\">不过可以通过第三方镜像仓库进行查询，比如在查询的镜像名称前加上 <code>docker.1ms.run/</code>，比如查询<code>nginx</code>镜像，则输入<code>docker search docker.1ms.run/nginx</code>，这里要注意并不是所有的第三方镜像仓库都支持查询。</li>\n<li class=\"lvl-2\">可以编写一个脚本<code>docker_search</code>，查询镜像并输出结果，如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt; <span class=\"string\">&#x27;EOF&#x27;</span> &gt; docker_search</span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\">QUERY=<span class=\"variable\">$&#123;1&#125;</span>     <span class=\"comment\"># 查询关键词，这里要注意，第一个参数必须是查询关键词</span></span><br><span class=\"line\"><span class=\"comment\"># 获取除第一个参数外的所有参数</span></span><br><span class=\"line\">ARGS=<span class=\"variable\">$&#123;@:2&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;查询镜像：docker search docker.1ms.run/<span class=\"variable\">$QUERY</span> <span class=\"variable\">$ARGS</span>&quot;</span></span><br><span class=\"line\">docker search docker.1ms.run/<span class=\"variable\">$QUERY</span> <span class=\"variable\">$ARGS</span></span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x docker_search</span><br><span class=\"line\"><span class=\"comment\"># 将其移动到 /usr/local/bin/</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> docker_search /usr/local/bin/docker_search</span><br><span class=\"line\"><span class=\"comment\"># 如果/usr/local/bin/没有在PATH中，请添加到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export PATH=<span class=\"variable\">$PATH</span>:/usr/local/sbin&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">docker_search redis -f stars=100 --<span class=\"built_in\">limit</span> 5 --no-trunc</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME                DESCRIPTION                                                                                       STARS     OFFICIAL</span><br><span class=\"line\">redis               Redis is the world’s fastest data platform <span class=\"keyword\">for</span> caching, vector search, and NoSQL databases.      13315     [OK]</span><br><span class=\"line\">redis/redis-stack   redis-stack installs a Redis server with additional database capabilities and the RedisInsight.   149</span><br><span class=\"line\">bitnami/redis       Bitnami container image <span class=\"keyword\">for</span> Redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">基于url搜索，支持分页，但不能支持其它search参数</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt; <span class=\"string\">&#x27;EOF&#x27;</span> &gt; docker_search_by_url</span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数处理</span></span><br><span class=\"line\">QUERY=<span class=\"variable\">$&#123;1:-nginx&#125;</span>     <span class=\"comment\"># 默认查询关键词</span></span><br><span class=\"line\">N=<span class=\"variable\">$&#123;2:-25&#125;</span>            <span class=\"comment\"># 默认每页条数</span></span><br><span class=\"line\">PAGE=<span class=\"variable\">$&#123;3:-1&#125;</span>          <span class=\"comment\"># 默认页码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像源列表：依次尝试访问这些域名，这里要注意，并不是所有的镜像源都支持搜索功能</span></span><br><span class=\"line\">REGISTRIES=(</span><br><span class=\"line\">  <span class=\"string\">&quot;docker.1ms.run&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;register.librax.org&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># 你可以继续添加备用域名</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化成功标志</span></span><br><span class=\"line\">WORKING_URL=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历域名，找到第一个可访问的</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> REG <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;REGISTRIES[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">  TEST_URL=<span class=\"string\">&quot;https://<span class=\"variable\">$&#123;REG&#125;</span>/v1/search?q=test&amp;n=1&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> curl -s --connect-timeout 2 <span class=\"string\">&quot;<span class=\"variable\">$TEST_URL</span>&quot;</span> | grep -q <span class=\"string\">&#x27;&quot;results&quot;&#x27;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">    WORKING_URL=<span class=\"string\">&quot;https://<span class=\"variable\">$&#123;REG&#125;</span>/v1/search?q=<span class=\"variable\">$&#123;QUERY&#125;</span>&amp;n=<span class=\"variable\">$&#123;N&#125;</span>&amp;page=<span class=\"variable\">$&#123;PAGE&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果都失败，退出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -z <span class=\"string\">&quot;<span class=\"variable\">$WORKING_URL</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 无法连接任何镜像源，请检查网络或备用域名设置。&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 请求数据并格式化输出</span></span><br><span class=\"line\">curl -s <span class=\"string\">&quot;<span class=\"variable\">$WORKING_URL</span>&quot;</span> \\</span><br><span class=\"line\">| jq -r <span class=\"string\">&#x27;[&quot;NAME&quot;,&quot;STARS&quot;,&quot;OFFICIAL&quot;,&quot;DESCRIPTION&quot;],</span></span><br><span class=\"line\"><span class=\"string\">         (.results[] |</span></span><br><span class=\"line\"><span class=\"string\">         [.name,</span></span><br><span class=\"line\"><span class=\"string\">          (.star_count|tostring),</span></span><br><span class=\"line\"><span class=\"string\">          (if .is_official then &quot;[OK]&quot; else &quot;&quot; end),</span></span><br><span class=\"line\"><span class=\"string\">          .description])</span></span><br><span class=\"line\"><span class=\"string\">         | @tsv&#x27;</span> \\</span><br><span class=\"line\">| column -t -s $<span class=\"string\">&#x27;\\t&#x27;</span></span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"docker-image-镜像管理\"><code>docker image</code> : 镜像管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image --help</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>别名(简写)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>build</td>\n<td>从 Dockerfile 构建一个镜像</td>\n<td>docker build</td>\n</tr>\n<tr>\n<td>history</td>\n<td>显示镜像的历史记录</td>\n<td>docker history</td>\n</tr>\n<tr>\n<td>import</td>\n<td>从 tar 包导入内容以创建文件系统镜像</td>\n<td>docker import</td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>显示一个或多个镜像的详细信息</td>\n<td>可以使用 <code>docker inspect</code></td>\n</tr>\n<tr>\n<td>load</td>\n<td>从 tar 归档或标准输入中加载镜像</td>\n<td>docker load</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出镜像</td>\n<td>docker images</td>\n</tr>\n<tr>\n<td>prune</td>\n<td>移除未使用的镜像</td>\n<td></td>\n</tr>\n<tr>\n<td>pull</td>\n<td>从镜像仓库下载镜像</td>\n<td>docker pull</td>\n</tr>\n<tr>\n<td>push</td>\n<td>上传镜像到镜像仓库</td>\n<td>docker push</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>移除一个或多个镜像</td>\n<td>docker rmi</td>\n</tr>\n<tr>\n<td>save</td>\n<td>将一个或多个镜像保存为 tar 归档（默认输出到标准输出）</td>\n<td>docker save</td>\n</tr>\n<tr>\n<td>tag</td>\n<td>创建一个标签 TARGET_IMAGE 指向 SOURCE_IMAGE</td>\n<td>docker tag</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 <code>docker image COMMAND --help</code> 可获取某个命令的更多信息。</p>\n</li>\n</ul>\n<h3 id=\"docker-pull-拉取镜像\"><code>docker pull</code> : 拉取镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image pull</code> == <code>docker pull</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式，不加tag默认拉取 :latest</span></span><br><span class=\"line\">$ docker pull &lt;image_name&gt;[:&lt;tag&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取nginx镜像，默认拉取最新版本：latest，nginx是官方镜像，完整名称实际上是 library/nginx</span></span><br><span class=\"line\">$ docker pull nginx  ==  docker pull library/nginx  ==  docker pull nginx:latest</span><br><span class=\"line\"><span class=\"comment\"># 拉取指定tag的镜像</span></span><br><span class=\"line\">$ docker pull nginx:1.28.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取非官方镜像，用户上传的</span></span><br><span class=\"line\">$ docker pull hanqunfeng/alpine-jre8-slim:1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取指定平台的镜像，如果不指定 --platform 参数，默认会拉取与你当前 Docker 客户端运行平台匹配的镜像，通过 docker version 查看</span></span><br><span class=\"line\">$ docker pull --platform=linux/amd64 nginx:latest</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <a href=\"/2025/05/20/docker-install/\" title=\"Linux 安装 Docker\">Linux 安装 Docker</a> 中介绍了如配置国内的镜像加速源来加快镜像的拉取，但是国内镜像源不稳定，随时都有可能不可用，而且每次重新配置镜像源还需要重启Docker，可以编写一个脚本来完成<code>pull</code>，这样每次更新镜像源时只需要修改脚本，而不需要重启Docker了。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 脚本名称：docker_pull</span></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用法检查</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -z <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: <span class=\"variable\">$0</span> &lt;镜像名&gt;，例如：docker_pull redis, docker_pull nginx --platform=linux/arm64&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 原始镜像名称，例如 nginx 或 someuser/image，要求第一个参数必须是镜像名称</span></span><br><span class=\"line\">ORIGINAL_IMAGE_NAME=<span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取除第一个参数外的所有参数</span></span><br><span class=\"line\">ARGS=<span class=\"variable\">$&#123;@:2&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像源列表，修改镜像源时只需要修改该列表即可</span></span><br><span class=\"line\">MIRROR_LIST=(</span><br><span class=\"line\">  <span class=\"string\">&quot;docker.1ms.run&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;docker.xuanyuan.me&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;docker.m.daocloud.io&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;docker.1panel.live&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果镜像名中不包含 &quot;/&quot;，加上 &quot;library/&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">&quot;<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span>&quot;</span> != *<span class=\"string\">&quot;/&quot;</span>* ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  IMAGE_NAME=<span class=\"string\">&quot;library/<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  IMAGE_NAME=<span class=\"string\">&quot;<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历镜像源</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> MIRROR <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;MIRROR_LIST[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">  FULL_IMAGE=<span class=\"string\">&quot;<span class=\"variable\">$MIRROR</span>/<span class=\"variable\">$IMAGE_NAME</span>&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;尝试从 <span class=\"variable\">$FULL_IMAGE</span> <span class=\"variable\">$ARGS</span> 拉取镜像...&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;docker pull <span class=\"variable\">$&#123;FULL_IMAGE&#125;</span> <span class=\"variable\">$&#123;ARGS&#125;</span>&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> docker pull <span class=\"variable\">$&#123;FULL_IMAGE&#125;</span> <span class=\"variable\">$&#123;ARGS&#125;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;成功拉取镜像：<span class=\"variable\">$FULL_IMAGE</span> <span class=\"variable\">$ARGS</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 将镜像重命名为去除镜像源前缀的版本</span></span><br><span class=\"line\">    docker tag <span class=\"string\">&quot;<span class=\"variable\">$FULL_IMAGE</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;镜像重命名为：<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 可选：删除带镜像源前缀的镜像</span></span><br><span class=\"line\">    docker rmi <span class=\"string\">&quot;<span class=\"variable\">$FULL_IMAGE</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;从 <span class=\"variable\">$MIRROR</span> 拉取失败，尝试下一个镜像源...&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;所有镜像源尝试失败，无法拉取镜像：<span class=\"variable\">$ORIGINAL_IMAGE_NAME</span> <span class=\"variable\">$ARGS</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 1</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>如何获取镜像tag</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">docker 命令中没有提供直接获取镜像tag的命令，如果不想到<code>dockerhub</code>上查看，可以通过如下方式获取</li>\n<li class=\"lvl-2\">通过dockerhub的api接口获取(需要科学上网)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只显示tag名称，官方镜像替换 nginx，非官方镜像替换 libryary/nginx，page_size=5表示每页5条数据，page=1表示第一页（默认为1）</span></span><br><span class=\"line\">curl -s <span class=\"string\">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> | jq <span class=\"string\">&#x27;.results[].name&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 也可以使用如下url，两者效果相同</span></span><br><span class=\"line\"><span class=\"comment\">## https://hub.docker.com/v2/namespaces/&#123;namespace&#125;/repositories/&#123;repository&#125;/tags?page_size=5&amp;page=1</span></span><br><span class=\"line\"><span class=\"comment\">## 示例：https://hub.docker.com/v2/namespaces/library/repositories/nginx/tags?page_size=1&amp;page=1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式，并显示最后更新时间和镜像大小</span></span><br><span class=\"line\">curl -s <span class=\"string\">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> | jq <span class=\"string\">&#x27;.results[] | &#123;name,last_updated,full_size&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出表格格式，并格式化输出</span></span><br><span class=\"line\">curl -s <span class=\"string\">&quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot;</span> \\</span><br><span class=\"line\">| jq -r <span class=\"string\">&#x27;.results[] |</span></span><br><span class=\"line\"><span class=\"string\">  &quot;\\(.name)\\t\\t\\(.last_updated | sub(&quot;T&quot;; &quot; &quot;) | sub(&quot;\\\\..*&quot;; &quot;&quot;))\\t\\t\\(((.full_size / 1024 / 1024 * 100 | round)/100) | tostring) MB&quot;&#x27;</span> \\</span><br><span class=\"line\">  | awk <span class=\"string\">&#x27;&#123;printf &quot;%-30s %-20s %8.2f MB\\n&quot;, $1, $2&quot; &quot;$3, $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">通过<a href=\"https://github.com/containers/skopeo\">skopeo</a>工具获取</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里使用容器的方式(需要科学上网)</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> quay.io/skopeo/stable:latest inspect --override-os linux  docker://docker.io/nginx | jq <span class=\"string\">&#x27;.RepoTags[]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 将`docker.io`替换为镜像源`docker.1ms.run`，不需要科学上网</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> quay.io/skopeo/stable:latest inspect --override-os linux  docker://docker.1ms.run/nginx | jq <span class=\"string\">&#x27;.RepoTags[]&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">为了方便使用可以编写一个脚本</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt; <span class=\"string\">EOF &gt; docker_tags</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 用法提示</span></span><br><span class=\"line\"><span class=\"string\">if [ -z &quot;\\$1&quot; ]; then</span></span><br><span class=\"line\"><span class=\"string\">  echo &quot;用法: \\$0 &lt;镜像名称，例如 nginx 或 library/nginx&gt;&quot;</span></span><br><span class=\"line\"><span class=\"string\">  exit 1</span></span><br><span class=\"line\"><span class=\"string\">fi</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">IMAGE_NAME=\\$1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 使用 skopeo 获取镜像信息并解析标签列表</span></span><br><span class=\"line\"><span class=\"string\">docker run --rm quay.io/skopeo/stable:latest \\\\</span></span><br><span class=\"line\"><span class=\"string\">  inspect --override-os linux docker://docker.1ms.run/\\$IMAGE_NAME \\\\</span></span><br><span class=\"line\"><span class=\"string\">  | jq &#x27;.RepoTags[]&#x27;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x docker_tags</span><br><span class=\"line\"><span class=\"comment\"># 使用</span></span><br><span class=\"line\">docker_tags nginx</span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"docker-images-列出镜像\"><code>docker images</code> : 列出镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image ls</code> == <code>docker images</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有镜像，不包括悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）</span></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\"><span class=\"comment\"># 列出所有镜像，包括悬空镜像</span></span><br><span class=\"line\">$ docker images -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有镜像，并显示镜像的摘要信息</span></span><br><span class=\"line\">$ docker images --digests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有镜像，并输出为json格式</span></span><br><span class=\"line\">$ docker images --format json</span><br><span class=\"line\"><span class=\"comment\"># 只显示镜像名称和标签</span></span><br><span class=\"line\">$ docker images --format <span class=\"string\">&quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只显示镜像ID</span></span><br><span class=\"line\">$ docker images -q</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-inspect-查看镜像的详细信息\"><code>docker inspect</code> : 查看镜像的详细信息</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image inspect</code> == <code>docker inspect</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意，<code>docker inspect</code>如果基于名称查找会优先查找容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示镜像的详细信息，镜像名称</span></span><br><span class=\"line\">$ docker inspect nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示镜像的详细信息，镜像ID</span></span><br><span class=\"line\">$ docker inspect 9f0c0d0a0f0f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示镜像的Labels信息，获取json中指定的字段</span></span><br><span class=\"line\">$ docker image inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27;</span> nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-image-prune-删除未使用的镜像\"><code>docker image prune</code> : 删除未使用的镜像</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）</span></span><br><span class=\"line\">$ docker image prune</span><br><span class=\"line\"><span class=\"comment\"># 删除全部未使用镜像(未被任何一个容器引用)，包括悬空镜像</span></span><br><span class=\"line\">$ docker image prune -a</span><br><span class=\"line\"><span class=\"comment\"># 不进行确认提示，直接执行</span></span><br><span class=\"line\">$ docker image prune -f</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rmi-删除镜像\"><code>docker rmi</code> : 删除镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image rm</code> == <code>docker rmi</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除镜像，镜像名称</span></span><br><span class=\"line\">$ docker rmi nginx</span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像，空格分隔</span></span><br><span class=\"line\">$ docker rmi nginx mysql</span><br><span class=\"line\"><span class=\"comment\"># 删除镜像，镜像ID</span></span><br><span class=\"line\">$ docker rmi 9f0c0d0a0f0f</span><br><span class=\"line\"><span class=\"comment\"># 强制删除镜像，当镜像被容器引用时，会报错，需要使用-f参数进行强制删除</span></span><br><span class=\"line\">$ docker rmi -f nginx</span><br><span class=\"line\"><span class=\"comment\"># 删除全部镜像</span></span><br><span class=\"line\">$ docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-history-查看镜像的构建历史\"><code>docker history</code> : 查看镜像的构建历史</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image history</code> == <code>docker history</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">history</span> [OPTIONS] IMAGE</span><br><span class=\"line\"><span class=\"comment\"># 查看镜像的历史记录，镜像名称</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">history</span> nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看镜像的历史记录，镜像ID</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">history</span> 9f0c0d0a0f0f</span><br><span class=\"line\"><span class=\"comment\"># 显示完整的镜像历史记录，默认`CREATED BY`中的信息太长会被截断</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">history</span> --no-trunc nginx</span><br><span class=\"line\"><span class=\"comment\"># 显示为json格式</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">history</span> --format=json nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker history</code> 显示的是构建历史，会将每一个 Dockerfile 指令都算一层，而不是物理镜像层（layer）数量，若要查看镜像的物理层数，可以通过如下命令查看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker image inspect --format <span class=\"string\">&#x27;&#123;&#123; len .RootFS.Layers &#125;&#125;&#x27;</span> nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-tag-创建一个标签\"><code>docker tag</code> : 创建一个标签</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image tag</code> == <code>docker tag</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class=\"line\"><span class=\"comment\"># 创建一个标签</span></span><br><span class=\"line\">$ docker tag nginx:latest hanqunfeng/nginx:latest</span><br><span class=\"line\"><span class=\"comment\"># 查看镜像，可以看到两个镜像的 IMAGE ID 一致</span></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY         TAG       IMAGE ID       CREATED       SIZE</span><br><span class=\"line\">hanqunfeng/nginx   latest    be69f2940aaf   5 weeks ago   192MB</span><br><span class=\"line\">nginx              latest    be69f2940aaf   5 weeks ago   192MB</span><br><span class=\"line\"><span class=\"comment\"># 此时若通过 IMAGE ID 删除镜像，会报错，提示被多个 REPOSITORY 关联，需要使用 -f 参数进行强制删除</span></span><br><span class=\"line\">$ docker rmi be69f2940aaf</span><br><span class=\"line\">Error response from daemon: conflict: unable to delete be69f2940aaf (must be forced) - image is referenced <span class=\"keyword\">in</span> multiple repositories</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-save-将镜像保存为-tar-归档\"><code>docker save</code> : 将镜像保存为 tar 归档</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image save</code> == <code>docker save</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"><span class=\"comment\"># 将镜像保存为 tar 归档，-o  指定输出文件，文件名称任意，甚至都不需要以 .tar 结尾</span></span><br><span class=\"line\">$ docker save -o nginx.tar nginx</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">$ docker save nginx &gt; nginx.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-load-从-tar-归档中加载镜像\"><code>docker load</code> : 从 tar 归档中加载镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image load</code> == <code>docker load</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker load [OPTIONS]</span><br><span class=\"line\"><span class=\"comment\"># 从 tar 归档中加载镜像，导出tar归档时的镜像名称就是加载后的镜像名称</span></span><br><span class=\"line\">$ docker load -i nginx.tar</span><br><span class=\"line\"><span class=\"comment\"># -q 参数表示不显示进度条</span></span><br><span class=\"line\">$ docker load -q -i nginx.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-import-从文件创建镜像\"><code>docker import</code> : 从文件创建镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image import</code> == <code>docker import</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">$ docker import [OPTIONS] FILE|URL|- [REPOSITORY[:TAG]]</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\">file\t本地 tar 文件，例如 rootfs.tar</span><br><span class=\"line\">URL\t    网络地址（http/https）</span><br><span class=\"line\">-\t    从标准输入读取（比如通过管道）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出镜像名称与标签</span></span><br><span class=\"line\">REPOSITORY[:TAG]\t导入后镜像的名称与标签</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># OPTIONS</span></span><br><span class=\"line\">--change\t在导入镜像时设置 Dockerfile 指令，如 CMD、ENV、EXPOSE 等</span><br><span class=\"line\">--message, -m\t添加导入说明（commit message）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker import</code> 与  <code>docker load</code> 的区别</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>用途</th>\n<th>格式</th>\n<th>是否保留历史</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker import</code></td>\n<td>导入文件系统，创建镜像(由 <code>docker export</code> 生成)</td>\n<td>纯文件系统 tar 包</td>\n<td>❌ 不保留历史、标签等元数据</td>\n</tr>\n<tr>\n<td><code>docker load</code></td>\n<td>加载镜像（通常由 <code>docker save</code> 生成）</td>\n<td>Docker 镜像 tar（含元数据）</td>\n<td>✅ 保留 tag、层、历史等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例: 从容器导出再导入</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个容器</span></span><br><span class=\"line\">$ docker run -d -p 8080:80 --name nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导出容器文件系统，此时 nginx 容器中的所有文件都保存在 my_nginx.tar 文件中</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">export</span> -o my_nginx.tar nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入文件系统，导入时指定 启动命令，因为 my_nginx.tar 只是文件，并不包含任何启动命令</span></span><br><span class=\"line\">$ docker import --change=<span class=\"string\">&#x27;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#x27;</span> my_nginx.tar nginx:my_tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看镜像，镜像ID不一致</span></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY         TAG       IMAGE ID       CREATED         SIZE</span><br><span class=\"line\">nginx              my_tag    4ab42de31bac   4 seconds ago   191MB</span><br><span class=\"line\">nginx              latest    be69f2940aaf   5 weeks ago     192MB</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-build-从指定目录或URL中的-Dockerfile-构建-Docker-镜像\"><code>docker build</code> : 从指定目录或URL中的 Dockerfile 构建 Docker 镜像</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image build</code> == <code>docker build</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令格式</span></span><br><span class=\"line\">docker build [OPTIONS] PATH | URL | -</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\">PATH\t  Dockerfile 所在的目录</span><br><span class=\"line\">URL\t      Git 仓库的 URL</span><br><span class=\"line\">-\t      从标准输入读取 Dockerfile</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，-t: 指定镜像名称，.: 表示从当前目录查找Dockerfile，默认文件名称为 Dockerfile</span></span><br><span class=\"line\">docker build -t myimage:latest .</span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，-f: 指定 Dockerfile 的相对路径，.: 表示基于当前目录，实际的 Dockerfile 路径就是 ./path/MyDockerfile</span></span><br><span class=\"line\">docker build -t myimage:latest -f path/MyDockerfile .</span><br><span class=\"line\"><span class=\"comment\"># 实际的 Dockerfile 路径就是 /usr/local/path/MyDockerfile</span></span><br><span class=\"line\">docker build -t myimage:latest -f path/MyDockerfile /usr/local</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，从 Git 仓库中构建，git 仓库的 Dockerfile 必须在根目录下</span></span><br><span class=\"line\">docker build https://github.com/hanqunfeng/docker_test.git -t abc:1.0.0</span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，从 Git 仓库中构建，指定 Dockerfile 的相对路径</span></span><br><span class=\"line\">docker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git -t abc:1.0.1</span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，从 Git 仓库中构建，指定分支或 tag</span></span><br><span class=\"line\">docker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git#release -t abc:1.0.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建，但会非常慢，一般没有导致某一个层发生变化时不需要加上这个参数</span></span><br><span class=\"line\">docker build --no-cache -t app:latest .</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker build</code>中还有一些重要的参数，以及<code>Dockerfile</code>文件该怎么编写，请参考<a href=\"/2025/05/26/docker-dockerfile/\" title=\"Docker 命令 之 Dockerfile\">Docker 命令 之 Dockerfile</a></p>\n</li>\n</ul>\n<h3 id=\"docker-push-推送本地镜像到远程仓库\"><code>docker push</code> : 推送本地镜像到远程仓库</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker image push</code> == <code>docker push</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>这里介绍如何将镜像推送到<code>docker hub</code>远程仓库</p>\n</li>\n<li class=\"lvl-2\">\n<p>需要先在<a href=\"https://hub.docker.com/\">docker hub</a>网站上创建一个账号，比如我的用户名是<code>hanqunfeng</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>然后就可以使用下面的命令将本地镜像推送到远程仓库了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看本地镜像</span></span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY         TAG       IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">nginx              latest    e573c6323878   18 hours ago   191MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对nginx镜像打tag,前缀必须与用户名一致</span></span><br><span class=\"line\">$ docker tag nginx hanqunfeng/nginx:1.0.0</span><br><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY         TAG       IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">hanqunfeng/nginx   1.0.0     be69f2940aaf   5 weeks ago    192MB</span><br><span class=\"line\">nginx              latest    be69f2940aaf   5 weeks ago    192MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录 docker hup</span></span><br><span class=\"line\">$ docker login -u hanqunfeng</span><br><span class=\"line\"></span><br><span class=\"line\">i Info → A Personal Access Token (PAT) can be used instead.</span><br><span class=\"line\">          To create a PAT, visit https://app.docker.com/settings</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Password: <span class=\"comment\"># 输入密码</span></span><br><span class=\"line\">Login Succeeded</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录同时输入密码</span></span><br><span class=\"line\"><span class=\"comment\"># docker login -u hanqunfeng -p 12345678</span></span><br><span class=\"line\"><span class=\"comment\"># 登录其它仓库</span></span><br><span class=\"line\"><span class=\"comment\"># docker login -u username -p password registry.orther.com</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送到docker hub，此后就可以通过 docker pull hanqunfeng/nginx:1.0.0 获取了</span></span><br><span class=\"line\">$ docker push hanqunfeng/nginx:1.0.0</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker 命令 中 镜像管理 相关命令 Docker官方文档 Application programming interfaces (APIs) docker search : 搜索镜像 推荐在dockerhub上搜索镜像，以获取更详细的镜像信息。 国内也可以通过毫秒镜像,轩辕 Docker 镜像搜索来搜索镜像。 12345678910$ docker search --help用法: docker search [OPTIONS] TERM在 Docker Hub 中搜索镜像选项: -f, --filter filter 根据提供的条件过滤输出，常见的过滤条件包括：stars（星级）、is-official（是否为官方镜像） --format string 使用 Go 模板美化输出，不太常用 --limit int 搜索结果的最大数量 --no-trunc 不截断输出内容，显示完整信息（默认输出中某些字段如描述可能被截断） 示例 12345678910111213141516# 搜索名称中包含 nginx 的镜像$ docker search nginx# 搜索名称中包含 nginx 且星级不少于 100 的镜像。$ docker search -f stars=100 nginx# 搜索官方镜像$ docker search -f is-official=true nginx# 搜索 nginx，按照指定模板格式化输出$ docker search nginx --format &quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125; stars: &#123;&#123;.Description&#125;&#125;&quot;# 搜索nginx镜像，并限制5个结果$ docker search nginx --limit 5# 组合使用多个选项$ docker search -f stars=100 --limit 5 --no-trunc nginx docker search 命令报错的解决方法 目前国内使用docker search时会出现Error response from daemon: Get &quot;https://index.docker.io/v1/search?q=nginx&amp;n=25&quot;: dial tcp 210.56.51.193:443: i/o timeout的错误，即便我们配置了国内的镜像源，这个错误还是会存在。 即便为宿主机和docker都配置上DNS也依然会报错。 不过可以通过第三方镜像仓库进行查询，比如在查询的镜像名称前加上 docker.1ms.run/，比如查询nginx镜像，则输入docker search docker.1ms.run/nginx，这里要注意并不是所有的第三方镜像仓库都支持查询。 可以编写一个脚本docker_search，查询镜像并输出结果，如下： 1234567891011121314151617181920212223cat &lt;&lt; &#x27;EOF&#x27; &gt; docker_search#!/bin/bashQUERY=$&#123;1&#125; # 查询关键词，这里要注意，第一个参数必须是查询关键词# 获取除第一个参数外的所有参数ARGS=$&#123;@:2&#125;echo &quot;查询镜像：docker search docker.1ms.run/$QUERY $ARGS&quot;docker search docker.1ms.run/$QUERY $ARGSEOF# 设置执行权限chmod +x docker_search# 将其移动到 /usr/local/bin/mv docker_search /usr/local/bin/docker_search# 如果/usr/local/bin/没有在PATH中，请添加到环境变量echo &quot;export PATH=$PATH:/usr/local/sbin&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc# 测试docker_search redis -f stars=100 --limit 5 --no-trunc## 输出NAME DESCRIPTION STARS OFFICIALredis Redis is the world’s fastest data platform for caching, vector search, and NoSQL databases. 13315 [OK]redis/redis-stack redis-stack installs a Redis server with additional database capabilities and the RedisInsight. 149bitnami/redis Bitnami container image for Redis 基于url搜索，支持分页，但不能支持其它search参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344cat &lt;&lt; &#x27;EOF&#x27; &gt; docker_search_by_url#!/bin/bash# 参数处理QUERY=$&#123;1:-nginx&#125; # 默认查询关键词N=$&#123;2:-25&#125; # 默认每页条数PAGE=$&#123;3:-1&#125; # 默认页码# 镜像源列表：依次尝试访问这些域名，这里要注意，并不是所有的镜像源都支持搜索功能REGISTRIES=( &quot;docker.1ms.run&quot; &quot;register.librax.org&quot; # 你可以继续添加备用域名)# 初始化成功标志WORKING_URL=&quot;&quot;# 遍历域名，找到第一个可访问的for REG in &quot;$&#123;REGISTRIES[@]&#125;&quot;; do TEST_URL=&quot;https://$&#123;REG&#125;/v1/search?q=test&amp;n=1&quot; if curl -s --connect-timeout 2 &quot;$TEST_URL&quot; | grep -q &#x27;&quot;results&quot;&#x27;; then WORKING_URL=&quot;https://$&#123;REG&#125;/v1/search?q=$&#123;QUERY&#125;&amp;n=$&#123;N&#125;&amp;page=$&#123;PAGE&#125;&quot; break fidone# 如果都失败，退出if [ -z &quot;$WORKING_URL&quot; ]; then echo &quot;❌ 无法连接任何镜像源，请检查网络或备用域名设置。&quot; exit 1fi# 请求数据并格式化输出curl -s &quot;$WORKING_URL&quot; \\| jq -r &#x27;[&quot;NAME&quot;,&quot;STARS&quot;,&quot;OFFICIAL&quot;,&quot;DESCRIPTION&quot;], (.results[] | [.name, (.star_count|tostring), (if .is_official then &quot;[OK]&quot; else &quot;&quot; end), .description]) | @tsv&#x27; \\| column -t -s $&#x27;\\t&#x27;EOF docker image : 镜像管理 docker image --help 命令 说明 别名(简写) build 从 Dockerfile 构建一个镜像 docker build history 显示镜像的历史记录 docker history import 从 tar 包导入内容以创建文件系统镜像 docker import inspect 显示一个或多个镜像的详细信息 可以使用 docker inspect load 从 tar 归档或标准输入中加载镜像 docker load ls 列出镜像 docker images prune 移除未使用的镜像 pull 从镜像仓库下载镜像 docker pull push 上传镜像到镜像仓库 docker push rm 移除一个或多个镜像 docker rmi save 将一个或多个镜像保存为 tar 归档（默认输出到标准输出） docker save tag 创建一个标签 TARGET_IMAGE 指向 SOURCE_IMAGE docker tag 运行 docker image COMMAND --help 可获取某个命令的更多信息。 docker pull : 拉取镜像 docker image pull == docker pull 12345678910111213# 命令格式，不加tag默认拉取 :latest$ docker pull &lt;image_name&gt;[:&lt;tag&gt;]# 拉取nginx镜像，默认拉取最新版本：latest，nginx是官方镜像，完整名称实际上是 library/nginx$ docker pull nginx == docker pull library/nginx == docker pull nginx:latest# 拉取指定tag的镜像$ docker pull nginx:1.28.0# 拉取非官方镜像，用户上传的$ docker pull hanqunfeng/alpine-jre8-slim:1.0.0# 拉取指定平台的镜像，如果不指定 --platform 参数，默认会拉取与你当前 Docker 客户端运行平台匹配的镜像，通过 docker version 查看$ docker pull --platform=linux/amd64 nginx:latest 在 Linux 安装 Docker 中介绍了如配置国内的镜像加速源来加快镜像的拉取，但是国内镜像源不稳定，随时都有可能不可用，而且每次重新配置镜像源还需要重启Docker，可以编写一个脚本来完成pull，这样每次更新镜像源时只需要修改脚本，而不需要重启Docker了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 脚本名称：docker_pull#!/bin/bash# 用法检查if [[ -z &quot;$1&quot; ]]; then echo &quot;用法: $0 &lt;镜像名&gt;，例如：docker_pull redis, docker_pull nginx --platform=linux/arm64&quot; exit 1fi# 原始镜像名称，例如 nginx 或 someuser/image，要求第一个参数必须是镜像名称ORIGINAL_IMAGE_NAME=&quot;$1&quot;# 获取除第一个参数外的所有参数ARGS=$&#123;@:2&#125;# 镜像源列表，修改镜像源时只需要修改该列表即可MIRROR_LIST=( &quot;docker.1ms.run&quot; &quot;docker.xuanyuan.me&quot; &quot;docker.m.daocloud.io&quot; &quot;docker.1panel.live&quot;)# 如果镜像名中不包含 &quot;/&quot;，加上 &quot;library/&quot;if [[ &quot;$ORIGINAL_IMAGE_NAME&quot; != *&quot;/&quot;* ]]; then IMAGE_NAME=&quot;library/$ORIGINAL_IMAGE_NAME&quot;else IMAGE_NAME=&quot;$ORIGINAL_IMAGE_NAME&quot;fi# 遍历镜像源for MIRROR in &quot;$&#123;MIRROR_LIST[@]&#125;&quot;; do FULL_IMAGE=&quot;$MIRROR/$IMAGE_NAME&quot; echo &quot;尝试从 $FULL_IMAGE $ARGS 拉取镜像...&quot; echo &quot;docker pull $&#123;FULL_IMAGE&#125; $&#123;ARGS&#125;&quot; if docker pull $&#123;FULL_IMAGE&#125; $&#123;ARGS&#125;; then echo &quot;成功拉取镜像：$FULL_IMAGE $ARGS&quot; # 将镜像重命名为去除镜像源前缀的版本 docker tag &quot;$FULL_IMAGE&quot; &quot;$ORIGINAL_IMAGE_NAME&quot; echo &quot;镜像重命名为：$ORIGINAL_IMAGE_NAME&quot; # 可选：删除带镜像源前缀的镜像 docker rmi &quot;$FULL_IMAGE&quot; &gt;/dev/null 2&gt;&amp;1 exit 0 else echo &quot;从 $MIRROR 拉取失败，尝试下一个镜像源...&quot; fidoneecho &quot;所有镜像源尝试失败，无法拉取镜像：$ORIGINAL_IMAGE_NAME $ARGS&quot;exit 1 如何获取镜像tag docker 命令中没有提供直接获取镜像tag的命令，如果不想到dockerhub上查看，可以通过如下方式获取 通过dockerhub的api接口获取(需要科学上网) 123456789101112131415# 只显示tag名称，官方镜像替换 nginx，非官方镜像替换 libryary/nginx，page_size=5表示每页5条数据，page=1表示第一页（默认为1）curl -s &quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot; | jq &#x27;.results[].name&#x27;## 也可以使用如下url，两者效果相同## https://hub.docker.com/v2/namespaces/&#123;namespace&#125;/repositories/&#123;repository&#125;/tags?page_size=5&amp;page=1## 示例：https://hub.docker.com/v2/namespaces/library/repositories/nginx/tags?page_size=1&amp;page=1# 输出json格式，并显示最后更新时间和镜像大小curl -s &quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot; | jq &#x27;.results[] | &#123;name,last_updated,full_size&#125;&#x27;# 输出表格格式，并格式化输出curl -s &quot;https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=5&amp;page=1&quot; \\| jq -r &#x27;.results[] | &quot;\\(.name)\\t\\t\\(.last_updated | sub(&quot;T&quot;; &quot; &quot;) | sub(&quot;\\\\..*&quot;; &quot;&quot;))\\t\\t\\(((.full_size / 1024 / 1024 * 100 | round)/100) | tostring) MB&quot;&#x27; \\ | awk &#x27;&#123;printf &quot;%-30s %-20s %8.2f MB\\n&quot;, $1, $2&quot; &quot;$3, $4&#125;&#x27; 通过skopeo工具获取 1234# 这里使用容器的方式(需要科学上网)docker run --rm quay.io/skopeo/stable:latest inspect --override-os linux docker://docker.io/nginx | jq &#x27;.RepoTags[]&#x27;# 将`docker.io`替换为镜像源`docker.1ms.run`，不需要科学上网docker run --rm quay.io/skopeo/stable:latest inspect --override-os linux docker://docker.1ms.run/nginx | jq &#x27;.RepoTags[]&#x27; 为了方便使用可以编写一个脚本 12345678910111213141516171819cat &lt;&lt; EOF &gt; docker_tags#!/bin/bash# 用法提示if [ -z &quot;\\$1&quot; ]; then echo &quot;用法: \\$0 &lt;镜像名称，例如 nginx 或 library/nginx&gt;&quot; exit 1fiIMAGE_NAME=\\$1# 使用 skopeo 获取镜像信息并解析标签列表docker run --rm quay.io/skopeo/stable:latest \\\\ inspect --override-os linux docker://docker.1ms.run/\\$IMAGE_NAME \\\\ | jq &#x27;.RepoTags[]&#x27;EOFchmod +x docker_tags# 使用docker_tags nginx docker images : 列出镜像 docker image ls == docker images 123456789101112131415# 列出所有镜像，不包括悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）$ docker images# 列出所有镜像，包括悬空镜像$ docker images -a# 列出所有镜像，并显示镜像的摘要信息$ docker images --digests# 列出所有镜像，并输出为json格式$ docker images --format json# 只显示镜像名称和标签$ docker images --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;# 只显示镜像ID$ docker images -q docker inspect : 查看镜像的详细信息 docker image inspect == docker inspect 这里要注意，docker inspect如果基于名称查找会优先查找容器 1234567891011# 命令格式$ docker inspect [OPTIONS] NAME|ID [NAME|ID...]# 显示镜像的详细信息，镜像名称$ docker inspect nginx# 显示镜像的详细信息，镜像ID$ docker inspect 9f0c0d0a0f0f# 显示镜像的Labels信息，获取json中指定的字段$ docker image inspect --format=&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27; nginx docker image prune : 删除未使用的镜像 123456# 删除悬空镜像，（dangling images:没有 tag 的镜像,通常是构建中间产物,例如：&lt;none&gt;:&lt;none&gt; 形式。）$ docker image prune# 删除全部未使用镜像(未被任何一个容器引用)，包括悬空镜像$ docker image prune -a# 不进行确认提示，直接执行$ docker image prune -f docker rmi : 删除镜像 docker image rm == docker rmi 12345678910111213# 命令格式$ docker rmi [OPTIONS] IMAGE [IMAGE...]# 删除镜像，镜像名称$ docker rmi nginx# 删除多个镜像，空格分隔$ docker rmi nginx mysql# 删除镜像，镜像ID$ docker rmi 9f0c0d0a0f0f# 强制删除镜像，当镜像被容器引用时，会报错，需要使用-f参数进行强制删除$ docker rmi -f nginx# 删除全部镜像$ docker rmi $(docker images -q) docker history : 查看镜像的构建历史 docker image history == docker history 12345678910# 命令格式$ docker history [OPTIONS] IMAGE# 查看镜像的历史记录，镜像名称$ docker history nginx# 查看镜像的历史记录，镜像ID$ docker history 9f0c0d0a0f0f# 显示完整的镜像历史记录，默认`CREATED BY`中的信息太长会被截断$ docker history --no-trunc nginx# 显示为json格式$ docker history --format=json nginx docker history 显示的是构建历史，会将每一个 Dockerfile 指令都算一层，而不是物理镜像层（layer）数量，若要查看镜像的物理层数，可以通过如下命令查看 1$ docker image inspect --format &#x27;&#123;&#123; len .RootFS.Layers &#125;&#125;&#x27; nginx docker tag : 创建一个标签 docker image tag == docker tag 123456789101112# 命令格式$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]# 创建一个标签$ docker tag nginx:latest hanqunfeng/nginx:latest# 查看镜像，可以看到两个镜像的 IMAGE ID 一致$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhanqunfeng/nginx latest be69f2940aaf 5 weeks ago 192MBnginx latest be69f2940aaf 5 weeks ago 192MB# 此时若通过 IMAGE ID 删除镜像，会报错，提示被多个 REPOSITORY 关联，需要使用 -f 参数进行强制删除$ docker rmi be69f2940aafError response from daemon: conflict: unable to delete be69f2940aaf (must be forced) - image is referenced in multiple repositories docker save : 将镜像保存为 tar 归档 docker image save == docker save 123456# 命令格式$ docker save [OPTIONS] IMAGE [IMAGE...]# 将镜像保存为 tar 归档，-o 指定输出文件，文件名称任意，甚至都不需要以 .tar 结尾$ docker save -o nginx.tar nginx# 或者$ docker save nginx &gt; nginx.tar docker load : 从 tar 归档中加载镜像 docker image load == docker load 123456# 命令格式$ docker load [OPTIONS]# 从 tar 归档中加载镜像，导出tar归档时的镜像名称就是加载后的镜像名称$ docker load -i nginx.tar# -q 参数表示不显示进度条$ docker load -q -i nginx.tar docker import : 从文件创建镜像 docker image import == docker import 12345678910111213# 命令格式$ docker import [OPTIONS] FILE|URL|- [REPOSITORY[:TAG]]## 参数说明file 本地 tar 文件，例如 rootfs.tarURL 网络地址（http/https）- 从标准输入读取（比如通过管道）# 输出镜像名称与标签REPOSITORY[:TAG] 导入后镜像的名称与标签# OPTIONS--change 在导入镜像时设置 Dockerfile 指令，如 CMD、ENV、EXPOSE 等--message, -m 添加导入说明（commit message） docker import 与 docker load 的区别 命令 用途 格式 是否保留历史 docker import 导入文件系统，创建镜像(由 docker export 生成) 纯文件系统 tar 包 ❌ 不保留历史、标签等元数据 docker load 加载镜像（通常由 docker save 生成） Docker 镜像 tar（含元数据） ✅ 保留 tag、层、历史等 示例: 从容器导出再导入 1234567891011121314# 启动一个容器$ docker run -d -p 8080:80 --name nginx nginx# 导出容器文件系统，此时 nginx 容器中的所有文件都保存在 my_nginx.tar 文件中$ docker export -o my_nginx.tar nginx# 导入文件系统，导入时指定 启动命令，因为 my_nginx.tar 只是文件，并不包含任何启动命令$ docker import --change=&#x27;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#x27; my_nginx.tar nginx:my_tag# 查看镜像，镜像ID不一致$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx my_tag 4ab42de31bac 4 seconds ago 191MBnginx latest be69f2940aaf 5 weeks ago 192MB docker build : 从指定目录或URL中的 Dockerfile 构建 Docker 镜像 docker image build == docker build 123456789101112131415161718192021222324# 命令格式docker build [OPTIONS] PATH | URL | -# 参数说明PATH Dockerfile 所在的目录URL Git 仓库的 URL- 从标准输入读取 Dockerfile# 构建镜像，-t: 指定镜像名称，.: 表示从当前目录查找Dockerfile，默认文件名称为 Dockerfiledocker build -t myimage:latest .# 构建镜像，-f: 指定 Dockerfile 的相对路径，.: 表示基于当前目录，实际的 Dockerfile 路径就是 ./path/MyDockerfiledocker build -t myimage:latest -f path/MyDockerfile .# 实际的 Dockerfile 路径就是 /usr/local/path/MyDockerfiledocker build -t myimage:latest -f path/MyDockerfile /usr/local# 构建镜像，从 Git 仓库中构建，git 仓库的 Dockerfile 必须在根目录下docker build https://github.com/hanqunfeng/docker_test.git -t abc:1.0.0# 构建镜像，从 Git 仓库中构建，指定 Dockerfile 的相对路径docker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git -t abc:1.0.1# 构建镜像，从 Git 仓库中构建，指定分支或 tagdocker build -f docker/Dockerfile https://github.com/hanqunfeng/docker_test.git#release -t abc:1.0.2# 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建，但会非常慢，一般没有导致某一个层发生变化时不需要加上这个参数docker build --no-cache -t app:latest . docker build中还有一些重要的参数，以及Dockerfile文件该怎么编写，请参考Docker 命令 之 Dockerfile docker push : 推送本地镜像到远程仓库 docker image push == docker push 这里介绍如何将镜像推送到docker hub远程仓库 需要先在docker hub网站上创建一个账号，比如我的用户名是hanqunfeng 然后就可以使用下面的命令将本地镜像推送到远程仓库了 1234567891011121314151617181920212223242526272829# 查看本地镜像$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest e573c6323878 18 hours ago 191MB# 对nginx镜像打tag,前缀必须与用户名一致$ docker tag nginx hanqunfeng/nginx:1.0.0$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhanqunfeng/nginx 1.0.0 be69f2940aaf 5 weeks ago 192MBnginx latest be69f2940aaf 5 weeks ago 192MB# 登录 docker hup$ docker login -u hanqunfengi Info → A Personal Access Token (PAT) can be used instead. To create a PAT, visit https://app.docker.com/settingsPassword: # 输入密码Login Succeeded# 登录同时输入密码# docker login -u hanqunfeng -p 12345678# 登录其它仓库# docker login -u username -p password registry.orther.com# 推送到docker hub，此后就可以通过 docker pull hanqunfeng/nginx:1.0.0 获取了$ docker push hanqunfeng/nginx:1.0.0","summary":"摘要 本文介绍 Docker 命令 中 镜像管理 相关命令 Docker官方文档 Application programming interfaces (APIs)","date_published":"2025-05-22T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/20/docker-install/","url":"https://blog.hanqunfeng.com/2025/05/20/docker-install/","title":"Linux 安装 Docker","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Linux 下的 Docker 安装方法，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p>windows、macos、ubuntu等桌面系统请安装 <a href=\"https://www.docker.com/products/docker-desktop/\">Docker Desktop</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>阿里云专有服务器参考：<a href=\"https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker\">阿里云专有服务器如何安装Docker</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>腾讯云专有服务器参考：<a href=\"https://cloud.tencent.com/document/product/1207/45596\">腾讯云专有服务器如何安装Docker</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>AWS专有服务器参考：<a href=\"/2025/05/19/docker-install-aws/\" title=\"AWS专有服务器如何安装Docker\">AWS专有服务器如何安装Docker</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/install/\">安装Docker Engine</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Docker-简介\">Docker 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker 是一个开源的容器化平台，用于打包、分发和运行应用程序。它通过将应用程序及其依赖打包到一个“容器”中，确保应用在不同环境中始终能够一致运行。与传统的虚拟机相比，Docker 容器更轻量、启动更快、资源占用更少。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker 采用<code>客户端-服务器</code>架构，核心组件包括 <code>Docker Engine</code>（负责构建和运行容器）、<code>Dockerfile</code>（定义构建镜像的指令）、<code>镜像</code>（应用和依赖的只读模板）和<code>容器</code>（基于镜像运行的实例）。开发者可以通过 Docker Hub 共享或下载镜像，极大简化了部署流程。</p>\n</li>\n<li class=\"lvl-2\">\n<p>总结来说，Docker 提高了开发效率，支持持续集成与部署（CI/CD），在微服务架构中尤为常用，是现代 DevOps 流程的重要工具。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/get-started/docker-overview/\">Docker是什么？</a><br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nIdftv.png\" alt=\"\"></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Docker 仓库（Registry）</td>\n<td>Docker仓库用于存储Docker镜像。Docker Hub是一个任何人都可以使用的公共仓库，默认情况下，Docker在Docker Hub上查找图像。你也可以配置自己的私人仓库。<br>当您使用docker pull或docker run命令时，Docker会从您配置的仓库中提取所需的镜像。当您使用docker push命令时，Docker会将您的镜像推送到已配置的仓库中。</td>\n</tr>\n<tr>\n<td>Docker 守护进程（Daemon）</td>\n<td>监听Docker API请求，并管理Docker对象，如镜像、容器、网络和卷。守护程序还可以与其他守护程序通信来管理Docker服务。</td>\n</tr>\n<tr>\n<td>Docker 客户端（Client）</td>\n<td>Docker 客户端（docker）是许多用户与 Docker 交互的主要方式。当你使用如 docker run 这样的命令时，客户端会将这些命令发送给 dockerd（Docker 守护进程），由它来执行这些操作。<br>docker 命令是通过 Docker API 进行通信的。Docker 客户端可以与多个守护进程进行通信。</td>\n</tr>\n<tr>\n<td>Docker 主机（Host）</td>\n<td>运行 Docker 守护进程和容器的物理或虚拟机器。</td>\n</tr>\n<tr>\n<td>Docker 镜像（Images）</td>\n<td>创建容器的只读模板，包含运行应用所需的所有文件和配置。</td>\n</tr>\n<tr>\n<td>Docker 容器（Container）</td>\n<td>基于镜像运行的实例，是一个或多个应用的独立运行环境。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Docker-安装\">Docker 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>全新安装前需要先卸载旧版本，卸载<code>docker</code>也可以按照如下方式操作</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除Docker相关源</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -f /etc/yum.repos.d/docker*.repo</span><br><span class=\"line\"><span class=\"comment\"># 删除Docker相关软件包，dnf可能会报告您没有安装这些软件包。</span></span><br><span class=\"line\"><span class=\"comment\"># 卸载docker旧版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y remove \\</span><br><span class=\"line\">               docker \\</span><br><span class=\"line\">               docker-client \\</span><br><span class=\"line\">               docker-client-latest \\</span><br><span class=\"line\">               docker-common \\</span><br><span class=\"line\">               docker-latest \\</span><br><span class=\"line\">               docker-latest-logrotate \\</span><br><span class=\"line\">               docker-logrotate \\</span><br><span class=\"line\">               docker-engine</span><br><span class=\"line\"><span class=\"comment\"># 卸载docker新版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y remove \\</span><br><span class=\"line\">            docker-ce \\</span><br><span class=\"line\">            containerd.io \\</span><br><span class=\"line\">            docker-ce-rootless-extras \\</span><br><span class=\"line\">            docker-buildx-plugin \\</span><br><span class=\"line\">            docker-ce-cli \\</span><br><span class=\"line\">            docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除Docker数据,镜像、容器、卷和网络</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/containerd</span><br><span class=\"line\"><span class=\"comment\"># 删除Docker配置</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /etc/docker/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置docker存储库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install dnf-plugins-core</span><br><span class=\"line\"><span class=\"comment\"># 海外，添加Docker的官方存储库</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"comment\"># 国内，添加阿里云的存储库</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 Docker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装最新版本，升级 docker 时也是执行如下命令</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定版本</span></span><br><span class=\"line\"><span class=\"comment\"># 先查看所有版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf list docker-ce --showduplicates | <span class=\"built_in\">sort</span> -r</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">docker-ce.x86_64               3:26.1.3-1.el8                  docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64               3:26.1.3-1.el8                  @docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64               3:26.1.2-1.el8                  docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64               3:26.1.1-1.el8                  docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64               3:26.1.0-1.el8                  docker-ce-stable</span><br><span class=\"line\">…………………………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定版本，这里 VERSION_STRING 为版本号，例如 3:26.1.3-1.el8</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br><span class=\"line\"><span class=\"comment\">## 比如</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 如果只安装客户端用于连接远程 Docker 主机</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-ce-cli docker-buildx-plugin docker-compose-plugin -y</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>组件名称</th>\n<th>是否必需（本地运行 Docker）</th>\n<th>功能简介</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker-ce</code></td>\n<td>✅ 是</td>\n<td>Docker Engine 的核心，包括 <code>dockerd</code>（守护进程）和 <code>docker</code>（CLI）</td>\n<td>完整安装 Docker 时包含此组件</td>\n</tr>\n<tr>\n<td><code>docker-ce-cli</code></td>\n<td>✅ 是（或单独用于远程控制）</td>\n<td>Docker 命令行工具，如 <code>docker run</code>, <code>docker ps</code>, <code>docker build</code> 等</td>\n<td>可以独立安装，只用于控制远程 Docker 主机</td>\n</tr>\n<tr>\n<td><code>containerd.io</code></td>\n<td>✅ 是（本地运行容器）</td>\n<td>容器运行时，Docker 后端用于真正启动/管理容器</td>\n<td>如果你只使用 Docker CLI，不运行本地容器则不需要</td>\n</tr>\n<tr>\n<td><code>docker-buildx-plugin</code></td>\n<td>❌ 否</td>\n<td>提供 <code>docker buildx</code> 命令，支持高级构建特性（如跨平台、多阶段构建）</td>\n<td>可选，适合高级构建需求</td>\n</tr>\n<tr>\n<td><code>docker-compose-plugin</code></td>\n<td>❌ 否</td>\n<td>提供 <code>docker compose</code> 命令，用于编排多个服务</td>\n<td>如果使用 Compose，则建议安装此插件</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Docker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置Docker守护进程在系统启动时自动启动</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"><span class=\"comment\"># 启动Docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加当前用户到docker组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加当前用户到docker组，这样当前用户就可以不需要使用sudo就能使用docker命令</span></span><br><span class=\"line\"><span class=\"comment\"># 当前用户是centos</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker centos</span><br><span class=\"line\"><span class=\"comment\"># 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组</span></span><br><span class=\"line\">newgrp docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>验证 Docker 安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version <span class=\"comment\"># 查看 Docker version</span></span><br><span class=\"line\"><span class=\"comment\"># 显示 Docker 基本信息，包括版本信息，插件信息，镜像加速信息等等。</span></span><br><span class=\"line\">docker info</span><br><span class=\"line\"><span class=\"comment\"># 拉取hello-world镜像，此时国内会提示访问失败，需要添加国内镜像源</span></span><br><span class=\"line\">docker pull hello-world</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加国内镜像源</p>\n</li>\n</ul>\n<blockquote>\n<p>目前国内大部分的Docker镜像源都关闭了，另外阿里云的Docker镜像源只允许在阿里云的机器上使用。<br>\n参考：<a href=\"https://blog.xuanyuan.me/archives/1154\">Docker/DockerHub 国内镜像源/加速列表</a>,<a href=\"https://status.1panel.top/status/docker\">国内 Docker 服务状态 &amp; 镜像加速监控</a><br>\n注意：国内镜像源的更新会比官网滞后，但只要不是获取最新版本基本上是够用的。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/docker/daemon.json &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;registry-mirrors&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &quot;https://docker.1ms.run&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;https://docker.xuanyuan.me&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;https://docker.m.daocloud.io&quot;</span></span><br><span class=\"line\"><span class=\"string\">    ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启Docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以通过如下命令查看是否配置生效，查看 Registry Mirrors 中的配置</span></span><br><span class=\"line\">docker info</span><br><span class=\"line\"><span class=\"comment\"># 验证国内镜像源</span></span><br><span class=\"line\">docker pull hello-world</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker命令自动补全，参考：<a href=\"https://docs.docker.com/engine/cli/completion/\">官方文档</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用的bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装bash-completion</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install bash-completion -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加自动补全到当前登录用户</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOT &gt;&gt; ~/.bashrc</span></span><br><span class=\"line\"><span class=\"string\">if [ -f /etc/bash_completion ]; then</span></span><br><span class=\"line\"><span class=\"string\">    . /etc/bash_completion</span></span><br><span class=\"line\"><span class=\"string\">fi</span></span><br><span class=\"line\"><span class=\"string\">EOT</span></span><br><span class=\"line\"><span class=\"comment\"># 刷新bash</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建自动补全文件</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.local/share/bash-completion/completions</span><br><span class=\"line\">docker completion bash &gt; ~/.local/share/bash-completion/completions/docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动一个新的bash</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> bash</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>/var/lib/docker</code> 用于存储 Docker 运行时生成的数据，如镜像、容器、网络、卷、配置文件、日志等，其目录结构说明如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>目录名</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>buildkit/</code></td>\n<td>存放 Docker BuildKit 构建缓存和状态信息；构建镜像时的中间文件和上下文会存于此，空间占用可能较大。</td>\n</tr>\n<tr>\n<td><code>containers/</code></td>\n<td>每个容器一个子目录，包含配置文件和运行日志（如 <code>container.log</code>），用于容器的运行状态记录和管理。</td>\n</tr>\n<tr>\n<td><code>engine-id</code></td>\n<td>存储 Docker 引擎的唯一 ID，Docker 安装时生成，常用于 swarm 节点识别。</td>\n</tr>\n<tr>\n<td><code>image/</code></td>\n<td>镜像的元数据（不含实际 layer 数据），组织镜像的结构、标签、驱动等信息。</td>\n</tr>\n<tr>\n<td><code>network/</code></td>\n<td>网络配置及状态信息，如默认 <code>bridge</code> 网络、自定义网络配置等。</td>\n</tr>\n<tr>\n<td><code>overlay2/</code></td>\n<td>镜像和容器实际的数据层（overlay2 是存储驱动），包含所有联合文件系统层，是 Docker 中最大的空间使用者。</td>\n</tr>\n<tr>\n<td><code>plugins/</code></td>\n<td>存放 Docker 插件（如网络、卷插件）的配置和数据，一般为空，除非使用了扩展插件。</td>\n</tr>\n<tr>\n<td><code>runtimes/</code></td>\n<td>支持的 OCI runtime 配置目录，如默认的 <code>runc</code>，也可能包含其他 runtime（如 <code>kata</code>, <code>gvisor</code>）。</td>\n</tr>\n<tr>\n<td><code>swarm/</code></td>\n<td>Docker swarm 模式下的集群元数据与节点状态，仅在初始化 swarm 后存在实际数据。</td>\n</tr>\n<tr>\n<td><code>tmp/</code></td>\n<td>Docker 的临时文件目录，如镜像下载缓存、挂载操作中的临时文件，通常可以清理但需小心。</td>\n</tr>\n<tr>\n<td><code>volumes/</code></td>\n<td>Docker 卷的数据目录，每个卷一个子目录，卷中的持久化数据实际存放于此。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>/var/lib/containerd</code> 是 Containerd 守护进程的默认数据存储目录。Containerd 是 Docker 和其他容器平台（如 Kubernetes）底层的 容器运行时（Container Runtime），负责拉取镜像、管理容器生命周期、挂载文件系统等操作。其目录结构说明如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>目录名</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>io.containerd.content.v1.content/</code></td>\n<td>存储镜像 layer 的实际二进制内容（blob），遵循 OCI 镜像规范，是镜像和容器文件系统的数据来源。</td>\n</tr>\n<tr>\n<td><code>io.containerd.metadata.v1.bolt/</code></td>\n<td>使用 BoltDB 存储 containerd 的元数据（如镜像信息、容器状态、快照引用等），是 containerd 的核心元数据数据库。</td>\n</tr>\n<tr>\n<td><code>io.containerd.runtime.v1.linux/</code></td>\n<td>存储旧版（v1 API）运行时容器信息，目前已逐步被 <code>v2</code> 接口取代，仅在向后兼容场景中存在。</td>\n</tr>\n<tr>\n<td><code>io.containerd.runtime.v2.task/</code></td>\n<td>存储 v2 运行时接口下容器的运行时状态，如容器进程的 shim、PID、日志路径等，是容器实际运行时所依赖的。</td>\n</tr>\n<tr>\n<td><code>io.containerd.snapshotter.v1.native/</code></td>\n<td>使用 native 模式存储的容器快照（文件系统层），直接复制底层文件；性能较差，占用空间较大，主要用于测试或特定用途。</td>\n</tr>\n<tr>\n<td><code>io.containerd.snapshotter.v1.overlayfs/</code></td>\n<td>使用 overlayfs 模式存储容器的文件系统快照（镜像层和容器层）；这是生产环境默认的高效存储驱动。</td>\n</tr>\n<tr>\n<td><code>tmpmounts/</code></td>\n<td>临时挂载点目录，containerd 用于镜像解包、中间构建过程中的挂载操作，通常是构建或运行过程的临时数据。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>MacOS/Windows下无法查看<code>/var/lib/docker</code>的解决方法</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">在 MacOS/Windows 上使用Docker时，是启动了一个虚拟机来运行docker的，由于其运行在虚拟机内部，直接查找<code>/var/lib/docker</code>路径是无效的。</li>\n<li class=\"lvl-2\">解决方法如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个临时容器，并进入其内部</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh</span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\">--it</span><br><span class=\"line\">    交互式地运行容器,并分配一个伪终端</span><br><span class=\"line\"></span><br><span class=\"line\">--<span class=\"built_in\">rm</span></span><br><span class=\"line\">    退出容器时，自动删除容器</span><br><span class=\"line\"></span><br><span class=\"line\">--privileged</span><br><span class=\"line\">    给容器特权权限，这意味着容器几乎拥有宿主机的所有能力，能访问 /dev、修改内核参数等。非常强大但也很危险。</span><br><span class=\"line\"></span><br><span class=\"line\">--pid=host</span><br><span class=\"line\">    容器共享宿主机的进程命名空间（PID Namespace）。</span><br><span class=\"line\">    这使得容器可以看到并访问宿主机的所有进程（包括 PID 1，即系统 init 进程）。</span><br><span class=\"line\"></span><br><span class=\"line\">debian</span><br><span class=\"line\">    使用的基础镜像是 Debian，容器里运行的是这个系统。</span><br><span class=\"line\"></span><br><span class=\"line\">nsenter -t 1 -m -u -n -i sh</span><br><span class=\"line\">    这是容器内部运行的命令，用来进入宿主机的命名空间：</span><br><span class=\"line\">        nsenter：Linux 工具，用于进入其他进程的命名空间。</span><br><span class=\"line\">        -t 1：指定目标进程的 PID 是 1（宿主机的 init 或 systemd）。</span><br><span class=\"line\">        -m：进入目标进程的 Mount Namespace（文件系统挂载）。</span><br><span class=\"line\">        -u：进入目标的 UTS Namespace（主机名等）。</span><br><span class=\"line\">        -n：进入目标的 Network Namespace（网络）。</span><br><span class=\"line\">        -i：进入目标的 IPC Namespace（进程间通信）。</span><br><span class=\"line\">        sh：在这些命名空间中执行一个 shell。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">这个命令启动一个基于 Debian 的容器，给它所有特权，让它能看到宿主机的进程，然后使用 nsenter 进入 PID 为 1 的所有命名空间（相当于进入宿主机的视角），最后启动一个 sh，你就在容器里 “变成了宿主机”。</li>\n<li class=\"lvl-2\">这样，你就可以在这个容器中查看<code>/var/lib/docker</code>目录了。</li>\n</ul>\n</div>\n","content_text":"摘要 本文介绍 Linux 下的 Docker 安装方法，本文以 CentOS 8 为例。 windows、macos、ubuntu等桌面系统请安装 Docker Desktop。 阿里云专有服务器参考：阿里云专有服务器如何安装Docker 腾讯云专有服务器参考：腾讯云专有服务器如何安装Docker AWS专有服务器参考：AWS专有服务器如何安装Docker Docker官方文档 安装Docker Engine Docker 简介 Docker 是一个开源的容器化平台，用于打包、分发和运行应用程序。它通过将应用程序及其依赖打包到一个“容器”中，确保应用在不同环境中始终能够一致运行。与传统的虚拟机相比，Docker 容器更轻量、启动更快、资源占用更少。 Docker 采用客户端-服务器架构，核心组件包括 Docker Engine（负责构建和运行容器）、Dockerfile（定义构建镜像的指令）、镜像（应用和依赖的只读模板）和容器（基于镜像运行的实例）。开发者可以通过 Docker Hub 共享或下载镜像，极大简化了部署流程。 总结来说，Docker 提高了开发效率，支持持续集成与部署（CI/CD），在微服务架构中尤为常用，是现代 DevOps 流程的重要工具。 Docker是什么？ 名称 描述 Docker 仓库（Registry） Docker仓库用于存储Docker镜像。Docker Hub是一个任何人都可以使用的公共仓库，默认情况下，Docker在Docker Hub上查找图像。你也可以配置自己的私人仓库。当您使用docker pull或docker run命令时，Docker会从您配置的仓库中提取所需的镜像。当您使用docker push命令时，Docker会将您的镜像推送到已配置的仓库中。 Docker 守护进程（Daemon） 监听Docker API请求，并管理Docker对象，如镜像、容器、网络和卷。守护程序还可以与其他守护程序通信来管理Docker服务。 Docker 客户端（Client） Docker 客户端（docker）是许多用户与 Docker 交互的主要方式。当你使用如 docker run 这样的命令时，客户端会将这些命令发送给 dockerd（Docker 守护进程），由它来执行这些操作。docker 命令是通过 Docker API 进行通信的。Docker 客户端可以与多个守护进程进行通信。 Docker 主机（Host） 运行 Docker 守护进程和容器的物理或虚拟机器。 Docker 镜像（Images） 创建容器的只读模板，包含运行应用所需的所有文件和配置。 Docker 容器（Container） 基于镜像运行的实例，是一个或多个应用的独立运行环境。 Docker 安装 全新安装前需要先卸载旧版本，卸载docker也可以按照如下方式操作 123456789101112131415161718192021222324252627# 删除Docker相关源sudo rm -f /etc/yum.repos.d/docker*.repo# 删除Docker相关软件包，dnf可能会报告您没有安装这些软件包。# 卸载docker旧版本sudo dnf -y remove \\ docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine# 卸载docker新版本sudo dnf -y remove \\ docker-ce \\ containerd.io \\ docker-ce-rootless-extras \\ docker-buildx-plugin \\ docker-ce-cli \\ docker-compose-plugin# 删除Docker数据,镜像、容器、卷和网络sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd# 删除Docker配置sudo rm -rf /etc/docker/ 设置docker存储库 12345sudo dnf -y install dnf-plugins-core# 海外，添加Docker的官方存储库sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 国内，添加阿里云的存储库sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装 Docker 123456789101112131415161718192021# 安装最新版本，升级 docker 时也是执行如下命令sudo dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 安装指定版本# 先查看所有版本sudo dnf list docker-ce --showduplicates | sort -r## 输出docker-ce.x86_64 3:26.1.3-1.el8 docker-ce-stabledocker-ce.x86_64 3:26.1.3-1.el8 @docker-ce-stabledocker-ce.x86_64 3:26.1.2-1.el8 docker-ce-stabledocker-ce.x86_64 3:26.1.1-1.el8 docker-ce-stabledocker-ce.x86_64 3:26.1.0-1.el8 docker-ce-stable…………………………# 安装指定版本，这里 VERSION_STRING 为版本号，例如 3:26.1.3-1.el8sudo dnf install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin -y## 比如sudo dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y## 如果只安装客户端用于连接远程 Docker 主机sudo dnf install docker-ce-cli docker-buildx-plugin docker-compose-plugin -y 组件名称 是否必需（本地运行 Docker） 功能简介 备注 docker-ce ✅ 是 Docker Engine 的核心，包括 dockerd（守护进程）和 docker（CLI） 完整安装 Docker 时包含此组件 docker-ce-cli ✅ 是（或单独用于远程控制） Docker 命令行工具，如 docker run, docker ps, docker build 等 可以独立安装，只用于控制远程 Docker 主机 containerd.io ✅ 是（本地运行容器） 容器运行时，Docker 后端用于真正启动/管理容器 如果你只使用 Docker CLI，不运行本地容器则不需要 docker-buildx-plugin ❌ 否 提供 docker buildx 命令，支持高级构建特性（如跨平台、多阶段构建） 可选，适合高级构建需求 docker-compose-plugin ❌ 否 提供 docker compose 命令，用于编排多个服务 如果使用 Compose，则建议安装此插件 启动 Docker 1234# 设置Docker守护进程在系统启动时自动启动sudo systemctl enable docker# 启动Dockersudo systemctl start docker 添加当前用户到docker组 12345# 添加当前用户到docker组，这样当前用户就可以不需要使用sudo就能使用docker命令# 当前用户是centossudo usermod -aG docker centos# 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组newgrp docker 验证 Docker 安装 12345docker version # 查看 Docker version# 显示 Docker 基本信息，包括版本信息，插件信息，镜像加速信息等等。docker info# 拉取hello-world镜像，此时国内会提示访问失败，需要添加国内镜像源docker pull hello-world 添加国内镜像源 目前国内大部分的Docker镜像源都关闭了，另外阿里云的Docker镜像源只允许在阿里云的机器上使用。 参考：Docker/DockerHub 国内镜像源/加速列表,国内 Docker 服务状态 &amp; 镜像加速监控 注意：国内镜像源的更新会比官网滞后，但只要不是获取最新版本基本上是够用的。 123456789101112131415161718sudo tee /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;: [ &quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot; ]&#125;EOF# 重启Dockersudo systemctl daemon-reloadsudo systemctl restart docker# 可以通过如下命令查看是否配置生效，查看 Registry Mirrors 中的配置docker info# 验证国内镜像源docker pull hello-world Docker命令自动补全，参考：官方文档 1234567891011121314151617181920# 使用的bash# 安装bash-completionsudo dnf install bash-completion -y# 添加自动补全到当前登录用户cat &lt;&lt;EOT &gt;&gt; ~/.bashrcif [ -f /etc/bash_completion ]; then . /etc/bash_completionfiEOT# 刷新bashsource ~/.bashrc# 创建自动补全文件mkdir -p ~/.local/share/bash-completion/completionsdocker completion bash &gt; ~/.local/share/bash-completion/completions/docker# 启动一个新的bashexec bash /var/lib/docker 用于存储 Docker 运行时生成的数据，如镜像、容器、网络、卷、配置文件、日志等，其目录结构说明如下： 目录名 作用说明 buildkit/ 存放 Docker BuildKit 构建缓存和状态信息；构建镜像时的中间文件和上下文会存于此，空间占用可能较大。 containers/ 每个容器一个子目录，包含配置文件和运行日志（如 container.log），用于容器的运行状态记录和管理。 engine-id 存储 Docker 引擎的唯一 ID，Docker 安装时生成，常用于 swarm 节点识别。 image/ 镜像的元数据（不含实际 layer 数据），组织镜像的结构、标签、驱动等信息。 network/ 网络配置及状态信息，如默认 bridge 网络、自定义网络配置等。 overlay2/ 镜像和容器实际的数据层（overlay2 是存储驱动），包含所有联合文件系统层，是 Docker 中最大的空间使用者。 plugins/ 存放 Docker 插件（如网络、卷插件）的配置和数据，一般为空，除非使用了扩展插件。 runtimes/ 支持的 OCI runtime 配置目录，如默认的 runc，也可能包含其他 runtime（如 kata, gvisor）。 swarm/ Docker swarm 模式下的集群元数据与节点状态，仅在初始化 swarm 后存在实际数据。 tmp/ Docker 的临时文件目录，如镜像下载缓存、挂载操作中的临时文件，通常可以清理但需小心。 volumes/ Docker 卷的数据目录，每个卷一个子目录，卷中的持久化数据实际存放于此。 /var/lib/containerd 是 Containerd 守护进程的默认数据存储目录。Containerd 是 Docker 和其他容器平台（如 Kubernetes）底层的 容器运行时（Container Runtime），负责拉取镜像、管理容器生命周期、挂载文件系统等操作。其目录结构说明如下： 目录名 作用说明 io.containerd.content.v1.content/ 存储镜像 layer 的实际二进制内容（blob），遵循 OCI 镜像规范，是镜像和容器文件系统的数据来源。 io.containerd.metadata.v1.bolt/ 使用 BoltDB 存储 containerd 的元数据（如镜像信息、容器状态、快照引用等），是 containerd 的核心元数据数据库。 io.containerd.runtime.v1.linux/ 存储旧版（v1 API）运行时容器信息，目前已逐步被 v2 接口取代，仅在向后兼容场景中存在。 io.containerd.runtime.v2.task/ 存储 v2 运行时接口下容器的运行时状态，如容器进程的 shim、PID、日志路径等，是容器实际运行时所依赖的。 io.containerd.snapshotter.v1.native/ 使用 native 模式存储的容器快照（文件系统层），直接复制底层文件；性能较差，占用空间较大，主要用于测试或特定用途。 io.containerd.snapshotter.v1.overlayfs/ 使用 overlayfs 模式存储容器的文件系统快照（镜像层和容器层）；这是生产环境默认的高效存储驱动。 tmpmounts/ 临时挂载点目录，containerd 用于镜像解包、中间构建过程中的挂载操作，通常是构建或运行过程的临时数据。 MacOS/Windows下无法查看/var/lib/docker的解决方法 在 MacOS/Windows 上使用Docker时，是启动了一个虚拟机来运行docker的，由于其运行在虚拟机内部，直接查找/var/lib/docker路径是无效的。 解决方法如下： 12345678910111213141516171819202122232425262728# 启动一个临时容器，并进入其内部docker run --rm -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh## 说明--it 交互式地运行容器,并分配一个伪终端--rm 退出容器时，自动删除容器--privileged 给容器特权权限，这意味着容器几乎拥有宿主机的所有能力，能访问 /dev、修改内核参数等。非常强大但也很危险。--pid=host 容器共享宿主机的进程命名空间（PID Namespace）。 这使得容器可以看到并访问宿主机的所有进程（包括 PID 1，即系统 init 进程）。debian 使用的基础镜像是 Debian，容器里运行的是这个系统。nsenter -t 1 -m -u -n -i sh 这是容器内部运行的命令，用来进入宿主机的命名空间： nsenter：Linux 工具，用于进入其他进程的命名空间。 -t 1：指定目标进程的 PID 是 1（宿主机的 init 或 systemd）。 -m：进入目标进程的 Mount Namespace（文件系统挂载）。 -u：进入目标的 UTS Namespace（主机名等）。 -n：进入目标的 Network Namespace（网络）。 -i：进入目标的 IPC Namespace（进程间通信）。 sh：在这些命名空间中执行一个 shell。 这个命令启动一个基于 Debian 的容器，给它所有特权，让它能看到宿主机的进程，然后使用 nsenter 进入 PID 为 1 的所有命名空间（相当于进入宿主机的视角），最后启动一个 sh，你就在容器里 “变成了宿主机”。 这样，你就可以在这个容器中查看/var/lib/docker目录了。","summary":"摘要 本文介绍 Linux 下的 Docker 安装方法，本文以 CentOS 8 为例。 windows、macos、ubuntu等桌面系统请安装 Docker Desktop。 阿里云专有服务器参考：阿里云专有服务器如何安装Docker 腾讯云专有服务器参考：腾讯云专有服务器如何安装Docker AWS专有服务器参考：AWS专有服务器如何安装Docker Docker官方文档 安装Docker Engine","date_published":"2025-05-20T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/19/docker-install-aws/","url":"https://blog.hanqunfeng.com/2025/05/19/docker-install-aws/","title":"AWS专有服务器如何安装Docker","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在 AWS 专有服务器上安装 Docker</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Update and install Docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum update -y</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Amazon Linux 2</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> amazon-linux-extras install docker -y</span><br><span class=\"line\"><span class=\"comment\"># Amazon Linux 2023</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install docker -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> curl -L <span class=\"string\">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class=\"subst\">$(uname -s)</span>-<span class=\"subst\">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make the docker-compose command available</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable Docker service</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"><span class=\"comment\"># Start the service</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br><span class=\"line\"><span class=\"comment\"># Add the current user to the docker group</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker ec2-user</span><br><span class=\"line\"><span class=\"comment\"># 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组</span></span><br><span class=\"line\">newgrp docker</span><br><span class=\"line\"><span class=\"comment\"># Check Docker version</span></span><br><span class=\"line\">docker version</span><br><span class=\"line\"><span class=\"comment\"># Test Docker</span></span><br><span class=\"line\">docker run hello-world</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍如何在 AWS 专有服务器上安装 Docker 12345678910111213141516171819202122232425262728# Update and install Dockersudo yum update -y# Amazon Linux 2sudo amazon-linux-extras install docker -y# Amazon Linux 2023sudo yum install docker -y# Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# Make the docker-compose command availablesudo chmod +x /usr/local/bin/docker-compose# Enable Docker servicesudo systemctl enable docker# Start the servicesudo systemctl start docker# Add the current user to the docker groupsudo usermod -aG docker ec2-user# 让组权限立即生效最稳妥的做法是：注销并重新登录远程主机，但也可以尝试用下面命令立即加载新组newgrp docker# Check Docker versiondocker version# Test Dockerdocker run hello-world","summary":"摘要 本文介绍如何在 AWS 专有服务器上安装 Docker","date_published":"2025-05-19T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/13/jvm-tools-01/","url":"https://blog.hanqunfeng.com/2025/05/13/jvm-tools-01/","title":"JVM 之 命令行工具","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍JVM的命令行工具</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\">JDK8 The Java® Virtual Machine Specification</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\">JDK8的java指令的官⽅⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/index.html\">JDK⼯具官⽹⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html\">JDK17的java指令的官⽅⽂档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"JVM-的参数-三类\">JVM 的参数(三类)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>标准参数: 以<code>-</code>开头，所有 HotSpot 都⽀持。例如<code>java -version</code>。这类参数可以使⽤<code>java -help</code> 或者<code>java -?</code>全部打印出来</p>\n</li>\n<li class=\"lvl-2\">\n<p>⾮标准参数: 以<code>-X</code>开头，是特定 HotSpot版本⽀持的指令。例如<code>java -Xms200M -Xmx200M</code>。这类指令可以⽤<code>java -X</code> 全部打印出来。</p>\n</li>\n<li class=\"lvl-2\">\n<p>不稳定参数: 这也是 JVM调优的噩梦。以<code>-XX</code> 开头，这些参数是跟特定HotSpot版本对应的，很有可能换个版本就没有了。详细的⽂档资料也特别少。JDK8 中的以下⼏个指令可以帮助开发者了解 JDK8 中的这⼀类不稳定参数。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintFlagsInitial -version   <span class=\"comment\"># 所有参数的默认值</span></span><br><span class=\"line\">java -XX:+PrintFlagsFinal -version      <span class=\"comment\"># 所有参数最终⽣效的值。</span></span><br><span class=\"line\">java -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version      <span class=\"comment\"># 所有参数最终⽣效的值，包含实验性参数。</span></span><br><span class=\"line\">java -XX:+PrintCommandLineFlags -version <span class=\"comment\"># 当前命令生效的值，可以看到是⽤的哪种GC。 JDK1.8默认⽤的ParallelGC</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行-java-XX-UnlockExperimentalVMOptions-XX-PrintFlagsFinal-version-返回值说明\">运行 <code>java -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version</code> 返回值说明</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Global flags]</span><br><span class=\"line\">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;</span><br><span class=\"line\">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;</span><br><span class=\"line\">     bool AdjustConcurrency                         = <span class=\"literal\">false</span>                               &#123;product&#125;</span><br><span class=\"line\">     bool AggressiveHeap                            = <span class=\"literal\">false</span>                               &#123;product&#125;</span><br><span class=\"line\">     bool AggressiveOpts                            = <span class=\"literal\">false</span>                               &#123;product&#125;</span><br><span class=\"line\">     intx AliasLevel                                = 3                                   &#123;C2 product&#125;</span><br><span class=\"line\">     ………………………………</span><br><span class=\"line\"><span class=\"comment\"># 格式：flag类型，flag名称，flag值，flag来源与作用域修饰符</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>flag类型:</p>\n</li>\n</ul>\n<blockquote>\n<p>jdk8</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标识符</th>\n<th>含义</th>\n<th>描述说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>intx</code></td>\n<td>有符号整数（int extended）</td>\n<td>用于表示带符号整数型参数</td>\n</tr>\n<tr>\n<td><code>uintx</code></td>\n<td>无符号整数（unsigned int extended）</td>\n<td>表示非负整数型参数</td>\n</tr>\n<tr>\n<td><code>uint64_t</code></td>\n<td>无符号 64 位整数</td>\n<td>适用于需要更大整数值的参数，比如内存大小、纳秒时间戳等</td>\n</tr>\n<tr>\n<td><code>bool</code></td>\n<td>布尔型</td>\n<td><code>true</code> 或 <code>false</code>，表示开关型参数。<code>+</code>表示开启，<code>-</code>表示关闭。 如 <code>-XX:+UseG1GC</code>，表示开启 G1 回收器功能。</td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>双精度浮点型</td>\n<td>用于表示浮点数值类型的 JVM 参数</td>\n</tr>\n<tr>\n<td><code>ccstr</code></td>\n<td>常量 C 字符串指针</td>\n<td>表示字符串参数（不可变）</td>\n</tr>\n<tr>\n<td><code>ccstrlist</code></td>\n<td>C 字符串列表</td>\n<td>表示以逗号分隔的字符串列表</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>jdk11后出现更多的类型</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标识符</th>\n<th>含义</th>\n<th>描述说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>int</code></td>\n<td>有符号整数,通常是 32 位</td>\n<td>JVM 内部使用的普通 int 参数</td>\n</tr>\n<tr>\n<td><code>uint</code></td>\n<td>无符号整数,通常是 32 位</td>\n<td>少量用于特殊场景的参数</td>\n</tr>\n<tr>\n<td><code>size_t</code></td>\n<td>内存大小</td>\n<td>表示内存大小参数（单位一般为字节）,jdk11后出现，原来是 <code>uintx</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>flag来源与作用域修饰符</p>\n</li>\n</ul>\n<blockquote>\n<p>jdk8</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#123;product&#125;</code></td>\n<td>正式产品参数（用户可用，可通过 <code>-XX:</code> 进行设置）</td>\n</tr>\n<tr>\n<td><code>&#123;pd product&#125;</code></td>\n<td>平台相关的正式参数（platform-dependent），在某些操作系统/CPU 上可用</td>\n</tr>\n<tr>\n<td><code>&#123;C1 product&#125;</code></td>\n<td>仅在使用 <strong>C1 编译器（优化编译器）</strong> 时有效的参数</td>\n</tr>\n<tr>\n<td><code>&#123;C2 product&#125;</code></td>\n<td>仅在使用 <strong>C2 编译器（优化编译器）</strong> 时有效的参数</td>\n</tr>\n<tr>\n<td><code>&#123;manageable&#125;</code></td>\n<td>可通过 JMX 动态管理的参数（运行时可调整）</td>\n</tr>\n<tr>\n<td><code>&#123;ARCH product&#125;</code></td>\n<td>与 CPU 架构相关的产品参数（如 x86、ARM 等）</td>\n</tr>\n<tr>\n<td><code>&#123;lp64_product&#125;</code></td>\n<td>仅在 64 位 JVM 上才有效的产品参数</td>\n</tr>\n<tr>\n<td><code>&#123;experimental&#125;</code></td>\n<td>实验性的 参数，可能在将来的版本中删除或更改。需要开启 -XX:+UnlockExperimentalVMOptions</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>jdk11后出现更多的类型</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#123;C1 pd product&#125;</code></td>\n<td>平台相关的正式参数,仅在使用 <strong>C1 编译器（优化编译器）</strong> 时有效的参数</td>\n</tr>\n<tr>\n<td><code>&#123;C2 pd product&#125;</code></td>\n<td>平台相关的正式参数,仅在使用 <strong>C2 编译器（优化编译器）</strong> 时有效的参数</td>\n</tr>\n<tr>\n<td><code>&#123;JVMCI product&#125;</code></td>\n<td>此参数适用于 JVMCI 或 Graal 编译器相关功能，jdk21添加</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>另外，jdk11+ 中，最后还会多出一列，其作用是说明该参数的设置来源</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>来源标识</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#123;default&#125;</code></td>\n<td>使用的是该参数的默认值（没有被用户或系统设置）</td>\n</tr>\n<tr>\n<td><code>&#123;command line&#125;</code></td>\n<td>用户通过命令行显式设置的参数（如 <code>-XX:+UseG1GC</code>）</td>\n</tr>\n<tr>\n<td><code>&#123;ergonomic&#125;</code></td>\n<td>JVM 根据系统环境自动选择的值（自适应设置）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"jps-查看当前jvm中的进程\">jps: 查看当前jvm中的进程</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看java进程ID</span></span><br><span class=\"line\">jps</span><br><span class=\"line\"><span class=\"comment\"># 查看java进程信息，包括ID和启动类或jar的名称</span></span><br><span class=\"line\">jps -l</span><br><span class=\"line\"><span class=\"comment\"># 查看启动java进程时传递给jvm的参数设置</span></span><br><span class=\"line\">jps -v</span><br><span class=\"line\"><span class=\"comment\"># 查看java进程信息，同时显示启动java进程时传递给jvm的参数设置</span></span><br><span class=\"line\">jps -lv</span><br></pre></td></tr></table></figure>\n<h2 id=\"jinfo-查看JVM参数\">jinfo: 查看JVM参数</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>jinfo 是 JDK 自带的命令行工具之一，用于 查看和修改正在运行中的 Java 进程的配置信息，主要包括 JVM 参数、系统属性等信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 Java 9+ 之后被标记为 deprecated，建议改用 jcmd 替代</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看正在运行的 JVM 参数</span></span><br><span class=\"line\">jinfo &lt;PID&gt;</span><br><span class=\"line\"><span class=\"comment\"># jcmd 命令，分成三个</span></span><br><span class=\"line\">jcmd &lt;pid&gt; VM.flags <span class=\"comment\"># VM Flags</span></span><br><span class=\"line\">jcmd &lt;pid&gt; VM.system_properties <span class=\"comment\"># System Properties</span></span><br><span class=\"line\">jcmd &lt;pid&gt; VM.command_line <span class=\"comment\"># Command Line</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定进程的系统属性（-sysprops）</span></span><br><span class=\"line\">jinfo -sysprops &lt;PID&gt;</span><br><span class=\"line\"><span class=\"comment\"># jcmd 命令</span></span><br><span class=\"line\">jcmd &lt;pid&gt; VM.system_properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 动态修改 JVM 参数（仅支持部分参数）</span></span><br><span class=\"line\">jinfo -flag [+|-]&lt;flagname&gt; &lt;pid&gt;</span><br><span class=\"line\"><span class=\"comment\">## 例：打开 GC 日志</span></span><br><span class=\"line\">jinfo -flag +PrintGC &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查是否开启了某个 JVM 特性（如 UseG1GC）</span></span><br><span class=\"line\">jinfo -flag UseG1GC &lt;pid&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"jstat-查看指定JAVA进程的运行状态\">jstat: 查看指定JAVA进程的运行状态</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看运行状态</span></span><br><span class=\"line\">jstat -gc &lt;PID&gt;</span><br><span class=\"line\"><span class=\"comment\"># 查看运行状态，每隔5000毫秒输出一次，共输出20次</span></span><br><span class=\"line\">jstat -gc &lt;PID&gt; 5000 20</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">512.0  512.0   0.0   224.0  29696.0  27138.2   105984.0   96531.8   122368.0 114450.4 15360.0 14018.9    733    5.099   4      0.833    5.931</span><br><span class=\"line\">512.0  512.0   0.0   224.0  29696.0  27203.9   105984.0   96531.8   122368.0 114450.4 15360.0 14018.9    733    5.099   4      0.833    5.931</span><br><span class=\"line\">512.0  512.0   0.0   224.0  29696.0  27220.4   105984.0   96531.8   122368.0 114450.4 15360.0 14018.9    733    5.099   4      0.833    5.931</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>内存区统计（单位：KB）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>S0C</strong></td>\n<td>Survivor 0 区的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>S1C</strong></td>\n<td>Survivor 1 区的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>S0U</strong></td>\n<td>Survivor 0 区已使用内存（KB）</td>\n</tr>\n<tr>\n<td><strong>S1U</strong></td>\n<td>Survivor 1 区已使用内存（KB）</td>\n</tr>\n<tr>\n<td><strong>EC</strong></td>\n<td>Eden 区的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>EU</strong></td>\n<td>Eden 区已使用内存（KB）</td>\n</tr>\n<tr>\n<td><strong>OC</strong></td>\n<td>Old Generation（老年代）的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>OU</strong></td>\n<td>Old Generation 已使用内存（KB）</td>\n</tr>\n<tr>\n<td><strong>MC</strong></td>\n<td>Metaspace（元空间）的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>MU</strong></td>\n<td>Metaspace 已使用内存（KB）</td>\n</tr>\n<tr>\n<td><strong>CCSC</strong></td>\n<td>Compressed Class Space 的容量（KB）</td>\n</tr>\n<tr>\n<td><strong>CCSU</strong></td>\n<td>Compressed Class Space 已使用内存（KB）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>GC 次数与耗时(从应用程序启动到采样时)</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>YGC</strong></td>\n<td>Young GC（Minor GC） 的累计次数</td>\n</tr>\n<tr>\n<td><strong>YGCT</strong></td>\n<td>Young GC 累计耗时（单位：秒）</td>\n</tr>\n<tr>\n<td><strong>FGC</strong></td>\n<td>Full GC 的累计次数</td>\n</tr>\n<tr>\n<td><strong>FGCT</strong></td>\n<td>Full GC 累计耗时（单位：秒）</td>\n</tr>\n<tr>\n<td><strong>GCT</strong></td>\n<td>GC 总耗时（YGCT + FGCT，总和）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"jstack-查看指定JAVA进程中各线程的调用堆栈\">jstack: 查看指定JAVA进程中各线程的调用堆栈</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印线程的标准栈信息（栈帧 + 线程状态）</span></span><br><span class=\"line\">jstack &lt;PID&gt;</span><br><span class=\"line\"><span class=\"comment\"># 在标准输出基础上，额外打印线程拥有的锁（monitor）和 waited on 锁对象信息</span></span><br><span class=\"line\">jstack -l &lt;PID&gt;</span><br><span class=\"line\"><span class=\"comment\"># 输出到文件</span></span><br><span class=\"line\">jstack -l &lt;PID&gt; &gt; jstack.tdump <span class=\"comment\"># 这个文件名后缀只是为了方便 jvisualvm 查看</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;idle-connection-reaper&quot;</span> <span class=\"comment\">#68 daemon prio=5 os_prio=0 tid=0x00007f38b6ae2800 nid=0x62e9 waiting on condition [0x00007f385b0f5000]</span></span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">\tat java.lang.Thread.<span class=\"built_in\">sleep</span>(Native Method)</span><br><span class=\"line\">\tat software.amazon.awssdk.http.apache.internal.conn.IdleConnectionReaper<span class=\"variable\">$ReaperTask</span>.run(IdleConnectionReaper.java:151)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor<span class=\"variable\">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:750)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- &lt;0x00000000c561cfd8&gt; (a java.util.concurrent.ThreadPoolExecutor<span class=\"variable\">$Worker</span>)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>jstack输出内容含义</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&quot;idle-connection-reaper&quot;</code></td>\n<td>线程名称。这个线程是 AWS SDK 中用于清理空闲连接的后台线程。</td>\n</tr>\n<tr>\n<td><code>#68</code></td>\n<td>线程 ID（Java 层分配的编号）。</td>\n</tr>\n<tr>\n<td><code>daemon</code></td>\n<td>表示这是一个 <strong>守护线程</strong>。JVM 退出时不会等待守护线程运行结束。</td>\n</tr>\n<tr>\n<td><code>prio=5</code></td>\n<td>Java 层的线程优先级（默认 1–10，5 是默认）。</td>\n</tr>\n<tr>\n<td><code>os_prio=0</code></td>\n<td>操作系统层线程优先级（取决于操作系统和 JVM 的实现）。</td>\n</tr>\n<tr>\n<td><code>tid=0x00007f38b6ae2800</code></td>\n<td>线程 ID（Java 层使用的地址标识）。</td>\n</tr>\n<tr>\n<td><code>nid=0x62e9</code></td>\n<td>Native ID，操作系统分配的线程 ID（十六进制表示），可以通过命令<code>printf &quot;%d\\n&quot; 0x62e9</code>转换为10进制。<br>  <code>ps -Lp &lt;PID&gt;</code> 和 <code>top -Hp &lt;PID&gt;</code> 展示的线程id是10进制</td>\n</tr>\n<tr>\n<td><code>waiting on condition</code></td>\n<td>线程状态说明：正在等待某种条件，一般指 <code>sleep()</code> 或 <code>wait()</code> 等。</td>\n</tr>\n<tr>\n<td><code>[0x00007f385b0f5000]</code></td>\n<td>栈帧的内存地址。</td>\n</tr>\n<tr>\n<td><code>java.lang.Thread.State: TIMED_WAITING (sleeping)</code></td>\n<td>线程状态。</td>\n</tr>\n<tr>\n<td><code>at java.lang.Thread.sleep(Native Method)</code> <br> …………………………</td>\n<td>线程调用栈信息，包括调用方法、调用参数、调用栈帧。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>另外还有如下信息，表示此线程持有的可拥有同步器（例如 ReentrantLock），具体内容如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Locked ownable synchronizers:</span><br><span class=\"line\">\t- &lt;0x00000000c561cfd8&gt; (a java.util.concurrent.ThreadPoolExecutor<span class=\"variable\">$Worker</span>)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;0x00000000c561cfd8&gt;</code></td>\n<td>持有锁的对象地址。可以在其他线程中查找这个地址，以判断死锁等问题。</td>\n</tr>\n<tr>\n<td><code>(a ThreadPoolExecutor$Worker)</code></td>\n<td>表示该锁属于 <code>ThreadPoolExecutor</code> 的某个 <code>Worker</code> 线程（这是线程池的工作线程）。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>线程状态</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>含义</th>\n<th>常见原因 / 示例方法</th>\n<th>示例 jstack 输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RUNNABLE</code></td>\n<td>线程正在运行或准备运行，等待 CPU 时间片。</td>\n<td>线程活跃运行中</td>\n<td><code>&quot;Thread-0&quot; #1 prio=5 os_prio=0 tid=0x00007f8d9c001000 nid=0x1a runnable [0x00007f8dbf7fe000]</code></td>\n</tr>\n<tr>\n<td><code>BLOCKED (on object monitor)</code></td>\n<td>等待获取对象的监视器锁（同步锁），即等待进入同步块或方法。</td>\n<td><code>synchronized</code> 同步块或方法</td>\n<td><code>&quot;Thread-1&quot; #2 prio=5 os_prio=0 tid=0x00007f8d9c002000 nid=0x1b waiting for monitor entry [0x00007f8dbeaff000]</code></td>\n</tr>\n<tr>\n<td><code>WAITING (on object monitor)</code></td>\n<td>无限期等待其他线程执行某操作。</td>\n<td><code>Object.wait()</code><br><code>Thread.join()</code><br><code>LockSupport.park()</code><br><code>Condition.await()</code></td>\n<td><code>&quot;Thread-2&quot; #3 prio=5 os_prio=0 tid=0x00007f8d9c003000 nid=0x1c waiting on condition [0x00007f8dbebff000]</code></td>\n</tr>\n<tr>\n<td><code>TIMED_WAITING (on object monitor)</code></td>\n<td>等待固定时间，直到条件满足或超时。</td>\n<td><code>Object.wait(long)</code><br><code>Thread.sleep(long)</code><br><code>Condition.awaitNanos(long)</code><br><code>DelayQueue.take()</code></td>\n<td><code>&quot;Thread-3&quot; #4 prio=5 os_prio=0 tid=0x00007f8d9c004000 nid=0x1d timed_waiting [0x00007f8dbebff000]</code></td>\n</tr>\n<tr>\n<td><code>TERMINATED</code></td>\n<td>线程已运行完毕并退出（通常不在 jstack 中显示）。</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用jstack检查死锁\">使用jstack检查死锁</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>死锁是指多个线程互相等待对方释放锁，导致无法继续运行的情况。</p>\n</li>\n</ul>\n<h4 id=\"直接查找-Found-one-Java-level-deadlock-提示\">直接查找 <code>Found one Java-level deadlock</code> 提示</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Found one Java-level deadlock:</span><br><span class=\"line\">=============================</span><br><span class=\"line\"><span class=\"string\">&quot;Thread-1&quot;</span>:</span><br><span class=\"line\">  waiting to lock monitor 0x0000000005c0a098 (object 0x00000000d5c10a70, a java.lang.Object),</span><br><span class=\"line\">  <span class=\"built_in\">which</span> is held by <span class=\"string\">&quot;Thread-2&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Thread-2&quot;</span>:</span><br><span class=\"line\">  waiting to lock monitor 0x0000000005c0a128 (object 0x00000000d5c10aa0, a java.lang.Object),</span><br><span class=\"line\">  <span class=\"built_in\">which</span> is held by <span class=\"string\">&quot;Thread-1&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>表示两个线程互相等待对方释放锁，造成死锁。</p>\n</li>\n<li class=\"lvl-2\">\n<p>目前只支持找出 <code>synchronized</code> 关键字阻塞住的线程，如果是 <code>java.util.concurrent.Lock</code> 目前还不支持。</p>\n</li>\n</ul>\n<h4 id=\"手动判断死锁的特征（如果没有上面的提示）\">手动判断死锁的特征（如果没有上面的提示）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 JVM 没有显式提示，你可以通过以下死锁特征进行手动识别：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线程处于 <code>BLOCKED</code> 状态</td>\n<td>线程被锁阻塞在 <code>monitor</code> 上。</td>\n</tr>\n<tr>\n<td><code>waiting to lock</code> 和 <code>locked</code> 出现交叉</td>\n<td>一个线程正在等待另一个线程持有的锁，而另一个线程也在等待当前线程的锁。</td>\n</tr>\n<tr>\n<td>没有能继续执行的线程</td>\n<td>多个线程都处于 <code>BLOCKED</code> 状态，且相互依赖。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>在 Java 8 之后支持获取 JVM 内部线程</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">VM 内部线程包括下面几种：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>线程类型</th>\n<th>示例名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JIT（Just-In-Time）编译线程</td>\n<td>C1 CompilerThread0, C2 CompilerThread0</td>\n</tr>\n<tr>\n<td>GC 线程</td>\n<td>GC Thread0, G1 Young RemSet Sampling</td>\n</tr>\n<tr>\n<td>其它内部线程</td>\n<td>VM Periodic Task Thread, VM Thread, Service Thread</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>自 JDK 7 及以上版本开始，HotSpot JVM 默认启用了：分层编译（Tiered Compilation），即同时使用 C1 和 C2 编译器。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>编译器</th>\n<th>特性</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>C1（Client Compiler）</strong></td>\n<td>编译速度快，优化少</td>\n<td>程序启动时使用，提升启动速度</td>\n</tr>\n<tr>\n<td><strong>C2（Server Compiler）</strong></td>\n<td>编译速度慢，优化强</td>\n<td>热点代码达到一定门槛后使用，提升长期运行性能</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>JVM 启动后，先解释执行字节码；热点代码首先由 C1 编译器处理；如果进一步变热，交由 C2 编译器优化；整个过程由 JVM 自动管理，不需要手动干预。</p>\n</blockquote>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>是否可以指定只用某个编译器？是的，你可以用 JVM 参数控制，但真没必要。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-client</code></td>\n<td>使用 C1 编译器（适合启动快）</td>\n</tr>\n<tr>\n<td><code>-server</code></td>\n<td>使用 C2 编译器（适合长时间运行的服务）</td>\n</tr>\n<tr>\n<td><code>-XX:-TieredCompilation</code></td>\n<td>禁用分层编译，仅使用 <code>-client</code> 或 <code>-server</code> 指定的编译器</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"jmap-分析运行中-Java-进程的内存使用情况\">jmap: 分析运行中 Java 进程的内存使用情况</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>jmap 比较消耗内存，所以不推荐生产环境使用。</p>\n</li>\n</ul>\n<h3 id=\"jmap-histo-pid-查看类实例数量及占用内存\"><code>jmap -histo &lt;pid&gt;</code>: 查看类实例数量及占用内存</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmap -histo 25238</span><br><span class=\"line\">25238:</span><br><span class=\"line\"></span><br><span class=\"line\"> num     <span class=\"comment\">#instances         #bytes  class name</span></span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:        106175       10838440  [C</span><br><span class=\"line\">   2:         94344        3019008  java.util.concurrent.ConcurrentHashMap<span class=\"variable\">$Node</span></span><br><span class=\"line\">   3:        105529        2532696  java.lang.String</span><br><span class=\"line\">   4:         11203        2496608  [B</span><br><span class=\"line\">   5:         20178        2430136  [Ljava.lang.Object;</span><br><span class=\"line\">   6:         21642        2399904  java.lang.Class</span><br><span class=\"line\">…………………………</span><br><span class=\"line\">Total        857252       51328200</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># num: 序号</span></span><br><span class=\"line\"><span class=\"comment\"># instances: 实例数量</span></span><br><span class=\"line\"><span class=\"comment\"># bytes: 实例字节数</span></span><br><span class=\"line\"><span class=\"comment\"># class name: 类名, [C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[L is a List</span></span><br><span class=\"line\"><span class=\"comment\"># Total: 总数</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-heap-pid-查看堆使用情况\"><code>jmap -heap &lt;pid&gt;</code>: 查看堆使用情况</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmap -heap 25238</span><br><span class=\"line\">Attaching to process ID 25238, please <span class=\"built_in\">wait</span>...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.371-b11</span><br><span class=\"line\"></span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Parallel GC with 2 thread(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration:    <span class=\"comment\"># 堆配置</span></span><br><span class=\"line\">   MinHeapFreeRatio         = 0                     <span class=\"comment\"># 最小空闲百分比</span></span><br><span class=\"line\">   MaxHeapFreeRatio         = 100                     <span class=\"comment\"># 最大空闲百分比</span></span><br><span class=\"line\">   MaxHeapSize              = 1010827264 (964.0MB)    <span class=\"comment\"># 最大堆大小</span></span><br><span class=\"line\">   NewSize                  = 21495808 (20.5MB)       <span class=\"comment\"># 新生代大小</span></span><br><span class=\"line\">   MaxNewSize               = 336592896 (321.0MB)     <span class=\"comment\"># 新生代最大大小</span></span><br><span class=\"line\">   OldSize                  = 43515904 (41.5MB)       <span class=\"comment\"># 老年代大小</span></span><br><span class=\"line\">   NewRatio                 = 2                       <span class=\"comment\"># 新生代与老年代比例</span></span><br><span class=\"line\">   SurvivorRatio            = 8                       <span class=\"comment\"># 幸存者比例</span></span><br><span class=\"line\">   MetaspaceSize            = 21807104 (20.796875MB)   <span class=\"comment\"># 元空间大小</span></span><br><span class=\"line\">   CompressedClassSpaceSize = 1073741824 (1024.0MB)   <span class=\"comment\"># 压缩类空间大小，用于存储所有 类指针（Klass pointer）</span></span><br><span class=\"line\">   MaxMetaspaceSize         = 17592186044415 MB       <span class=\"comment\"># 元空间最大大小</span></span><br><span class=\"line\">   G1HeapRegionSize         = 0 (0.0MB)               <span class=\"comment\"># G1堆大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:       <span class=\"comment\"># 堆使用情况</span></span><br><span class=\"line\">PS Young Generation <span class=\"comment\"># 年轻生代</span></span><br><span class=\"line\">Eden Space:         <span class=\"comment\"># Eden 区</span></span><br><span class=\"line\">   capacity = 30932992 (29.5MB)    <span class=\"comment\">#  Eden 区大小</span></span><br><span class=\"line\">   used     = 16705104 (15.931228637695312MB) <span class=\"comment\">#  Eden 区使用情况</span></span><br><span class=\"line\">   free     = 14227888 (13.568771362304688MB) <span class=\"comment\">#  Eden 区剩余情况</span></span><br><span class=\"line\">   54.00416487354343% used                    <span class=\"comment\">#  Eden 区使用百分比</span></span><br><span class=\"line\">From Space:                      <span class=\"comment\"># 幸存者区 survivor0</span></span><br><span class=\"line\">   capacity = 524288 (0.5MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 524288 (0.5MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">To Space:                       <span class=\"comment\"># 幸存者区 survivor1</span></span><br><span class=\"line\">   capacity = 524288 (0.5MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 524288 (0.5MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">PS Old Generation                <span class=\"comment\"># 老年代</span></span><br><span class=\"line\">   capacity = 193462272 (184.5MB)</span><br><span class=\"line\">   used     = 43292112 (41.28657531738281MB)</span><br><span class=\"line\">   free     = 150170160 (143.2134246826172MB)</span><br><span class=\"line\">   22.377547597497458% used</span><br><span class=\"line\"></span><br><span class=\"line\">38722 interned Strings occupying 4184168 bytes. <span class=\"comment\"># 堆中字符串数量及占用内存</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"jmap-dump-live-format-b-file-file-pid-创建一个快照，并保存到文件中\"><code>jmap -dump:live,format=b,file=&lt;file&gt; &lt;pid&gt;</code>: 创建一个快照，并保存到文件中</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个快照，并保存到当前目录下</span></span><br><span class=\"line\">$ jmap -dump:live,format=b,file=test.hprof 25238</span><br><span class=\"line\">Dumping heap to /tmp/test.hprof ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n<h2 id=\"jcmd-可以替代jmap命令，jdk1-8-推荐使用\">jcmd: 可以替代<code>jmap</code>命令，<code>jdk1.8+</code>推荐使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>jcmd</code> 是 <code>JDK</code> 的一个命令行工具，用于管理 <code>JVM</code>，<code>jcmd</code> 可以查看 <code>JVM</code> 的运行状态、查看堆内存信息、触发 GC、查看线程信息、查看类信息等等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境不建议使用<code>jmap</code>，因其会占用大量内存，推荐使用 <code>jcmd</code>。</p>\n</li>\n</ul>\n<h3 id=\"jcmd-pid-GC-heap-info-查看堆使用情况\"><code>jcmd &lt;pid&gt; GC.heap_info</code>: 查看堆使用情况</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>类似 <code>jmap -heap &lt;pid&gt;</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jcmd 25238 GC.heap_info</span><br><span class=\"line\">25238:</span><br><span class=\"line\"> PSYoungGen      total 30208K, used 23593K [0x00000000ebf00000, 0x00000000edd80000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 29696K, 78% used [0x00000000ebf00000,0x00000000ed5d2560,0x00000000edc00000)</span><br><span class=\"line\">  from space 512K, 43% used [0x00000000edd00000,0x00000000edd38000,0x00000000edd80000)</span><br><span class=\"line\">  to   space 512K, 0% used [0x00000000edc80000,0x00000000edc80000,0x00000000edd00000)</span><br><span class=\"line\"> ParOldGen       total 105984K, used 96547K [0x00000000c3c00000, 0x00000000ca380000, 0x00000000ebf00000)</span><br><span class=\"line\">  object space 105984K, 91% used [0x00000000c3c00000,0x00000000c9a48f10,0x00000000ca380000)</span><br><span class=\"line\"> Metaspace       used 114450K, capacity 122262K, committed 122368K, reserved 1157120K</span><br><span class=\"line\">  class space    used 14018K, capacity 15294K, committed 15360K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<h3 id=\"jcmd-pid-GC-class-histogram-查看类加载情况\"><code>jcmd &lt;pid&gt; GC.class_histogram</code>: 查看类加载情况</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>类似 <code>jmap -histo &lt;pid&gt;</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jcmd 25238 GC.class_histogram</span><br><span class=\"line\">25238:</span><br><span class=\"line\"></span><br><span class=\"line\"> num     <span class=\"comment\">#instances         #bytes  class name</span></span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:        106175       10838440  [C</span><br><span class=\"line\">   2:         94344        3019008  java.util.concurrent.ConcurrentHashMap<span class=\"variable\">$Node</span></span><br><span class=\"line\">   3:        105529        2532696  java.lang.String</span><br><span class=\"line\">   4:         11203        2496608  [B</span><br><span class=\"line\">   5:         20178        2430136  [Ljava.lang.Object;</span><br><span class=\"line\">   6:         21642        2399904  java.lang.Class</span><br><span class=\"line\">…………………………</span><br><span class=\"line\">Total        857252       51328200</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># num: 序号</span></span><br><span class=\"line\"><span class=\"comment\"># instances: 实例数量</span></span><br><span class=\"line\"><span class=\"comment\"># bytes: 实例字节数</span></span><br><span class=\"line\"><span class=\"comment\"># class name: 类名, [C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[L is a List</span></span><br><span class=\"line\"><span class=\"comment\"># Total: 总数</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"jcmd-pid-GC-heap-dump-path-to-heap-hprof-导出-heap-dump\"><code>jcmd &lt;pid&gt; GC.heap_dump /path/to/heap.hprof</code>: 导出 heap dump</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>替代 <code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code>，但仍会有停顿（触发FullGC），dump 过程慢，生产环境慎重使用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jcmd 25238 GC.heap_dump ./heap.hprof</span><br><span class=\"line\">25238:</span><br><span class=\"line\">Heap dump file created</span><br><span class=\"line\"><span class=\"comment\"># 注意这里使用的是相对目录，./heap.hprof，但此时 &quot;./&quot; 并不是运行命令时所在的目录，而是指 Java 进程的工作目录，如果你不知道工作目录，可以通过如下命令查看</span></span><br><span class=\"line\">jcmd &lt;pid&gt; VM.system_properties | grep <span class=\"string\">&quot;user.dir&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># linux下也可以通过如下命令查看</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /proc/&lt;pid&gt;/cwd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为生产环境不推荐使用 <code>jmap</code> 或 <code>jcmd</code> 导出 heap dump，所以我们需要在生产环境中配置如下jvm参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+HeadDumpOnOutOfMemoryError <span class=\"comment\"># 内存溢出（OOM）时会自动保存堆内存快照文件</span></span><br><span class=\"line\">-XX:HeapDumpPath=/path/to/dump.hprof <span class=\"comment\"># 指定堆内存快照文件保存路径，如果不配置，则默认保存在 Java 进程的工作目录下，文件名称默认为 java_&lt;pid&gt;.hprof</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"jhat-分析-Java-Heap-Dump-文件（-hprof）的工具\">jhat: 分析 Java Heap Dump 文件（.hprof）的工具</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>jhat（Java Heap Analysis Tool）是 JDK 附带的一个用于**分析 Java Heap Dump 文件（.hprof）**的工具。它可以将堆快照作为 HTTP 服务加载，并允许你通过浏览器交互式地查看和查询对象信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>不过需要注意的是：<br>\n🔺 从 JDK 9 起，jhat 已被官方废弃，推荐使用更强大的工具如 <code>VisualVM</code>、<code>Eclipse MAT</code> 或 <code>jcmd + 外部工具</code>。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认端口7000</span></span><br><span class=\"line\">jhat &lt;heap dump file&gt;</span><br><span class=\"line\"><span class=\"comment\"># 指定端口</span></span><br><span class=\"line\">jhat -port 8000 &lt;heap dump file&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"jvisualvm-图形化的-JVM-监控与分析工具\">jvisualvm: 图形化的 JVM 监控与分析工具</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>jvisualvm（全称：Java VisualVM）是 Java 官方提供的一款 图形化的 JVM 监控与分析工具，用于观察、分析和调试正在运行的 Java 程序。它非常适合开发和测试环境中进行内存分析、线程分析、GC 行为观察等任务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>功能概览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>进程监控</strong></td>\n<td>查看本地或远程 JVM 进程的内存、CPU、线程等运行状态</td>\n</tr>\n<tr>\n<td><strong>内存使用分析</strong></td>\n<td>查看堆内存使用情况、GC 次数和时间、类实例分布等</td>\n</tr>\n<tr>\n<td><strong>线程分析</strong></td>\n<td>查看线程状态、线程栈、是否存在死锁</td>\n</tr>\n<tr>\n<td><strong>GC 分析</strong></td>\n<td>图形化展示 GC 活动、频率与耗时</td>\n</tr>\n<tr>\n<td><strong>堆转储分析</strong></td>\n<td>导入 <code>.hprof</code> 文件进行对象实例、类、引用关系分析</td>\n</tr>\n<tr>\n<td><strong>CPU 分析</strong></td>\n<td>分析方法调用路径、耗时、热点代码（需手动启用 CPU profiler）</td>\n</tr>\n<tr>\n<td><strong>插件支持</strong></td>\n<td>可以通过插件安装更多功能（如 Visual GC）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 jvisualvm</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不要在生产环境使用，如果是分析服务端 .hprof 文件，可以导出到本地后在本地启动</span></span><br><span class=\"line\">$ jvisualvm</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 jvisualvm 中导入 .hprof 文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jvisualvm --openfile &lt;heap dump file&gt;</span><br><span class=\"line\"><span class=\"comment\"># 或者 先打开 jvisualvm 后，点击 File -&gt; Open File -&gt; 选择 .hprof 文件</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 注意事项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>注意点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不适用于大规模生产环境监控</td>\n<td>因为其分析过程可能会对 JVM 有轻微影响</td>\n</tr>\n<tr>\n<td><code>.hprof</code> 文件过大时加载缓慢</td>\n<td>可配合 Eclipse MAT 使用</td>\n</tr>\n<tr>\n<td>CPU/Memory Profiler 会增加系统负担</td>\n<td>使用时谨慎，建议只在测试环境启用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Eclipse-MAT-Java-Heap-Dump-分析工具\">Eclipse MAT: Java Heap Dump 分析工具</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://eclipse.dev/mat\">Eclipse MAT</a>（Eclipse Memory Analyzer Tool）是一个用于分析 Java 堆快照的工具，它提供了许多功能来帮助开发人员理解 Java 应用程序中的内存问题。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>MaxOS系统安装Eclipse MAT后，启动报错，报错信息为：The JVM shared library “/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/…/lib/server/libjvm.dylib” does not contain the JNI_CreateJavaVM symbol.</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">解决方法：<br>\n1.在应用列表，找到<code>MemoryAnalyzer.app</code>，然后右键单击后，选择<code>显示包内容</code>,进入Contents目录，找到<code>Info.plist</code>文件<br>\n2.打开<code>Info.plist</code>文件后，可以看到注释<code>&lt;string&gt;-vm&lt;/string&gt;</code>配置项，我们需要做的就是打开这个配置项，并且将其设置为我们系统的Java路径，最新版需要<code>jdk17+</code></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>-vm<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>/Users/hanqf/develop_soft/jdk17/bin/java<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"Arthas-推荐\">Arthas : 推荐</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://arthas.aliyun.com\">Arthas</a> 是阿里巴巴开源的一款 Java 诊断工具，专为线上诊断而设计。它可以帮助开发者在不重启、不修改代码的情况下，排查生产环境中 Java 应用的问题。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Arthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意一点，就是Arthas从<code>4.x</code>版本开始，需要依赖<code>JDK8+</code>，如果是<code>JDK6/7</code>，可以下载最后一个3.x版本 <a href=\"https://github.com/alibaba/arthas/releases/tag/arthas-all-3.7.2\">3.7.2</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为了方便我们学习，Arthas还为我们提供了一个练习场，<a href=\"https://killercoda.com/arthas/course/arthas-tutorials-cn\">Arthas Playground</a>。</p>\n</li>\n</ul>\n<h3 id=\"Arthas-核心特点\">Arthas 核心特点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无需重启、侵入性低<br>\nArthas 可以 attach 到正在运行的 JVM 上，不需要重启服务或修改源代码。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令式交互体验<br>\n类似 Linux shell 的操作方式，支持 tab 补全、上下键历史命令等，非常直观。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实时查看和监控<br>\n可查看方法参数、返回值、调用栈、执行耗时、JVM 线程、内存等实时数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>多种连接方式<br>\n支持命令行终端、本地 shell、Web 页面、telnet 等多种连接方式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持多种 JVM 版本<br>\n支持 Java 6+，包括 OpenJDK、Oracle JDK、Alibaba Dragonwell 等。</p>\n</li>\n</ul>\n<h3 id=\"Arthas-常用命令\">Arthas 常用命令</h3>\n<h4 id=\"启动\">启动</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar arthas-boot.jar</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br><span class=\"line\">[INFO] JAVA_HOME: /Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home/jre</span><br><span class=\"line\">[INFO] arthas-boot version: 4.0.5</span><br><span class=\"line\">[INFO] Process 43959 already using port 3658</span><br><span class=\"line\">[INFO] Process 43959 already using port 8563</span><br><span class=\"line\">[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.</span><br><span class=\"line\">* [1]: 43959 demo-arthas-spring-boot.jar</span><br><span class=\"line\">  [2]: 50851 org.jetbrains.idea.maven.server.RemoteMavenServer36</span><br><span class=\"line\">  [3]: 50813 org.sonarsource.sonarlint.core.backend.cli.SonarLintServerCli</span><br><span class=\"line\">  [4]: 50655 com.intellij.idea.Main</span><br><span class=\"line\"><span class=\"comment\"># 启动后，会自动进入交互模式，此时输入要监控的进程序号</span></span><br><span class=\"line\">1 <span class=\"comment\"># 比如这里输入 1 回车</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[INFO] arthas home: /Users/hanqf/.arthas/lib/4.0.5/arthas</span><br><span class=\"line\">[INFO] The target process already listen port 3658, skip attach.</span><br><span class=\"line\">[INFO] arthas-client connect 0.0.0.0 3658</span><br><span class=\"line\">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class=\"line\"> /  O  \\ |  .--. <span class=\"string\">&#x27;&#x27;</span>--.  .--<span class=\"string\">&#x27;|  &#x27;</span>--<span class=\"string\">&#x27;  | /  O  \\ &#x27;</span>   .-<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|  .-.  ||  &#x27;</span>--<span class=\"string\">&#x27;.&#x27;</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class=\"line\">|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-<span class=\"string\">&#x27;    |</span></span><br><span class=\"line\"><span class=\"string\">`--&#x27;</span> `--<span class=\"string\">&#x27;`--&#x27;</span> <span class=\"string\">&#x27;--&#x27;</span>   `--<span class=\"string\">&#x27;   `--&#x27;</span>  `--<span class=\"string\">&#x27;`--&#x27;</span> `--<span class=\"string\">&#x27;`-----&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">wiki        https://arthas.aliyun.com/doc</span><br><span class=\"line\">tutorials   https://arthas.aliyun.com/doc/arthas-tutorials.html</span><br><span class=\"line\">version     4.0.5</span><br><span class=\"line\">main_class  demo-arthas-spring-boot.jar</span><br><span class=\"line\">pid         43959</span><br><span class=\"line\">start_time  2025-05-14 14:57:18.031</span><br><span class=\"line\">currnt_time 2025-05-14 14:59:22.004</span><br><span class=\"line\"></span><br><span class=\"line\">[arthas@43959]$ <span class=\"comment\"># 此时进入 arthas 命令行交互状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出 arthas</span></span><br><span class=\"line\">[arthas@43959]$ stop <span class=\"comment\"># 退出 arthas</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>arthas 命令有很多，当常用的也就几个，另外如果记不住某个命令怎么用了可以通过如下命令查询</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"built_in\">command</span>&gt; -h 或者 <span class=\"built_in\">help</span> &lt;<span class=\"built_in\">command</span>&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dashboard-实时查看-JVM-运行状态\">dashboard :  实时查看 JVM 运行状态</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 JVM 运行状态， 默认每隔 5 秒刷新 CPU、内存、线程、GC 等信息</span></span><br><span class=\"line\"><span class=\"comment\"># 默认会一直刷新状态，按 `q` 或  `Ctrl+C` 退出</span></span><br><span class=\"line\">dashboard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每隔 2 秒刷新一次</span></span><br><span class=\"line\">dashboard -i 2000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 刷新 10 次后停止</span></span><br><span class=\"line\">dashboard -n 10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每隔 2 秒刷新一次，刷新 10 次后停止</span></span><br><span class=\"line\">dashboard -i 2000 -n 10</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/2L73Hi.png\" alt=\"\" width=\"1400\" height=\"900\"></p>\n<h4 id=\"thread-查看当前-JVM-线程信息\">thread : 查看当前 JVM 线程信息</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前 JVM 线程信息，按 CPU 使用率倒序</span></span><br><span class=\"line\">thread</span><br><span class=\"line\"><span class=\"comment\"># 查看所有线程信息</span></span><br><span class=\"line\">thread --all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定线程的堆栈信息</span></span><br><span class=\"line\">thread 18</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;http-nio-80-exec-1&quot;</span> Id=18 WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer<span class=\"variable\">$ConditionObject</span>@51866c16</span><br><span class=\"line\">    at sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">    -  waiting on java.util.concurrent.locks.AbstractQueuedSynchronizer<span class=\"variable\">$ConditionObject</span>@51866c16</span><br><span class=\"line\">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class=\"line\">    at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class=\"variable\">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class=\"line\">    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class=\"line\">    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)</span><br><span class=\"line\">    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)</span><br><span class=\"line\">    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class=\"line\">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class=\"line\">    at java.util.concurrent.ThreadPoolExecutor<span class=\"variable\">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class=\"line\">    at org.apache.tomcat.util.threads.TaskThread<span class=\"variable\">$WrappingRunnable</span>.run(TaskThread.java:61)</span><br><span class=\"line\">    at java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看最忙的前5个线程的堆栈信息</span></span><br><span class=\"line\">thread -n 5</span><br><span class=\"line\"><span class=\"comment\"># 查看全部线程的堆栈信息</span></span><br><span class=\"line\">thread -n -1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 cpu 使用率统计的采样间隔，单位为毫秒，默认值为 200</span></span><br><span class=\"line\">thread -i 500</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找出当前阻塞其他线程的线程</span></span><br><span class=\"line\">thread -b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定状态的线程</span></span><br><span class=\"line\">thread --state WAITING</span><br></pre></td></tr></table></figure>\n<h4 id=\"sc-查看-JVM-已加载的类信息\">sc : 查看 JVM 已加载的类信息</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Search-Class</code> 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通配符匹配，打印搜索到的类全名</span></span><br><span class=\"line\">sc *.demo.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印类的详细信息</span></span><br><span class=\"line\">sc -d com.example.demo.arthas.AdminFilterConfig</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印出类的 Field 信息</span></span><br><span class=\"line\">sc -d -f com.example.demo.arthas.AdminFilterConfig</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通配符查询并获取classLoaderHash</span></span><br><span class=\"line\">sc -d *AdminFilterConfig | grep classLoaderHash</span><br></pre></td></tr></table></figure>\n<h4 id=\"sm-查看已加载类的方法信息\">sm  : 查看已加载类的方法信息</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Search-Method</code> 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Method 信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印指定类中的方法</span></span><br><span class=\"line\">sm java.lang.String</span><br><span class=\"line\"><span class=\"comment\"># 展示方法的详细信息</span></span><br><span class=\"line\">sm -d java.lang.String</span><br><span class=\"line\"><span class=\"comment\"># 展示指定方法的详细信息</span></span><br><span class=\"line\">sm -d java.lang.String substring</span><br><span class=\"line\"><span class=\"comment\"># 模糊匹配</span></span><br><span class=\"line\">sm -d java.lang.String eq*</span><br></pre></td></tr></table></figure>\n<h4 id=\"jad-Java源码反编译工具\">jad : Java源码反编译工具</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>验证生产环境下的代码是否与提交的代码一致</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印出类的源码，类名</span></span><br><span class=\"line\">jad com.example.demo.arthas.user.UserController</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">jad com.example.demo.arthas.user.UserController</span><br><span class=\"line\"></span><br><span class=\"line\">ClassLoader:</span><br><span class=\"line\">+-org.springframework.boot.loader.LaunchedURLClassLoader@5b2133b1</span><br><span class=\"line\">  +-sun.misc.Launcher<span class=\"variable\">$AppClassLoader</span>@5c647e05</span><br><span class=\"line\">    +-sun.misc.Launcher<span class=\"variable\">$ExtClassLoader</span>@452b3a41</span><br><span class=\"line\"></span><br><span class=\"line\">Location:</span><br><span class=\"line\">file:/Users/hanqf/Desktop/arhtas_dir/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/</span><br><span class=\"line\"></span><br><span class=\"line\">       /*</span><br><span class=\"line\">        * Decompiled with CFR.</span><br><span class=\"line\">        *</span><br><span class=\"line\">        * Could not load the following classes:</span><br><span class=\"line\">        *  com.example.demo.arthas.user.User</span><br><span class=\"line\">        *  org.slf4j.Logger</span><br><span class=\"line\">        *  org.slf4j.LoggerFactory</span><br><span class=\"line\">        *  org.springframework.web.bind.annotation.GetMapping</span><br><span class=\"line\">        *  org.springframework.web.bind.annotation.PathVariable</span><br><span class=\"line\">        *  org.springframework.web.bind.annotation.RestController</span><br><span class=\"line\">        */</span><br><span class=\"line\">       package com.example.demo.arthas.user;</span><br><span class=\"line\"></span><br><span class=\"line\">       import com.example.demo.arthas.user.User;</span><br><span class=\"line\">       import org.slf4j.Logger;</span><br><span class=\"line\">       import org.slf4j.LoggerFactory;</span><br><span class=\"line\">       import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\">       import org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\">       import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">       @RestController</span><br><span class=\"line\">       public class UserController &#123;</span><br><span class=\"line\">           private static final Logger logger = LoggerFactory.getLogger(UserController.class);</span><br><span class=\"line\"></span><br><span class=\"line\">           @GetMapping(value=&#123;<span class=\"string\">&quot;/user/&#123;id&#125;&quot;</span>&#125;)</span><br><span class=\"line\">           public User findUserById(@PathVariable Integer <span class=\"built_in\">id</span>) &#123;</span><br><span class=\"line\">/*15*/         logger.info(<span class=\"string\">&quot;id: &#123;&#125;&quot;</span>, (Object)<span class=\"built_in\">id</span>);</span><br><span class=\"line\">/*17*/         <span class=\"keyword\">if</span> (<span class=\"built_in\">id</span> != null &amp;&amp; <span class=\"built_in\">id</span> &lt; 1) &#123;</span><br><span class=\"line\">                   throw new IllegalArgumentException(<span class=\"string\">&quot;id &lt; 1&quot;</span>);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"built_in\">return</span> new User(id.intValue(), <span class=\"string\">&quot;name&quot;</span> + <span class=\"built_in\">id</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Affect(row-cnt:1) cost <span class=\"keyword\">in</span> 411 ms.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 反编译后的源码会有类加载器的信息，如果只希望打印源码，可以加上 --source-only</span></span><br><span class=\"line\">jad --source-only com.example.demo.arthas.user.UserController</span><br><span class=\"line\"><span class=\"comment\"># 不显示行号</span></span><br><span class=\"line\">jad --source-only com.example.demo.arthas.user.UserController --lineNumber <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出到文件</span></span><br><span class=\"line\">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印出类中某个方法的源码，类名 + 方法名</span></span><br><span class=\"line\">jad com.example.demo.arthas.user.UserController findUserById</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 反编译时指定dump class文件目录</span></span><br><span class=\"line\">jad --source-only com.example.demo.arthas.user.UserController --lineNumber <span class=\"literal\">false</span> -d /tmp/jad</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当有多个 ClassLoader 都加载了这个类时，jad 命令会输出对应 ClassLoader 实例的 hashcode，然后你只需要重新执行 jad 命令，并使用参数 -c <hashcode> 就可以反编译指定 ClassLoader 加载的那个类了；</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jad org.apache.log4j.Logger</span><br><span class=\"line\"></span><br><span class=\"line\">Found more than one class <span class=\"keyword\">for</span>: org.apache.log4j.Logger, Please use jad -c hashcode org.apache.log4j.Logger</span><br><span class=\"line\">HASHCODE  CLASSLOADER</span><br><span class=\"line\">69dcaba4  +-monitor<span class=\"string\">&#x27;s ModuleClassLoader</span></span><br><span class=\"line\"><span class=\"string\">6e51ad67  +-java.net.URLClassLoader@6e51ad67</span></span><br><span class=\"line\"><span class=\"string\">            +-sun.misc.Launcher$AppClassLoader@6951a712</span></span><br><span class=\"line\"><span class=\"string\">            +-sun.misc.Launcher$ExtClassLoader@6fafc4c2</span></span><br><span class=\"line\"><span class=\"string\">2bdd9114  +-pandora-qos-service&#x27;</span>s ModuleClassLoader</span><br><span class=\"line\">4c0df5f8  +-pandora-framework<span class=\"string\">&#x27;s ModuleClassLoader</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Affect(row-cnt:0) cost in 38 ms.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 指定类加载器</span></span><br><span class=\"line\"><span class=\"string\">$ jad org.apache.log4j.Logger -c 69dcaba4</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"mc-Memory-Compiler-内存编译器，编译-java文件生成-class\">mc : Memory Compiler/内存编译器，编译<code>.java</code>文件生成<code>.class</code></h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译，这里一定要指定类加载器，否则会报错，因为你编译的类中可能import其它类，不指定就会提示找不到对应的类。</span></span><br><span class=\"line\"><span class=\"comment\"># 类加载器可以通过 jad 命令获取</span></span><br><span class=\"line\">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java</span><br><span class=\"line\"><span class=\"comment\"># 指定类加载器的编号</span></span><br><span class=\"line\">mc -c 5b2133b1 /tmp/UserController.java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将 UserController.class 文件输出到指定目录， -d 指定输出目录</span></span><br><span class=\"line\">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mc 命令有可能失败。如果编译失败可以在本地编译好.class文件，再上传到服务器。</p>\n</li>\n</ul>\n<h4 id=\"retransform-重新加载类-热修改代码\">retransform : 重新加载类(热修改代码)</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retransform /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 通过 retransform 重新加载的 class</span></span><br><span class=\"line\">retransform -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除通过 retransform 重新加载的 class，通过 id 删除</span></span><br><span class=\"line\">retransform -d 1</span><br><span class=\"line\"><span class=\"comment\"># 删除所有</span></span><br><span class=\"line\">retransform --deleteAll</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除后要重新触发 retransform，否则内存中依旧使用的是删除前的 class</span></span><br><span class=\"line\">retransform --classPattern com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure>\n<h4 id=\"sysprop-查看当前-JVM-的系统属性\">sysprop : 查看当前 JVM 的系统属性</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印系统属性</span></span><br><span class=\"line\">sysprop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定单个 key，key支持自动补全</span></span><br><span class=\"line\">sysprop java.version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过grep过滤</span></span><br><span class=\"line\">sysprop | grep user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 或 修改 系统属性</span></span><br><span class=\"line\">sysprop testKey testValue</span><br></pre></td></tr></table></figure>\n<h4 id=\"sysenv-查看当前-JVM-的环境变量\">sysenv : 查看当前 JVM 的环境变量</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有环境变量</span></span><br><span class=\"line\">sysenv</span><br><span class=\"line\"><span class=\"comment\"># 指定单个 key，key支持自动补全</span></span><br><span class=\"line\">sysenv PATH</span><br><span class=\"line\"><span class=\"comment\"># 通过grep过滤</span></span><br><span class=\"line\">sysenv | grep PATH</span><br></pre></td></tr></table></figure>\n<h4 id=\"jvm-查看当前-JVM-的信息，包含很多重要的信息\">jvm : 查看当前 JVM 的信息，包含很多重要的信息</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jvm</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>GARBAGE-COLLECTORS </code> GC 相关</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>THREAD</code> 相关</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COUNT: JVM 当前活跃的线程数</span><br><span class=\"line\">DAEMON-COUNT: JVM 当前活跃的守护线程数</span><br><span class=\"line\">PEAK-COUNT: 从 JVM 启动开始曾经活着的最大线程数</span><br><span class=\"line\">STARTED-COUNT: 从 JVM 启动开始总共启动过的线程次数</span><br><span class=\"line\">DEADLOCK-COUNT: JVM 当前死锁的线程数</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>FILE-DESCRIPTOR</code> 文件描述符相关</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAX-FILE-DESCRIPTOR-COUNT：JVM 进程最大可以打开的文件描述符数</span><br><span class=\"line\">OPEN-FILE-DESCRIPTOR-COUNT：JVM 当前打开的文件描述符数</span><br></pre></td></tr></table></figure>\n<h4 id=\"watch-函数执行数据观测\">watch : 函数执行数据观测</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 观察指定类中某个方法的调用情况，className +  methodName + 返回值表达式</span></span><br><span class=\"line\"><span class=\"comment\"># 开启后，当方法被调用时，会按照指定的 `返回值表达式` 输出结果，返回值表达式 可以不指定，默认为 &#123;params, target, returnObj&#125;</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController findUserById <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 观察全部方法，通配符匹配</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController <span class=\"string\">&#x27;*&#x27;</span> <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 默认输出结果没有展开，可以加上 -x 指定输出结果的属性遍历深度，默认为 1，最大值是 4</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController <span class=\"string\">&#x27;*&#x27;</span> <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 仅当抛出异常时才打印，-e 在函数异常之后观察</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController <span class=\"string\">&#x27;*&#x27;</span> <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2 -e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数条件过滤，params[0] &gt; 100 表示方法入参中第一个参数的值大于 100 时才触发打印</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController * returnObj <span class=\"string\">&#x27;params[0] &gt; 100&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按请求耗时进行过滤，#cost&gt;200 表示耗时大于200ms</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController * <span class=\"string\">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class=\"string\">&#x27;#cost&gt;200&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出watch</span></span><br><span class=\"line\">q</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>watch 命令表达式支持变量说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型/说明</th>\n<th>作用/含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>loader</code></td>\n<td><code>ClassLoader</code></td>\n<td>方法所在类的类加载器对象</td>\n</tr>\n<tr>\n<td><code>clazz</code></td>\n<td><code>Class&lt;?&gt;</code></td>\n<td>方法所属的类（<code>Class</code> 对象）</td>\n</tr>\n<tr>\n<td><code>method</code></td>\n<td><code>java.lang.reflect.Method</code></td>\n<td>被调用的方法的反射对象</td>\n</tr>\n<tr>\n<td><code>target</code></td>\n<td><code>Object</code></td>\n<td>方法的调用目标对象（即 <code>this</code> 对象），静态方法中为 <code>null</code></td>\n</tr>\n<tr>\n<td><code>params</code></td>\n<td><code>Object[]</code></td>\n<td>方法的入参数组</td>\n</tr>\n<tr>\n<td><code>returnObj</code></td>\n<td><code>Object</code></td>\n<td>方法的返回值</td>\n</tr>\n<tr>\n<td><code>throwExp</code></td>\n<td><code>Throwable</code></td>\n<td>方法抛出的异常</td>\n</tr>\n<tr>\n<td><code>isBefore</code></td>\n<td><code>boolean</code></td>\n<td>当前执行位置是否是方法调用<strong>之前</strong>（<code>BEFORE</code> 阶段）</td>\n</tr>\n<tr>\n<td><code>isThrow</code></td>\n<td><code>boolean</code></td>\n<td>当前方法是否以异常结束（<code>THROWS</code> 阶段）</td>\n</tr>\n<tr>\n<td><code>isReturn</code></td>\n<td><code>boolean</code></td>\n<td>当前方法是否正常返回（<code>RETURN</code> 阶段）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"jobs-查看运行中的任务\">jobs : 查看运行中的任务</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如下命令会转到后台运行 ，与linux命令类似，命令最后加上 `&amp;` 即可</span></span><br><span class=\"line\">watch com.example.demo.arthas.user.UserController * <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span> <span class=\"string\">&#x27;throwExp != null&#x27;</span> &gt;&gt; a.log &amp;</span><br><span class=\"line\"><span class=\"comment\"># 查看后台任务</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[1]*</span><br><span class=\"line\">       Running           watch com.example.demo.arthas.user.UserController * <span class=\"string\">&#x27;&#123;params, throwExp&#125;&#x27;</span> <span class=\"string\">&#x27;throwExp != null&#x27;</span> &gt;&gt; a.log &amp;</span><br><span class=\"line\">       execution count : 0</span><br><span class=\"line\">       start time      : Thu May 15 15:10:04 CST 2025</span><br><span class=\"line\">       <span class=\"built_in\">timeout</span> <span class=\"built_in\">date</span>    : Fri May 16 15:10:04 CST 2025</span><br><span class=\"line\">       session         : ded56dfd-5683-4427-ac08-792f8fb75e5e (current)</span><br><span class=\"line\"><span class=\"comment\"># 结束任务</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> 1 <span class=\"comment\"># 1为后台任务id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将后台任务转到前台</span></span><br><span class=\"line\"><span class=\"built_in\">fg</span> 1 <span class=\"comment\"># 1为后台任务id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂停任务，但此时会将arthas进程都挂起，所以并不好用</span></span><br><span class=\"line\">ctrl+z</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将前台任务转到后台继续执行</span></span><br><span class=\"line\"><span class=\"built_in\">bg</span> 1 <span class=\"comment\"># 1为前台任务id</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"logger-查看-logger-信息，更新-logger-level\">logger : 查看 logger 信息，更新 logger level</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 logger 信息</span></span><br><span class=\"line\">logger</span><br><span class=\"line\"><span class=\"comment\"># 查看指定名字的logger信息</span></span><br><span class=\"line\">logger -n ROOT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看没有 appender 的 logger 的信息，不加这个参数只会打印有 appender 的 logger 的信息</span></span><br><span class=\"line\">logger --include-no-appender</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新 logger level，-c classLoader 的 hashcode</span></span><br><span class=\"line\">logger --name ROOT --level debug -c 5b2133b1</span><br><span class=\"line\">logger --name ROOT --level error --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br></pre></td></tr></table></figure>\n<h4 id=\"classloader-查看-classloader-的继承树，urls，类加载信息\">classloader : 查看 classloader 的继承树，urls，类加载信息</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 classloader 的信息，加载class的数量，hashcode，classloader 的 parent</span></span><br><span class=\"line\">classloader -l</span><br><span class=\"line\"><span class=\"comment\"># 树形展示</span></span><br><span class=\"line\">classloader -t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找资源，比如查找指定名称的文件</span></span><br><span class=\"line\">classloader -c 5b2133b1 -r application.properties</span><br><span class=\"line\">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure>\n<h4 id=\"ognl-执行-ognl-表达式\">ognl : 执行 ognl 表达式</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 调用静态函数</span></span><br><span class=\"line\">ognl <span class=\"string\">&#x27;@java.lang.System@out.println(&quot;hello&quot;)&#x27;</span></span><br><span class=\"line\">ognl <span class=\"string\">&#x27;@java.lang.Math@sqrt(9.0)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取静态类的静态字段</span></span><br><span class=\"line\">ognl <span class=\"string\">&#x27;@java.io.File@separator&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 需要指定classLoaderClass</span></span><br><span class=\"line\">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br><span class=\"line\"><span class=\"comment\"># 获取classLoaderHash</span></span><br><span class=\"line\">sc -d *UserController | grep classLoaderHash</span><br><span class=\"line\">ognl -c 5b2133b1 @com.example.demo.arthas.user.UserController@logger</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回值展开基层 -x</span></span><br><span class=\"line\">ognl -c 5b2133b1 @com.example.demo.arthas.user.UserController@logger -x 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行多行表达式，赋值给临时变量，返回一个 List</span></span><br><span class=\"line\">ognl <span class=\"string\">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 索引</span></span><br><span class=\"line\"><span class=\"comment\"># 获取数组中的第一个元素</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1,2,3,4&#125;[0]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 变量引用，使用 # 在 OGNL 中定义临时变量，他们全局可见，此外表达式计算的每一步结果都保存在变量 this 中</span></span><br><span class=\"line\"><span class=\"comment\"># 下面命令通过获取列表的第一个元素进行判断如果大于 5 则乘以 2 反之则加 10</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;10,20,30&#125;[0].(#this &gt; 5 ? #this*2 : #this+10)&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 每个元素乘以 2 后返回</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1, 2, 3&#125;.&#123;#this*2&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法调用</span></span><br><span class=\"line\"><span class=\"comment\"># 通过下面命令可以调用 ArrayList 的 size() 方法获取到 ArrayList 的大小</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1,2,3,4&#125;.size()&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复杂链式表达式</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;@java.lang.System@out.(print(&#x27;Hello &#x27;), print(&#x27;world\\n&#x27;))&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建原生数组</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;new int[] &#123;1, 2, 3&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建普通 Map</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;#&#123; &#x27;foo&#x27;: &#x27;foo value&#x27;, &#x27;bar&#x27;: &#x27;bar value&#x27; &#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建特定类型 Map</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;#@java.util.HashMap@&#123; &#x27;foo&#x27;: &#x27;foo value&#x27;, &#x27;bar&#x27;: &#x27;bar value&#x27; &#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找所有匹配的元素</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;? #this instanceof Number&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找第一个匹配的元素</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;^ #this instanceof Number&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找最后一个匹配的元素</span></span><br><span class=\"line\">ognl <span class=\"string\">&quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;$ #this instanceof Number&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"vmoption-查看，更新-VM-诊断相关的参数\">vmoption : 查看，更新 VM 诊断相关的参数</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有的 option</span></span><br><span class=\"line\">vmoption</span><br><span class=\"line\"><span class=\"comment\"># 查看指定的 option</span></span><br><span class=\"line\">vmoption PrintGC</span><br><span class=\"line\"><span class=\"comment\"># 更新指定的 option</span></span><br><span class=\"line\">vmoption PrintGC <span class=\"literal\">true</span></span><br><span class=\"line\">vmoption PrintGCDetails <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"vmtool-实现查询内存对象，强制-GC-等功能\">vmtool : 实现查询内存对象，强制 GC 等功能</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取对象，--action getInstances: 获取对象实例，--className: 指定类名，--limit: 指定获取数量</span></span><br><span class=\"line\">vmtool --action getInstances --className java.lang.String --<span class=\"built_in\">limit</span> 10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 classloader name，这里获取 spring的 ApplicationContext 对象，-x: 展开多少层</span></span><br><span class=\"line\">vmtool --action getInstances --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --className org.springframework.context.ApplicationContext -x 3</span><br><span class=\"line\"><span class=\"comment\"># 指定 classloader hash</span></span><br><span class=\"line\">sc -d org.springframework.context.ApplicationContext | grep classLoaderHash</span><br><span class=\"line\">vmtool --action getInstances -c 19469ea2 --className org.springframework.context.ApplicationContext</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行表达式，--express: 执行的表达式，这里是调用对象的方法</span></span><br><span class=\"line\">vmtool --action getInstances --className com.example.demo.arthas.aop.HelloWorldService --express <span class=\"string\">&#x27;instances[0].getHelloMessage()&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制 GC，可以结合 vmoption 命令动态打开PrintGC开关</span></span><br><span class=\"line\">vmtool --action forceGc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 中断线程， -t 线程ID,可以使用 thread命令获取</span></span><br><span class=\"line\">vmtool --action interruptThread -t 1</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍JVM的命令行工具 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档 JVM 的参数(三类) 标准参数: 以-开头，所有 HotSpot 都⽀持。例如java -version。这类参数可以使⽤java -help 或者java -?全部打印出来 ⾮标准参数: 以-X开头，是特定 HotSpot版本⽀持的指令。例如java -Xms200M -Xmx200M。这类指令可以⽤java -X 全部打印出来。 不稳定参数: 这也是 JVM调优的噩梦。以-XX 开头，这些参数是跟特定HotSpot版本对应的，很有可能换个版本就没有了。详细的⽂档资料也特别少。JDK8 中的以下⼏个指令可以帮助开发者了解 JDK8 中的这⼀类不稳定参数。 1234java -XX:+PrintFlagsInitial -version # 所有参数的默认值java -XX:+PrintFlagsFinal -version # 所有参数最终⽣效的值。java -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version # 所有参数最终⽣效的值，包含实验性参数。java -XX:+PrintCommandLineFlags -version # 当前命令生效的值，可以看到是⽤的哪种GC。 JDK1.8默认⽤的ParallelGC 运行 java -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version 返回值说明 1234567891011121314151617[Global flags] intx ActiveProcessorCount = -1 &#123;product&#125; uintx AdaptiveSizeDecrementScaleFactor = 4 &#123;product&#125; uintx AdaptiveSizeMajorGCDecayTimeScale = 10 &#123;product&#125; uintx AdaptiveSizePausePolicy = 0 &#123;product&#125; uintx AdaptiveSizePolicyCollectionCostMargin = 50 &#123;product&#125; uintx AdaptiveSizePolicyInitializingSteps = 20 &#123;product&#125; uintx AdaptiveSizePolicyOutputInterval = 0 &#123;product&#125; uintx AdaptiveSizePolicyWeight = 10 &#123;product&#125; uintx AdaptiveSizeThroughPutPolicy = 0 &#123;product&#125; uintx AdaptiveTimeWeight = 25 &#123;product&#125; bool AdjustConcurrency = false &#123;product&#125; bool AggressiveHeap = false &#123;product&#125; bool AggressiveOpts = false &#123;product&#125; intx AliasLevel = 3 &#123;C2 product&#125; ………………………………# 格式：flag类型，flag名称，flag值，flag来源与作用域修饰符 flag类型: jdk8 标识符 含义 描述说明 intx 有符号整数（int extended） 用于表示带符号整数型参数 uintx 无符号整数（unsigned int extended） 表示非负整数型参数 uint64_t 无符号 64 位整数 适用于需要更大整数值的参数，比如内存大小、纳秒时间戳等 bool 布尔型 true 或 false，表示开关型参数。+表示开启，-表示关闭。 如 -XX:+UseG1GC，表示开启 G1 回收器功能。 double 双精度浮点型 用于表示浮点数值类型的 JVM 参数 ccstr 常量 C 字符串指针 表示字符串参数（不可变） ccstrlist C 字符串列表 表示以逗号分隔的字符串列表 jdk11后出现更多的类型 标识符 含义 描述说明 int 有符号整数,通常是 32 位 JVM 内部使用的普通 int 参数 uint 无符号整数,通常是 32 位 少量用于特殊场景的参数 size_t 内存大小 表示内存大小参数（单位一般为字节）,jdk11后出现，原来是 uintx flag来源与作用域修饰符 jdk8 标记 含义 &#123;product&#125; 正式产品参数（用户可用，可通过 -XX: 进行设置） &#123;pd product&#125; 平台相关的正式参数（platform-dependent），在某些操作系统/CPU 上可用 &#123;C1 product&#125; 仅在使用 C1 编译器（优化编译器） 时有效的参数 &#123;C2 product&#125; 仅在使用 C2 编译器（优化编译器） 时有效的参数 &#123;manageable&#125; 可通过 JMX 动态管理的参数（运行时可调整） &#123;ARCH product&#125; 与 CPU 架构相关的产品参数（如 x86、ARM 等） &#123;lp64_product&#125; 仅在 64 位 JVM 上才有效的产品参数 &#123;experimental&#125; 实验性的 参数，可能在将来的版本中删除或更改。需要开启 -XX:+UnlockExperimentalVMOptions jdk11后出现更多的类型 标记 含义 &#123;C1 pd product&#125; 平台相关的正式参数,仅在使用 C1 编译器（优化编译器） 时有效的参数 &#123;C2 pd product&#125; 平台相关的正式参数,仅在使用 C2 编译器（优化编译器） 时有效的参数 &#123;JVMCI product&#125; 此参数适用于 JVMCI 或 Graal 编译器相关功能，jdk21添加 另外，jdk11+ 中，最后还会多出一列，其作用是说明该参数的设置来源 来源标识 含义说明 &#123;default&#125; 使用的是该参数的默认值（没有被用户或系统设置） &#123;command line&#125; 用户通过命令行显式设置的参数（如 -XX:+UseG1GC） &#123;ergonomic&#125; JVM 根据系统环境自动选择的值（自适应设置） jps: 查看当前jvm中的进程 12345678# 查看java进程IDjps# 查看java进程信息，包括ID和启动类或jar的名称jps -l# 查看启动java进程时传递给jvm的参数设置jps -v# 查看java进程信息，同时显示启动java进程时传递给jvm的参数设置jps -lv jinfo: 查看JVM参数 jinfo 是 JDK 自带的命令行工具之一，用于 查看和修改正在运行中的 Java 进程的配置信息，主要包括 JVM 参数、系统属性等信息。 在 Java 9+ 之后被标记为 deprecated，建议改用 jcmd 替代 12345678910111213141516171819# 查看正在运行的 JVM 参数jinfo &lt;PID&gt;# jcmd 命令，分成三个jcmd &lt;pid&gt; VM.flags # VM Flagsjcmd &lt;pid&gt; VM.system_properties # System Propertiesjcmd &lt;pid&gt; VM.command_line # Command Line# 查看指定进程的系统属性（-sysprops）jinfo -sysprops &lt;PID&gt;# jcmd 命令jcmd &lt;pid&gt; VM.system_properties# 动态修改 JVM 参数（仅支持部分参数）jinfo -flag [+|-]&lt;flagname&gt; &lt;pid&gt;## 例：打开 GC 日志jinfo -flag +PrintGC &lt;pid&gt;# 检查是否开启了某个 JVM 特性（如 UseG1GC）jinfo -flag UseG1GC &lt;pid&gt; jstat: 查看指定JAVA进程的运行状态 123456789# 查看运行状态jstat -gc &lt;PID&gt;# 查看运行状态，每隔5000毫秒输出一次，共输出20次jstat -gc &lt;PID&gt; 5000 20# 输出 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT512.0 512.0 0.0 224.0 29696.0 27138.2 105984.0 96531.8 122368.0 114450.4 15360.0 14018.9 733 5.099 4 0.833 5.931512.0 512.0 0.0 224.0 29696.0 27203.9 105984.0 96531.8 122368.0 114450.4 15360.0 14018.9 733 5.099 4 0.833 5.931512.0 512.0 0.0 224.0 29696.0 27220.4 105984.0 96531.8 122368.0 114450.4 15360.0 14018.9 733 5.099 4 0.833 5.931 内存区统计（单位：KB） 列名 含义说明 S0C Survivor 0 区的容量（KB） S1C Survivor 1 区的容量（KB） S0U Survivor 0 区已使用内存（KB） S1U Survivor 1 区已使用内存（KB） EC Eden 区的容量（KB） EU Eden 区已使用内存（KB） OC Old Generation（老年代）的容量（KB） OU Old Generation 已使用内存（KB） MC Metaspace（元空间）的容量（KB） MU Metaspace 已使用内存（KB） CCSC Compressed Class Space 的容量（KB） CCSU Compressed Class Space 已使用内存（KB） GC 次数与耗时(从应用程序启动到采样时) 列名 含义说明 YGC Young GC（Minor GC） 的累计次数 YGCT Young GC 累计耗时（单位：秒） FGC Full GC 的累计次数 FGCT Full GC 累计耗时（单位：秒） GCT GC 总耗时（YGCT + FGCT，总和） jstack: 查看指定JAVA进程中各线程的调用堆栈 123456789101112131415161718# 打印线程的标准栈信息（栈帧 + 线程状态）jstack &lt;PID&gt;# 在标准输出基础上，额外打印线程拥有的锁（monitor）和 waited on 锁对象信息jstack -l &lt;PID&gt;# 输出到文件jstack -l &lt;PID&gt; &gt; jstack.tdump # 这个文件名后缀只是为了方便 jvisualvm 查看# 输出&quot;idle-connection-reaper&quot; #68 daemon prio=5 os_prio=0 tid=0x00007f38b6ae2800 nid=0x62e9 waiting on condition [0x00007f385b0f5000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at software.amazon.awssdk.http.apache.internal.conn.IdleConnectionReaper$ReaperTask.run(IdleConnectionReaper.java:151) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:750) Locked ownable synchronizers: - &lt;0x00000000c561cfd8&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker) jstack输出内容含义 字段 含义 &quot;idle-connection-reaper&quot; 线程名称。这个线程是 AWS SDK 中用于清理空闲连接的后台线程。 #68 线程 ID（Java 层分配的编号）。 daemon 表示这是一个 守护线程。JVM 退出时不会等待守护线程运行结束。 prio=5 Java 层的线程优先级（默认 1–10，5 是默认）。 os_prio=0 操作系统层线程优先级（取决于操作系统和 JVM 的实现）。 tid=0x00007f38b6ae2800 线程 ID（Java 层使用的地址标识）。 nid=0x62e9 Native ID，操作系统分配的线程 ID（十六进制表示），可以通过命令printf &quot;%d\\n&quot; 0x62e9转换为10进制。 ps -Lp &lt;PID&gt; 和 top -Hp &lt;PID&gt; 展示的线程id是10进制 waiting on condition 线程状态说明：正在等待某种条件，一般指 sleep() 或 wait() 等。 [0x00007f385b0f5000] 栈帧的内存地址。 java.lang.Thread.State: TIMED_WAITING (sleeping) 线程状态。 at java.lang.Thread.sleep(Native Method) ………………………… 线程调用栈信息，包括调用方法、调用参数、调用栈帧。 另外还有如下信息，表示此线程持有的可拥有同步器（例如 ReentrantLock），具体内容如下： 12Locked ownable synchronizers: - &lt;0x00000000c561cfd8&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker) 内容 含义 &lt;0x00000000c561cfd8&gt; 持有锁的对象地址。可以在其他线程中查找这个地址，以判断死锁等问题。 (a ThreadPoolExecutor$Worker) 表示该锁属于 ThreadPoolExecutor 的某个 Worker 线程（这是线程池的工作线程）。 线程状态 状态 含义 常见原因 / 示例方法 示例 jstack 输出 RUNNABLE 线程正在运行或准备运行，等待 CPU 时间片。 线程活跃运行中 &quot;Thread-0&quot; #1 prio=5 os_prio=0 tid=0x00007f8d9c001000 nid=0x1a runnable [0x00007f8dbf7fe000] BLOCKED (on object monitor) 等待获取对象的监视器锁（同步锁），即等待进入同步块或方法。 synchronized 同步块或方法 &quot;Thread-1&quot; #2 prio=5 os_prio=0 tid=0x00007f8d9c002000 nid=0x1b waiting for monitor entry [0x00007f8dbeaff000] WAITING (on object monitor) 无限期等待其他线程执行某操作。 Object.wait()Thread.join()LockSupport.park()Condition.await() &quot;Thread-2&quot; #3 prio=5 os_prio=0 tid=0x00007f8d9c003000 nid=0x1c waiting on condition [0x00007f8dbebff000] TIMED_WAITING (on object monitor) 等待固定时间，直到条件满足或超时。 Object.wait(long)Thread.sleep(long)Condition.awaitNanos(long)DelayQueue.take() &quot;Thread-3&quot; #4 prio=5 os_prio=0 tid=0x00007f8d9c004000 nid=0x1d timed_waiting [0x00007f8dbebff000] TERMINATED 线程已运行完毕并退出（通常不在 jstack 中显示）。 - - 使用jstack检查死锁 死锁是指多个线程互相等待对方释放锁，导致无法继续运行的情况。 直接查找 Found one Java-level deadlock 提示 12345678Found one Java-level deadlock:=============================&quot;Thread-1&quot;: waiting to lock monitor 0x0000000005c0a098 (object 0x00000000d5c10a70, a java.lang.Object), which is held by &quot;Thread-2&quot;&quot;Thread-2&quot;: waiting to lock monitor 0x0000000005c0a128 (object 0x00000000d5c10aa0, a java.lang.Object), which is held by &quot;Thread-1&quot; 表示两个线程互相等待对方释放锁，造成死锁。 目前只支持找出 synchronized 关键字阻塞住的线程，如果是 java.util.concurrent.Lock 目前还不支持。 手动判断死锁的特征（如果没有上面的提示） 如果 JVM 没有显式提示，你可以通过以下死锁特征进行手动识别： 特征 描述 线程处于 BLOCKED 状态 线程被锁阻塞在 monitor 上。 waiting to lock 和 locked 出现交叉 一个线程正在等待另一个线程持有的锁，而另一个线程也在等待当前线程的锁。 没有能继续执行的线程 多个线程都处于 BLOCKED 状态，且相互依赖。 在 Java 8 之后支持获取 JVM 内部线程 VM 内部线程包括下面几种： 线程类型 示例名称 JIT（Just-In-Time）编译线程 C1 CompilerThread0, C2 CompilerThread0 GC 线程 GC Thread0, G1 Young RemSet Sampling 其它内部线程 VM Periodic Task Thread, VM Thread, Service Thread 自 JDK 7 及以上版本开始，HotSpot JVM 默认启用了：分层编译（Tiered Compilation），即同时使用 C1 和 C2 编译器。 编译器 特性 用途 C1（Client Compiler） 编译速度快，优化少 程序启动时使用，提升启动速度 C2（Server Compiler） 编译速度慢，优化强 热点代码达到一定门槛后使用，提升长期运行性能 JVM 启动后，先解释执行字节码；热点代码首先由 C1 编译器处理；如果进一步变热，交由 C2 编译器优化；整个过程由 JVM 自动管理，不需要手动干预。 是否可以指定只用某个编译器？是的，你可以用 JVM 参数控制，但真没必要。 参数 含义 -client 使用 C1 编译器（适合启动快） -server 使用 C2 编译器（适合长时间运行的服务） -XX:-TieredCompilation 禁用分层编译，仅使用 -client 或 -server 指定的编译器 jmap: 分析运行中 Java 进程的内存使用情况 jmap 比较消耗内存，所以不推荐生产环境使用。 jmap -histo &lt;pid&gt;: 查看类实例数量及占用内存 12345678910111213141516171819$ jmap -histo 2523825238: num #instances #bytes class name---------------------------------------------- 1: 106175 10838440 [C 2: 94344 3019008 java.util.concurrent.ConcurrentHashMap$Node 3: 105529 2532696 java.lang.String 4: 11203 2496608 [B 5: 20178 2430136 [Ljava.lang.Object; 6: 21642 2399904 java.lang.Class…………………………Total 857252 51328200# num: 序号# instances: 实例数量# bytes: 实例字节数# class name: 类名, [C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[L is a List# Total: 总数 jmap -heap &lt;pid&gt;: 查看堆使用情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ jmap -heap 25238Attaching to process ID 25238, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.371-b11using thread-local object allocation.Parallel GC with 2 thread(s)Heap Configuration: # 堆配置 MinHeapFreeRatio = 0 # 最小空闲百分比 MaxHeapFreeRatio = 100 # 最大空闲百分比 MaxHeapSize = 1010827264 (964.0MB) # 最大堆大小 NewSize = 21495808 (20.5MB) # 新生代大小 MaxNewSize = 336592896 (321.0MB) # 新生代最大大小 OldSize = 43515904 (41.5MB) # 老年代大小 NewRatio = 2 # 新生代与老年代比例 SurvivorRatio = 8 # 幸存者比例 MetaspaceSize = 21807104 (20.796875MB) # 元空间大小 CompressedClassSpaceSize = 1073741824 (1024.0MB) # 压缩类空间大小，用于存储所有 类指针（Klass pointer） MaxMetaspaceSize = 17592186044415 MB # 元空间最大大小 G1HeapRegionSize = 0 (0.0MB) # G1堆大小Heap Usage: # 堆使用情况PS Young Generation # 年轻生代Eden Space: # Eden 区 capacity = 30932992 (29.5MB) # Eden 区大小 used = 16705104 (15.931228637695312MB) # Eden 区使用情况 free = 14227888 (13.568771362304688MB) # Eden 区剩余情况 54.00416487354343% used # Eden 区使用百分比From Space: # 幸存者区 survivor0 capacity = 524288 (0.5MB) used = 0 (0.0MB) free = 524288 (0.5MB) 0.0% usedTo Space: # 幸存者区 survivor1 capacity = 524288 (0.5MB) used = 0 (0.0MB) free = 524288 (0.5MB) 0.0% usedPS Old Generation # 老年代 capacity = 193462272 (184.5MB) used = 43292112 (41.28657531738281MB) free = 150170160 (143.2134246826172MB) 22.377547597497458% used38722 interned Strings occupying 4184168 bytes. # 堆中字符串数量及占用内存 jmap -dump:live,format=b,file=&lt;file&gt; &lt;pid&gt;: 创建一个快照，并保存到文件中 1234# 创建一个快照，并保存到当前目录下$ jmap -dump:live,format=b,file=test.hprof 25238Dumping heap to /tmp/test.hprof ...Heap dump file created jcmd: 可以替代jmap命令，jdk1.8+推荐使用 jcmd 是 JDK 的一个命令行工具，用于管理 JVM，jcmd 可以查看 JVM 的运行状态、查看堆内存信息、触发 GC、查看线程信息、查看类信息等等。 生产环境不建议使用jmap，因其会占用大量内存，推荐使用 jcmd。 jcmd &lt;pid&gt; GC.heap_info: 查看堆使用情况 类似 jmap -heap &lt;pid&gt; 12345678910$ jcmd 25238 GC.heap_info25238: PSYoungGen total 30208K, used 23593K [0x00000000ebf00000, 0x00000000edd80000, 0x0000000100000000) eden space 29696K, 78% used [0x00000000ebf00000,0x00000000ed5d2560,0x00000000edc00000) from space 512K, 43% used [0x00000000edd00000,0x00000000edd38000,0x00000000edd80000) to space 512K, 0% used [0x00000000edc80000,0x00000000edc80000,0x00000000edd00000) ParOldGen total 105984K, used 96547K [0x00000000c3c00000, 0x00000000ca380000, 0x00000000ebf00000) object space 105984K, 91% used [0x00000000c3c00000,0x00000000c9a48f10,0x00000000ca380000) Metaspace used 114450K, capacity 122262K, committed 122368K, reserved 1157120K class space used 14018K, capacity 15294K, committed 15360K, reserved 1048576K jcmd &lt;pid&gt; GC.class_histogram: 查看类加载情况 类似 jmap -histo &lt;pid&gt; 12345678910111213141516171819$ jcmd 25238 GC.class_histogram25238: num #instances #bytes class name---------------------------------------------- 1: 106175 10838440 [C 2: 94344 3019008 java.util.concurrent.ConcurrentHashMap$Node 3: 105529 2532696 java.lang.String 4: 11203 2496608 [B 5: 20178 2430136 [Ljava.lang.Object; 6: 21642 2399904 java.lang.Class…………………………Total 857252 51328200# num: 序号# instances: 实例数量# bytes: 实例字节数# class name: 类名, [C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[L is a List# Total: 总数 jcmd &lt;pid&gt; GC.heap_dump /path/to/heap.hprof: 导出 heap dump 替代 jmap -dump:format=b,file=heap.hprof &lt;pid&gt;，但仍会有停顿（触发FullGC），dump 过程慢，生产环境慎重使用 1234567$ jcmd 25238 GC.heap_dump ./heap.hprof25238:Heap dump file created# 注意这里使用的是相对目录，./heap.hprof，但此时 &quot;./&quot; 并不是运行命令时所在的目录，而是指 Java 进程的工作目录，如果你不知道工作目录，可以通过如下命令查看jcmd &lt;pid&gt; VM.system_properties | grep &quot;user.dir&quot;# linux下也可以通过如下命令查看ls -l /proc/&lt;pid&gt;/cwd 因为生产环境不推荐使用 jmap 或 jcmd 导出 heap dump，所以我们需要在生产环境中配置如下jvm参数 12-XX:+HeadDumpOnOutOfMemoryError # 内存溢出（OOM）时会自动保存堆内存快照文件-XX:HeapDumpPath=/path/to/dump.hprof # 指定堆内存快照文件保存路径，如果不配置，则默认保存在 Java 进程的工作目录下，文件名称默认为 java_&lt;pid&gt;.hprof jhat: 分析 Java Heap Dump 文件（.hprof）的工具 jhat（Java Heap Analysis Tool）是 JDK 附带的一个用于**分析 Java Heap Dump 文件（.hprof）**的工具。它可以将堆快照作为 HTTP 服务加载，并允许你通过浏览器交互式地查看和查询对象信息。 不过需要注意的是： 🔺 从 JDK 9 起，jhat 已被官方废弃，推荐使用更强大的工具如 VisualVM、Eclipse MAT 或 jcmd + 外部工具。 1234# 默认端口7000jhat &lt;heap dump file&gt;# 指定端口jhat -port 8000 &lt;heap dump file&gt; jvisualvm: 图形化的 JVM 监控与分析工具 jvisualvm（全称：Java VisualVM）是 Java 官方提供的一款 图形化的 JVM 监控与分析工具，用于观察、分析和调试正在运行的 Java 程序。它非常适合开发和测试环境中进行内存分析、线程分析、GC 行为观察等任务。 功能概览 功能 描述 进程监控 查看本地或远程 JVM 进程的内存、CPU、线程等运行状态 内存使用分析 查看堆内存使用情况、GC 次数和时间、类实例分布等 线程分析 查看线程状态、线程栈、是否存在死锁 GC 分析 图形化展示 GC 活动、频率与耗时 堆转储分析 导入 .hprof 文件进行对象实例、类、引用关系分析 CPU 分析 分析方法调用路径、耗时、热点代码（需手动启用 CPU profiler） 插件支持 可以通过插件安装更多功能（如 Visual GC） 启动 jvisualvm 12# 不要在生产环境使用，如果是分析服务端 .hprof 文件，可以导出到本地后在本地启动$ jvisualvm 在 jvisualvm 中导入 .hprof 文件 12$ jvisualvm --openfile &lt;heap dump file&gt;# 或者 先打开 jvisualvm 后，点击 File -&gt; Open File -&gt; 选择 .hprof 文件 ⚠️ 注意事项 注意点 说明 不适用于大规模生产环境监控 因为其分析过程可能会对 JVM 有轻微影响 .hprof 文件过大时加载缓慢 可配合 Eclipse MAT 使用 CPU/Memory Profiler 会增加系统负担 使用时谨慎，建议只在测试环境启用 Eclipse MAT: Java Heap Dump 分析工具 Eclipse MAT（Eclipse Memory Analyzer Tool）是一个用于分析 Java 堆快照的工具，它提供了许多功能来帮助开发人员理解 Java 应用程序中的内存问题。 MaxOS系统安装Eclipse MAT后，启动报错，报错信息为：The JVM shared library “/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/…/lib/server/libjvm.dylib” does not contain the JNI_CreateJavaVM symbol. 解决方法： 1.在应用列表，找到MemoryAnalyzer.app，然后右键单击后，选择显示包内容,进入Contents目录，找到Info.plist文件 2.打开Info.plist文件后，可以看到注释&lt;string&gt;-vm&lt;/string&gt;配置项，我们需要做的就是打开这个配置项，并且将其设置为我们系统的Java路径，最新版需要jdk17+ 12&lt;string&gt;-vm&lt;/string&gt;&lt;string&gt;/Users/hanqf/develop_soft/jdk17/bin/java&lt;/string&gt; Arthas : 推荐 Arthas 是阿里巴巴开源的一款 Java 诊断工具，专为线上诊断而设计。它可以帮助开发者在不重启、不修改代码的情况下，排查生产环境中 Java 应用的问题。 Arthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 这里要注意一点，就是Arthas从4.x版本开始，需要依赖JDK8+，如果是JDK6/7，可以下载最后一个3.x版本 3.7.2。 为了方便我们学习，Arthas还为我们提供了一个练习场，Arthas Playground。 Arthas 核心特点 无需重启、侵入性低 Arthas 可以 attach 到正在运行的 JVM 上，不需要重启服务或修改源代码。 命令式交互体验 类似 Linux shell 的操作方式，支持 tab 补全、上下键历史命令等，非常直观。 实时查看和监控 可查看方法参数、返回值、调用栈、执行耗时、JVM 线程、内存等实时数据。 多种连接方式 支持命令行终端、本地 shell、Web 页面、telnet 等多种连接方式。 支持多种 JVM 版本 支持 Java 6+，包括 OpenJDK、Oracle JDK、Alibaba Dragonwell 等。 Arthas 常用命令 启动 123456789101112131415161718192021222324252627282930313233343536java -jar arthas-boot.jar## 输出java -jar arthas-boot.jar --target-ip 0.0.0.0[INFO] JAVA_HOME: /Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home/jre[INFO] arthas-boot version: 4.0.5[INFO] Process 43959 already using port 3658[INFO] Process 43959 already using port 8563[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 43959 demo-arthas-spring-boot.jar [2]: 50851 org.jetbrains.idea.maven.server.RemoteMavenServer36 [3]: 50813 org.sonarsource.sonarlint.core.backend.cli.SonarLintServerCli [4]: 50655 com.intellij.idea.Main# 启动后，会自动进入交互模式，此时输入要监控的进程序号1 # 比如这里输入 1 回车## 输出[INFO] arthas home: /Users/hanqf/.arthas/lib/4.0.5/arthas[INFO] The target process already listen port 3658, skip attach.[INFO] arthas-client connect 0.0.0.0 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. &#x27;&#x27;--. .--&#x27;| &#x27;--&#x27; | / O \\ &#x27; .-&#x27;| .-. || &#x27;--&#x27;.&#x27; | | | .--. || .-. |`. `-.| | | || |\\ \\ | | | | | || | | |.-&#x27; |`--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27; `--&#x27; `--&#x27; `--&#x27;`--&#x27; `--&#x27;`-----&#x27;wiki https://arthas.aliyun.com/doctutorials https://arthas.aliyun.com/doc/arthas-tutorials.htmlversion 4.0.5main_class demo-arthas-spring-boot.jarpid 43959start_time 2025-05-14 14:57:18.031currnt_time 2025-05-14 14:59:22.004[arthas@43959]$ # 此时进入 arthas 命令行交互状态# 退出 arthas[arthas@43959]$ stop # 退出 arthas arthas 命令有很多，当常用的也就几个，另外如果记不住某个命令怎么用了可以通过如下命令查询 1&lt;command&gt; -h 或者 help &lt;command&gt; dashboard : 实时查看 JVM 运行状态 123456789101112# 查看 JVM 运行状态， 默认每隔 5 秒刷新 CPU、内存、线程、GC 等信息# 默认会一直刷新状态，按 `q` 或 `Ctrl+C` 退出dashboard# 每隔 2 秒刷新一次dashboard -i 2000# 刷新 10 次后停止dashboard -n 10# 每隔 2 秒刷新一次，刷新 10 次后停止dashboard -i 2000 -n 10 thread : 查看当前 JVM 线程信息 1234567891011121314151617181920212223242526272829303132333435# 查看当前 JVM 线程信息，按 CPU 使用率倒序thread# 查看所有线程信息thread --all# 查看指定线程的堆栈信息thread 18## 输出&quot;http-nio-80-exec-1&quot; Id=18 WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@51866c16 at sun.misc.Unsafe.park(Native Method) - waiting on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@51866c16 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)# 查看最忙的前5个线程的堆栈信息thread -n 5# 查看全部线程的堆栈信息thread -n -1# 指定 cpu 使用率统计的采样间隔，单位为毫秒，默认值为 200thread -i 500# 找出当前阻塞其他线程的线程thread -b# 查看指定状态的线程thread --state WAITING sc : 查看 JVM 已加载的类信息 Search-Class 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息 1234567891011# 通配符匹配，打印搜索到的类全名sc *.demo.*# 打印类的详细信息sc -d com.example.demo.arthas.AdminFilterConfig# 打印出类的 Field 信息sc -d -f com.example.demo.arthas.AdminFilterConfig# 通配符查询并获取classLoaderHashsc -d *AdminFilterConfig | grep classLoaderHash sm : 查看已加载类的方法信息 Search-Method 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Method 信息 12345678# 打印指定类中的方法sm java.lang.String# 展示方法的详细信息sm -d java.lang.String# 展示指定方法的详细信息sm -d java.lang.String substring# 模糊匹配sm -d java.lang.String eq* jad : Java源码反编译工具 验证生产环境下的代码是否与提交的代码一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 打印出类的源码，类名jad com.example.demo.arthas.user.UserController## 输出jad com.example.demo.arthas.user.UserControllerClassLoader:+-org.springframework.boot.loader.LaunchedURLClassLoader@5b2133b1 +-sun.misc.Launcher$AppClassLoader@5c647e05 +-sun.misc.Launcher$ExtClassLoader@452b3a41Location:file:/Users/hanqf/Desktop/arhtas_dir/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/ /* * Decompiled with CFR. * * Could not load the following classes: * com.example.demo.arthas.user.User * org.slf4j.Logger * org.slf4j.LoggerFactory * org.springframework.web.bind.annotation.GetMapping * org.springframework.web.bind.annotation.PathVariable * org.springframework.web.bind.annotation.RestController */ package com.example.demo.arthas.user; import com.example.demo.arthas.user.User; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;) public User findUserById(@PathVariable Integer id) &#123;/*15*/ logger.info(&quot;id: &#123;&#125;&quot;, (Object)id);/*17*/ if (id != null &amp;&amp; id &lt; 1) &#123; throw new IllegalArgumentException(&quot;id &lt; 1&quot;); &#125; return new User(id.intValue(), &quot;name&quot; + id); &#125; &#125;Affect(row-cnt:1) cost in 411 ms. 12345678910111213# 反编译后的源码会有类加载器的信息，如果只希望打印源码，可以加上 --source-onlyjad --source-only com.example.demo.arthas.user.UserController# 不显示行号jad --source-only com.example.demo.arthas.user.UserController --lineNumber false# 输出到文件jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java# 打印出类中某个方法的源码，类名 + 方法名jad com.example.demo.arthas.user.UserController findUserById# 反编译时指定dump class文件目录jad --source-only com.example.demo.arthas.user.UserController --lineNumber false -d /tmp/jad 当有多个 ClassLoader 都加载了这个类时，jad 命令会输出对应 ClassLoader 实例的 hashcode，然后你只需要重新执行 jad 命令，并使用参数 -c 就可以反编译指定 ClassLoader 加载的那个类了； 123456789101112131415$ jad org.apache.log4j.LoggerFound more than one class for: org.apache.log4j.Logger, Please use jad -c hashcode org.apache.log4j.LoggerHASHCODE CLASSLOADER69dcaba4 +-monitor&#x27;s ModuleClassLoader6e51ad67 +-java.net.URLClassLoader@6e51ad67 +-sun.misc.Launcher$AppClassLoader@6951a712 +-sun.misc.Launcher$ExtClassLoader@6fafc4c22bdd9114 +-pandora-qos-service&#x27;s ModuleClassLoader4c0df5f8 +-pandora-framework&#x27;s ModuleClassLoaderAffect(row-cnt:0) cost in 38 ms.# 指定类加载器$ jad org.apache.log4j.Logger -c 69dcaba4 mc : Memory Compiler/内存编译器，编译.java文件生成.class 12345678# 编译，这里一定要指定类加载器，否则会报错，因为你编译的类中可能import其它类，不指定就会提示找不到对应的类。# 类加载器可以通过 jad 命令获取mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java# 指定类加载器的编号mc -c 5b2133b1 /tmp/UserController.java# 将 UserController.class 文件输出到指定目录， -d 指定输出目录mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp mc 命令有可能失败。如果编译失败可以在本地编译好.class文件，再上传到服务器。 retransform : 重新加载类(热修改代码) 123456789101112retransform /tmp/com/example/demo/arthas/user/UserController.class# 查看 通过 retransform 重新加载的 classretransform -l# 删除通过 retransform 重新加载的 class，通过 id 删除retransform -d 1# 删除所有retransform --deleteAll# 删除后要重新触发 retransform，否则内存中依旧使用的是删除前的 classretransform --classPattern com.example.demo.arthas.user.UserController sysprop : 查看当前 JVM 的系统属性 1234567891011# 打印系统属性sysprop# 指定单个 key，key支持自动补全sysprop java.version# 通过grep过滤sysprop | grep user# 设置 或 修改 系统属性sysprop testKey testValue sysenv : 查看当前 JVM 的环境变量 123456# 列出所有环境变量sysenv# 指定单个 key，key支持自动补全sysenv PATH# 通过grep过滤sysenv | grep PATH jvm : 查看当前 JVM 的信息，包含很多重要的信息 1jvm GARBAGE-COLLECTORS GC 相关 THREAD 相关 12345COUNT: JVM 当前活跃的线程数DAEMON-COUNT: JVM 当前活跃的守护线程数PEAK-COUNT: 从 JVM 启动开始曾经活着的最大线程数STARTED-COUNT: 从 JVM 启动开始总共启动过的线程次数DEADLOCK-COUNT: JVM 当前死锁的线程数 FILE-DESCRIPTOR 文件描述符相关 12MAX-FILE-DESCRIPTOR-COUNT：JVM 进程最大可以打开的文件描述符数OPEN-FILE-DESCRIPTOR-COUNT：JVM 当前打开的文件描述符数 watch : 函数执行数据观测 让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。 123456789101112131415161718192021# 观察指定类中某个方法的调用情况，className + methodName + 返回值表达式# 开启后，当方法被调用时，会按照指定的 `返回值表达式` 输出结果，返回值表达式 可以不指定，默认为 &#123;params, target, returnObj&#125;watch com.example.demo.arthas.user.UserController findUserById &#x27;&#123;params, throwExp&#125;&#x27;# 观察全部方法，通配符匹配watch com.example.demo.arthas.user.UserController &#x27;*&#x27; &#x27;&#123;params, throwExp&#125;&#x27;# 默认输出结果没有展开，可以加上 -x 指定输出结果的属性遍历深度，默认为 1，最大值是 4watch com.example.demo.arthas.user.UserController &#x27;*&#x27; &#x27;&#123;params, throwExp&#125;&#x27; -x 2# 仅当抛出异常时才打印，-e 在函数异常之后观察watch com.example.demo.arthas.user.UserController &#x27;*&#x27; &#x27;&#123;params, throwExp&#125;&#x27; -x 2 -e# 参数条件过滤，params[0] &gt; 100 表示方法入参中第一个参数的值大于 100 时才触发打印watch com.example.demo.arthas.user.UserController * returnObj &#x27;params[0] &gt; 100&#x27;# 按请求耗时进行过滤，#cost&gt;200 表示耗时大于200mswatch com.example.demo.arthas.user.UserController * &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27;# 退出watchq watch 命令表达式支持变量说明表 名称 类型/说明 作用/含义 loader ClassLoader 方法所在类的类加载器对象 clazz Class&lt;?&gt; 方法所属的类（Class 对象） method java.lang.reflect.Method 被调用的方法的反射对象 target Object 方法的调用目标对象（即 this 对象），静态方法中为 null params Object[] 方法的入参数组 returnObj Object 方法的返回值 throwExp Throwable 方法抛出的异常 isBefore boolean 当前执行位置是否是方法调用之前（BEFORE 阶段） isThrow boolean 当前方法是否以异常结束（THROWS 阶段） isReturn boolean 当前方法是否正常返回（RETURN 阶段） jobs : 查看运行中的任务 12345678910111213141516171819202122# 如下命令会转到后台运行 ，与linux命令类似，命令最后加上 `&amp;` 即可watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; &#x27;throwExp != null&#x27; &gt;&gt; a.log &amp;# 查看后台任务jobs## 输出[1]* Running watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; &#x27;throwExp != null&#x27; &gt;&gt; a.log &amp; execution count : 0 start time : Thu May 15 15:10:04 CST 2025 timeout date : Fri May 16 15:10:04 CST 2025 session : ded56dfd-5683-4427-ac08-792f8fb75e5e (current)# 结束任务kill 1 # 1为后台任务id# 将后台任务转到前台fg 1 # 1为后台任务id# 暂停任务，但此时会将arthas进程都挂起，所以并不好用ctrl+z# 将前台任务转到后台继续执行bg 1 # 1为前台任务id logger : 查看 logger 信息，更新 logger level 1234567891011# 查看 logger 信息logger# 查看指定名字的logger信息logger -n ROOT# 查看没有 appender 的 logger 的信息，不加这个参数只会打印有 appender 的 logger 的信息logger --include-no-appender# 更新 logger level，-c classLoader 的 hashcodelogger --name ROOT --level debug -c 5b2133b1logger --name ROOT --level error --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader classloader : 查看 classloader 的继承树，urls，类加载信息 12345678# 查看 classloader 的信息，加载class的数量，hashcode，classloader 的 parentclassloader -l# 树形展示classloader -t# 查找资源，比如查找指定名称的文件classloader -c 5b2133b1 -r application.propertiesclassloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml ognl : 执行 ognl 表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 调用静态函数ognl &#x27;@java.lang.System@out.println(&quot;hello&quot;)&#x27;ognl &#x27;@java.lang.Math@sqrt(9.0)&#x27;# 获取静态类的静态字段ognl &#x27;@java.io.File@separator&#x27;# 需要指定classLoaderClassognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger# 获取classLoaderHashsc -d *UserController | grep classLoaderHashognl -c 5b2133b1 @com.example.demo.arthas.user.UserController@logger# 返回值展开基层 -xognl -c 5b2133b1 @com.example.demo.arthas.user.UserController@logger -x 3# 执行多行表达式，赋值给临时变量，返回一个 Listognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;# 索引# 获取数组中的第一个元素ognl &quot;&#123;1,2,3,4&#125;[0]&quot;# 变量引用，使用 # 在 OGNL 中定义临时变量，他们全局可见，此外表达式计算的每一步结果都保存在变量 this 中# 下面命令通过获取列表的第一个元素进行判断如果大于 5 则乘以 2 反之则加 10ognl &quot;&#123;10,20,30&#125;[0].(#this &gt; 5 ? #this*2 : #this+10)&quot;# 每个元素乘以 2 后返回ognl &quot;&#123;1, 2, 3&#125;.&#123;#this*2&#125;&quot;# 方法调用# 通过下面命令可以调用 ArrayList 的 size() 方法获取到 ArrayList 的大小ognl &quot;&#123;1,2,3,4&#125;.size()&quot;# 复杂链式表达式ognl &quot;@java.lang.System@out.(print(&#x27;Hello &#x27;), print(&#x27;world\\n&#x27;))&quot;# 新建原生数组ognl &quot;new int[] &#123;1, 2, 3&#125;&quot;# 新建普通 Mapognl &quot;#&#123; &#x27;foo&#x27;: &#x27;foo value&#x27;, &#x27;bar&#x27;: &#x27;bar value&#x27; &#125;&quot;# 新建特定类型 Mapognl &quot;#@java.util.HashMap@&#123; &#x27;foo&#x27;: &#x27;foo value&#x27;, &#x27;bar&#x27;: &#x27;bar value&#x27; &#125;&quot;# 查找所有匹配的元素ognl &quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;? #this instanceof Number&#125;&quot;# 查找第一个匹配的元素ognl &quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;^ #this instanceof Number&#125;&quot;# 查找最后一个匹配的元素ognl &quot;&#123;1024, &#x27;Hello world!&#x27;, true, 2048&#125;.&#123;$ #this instanceof Number&#125;&quot; vmoption : 查看，更新 VM 诊断相关的参数 1234567# 查看所有的 optionvmoption# 查看指定的 optionvmoption PrintGC# 更新指定的 optionvmoption PrintGC truevmoption PrintGCDetails true vmtool : 实现查询内存对象，强制 GC 等功能 1234567891011121314151617# 获取对象，--action getInstances: 获取对象实例，--className: 指定类名，--limit: 指定获取数量vmtool --action getInstances --className java.lang.String --limit 10# 指定 classloader name，这里获取 spring的 ApplicationContext 对象，-x: 展开多少层vmtool --action getInstances --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --className org.springframework.context.ApplicationContext -x 3# 指定 classloader hashsc -d org.springframework.context.ApplicationContext | grep classLoaderHashvmtool --action getInstances -c 19469ea2 --className org.springframework.context.ApplicationContext# 执行表达式，--express: 执行的表达式，这里是调用对象的方法vmtool --action getInstances --className com.example.demo.arthas.aop.HelloWorldService --express &#x27;instances[0].getHelloMessage()&#x27;# 强制 GC，可以结合 vmoption 命令动态打开PrintGC开关vmtool --action forceGc# 中断线程， -t 线程ID,可以使用 thread命令获取vmtool --action interruptThread -t 1","summary":"摘要 本文介绍JVM的命令行工具 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档","date_published":"2025-05-13T13:30:05.000Z","tags":["技术","jvm","jvm"]},{"id":"https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/","url":"https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/","title":"JVM 之 内存模型与垃圾回收机制(GC)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍JVM的内存模型与垃圾回收机制</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\">JDK8 The Java® Virtual Machine Specification</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\">JDK8的java指令的官⽅⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/index.html\">JDK⼯具官⽹⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html\">JDK17的java指令的官⽅⽂档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"JVM虚拟机结构-HotSpot\">JVM虚拟机结构(HotSpot)</h2>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/cGMyEe.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置内存分配示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># jdk1.8+</span></span><br><span class=\"line\">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=128M ‐XX:MaxMetaspaceSize=256M ‐jar server.jar</span><br><span class=\"line\"><span class=\"comment\"># jdk1.6/1.7</span></span><br><span class=\"line\">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:PermSize=128M ‐XX:MaxPermSize=256M ‐jar server.jar</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>各参数含义与默认值（针对 JDK 1.8）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义说明</th>\n<th>默认值（JDK 1.8）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-Xms2048M</code></td>\n<td><strong>初始堆大小</strong>，即 JVM 启动时分配的堆内存大小（这里是 2GB）</td>\n<td>物理内存的 1/64（最小 1MB），推荐配置为与 -Xmx 一致</td>\n</tr>\n<tr>\n<td><code>-Xmx2048M</code></td>\n<td><strong>最大堆内存大小</strong>，JVM 允许分配的最大堆内存</td>\n<td>物理内存的 1/4（受限于 32位/64位）</td>\n</tr>\n<tr>\n<td><code>-Xmn1024M</code></td>\n<td><strong>新生代大小</strong>（Eden + Survivor）为 1GB</td>\n<td>未显式指定时，通常占堆的 1/3 左右</td>\n</tr>\n<tr>\n<td><code>-Xss512K</code></td>\n<td><strong>每个线程的栈大小</strong>（Thread Stack Size），这里设置为 512KB</td>\n<td>1MB（64位系统）或 512KB（32位系统）</td>\n</tr>\n<tr>\n<td><code>-XX:MetaspaceSize=256M</code></td>\n<td><strong>元空间初始大小</strong>（用于加载类的元数据，不再使用 PermGen），达到该值后，JVM 会触发一次 GC，空间不够时会进行扩容，最大到  <code>MaxMetaspaceSize</code></td>\n<td>默认 21MB（客户端）或 16MB（服务器端），为避免频繁扩容导致的GC，可以设置的稍微大一些，比如<code>MaxMetaspaceSize</code>的一半，或干脆与<code>MaxMetaspaceSize</code>一样大</td>\n</tr>\n<tr>\n<td><code>-XX:MaxMetaspaceSize=256M</code></td>\n<td><strong>元空间最大大小</strong>，接近设置值时会触发 Full GC</td>\n<td>无限制（默认只受物理内存约束） ，推荐配置一个合适的数值，比如8G的内存可以配置为256M</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类装载子系统（Class-Loading-Subsystem）\">类装载子系统（Class Loading Subsystem）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>类装载子系统负责将 <code>.class</code> 文件加载到 JVM 中，并进行解析、验证、初始化等过程。</p>\n</li>\n<li class=\"lvl-2\">\n<p>加载过程的几个阶段：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>加载（Loading）</strong></td>\n<td>将 <code>.class</code> 文件读取为二进制数据，构造 <code>Class</code> 对象</td>\n</tr>\n<tr>\n<td><strong>验证（Verification）</strong></td>\n<td>确保字节码文件格式正确、安全合法（防止恶意代码）</td>\n</tr>\n<tr>\n<td><strong>准备（Preparation）</strong></td>\n<td>为类的静态变量分配内存，并设置默认初始值</td>\n</tr>\n<tr>\n<td><strong>解析（Resolution）</strong></td>\n<td>将常量池中的符号引用替换为直接引用（方法、字段等）</td>\n</tr>\n<tr>\n<td><strong>初始化（Initialization）</strong></td>\n<td>执行 <code>&lt;clinit&gt;</code> 静态初始化方法，对静态变量赋初始值</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>类加载器（ClassLoader）体系结构：详细参考 <a href=\"/2025/05/08/jvm-classloader-01/\" title=\"JVM 之 类加载器\">JVM 之 类加载器</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类加载器名称</th>\n<th>加载内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>引导类加载器（Bootstrap ClassLoader）</strong></td>\n<td>Java 核心类库（如 <code>java.lang.*</code>）</td>\n<td>由 JVM 自身实现，用本地代码实现，无法直接访问</td>\n</tr>\n<tr>\n<td><strong>扩展类加载器（Extension ClassLoader）</strong></td>\n<td><code>JAVA_HOME/jre/lib/ext</code> 目录下的类</td>\n<td>加载标准扩展类库</td>\n</tr>\n<tr>\n<td><strong>应用类加载器（Application ClassLoader）</strong></td>\n<td>用户应用类路径（CLASSPATH 指定的目录）</td>\n<td>最常用，加载大多数应用代码</td>\n</tr>\n<tr>\n<td><strong>自定义类加载器（Custom ClassLoader）</strong></td>\n<td>用户手动实现的类加载器</td>\n<td>可以打破双亲委派机制，实现热加载、加密类加载等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>类加载采用 双亲委派模型：请求会先向父加载器委托，只有在父加载器加载失败时才尝试自身加载。</p>\n</blockquote>\n<h3 id=\"字节码执行引擎（Execution-Engine）\">字节码执行引擎（Execution Engine）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>字节码执行引擎负责将 Java 字节码解释或编译为机器代码，并在底层平台上执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>执行引擎的核心模块</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>组件名称</th>\n<th>作用说明</th>\n<th>关键特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>解释器（Interpreter）</strong></td>\n<td>将字节码逐条解释执行</td>\n<td>启动快，适合冷代码（非热点代码），执行效率相对较低</td>\n</tr>\n<tr>\n<td><strong>即时编译器（JIT Compiler）</strong></td>\n<td>将热点代码编译为本地机器码，提高执行效率</td>\n<td>包含 C1（Client）和 C2（Server）两种，支持优化如：方法内联、逃逸分析、循环展开等</td>\n</tr>\n<tr>\n<td><strong>垃圾收集器（Garbage Collector, GC）</strong></td>\n<td>自动内存管理，负责对象生命周期的回收</td>\n<td>常见算法包括：Serial、Parallel、CMS、G1、ZGC（低延迟）等，根据不同场景选择</td>\n</tr>\n<tr>\n<td><strong>本地接口（Native Interface）</strong></td>\n<td>支持 Java 与本地语言（如 C/C++）的互操作</td>\n<td>通过 JNI（Java Native Interface）实现，调用底层操作系统或第三方库功能</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>即时编译器（JIT Compiler）</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">JVM 的 HotSpot 编译器有两个主要组件：<br>\nC1 编译器（Client 编译器）：轻量、快速编译，优化少。<br>\nC2 编译器（Server 编译器）：优化高级，耗时长，适合长时间运行的热点代码。</li>\n<li class=\"lvl-2\">在 64 位 JDK 中，默认就是 -server 模式 <code>(C2 编译器)</code> ，不再支持 -client <code>(C1 编译器)</code>。</li>\n<li class=\"lvl-2\">在 32 位 JDK 中，根据平台和启动方式，可能会自动选择 -client 或 -server，也可以手动指定。</li>\n<li class=\"lvl-2\">分层编译（Tiered Compilation） 允许 JVM 在一开始用 C1 编译器快速编译字节码，后续热点代码再交给 C2 编译器进行更高级优化。这样结合了 -client（快启动）和 -server（高性能）的优点。<code>TieredCompilation</code>参数控制是否开启分层编译，默认开启。</li>\n<li class=\"lvl-2\"><code>-XX:TieredStopAtLeve=&lt;level&gt;</code> 参数控制 编译器最多使用哪一层优化级别。它的取值如下，值越低启动越快，但优化越少。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>仅解释执行（不开启编译器）</td>\n</tr>\n<tr>\n<td>1</td>\n<td>只使用 C1 编译器的第一级（最少优化）</td>\n</tr>\n<tr>\n<td>2</td>\n<td>C1 第二级，略多优化</td>\n</tr>\n<tr>\n<td>3</td>\n<td>C1 第三级，更优化</td>\n</tr>\n<tr>\n<td>4</td>\n<td>启用 C2 编译器（完全优化，默认值）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"JVM-内存模型（Java-Memory-Model，JMM）\">JVM 内存模型（Java Memory Model，JMM）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JMM 是 Java 虚拟机规范中定义的一种 抽象内存模型，它决定了多线程程序中变量的读写可见性、有序性和原子性。同时，JVM 在物理层也有一个实际的内存结构，称为运行时数据区域（Runtime Data Areas），这两个可以结合理解。</p>\n</li>\n<li class=\"lvl-2\">\n<p>JMM 的主要目标</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">保证多线程环境下的数据一致性</li>\n<li class=\"lvl-6\">指导 JVM 和 CPU 的内存交互行为（如重排序、缓存）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>实际运行时内存结构如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内存区域</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>📌 <strong>程序计数器（PC）</strong></td>\n<td>每个线程私有，记录当前执行的字节码指令地址</td>\n</tr>\n<tr>\n<td>📌 <strong>Java 线程栈</strong></td>\n<td>每个线程私有，方法调用时用于存储局部变量、操作数栈等</td>\n</tr>\n<tr>\n<td>📌 <strong>本地方法栈</strong></td>\n<td>与虚拟机栈类似，用于 native 方法</td>\n</tr>\n<tr>\n<td>📌 <strong>堆（Heap）</strong></td>\n<td>所有线程共享，存储对象实例、数组等，GC 的主要区域</td>\n</tr>\n<tr>\n<td>📌 <strong>方法区（或元空间）</strong></td>\n<td>所有线程共享，存储类信息、静态变量、常量池等（JDK8 后称为 Metaspace）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"垃圾回收器\">垃圾回收器</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>垃圾回收器负责自动管理内存，回收不再使用的对象，避免内存泄漏和溢出。</p>\n</li>\n</ul>\n<h3 id=\"什么是垃圾\">什么是垃圾</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>内存中没有被（线程栈变量，静态变量，常量池，JNI指针）引用的地址就是垃圾</p>\n</li>\n<li class=\"lvl-2\">\n<p>可达性分析算法：是现代 JVM 判断一个对象是否“还活着”的主要算法。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本思想：</span><br><span class=\"line\">从一组称为 “GC Roots” 的对象出发，沿着对象之间的引用链向下搜索。</span><br><span class=\"line\">如果某个对象 可以从 GC Roots 追踪到，就认为它是 “可达” 的（Alive）。</span><br><span class=\"line\">否则就认为是 “不可达” 的（Garbage），可以被回收。</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>在 JVM 中，<code>GC Roots</code> 是一些 始终可用的、不会被垃圾回收的引用起点，主要包括：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>GC Roots 来源</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>当前线程栈中的引用（局部变量表）</td>\n<td>各个线程正在调用的方法中的局部变量、参数等</td>\n</tr>\n<tr>\n<td>静态字段引用</td>\n<td>类的静态字段引用的对象</td>\n</tr>\n<tr>\n<td>JNI 引用（Native 方法引用）</td>\n<td>Java 本地方法中引用的对象</td>\n</tr>\n<tr>\n<td>常量引用池中的对象</td>\n<td>字符串常量等可能持有对象引用</td>\n</tr>\n<tr>\n<td>活动线程对象</td>\n<td>线程自身在 GC 时不会被回收</td>\n</tr>\n<tr>\n<td>JVM 内部结构（如系统类加载器等）</td>\n<td>JVM 关键系统对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"垃圾回收器种类：\">垃圾回收器种类：</h3>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/TEILZ9.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>左边6种叫分代模型，右边的4种叫分区模型</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>分代模型（Generational Model）</strong></em><br>\n堆内存划分为：<br>\n年轻代（Young Generation）：存放新创建的对象，分为 Eden 和 Survivor 区。<br>\n老年代（Old Generation）：存放经过多次 GC 后仍然存活的对象。</p>\n<p><em><strong>分区模型（Region-based Model）</strong></em><br>\n分区模型（如 G1、ZGC、Shenandoah）不再严格按照代划分内存，而是把堆划分为多个 大小相同的 Region。每个 Region 可以在运行时被动态标记为 Eden、Survivor 或 Old。</p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分代模型中，上面3个是新生代垃圾回收器，下面3个是老年代垃圾回收器，可以交叉配对（见上图虚线），但最常用是上下两两配对。</p>\n</li>\n<li class=\"lvl-2\">\n<p>CMS即可以作为新生代垃圾回收器，也可以作为老年代垃圾回收器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>EpsilonGC，是一个特殊的垃圾回收器，它不回收任何对象，只负责最终记录，做测试用的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>目前最先进的模型是 <code>ZGC</code>，jkd11开始支持，但直到JDK16才比较完善，目前非默认配置，需要手动配置。其与Redhat出品的 <code>Shenandoah</code> 是竞争关系。</p>\n</li>\n<li class=\"lvl-2\">\n<p>常见垃圾回收器及其分类、JDK版本</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>垃圾回收器</th>\n<th>所属模型</th>\n<th>说明</th>\n<th>首次出现 JDK 版本</th>\n<th>启用命令（JVM 参数）</th>\n<th>适合的堆内存大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Serial</strong></td>\n<td>分代模型</td>\n<td>单线程，新生代和老年代都使用 Serial，适用于小堆内存, <code>已弃用</code></td>\n<td>JDK 1.2</td>\n<td><code>-XX:+UseSerialGC</code></td>\n<td>💾 小于 1GB</td>\n</tr>\n<tr>\n<td><strong>ParNew</strong></td>\n<td>分代模型</td>\n<td>Serial 的多线程版本，<strong>仅用于 CMS 新生代</strong>, <code>JDK11已弃用</code></td>\n<td>JDK 1.4</td>\n<td><code>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></td>\n<td>💾 1GB ~ 4GB</td>\n</tr>\n<tr>\n<td><strong>Parallel（吞吐量 GC）</strong></td>\n<td>分代模型</td>\n<td>多线程 GC，适合吞吐量优先的应用场景</td>\n<td>JDK 1.4</td>\n<td><code>-XX:+UseParallelGC</code>（新生代）<br><code>-XX:+UseParallelOldGC</code>（老年代）</td>\n<td>💾 2GB ~ 8GB</td>\n</tr>\n<tr>\n<td><strong>CMS（Concurrent Mark Sweep）</strong></td>\n<td>分代模型</td>\n<td>老年代并发标记-清除，低延迟，但存在碎片，<code>JDK14已弃用</code></td>\n<td>JDK 1.4</td>\n<td><code>-XX:+UseConcMarkSweepGC</code></td>\n<td>💾 2GB ~ 8GB</td>\n</tr>\n<tr>\n<td><strong>G1（Garbage First）</strong></td>\n<td>分区模型</td>\n<td>将堆划分为 Region，逻辑分代，支持并发压缩，平衡延迟与吞吐</td>\n<td>JDK 7u4（正式）</td>\n<td><code>-XX:+UseG1GC</code></td>\n<td>💾 4GB ~ 数十 GB</td>\n</tr>\n<tr>\n<td><strong>ZGC（Z Garbage Collector）</strong></td>\n<td>分区模型</td>\n<td>Region 弹性大小，支持超大堆，低延迟（&lt;10ms 停顿）</td>\n<td>JDK 11（实验），JDK 15（正式）</td>\n<td><code>-XX:+UseZGC</code></td>\n<td>💾 8GB ~ 数 TB（超大堆）</td>\n</tr>\n<tr>\n<td><strong>Shenandoah</strong></td>\n<td>分区模型</td>\n<td>红帽主导，低延迟，并发回收与并发压缩</td>\n<td>JDK 12（实验），JDK 15（正式）</td>\n<td><code>-XX:+UseShenandoahGC</code></td>\n<td>💾 2GB ~ 数十 GB</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>对于 CMS，启用后会自动使用 ParNew 作为新生代回收器（除非显式禁止）。<br>\n对于 Parallel GC 启用 <code>-XX:+UseParallelGC</code>（新生代）会自动启用 <code>-XX:+UseParallelOldGC</code>（老年代）。<br>\n对于ZGC，jdk15以前最大支持4T内存，之后最大支持16T内存。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>各版本默认垃圾回收器及推荐配置（JDK 1.6 起）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>JDK 版本</th>\n<th>默认 GC</th>\n<th>建议使用 GC（按场景分类）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>JDK 1.6</strong></td>\n<td>Serial / Parallel</td>\n<td>- 小型应用（如桌面程序）：<code>-XX:+UseSerialGC</code>  <br> - 中大型应用（吞吐量优先）：<code>-XX:+UseParallelGC</code></td>\n</tr>\n<tr>\n<td><strong>JDK 1.7</strong></td>\n<td>同上</td>\n<td>同 JDK 1.6</td>\n</tr>\n<tr>\n<td><strong>JDK 1.8</strong></td>\n<td>Parallel</td>\n<td>- 吞吐优先：默认 <code>-XX:+UseParallelGC</code> <br> - 响应优先：<code>-XX:+UseConcMarkSweepGC</code>（CMS）<br> - 大堆 + 未来升级考虑：<code>-XX:+UseG1GC</code>（推荐）</td>\n</tr>\n<tr>\n<td><strong>JDK 9-14</strong></td>\n<td>G1 GC</td>\n<td>- 一般默认即可：<code>-XX:+UseG1GC</code>（延迟与吞吐平衡）<br> - 极端低延迟要求：升级到 JDK 11+ 使用 ZGC/Shenandoah</td>\n</tr>\n<tr>\n<td><strong>JDK 15+</strong></td>\n<td>G1 GC（默认），ZGC / Shenandoah 可选</td>\n<td>- 延迟敏感（在线服务、RT系统）：<code>-XX:+UseZGC</code> 或 <code>-XX:+UseShenandoahGC</code><br> - 吞吐为主：<code>-XX:+UseParallelGC</code><br> - 综合平衡：<code>-XX:+UseG1GC</code>（默认）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>判断默认 GC 的方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾回收算法\">垃圾回收算法</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JVM 中常见垃圾回收算法汇总</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>算法名称</th>\n<th>核心思想</th>\n<th>适用阶段/区域</th>\n<th>优缺点简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>标记-清除（Mark-Sweep）</strong></td>\n<td>标记出存活对象，清除未标记对象</td>\n<td>老年代</td>\n<td>简单高效，但会产生大量碎片，不适合连续内存分配</td>\n</tr>\n<tr>\n<td><strong>标记-整理（Mark-Compact）</strong></td>\n<td>标记后移动存活对象，整理碎片</td>\n<td>老年代</td>\n<td>消除碎片，代价是移动对象，适用于老年代压缩</td>\n</tr>\n<tr>\n<td><strong>复制算法（Copying）</strong></td>\n<td>将对象复制到另一块内存（如 Eden → Survivor）</td>\n<td>新生代</td>\n<td>高效率，适合回收大多数对象短命的新生代，但需要额外空间</td>\n</tr>\n<tr>\n<td><strong>分代回收（Generational）</strong></td>\n<td>将对象按生命周期划分（新生代/老年代）</td>\n<td>整个堆结构</td>\n<td>实用性强，结合不同算法应用于不同代，现代 GC 基础</td>\n</tr>\n<tr>\n<td><strong>分区回收（Region-based）</strong></td>\n<td>将堆划分为若干等大小的 Region 动态分配</td>\n<td>整个堆（如 G1、ZGC）</td>\n<td>更灵活，支持并发并行，减少 STW 停顿，适用于大堆、低延迟场景</td>\n</tr>\n<tr>\n<td><strong>增量回收（Incremental）</strong></td>\n<td>分阶段小步执行 GC 以减少单次停顿</td>\n<td>某些并发/低延迟 GC</td>\n<td>减少暂停时间，但整体效率可能降低</td>\n</tr>\n<tr>\n<td><strong>并发回收（Concurrent）</strong></td>\n<td>标记、清理等步骤与应用线程并发执行</td>\n<td>CMS、G1、ZGC 等</td>\n<td>停顿时间短，对响应时间要求高的系统友好</td>\n</tr>\n<tr>\n<td><strong>三色标记（Tri-color Marking）</strong></td>\n<td>并发标记算法的一种实现思想</td>\n<td>CMS、G1、ZGC 等</td>\n<td>白（待回收）、灰（已标记未扫描）、黑（已标记已扫描），避免“漏标”问题</td>\n</tr>\n<tr>\n<td><strong>SATB（Snapshot-At-The-Beginning）</strong></td>\n<td>并发标记的快照策略</td>\n<td>G1、ZGC</td>\n<td>保证在并发标记过程中不遗漏新引用，适合高并发场景</td>\n</tr>\n<tr>\n<td><strong>Lazy Compaction（延迟压缩）</strong></td>\n<td>不每次 GC 都压缩，视情况而定</td>\n<td>G1 等</td>\n<td>降低不必要的移动成本</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对应关系：GC 回收器和底层算法</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>回收器</th>\n<th>使用的算法组合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Serial</strong></td>\n<td>新生代：复制算法<br>老年代：标记-整理</td>\n</tr>\n<tr>\n<td><strong>ParNew</strong></td>\n<td>新生代：复制算法（多线程）</td>\n</tr>\n<tr>\n<td><strong>Parallel</strong></td>\n<td>新生代：复制算法<br>老年代：标记-整理</td>\n</tr>\n<tr>\n<td><strong>CMS</strong></td>\n<td>新生代：ParNew（复制）<br>老年代：标记-清除 + 三色标记 + 并发</td>\n</tr>\n<tr>\n<td><strong>G1</strong></td>\n<td>分区回收 + 三色标记 + SATB + Lazy Compaction</td>\n</tr>\n<tr>\n<td><strong>ZGC</strong></td>\n<td>分区回收 + 并发标记 + SATB + Region Remapping</td>\n</tr>\n<tr>\n<td><strong>Shenandoah</strong></td>\n<td>分区回收 + 并发标记 + 并发压缩 + 三色标记</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       ┌────────────────────────┐</span><br><span class=\"line\">       │   常见 GC 算法分类       │</span><br><span class=\"line\">       └────────────────────────┘</span><br><span class=\"line\">                 │</span><br><span class=\"line\">   ┌─────────────┴──────────────┐</span><br><span class=\"line\">   │                            │</span><br><span class=\"line\">分代模型                      分区模型</span><br><span class=\"line\">   │                            │</span><br><span class=\"line\"> ┌─┴─────┐                  ┌───┴─────┐</span><br><span class=\"line\">复制   标记-清除         Region-based 并发</span><br><span class=\"line\">      标记-整理             SATB / 三色标记</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是-STW（Stop-The-World）\">什么是 STW（Stop-The-World）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>STW（Stop-The-World） 指的是：在某些垃圾回收阶段，JVM 会暂停所有应用线程（也叫用户线程），让垃圾回收线程独占 CPU 执行 GC 逻辑。</p>\n</li>\n<li class=\"lvl-2\">\n<p>你可以这样理解 STW</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">JVM 会“按下暂停键”暂停所有正在运行的 Java 程序代码；</li>\n<li class=\"lvl-6\">然后 专心进行 GC 的某些阶段（如标记、整理、复制等）；</li>\n<li class=\"lvl-6\">GC 完成后，才会“恢复运行”应用线程。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>各 GC 中 STW 的存在情况</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>回收器</th>\n<th>是否存在 STW？</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Serial</td>\n<td>✅ 是，全停顿，全阶段单线程</td>\n<td>堆越大 STW 越长</td>\n</tr>\n<tr>\n<td>Parallel</td>\n<td>✅ 是，全停顿，多线程执行 GC</td>\n<td>提高效率但仍会暂停</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td>✅ 有，初始标记和最终重新标记是 STW</td>\n<td>大部分阶段并发执行</td>\n</tr>\n<tr>\n<td>G1</td>\n<td>✅ 有，但设计为尽可能缩短 STW</td>\n<td>分阶段并发 + 并行处理</td>\n</tr>\n<tr>\n<td>ZGC</td>\n<td>✅ 极短（&lt;10ms）</td>\n<td>仅个别阶段是 STW，几乎感知不到</td>\n</tr>\n<tr>\n<td>Shenandoah</td>\n<td>✅ 极短</td>\n<td>高度并发，STW 时间也极短</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为什么要关注 STW？</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">在响应时间敏感型系统（如在线交易系统、游戏服务器、API 网关）中，长时间的 STW 会造成用户请求卡顿、超时。</li>\n<li class=\"lvl-6\">因此，选择 低 STW 的 GC（如 G1、ZGC、Shenandoah） 对这类系统至关重要。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"堆内存结构\">堆内存结构</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不同的垃圾回收器决定了堆内存的结构不同，但总体上分为两种类型：分代模型和分区模型。</p>\n</li>\n</ul>\n<h3 id=\"分代模型\">分代模型</h3>\n<h4 id=\"Parallel-垃圾回收器\">Parallel 垃圾回收器</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Apr5aY.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>堆结构被划分为 <code>Old Generation（老年代）</code> 和 <code>Young Generation（新生代）</code> 两部分。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Young Generation</code> 由 <code>Eden</code> 和 两个 <code>Survivor</code> 组成，其中 <code>Eden</code> 是一个连续的内存区域，<code>Survivor</code> 是一个非连续的内存区域。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，<code>Young Generation</code>占堆内存的 <code>1/3</code>,  <code>Old Generation</code> 占堆内存的 <code>2/3</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，<code>Eden:S0:S1 = 8:1:1</code> ,如果希望为 4:1:1，使用 <code>-XX:SurvivorRatio=4</code>，但实际上这个比例并不是固定的，而是由jvm基于情况自动变化的，因为JVM默认开启了这个参数<code>-XX:+UseAdaptiveSizePolicy</code>，如果希望固定这个比例，可以设置为 <code>-XX:-UseAdaptiveSizePolicy</code>来关闭这个配置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，对象最多经历<code>15次</code>Minor GC后进入老年代，可以通过 <code>-XX:MaxTenuringThreshold=n</code> 设置。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>区域</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Eden</strong></td>\n<td>对象首次创建的区域，大部分对象在这里创建并很快被回收</td>\n</tr>\n<tr>\n<td><strong>S0/S1</strong></td>\n<td>Survivor 区域：两个交替使用的缓冲区（From 和 To），用于拷贝存活对象</td>\n</tr>\n<tr>\n<td><strong>Old</strong></td>\n<td>老年代：存活次数多、生命周期长的对象会从新生代晋升到老年代，回收频率低</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对象内存分配图解(简化)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建对象</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">进入 Eden 区（新生代）</span><br><span class=\"line\">   ↓ Eden 区满</span><br><span class=\"line\">第一次 Minor GC（存活对象[Eden]复制到 S0）</span><br><span class=\"line\">   ↓ Eden 区满 或 S0 区满</span><br><span class=\"line\">第二次 Minor GC（存活对象[Eden和S0]复制到 S1，年龄 +1）</span><br><span class=\"line\">   ↓ Eden 区满 或 S1 区满</span><br><span class=\"line\">第三次 Minor GC（存活对象[Eden和S1]复制到 S0，年龄 +1）</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">……  S0/S1 交替，年龄达到阈值（如 15）</span><br><span class=\"line\">   ↓ 还没有被回收</span><br><span class=\"line\">晋升到 Old 区（老年代），等待Old区满 触发 Full GC</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>大对象直接进入老年代</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">大对象就是需要大量连续内存空间的对象（比如：字符串、数组），如果对象很大（如超过 Eden 区大小，或是超过 Survivor 区大小），可能直接分配到老年代</li>\n<li class=\"lvl-6\">也可以通过 <code>-XX:PretenureSizeThreshold=&lt;大小，单位字节&gt;</code> 控制超过一定大小的对象是否直接分配到老年代（Old Generation），跳过新生代（Eden），以避免大对象频繁在年轻代造成 GC 压力。这个参数只在 Serial 和ParNew两个收集器下有效。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>对象动态年龄判断</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">对象在Survivor区来回移动时，如果这批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，</li>\n<li class=\"lvl-6\">例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。</li>\n<li class=\"lvl-6\">对象动态年龄判断机制一般是在minor gc之后触发的。</li>\n</ul>\n</li>\n</ul>\n<div class=\"tips\">\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>对象逃逸分析</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">如果对象很小，且只在方法内部使用，并没有被外部引用，则其有可能直接分配到栈内存，而不进入堆内存</li>\n<li class=\"lvl-6\">JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<code>标量替换</code>优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>标量替换</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。</li>\n<li class=\"lvl-6\">开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>标量与聚合量</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），</li>\n<li class=\"lvl-6\">标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h4 id=\"Parallel-垃圾回收器（Parallel-GC）-的工作方式\">Parallel 垃圾回收器（Parallel GC） 的工作方式</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/fo2Egs.png\" alt=\"\" width=\"1200\" height=\"600\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Parallel GC 是多线程垃圾回收器，可以通过 <code>-XX:ParallelGCThreads</code> 来设置GC线程数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当 Parallel GC 被触发（例如 Minor GC 或 Full GC）时，所有用户线程 被完全暂停（Stop-The-World, STW）</p>\n</li>\n</ul>\n<h4 id=\"Parallel-GC-参数配置表（吞吐量优先-GC）\">Parallel GC 参数配置表（吞吐量优先 GC）</h4>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n<th>默认值（如未特别说明）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-XX:+UseParallelGC</code></td>\n<td>开启 Parallel GC，用于新生代收集</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:+UseParallelOldGC</code></td>\n<td>开启老年代并行收集（Parallel Old）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:ParallelGCThreads</code></td>\n<td>垃圾回收时的并行线程数（与 CPU 数量相关）</td>\n<td>根据硬件自动配置</td>\n</tr>\n<tr>\n<td><code>-XX:MaxGCPauseMillis</code></td>\n<td>设置 GC 最大暂停时间目标（影响内存分配策略）</td>\n<td>一个非常大的值，可以认为无限制（建议按需设置）</td>\n</tr>\n<tr>\n<td><code>-XX:GCTimeRatio</code></td>\n<td>设置 GC 时间与应用运行时间的比值（0~100）<br>值越小，GC 越频繁，值越大 GC 越少</td>\n<td>99（表示 1% 用于 GC，99% 用于应用）</td>\n</tr>\n<tr>\n<td><code>-XX:+UseAdaptiveSizePolicy</code></td>\n<td>启用自适应 GC 策略（根据运行状况自动调整各区域大小）</td>\n<td>默认开启</td>\n</tr>\n<tr>\n<td><code>-XX:SurvivorRatio</code></td>\n<td>Eden 与 Survivor 的内存比例（如 8 表示 Eden:S0:S1 = 8:1:1）</td>\n<td>8</td>\n</tr>\n<tr>\n<td><code>-XX:InitialTenuringThreshold</code></td>\n<td>对象晋升到老年代的初始年龄（会随运行动态调整）</td>\n<td>7</td>\n</tr>\n<tr>\n<td><code>-XX:MaxTenuringThreshold</code></td>\n<td>晋升到老年代的最大年龄（对象在 Survivor 区经历几次 GC）</td>\n<td>15</td>\n</tr>\n<tr>\n<td><code>-XX:PretenureSizeThreshold</code></td>\n<td>设置大对象阈值，超过该大小的对象直接分配到老年代</td>\n<td>0（即禁用）</td>\n</tr>\n<tr>\n<td><code>-XX:+ScavengeBeforeFullGC</code></td>\n<td>在 Full GC 之前是否先执行一次 Minor GC</td>\n<td>true启</td>\n</tr>\n<tr>\n<td><code>-XX:+UseFastAccessorMethods</code></td>\n<td>优化原始类型的 get/set 方法性能</td>\n<td>false启</td>\n</tr>\n<tr>\n<td><code>-XX:+AlwaysPreTouch</code></td>\n<td>JVM 启动时立即分配并初始化所有内存页，避免运行时首次分配带来的停顿</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分区模型\">分区模型</h3>\n<h4 id=\"G1-垃圾回收器\">G1 垃圾回收器</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/AaqBxm.png\" alt=\"\" width=\"900\" height=\"300\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>G1(Garbage-First) 属于 物理上分区，逻辑上分代，真正的分区模型是 <code>ZGC</code>（jdk21后也支持分代）</p>\n</li>\n<li class=\"lvl-2\">\n<p>G1将Java堆划分为多个大小相等的Region，Region大小是2的幂，范围在1MB到32MB之间。JDK9之前默认最多支持2048个Region，这就导致G1最大支持64G 的堆 (<code>2048 Regions × 32MB = 64GB</code>)，JDK10之后的版本可支持更多Region数量，JDK17进一步优化了Region映射机制，提升了大堆场景下的性能，使其可以支持更大的内存，但对于超大堆（&gt;1T），考虑到GC暂停时间，建议使用ZGC或Shenandoah GC。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Region一旦被回收，重新分配时可以是任意类型，比如原先是<code>Eden</code>，那么重新分配时可以是<code>Old</code>，反之亦然。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一般Region大小由JVM自动计算，当然也可以用参数<code>-XX:G1HeapRegionSize</code>手动指定Region大小，但是推荐默认的计算方式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 G1 GC 中，不要使用 <code>-Xmn</code>，G1 中推荐使用以下更细粒度的控制方式：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是实验性参数，需要开启 `-XX:+UnlockExperimentalVMOptions`，但依旧推荐在生产环境中使用</span></span><br><span class=\"line\">-XX:G1NewSizePercent=5</span><br><span class=\"line\">-XX:G1MaxNewSizePercent=60</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认年轻代对堆内存的占比是<code>5%</code>，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过   <code>-XX:G1NewSizePercent</code>设置新生代初始占比，这是实验性参数，需要开启 <code>-XX:+UnlockExperimentalVMOptions</code>，但依旧推荐在生产环境中使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过<code>60%</code>，可以通过<code>-XX:G1MaxNewSizePercent</code>调整，这是实验性参数，需要开启 <code>-XX:+UnlockExperimentalVMOptions</code>，但依旧推荐在生产环境中使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>年轻代中的Eden和Survivor对应的region也跟之前一样，默认<code>8:1:1</code>，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>\n</li>\n<li class=\"lvl-2\">\n<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫<code>Humongous</code>区，而不是让大对象直接进入老年代的Region中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的<code>50%</code>，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>\n</li>\n</ul>\n<h5 id=\"G1垃圾收集分类\">G1垃圾收集分类</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>YoungGC<br>\nYoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做YoungGC，直到下一次Eden区放满，G1计算回收时间接近参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么就会触发Young GC</p>\n</li>\n<li class=\"lvl-2\">\n<p>MixedGC<br>\n不是FullGC，老年代的堆占有率达到参数 <code>-XX:InitiatingHeapOccupancyPercent</code> 设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</p>\n</li>\n<li class=\"lvl-2\">\n<p>Full GC<br>\n停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>\n</li>\n</ul>\n<h4 id=\"G1-收集器的工作方式-MixedGC\">G1 收集器的工作方式(MixedGC)</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/XbkEoh.png\" alt=\"\" width=\"1200\" height=\"400\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>图中主要展示了一个典型的 G1 GC 的 并发标记周期（Concurrent Mark Cycle） 的过程。</p>\n</li>\n<li class=\"lvl-2\">\n<p>图中的水平箭头表示各线程（用户线程和GC线程）的执行路径。</p>\n</li>\n<li class=\"lvl-2\">\n<p>竖直的<code>Safepoint</code>线表示一次GC过程中会暂停所有用户线程的时刻（Stop-The-World）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1️⃣ 初始标记（Initial Mark）</span><br><span class=\"line\">    进入 Safepoint： 所有用户线程在此刻暂停（STW）。</span><br><span class=\"line\">    标记 GC Roots 直接可达对象。</span><br><span class=\"line\">    非常短暂，但属于 Stop-The-World 阶段。</span><br><span class=\"line\">    图中是“初始标记”箭头在 Safepoint 之后立刻执行。</span><br><span class=\"line\"></span><br><span class=\"line\">2️⃣ 并发标记（Concurrent Mark）</span><br><span class=\"line\">    用户线程 恢复运行（图中用户线程继续向右延伸）。</span><br><span class=\"line\">    GC 线程 并发进行标记工作（即在用户线程运行期间进行标记）。</span><br><span class=\"line\">    图中蓝色的“并发标记”箭头与用户线程箭头并行显示，表示并发执行。</span><br><span class=\"line\"></span><br><span class=\"line\">3️⃣ 最终标记（Remark / Final Mark）</span><br><span class=\"line\">    再次进入 Safepoint。</span><br><span class=\"line\">    重新暂停所有用户线程。</span><br><span class=\"line\">    处理并发标记阶段中遗漏的引用更新等信息，保证标记的准确性。</span><br><span class=\"line\"></span><br><span class=\"line\">4️⃣ 筛选回收（Cleanup / Filtered Collection）</span><br><span class=\"line\">    对已标记的对象做清理（回收不可达对象）。</span><br><span class=\"line\">    判断是否需要回收某些 Region。</span><br><span class=\"line\">    图中蓝色箭头标注为“筛选回收”。</span><br><span class=\"line\"></span><br><span class=\"line\">5️⃣ 恢复用户线程</span><br><span class=\"line\">    在最后一个 Safepoint 之后，所有用户线程重新开始执行（图中黄色箭头重新向右延伸）。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>G1的GC 过程会经历多次<code>Safepoint</code>，但只有 <code>并发标记阶段</code> 是整个周期中最耗时但不会暂停用户线程(STW)的部分。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>Safepoint（安全点）</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">在 JVM（Java 虚拟机）中，Safepoint（安全点） 是一个非常重要的概念，它代表 所有线程必须“安全地”暂停的某个时间点，以便 JVM 能够执行某些全局操作，比如：<br>\n垃圾回收（GC）<br>\n栈遍历（例如生成堆快照、做逃逸分析等）<br>\n类卸载<br>\nJIT 编译的一些重写操作等</li>\n<li class=\"lvl-2\">如果线程正在运行、改变堆中对象的数据，那么 GC 就无法准确标记和回收对象。因此 JVM 需要 让所有线程在一个“可控、安全的位置”上暂停，这个位置就叫 Safepoint。</li>\n<li class=\"lvl-2\">Safepoint 是怎么工作的？<br>\n1.JVM 发出“进入 Safepoint”的信号（比如要开始 GC）<br>\n2.所有线程收到信号后，必须等到“最近的 Safepoint”再停下来：<br>\nSafepoint 不是任意位置都可以停，它只出现在字节码中一些特定的指令点（比如方法调用、循环跳转等）<br>\n3.等所有线程都进入 Safepoint 后，JVM 才能开始执行 GC 等全局操作。</li>\n</ul>\n</div>\n<h5 id=\"G1-收集器参数配置表\">G1 收集器参数配置表</h5>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-XX:+UseG1GC</code></td>\n<td>使用 G1 垃圾收集器</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:ParallelGCThreads</code></td>\n<td>指定 GC 工作的线程数量</td>\n<td>与 CPU 数量相关</td>\n</tr>\n<tr>\n<td><code>-XX:G1HeapRegionSize</code></td>\n<td>设置堆分区大小（1MB~32MB，2 的幂），堆默认划分为 2048 个 Region</td>\n<td>自动计算</td>\n</tr>\n<tr>\n<td><code>-XX:MaxGCPauseMillis</code></td>\n<td>设置 GC 目标最大暂停时间</td>\n<td>200ms</td>\n</tr>\n<tr>\n<td><code>-XX:G1NewSizePercent</code></td>\n<td>新生代初始占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions</td>\n<td>5%</td>\n</tr>\n<tr>\n<td><code>-XX:G1MaxNewSizePercent</code></td>\n<td>新生代最大占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions</td>\n<td>60%</td>\n</tr>\n<tr>\n<td><code>-XX:TargetSurvivorRatio</code></td>\n<td>Survivor 区填充目标（超过该比例，晋升老年代）</td>\n<td>50%</td>\n</tr>\n<tr>\n<td><code>-XX:MaxTenuringThreshold</code></td>\n<td>最大对象年龄阈值（年龄超过将进入老年代）</td>\n<td>15</td>\n</tr>\n<tr>\n<td><code>-XX:InitiatingHeapOccupancyPercent</code></td>\n<td>老年代的使用率超过该值触发 Mixed GC</td>\n<td>45%</td>\n</tr>\n<tr>\n<td><code>-XX:G1MixedGCLiveThresholdPercent</code></td>\n<td>Mixed GC 中：Region 存活对象占比低于该值才会被回收，实验性参数，-XX:+UnlockExperimentalVMOptions</td>\n<td>85%</td>\n</tr>\n<tr>\n<td><code>-XX:G1HeapWastePercent</code></td>\n<td>Mixed GC 回收目标：空闲 Region 达堆总量该百分比就结束混合回收</td>\n<td>5%</td>\n</tr>\n<tr>\n<td><code>-XX:G1ReservePercent</code></td>\n<td>为满足停顿时间目标保留的堆空间比例，是一种空间换时间的策略，在内存不足时可能造成内存更加紧张</td>\n<td>10%</td>\n</tr>\n<tr>\n<td><code>-XX:G1UseAdaptiveIHOP</code></td>\n<td>是否启用自适应IHOP，启用后G1会在初始采样后自动调整IHOP值</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>-XX:G1AdaptiveIHOPNumInitialSamples</code></td>\n<td>指定前几次GC活动按IHOP参数计算</td>\n<td>3</td>\n</tr>\n<tr>\n<td><code>-XX:SoftRefLRUPolicyMSPerMB</code></td>\n<td>每MB堆内存中软引用的过期时间(ms)</td>\n<td>1000</td>\n</tr>\n<tr>\n<td><code>-XX:G1OldCSetRegionThresholdPercent</code></td>\n<td>设置一次混合GC中需要清理的Old区的内存比例，调大可降低G1频率但会增加每次GC时间</td>\n<td>10%</td>\n</tr>\n<tr>\n<td><code>-XX:G1MixedGCCountTarget</code></td>\n<td>设置G1垃圾回收器的线程上限，HotSpot会根据清理目标自动计算所需线程数，但不会超过此上限</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ZGC-垃圾回收器\">ZGC 垃圾回收器</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/bBUAYt.png\" alt=\"\" width=\"700\" height=\"500\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZGC(Z Garbage Collector)是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Platform</th>\n<th>Supported</th>\n<th>Since</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Linux/x64</td>\n<td>✅</td>\n<td>JDK 11</td>\n<td></td>\n</tr>\n<tr>\n<td>Linux/AArch64</td>\n<td>✅</td>\n<td>JDK 13</td>\n<td></td>\n</tr>\n<tr>\n<td>macOS</td>\n<td>✅</td>\n<td>JDK 14</td>\n<td></td>\n</tr>\n<tr>\n<td>Windows</td>\n<td>✅</td>\n<td>JDK 14</td>\n<td>Requires Windows version 1803 (Windows 10 or Windows Server 2019) or later.</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZGC收集器是一款基于Region内存布局的，暂时不设分代的(jdk21后支持分代)，使用了<code>读屏障</code>、<code>颜色指针</code>等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>颜色指针</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">在 ZGC（Z Garbage Collector）中，颜色指针（Colored Pointer）是一种核心机制，把对象的 GC 状态信息直接嵌入到对象的引用（地址）中，用于在不增加对象额外元数据的前提下，跟踪对象在垃圾回收过程中的状态。</li>\n<li class=\"lvl-2\">在传统 GC 中，对象的“颜色”（如白色、灰色、黑色）表示其在 GC 不同阶段的状态，这些信息一般存储在额外的数据结构中（如记忆集合、位图等）。</li>\n<li class=\"lvl-2\">而在 ZGC 中，ZGC 将对象的这些状态信息编码进指针的高位中。所以一个对象引用（pointer）不仅仅是内存地址，还携带了对象在 GC 过程中的“颜色”信息。</li>\n<li class=\"lvl-2\">ZGC 主要运行在 64 位系统上，但当前的操作系统和 CPU 实际上只使用 48～57 位虚拟地址。ZGC 利用未使用的高位进行编码。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/LD51Zb.png\" alt=\"\" width=\"900\" height=\"300\"></li>\n<li class=\"lvl-2\">每个对象有一个64位指针，这64位被分为：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>位数</th>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>18 位</td>\n<td>预留</td>\n<td>保留位，未来可能用于扩展功能</td>\n</tr>\n<tr>\n<td>1 位</td>\n<td>Finalizable</td>\n<td>表示对象可终结（即实现了 <code>finalize()</code> 方法）</td>\n</tr>\n<tr>\n<td>1 位</td>\n<td>Remapped</td>\n<td>标识对象是否已被转移(用于标识某个引用是否已经被重定向（更新为新地址）)；为 1 表示该对象未在重定位集（Relocation Set）中，即新地址，为0表示旧地址</td>\n</tr>\n<tr>\n<td>1 位</td>\n<td>Marked1</td>\n<td>标记位之一，用于 GC 过程中的对象标记阶段 ,由于 ZGC 是并发 GC，需要两位来支持颜色切换机制（Color Flip），确保在不同 GC 周期中可以区分新旧标记，需要触发一次读取屏障（load barrier），找到对象的新位置，并更新这个引用。</td>\n</tr>\n<tr>\n<td>1 位</td>\n<td>Marked0</td>\n<td>另一个标记位，与 Marked1 配合用于 GC 标记阶段</td>\n</tr>\n<tr>\n<td>42 位</td>\n<td>对象地址部分</td>\n<td>实际的内存地址部分，最多可表示 2^42 字节（即 4 TB）,jdk15后占用 44位，支持 16TB</td>\n</tr>\n</tbody>\n</table>\n<p><em><strong>读屏障</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>ZGC（Z Garbage Collector）中的**读屏障（Read Barrier）是其核心机制之一，它保证了并发压缩（对象移动）**时程序的正确性，是实现低延迟、高并发垃圾回收的关键。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在传统 GC 中，如果对象在 GC 过程中被移动，程序访问到的对象地址可能就无效了。因此，需要**“停世界”**将所有引用更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>而 ZGC 的设计目标是 &lt;10ms 的 GC 停顿时间，所以它采用 <code>并发标记 + 并发移动 + 并发引用更新</code> 的模式。在这种模式下，对象可以在程序运行时被移动，但程序访问时必须“知道”这个对象是否已经被移动，并获取其最新地址，这就是读屏障的职责。</p>\n</li>\n<li class=\"lvl-2\">\n<p>读屏障是一种在读取对象引用时自动插入的逻辑，用于检查引用是否有效，并在必要时进行修正（即地址重定向）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZGC 是目前唯一在所有对象访问中都使用读屏障的 GC，它在每次对象指针解引用时都进行如下操作：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>职责</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>检测引用是否是老地址</strong></td>\n<td>利用指针中的元信息（颜色指针，如 Remapped 位）判断引用是否已经被更新</td>\n</tr>\n<tr>\n<td><strong>如果未更新则重定向引用</strong></td>\n<td>如果引用的是旧地址，屏障会通过 forwarding table 找到新地址并更新</td>\n</tr>\n<tr>\n<td><strong>保证最终访问对象的地址正确</strong></td>\n<td>即使在对象移动过程中，程序也总能访问到有效地址，无需停顿所有线程</td>\n</tr>\n</tbody>\n</table>\n<pre>\n<code class=\"mermaid\">\ngraph TD\nA[程序访问对象引用&lt;br&#x2F;&gt;例如：Person p &#x3D; personField] --&gt; B[JVM 插入读屏障逻辑]\nB --&gt; C[读屏障检查颜色指针中的 Remapped 位]\nC --&gt; D{Remapped 位为 0 吗？}\nD -- 是 --&gt; E[检查对象是否已被移动]\nE --&gt; F[更新引用地址为新地址]\nF --&gt; G[设置 Remapped 位为 1]\nG --&gt; H[使用更新后的引用访问对象]\nD -- 否 --&gt; I[直接使用当前引用访问对象]\n</code>\n</pre>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZGC的Region可以具有大、中、小三类容量：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">小型Region（Small Region） ： 容量固定为2MB，用于放置小于256KB的小对象。</li>\n<li class=\"lvl-6\">中型Region（Medium Region） ： 容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li>\n<li class=\"lvl-6\">大型Region（Large Region） ： 容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。</li>\n</ul>\n<blockquote>\n<p>每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>ZGC 特点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">支持极大堆（JDK 15 起支持最高 16TB）</li>\n<li class=\"lvl-6\">GC 停顿时间通常低于 1ms（与堆大小基本无关）</li>\n<li class=\"lvl-6\">适合低延迟、高吞吐、高可用的应用场景，如交易系统、广告推荐等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"ZGC-收集器的工作方式\">ZGC 收集器的工作方式</h5>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/94yKcU.png\" alt=\"\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1️⃣ 并发标记（Concurrent Mark）：</span><br><span class=\"line\">   与G1一样，并发标记是遍历对象图做可达性分析的阶段，</span><br><span class=\"line\">   它的初始标记(Mark Start)和最终标记(Mark End)也会出现短暂的停顿，</span><br><span class=\"line\">   与G1不同的是，ZGC的标记是在指针上而不是在对象上进行的，</span><br><span class=\"line\">   标记阶段会更新染色指针中的 Marked 0、 Marked 1 标志位。</span><br><span class=\"line\"></span><br><span class=\"line\">2️⃣ 并发预备重分配（Concurrent Prepare <span class=\"keyword\">for</span> Relocate）：</span><br><span class=\"line\">   这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</span><br><span class=\"line\">   ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</span><br><span class=\"line\"></span><br><span class=\"line\">3️⃣ 并发重分配（Concurrent Relocate）：</span><br><span class=\"line\">   重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，</span><br><span class=\"line\">   并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。</span><br><span class=\"line\">   ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，</span><br><span class=\"line\">   这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，</span><br><span class=\"line\">   并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</span><br><span class=\"line\"></span><br><span class=\"line\">4️⃣ 并发重映射（Concurrent Remap）：</span><br><span class=\"line\">   重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。</span><br><span class=\"line\">   ZGC很巧妙地把并发重映射阶段（Concurrent Remap）要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段（Concurrent Mark）里去完成，</span><br><span class=\"line\">   反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。</span><br><span class=\"line\">   一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</span><br></pre></td></tr></table></figure>\n<h5 id=\"ZGC存在的问题\">ZGC存在的问题</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZGC最大的问题是<code>浮动垃圾</code>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。</p>\n</li>\n<li class=\"lvl-2\">\n<p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>\n</li>\n<li class=\"lvl-2\">\n<p>JDK21正式引入了分代（jdk17是预览版），可以在生产环境中使用，需要手动开启：<code>-XX:+ZGenerational</code></p>\n</li>\n</ul>\n<h5 id=\"ZGC-收集器参数配置表\">ZGC 收集器参数配置表</h5>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n<th>默认值（如未特殊标注）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-XX:+UseZGC</code></td>\n<td>启用 ZGC 垃圾收集器</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:+UnlockExperimentalVMOptions</code></td>\n<td>解锁实验性参数（JDK 11~14 使用 ZGC 必须）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:+UseLargePages</code></td>\n<td>启用大页内存（性能优化）</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>-XX:+UseTransparentHugePages</code></td>\n<td>启用透明大页（部分 Linux 上可结合使用）</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>-Xmx</code> / <code>-Xms</code></td>\n<td>设置最大/初始堆大小</td>\n<td>用户配置</td>\n</tr>\n<tr>\n<td><code>-XX:ZUncommitDelay=&lt;秒&gt;</code></td>\n<td>未使用内存释放回操作系统的延迟时间（ZGC 会自动释放内存）</td>\n<td>300（5分钟）</td>\n</tr>\n<tr>\n<td><code>-XX:SoftMaxHeapSize=&lt;大小&gt;</code></td>\n<td>软最大堆（Soft Heap Limit）：ZGC 尝试将使用的堆控制在该值以内</td>\n<td>默认等于 -Xmx</td>\n</tr>\n<tr>\n<td><code>-XX:MaxHeapFreeRatio</code></td>\n<td>最大堆空闲比例（超过此比例可能触发内存释放）</td>\n<td>70</td>\n</tr>\n<tr>\n<td><code>-XX:MinHeapFreeRatio</code></td>\n<td>最小堆空闲比例（低于此比例可能触发扩容）</td>\n<td>40</td>\n</tr>\n<tr>\n<td><code>-XX:+ZGenerational</code></td>\n<td>启用 ZGC 分代收集（从 JDK 21 起支持，默认关闭）</td>\n<td>false（JDK 21+）</td>\n</tr>\n<tr>\n<td><code>-XX:+PrintGC</code> / <code>-Xlog:gc*</code></td>\n<td>开启 GC 日志输出</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>-XX:+ZProactive</code></td>\n<td>主动回收策略（在系统空闲时尝试回收）</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>-XX:ZCollectionInterval=&lt;秒&gt;</code></td>\n<td>主动回收之间的最小时间间隔（配合 ZProactive）</td>\n<td>默认值因版本而异</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ZGC-vs-G1-GC-vs-Parallel-GC-对比表\">ZGC vs G1 GC vs Parallel GC 对比表</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><strong>ZGC</strong></th>\n<th><strong>G1 GC</strong></th>\n<th><strong>Parallel GC</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>设计目标</strong></td>\n<td><strong>极低延迟</strong>，&lt;1ms 停顿</td>\n<td>平衡 <strong>低延迟</strong> 与 <strong>高吞吐</strong></td>\n<td><strong>高吞吐</strong>，最大化 CPU 使用</td>\n</tr>\n<tr>\n<td><strong>GC 停顿时间</strong></td>\n<td>&lt;1ms，堆大小增加不影响停顿时间</td>\n<td>几十到几百毫秒，堆越大停顿越明显</td>\n<td>停顿时间可能达到秒级，<strong>堆越大越明显</strong></td>\n</tr>\n<tr>\n<td><strong>堆大小支持</strong></td>\n<td>支持高达 <strong>16TB</strong>（JDK 15+）</td>\n<td>支持 <strong>最多 4TB</strong></td>\n<td>支持大堆，但停顿明显</td>\n</tr>\n<tr>\n<td><strong>是否分代</strong></td>\n<td>默认不分代（JDK 21+ 可开启 <code>-XX:+ZGenerational</code>）</td>\n<td>分代（新生代 + 老年代）</td>\n<td>分代（新生代 + 老年代）</td>\n</tr>\n<tr>\n<td><strong>并发回收</strong></td>\n<td>是，<strong>包括标记、压缩、引用处理都并发</strong></td>\n<td>部分并发，仍包含明显 Stop-The-World 阶段</td>\n<td>否，<strong>全部 Stop-The-World</strong></td>\n</tr>\n<tr>\n<td><strong>移动对象时是否停顿</strong></td>\n<td>否，使用读屏障并发转移对象</td>\n<td>是（通过复制区域）</td>\n<td>是</td>\n</tr>\n<tr>\n<td><strong>实现机制</strong></td>\n<td>标记-重定位，基于读屏障</td>\n<td>Region 分区 + 标记-复制 + Mixed GC</td>\n<td>标记-复制（新生代）、标记-整理（老年代）</td>\n</tr>\n<tr>\n<td><strong>吞吐能力</strong></td>\n<td>中高</td>\n<td>高</td>\n<td><strong>最高</strong></td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>低延迟系统，如金融、交易、推荐等实时应用</td>\n<td>通用后台系统、Web 服务等</td>\n<td>批处理、数据计算、日志分析等不敏感于停顿的系统</td>\n</tr>\n<tr>\n<td><strong>默认启用</strong></td>\n<td>否，需指定 <code>-XX:+UseZGC</code></td>\n<td>JDK 9+ 默认 GC</td>\n<td>JDK 8 及以前默认 GC</td>\n</tr>\n<tr>\n<td><strong>调优复杂度</strong></td>\n<td>低，大多数参数可省略</td>\n<td>中，需要设置目标停顿时间等</td>\n<td>高，需要精细配置 Eden/Survivor 等比例</td>\n</tr>\n<tr>\n<td><strong>GC 日志配置方式</strong></td>\n<td>统一日志格式：<code>-Xlog:gc*</code>（JDK 9+）</td>\n<td>支持传统的 <code>-XX:+PrintGCDetails</code> 和 <code>-Xlog:gc*</code> 日志输出</td>\n<td>主要使用旧参数：<code>-XX:+PrintGCDetails</code> 等</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>ZGC 吞吐能力较弱的原因</strong></em></p>\n<table>\n<thead>\n<tr>\n<th>原因</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1. 并发阶段代价较高</strong></td>\n<td>ZGC 几乎所有的 GC 工作（包括标记、整理、引用处理、转移对象）都在与应用线程并发执行。虽然减少了停顿，但这些 GC 线程与业务线程共享 CPU 资源，<strong>增加了 CPU 上下文切换和缓存竞争</strong>，从而影响业务线程的执行效率。</td>\n</tr>\n<tr>\n<td><strong>2. 读屏障开销</strong></td>\n<td>ZGC 依赖<strong>着色指针和读屏障（load barrier）机制</strong>来跟踪对象引用状态，支持并发转移。虽然非常高效，但仍比传统 GC 的普通读写路径慢一些，在高频访问对象场景下会带来一定 CPU 开销。</td>\n</tr>\n<tr>\n<td><strong>3. 对硬件依赖高，调度保守</strong></td>\n<td>为了实现“&lt;1ms 停顿”的目标，ZGC 会选择更保守的调度策略（如避免并发线程使用过多 CPU），而不会像 Parallel GC 那样“榨干”所有核心资源。</td>\n</tr>\n<tr>\n<td><strong>4. 内存开销更高</strong></td>\n<td>为了支持并发压缩和转移，ZGC 通常需要为每个对象保留元数据和更多的转移空间（即“浮动垃圾”区域），这可能导致<strong>频繁的 GC 周期</strong>，影响吞吐。</td>\n</tr>\n<tr>\n<td><strong>5. 设计目标非吞吐优先</strong></td>\n<td>ZGC 的首要目标是<strong>低延迟而非最大吞吐</strong>。与 Parallel GC（以吞吐为核心）设计目标不同，ZGC 更适合场景为“对延迟敏感但吞吐可接受”的系统。</td>\n</tr>\n</tbody>\n</table>\n<p>最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。<br>\n另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！<br>\n也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>\n<p>ZGC 吞吐弱，不是因为技术落后，而是因为它主动选择在低延迟和高吞吐之间偏向了低延迟。<br>\n在对响应时间要求极高的系统中，它是非常合适的选择。<br>\n但如果你的目标是压榨机器性能跑批处理、日志分析这类吞吐导向型任务，Parallel GC 或 G1 会更合适。</p>\n</div>\n<h2 id=\"内存溢出-OutOfMemoryError，简称-OOM\">内存溢出(OutOfMemoryError，简称 OOM)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JVM 常见内存溢出类型汇总表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>溢出类型</th>\n<th>异常信息</th>\n<th>触发原因/描述</th>\n<th>相关参数和建议配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>堆内存溢出</strong></td>\n<td><code>java.lang.OutOfMemoryError: Java heap space</code></td>\n<td>- 创建大量对象，堆空间不足<br>- 内存泄漏：对象不再使用却有强引用<br>- 老年代对象太多无法晋升</td>\n<td><code>-Xms</code> / <code>-Xmx</code> 设置堆大小</td>\n</tr>\n<tr>\n<td><strong>栈溢出（递归）</strong></td>\n<td><code>java.lang.StackOverflowError</code></td>\n<td>- 方法无限递归或递归层级太深</td>\n<td><code>-Xss</code> 设置线程栈大小</td>\n</tr>\n<tr>\n<td><strong>无法创建新线程</strong></td>\n<td><code>java.lang.OutOfMemoryError: unable to create new native thread</code></td>\n<td>- 创建线程过多（如线程池配置过大）<br>- 系统或 JVM native 线程资源耗尽</td>\n<td>控制线程池大小，避免无限新建线程</td>\n</tr>\n<tr>\n<td><strong>元空间溢出</strong></td>\n<td><code>java.lang.OutOfMemoryError: Metaspace</code></td>\n<td>- 动态加载类过多（如使用 CGLIB、JSP 动态生成类）<br>- 类无法卸载（如 ClassLoader 泄漏）</td>\n<td><code>-XX:MetaspaceSize</code> / <code>-XX:MaxMetaspaceSize</code></td>\n</tr>\n<tr>\n<td><strong>直接内存溢出</strong></td>\n<td><code>java.lang.OutOfMemoryError: Direct buffer memory</code></td>\n<td>- 使用 <code>ByteBuffer.allocateDirect()</code> 分配大量直接内存<br>- Netty 等框架默认使用直接内存</td>\n<td><code>-XX:MaxDirectMemorySize</code></td>\n</tr>\n<tr>\n<td><strong>GC 开销过高</strong></td>\n<td><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code></td>\n<td>- JVM 花费 &gt;98% 的时间 GC 但回收 &lt;2% 的内存，认为进入“GC 死循环”</td>\n<td>分析 GC 日志、优化堆设置</td>\n</tr>\n<tr>\n<td><strong>类卸载失败（内存泄漏）</strong></td>\n<td>（不一定报错，但可能导致 Metaspace OOM）</td>\n<td>- Web 容器频繁部署热更新 WAR 包时，ClassLoader 无法卸载，导致类永久驻留</td>\n<td>优化 ClassLoader 管理，使用内存分析工具</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>堆快照(堆转储)文件分析</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>\n<td>OOM 时生成堆转储文件 ,建议生产环境开启</td>\n</tr>\n<tr>\n<td><code>-XX:HeapDumpPath=xxx.hprof</code></td>\n<td>指定堆转储文件保存路径 <br> 默认保存在当前目录</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用分析工具与命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>工具/命令</th>\n<th>简介与功能</th>\n<th>使用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>MAT（Memory Analyzer Tool）</strong></td>\n<td>Eclipse 出品的强大图形工具，支持泄漏分析、对象引用链分析、内存占用统计等</td>\n<td>下载地址：<br><a href=\"https://www.eclipse.org/mat/\">https://www.eclipse.org/mat/</a><br>打开后直接导入 <code>.hprof</code> 文件即可分析</td>\n</tr>\n<tr>\n<td><strong>VisualVM</strong></td>\n<td>官方可视化 JVM 监控工具，支持实时分析、GC 查看、线程状态与堆转储查看</td>\n<td>附带于 JDK（或单独安装），打开 <code>.hprof</code> 文件进行可视化分析</td>\n</tr>\n<tr>\n<td><strong>JProfiler</strong></td>\n<td>商业级 Java 性能分析工具，提供堆分析、CPU 分析、线程分析等全套功能</td>\n<td>支持打开 <code>.hprof</code> 文件，也可在运行时配合使用（需付费或试用）</td>\n</tr>\n<tr>\n<td><strong>YourKit</strong></td>\n<td>商业性能分析工具，界面友好，支持丰富的分析功能</td>\n<td>支持堆分析，适合内存泄漏排查</td>\n</tr>\n<tr>\n<td><strong>jhat</strong>（过时）</td>\n<td>JDK 附带的旧工具，用于分析 <code>.hprof</code> 文件，开启 Web 界面查看（已废弃）</td>\n<td>命令：<code>jhat heapdump.hprof</code>，浏览器访问 <code>http://localhost:7000</code>（JDK 8 及以下）</td>\n</tr>\n<tr>\n<td><strong>jmap</strong></td>\n<td>用于生成堆转储文件或查看堆对象统计信息（<strong>不是分析工具本身</strong>）</td>\n<td>命令：<code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code> 生成转储；配合 MAT 使用</td>\n</tr>\n<tr>\n<td><strong>jcmd</strong></td>\n<td>更现代的诊断命令工具，可生成 heap dump、执行 GC、打印 VM 状态等</td>\n<td>命令：<code>jcmd &lt;pid&gt; GC.heap_dump heap.hprof</code></td>\n</tr>\n<tr>\n<td><strong><a href=\"http://GCEasy.io\">GCEasy.io</a></strong></td>\n<td>在线分析工具，支持 <code>.hprof</code> 文件和 GC 日志上传分析</td>\n<td>网站：<a href=\"https://gceasy.io\">https://gceasy.io</a></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>GC日志相关参数(JDK1.8及以下)</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-XX:+PrintGC</code></td>\n<td>打印基本 GC 信息（建议配合 <code>-XX:+PrintGCDetails</code> 使用）,与<code>-verbose:gc</code>等价</td>\n</tr>\n<tr>\n<td><code>-XX:+PrintGCDetails</code></td>\n<td>打印详细的 GC 日志信息（如各区域使用情况、对象分配、晋升等）</td>\n</tr>\n<tr>\n<td><code>-XX:+PrintGCDateStamps</code></td>\n<td>在 GC 日志中添加日期时间戳</td>\n</tr>\n<tr>\n<td><code>-XX:+PrintGCTimeStamps</code></td>\n<td>在 GC 日志中添加 JVM 启动以来的时间戳</td>\n</tr>\n<tr>\n<td><code>-Xloggc:/var/log/myapp/gc.log</code></td>\n<td>将 GC 日志输出到指定文件</td>\n</tr>\n<tr>\n<td><code>-XX:+UseGCLogFileRotation</code></td>\n<td>启用 GC 日志文件轮转（适用于大规模系统的 GC 日志管理）</td>\n</tr>\n<tr>\n<td><code>-XX:NumberOfGCLogFiles=5</code></td>\n<td>最多保留 5 个 GC 日志历史文件</td>\n</tr>\n<tr>\n<td><code>-XX:GCLogFileSize=10M</code></td>\n<td>每个 GC 日志文件最大为 10MB</td>\n</tr>\n<tr>\n<td><code>-XX:+PrintGCCause</code></td>\n<td>打印 GC 的触发原因（如 Minor GC、System.gc() 等）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>GC日志相关参数(JDK9+)</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>-Xlog</code> 是用于配置 JVM 日志记录的参数，它是从 JDK 9 开始引入的统一日志框架（Unified Logging）的一部分。</li>\n<li class=\"lvl-6\">通过 -Xlog 选项，你可以控制日志的 标签（tags）、输出级别（level）、输出位置（output） 等内容。</li>\n<li class=\"lvl-6\">基本格式</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xlog[:[tag1[,tag2...]][[:level][:[output][:[decorators][:rotation]]]]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">常见 Tags（标签）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>标签</th>\n<th>含义</th>\n<th>用途示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>类加载</strong></td>\n<td><code>classload</code></td>\n<td>JVM 类加载活动的总体信息</td>\n<td>观察类加载失败或重复加载</td>\n</tr>\n<tr>\n<td></td>\n<td><code>class+load</code></td>\n<td>显示每个类加载过程细节</td>\n<td>定位类加载异常、热加载分析</td>\n</tr>\n<tr>\n<td></td>\n<td><code>class+unload</code></td>\n<td>记录类卸载事件</td>\n<td>分析类卸载时机或内存释放情况</td>\n</tr>\n<tr>\n<td><strong>垃圾回收</strong></td>\n<td><code>gc</code></td>\n<td>总体 GC 活动信息</td>\n<td>GC 调优入门使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+start</code></td>\n<td>GC 事件开始时间与类型</td>\n<td>查看 GC 频率与触发点</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+heap</code></td>\n<td>GC 前后的堆使用情况</td>\n<td>分析堆使用与分区占比</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+phases</code></td>\n<td>GC 内部阶段细节</td>\n<td>G1/ZGC 等调试用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+age</code></td>\n<td>年龄分布情况</td>\n<td>判断对象晋升路径、老年代压力</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+ergo</code></td>\n<td>GC 的自适应调整决策</td>\n<td>查看线程、堆大小自动调整逻辑</td>\n</tr>\n<tr>\n<td><strong>JIT 编译</strong></td>\n<td><code>jit</code></td>\n<td>JIT 编译日志入口</td>\n<td>性能热点方法分析</td>\n</tr>\n<tr>\n<td></td>\n<td><code>compiler</code></td>\n<td>显示方法编译、时间等</td>\n<td>判断是否有方法未被优化</td>\n</tr>\n<tr>\n<td></td>\n<td><code>codecache</code></td>\n<td>已编译代码存储区使用情况</td>\n<td>判断是否达到缓存上限</td>\n</tr>\n<tr>\n<td></td>\n<td><code>nmethod</code></td>\n<td>JIT 生成的 native 方法生命周期</td>\n<td>观察 native 代码生成与卸载</td>\n</tr>\n<tr>\n<td><strong>内存</strong></td>\n<td><code>memory</code></td>\n<td>总体内存使用情况</td>\n<td>诊断内存泄漏或溢出</td>\n</tr>\n<tr>\n<td></td>\n<td><code>gc+heap</code></td>\n<td>堆结构与占用情况</td>\n<td>与 GC 联合分析使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>os+memory</code></td>\n<td>JVM 与操作系统间的内存交互</td>\n<td>判断是否系统层内存申请失败</td>\n</tr>\n<tr>\n<td><strong>线程</strong></td>\n<td><code>thread</code></td>\n<td>线程的创建、终止、状态变化</td>\n<td>线程泄漏或频繁创建排查</td>\n</tr>\n<tr>\n<td></td>\n<td><code>safepoint</code></td>\n<td>JVM 进入/退出 safepoint 的信息</td>\n<td>分析 STW 停顿时间与频率</td>\n</tr>\n<tr>\n<td><strong>锁与同步</strong></td>\n<td><code>synchronization</code></td>\n<td>锁竞争、获取和释放信息</td>\n<td>分析性能瓶颈中的锁争用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>monitorinflation</code></td>\n<td>轻量级锁升级为重量级锁过程</td>\n<td>排查锁膨胀导致的延迟问题</td>\n</tr>\n<tr>\n<td><strong>操作系统交互</strong></td>\n<td><code>os</code></td>\n<td>JVM 与操作系统交互日志</td>\n<td>常规系统资源请求信息</td>\n</tr>\n<tr>\n<td></td>\n<td><code>os+thread</code></td>\n<td>OS 层级线程管理信息</td>\n<td>高并发时线程绑定与调度分析</td>\n</tr>\n<tr>\n<td></td>\n<td><code>os+cpu</code></td>\n<td>CPU 使用与分布情况</td>\n<td>排查高 CPU 使用的问题</td>\n</tr>\n<tr>\n<td><strong>类元数据</strong></td>\n<td><code>metaspace</code></td>\n<td>元空间内存使用与变化</td>\n<td>排查 Metaspace OOM</td>\n</tr>\n<tr>\n<td></td>\n<td><code>cds</code></td>\n<td>类共享数据（CDS）日志</td>\n<td>分析类加载加速是否生效</td>\n</tr>\n<tr>\n<td><strong>安全</strong></td>\n<td><code>security</code></td>\n<td>安全相关操作日志</td>\n<td>权限检查失败、密钥加载等调试</td>\n</tr>\n<tr>\n<td></td>\n<td><code>module</code></td>\n<td>模块系统（JPMS）相关日志</td>\n<td>模块访问控制失败分析</td>\n</tr>\n<tr>\n<td><strong>其他</strong></td>\n<td><code>start</code></td>\n<td>JVM 启动流程日志</td>\n<td>启动阶段慢、出错时使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>init</code></td>\n<td>各子系统初始化过程</td>\n<td>定位子系统启动顺序与异常</td>\n</tr>\n<tr>\n<td></td>\n<td><code>jni</code></td>\n<td>Java 调用 native 方法日志</td>\n<td>JNI 崩溃、性能问题分析</td>\n</tr>\n<tr>\n<td></td>\n<td><code>classpath</code></td>\n<td>类路径加载详情</td>\n<td>类找不到、路径冲突等问题排查</td>\n</tr>\n<tr>\n<td></td>\n<td><code>exceptions</code></td>\n<td>异常信息及堆栈打印</td>\n<td>捕获未处理异常、频繁抛错分析</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>Level（级别）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>等级</th>\n<th>含义说明</th>\n<th>用途示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>off</code></td>\n<td>关闭日志记录</td>\n<td>完全禁用指定标签的日志输出</td>\n</tr>\n<tr>\n<td><code>error</code></td>\n<td>严重错误，仅记录影响系统运行的错误信息</td>\n<td>捕获崩溃、严重故障</td>\n</tr>\n<tr>\n<td><code>warning</code></td>\n<td>潜在问题，可能影响稳定性</td>\n<td>记录可能的内存、配置问题</td>\n</tr>\n<tr>\n<td><code>info</code></td>\n<td>常规信息（默认级别）</td>\n<td>日常运行日志，如 GC 次数</td>\n</tr>\n<tr>\n<td><code>debug</code></td>\n<td>更详细的调试信息，适用于问题诊断</td>\n<td>跟踪行为变化或代码路径</td>\n</tr>\n<tr>\n<td><code>trace</code></td>\n<td>最详细的信息，记录几乎所有细节</td>\n<td>深度调试，如方法级别跟踪</td>\n</tr>\n<tr>\n<td><code>all</code></td>\n<td>打印所有级别的日志（包括 trace 及以上）</td>\n<td>全量日志输出，用于完全监控</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>Output（输出位置）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>输出位置</th>\n<th>含义说明</th>\n<th>示例用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stdout</code></td>\n<td>标准输出（默认）</td>\n<td><code>-Xlog:gc=info:stdout</code></td>\n</tr>\n<tr>\n<td><code>stderr</code></td>\n<td>标准错误输出</td>\n<td><code>-Xlog:gc=info:stderr</code></td>\n</tr>\n<tr>\n<td><code>file=路径</code></td>\n<td>输出到指定文件路径（自动创建文件）</td>\n<td><code>-Xlog:gc:file=gc.log</code></td>\n</tr>\n<tr>\n<td>多个输出用逗号分隔</td>\n<td>可同时输出到多个位置</td>\n<td><code>-Xlog:gc:file=gc.log,stdout</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>Decorators（装饰器）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>装饰器</th>\n<th>含义说明</th>\n<th>示例输出片段（含该装饰器时）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>time</code></td>\n<td>显示当前系统时间（wall-clock time）</td>\n<td><code>2025-05-16T10:45:12.123+0800</code></td>\n</tr>\n<tr>\n<td><code>uptime</code></td>\n<td>显示 JVM 启动以来的运行时间（毫秒）</td>\n<td><code>5.123s</code>（表示已运行 5.123 秒）</td>\n</tr>\n<tr>\n<td><code>level</code></td>\n<td>显示日志级别（如 info, warning 等）</td>\n<td><code>[info]</code>, <code>[debug]</code></td>\n</tr>\n<tr>\n<td><code>tags</code></td>\n<td>显示日志标签</td>\n<td><code>[gc]</code>, <code>[class,load]</code></td>\n</tr>\n<tr>\n<td><code>tid</code></td>\n<td>显示线程 ID</td>\n<td><code>tid=0x00007fddc4012800</code></td>\n</tr>\n<tr>\n<td><code>hostname</code></td>\n<td>显示主机名</td>\n<td><code>host=example.local</code></td>\n</tr>\n<tr>\n<td><code>pid</code></td>\n<td>显示当前 JVM 进程 ID</td>\n<td><code>pid=12345</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>Rotation (日志轮转设置)</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>设置参数</th>\n<th>含义说明</th>\n<th>示例值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>filecount=n</code></td>\n<td>保留的日志文件数量（最大文件轮转数）</td>\n<td><code>filecount=5</code></td>\n</tr>\n<tr>\n<td><code>filesize=n</code></td>\n<td>单个日志文件的最大大小（支持单位：k/m/g）</td>\n<td><code>filesize=10m</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>示例：</p>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xlog:gc*:file=/var/log/app/gc.log:time,<span class=\"built_in\">uptime</span>,level,tags:filecount=5,filesize=20M</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>项</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tag</code></td>\n<td><code>gc*</code></td>\n<td>匹配所有以 <code>gc</code> 开头的标签（如 <code>gc+heap</code> 等）</td>\n</tr>\n<tr>\n<td><code>level</code></td>\n<td><em>省略</em></td>\n<td>默认是 <code>info</code></td>\n</tr>\n<tr>\n<td><code>output</code></td>\n<td><code>file=/var/log/app/gc.log</code></td>\n<td>日志写入该文件</td>\n</tr>\n<tr>\n<td><code>decorators</code></td>\n<td><code>time,uptime,level,tags</code></td>\n<td>日志前缀包含时间、启动时间、日志级别、标签</td>\n</tr>\n<tr>\n<td><code>rotation</code></td>\n<td><code>filecount=5,filesize=20M</code></td>\n<td>最多保留 5 个日志文件，单个文件最大 20MB</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>日志文件中可以使用变量</p>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xlog:gc*:file=gc_%p_%t.log</span><br></pre></td></tr></table></figure>\n<p><strong>常用变量表</strong></p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%p</td>\n<td>进程ID（Process ID）</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>时间戳（代表日志文件创建时的时间戳）</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>主机名（Hostname）</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>序列号，从0开始，每创建新文件加1</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>唯一标识符，用于解决文件名冲突</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>当多个JVM进程使用相同的文件名模式时的区分计数器</td>\n</tr>\n</tbody>\n</table>\n<p><strong>时间相关变量表</strong></p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%Y</td>\n<td>年（Year）</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月（Month）</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>日（Day）</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>小时（Hour）</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>分钟（Minute）</td>\n</tr>\n<tr>\n<td>%S</td>\n<td>秒（Second）</td>\n</tr>\n</tbody>\n</table>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础配置</span></span><br><span class=\"line\">-Xlog:gc*:file=gc_%p_%Y%m%d_%H%M%S.<span class=\"built_in\">log</span>:time,<span class=\"built_in\">uptime</span>,level,tags:filecount=5,filesize=20M</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 详细GC日志配置</span></span><br><span class=\"line\">-Xlog:gc*=debug:file=gc_%p_%t.log:time,<span class=\"built_in\">uptime</span>,level,tags:filecount=10,filesize=50M</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多目标输出</span></span><br><span class=\"line\">-Xlog:gc*=info:file=gc.log::filecount=5,filesize=20M -Xlog:gc*=debug:file=gc_detailed.log</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>对于GC日志的分析<br>\n人工分析还是太复杂了，可以使用<a href=\"https://gceasy.io\">GCEasy.io</a>，每个月免费5次。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍JVM的内存模型与垃圾回收机制 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档 JVM虚拟机结构(HotSpot) 设置内存分配示例 1234# jdk1.8+java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=128M ‐XX:MaxMetaspaceSize=256M ‐jar server.jar# jdk1.6/1.7java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:PermSize=128M ‐XX:MaxPermSize=256M ‐jar server.jar 各参数含义与默认值（针对 JDK 1.8） 参数 含义说明 默认值（JDK 1.8） -Xms2048M 初始堆大小，即 JVM 启动时分配的堆内存大小（这里是 2GB） 物理内存的 1/64（最小 1MB），推荐配置为与 -Xmx 一致 -Xmx2048M 最大堆内存大小，JVM 允许分配的最大堆内存 物理内存的 1/4（受限于 32位/64位） -Xmn1024M 新生代大小（Eden + Survivor）为 1GB 未显式指定时，通常占堆的 1/3 左右 -Xss512K 每个线程的栈大小（Thread Stack Size），这里设置为 512KB 1MB（64位系统）或 512KB（32位系统） -XX:MetaspaceSize=256M 元空间初始大小（用于加载类的元数据，不再使用 PermGen），达到该值后，JVM 会触发一次 GC，空间不够时会进行扩容，最大到 MaxMetaspaceSize 默认 21MB（客户端）或 16MB（服务器端），为避免频繁扩容导致的GC，可以设置的稍微大一些，比如MaxMetaspaceSize的一半，或干脆与MaxMetaspaceSize一样大 -XX:MaxMetaspaceSize=256M 元空间最大大小，接近设置值时会触发 Full GC 无限制（默认只受物理内存约束） ，推荐配置一个合适的数值，比如8G的内存可以配置为256M 类装载子系统（Class Loading Subsystem） 类装载子系统负责将 .class 文件加载到 JVM 中，并进行解析、验证、初始化等过程。 加载过程的几个阶段： 阶段 说明 加载（Loading） 将 .class 文件读取为二进制数据，构造 Class 对象 验证（Verification） 确保字节码文件格式正确、安全合法（防止恶意代码） 准备（Preparation） 为类的静态变量分配内存，并设置默认初始值 解析（Resolution） 将常量池中的符号引用替换为直接引用（方法、字段等） 初始化（Initialization） 执行 &lt;clinit&gt; 静态初始化方法，对静态变量赋初始值 类加载器（ClassLoader）体系结构：详细参考 JVM 之 类加载器 类加载器名称 加载内容 说明 引导类加载器（Bootstrap ClassLoader） Java 核心类库（如 java.lang.*） 由 JVM 自身实现，用本地代码实现，无法直接访问 扩展类加载器（Extension ClassLoader） JAVA_HOME/jre/lib/ext 目录下的类 加载标准扩展类库 应用类加载器（Application ClassLoader） 用户应用类路径（CLASSPATH 指定的目录） 最常用，加载大多数应用代码 自定义类加载器（Custom ClassLoader） 用户手动实现的类加载器 可以打破双亲委派机制，实现热加载、加密类加载等 类加载采用 双亲委派模型：请求会先向父加载器委托，只有在父加载器加载失败时才尝试自身加载。 字节码执行引擎（Execution Engine） 字节码执行引擎负责将 Java 字节码解释或编译为机器代码，并在底层平台上执行。 执行引擎的核心模块 组件名称 作用说明 关键特性 解释器（Interpreter） 将字节码逐条解释执行 启动快，适合冷代码（非热点代码），执行效率相对较低 即时编译器（JIT Compiler） 将热点代码编译为本地机器码，提高执行效率 包含 C1（Client）和 C2（Server）两种，支持优化如：方法内联、逃逸分析、循环展开等 垃圾收集器（Garbage Collector, GC） 自动内存管理，负责对象生命周期的回收 常见算法包括：Serial、Parallel、CMS、G1、ZGC（低延迟）等，根据不同场景选择 本地接口（Native Interface） 支持 Java 与本地语言（如 C/C++）的互操作 通过 JNI（Java Native Interface）实现，调用底层操作系统或第三方库功能 即时编译器（JIT Compiler） JVM 的 HotSpot 编译器有两个主要组件： C1 编译器（Client 编译器）：轻量、快速编译，优化少。 C2 编译器（Server 编译器）：优化高级，耗时长，适合长时间运行的热点代码。 在 64 位 JDK 中，默认就是 -server 模式 (C2 编译器) ，不再支持 -client (C1 编译器)。 在 32 位 JDK 中，根据平台和启动方式，可能会自动选择 -client 或 -server，也可以手动指定。 分层编译（Tiered Compilation） 允许 JVM 在一开始用 C1 编译器快速编译字节码，后续热点代码再交给 C2 编译器进行更高级优化。这样结合了 -client（快启动）和 -server（高性能）的优点。TieredCompilation参数控制是否开启分层编译，默认开启。 -XX:TieredStopAtLeve=&lt;level&gt; 参数控制 编译器最多使用哪一层优化级别。它的取值如下，值越低启动越快，但优化越少。 值 含义 0 仅解释执行（不开启编译器） 1 只使用 C1 编译器的第一级（最少优化） 2 C1 第二级，略多优化 3 C1 第三级，更优化 4 启用 C2 编译器（完全优化，默认值） JVM 内存模型（Java Memory Model，JMM） JMM 是 Java 虚拟机规范中定义的一种 抽象内存模型，它决定了多线程程序中变量的读写可见性、有序性和原子性。同时，JVM 在物理层也有一个实际的内存结构，称为运行时数据区域（Runtime Data Areas），这两个可以结合理解。 JMM 的主要目标 保证多线程环境下的数据一致性 指导 JVM 和 CPU 的内存交互行为（如重排序、缓存） 实际运行时内存结构如下： 内存区域 说明 📌 程序计数器（PC） 每个线程私有，记录当前执行的字节码指令地址 📌 Java 线程栈 每个线程私有，方法调用时用于存储局部变量、操作数栈等 📌 本地方法栈 与虚拟机栈类似，用于 native 方法 📌 堆（Heap） 所有线程共享，存储对象实例、数组等，GC 的主要区域 📌 方法区（或元空间） 所有线程共享，存储类信息、静态变量、常量池等（JDK8 后称为 Metaspace） 垃圾回收器 垃圾回收器负责自动管理内存，回收不再使用的对象，避免内存泄漏和溢出。 什么是垃圾 内存中没有被（线程栈变量，静态变量，常量池，JNI指针）引用的地址就是垃圾 可达性分析算法：是现代 JVM 判断一个对象是否“还活着”的主要算法。 1234基本思想：从一组称为 “GC Roots” 的对象出发，沿着对象之间的引用链向下搜索。如果某个对象 可以从 GC Roots 追踪到，就认为它是 “可达” 的（Alive）。否则就认为是 “不可达” 的（Garbage），可以被回收。 在 JVM 中，GC Roots 是一些 始终可用的、不会被垃圾回收的引用起点，主要包括： GC Roots 来源 说明 当前线程栈中的引用（局部变量表） 各个线程正在调用的方法中的局部变量、参数等 静态字段引用 类的静态字段引用的对象 JNI 引用（Native 方法引用） Java 本地方法中引用的对象 常量引用池中的对象 字符串常量等可能持有对象引用 活动线程对象 线程自身在 GC 时不会被回收 JVM 内部结构（如系统类加载器等） JVM 关键系统对象 垃圾回收器种类： 左边6种叫分代模型，右边的4种叫分区模型 分代模型（Generational Model） 堆内存划分为： 年轻代（Young Generation）：存放新创建的对象，分为 Eden 和 Survivor 区。 老年代（Old Generation）：存放经过多次 GC 后仍然存活的对象。 分区模型（Region-based Model） 分区模型（如 G1、ZGC、Shenandoah）不再严格按照代划分内存，而是把堆划分为多个 大小相同的 Region。每个 Region 可以在运行时被动态标记为 Eden、Survivor 或 Old。 分代模型中，上面3个是新生代垃圾回收器，下面3个是老年代垃圾回收器，可以交叉配对（见上图虚线），但最常用是上下两两配对。 CMS即可以作为新生代垃圾回收器，也可以作为老年代垃圾回收器。 EpsilonGC，是一个特殊的垃圾回收器，它不回收任何对象，只负责最终记录，做测试用的。 目前最先进的模型是 ZGC，jkd11开始支持，但直到JDK16才比较完善，目前非默认配置，需要手动配置。其与Redhat出品的 Shenandoah 是竞争关系。 常见垃圾回收器及其分类、JDK版本 垃圾回收器 所属模型 说明 首次出现 JDK 版本 启用命令（JVM 参数） 适合的堆内存大小 Serial 分代模型 单线程，新生代和老年代都使用 Serial，适用于小堆内存, 已弃用 JDK 1.2 -XX:+UseSerialGC 💾 小于 1GB ParNew 分代模型 Serial 的多线程版本，仅用于 CMS 新生代, JDK11已弃用 JDK 1.4 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 💾 1GB ~ 4GB Parallel（吞吐量 GC） 分代模型 多线程 GC，适合吞吐量优先的应用场景 JDK 1.4 -XX:+UseParallelGC（新生代）-XX:+UseParallelOldGC（老年代） 💾 2GB ~ 8GB CMS（Concurrent Mark Sweep） 分代模型 老年代并发标记-清除，低延迟，但存在碎片，JDK14已弃用 JDK 1.4 -XX:+UseConcMarkSweepGC 💾 2GB ~ 8GB G1（Garbage First） 分区模型 将堆划分为 Region，逻辑分代，支持并发压缩，平衡延迟与吞吐 JDK 7u4（正式） -XX:+UseG1GC 💾 4GB ~ 数十 GB ZGC（Z Garbage Collector） 分区模型 Region 弹性大小，支持超大堆，低延迟（&lt;10ms 停顿） JDK 11（实验），JDK 15（正式） -XX:+UseZGC 💾 8GB ~ 数 TB（超大堆） Shenandoah 分区模型 红帽主导，低延迟，并发回收与并发压缩 JDK 12（实验），JDK 15（正式） -XX:+UseShenandoahGC 💾 2GB ~ 数十 GB 对于 CMS，启用后会自动使用 ParNew 作为新生代回收器（除非显式禁止）。 对于 Parallel GC 启用 -XX:+UseParallelGC（新生代）会自动启用 -XX:+UseParallelOldGC（老年代）。 对于ZGC，jdk15以前最大支持4T内存，之后最大支持16T内存。 各版本默认垃圾回收器及推荐配置（JDK 1.6 起） JDK 版本 默认 GC 建议使用 GC（按场景分类） JDK 1.6 Serial / Parallel - 小型应用（如桌面程序）：-XX:+UseSerialGC - 中大型应用（吞吐量优先）：-XX:+UseParallelGC JDK 1.7 同上 同 JDK 1.6 JDK 1.8 Parallel - 吞吐优先：默认 -XX:+UseParallelGC - 响应优先：-XX:+UseConcMarkSweepGC（CMS） - 大堆 + 未来升级考虑：-XX:+UseG1GC（推荐） JDK 9-14 G1 GC - 一般默认即可：-XX:+UseG1GC（延迟与吞吐平衡） - 极端低延迟要求：升级到 JDK 11+ 使用 ZGC/Shenandoah JDK 15+ G1 GC（默认），ZGC / Shenandoah 可选 - 延迟敏感（在线服务、RT系统）：-XX:+UseZGC 或 -XX:+UseShenandoahGC - 吞吐为主：-XX:+UseParallelGC - 综合平衡：-XX:+UseG1GC（默认） 判断默认 GC 的方式 1java -XX:+PrintCommandLineFlags -version 垃圾回收算法 JVM 中常见垃圾回收算法汇总 算法名称 核心思想 适用阶段/区域 优缺点简述 标记-清除（Mark-Sweep） 标记出存活对象，清除未标记对象 老年代 简单高效，但会产生大量碎片，不适合连续内存分配 标记-整理（Mark-Compact） 标记后移动存活对象，整理碎片 老年代 消除碎片，代价是移动对象，适用于老年代压缩 复制算法（Copying） 将对象复制到另一块内存（如 Eden → Survivor） 新生代 高效率，适合回收大多数对象短命的新生代，但需要额外空间 分代回收（Generational） 将对象按生命周期划分（新生代/老年代） 整个堆结构 实用性强，结合不同算法应用于不同代，现代 GC 基础 分区回收（Region-based） 将堆划分为若干等大小的 Region 动态分配 整个堆（如 G1、ZGC） 更灵活，支持并发并行，减少 STW 停顿，适用于大堆、低延迟场景 增量回收（Incremental） 分阶段小步执行 GC 以减少单次停顿 某些并发/低延迟 GC 减少暂停时间，但整体效率可能降低 并发回收（Concurrent） 标记、清理等步骤与应用线程并发执行 CMS、G1、ZGC 等 停顿时间短，对响应时间要求高的系统友好 三色标记（Tri-color Marking） 并发标记算法的一种实现思想 CMS、G1、ZGC 等 白（待回收）、灰（已标记未扫描）、黑（已标记已扫描），避免“漏标”问题 SATB（Snapshot-At-The-Beginning） 并发标记的快照策略 G1、ZGC 保证在并发标记过程中不遗漏新引用，适合高并发场景 Lazy Compaction（延迟压缩） 不每次 GC 都压缩，视情况而定 G1 等 降低不必要的移动成本 对应关系：GC 回收器和底层算法 回收器 使用的算法组合 Serial 新生代：复制算法老年代：标记-整理 ParNew 新生代：复制算法（多线程） Parallel 新生代：复制算法老年代：标记-整理 CMS 新生代：ParNew（复制）老年代：标记-清除 + 三色标记 + 并发 G1 分区回收 + 三色标记 + SATB + Lazy Compaction ZGC 分区回收 + 并发标记 + SATB + Region Remapping Shenandoah 分区回收 + 并发标记 + 并发压缩 + 三色标记 1234567891011 ┌────────────────────────┐ │ 常见 GC 算法分类 │ └────────────────────────┘ │ ┌─────────────┴──────────────┐ │ │分代模型 分区模型 │ │ ┌─┴─────┐ ┌───┴─────┐复制 标记-清除 Region-based 并发 标记-整理 SATB / 三色标记 什么是 STW（Stop-The-World） STW（Stop-The-World） 指的是：在某些垃圾回收阶段，JVM 会暂停所有应用线程（也叫用户线程），让垃圾回收线程独占 CPU 执行 GC 逻辑。 你可以这样理解 STW JVM 会“按下暂停键”暂停所有正在运行的 Java 程序代码； 然后 专心进行 GC 的某些阶段（如标记、整理、复制等）； GC 完成后，才会“恢复运行”应用线程。 各 GC 中 STW 的存在情况 回收器 是否存在 STW？ 说明 Serial ✅ 是，全停顿，全阶段单线程 堆越大 STW 越长 Parallel ✅ 是，全停顿，多线程执行 GC 提高效率但仍会暂停 CMS ✅ 有，初始标记和最终重新标记是 STW 大部分阶段并发执行 G1 ✅ 有，但设计为尽可能缩短 STW 分阶段并发 + 并行处理 ZGC ✅ 极短（&lt;10ms） 仅个别阶段是 STW，几乎感知不到 Shenandoah ✅ 极短 高度并发，STW 时间也极短 为什么要关注 STW？ 在响应时间敏感型系统（如在线交易系统、游戏服务器、API 网关）中，长时间的 STW 会造成用户请求卡顿、超时。 因此，选择 低 STW 的 GC（如 G1、ZGC、Shenandoah） 对这类系统至关重要。 堆内存结构 不同的垃圾回收器决定了堆内存的结构不同，但总体上分为两种类型：分代模型和分区模型。 分代模型 Parallel 垃圾回收器 堆结构被划分为 Old Generation（老年代） 和 Young Generation（新生代） 两部分。 Young Generation 由 Eden 和 两个 Survivor 组成，其中 Eden 是一个连续的内存区域，Survivor 是一个非连续的内存区域。 默认情况下，Young Generation占堆内存的 1/3, Old Generation 占堆内存的 2/3。 默认情况下，Eden:S0:S1 = 8:1:1 ,如果希望为 4:1:1，使用 -XX:SurvivorRatio=4，但实际上这个比例并不是固定的，而是由jvm基于情况自动变化的，因为JVM默认开启了这个参数-XX:+UseAdaptiveSizePolicy，如果希望固定这个比例，可以设置为 -XX:-UseAdaptiveSizePolicy来关闭这个配置。 默认情况下，对象最多经历15次Minor GC后进入老年代，可以通过 -XX:MaxTenuringThreshold=n 设置。 区域 说明 Eden 对象首次创建的区域，大部分对象在这里创建并很快被回收 S0/S1 Survivor 区域：两个交替使用的缓冲区（From 和 To），用于拷贝存活对象 Old 老年代：存活次数多、生命周期长的对象会从新生代晋升到老年代，回收频率低 对象内存分配图解(简化) 12345678910111213创建对象 ↓进入 Eden 区（新生代） ↓ Eden 区满第一次 Minor GC（存活对象[Eden]复制到 S0） ↓ Eden 区满 或 S0 区满第二次 Minor GC（存活对象[Eden和S0]复制到 S1，年龄 +1） ↓ Eden 区满 或 S1 区满第三次 Minor GC（存活对象[Eden和S1]复制到 S0，年龄 +1） ↓…… S0/S1 交替，年龄达到阈值（如 15） ↓ 还没有被回收晋升到 Old 区（老年代），等待Old区满 触发 Full GC 大对象直接进入老年代 大对象就是需要大量连续内存空间的对象（比如：字符串、数组），如果对象很大（如超过 Eden 区大小，或是超过 Survivor 区大小），可能直接分配到老年代 也可以通过 -XX:PretenureSizeThreshold=&lt;大小，单位字节&gt; 控制超过一定大小的对象是否直接分配到老年代（Old Generation），跳过新生代（Eden），以避免大对象频繁在年轻代造成 GC 压力。这个参数只在 Serial 和ParNew两个收集器下有效。 对象动态年龄判断 对象在Survivor区来回移动时，如果这批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了， 例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。 对象动态年龄判断机制一般是在minor gc之后触发的。 对象逃逸分析 如果对象很小，且只在方法内部使用，并没有被外部引用，则其有可能直接分配到栈内存，而不进入堆内存 JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过标量替换优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis) 标量替换 通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。 开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。 标量与聚合量 标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等）， 标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。 Parallel 垃圾回收器（Parallel GC） 的工作方式 Parallel GC 是多线程垃圾回收器，可以通过 -XX:ParallelGCThreads 来设置GC线程数量。 当 Parallel GC 被触发（例如 Minor GC 或 Full GC）时，所有用户线程 被完全暂停（Stop-The-World, STW） Parallel GC 参数配置表（吞吐量优先 GC） 参数名 说明 默认值（如未特别说明） -XX:+UseParallelGC 开启 Parallel GC，用于新生代收集 - -XX:+UseParallelOldGC 开启老年代并行收集（Parallel Old） - -XX:ParallelGCThreads 垃圾回收时的并行线程数（与 CPU 数量相关） 根据硬件自动配置 -XX:MaxGCPauseMillis 设置 GC 最大暂停时间目标（影响内存分配策略） 一个非常大的值，可以认为无限制（建议按需设置） -XX:GCTimeRatio 设置 GC 时间与应用运行时间的比值（0~100）值越小，GC 越频繁，值越大 GC 越少 99（表示 1% 用于 GC，99% 用于应用） -XX:+UseAdaptiveSizePolicy 启用自适应 GC 策略（根据运行状况自动调整各区域大小） 默认开启 -XX:SurvivorRatio Eden 与 Survivor 的内存比例（如 8 表示 Eden:S0:S1 = 8:1:1） 8 -XX:InitialTenuringThreshold 对象晋升到老年代的初始年龄（会随运行动态调整） 7 -XX:MaxTenuringThreshold 晋升到老年代的最大年龄（对象在 Survivor 区经历几次 GC） 15 -XX:PretenureSizeThreshold 设置大对象阈值，超过该大小的对象直接分配到老年代 0（即禁用） -XX:+ScavengeBeforeFullGC 在 Full GC 之前是否先执行一次 Minor GC true启 -XX:+UseFastAccessorMethods 优化原始类型的 get/set 方法性能 false启 -XX:+AlwaysPreTouch JVM 启动时立即分配并初始化所有内存页，避免运行时首次分配带来的停顿 false 分区模型 G1 垃圾回收器 G1(Garbage-First) 属于 物理上分区，逻辑上分代，真正的分区模型是 ZGC（jdk21后也支持分代） G1将Java堆划分为多个大小相等的Region，Region大小是2的幂，范围在1MB到32MB之间。JDK9之前默认最多支持2048个Region，这就导致G1最大支持64G 的堆 (2048 Regions × 32MB = 64GB)，JDK10之后的版本可支持更多Region数量，JDK17进一步优化了Region映射机制，提升了大堆场景下的性能，使其可以支持更大的内存，但对于超大堆（&gt;1T），考虑到GC暂停时间，建议使用ZGC或Shenandoah GC。 Region一旦被回收，重新分配时可以是任意类型，比如原先是Eden，那么重新分配时可以是Old，反之亦然。 一般Region大小由JVM自动计算，当然也可以用参数-XX:G1HeapRegionSize手动指定Region大小，但是推荐默认的计算方式。 G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。 在 G1 GC 中，不要使用 -Xmn，G1 中推荐使用以下更细粒度的控制方式： 123# 这是实验性参数，需要开启 `-XX:+UnlockExperimentalVMOptions`，但依旧推荐在生产环境中使用-XX:G1NewSizePercent=5-XX:G1MaxNewSizePercent=60 默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过 -XX:G1NewSizePercent设置新生代初始占比，这是实验性参数，需要开启 -XX:+UnlockExperimentalVMOptions，但依旧推荐在生产环境中使用。 在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过-XX:G1MaxNewSizePercent调整，这是实验性参数，需要开启 -XX:+UnlockExperimentalVMOptions，但依旧推荐在生产环境中使用。 年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。 G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。 在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。 Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。 Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。 G1垃圾收集分类 YoungGC YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做YoungGC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC MixedGC 不是FullGC，老年代的堆占有率达到参数 -XX:InitiatingHeapOccupancyPercent 设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC Full GC 停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了) G1 收集器的工作方式(MixedGC) 图中主要展示了一个典型的 G1 GC 的 并发标记周期（Concurrent Mark Cycle） 的过程。 图中的水平箭头表示各线程（用户线程和GC线程）的执行路径。 竖直的Safepoint线表示一次GC过程中会暂停所有用户线程的时刻（Stop-The-World）。 12345678910111213141516171819202122231️⃣ 初始标记（Initial Mark） 进入 Safepoint： 所有用户线程在此刻暂停（STW）。 标记 GC Roots 直接可达对象。 非常短暂，但属于 Stop-The-World 阶段。 图中是“初始标记”箭头在 Safepoint 之后立刻执行。2️⃣ 并发标记（Concurrent Mark） 用户线程 恢复运行（图中用户线程继续向右延伸）。 GC 线程 并发进行标记工作（即在用户线程运行期间进行标记）。 图中蓝色的“并发标记”箭头与用户线程箭头并行显示，表示并发执行。3️⃣ 最终标记（Remark / Final Mark） 再次进入 Safepoint。 重新暂停所有用户线程。 处理并发标记阶段中遗漏的引用更新等信息，保证标记的准确性。4️⃣ 筛选回收（Cleanup / Filtered Collection） 对已标记的对象做清理（回收不可达对象）。 判断是否需要回收某些 Region。 图中蓝色箭头标注为“筛选回收”。5️⃣ 恢复用户线程 在最后一个 Safepoint 之后，所有用户线程重新开始执行（图中黄色箭头重新向右延伸）。 G1的GC 过程会经历多次Safepoint，但只有 并发标记阶段 是整个周期中最耗时但不会暂停用户线程(STW)的部分。 Safepoint（安全点） 在 JVM（Java 虚拟机）中，Safepoint（安全点） 是一个非常重要的概念，它代表 所有线程必须“安全地”暂停的某个时间点，以便 JVM 能够执行某些全局操作，比如： 垃圾回收（GC） 栈遍历（例如生成堆快照、做逃逸分析等） 类卸载 JIT 编译的一些重写操作等 如果线程正在运行、改变堆中对象的数据，那么 GC 就无法准确标记和回收对象。因此 JVM 需要 让所有线程在一个“可控、安全的位置”上暂停，这个位置就叫 Safepoint。 Safepoint 是怎么工作的？ 1.JVM 发出“进入 Safepoint”的信号（比如要开始 GC） 2.所有线程收到信号后，必须等到“最近的 Safepoint”再停下来： Safepoint 不是任意位置都可以停，它只出现在字节码中一些特定的指令点（比如方法调用、循环跳转等） 3.等所有线程都进入 Safepoint 后，JVM 才能开始执行 GC 等全局操作。 G1 收集器参数配置表 参数名 说明 默认值 -XX:+UseG1GC 使用 G1 垃圾收集器 - -XX:ParallelGCThreads 指定 GC 工作的线程数量 与 CPU 数量相关 -XX:G1HeapRegionSize 设置堆分区大小（1MB~32MB，2 的幂），堆默认划分为 2048 个 Region 自动计算 -XX:MaxGCPauseMillis 设置 GC 目标最大暂停时间 200ms -XX:G1NewSizePercent 新生代初始占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions 5% -XX:G1MaxNewSizePercent 新生代最大占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions 60% -XX:TargetSurvivorRatio Survivor 区填充目标（超过该比例，晋升老年代） 50% -XX:MaxTenuringThreshold 最大对象年龄阈值（年龄超过将进入老年代） 15 -XX:InitiatingHeapOccupancyPercent 老年代的使用率超过该值触发 Mixed GC 45% -XX:G1MixedGCLiveThresholdPercent Mixed GC 中：Region 存活对象占比低于该值才会被回收，实验性参数，-XX:+UnlockExperimentalVMOptions 85% -XX:G1HeapWastePercent Mixed GC 回收目标：空闲 Region 达堆总量该百分比就结束混合回收 5% -XX:G1ReservePercent 为满足停顿时间目标保留的堆空间比例，是一种空间换时间的策略，在内存不足时可能造成内存更加紧张 10% -XX:G1UseAdaptiveIHOP 是否启用自适应IHOP，启用后G1会在初始采样后自动调整IHOP值 true -XX:G1AdaptiveIHOPNumInitialSamples 指定前几次GC活动按IHOP参数计算 3 -XX:SoftRefLRUPolicyMSPerMB 每MB堆内存中软引用的过期时间(ms) 1000 -XX:G1OldCSetRegionThresholdPercent 设置一次混合GC中需要清理的Old区的内存比例，调大可降低G1频率但会增加每次GC时间 10% -XX:G1MixedGCCountTarget 设置G1垃圾回收器的线程上限，HotSpot会根据清理目标自动计算所需线程数，但不会超过此上限 8 ZGC 垃圾回收器 ZGC(Z Garbage Collector)是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器 Platform Supported Since Comment Linux/x64 ✅ JDK 11 Linux/AArch64 ✅ JDK 13 macOS ✅ JDK 14 Windows ✅ JDK 14 Requires Windows version 1803 (Windows 10 or Windows Server 2019) or later. ZGC收集器是一款基于Region内存布局的，暂时不设分代的(jdk21后支持分代)，使用了读屏障、颜色指针等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。 颜色指针 在 ZGC（Z Garbage Collector）中，颜色指针（Colored Pointer）是一种核心机制，把对象的 GC 状态信息直接嵌入到对象的引用（地址）中，用于在不增加对象额外元数据的前提下，跟踪对象在垃圾回收过程中的状态。 在传统 GC 中，对象的“颜色”（如白色、灰色、黑色）表示其在 GC 不同阶段的状态，这些信息一般存储在额外的数据结构中（如记忆集合、位图等）。 而在 ZGC 中，ZGC 将对象的这些状态信息编码进指针的高位中。所以一个对象引用（pointer）不仅仅是内存地址，还携带了对象在 GC 过程中的“颜色”信息。 ZGC 主要运行在 64 位系统上，但当前的操作系统和 CPU 实际上只使用 48～57 位虚拟地址。ZGC 利用未使用的高位进行编码。 每个对象有一个64位指针，这64位被分为： 位数 名称 含义 18 位 预留 保留位，未来可能用于扩展功能 1 位 Finalizable 表示对象可终结（即实现了 finalize() 方法） 1 位 Remapped 标识对象是否已被转移(用于标识某个引用是否已经被重定向（更新为新地址）)；为 1 表示该对象未在重定位集（Relocation Set）中，即新地址，为0表示旧地址 1 位 Marked1 标记位之一，用于 GC 过程中的对象标记阶段 ,由于 ZGC 是并发 GC，需要两位来支持颜色切换机制（Color Flip），确保在不同 GC 周期中可以区分新旧标记，需要触发一次读取屏障（load barrier），找到对象的新位置，并更新这个引用。 1 位 Marked0 另一个标记位，与 Marked1 配合用于 GC 标记阶段 42 位 对象地址部分 实际的内存地址部分，最多可表示 2^42 字节（即 4 TB）,jdk15后占用 44位，支持 16TB 读屏障 ZGC（Z Garbage Collector）中的**读屏障（Read Barrier）是其核心机制之一，它保证了并发压缩（对象移动）**时程序的正确性，是实现低延迟、高并发垃圾回收的关键。 在传统 GC 中，如果对象在 GC 过程中被移动，程序访问到的对象地址可能就无效了。因此，需要**“停世界”**将所有引用更新。 而 ZGC 的设计目标是 &lt;10ms 的 GC 停顿时间，所以它采用 并发标记 + 并发移动 + 并发引用更新 的模式。在这种模式下，对象可以在程序运行时被移动，但程序访问时必须“知道”这个对象是否已经被移动，并获取其最新地址，这就是读屏障的职责。 读屏障是一种在读取对象引用时自动插入的逻辑，用于检查引用是否有效，并在必要时进行修正（即地址重定向）。 ZGC 是目前唯一在所有对象访问中都使用读屏障的 GC，它在每次对象指针解引用时都进行如下操作： 职责 说明 检测引用是否是老地址 利用指针中的元信息（颜色指针，如 Remapped 位）判断引用是否已经被更新 如果未更新则重定向引用 如果引用的是旧地址，屏障会通过 forwarding table 找到新地址并更新 保证最终访问对象的地址正确 即使在对象移动过程中，程序也总能访问到有效地址，无需停顿所有线程 graph TD A[程序访问对象引用&lt;br&#x2F;&gt;例如：Person p &#x3D; personField] --&gt; B[JVM 插入读屏障逻辑] B --&gt; C[读屏障检查颜色指针中的 Remapped 位] C --&gt; D{Remapped 位为 0 吗？} D -- 是 --&gt; E[检查对象是否已被移动] E --&gt; F[更新引用地址为新地址] F --&gt; G[设置 Remapped 位为 1] G --&gt; H[使用更新后的引用访问对象] D -- 否 --&gt; I[直接使用当前引用访问对象] ZGC的Region可以具有大、中、小三类容量： 小型Region（Small Region） ： 容量固定为2MB，用于放置小于256KB的小对象。 中型Region（Medium Region） ： 容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。 大型Region（Large Region） ： 容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。 ZGC 特点： 支持极大堆（JDK 15 起支持最高 16TB） GC 停顿时间通常低于 1ms（与堆大小基本无关） 适合低延迟、高吞吐、高可用的应用场景，如交易系统、广告推荐等 ZGC 收集器的工作方式 123456789101112131415161718192021221️⃣ 并发标记（Concurrent Mark）： 与G1一样，并发标记是遍历对象图做可达性分析的阶段， 它的初始标记(Mark Start)和最终标记(Mark End)也会出现短暂的停顿， 与G1不同的是，ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新染色指针中的 Marked 0、 Marked 1 标志位。2️⃣ 并发预备重分配（Concurrent Prepare for Relocate）： 这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。 ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。3️⃣ 并发重分配（Concurrent Relocate）： 重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上， 并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。 ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象， 这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上， 并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。4️⃣ 并发重映射（Concurrent Remap）： 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。 ZGC很巧妙地把并发重映射阶段（Concurrent Remap）要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段（Concurrent Mark）里去完成， 反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。 一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。 ZGC存在的问题 ZGC最大的问题是浮动垃圾。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。 ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。 目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。 JDK21正式引入了分代（jdk17是预览版），可以在生产环境中使用，需要手动开启：-XX:+ZGenerational ZGC 收集器参数配置表 参数名 说明 默认值（如未特殊标注） -XX:+UseZGC 启用 ZGC 垃圾收集器 - -XX:+UnlockExperimentalVMOptions 解锁实验性参数（JDK 11~14 使用 ZGC 必须） - -XX:+UseLargePages 启用大页内存（性能优化） false -XX:+UseTransparentHugePages 启用透明大页（部分 Linux 上可结合使用） false -Xmx / -Xms 设置最大/初始堆大小 用户配置 -XX:ZUncommitDelay=&lt;秒&gt; 未使用内存释放回操作系统的延迟时间（ZGC 会自动释放内存） 300（5分钟） -XX:SoftMaxHeapSize=&lt;大小&gt; 软最大堆（Soft Heap Limit）：ZGC 尝试将使用的堆控制在该值以内 默认等于 -Xmx -XX:MaxHeapFreeRatio 最大堆空闲比例（超过此比例可能触发内存释放） 70 -XX:MinHeapFreeRatio 最小堆空闲比例（低于此比例可能触发扩容） 40 -XX:+ZGenerational 启用 ZGC 分代收集（从 JDK 21 起支持，默认关闭） false（JDK 21+） -XX:+PrintGC / -Xlog:gc* 开启 GC 日志输出 - -XX:+ZProactive 主动回收策略（在系统空闲时尝试回收） true -XX:ZCollectionInterval=&lt;秒&gt; 主动回收之间的最小时间间隔（配合 ZProactive） 默认值因版本而异 ZGC vs G1 GC vs Parallel GC 对比表 特性 ZGC G1 GC Parallel GC 设计目标 极低延迟，&lt;1ms 停顿 平衡 低延迟 与 高吞吐 高吞吐，最大化 CPU 使用 GC 停顿时间 &lt;1ms，堆大小增加不影响停顿时间 几十到几百毫秒，堆越大停顿越明显 停顿时间可能达到秒级，堆越大越明显 堆大小支持 支持高达 16TB（JDK 15+） 支持 最多 4TB 支持大堆，但停顿明显 是否分代 默认不分代（JDK 21+ 可开启 -XX:+ZGenerational） 分代（新生代 + 老年代） 分代（新生代 + 老年代） 并发回收 是，包括标记、压缩、引用处理都并发 部分并发，仍包含明显 Stop-The-World 阶段 否，全部 Stop-The-World 移动对象时是否停顿 否，使用读屏障并发转移对象 是（通过复制区域） 是 实现机制 标记-重定位，基于读屏障 Region 分区 + 标记-复制 + Mixed GC 标记-复制（新生代）、标记-整理（老年代） 吞吐能力 中高 高 最高 适用场景 低延迟系统，如金融、交易、推荐等实时应用 通用后台系统、Web 服务等 批处理、数据计算、日志分析等不敏感于停顿的系统 默认启用 否，需指定 -XX:+UseZGC JDK 9+ 默认 GC JDK 8 及以前默认 GC 调优复杂度 低，大多数参数可省略 中，需要设置目标停顿时间等 高，需要精细配置 Eden/Survivor 等比例 GC 日志配置方式 统一日志格式：-Xlog:gc*（JDK 9+） 支持传统的 -XX:+PrintGCDetails 和 -Xlog:gc* 日志输出 主要使用旧参数：-XX:+PrintGCDetails 等 ZGC 吞吐能力较弱的原因 原因 解释 1. 并发阶段代价较高 ZGC 几乎所有的 GC 工作（包括标记、整理、引用处理、转移对象）都在与应用线程并发执行。虽然减少了停顿，但这些 GC 线程与业务线程共享 CPU 资源，增加了 CPU 上下文切换和缓存竞争，从而影响业务线程的执行效率。 2. 读屏障开销 ZGC 依赖着色指针和读屏障（load barrier）机制来跟踪对象引用状态，支持并发转移。虽然非常高效，但仍比传统 GC 的普通读写路径慢一些，在高频访问对象场景下会带来一定 CPU 开销。 3. 对硬件依赖高，调度保守 为了实现“&lt;1ms 停顿”的目标，ZGC 会选择更保守的调度策略（如避免并发线程使用过多 CPU），而不会像 Parallel GC 那样“榨干”所有核心资源。 4. 内存开销更高 为了支持并发压缩和转移，ZGC 通常需要为每个对象保留元数据和更多的转移空间（即“浮动垃圾”区域），这可能导致频繁的 GC 周期，影响吞吐。 5. 设计目标非吞吐优先 ZGC 的首要目标是低延迟而非最大吞吐。与 Parallel GC（以吞吐为核心）设计目标不同，ZGC 更适合场景为“对延迟敏感但吞吐可接受”的系统。 最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。 另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！ 也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。 ZGC 吞吐弱，不是因为技术落后，而是因为它主动选择在低延迟和高吞吐之间偏向了低延迟。 在对响应时间要求极高的系统中，它是非常合适的选择。 但如果你的目标是压榨机器性能跑批处理、日志分析这类吞吐导向型任务，Parallel GC 或 G1 会更合适。 内存溢出(OutOfMemoryError，简称 OOM) JVM 常见内存溢出类型汇总表 溢出类型 异常信息 触发原因/描述 相关参数和建议配置 堆内存溢出 java.lang.OutOfMemoryError: Java heap space - 创建大量对象，堆空间不足- 内存泄漏：对象不再使用却有强引用- 老年代对象太多无法晋升 -Xms / -Xmx 设置堆大小 栈溢出（递归） java.lang.StackOverflowError - 方法无限递归或递归层级太深 -Xss 设置线程栈大小 无法创建新线程 java.lang.OutOfMemoryError: unable to create new native thread - 创建线程过多（如线程池配置过大）- 系统或 JVM native 线程资源耗尽 控制线程池大小，避免无限新建线程 元空间溢出 java.lang.OutOfMemoryError: Metaspace - 动态加载类过多（如使用 CGLIB、JSP 动态生成类）- 类无法卸载（如 ClassLoader 泄漏） -XX:MetaspaceSize / -XX:MaxMetaspaceSize 直接内存溢出 java.lang.OutOfMemoryError: Direct buffer memory - 使用 ByteBuffer.allocateDirect() 分配大量直接内存- Netty 等框架默认使用直接内存 -XX:MaxDirectMemorySize GC 开销过高 java.lang.OutOfMemoryError: GC overhead limit exceeded - JVM 花费 &gt;98% 的时间 GC 但回收 &lt;2% 的内存，认为进入“GC 死循环” 分析 GC 日志、优化堆设置 类卸载失败（内存泄漏） （不一定报错，但可能导致 Metaspace OOM） - Web 容器频繁部署热更新 WAR 包时，ClassLoader 无法卸载，导致类永久驻留 优化 ClassLoader 管理，使用内存分析工具 堆快照(堆转储)文件分析 参数 说明 -XX:+HeapDumpOnOutOfMemoryError OOM 时生成堆转储文件 ,建议生产环境开启 -XX:HeapDumpPath=xxx.hprof 指定堆转储文件保存路径 默认保存在当前目录 常用分析工具与命令 工具/命令 简介与功能 使用说明 MAT（Memory Analyzer Tool） Eclipse 出品的强大图形工具，支持泄漏分析、对象引用链分析、内存占用统计等 下载地址：https://www.eclipse.org/mat/打开后直接导入 .hprof 文件即可分析 VisualVM 官方可视化 JVM 监控工具，支持实时分析、GC 查看、线程状态与堆转储查看 附带于 JDK（或单独安装），打开 .hprof 文件进行可视化分析 JProfiler 商业级 Java 性能分析工具，提供堆分析、CPU 分析、线程分析等全套功能 支持打开 .hprof 文件，也可在运行时配合使用（需付费或试用） YourKit 商业性能分析工具，界面友好，支持丰富的分析功能 支持堆分析，适合内存泄漏排查 jhat（过时） JDK 附带的旧工具，用于分析 .hprof 文件，开启 Web 界面查看（已废弃） 命令：jhat heapdump.hprof，浏览器访问 http://localhost:7000（JDK 8 及以下） jmap 用于生成堆转储文件或查看堆对象统计信息（不是分析工具本身） 命令：jmap -dump:format=b,file=heap.hprof &lt;pid&gt; 生成转储；配合 MAT 使用 jcmd 更现代的诊断命令工具，可生成 heap dump、执行 GC、打印 VM 状态等 命令：jcmd &lt;pid&gt; GC.heap_dump heap.hprof GCEasy.io 在线分析工具，支持 .hprof 文件和 GC 日志上传分析 网站：https://gceasy.io GC日志相关参数(JDK1.8及以下) 参数 说明 -XX:+PrintGC 打印基本 GC 信息（建议配合 -XX:+PrintGCDetails 使用）,与-verbose:gc等价 -XX:+PrintGCDetails 打印详细的 GC 日志信息（如各区域使用情况、对象分配、晋升等） -XX:+PrintGCDateStamps 在 GC 日志中添加日期时间戳 -XX:+PrintGCTimeStamps 在 GC 日志中添加 JVM 启动以来的时间戳 -Xloggc:/var/log/myapp/gc.log 将 GC 日志输出到指定文件 -XX:+UseGCLogFileRotation 启用 GC 日志文件轮转（适用于大规模系统的 GC 日志管理） -XX:NumberOfGCLogFiles=5 最多保留 5 个 GC 日志历史文件 -XX:GCLogFileSize=10M 每个 GC 日志文件最大为 10MB -XX:+PrintGCCause 打印 GC 的触发原因（如 Minor GC、System.gc() 等） GC日志相关参数(JDK9+) -Xlog 是用于配置 JVM 日志记录的参数，它是从 JDK 9 开始引入的统一日志框架（Unified Logging）的一部分。 通过 -Xlog 选项，你可以控制日志的 标签（tags）、输出级别（level）、输出位置（output） 等内容。 基本格式 1-Xlog[:[tag1[,tag2...]][[:level][:[output][:[decorators][:rotation]]]]] 常见 Tags（标签） 类别 标签 含义 用途示例 类加载 classload JVM 类加载活动的总体信息 观察类加载失败或重复加载 class+load 显示每个类加载过程细节 定位类加载异常、热加载分析 class+unload 记录类卸载事件 分析类卸载时机或内存释放情况 垃圾回收 gc 总体 GC 活动信息 GC 调优入门使用 gc+start GC 事件开始时间与类型 查看 GC 频率与触发点 gc+heap GC 前后的堆使用情况 分析堆使用与分区占比 gc+phases GC 内部阶段细节 G1/ZGC 等调试用 gc+age 年龄分布情况 判断对象晋升路径、老年代压力 gc+ergo GC 的自适应调整决策 查看线程、堆大小自动调整逻辑 JIT 编译 jit JIT 编译日志入口 性能热点方法分析 compiler 显示方法编译、时间等 判断是否有方法未被优化 codecache 已编译代码存储区使用情况 判断是否达到缓存上限 nmethod JIT 生成的 native 方法生命周期 观察 native 代码生成与卸载 内存 memory 总体内存使用情况 诊断内存泄漏或溢出 gc+heap 堆结构与占用情况 与 GC 联合分析使用 os+memory JVM 与操作系统间的内存交互 判断是否系统层内存申请失败 线程 thread 线程的创建、终止、状态变化 线程泄漏或频繁创建排查 safepoint JVM 进入/退出 safepoint 的信息 分析 STW 停顿时间与频率 锁与同步 synchronization 锁竞争、获取和释放信息 分析性能瓶颈中的锁争用 monitorinflation 轻量级锁升级为重量级锁过程 排查锁膨胀导致的延迟问题 操作系统交互 os JVM 与操作系统交互日志 常规系统资源请求信息 os+thread OS 层级线程管理信息 高并发时线程绑定与调度分析 os+cpu CPU 使用与分布情况 排查高 CPU 使用的问题 类元数据 metaspace 元空间内存使用与变化 排查 Metaspace OOM cds 类共享数据（CDS）日志 分析类加载加速是否生效 安全 security 安全相关操作日志 权限检查失败、密钥加载等调试 module 模块系统（JPMS）相关日志 模块访问控制失败分析 其他 start JVM 启动流程日志 启动阶段慢、出错时使用 init 各子系统初始化过程 定位子系统启动顺序与异常 jni Java 调用 native 方法日志 JNI 崩溃、性能问题分析 classpath 类路径加载详情 类找不到、路径冲突等问题排查 exceptions 异常信息及堆栈打印 捕获未处理异常、频繁抛错分析 Level（级别） 等级 含义说明 用途示例 off 关闭日志记录 完全禁用指定标签的日志输出 error 严重错误，仅记录影响系统运行的错误信息 捕获崩溃、严重故障 warning 潜在问题，可能影响稳定性 记录可能的内存、配置问题 info 常规信息（默认级别） 日常运行日志，如 GC 次数 debug 更详细的调试信息，适用于问题诊断 跟踪行为变化或代码路径 trace 最详细的信息，记录几乎所有细节 深度调试，如方法级别跟踪 all 打印所有级别的日志（包括 trace 及以上） 全量日志输出，用于完全监控 Output（输出位置） 输出位置 含义说明 示例用法 stdout 标准输出（默认） -Xlog:gc=info:stdout stderr 标准错误输出 -Xlog:gc=info:stderr file=路径 输出到指定文件路径（自动创建文件） -Xlog:gc:file=gc.log 多个输出用逗号分隔 可同时输出到多个位置 -Xlog:gc:file=gc.log,stdout Decorators（装饰器） 装饰器 含义说明 示例输出片段（含该装饰器时） time 显示当前系统时间（wall-clock time） 2025-05-16T10:45:12.123+0800 uptime 显示 JVM 启动以来的运行时间（毫秒） 5.123s（表示已运行 5.123 秒） level 显示日志级别（如 info, warning 等） [info], [debug] tags 显示日志标签 [gc], [class,load] tid 显示线程 ID tid=0x00007fddc4012800 hostname 显示主机名 host=example.local pid 显示当前 JVM 进程 ID pid=12345 Rotation (日志轮转设置) 设置参数 含义说明 示例值 filecount=n 保留的日志文件数量（最大文件轮转数） filecount=5 filesize=n 单个日志文件的最大大小（支持单位：k/m/g） filesize=10m 示例： 1-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20M 项 值 含义 tag gc* 匹配所有以 gc 开头的标签（如 gc+heap 等） level 省略 默认是 info output file=/var/log/app/gc.log 日志写入该文件 decorators time,uptime,level,tags 日志前缀包含时间、启动时间、日志级别、标签 rotation filecount=5,filesize=20M 最多保留 5 个日志文件，单个文件最大 20MB 日志文件中可以使用变量 1-Xlog:gc*:file=gc_%p_%t.log 常用变量表 变量 含义 %p 进程ID（Process ID） %t 时间戳（代表日志文件创建时的时间戳） %h 主机名（Hostname） %n 序列号，从0开始，每创建新文件加1 %u 唯一标识符，用于解决文件名冲突 %i 当多个JVM进程使用相同的文件名模式时的区分计数器 时间相关变量表 变量 含义 %Y 年（Year） %m 月（Month） %d 日（Day） %H 小时（Hour） %M 分钟（Minute） %S 秒（Second） 12345678# 基础配置-Xlog:gc*:file=gc_%p_%Y%m%d_%H%M%S.log:time,uptime,level,tags:filecount=5,filesize=20M# 详细GC日志配置-Xlog:gc*=debug:file=gc_%p_%t.log:time,uptime,level,tags:filecount=10,filesize=50M# 多目标输出-Xlog:gc*=info:file=gc.log::filecount=5,filesize=20M -Xlog:gc*=debug:file=gc_detailed.log 对于GC日志的分析 人工分析还是太复杂了，可以使用GCEasy.io，每个月免费5次。","summary":"摘要 本文介绍JVM的内存模型与垃圾回收机制 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档","date_published":"2025-05-12T14:30:05.000Z","tags":["技术","jvm","jvm"]},{"id":"https://blog.hanqunfeng.com/2025/05/08/jvm-classloader-01/","url":"https://blog.hanqunfeng.com/2025/05/08/jvm-classloader-01/","title":"JVM 之 类加载器","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍JVM的类加载器</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\">JDK8 The Java® Virtual Machine Specification</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\">JDK8的java指令的官⽅⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/index.html\">JDK⼯具官⽹⽂档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html\">JDK17的java指令的官⽅⽂档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"类加载器\">类加载器</h2>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/weBeGe.png\" alt=\"\" width=\"1200\" height=\"400\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>左侧是JDK中实现的类加载器，通过<code>parent</code>属性形成⽗⼦关系。应⽤中⾃定义的类加载器的<code>parent</code>都是<br>\n<code>AppClassLoader</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>右侧是JDK中的类加载器实现类。通过类继承的机制形成体系。未来我们就可以通过继承相关的类实现⾃定义类<br>\n加载器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在代码中查看类加载器关系</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoaderDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ⽗⼦关系 AppClassLoader &lt;- ExtClassLoader &lt;- BootStrap Classloader</span></span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">cl1</span> <span class=\"operator\">=</span> LoaderDemo.class.getClassLoader();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;cl1 &gt; &quot;</span> + cl1); <span class=\"comment\">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;parent of cl1 &gt; &quot;</span> + cl1.getParent()); <span class=\"comment\">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class=\"line\">        <span class=\"comment\">// BootStrap Classloader由C++开发，是JVM虚拟机的⼀部分，本身不是JAVA类。</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;grant parent of cl1 &gt; &quot;</span> + cl1.getParent().getParent()); <span class=\"comment\">// null</span></span><br><span class=\"line\">        <span class=\"comment\">// String,Int等基础类由BootStrap Classloader加载。</span></span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">cl2</span> <span class=\"operator\">=</span> String.class.getClassLoader();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;cl2 &gt; &quot;</span> + cl2); <span class=\"comment\">// null</span></span><br><span class=\"line\">        System.out.println(cl1.loadClass(<span class=\"string\">&quot;java.util.List&quot;</span>).getClass().getClassLoader()); <span class=\"comment\">// null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双亲委派机制\">双亲委派机制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当⼀个类加载器要加载⼀个类时，整体的过程就是通过双亲委派机制向上委托查找，如果没有查找到，就向下委托加载。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Java 类加载机制中的<code>双亲委派模型（Parent Delegation Model）</code>是一种保证了类加载器按照层次结构从上到下来加载类的策略。这种层级化的加载流程确保了应用程序能够安全地加载并使用来自不同来源的类，同时也避免了内存中出现相同类的多个拷贝。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是双亲委派机制的工作原理：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">1.当一个类加载器接收到类加载请求时，它首先不会自行尝试去寻找类文件，而是将这个请求委派给它的父类加载器。</li>\n<li class=\"lvl-4\">2.父类加载器同样遵循此规则，它会继续把请求向上委派给它的父类加载器，直到达到根（bootstrapp）类加载器为止。</li>\n<li class=\"lvl-4\">3.根类加载器一般会直接访问本地文件系统来查找类文件，比如 JDK 自带的核心类库，或者在-Xbootclasspath指定的路径下查找。</li>\n<li class=\"lvl-4\">4.如果根类加载器找到了该类，则进行类的加载；如果找不到，则把这个任务交回给发出请求的子类加载器。</li>\n<li class=\"lvl-4\">5.子类加载器也重复步骤 4，若找到则加载，否则传递给下一个子类加载器，直至原始提出请求的类加载器。</li>\n<li class=\"lvl-4\">6.若所有的类加载器都未能找到所需的类，则最终抛出ClassNotFoundException异常。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/ftDnCj.png\" alt=\"\" width=\"600\" height=\"800\"></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>双亲委派有以下几个优点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">安全性：由于类加载是从顶层开始，这能防止恶意代码通过加载相同的包名和类名替代系统的关键类。</li>\n<li class=\"lvl-4\">唯一性：每个类都会被特定的类加载器加载一次，即便是在分布式的环境中也能保证类的统一性，避免因为多次加载导致的错误。</li>\n<li class=\"lvl-4\">可靠性：用户自定义的类加载器不用担心基础类已经被加载，它们可以专心于自己需要处理的部分。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>例如，当应用程序运行时，应用类加载器（Application ClassLoader）接收到对java.lang.String类的加载请求时，它会首先将请求传递给扩展类加载器（Extension ClassLoader），后者再传递给引导类加载器（Bootstrap ClassLoader）。引导类加载器会在其搜索路径中找到String类，并完成加载过程。如果应用程序试图提供自己的String类，由于双亲委派的存在，应用程序所指定的类并不会被加载，从而保证了平台核心 API 的一致性。</p>\n</li>\n<li class=\"lvl-2\">\n<p>总之，双亲委派机制是 Java 类加载过程中一个非常重要的特性，它不仅维护了类加载的安全性和一致性，也为开发者提供了灵活定制类加载规则的能力。</p>\n</li>\n</ul>\n<h3 id=\"每个类加载器查找类的默认路径\">每个类加载器查找类的默认路径</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Java 中，每个类加载器都有自己的类路径（Classpath）去查找类文件。下面是几个主要的类加载器以及它们的默认查找路径：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类加载器名称</th>\n<th>类名 / 别名</th>\n<th>父类加载器</th>\n<th>加载内容描述</th>\n<th>默认查找路径 / 系统属性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>启动类加载器</strong></td>\n<td>BootstrapClassLoader</td>\n<td>无</td>\n<td>加载 <strong>核心 Java 类库</strong></td>\n<td><code>&lt;JAVA_HOME&gt;/jre/lib/rt.jar</code>（JDK8 及之前）或 <code>sun.boot.class.path</code> 指定路径</td>\n</tr>\n<tr>\n<td><strong>扩展类加载器</strong></td>\n<td>ExtClassLoader</td>\n<td>BootstrapClassLoader</td>\n<td>加载 Java 平台扩展类库</td>\n<td><code>&lt;JAVA_HOME&gt;/jre/lib/ext</code> 或由 <code>java.ext.dirs</code> 系统属性指定</td>\n</tr>\n<tr>\n<td><strong>应用类加载器</strong></td>\n<td>AppClassLoader</td>\n<td>ExtClassLoader</td>\n<td>加载 <strong>应用程序类</strong>（用户编写的代码）</td>\n<td><code>-classpath</code>、<code>-cp</code> 参数、<code>CLASSPATH</code> 环境变量、<code>java.class.path</code> 属性、当前目录 (.)</td>\n</tr>\n<tr>\n<td><strong>自定义类加载器</strong></td>\n<td>用户自定义</td>\n<td>可指定</td>\n<td>可通过继承 <code>ClassLoader</code> 并重写 <code>findClass()</code> 方法实现自定义类加载逻辑，如从网络、数据库等加载类文件</td>\n<td>默认继承父加载器查找路径，也可自定义</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需要注意的是，除了 Bootstrap ClassLoader 外，其他的所有类加载器最终都是java.lang.ClassLoader的子类，并且每个类加载器实例都有一个直接的父类加载器。如果你创建了一个新的类加载器，它将继承 Application ClassLoader 作为它的父类，除非你在创建时指定了不同的父类加载器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>此外，Java 9 引入了模块化系统后，类加载机制也有了一些变化，对于模块路径上的类加载，会使用新的层次结构来处理，这使得类加载过程更加灵活同时保持了向后的兼容性。不过，对于传统的类路径上的类加载，双亲委派模型仍然适用。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/50fvA9.png\" alt=\"\" width=\"1200\" height=\"400\"></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类加载器名称</th>\n<th>类名 / 别名</th>\n<th>父类加载器</th>\n<th>加载模块范围</th>\n<th>默认查找路径 / 模块来源</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>引导类加载器</strong></td>\n<td><code>BootstrapClassLoader</code></td>\n<td>无</td>\n<td>加载 <code>java.*</code> 模块，例如 <code>java.base</code>（包含 <code>java.lang</code>, <code>java.util</code> 等）</td>\n<td><code>$JAVA_HOME/jmods</code> 中的模块文件，核心模块由 JVM 启动时直接加载</td>\n</tr>\n<tr>\n<td><strong>平台类加载器</strong></td>\n<td><code>PlatformClassLoader</code></td>\n<td>BootstrapClassLoader</td>\n<td>加载 <code>jdk.*</code>、<code>javafx.*</code> 等平台扩展模块</td>\n<td><code>$JAVA_HOME/jmods</code>，模块名为 <code>jdk.*</code>、<code>javafx.*</code> 等；</td>\n</tr>\n<tr>\n<td><strong>应用类加载器</strong></td>\n<td><code>AppClassLoader</code></td>\n<td>PlatformClassLoader</td>\n<td>加载应用模块（用户代码），包括模块路径 <code>--module-path</code> 和类路径 <code>-classpath</code> 下的类</td>\n<td>应用程序编写的模块或类，来自命令行 <code>--module-path</code>、<code>-classpath</code> 参数、<code>CLASSPATH</code> 环境变量等</td>\n</tr>\n<tr>\n<td><strong>自定义类加载器</strong></td>\n<td>用户自定义</td>\n<td>可指定父加载器</td>\n<td>加载非标准位置的类，可用于插件、网络加载、加密类加载等</td>\n<td>默认遵循双亲委派，可重写 <code>findClass()</code> 实现自定义路径查找或其他数据源，如网络、数据库、加密文件等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>jdk9+中，在委派给父加载器加载前，先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在代码中查看类加载路径</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BootStrap Classloader，加载java基础类。</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;BootStrap ClassLoader加载⽬录：&quot;</span> + System.getProperty(<span class=\"string\">&quot;sun.boot.class.path&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// Extention Classloader 加载⼀些扩展类。 可通过-D java.ext.dirs另⾏指定⽬录</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Extention ClassLoader加载⽬录：&quot;</span> + System.getProperty(<span class=\"string\">&quot;java.ext.dirs&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// AppClassLoader 加载CLASSPATH，应⽤下的Jar包。可通过-D java.class.path另⾏指定⽬录</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;AppClassLoader加载⽬录：&quot;</span> + System.getProperty(<span class=\"string\">&quot;java.class.path&quot;</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"双亲委派机制的实现原理\">双亲委派机制的实现原理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>java.lang.ClassLoader 类的 loadClass 方法是双亲委派的核心实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 加载指定名称的类，并根据 resolve 参数决定是否解析该类。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法实现了类加载的基本逻辑，包括检查类是否已加载、委托父类加载器加载、</span></span><br><span class=\"line\"><span class=\"comment\"> * 自行加载类以及解析类等步骤。该方法是 Java 类加载机制的核心部分之一，</span></span><br><span class=\"line\"><span class=\"comment\"> * 遵循双亲委派模型。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> name    要加载的类的全限定名</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> resolve 如果为 true，则在加载后解析该类</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 加载的 Class 对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> ClassNotFoundException 如果找不到指定的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 这个⽅法是protected声明的，意味着，是可以被⼦类覆盖的，所以，双亲委派机制也是可以被打破的，如Tomcat⼦类重写这个⽅法，并使⽤自己的类加载逻辑。</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 synchronized 确保多线程环境下类加载的同步</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">        <span class=\"comment\">// 每个类加载器对他加载过的类都有⼀个缓存，先去缓存中查看有没有加载过</span></span><br><span class=\"line\">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">//没有加载过，就⾛双亲委派</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 父类存在则让⽗类加载器进⾏加载</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//如果父类不存在，则从引导类加载器进⾏加载</span></span><br><span class=\"line\">                    c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"comment\">// findClass 方法是子类实现的，用于加载指定名称的类</span></span><br><span class=\"line\">                <span class=\"comment\">// ⽗类加载器没有加载过，就⾃⾏解析class⽂件加载</span></span><br><span class=\"line\">                c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                <span class=\"comment\">// 性能统计：记录类加载过程中的时间消耗和调用次数，便于监控和优化。</span></span><br><span class=\"line\">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 默认情况下，双亲委派模型只进⾏了验证和准备阶段，⽽不进⾏解析(如链接、初始化)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">            resolveClass(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>该方法实现了类加载的基本逻辑，包括检查类是否已加载、委托父类加载器加载、自行加载类以及解析类等步骤。该方法是 Java 类加载机制的核心部分之一，遵循双亲委派模型。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这个⽅法是<code>protected</code>声明的，意味着，是可以被⼦类覆盖的，所以，双亲委派机制也是可以被打破的，如Tomcat⼦类重写这个⽅法，并使⽤自己的类加载逻辑。</p>\n</li>\n</ul>\n<h2 id=\"沙箱保护机制\">沙箱保护机制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>沙箱保护机制是 Java 虚拟机提供的一种安全机制，用于保护应用程序免受恶意代码的攻击。</p>\n</li>\n<li class=\"lvl-2\">\n<p>java.lang.ClassLoader 类的 preDefineClass 方法是沙箱保护机制的核心实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个方法在双亲委派模型之前被调用，用于在加载类之前进行一些预处理操作。</span></span><br><span class=\"line\"><span class=\"comment\">// 参数：</span></span><br><span class=\"line\"><span class=\"comment\">// name: 要加载的类的全限定名。</span></span><br><span class=\"line\"><span class=\"comment\">// pd: 提供的保护域信息，可能为 null。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ProtectionDomain <span class=\"title function_\">preDefineClass</span><span class=\"params\">(String name,</span></span><br><span class=\"line\"><span class=\"params\">                                            ProtectionDomain pd)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkName(name))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoClassDefFoundError</span>(<span class=\"string\">&quot;IllegalName: &quot;</span> + name);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class=\"line\">        <span class=\"comment\">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class=\"line\">        <span class=\"comment\">// of the form &quot;java.*&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((name != <span class=\"literal\">null</span>) &amp;&amp; name.startsWith(<span class=\"string\">&quot;java.&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span></span><br><span class=\"line\">                (<span class=\"string\">&quot;Prohibited package name: &quot;</span> +</span><br><span class=\"line\">                 name.substring(<span class=\"number\">0</span>, name.lastIndexOf(<span class=\"string\">&#x27;.&#x27;</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pd == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            pd = defaultDomain;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name != <span class=\"literal\">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pd;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这个方法 <code>preDefineClass</code> 的作用是在类被定义之前进行一些安全检查和准备工作，确保类的合法性与安全性。它通常用于自定义类加载器中，以增强类加载过程中的安全控制。</p>\n</li>\n<li class=\"lvl-2\">\n<p>方法作用详解：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">1.防止定义非法类名的类（如 java.* 包下的类）：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果尝试加载的类属于 java. 开头的标准包（如 java.lang, java.util 等），会抛出 SecurityException。</li>\n<li class=\"lvl-6\">这是为了防止用户自定义类伪装成 Java 核心类库中的类，从而造成安全风险。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">2.校验类名合法性：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">调用 checkName(name) 检查类名是否合法（例如不能包含 /、非法字符等），若不合法则抛出 NoClassDefFoundError。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">3.证书一致性校验（签名一致性校验）：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果类有名称且提供了 ProtectionDomain，会调用 checkCerts(name, codeSource) 来确保当前类的签名与其所在包中其他类的签名一致。</li>\n<li class=\"lvl-6\">防止同一包中混入不同签名的类，避免潜在的恶意篡改。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">4.设置默认保护域（ProtectionDomain）：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果传入的 ProtectionDomain 为 null，则使用类加载器的默认域 defaultDomain。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linking链接过程\">Linking链接过程</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在ClassLoader的<code>loadClass</code>⽅法中，还有⼀个不起眼的步骤，<code>resolveClass</code>。这是⼀个<code>native</code>⽅法。⽽其实现的过程称为<code>linking-链接</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>链接过程的实现功能如下图：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/9vkhLN.png\" alt=\"\" width=\"900\" height=\"500\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>其中关于半初始化状态就是JDK在处理⼀个类的static静态属性时，会先给这个属性分配⼀个默认值，作⽤是占住内存。然后等连接过程完成后，在后⾯的初始化阶段，再将静态属性从默认值修改为指定的初始值。</p>\n</li>\n<li class=\"lvl-2\">\n<p>符号引⽤和直接引⽤</p>\n</li>\n</ul>\n<blockquote>\n<p>如果A类中有⼀个静态属性，引⽤了另⼀个B类。那么在对类进⾏初始化的过程中，因为A和B这两个类都没有初始化，JVM并不知道A和B这两个类的具体地址。所以这时，在A类中，只能创建⼀个不知道具体地址的引⽤，指向B类。这个引⽤就称为符号引⽤。⽽当A类和B类都完成初始化后，JVM⾃然就需要将这个符号引⽤转⽽指向B类具体的内存地址，这个引⽤就称为直接引⽤。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>来看一个有意思的示例</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态变量按声明顺序初始化</span></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法初始化apple对象时，price还没有被初始化，处于链接过程中的准备阶段，即半初始化状态，所以price为默认值0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Apple</span> <span class=\"variable\">apple</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Apple</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 解决方法是将price声明在apple的上面即可</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">double</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> <span class=\"number\">20.00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> totalpay;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Apple</span><span class=\"params\">(<span class=\"type\">double</span> discount)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;====&quot;</span> + price);</span><br><span class=\"line\">        totalpay = price - discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PriceTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Apple.apple.totalpay); <span class=\"comment\">// -10.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一个有意思的问题，就是只有当<code>loadClass</code>方法中的<code>resolve</code>参数为<code>true</code>时<code>resolveClass</code>方法才会被调用，但是大部分情况下，<code>resolve</code>参数都是<code>false</code>，这不是强制限制而是出于以下原因：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">\n<ol>\n<li class=\"lvl-7\">避免递归解析中出现错误或死循环<br>\n在类的解析过程中，如果该类引用了另一个还没加载的类，立即解析可能会导致无限递归或加载顺序问题。通过延迟解析，可以更好地控制加载流程。</li>\n</ol>\n</li>\n<li class=\"lvl-4\">\n<ol start=\"2\">\n<li class=\"lvl-7\">提高加载效率<br>\n加载类可能不一定马上就用到所有方法、字段等符号引用，推迟解析可以提高性能，尤其在批量加载很多类时。</li>\n</ol>\n</li>\n<li class=\"lvl-4\">\n<ol start=\"3\">\n<li class=\"lvl-7\">更灵活地处理类的依赖<br>\n开发者可以先加载类，稍后根据需要再解析。例如，在自定义类加载器中，可能先判断类是否已经存在、是否需要被增强（比如字节码增强），再决定是否解析。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"通过类加载器引⼊外部Jar包\">通过类加载器引⼊外部Jar包</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>虽然通常我们会将依赖的 jar 包直接放入项目的 classpath 中（比如通过构建工具如 Maven 或 Gradle 管理），但在某些特定场景下，我们确实需要动态地通过 URLClassLoader 加载外部 jar 包，这是 Java 提供的一种更灵活的类加载机制。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是一些必须或推荐使用 URLClassLoader 的典型应用场景：</p>\n</li>\n</ul>\n<h3 id=\"1-插件机制（Plugin-System）\">1. 插件机制（Plugin System）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明：<br>\n系统支持用户自定义插件（如 IDE 插件、浏览器扩展、游戏 mod），这些插件在运行时才加载，项目本身在编译期并不知道有哪些插件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>举例：<br>\nEclipse 或 IntelliJ 的插件系统<br>\nMinecraft 的 mod 加载器<br>\nSpring Boot Devtools 重新加载机制</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么不能直接放入 classpath？<br>\n因为插件是动态发现和加载的，不是编译时确定的。</p>\n</li>\n</ul>\n<h3 id=\"2-热部署-动态加载类\">2. 热部署 / 动态加载类</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明：<br>\n你想在应用运行过程中加载新的 jar 或类，比如热更新一个模块而无需重启服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>举例：<br>\nWeb 容器（如 Tomcat）的应用重新部署<br>\n使用 URLClassLoader 加载某个模块的新版本以实现热替换</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么不能放入 classpath？<br>\nclasspath 在启动时就固定了，不能动态添加；而 URLClassLoader 可以运行时加载新 jar。</p>\n</li>\n</ul>\n<h3 id=\"3-多版本隔离\">3. 多版本隔离</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明：<br>\n你希望不同的模块使用同一个库的不同版本，但 classpath 无法支持两个版本的同一个类。</p>\n</li>\n<li class=\"lvl-2\">\n<p>举例：<br>\n一个服务器运行多个服务实例，它们分别依赖 log4j 的不同版本<br>\n一个系统的插件 A 使用 fastjson 1.x，插件 B 使用 fastjson 2.x</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么不能放入 classpath？<br>\nclasspath 是共享的，会发生类冲突。使用多个 URLClassLoader，可实现类隔离。</p>\n</li>\n</ul>\n<h3 id=\"4-脚本或用户上传代码执行\">4. 脚本或用户上传代码执行</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明：<br>\n系统允许用户上传 jar 或 class 文件，然后在服务端执行其中的类逻辑。</p>\n</li>\n<li class=\"lvl-2\">\n<p>举例：<br>\n在线编程平台（如 LeetCode 后端）<br>\n用户上传算法 jar，平台运行并返回结果</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么不能放入 classpath？<br>\n用户上传内容是动态的，系统在运行前无法预知。</p>\n</li>\n</ul>\n<h3 id=\"5-实现类的延迟加载（节省资源）\">5. 实现类的延迟加载（节省资源）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明：<br>\n某些类/模块体积较大或依赖较多，不希望在程序启动时就加载，只有真正使用时再加载。</p>\n</li>\n<li class=\"lvl-2\">\n<p>举例：<br>\n大型桌面应用（如 IntelliJ）在打开某个功能模块时才加载相应 jar</p>\n</li>\n</ul>\n<h3 id=\"总结\">总结</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>使用 <code>URLClassLoader</code> 的原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插件系统</td>\n<td>插件动态加载，不在项目编译时可知</td>\n</tr>\n<tr>\n<td>热部署</td>\n<td>动态替换模块，无需重启</td>\n</tr>\n<tr>\n<td>多版本共存</td>\n<td>避免类冲突，实现类加载隔离</td>\n</tr>\n<tr>\n<td>用户上传 jar</td>\n<td>内容动态生成，classpath 无法预先配置</td>\n</tr>\n<tr>\n<td>延迟加载模块</td>\n<td>启动更快，节省内存</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你是在做框架设计或需要动态扩展能力的场景，理解并使用 URLClassLoader 会非常有帮助。</p>\n</li>\n</ul>\n<h3 id=\"场景假设\">场景假设</h3>\n<h4 id=\"调用外部jar\">调用外部jar</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们有一个外部 jar 文件：hello-plugin.jar，它包含一个类：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个类编译后打包进 hello-plugin.jar</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloPlugin</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello from plugin! :&quot;</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主程序使用 URLClassLoader 动态加载这个 jar</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLClassLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PluginLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 外部 jar 的路径</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">jarFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;plugins/hello-plugin.jar&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">URL</span> <span class=\"variable\">jarUrl</span> <span class=\"operator\">=</span> jarFile.toURI().toURL();</span><br><span class=\"line\">        <span class=\"comment\">// HTTPS jar 的 URL</span></span><br><span class=\"line\">        <span class=\"comment\">// URL jarUrl = new URL(&quot;https://your-domain.com/libs/hello-plugin.jar&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建 URLClassLoader（也可以设置父加载器）</span></span><br><span class=\"line\">        <span class=\"type\">URLClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URLClassLoader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>[]&#123;jarUrl&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载插件类</span></span><br><span class=\"line\">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class=\"string\">&quot;com.example.plugin.HelloPlugin&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建实例并调用方法</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">plugin</span> <span class=\"operator\">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">sayHello</span> <span class=\"operator\">=</span> clazz.getMethod(<span class=\"string\">&quot;sayHello&quot;</span>, String.class);</span><br><span class=\"line\">        sayHello.invoke(plugin, <span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关闭 ClassLoader（Java 7+ 推荐）</span></span><br><span class=\"line\">        classLoader.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时动态编译-Java-源代码\">运行时动态编译 Java 源代码</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们有一个 java 代码片段：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.tools.JavaCompiler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.tools.ToolProvider;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLClassLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Files;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DynamicJavaRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.example.dynamic.Hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Java 源代码</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sourceCode</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;package com.example.dynamic;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;public class Hello &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    public void say() &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        System.out.println(\\&quot;Hello from dynamic source!\\&quot;);\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    &#125;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#125;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建临时目录</span></span><br><span class=\"line\">        <span class=\"type\">Path</span> <span class=\"variable\">tempDir</span> <span class=\"operator\">=</span> Files.createTempDirectory(<span class=\"string\">&quot;dynamic-classes&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">outputDir</span> <span class=\"operator\">=</span> tempDir.toFile();</span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(&quot;临时目录：&quot; + outputDir.getAbsolutePath());</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建 .java 文件</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">javaFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(outputDir, <span class=\"string\">&quot;com/example/dynamic/Hello.java&quot;</span>);</span><br><span class=\"line\">        javaFile.getParentFile().mkdirs();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">FileWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(javaFile)) &#123;</span><br><span class=\"line\">            writer.write(sourceCode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 编译 Java 文件</span></span><br><span class=\"line\">        <span class=\"type\">JavaCompiler</span> <span class=\"variable\">compiler</span> <span class=\"operator\">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compiler == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;请用 JDK 而非 JRE 运行！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> compiler.run(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, javaFile.getPath());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;编译失败！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载类并调用</span></span><br><span class=\"line\">        <span class=\"type\">URLClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URLClassLoader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>[]&#123;outputDir.toURI().toURL()&#125;);</span><br><span class=\"line\">        Class&lt;?&gt; clazz = classLoader.loadClass(className);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clazz.getMethod(<span class=\"string\">&quot;say&quot;</span>);</span><br><span class=\"line\">        method.invoke(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清理（可选）</span></span><br><span class=\"line\">        classLoader.close();</span><br><span class=\"line\">        <span class=\"comment\">// 删除临时目录</span></span><br><span class=\"line\">        Files.walk(outputDir.toPath())</span><br><span class=\"line\">                .sorted(Comparator.reverseOrder()) <span class=\"comment\">// 先删文件，再删目录</span></span><br><span class=\"line\">                .map(Path::toFile)</span><br><span class=\"line\">                .forEach(File::delete);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关键点说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>机制</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>JavaCompiler</code></td>\n<td>JDK 自带的编译器（<code>tools.jar</code>）</td>\n</tr>\n<tr>\n<td><code>ToolProvider.getSystemJavaCompiler()</code></td>\n<td>只能在 JDK 环境中工作，JRE 无法使用</td>\n</tr>\n<tr>\n<td><code>URLClassLoader</code></td>\n<td>用于加载编译后的 .class 文件</td>\n</tr>\n<tr>\n<td><code>FileWriter</code></td>\n<td>保存代码为临时 Java 文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"自定义类加载器\">自定义类加载器</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>要自定义 ClassLoader，只需要继承于 <code>ClassLoader</code> 或者 <code>SecureClassLoader</code>，并重写 <code>findClass()</code> 方法即可</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：我们对上面的代码进行升级，不创建临时文件，而是在内存中编译代码，并从内存中加载字节码，而不依赖磁盘文件，更高效也更适合生产环境中动态类加载（如在线代码执行、脚本引擎等）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.tools.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URI;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InMemoryJavaRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.example.dynamic.Hello&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sourceCode</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;package com.example.dynamic;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;public class Hello &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    public void say() &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        System.out.println(\\&quot;Hello from memory compiled class!\\&quot;);\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    &#125;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取系统 Java 编译器</span></span><br><span class=\"line\">        <span class=\"type\">JavaCompiler</span> <span class=\"variable\">compiler</span> <span class=\"operator\">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compiler == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;请使用 JDK 运行此程序（非 JRE）&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 准备编译源代码：一个 JavaFileObject 表示源代码</span></span><br><span class=\"line\">        <span class=\"type\">JavaFileObject</span> <span class=\"variable\">sourceFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavaSourceFromString</span>(className, sourceCode);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建自定义的内存文件管理器（替代标准的磁盘管理器）</span></span><br><span class=\"line\">        <span class=\"type\">StandardJavaFileManager</span> <span class=\"variable\">standardFileManager</span> <span class=\"operator\">=</span> compiler.getStandardFileManager(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">MemoryJavaFileManager</span> <span class=\"variable\">fileManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MemoryJavaFileManager</span>(standardFileManager);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 执行编译任务</span></span><br><span class=\"line\">        JavaCompiler.<span class=\"type\">CompilationTask</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> compiler.getTask(<span class=\"literal\">null</span>, fileManager, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, Collections.singletonList(sourceFile));</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> task.call();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;编译失败！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载编译后的类</span></span><br><span class=\"line\">        Map&lt;String, <span class=\"type\">byte</span>[]&gt; classBytes = fileManager.getClassBytes();</span><br><span class=\"line\">        <span class=\"type\">InMemoryClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InMemoryClassLoader</span>(classBytes);</span><br><span class=\"line\">        Class&lt;?&gt; clazz = classLoader.loadClass(className);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clazz.getMethod(<span class=\"string\">&quot;say&quot;</span>);</span><br><span class=\"line\">        method.invoke(instance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于表示内存中的 Java 源代码</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaSourceFromString</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleJavaFileObject</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String code;</span><br><span class=\"line\"></span><br><span class=\"line\">        JavaSourceFromString(String className, String code) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(URI.create(<span class=\"string\">&quot;string:///&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + Kind.SOURCE.extension), Kind.SOURCE);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.code = code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> CharSequence <span class=\"title function_\">getCharContent</span><span class=\"params\">(<span class=\"type\">boolean</span> ignoreEncodingErrors)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将编译的 class 文件保存在内存中（不是文件系统）</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryJavaFileManager</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ForwardingJavaFileManager</span>&lt;StandardJavaFileManager&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ByteArrayOutputStream&gt; classOutputBuffers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        MemoryJavaFileManager(StandardJavaFileManager standardManager) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(standardManager);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> JavaFileObject <span class=\"title function_\">getJavaFileForOutput</span><span class=\"params\">(Location location, String className,</span></span><br><span class=\"line\"><span class=\"params\">                                                   JavaFileObject.Kind kind, FileObject sibling)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">            classOutputBuffers.put(className, outputStream);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleJavaFileObject</span>(</span><br><span class=\"line\">                    URI.create(<span class=\"string\">&quot;mem:///&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + kind.extension), kind) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> OutputStream <span class=\"title function_\">openOutputStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> outputStream;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Map&lt;String, <span class=\"type\">byte</span>[]&gt; getClassBytes() &#123;</span><br><span class=\"line\">            Map&lt;String, <span class=\"type\">byte</span>[]&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Map.Entry&lt;String, ByteArrayOutputStream&gt; entry : classOutputBuffers.entrySet()) &#123;</span><br><span class=\"line\">                result.put(entry.getKey(), entry.getValue().toByteArray());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义 ClassLoader，用于从内存中加载字节码</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InMemoryClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"type\">byte</span>[]&gt; classBytes;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">InMemoryClassLoader</span><span class=\"params\">(Map&lt;String, <span class=\"type\">byte</span>[]&gt; classBytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(ClassLoader.getSystemClassLoader());</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.classBytes = classBytes;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从内存中获取字节码</span></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = classBytes.get(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.findClass(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 定义类并返回，一定要使用 defineClass 方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, bytes, <span class=\"number\">0</span>, bytes.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进一步升级：我们现在将这个系统扩展为支持多个类同时动态编译、内存加载并执行。这对于需要处理多个类（例如接口 + 实现、内部依赖等）非常实用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.tools.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URI;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiClassInMemoryCompiler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 准备多个类的源代码</span></span><br><span class=\"line\">        Map&lt;String, String&gt; sources = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        sources.put(<span class=\"string\">&quot;com.example.api.Greeter&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;package com.example.api;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;public interface Greeter &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    void greet();\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#125;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        sources.put(<span class=\"string\">&quot;com.example.impl.EnglishGreeter&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;package com.example.impl;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;import com.example.api.Greeter;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;public class EnglishGreeter implements Greeter &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    public void greet() &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        System.out.println(\\&quot;Hello from EnglishGreeter!\\&quot;);\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    &#125;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#125;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">entryClassName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.example.impl.EnglishGreeter&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 编译</span></span><br><span class=\"line\">        Map&lt;String, <span class=\"type\">byte</span>[]&gt; compiledClasses = compile(sources);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compiledClasses == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;编译失败&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载并执行</span></span><br><span class=\"line\">        <span class=\"type\">InMemoryClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InMemoryClassLoader</span>(compiledClasses);</span><br><span class=\"line\">        Class&lt;?&gt; clazz = classLoader.loadClass(entryClassName);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clazz.getMethod(<span class=\"string\">&quot;greet&quot;</span>);</span><br><span class=\"line\">        method.invoke(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 编译器入口，支持多个类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, <span class=\"type\">byte</span>[]&gt; compile(Map&lt;String, String&gt; sources) &#123;</span><br><span class=\"line\">        <span class=\"type\">JavaCompiler</span> <span class=\"variable\">compiler</span> <span class=\"operator\">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compiler == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;请使用 JDK 运行&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;JavaFileObject&gt; compilationUnits = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : sources.entrySet()) &#123;</span><br><span class=\"line\">            compilationUnits.add(<span class=\"keyword\">new</span> <span class=\"title class_\">JavaSourceFromString</span>(entry.getKey(), entry.getValue()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">StandardJavaFileManager</span> <span class=\"variable\">stdManager</span> <span class=\"operator\">=</span> compiler.getStandardFileManager(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">MemoryJavaFileManager</span> <span class=\"variable\">memManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MemoryJavaFileManager</span>(stdManager);</span><br><span class=\"line\"></span><br><span class=\"line\">        JavaCompiler.<span class=\"type\">CompilationTask</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> compiler.getTask(<span class=\"literal\">null</span>, memManager, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, compilationUnits);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> task.call();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> success ? memManager.getClassBytes() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 源文件表示（Java 代码以字符串提供）</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaSourceFromString</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleJavaFileObject</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String code;</span><br><span class=\"line\"></span><br><span class=\"line\">        JavaSourceFromString(String className, String code) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(URI.create(<span class=\"string\">&quot;string:///&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + Kind.SOURCE.extension), Kind.SOURCE);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.code = code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> CharSequence <span class=\"title function_\">getCharContent</span><span class=\"params\">(<span class=\"type\">boolean</span> ignoreEncodingErrors)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存中的编译输出管理器</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryJavaFileManager</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ForwardingJavaFileManager</span>&lt;StandardJavaFileManager&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ByteArrayOutputStream&gt; classOutputBuffers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        MemoryJavaFileManager(StandardJavaFileManager standardManager) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(standardManager);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> JavaFileObject <span class=\"title function_\">getJavaFileForOutput</span><span class=\"params\">(Location location, String className,</span></span><br><span class=\"line\"><span class=\"params\">                                                   JavaFileObject.Kind kind, FileObject sibling)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">            classOutputBuffers.put(className, outputStream);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleJavaFileObject</span>(</span><br><span class=\"line\">                    URI.create(<span class=\"string\">&quot;mem:///&quot;</span> + className.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>) + kind.extension), kind) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> OutputStream <span class=\"title function_\">openOutputStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> outputStream;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Map&lt;String, <span class=\"type\">byte</span>[]&gt; getClassBytes() &#123;</span><br><span class=\"line\">            Map&lt;String, <span class=\"type\">byte</span>[]&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Map.Entry&lt;String, ByteArrayOutputStream&gt; entry : classOutputBuffers.entrySet()) &#123;</span><br><span class=\"line\">                result.put(entry.getKey(), entry.getValue().toByteArray());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于加载内存中的 class</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InMemoryClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"type\">byte</span>[]&gt; classBytes;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">InMemoryClassLoader</span><span class=\"params\">(Map&lt;String, <span class=\"type\">byte</span>[]&gt; classBytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(ClassLoader.getSystemClassLoader());</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.classBytes = classBytes;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = classBytes.get(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytes == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.findClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, bytes, <span class=\"number\">0</span>, bytes.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打破双亲委派，实现同类多版本共存\">打破双亲委派，实现同类多版本共存</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>假设我们有同一个jar包的不同版本，比如：<code>a-1.0.jar</code>和<code>a-2.0.jar</code>，他们具有同名的 <code>DemoClass</code>类 ,系统<code>classpath</code>中引入的是 <code>a-1.0.jar</code>，而此时我们通过⾃定的ClassLoader加载 <code>a-2.0.jar</code>，并调用 <code>DemoClass</code>类 ，我们会发现，⾃定的ClassLoader加载的类依旧是 <code>a-1.0.jar</code> 中的类，而不是 <code>a-2.0.jar</code> 中的类。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么会出现这种情况呢？这就是因为JDK的双亲委派机制。⾃定的ClassLoader的<code>parent</code>属性指向的是JDK内的<code>AppClassLoader</code>，⽽ <code>AppClassLoader</code> 会加载系统当中的所有代码，就包括 <code>a-1.0.jar</code>中的 <code>DemoClass</code>类。这时，⾃定的ClassLoader去加载 <code>DemoClass</code>类时，通过双亲委派向上查找，⾃然加载出来的就是APPClassloader中的<code>DemoClass</code>了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如何打破双亲委派呢？我们可以通过重写 <code>loadClass()</code>方法，来打破双亲委派，实现类⽂件的加载。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLConnection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.SecureClassLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SecureClassLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> URL jarUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CustomClassLoader</span><span class=\"params\">(URL jarUrl)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个独立的子类加载器，只加载指定 JAR</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jarUrl = jarUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把双亲委派机制反过来，先到⼦类加载器中加载，加载不到再去⽗类加载器中加载。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果类已加载，则直接返回</span></span><br><span class=\"line\">            Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (loadedClass == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                loadedClass = findClass(name);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 委派给父类加载器</span></span><br><span class=\"line\">                loadedClass = <span class=\"built_in\">super</span>.loadClass(name, resolve);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadedClass;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> code;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 访问jar包的url</span></span><br><span class=\"line\">            <span class=\"type\">URLConnection</span> <span class=\"variable\">urlConnection</span> <span class=\"operator\">=</span> jarUrl.openConnection();</span><br><span class=\"line\">            urlConnection.setUseCaches(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> urlConnection.getInputStream();</span><br><span class=\"line\">            <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((code = is.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                bos.write(code);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] data = bos.toByteArray();</span><br><span class=\"line\">            is.close();</span><br><span class=\"line\">            bos.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, data, <span class=\"number\">0</span>, data.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">jarFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;path/to/a-2.0.jar&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">URL</span> <span class=\"variable\">jarUrl</span> <span class=\"operator\">=</span> jarFile.toURI().toURL();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">CustomClassLoader</span> <span class=\"variable\">loader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomClassLoader</span>(jarUrl);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 DemoClass</span></span><br><span class=\"line\">        Class&lt;?&gt; clazz = loader.loadClass(<span class=\"string\">&quot;com.example.DemoClass&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        clazz.getMethod(<span class=\"string\">&quot;print&quot;</span>).invoke(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"打破双亲委派机制的典型场景\">打破双亲委派机制的典型场景</h3>\n<h4 id=\"Tomcat类加载器\">Tomcat类加载器</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/eGKhDn.png\" alt=\"\" width=\"550\" height=\"700\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CommonClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</p>\n</li>\n<li class=\"lvl-2\">\n<p>CatalinaClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可⻅；</p>\n</li>\n<li class=\"lvl-2\">\n<p>SharedClassLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可⻅，但是对于Tomcat容器不可⻅；</p>\n</li>\n<li class=\"lvl-2\">\n<p>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可⻅，⽐如加载war包⾥相关的类，每个war包应⽤都有⾃⼰的WebappClassLoader，实现相互隔离，⽐如不同war包应⽤引⼊了不同的spring版本，这样实现就能加载各⾃的spring版本；</p>\n</li>\n<li class=\"lvl-2\">\n<p>Jsp类加载器：针对每个JSP⻚⾯创建⼀个加载器。这个加载器⽐较轻量级，所以Tomcat还实现了热加载，也就是JSP只要修改了，就创建⼀个新的加载器，从⽽实现了JSP⻚⾯的热更新。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍JVM的类加载器 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档 类加载器 左侧是JDK中实现的类加载器，通过parent属性形成⽗⼦关系。应⽤中⾃定义的类加载器的parent都是 AppClassLoader 右侧是JDK中的类加载器实现类。通过类继承的机制形成体系。未来我们就可以通过继承相关的类实现⾃定义类 加载器。 在代码中查看类加载器关系 1234567891011121314public class LoaderDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // ⽗⼦关系 AppClassLoader &lt;- ExtClassLoader &lt;- BootStrap Classloader ClassLoader cl1 = LoaderDemo.class.getClassLoader(); System.out.println(&quot;cl1 &gt; &quot; + cl1); // sun.misc.Launcher$AppClassLoader@18b4aac2 System.out.println(&quot;parent of cl1 &gt; &quot; + cl1.getParent()); // sun.misc.Launcher$ExtClassLoader@1b6d3586 // BootStrap Classloader由C++开发，是JVM虚拟机的⼀部分，本身不是JAVA类。 System.out.println(&quot;grant parent of cl1 &gt; &quot; + cl1.getParent().getParent()); // null // String,Int等基础类由BootStrap Classloader加载。 ClassLoader cl2 = String.class.getClassLoader(); System.out.println(&quot;cl2 &gt; &quot; + cl2); // null System.out.println(cl1.loadClass(&quot;java.util.List&quot;).getClass().getClassLoader()); // null &#125;&#125; 双亲委派机制 当⼀个类加载器要加载⼀个类时，整体的过程就是通过双亲委派机制向上委托查找，如果没有查找到，就向下委托加载。 Java 类加载机制中的双亲委派模型（Parent Delegation Model）是一种保证了类加载器按照层次结构从上到下来加载类的策略。这种层级化的加载流程确保了应用程序能够安全地加载并使用来自不同来源的类，同时也避免了内存中出现相同类的多个拷贝。 以下是双亲委派机制的工作原理： 1.当一个类加载器接收到类加载请求时，它首先不会自行尝试去寻找类文件，而是将这个请求委派给它的父类加载器。 2.父类加载器同样遵循此规则，它会继续把请求向上委派给它的父类加载器，直到达到根（bootstrapp）类加载器为止。 3.根类加载器一般会直接访问本地文件系统来查找类文件，比如 JDK 自带的核心类库，或者在-Xbootclasspath指定的路径下查找。 4.如果根类加载器找到了该类，则进行类的加载；如果找不到，则把这个任务交回给发出请求的子类加载器。 5.子类加载器也重复步骤 4，若找到则加载，否则传递给下一个子类加载器，直至原始提出请求的类加载器。 6.若所有的类加载器都未能找到所需的类，则最终抛出ClassNotFoundException异常。 双亲委派有以下几个优点： 安全性：由于类加载是从顶层开始，这能防止恶意代码通过加载相同的包名和类名替代系统的关键类。 唯一性：每个类都会被特定的类加载器加载一次，即便是在分布式的环境中也能保证类的统一性，避免因为多次加载导致的错误。 可靠性：用户自定义的类加载器不用担心基础类已经被加载，它们可以专心于自己需要处理的部分。 例如，当应用程序运行时，应用类加载器（Application ClassLoader）接收到对java.lang.String类的加载请求时，它会首先将请求传递给扩展类加载器（Extension ClassLoader），后者再传递给引导类加载器（Bootstrap ClassLoader）。引导类加载器会在其搜索路径中找到String类，并完成加载过程。如果应用程序试图提供自己的String类，由于双亲委派的存在，应用程序所指定的类并不会被加载，从而保证了平台核心 API 的一致性。 总之，双亲委派机制是 Java 类加载过程中一个非常重要的特性，它不仅维护了类加载的安全性和一致性，也为开发者提供了灵活定制类加载规则的能力。 每个类加载器查找类的默认路径 在 Java 中，每个类加载器都有自己的类路径（Classpath）去查找类文件。下面是几个主要的类加载器以及它们的默认查找路径： 类加载器名称 类名 / 别名 父类加载器 加载内容描述 默认查找路径 / 系统属性 启动类加载器 BootstrapClassLoader 无 加载 核心 Java 类库 &lt;JAVA_HOME&gt;/jre/lib/rt.jar（JDK8 及之前）或 sun.boot.class.path 指定路径 扩展类加载器 ExtClassLoader BootstrapClassLoader 加载 Java 平台扩展类库 &lt;JAVA_HOME&gt;/jre/lib/ext 或由 java.ext.dirs 系统属性指定 应用类加载器 AppClassLoader ExtClassLoader 加载 应用程序类（用户编写的代码） -classpath、-cp 参数、CLASSPATH 环境变量、java.class.path 属性、当前目录 (.) 自定义类加载器 用户自定义 可指定 可通过继承 ClassLoader 并重写 findClass() 方法实现自定义类加载逻辑，如从网络、数据库等加载类文件 默认继承父加载器查找路径，也可自定义 需要注意的是，除了 Bootstrap ClassLoader 外，其他的所有类加载器最终都是java.lang.ClassLoader的子类，并且每个类加载器实例都有一个直接的父类加载器。如果你创建了一个新的类加载器，它将继承 Application ClassLoader 作为它的父类，除非你在创建时指定了不同的父类加载器。 此外，Java 9 引入了模块化系统后，类加载机制也有了一些变化，对于模块路径上的类加载，会使用新的层次结构来处理，这使得类加载过程更加灵活同时保持了向后的兼容性。不过，对于传统的类路径上的类加载，双亲委派模型仍然适用。 类加载器名称 类名 / 别名 父类加载器 加载模块范围 默认查找路径 / 模块来源 引导类加载器 BootstrapClassLoader 无 加载 java.* 模块，例如 java.base（包含 java.lang, java.util 等） $JAVA_HOME/jmods 中的模块文件，核心模块由 JVM 启动时直接加载 平台类加载器 PlatformClassLoader BootstrapClassLoader 加载 jdk.*、javafx.* 等平台扩展模块 $JAVA_HOME/jmods，模块名为 jdk.*、javafx.* 等； 应用类加载器 AppClassLoader PlatformClassLoader 加载应用模块（用户代码），包括模块路径 --module-path 和类路径 -classpath 下的类 应用程序编写的模块或类，来自命令行 --module-path、-classpath 参数、CLASSPATH 环境变量等 自定义类加载器 用户自定义 可指定父加载器 加载非标准位置的类，可用于插件、网络加载、加密类加载等 默认遵循双亲委派，可重写 findClass() 实现自定义路径查找或其他数据源，如网络、数据库、加密文件等 jdk9+中，在委派给父加载器加载前，先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。 在代码中查看类加载路径 123456// BootStrap Classloader，加载java基础类。System.out.println(&quot;BootStrap ClassLoader加载⽬录：&quot; + System.getProperty(&quot;sun.boot.class.path&quot;));// Extention Classloader 加载⼀些扩展类。 可通过-D java.ext.dirs另⾏指定⽬录System.out.println(&quot;Extention ClassLoader加载⽬录：&quot; + System.getProperty(&quot;java.ext.dirs&quot;));// AppClassLoader 加载CLASSPATH，应⽤下的Jar包。可通过-D java.class.path另⾏指定⽬录System.out.println(&quot;AppClassLoader加载⽬录：&quot; + System.getProperty(&quot;java.class.path&quot;)); 双亲委派机制的实现原理 java.lang.ClassLoader 类的 loadClass 方法是双亲委派的核心实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 加载指定名称的类，并根据 resolve 参数决定是否解析该类。 * * 该方法实现了类加载的基本逻辑，包括检查类是否已加载、委托父类加载器加载、 * 自行加载类以及解析类等步骤。该方法是 Java 类加载机制的核心部分之一， * 遵循双亲委派模型。 * * @param name 要加载的类的全限定名 * @param resolve 如果为 true，则在加载后解析该类 * @return 加载的 Class 对象 * @throws ClassNotFoundException 如果找不到指定的类 */// 这个⽅法是protected声明的，意味着，是可以被⼦类覆盖的，所以，双亲委派机制也是可以被打破的，如Tomcat⼦类重写这个⽅法，并使⽤自己的类加载逻辑。protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // 使用 synchronized 确保多线程环境下类加载的同步 synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded // 每个类加载器对他加载过的类都有⼀个缓存，先去缓存中查看有没有加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; //没有加载过，就⾛双亲委派 long t0 = System.nanoTime(); try &#123; // 父类存在则让⽗类加载器进⾏加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; //如果父类不存在，则从引导类加载器进⾏加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // findClass 方法是子类实现的，用于加载指定名称的类 // ⽗类加载器没有加载过，就⾃⾏解析class⽂件加载 c = findClass(name); // this is the defining class loader; record the stats // 性能统计：记录类加载过程中的时间消耗和调用次数，便于监控和优化。 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; // 默认情况下，双亲委派模型只进⾏了验证和准备阶段，⽽不进⾏解析(如链接、初始化) if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 该方法实现了类加载的基本逻辑，包括检查类是否已加载、委托父类加载器加载、自行加载类以及解析类等步骤。该方法是 Java 类加载机制的核心部分之一，遵循双亲委派模型。 这个⽅法是protected声明的，意味着，是可以被⼦类覆盖的，所以，双亲委派机制也是可以被打破的，如Tomcat⼦类重写这个⽅法，并使⽤自己的类加载逻辑。 沙箱保护机制 沙箱保护机制是 Java 虚拟机提供的一种安全机制，用于保护应用程序免受恶意代码的攻击。 java.lang.ClassLoader 类的 preDefineClass 方法是沙箱保护机制的核心实现 1234567891011121314151617181920212223242526// 这个方法在双亲委派模型之前被调用，用于在加载类之前进行一些预处理操作。// 参数：// name: 要加载的类的全限定名。// pd: 提供的保护域信息，可能为 null。private ProtectionDomain preDefineClass(String name, ProtectionDomain pd) &#123; if (!checkName(name)) throw new NoClassDefFoundError(&quot;IllegalName: &quot; + name); // Note: Checking logic in java.lang.invoke.MemberName.checkForTypeAlias // relies on the fact that spoofing is impossible if a class has a name // of the form &quot;java.*&quot; if ((name != null) &amp;&amp; name.startsWith(&quot;java.&quot;)) &#123; throw new SecurityException (&quot;Prohibited package name: &quot; + name.substring(0, name.lastIndexOf(&#x27;.&#x27;))); &#125; if (pd == null) &#123; pd = defaultDomain; &#125; if (name != null) checkCerts(name, pd.getCodeSource()); return pd; &#125; 这个方法 preDefineClass 的作用是在类被定义之前进行一些安全检查和准备工作，确保类的合法性与安全性。它通常用于自定义类加载器中，以增强类加载过程中的安全控制。 方法作用详解： 1.防止定义非法类名的类（如 java.* 包下的类）： 如果尝试加载的类属于 java. 开头的标准包（如 java.lang, java.util 等），会抛出 SecurityException。 这是为了防止用户自定义类伪装成 Java 核心类库中的类，从而造成安全风险。 2.校验类名合法性： 调用 checkName(name) 检查类名是否合法（例如不能包含 /、非法字符等），若不合法则抛出 NoClassDefFoundError。 3.证书一致性校验（签名一致性校验）： 如果类有名称且提供了 ProtectionDomain，会调用 checkCerts(name, codeSource) 来确保当前类的签名与其所在包中其他类的签名一致。 防止同一包中混入不同签名的类，避免潜在的恶意篡改。 4.设置默认保护域（ProtectionDomain）： 如果传入的 ProtectionDomain 为 null，则使用类加载器的默认域 defaultDomain。 Linking链接过程 在ClassLoader的loadClass⽅法中，还有⼀个不起眼的步骤，resolveClass。这是⼀个native⽅法。⽽其实现的过程称为linking-链接。 链接过程的实现功能如下图： 其中关于半初始化状态就是JDK在处理⼀个类的static静态属性时，会先给这个属性分配⼀个默认值，作⽤是占住内存。然后等连接过程完成后，在后⾯的初始化阶段，再将静态属性从默认值修改为指定的初始值。 符号引⽤和直接引⽤ 如果A类中有⼀个静态属性，引⽤了另⼀个B类。那么在对类进⾏初始化的过程中，因为A和B这两个类都没有初始化，JVM并不知道A和B这两个类的具体地址。所以这时，在A类中，只能创建⼀个不知道具体地址的引⽤，指向B类。这个引⽤就称为符号引⽤。⽽当A类和B类都完成初始化后，JVM⾃然就需要将这个符号引⽤转⽽指向B类具体的内存地址，这个引⽤就称为直接引⽤。 来看一个有意思的示例 1234567891011121314151617181920class Apple &#123; // 静态变量按声明顺序初始化 // 构造方法初始化apple对象时，price还没有被初始化，处于链接过程中的准备阶段，即半初始化状态，所以price为默认值0.0 static Apple apple = new Apple(10); // 解决方法是将price声明在apple的上面即可 static double price = 20.00; double totalpay; public Apple(double discount) &#123; System.out.println(&quot;====&quot; + price); totalpay = price - discount; &#125;&#125;public class PriceTest &#123; public static void main(String[] args) &#123; System.out.println(Apple.apple.totalpay); // -10.0 &#125;&#125; 这里有一个有意思的问题，就是只有当loadClass方法中的resolve参数为true时resolveClass方法才会被调用，但是大部分情况下，resolve参数都是false，这不是强制限制而是出于以下原因： 避免递归解析中出现错误或死循环 在类的解析过程中，如果该类引用了另一个还没加载的类，立即解析可能会导致无限递归或加载顺序问题。通过延迟解析，可以更好地控制加载流程。 提高加载效率 加载类可能不一定马上就用到所有方法、字段等符号引用，推迟解析可以提高性能，尤其在批量加载很多类时。 更灵活地处理类的依赖 开发者可以先加载类，稍后根据需要再解析。例如，在自定义类加载器中，可能先判断类是否已经存在、是否需要被增强（比如字节码增强），再决定是否解析。 通过类加载器引⼊外部Jar包 虽然通常我们会将依赖的 jar 包直接放入项目的 classpath 中（比如通过构建工具如 Maven 或 Gradle 管理），但在某些特定场景下，我们确实需要动态地通过 URLClassLoader 加载外部 jar 包，这是 Java 提供的一种更灵活的类加载机制。 以下是一些必须或推荐使用 URLClassLoader 的典型应用场景： 1. 插件机制（Plugin System） 场景说明： 系统支持用户自定义插件（如 IDE 插件、浏览器扩展、游戏 mod），这些插件在运行时才加载，项目本身在编译期并不知道有哪些插件。 举例： Eclipse 或 IntelliJ 的插件系统 Minecraft 的 mod 加载器 Spring Boot Devtools 重新加载机制 为什么不能直接放入 classpath？ 因为插件是动态发现和加载的，不是编译时确定的。 2. 热部署 / 动态加载类 场景说明： 你想在应用运行过程中加载新的 jar 或类，比如热更新一个模块而无需重启服务。 举例： Web 容器（如 Tomcat）的应用重新部署 使用 URLClassLoader 加载某个模块的新版本以实现热替换 为什么不能放入 classpath？ classpath 在启动时就固定了，不能动态添加；而 URLClassLoader 可以运行时加载新 jar。 3. 多版本隔离 场景说明： 你希望不同的模块使用同一个库的不同版本，但 classpath 无法支持两个版本的同一个类。 举例： 一个服务器运行多个服务实例，它们分别依赖 log4j 的不同版本 一个系统的插件 A 使用 fastjson 1.x，插件 B 使用 fastjson 2.x 为什么不能放入 classpath？ classpath 是共享的，会发生类冲突。使用多个 URLClassLoader，可实现类隔离。 4. 脚本或用户上传代码执行 场景说明： 系统允许用户上传 jar 或 class 文件，然后在服务端执行其中的类逻辑。 举例： 在线编程平台（如 LeetCode 后端） 用户上传算法 jar，平台运行并返回结果 为什么不能放入 classpath？ 用户上传内容是动态的，系统在运行前无法预知。 5. 实现类的延迟加载（节省资源） 场景说明： 某些类/模块体积较大或依赖较多，不希望在程序启动时就加载，只有真正使用时再加载。 举例： 大型桌面应用（如 IntelliJ）在打开某个功能模块时才加载相应 jar 总结 场景 使用 URLClassLoader 的原因 插件系统 插件动态加载，不在项目编译时可知 热部署 动态替换模块，无需重启 多版本共存 避免类冲突，实现类加载隔离 用户上传 jar 内容动态生成，classpath 无法预先配置 延迟加载模块 启动更快，节省内存 如果你是在做框架设计或需要动态扩展能力的场景，理解并使用 URLClassLoader 会非常有帮助。 场景假设 调用外部jar 我们有一个外部 jar 文件：hello-plugin.jar，它包含一个类： 12345678// 这个类编译后打包进 hello-plugin.jarpackage com.example.plugin;public class HelloPlugin &#123; public void sayHello(String name) &#123; System.out.println(&quot;Hello from plugin! :&quot; + name); &#125;&#125; 主程序使用 URLClassLoader 动态加载这个 jar 12345678910111213141516171819202122232425262728import java.io.File;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;public class PluginLoader &#123; public static void main(String[] args) throws Exception &#123; // 外部 jar 的路径 File jarFile = new File(&quot;plugins/hello-plugin.jar&quot;); URL jarUrl = jarFile.toURI().toURL(); // HTTPS jar 的 URL // URL jarUrl = new URL(&quot;https://your-domain.com/libs/hello-plugin.jar&quot;); // 构建 URLClassLoader（也可以设置父加载器） URLClassLoader classLoader = new URLClassLoader(new URL[]&#123;jarUrl&#125;); // 加载插件类 Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.plugin.HelloPlugin&quot;); // 创建实例并调用方法 Object plugin = clazz.getDeclaredConstructor().newInstance(); Method sayHello = clazz.getMethod(&quot;sayHello&quot;, String.class); sayHello.invoke(plugin, &quot;World&quot;); // 关闭 ClassLoader（Java 7+ 推荐） classLoader.close(); &#125;&#125; 运行时动态编译 Java 源代码 我们有一个 java 代码片段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import javax.tools.JavaCompiler;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Path;public class DynamicJavaRunner &#123; public static void main(String[] args) throws Exception &#123; String className = &quot;com.example.dynamic.Hello&quot;; // Java 源代码 String sourceCode = &quot;package com.example.dynamic;\\n&quot; + &quot;\\n&quot; + &quot;public class Hello &#123;\\n&quot; + &quot; public void say() &#123;\\n&quot; + &quot; System.out.println(\\&quot;Hello from dynamic source!\\&quot;);\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;\\n&quot;; // 创建临时目录 Path tempDir = Files.createTempDirectory(&quot;dynamic-classes&quot;); File outputDir = tempDir.toFile(); // System.out.println(&quot;临时目录：&quot; + outputDir.getAbsolutePath()); // 创建 .java 文件 File javaFile = new File(outputDir, &quot;com/example/dynamic/Hello.java&quot;); javaFile.getParentFile().mkdirs(); try (FileWriter writer = new FileWriter(javaFile)) &#123; writer.write(sourceCode); &#125; // 编译 Java 文件 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); if (compiler == null) &#123; System.err.println(&quot;请用 JDK 而非 JRE 运行！&quot;); return; &#125; int result = compiler.run(null, null, null, javaFile.getPath()); if (result != 0) &#123; System.err.println(&quot;编译失败！&quot;); return; &#125; // 加载类并调用 URLClassLoader classLoader = new URLClassLoader(new URL[]&#123;outputDir.toURI().toURL()&#125;); Class&lt;?&gt; clazz = classLoader.loadClass(className); Object instance = clazz.getDeclaredConstructor().newInstance(); Method method = clazz.getMethod(&quot;say&quot;); method.invoke(instance); // 清理（可选） classLoader.close(); // 删除临时目录 Files.walk(outputDir.toPath()) .sorted(Comparator.reverseOrder()) // 先删文件，再删目录 .map(Path::toFile) .forEach(File::delete); &#125;&#125; 关键点说明 机制 说明 JavaCompiler JDK 自带的编译器（tools.jar） ToolProvider.getSystemJavaCompiler() 只能在 JDK 环境中工作，JRE 无法使用 URLClassLoader 用于加载编译后的 .class 文件 FileWriter 保存代码为临时 Java 文件 自定义类加载器 要自定义 ClassLoader，只需要继承于 ClassLoader 或者 SecureClassLoader，并重写 findClass() 方法即可 示例：我们对上面的代码进行升级，不创建临时文件，而是在内存中编译代码，并从内存中加载字节码，而不依赖磁盘文件，更高效也更适合生产环境中动态类加载（如在线代码执行、脚本引擎等）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import javax.tools.*;import java.io.*;import java.net.URI;import java.util.*;import java.lang.reflect.*;public class InMemoryJavaRunner &#123; public static void main(String[] args) throws Exception &#123; String className = &quot;com.example.dynamic.Hello&quot;; String sourceCode = &quot;package com.example.dynamic;\\n&quot; + &quot;public class Hello &#123;\\n&quot; + &quot; public void say() &#123;\\n&quot; + &quot; System.out.println(\\&quot;Hello from memory compiled class!\\&quot;);\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;; // 获取系统 Java 编译器 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); if (compiler == null) &#123; System.err.println(&quot;请使用 JDK 运行此程序（非 JRE）&quot;); return; &#125; // 准备编译源代码：一个 JavaFileObject 表示源代码 JavaFileObject sourceFile = new JavaSourceFromString(className, sourceCode); // 创建自定义的内存文件管理器（替代标准的磁盘管理器） StandardJavaFileManager standardFileManager = compiler.getStandardFileManager(null, null, null); MemoryJavaFileManager fileManager = new MemoryJavaFileManager(standardFileManager); // 执行编译任务 JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, Collections.singletonList(sourceFile)); boolean success = task.call(); if (!success) &#123; System.err.println(&quot;编译失败！&quot;); return; &#125; // 加载编译后的类 Map&lt;String, byte[]&gt; classBytes = fileManager.getClassBytes(); InMemoryClassLoader classLoader = new InMemoryClassLoader(classBytes); Class&lt;?&gt; clazz = classLoader.loadClass(className); Object instance = clazz.getDeclaredConstructor().newInstance(); Method method = clazz.getMethod(&quot;say&quot;); method.invoke(instance); &#125; // 用于表示内存中的 Java 源代码 static class JavaSourceFromString extends SimpleJavaFileObject &#123; final String code; JavaSourceFromString(String className, String code) &#123; super(URI.create(&quot;string:///&quot; + className.replace(&#x27;.&#x27;, &#x27;/&#x27;) + Kind.SOURCE.extension), Kind.SOURCE); this.code = code; &#125; public CharSequence getCharContent(boolean ignoreEncodingErrors) &#123; return code; &#125; &#125; // 将编译的 class 文件保存在内存中（不是文件系统） static class MemoryJavaFileManager extends ForwardingJavaFileManager&lt;StandardJavaFileManager&gt; &#123; private final Map&lt;String, ByteArrayOutputStream&gt; classOutputBuffers = new HashMap&lt;&gt;(); MemoryJavaFileManager(StandardJavaFileManager standardManager) &#123; super(standardManager); &#125; @Override public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); classOutputBuffers.put(className, outputStream); return new SimpleJavaFileObject( URI.create(&quot;mem:///&quot; + className.replace(&#x27;.&#x27;, &#x27;/&#x27;) + kind.extension), kind) &#123; @Override public OutputStream openOutputStream() &#123; return outputStream; &#125; &#125;; &#125; public Map&lt;String, byte[]&gt; getClassBytes() &#123; Map&lt;String, byte[]&gt; result = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, ByteArrayOutputStream&gt; entry : classOutputBuffers.entrySet()) &#123; result.put(entry.getKey(), entry.getValue().toByteArray()); &#125; return result; &#125; &#125; // 自定义 ClassLoader，用于从内存中加载字节码 static class InMemoryClassLoader extends ClassLoader &#123; private final Map&lt;String, byte[]&gt; classBytes; public InMemoryClassLoader(Map&lt;String, byte[]&gt; classBytes) &#123; super(ClassLoader.getSystemClassLoader()); this.classBytes = classBytes; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // 从内存中获取字节码 byte[] bytes = classBytes.get(name); if (bytes == null) &#123; return super.findClass(name); &#125; // 定义类并返回，一定要使用 defineClass 方法 return defineClass(name, bytes, 0, bytes.length); &#125; &#125;&#125; 进一步升级：我们现在将这个系统扩展为支持多个类同时动态编译、内存加载并执行。这对于需要处理多个类（例如接口 + 实现、内部依赖等）非常实用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import javax.tools.*;import java.io.*;import java.net.URI;import java.util.*;import java.lang.reflect.*;// 主类public class MultiClassInMemoryCompiler &#123; public static void main(String[] args) throws Exception &#123; // 准备多个类的源代码 Map&lt;String, String&gt; sources = new HashMap&lt;&gt;(); sources.put(&quot;com.example.api.Greeter&quot;, &quot;package com.example.api;\\n&quot; + &quot;public interface Greeter &#123;\\n&quot; + &quot; void greet();\\n&quot; + &quot;&#125;\\n&quot;); sources.put(&quot;com.example.impl.EnglishGreeter&quot;, &quot;package com.example.impl;\\n&quot; + &quot;import com.example.api.Greeter;\\n&quot; + &quot;public class EnglishGreeter implements Greeter &#123;\\n&quot; + &quot; public void greet() &#123;\\n&quot; + &quot; System.out.println(\\&quot;Hello from EnglishGreeter!\\&quot;);\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;\\n&quot;); String entryClassName = &quot;com.example.impl.EnglishGreeter&quot;; // 编译 Map&lt;String, byte[]&gt; compiledClasses = compile(sources); if (compiledClasses == null) &#123; System.err.println(&quot;编译失败&quot;); return; &#125; // 加载并执行 InMemoryClassLoader classLoader = new InMemoryClassLoader(compiledClasses); Class&lt;?&gt; clazz = classLoader.loadClass(entryClassName); Object obj = clazz.getDeclaredConstructor().newInstance(); Method method = clazz.getMethod(&quot;greet&quot;); method.invoke(obj); &#125; // 编译器入口，支持多个类 public static Map&lt;String, byte[]&gt; compile(Map&lt;String, String&gt; sources) &#123; JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); if (compiler == null) &#123; System.err.println(&quot;请使用 JDK 运行&quot;); return null; &#125; List&lt;JavaFileObject&gt; compilationUnits = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, String&gt; entry : sources.entrySet()) &#123; compilationUnits.add(new JavaSourceFromString(entry.getKey(), entry.getValue())); &#125; StandardJavaFileManager stdManager = compiler.getStandardFileManager(null, null, null); MemoryJavaFileManager memManager = new MemoryJavaFileManager(stdManager); JavaCompiler.CompilationTask task = compiler.getTask(null, memManager, null, null, null, compilationUnits); boolean success = task.call(); return success ? memManager.getClassBytes() : null; &#125; // 源文件表示（Java 代码以字符串提供） static class JavaSourceFromString extends SimpleJavaFileObject &#123; final String code; JavaSourceFromString(String className, String code) &#123; super(URI.create(&quot;string:///&quot; + className.replace(&#x27;.&#x27;, &#x27;/&#x27;) + Kind.SOURCE.extension), Kind.SOURCE); this.code = code; &#125; @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) &#123; return code; &#125; &#125; // 内存中的编译输出管理器 static class MemoryJavaFileManager extends ForwardingJavaFileManager&lt;StandardJavaFileManager&gt; &#123; private final Map&lt;String, ByteArrayOutputStream&gt; classOutputBuffers = new HashMap&lt;&gt;(); MemoryJavaFileManager(StandardJavaFileManager standardManager) &#123; super(standardManager); &#125; @Override public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); classOutputBuffers.put(className, outputStream); return new SimpleJavaFileObject( URI.create(&quot;mem:///&quot; + className.replace(&#x27;.&#x27;, &#x27;/&#x27;) + kind.extension), kind) &#123; @Override public OutputStream openOutputStream() &#123; return outputStream; &#125; &#125;; &#125; public Map&lt;String, byte[]&gt; getClassBytes() &#123; Map&lt;String, byte[]&gt; result = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, ByteArrayOutputStream&gt; entry : classOutputBuffers.entrySet()) &#123; result.put(entry.getKey(), entry.getValue().toByteArray()); &#125; return result; &#125; &#125; // 用于加载内存中的 class static class InMemoryClassLoader extends ClassLoader &#123; private final Map&lt;String, byte[]&gt; classBytes; public InMemoryClassLoader(Map&lt;String, byte[]&gt; classBytes) &#123; super(ClassLoader.getSystemClassLoader()); this.classBytes = classBytes; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] bytes = classBytes.get(name); if (bytes == null) return super.findClass(name); return defineClass(name, bytes, 0, bytes.length); &#125; &#125;&#125; 打破双亲委派，实现同类多版本共存 假设我们有同一个jar包的不同版本，比如：a-1.0.jar和a-2.0.jar，他们具有同名的 DemoClass类 ,系统classpath中引入的是 a-1.0.jar，而此时我们通过⾃定的ClassLoader加载 a-2.0.jar，并调用 DemoClass类 ，我们会发现，⾃定的ClassLoader加载的类依旧是 a-1.0.jar 中的类，而不是 a-2.0.jar 中的类。 为什么会出现这种情况呢？这就是因为JDK的双亲委派机制。⾃定的ClassLoader的parent属性指向的是JDK内的AppClassLoader，⽽ AppClassLoader 会加载系统当中的所有代码，就包括 a-1.0.jar中的 DemoClass类。这时，⾃定的ClassLoader去加载 DemoClass类时，通过双亲委派向上查找，⾃然加载出来的就是APPClassloader中的DemoClass了。 如何打破双亲委派呢？我们可以通过重写 loadClass()方法，来打破双亲委派，实现类⽂件的加载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.net.URL;import java.net.URLConnection;import java.security.SecureClassLoader;public class CustomClassLoader extends SecureClassLoader &#123; private URL jarUrl; public CustomClassLoader(URL jarUrl) &#123; // 创建一个独立的子类加载器，只加载指定 JAR this.jarUrl = jarUrl; &#125; @Override public Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // 把双亲委派机制反过来，先到⼦类加载器中加载，加载不到再去⽗类加载器中加载。 synchronized (getClassLoadingLock(name)) &#123; // 如果类已加载，则直接返回 Class&lt;?&gt; loadedClass = findLoadedClass(name); if (loadedClass == null) &#123; loadedClass = findClass(name); &#125; else &#123; // 委派给父类加载器 loadedClass = super.loadClass(name, resolve); &#125; return loadedClass; &#125; &#125; @Override protected Class&lt;?&gt; findClass(String name) &#123; int code; try &#123; // 访问jar包的url URLConnection urlConnection = jarUrl.openConnection(); urlConnection.setUseCaches(false); InputStream is = urlConnection.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((code = is.read()) != -1) &#123; bos.write(code); &#125; byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name, data, 0, data.length); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 测试代码 12345678910111213141516import java.io.File;import java.net.URL;public class Test &#123; public static void main(String[] args) throws Exception &#123; File jarFile = new File(&quot;path/to/a-2.0.jar&quot;); URL jarUrl = jarFile.toURI().toURL(); CustomClassLoader loader = new CustomClassLoader(jarUrl); // 加载 DemoClass Class&lt;?&gt; clazz = loader.loadClass(&quot;com.example.DemoClass&quot;); Object obj = clazz.getDeclaredConstructor().newInstance(); clazz.getMethod(&quot;print&quot;).invoke(obj); &#125;&#125; 打破双亲委派机制的典型场景 Tomcat类加载器 CommonClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问； CatalinaClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可⻅； SharedClassLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可⻅，但是对于Tomcat容器不可⻅； WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可⻅，⽐如加载war包⾥相关的类，每个war包应⽤都有⾃⼰的WebappClassLoader，实现相互隔离，⽐如不同war包应⽤引⼊了不同的spring版本，这样实现就能加载各⾃的spring版本； Jsp类加载器：针对每个JSP⻚⾯创建⼀个加载器。这个加载器⽐较轻量级，所以Tomcat还实现了热加载，也就是JSP只要修改了，就创建⼀个新的加载器，从⽽实现了JSP⻚⾯的热更新。","summary":"摘要 本文介绍JVM的类加载器 JDK8 The Java® Virtual Machine Specification JDK8的java指令的官⽅⽂档 JDK⼯具官⽹⽂档 JDK17的java指令的官⽅⽂档","date_published":"2025-05-08T13:30:05.000Z","tags":["技术","jvm","jvm"]},{"id":"https://blog.hanqunfeng.com/2025/04/22/elasticsearch-06-api-aggs/","url":"https://blog.hanqunfeng.com/2025/04/22/elasticsearch-06-api-aggs/","title":"Elasticsearch 的 REST APIs:聚合查询","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Elasticsearch 的 REST APIs：聚合查询</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/rest-apis.html\">官方文档:REST APIs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/search-aggregations.html\">官方文档:Aggregations</a></p>\n</li>\n<li class=\"lvl-2\">\n<a href=\"/2025/04/17/elasticsearch-05-api/\" title=\"Elasticsearch 的 REST APIs\">Elasticsearch 的 REST APIs</a>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"聚合查询\">聚合查询</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html\">聚合查询</a>，可以让我们极其方便的实现对索引数据的统计、分析、运算等操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>基本语法包括以下部分：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">查询条件：指定需要聚合的文档，可以使用标准的 Elasticsearch 查询语法，如 term、match、range 等等。</li>\n<li class=\"lvl-4\">聚合函数：指定要执行的聚合操作，如 sum、avg、min、max、terms、date_histogram 等等。每个聚合命令都会生成一个聚合结果。</li>\n<li class=\"lvl-4\">聚合嵌套：聚合命令可以嵌套，以便更细粒度地分析数据。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &lt;index_name&gt;/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;&lt;aggs_name&gt;&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;agg_type&gt;&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;&lt;field_name&gt;&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">  <span class=\"comment\"># aggs：聚合的根节点，固定写法</span></span><br><span class=\"line\">  <span class=\"comment\"># aggs_name：聚合函数的名称，自己随意定义</span></span><br><span class=\"line\">  <span class=\"comment\"># agg_type：聚合种类，比如是桶聚合（terms）或者是指标聚合（avg、sum、min、max等）</span></span><br><span class=\"line\">  <span class=\"comment\"># field_name：字段名称或者叫域名。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>聚合的分类</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Metric Aggregation：—些数学运算，可以对文档字段进行统计分析，类比Mysql中的 min(), max(), sum() 操作。</li>\n<li class=\"lvl-4\">Bucket Aggregation：一些满足特定条件的文档的集合放置到一个桶里，每一个桶关联一个key，类比Mysql中的group by操作。</li>\n<li class=\"lvl-4\">Pipeline Aggregation：对其他的聚合结果进行二次聚合</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"示例数据准备\">示例数据准备</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们需要先准备一些数据，才能进行聚合分析。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果存在先删除</span></span><br><span class=\"line\">curl -X DELETE -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建索引</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;settings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_shards&quot;:&quot;1&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_replicas&quot;:&quot;2&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;mappings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;properties&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;category&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;price&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;double&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;count&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;integer&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;title&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;analyzer&quot;:&quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;search_analyzer&quot;:&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;remark&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;:&quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;:&quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;search_analyzer&quot;:&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;address&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;keyword&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;tags&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 插入数据</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;1&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;2&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;3&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;4&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;5&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;6&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Metric-Aggregation-指标聚合\">Metric Aggregation(指标聚合)</h2>\n<h3 id=\"单值分析︰只输出一个分析结果\">单值分析︰只输出一个分析结果</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>min, max, avg, sum</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 最大值、最小值、平均值、总和</span></span><br><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,  <span class=\"comment\"># 不返回文档，只返回聚合结果</span></span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;max_price&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，这里返回最大值</span></span><br><span class=\"line\">      <span class=\"string\">&quot;max&quot;</span>: &#123;     <span class=\"comment\"># 指标聚合函数名称</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span> <span class=\"comment\"># 指标聚合字段</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;min_price&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;min&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;avg_price&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;sum_price&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;sum&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Cardinality（类似distinct Count)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0, <span class=\"comment\"># 不返回文档，只返回聚合结果</span></span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;cardinality_count&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回去重后的数量</span></span><br><span class=\"line\">      <span class=\"string\">&quot;cardinality&quot;</span>: &#123;  <span class=\"comment\"># 指标聚合函数名称，cardinality表示去重</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span> <span class=\"comment\"># 指标聚合字段，去重的字段</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多值分析-输出多个分析结果\">多值分析:输出多个分析结果</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>stats（统计）, extended stats</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;stats_price&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;stats&quot;</span>: &#123; <span class=\"comment\"># 指标聚合函数名称，stats表示统计，会返回多个指标</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>: 15,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>: <span class=\"string\">&quot;eq&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>: null,</span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>: []     <span class=\"comment\"># 因为设置size 为 0，所以返回的结果为空</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggregations&quot;</span>: &#123; <span class=\"comment\"># 聚合结果</span></span><br><span class=\"line\">    <span class=\"string\">&quot;stats_price&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回多组聚合结果</span></span><br><span class=\"line\">      <span class=\"string\">&quot;count&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;min&quot;</span>: 3.99,</span><br><span class=\"line\">      <span class=\"string\">&quot;max&quot;</span>: 1999.99,</span><br><span class=\"line\">      <span class=\"string\">&quot;avg&quot;</span>: 562.1666666666666,</span><br><span class=\"line\">      <span class=\"string\">&quot;sum&quot;</span>: 6746</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>percentile （百分位）, percentile rank</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;percentile_price&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;percentiles&quot;</span>: &#123; <span class=\"comment\"># 指标聚合函数名称，percentiles表示百分位数聚合计算</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span>, <span class=\"comment\"># 指标聚合字段</span></span><br><span class=\"line\">        <span class=\"string\">&quot;percents&quot;</span>: [1, 5, 25, 50, 75, 95, 99] <span class=\"comment\"># 需要计算百分位数的数组</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 百分位数是一个统计学概念，用于描述一个给定集合的排序值。例如：</span></span><br><span class=\"line\"><span class=\"comment\"># 第 1 百分位数表示数据中小于这个值的所有数据占总数的 1%。</span></span><br><span class=\"line\"><span class=\"comment\"># 第 50 百分位数（中位数）表示数据中的一半小于这个值，另一半大于这个值。</span></span><br><span class=\"line\"><span class=\"comment\"># 第 99 百分位数表示数据中小于这个值的所有数据占总数的 99%。</span></span><br><span class=\"line\"><span class=\"comment\"># 通过计算这些百分位数，你可以了解 price 字段在整个shopping索引中的分布情况，从而可以用于数据分析、趋势判断等。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>top hits(排在前面的示例)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;top_hits&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回排在前面的示例</span></span><br><span class=\"line\">      <span class=\"string\">&quot;top_hits&quot;</span>: &#123; <span class=\"comment\"># 指标聚合函数名称，top_hits表示返回排在前面的示例</span></span><br><span class=\"line\">        <span class=\"string\">&quot;sort&quot;</span>: [&#123;<span class=\"string\">&quot;price&quot;</span>: &#123;<span class=\"string\">&quot;order&quot;</span>: <span class=\"string\">&quot;desc&quot;</span>&#125;&#125;], <span class=\"comment\"># 排序，按照price字段降序排序</span></span><br><span class=\"line\">        <span class=\"string\">&quot;size&quot;</span>: 3 <span class=\"comment\"># 只返回前3个</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Bucket-Aggregation-桶聚合\">Bucket Aggregation(桶聚合)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照一定的规则，将文档分配到不同的桶中，从而达到分类的目的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ES提供的一些常见的 Bucket Aggregation。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">terms（词条）, range（范围）, date_range（日期范围）, ip_range（IP范围）, missing（缺失）, histogram（直方图）, date_histogram（日期直方图）, geo_distance（地理距离）, significant_terms（重要词条）, composite（组合）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>桶聚合可以用于各种场景，例如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">对数据进行分组统计，比如按照地区、年龄段、性别等字段进行分组统计。</li>\n<li class=\"lvl-4\">对时间序列数据进行时间段分析，比如按照每小时、每天、每月、每季度、每年等时间段进行分析。</li>\n<li class=\"lvl-4\">对各种标签信息分类，并统计其数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"terms（词条）\">terms（词条）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照字段的值进行分组，并统计每个组的数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category字段进行分组，并统计每个组的数量。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_count&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回每个组的数量</span></span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123; <span class=\"comment\"># 桶聚合函数名称，terms表示按照字段的值进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>, <span class=\"comment\"># 按照category字段进行分组，注意不能是text类型，否则会报错</span></span><br><span class=\"line\">        <span class=\"string\">&quot;size&quot;</span>: 10, <span class=\"comment\"># 只返回前10个，默认是10</span></span><br><span class=\"line\">        <span class=\"string\">&quot;order&quot;</span>: &#123;<span class=\"string\">&quot;_count&quot;</span>: <span class=\"string\">&quot;desc&quot;</span>&#125; <span class=\"comment\"># 按照数量降序排序，默认是desc，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>: 15,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>: <span class=\"string\">&quot;eq&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>: null,</span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggregations&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_count&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;doc_count_error_upper_bound&quot;</span>: 0,  <span class=\"comment\"># 错误上界，表示在聚合过程中可能存在一些错误，但错误数量不会超过这个值</span></span><br><span class=\"line\">      <span class=\"string\">&quot;sum_other_doc_count&quot;</span>: 0,         <span class=\"comment\"># 表示在聚合过程中，除了返回的10个bucket，还有其他数量，这个数量就是sum_other_doc_count</span></span><br><span class=\"line\">      <span class=\"string\">&quot;buckets&quot;</span>: [                     <span class=\"comment\"># 返回的bucket</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;electronics&quot;</span>,          <span class=\"comment\"># 分组的key</span></span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 4                 <span class=\"comment\"># 分组的数量</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;books&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;fashion&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;groceries&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;home_appliances&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>限定聚合范围</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;query&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;range&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;price&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;gte&quot;</span>: 100 <span class=\"comment\"># 限定价格范围</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_count&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回每个组的数量</span></span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123; <span class=\"comment\"># 桶聚合函数名称，terms表示按照字段的值进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>, <span class=\"comment\"># 按照category字段进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;size&quot;</span>: 10, <span class=\"comment\"># 只返回前10个，默认是10</span></span><br><span class=\"line\">        <span class=\"string\">&quot;order&quot;</span>: &#123;<span class=\"string\">&quot;_count&quot;</span>: <span class=\"string\">&quot;desc&quot;</span>&#125; <span class=\"comment\"># 按照数量降序排序，默认是desc，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"range（范围）\">range（范围）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照字段的值进行分组，并统计每个组的数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照价格范围进行分组，并统计每个组的数量。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_range&quot;</span>: &#123; <span class=\"comment\"># 自定义名称，返回每个组的数量</span></span><br><span class=\"line\">      <span class=\"string\">&quot;range&quot;</span>: &#123; <span class=\"comment\"># 桶聚合函数名称，range表示按照字段的值进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span>, <span class=\"comment\"># 按照price字段进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;ranges&quot;</span>: [</span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;to&quot;</span>: 100&#125;, <span class=\"comment\"># 小于100</span></span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;from&quot;</span>: 100, <span class=\"string\">&quot;to&quot;</span>: 200&#125;, <span class=\"comment\"># 100-200，包括100，不包括200</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;key&quot;</span>:<span class=\"string\">&quot;&gt;=200&quot;</span>, <span class=\"comment\"># 设定键值，用于区分不同范围</span></span><br><span class=\"line\">            <span class=\"string\">&quot;from&quot;</span>:200 <span class=\"comment\"># 大于等于200</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>: 5,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>: <span class=\"string\">&quot;eq&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>: null,</span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggregations&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_range&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;buckets&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;*-100.0&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;to&quot;</span>: 100,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 6</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;100.0-200.0&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;from&quot;</span>: 100,</span><br><span class=\"line\">          <span class=\"string\">&quot;to&quot;</span>: 200,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;&gt;=200&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;from&quot;</span>: 200,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 6</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"date-range（日期范围）\">date_range（日期范围）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照字段的值进行分组，并统计每个组的数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照日期范围进行分组，并统计每个组的数量。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;date_range&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;date_range&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;created_at&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ranges&quot;</span>: [</span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;to&quot;</span>: <span class=\"string\">&quot;now-3d&quot;</span>&#125;, <span class=\"comment\"># 小于当前时间减去3天</span></span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;from&quot;</span>: <span class=\"string\">&quot;now-3d&quot;</span>,<span class=\"string\">&quot;to&quot;</span>: <span class=\"string\">&quot;now-1d&quot;</span>&#125;, <span class=\"comment\"># 大于当前时间减去3天（包含），小于当前时间减去1天</span></span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;key&quot;</span>:<span class=\"string\">&quot;now-1d&quot;</span>,<span class=\"string\">&quot;from&quot;</span>: <span class=\"string\">&quot;now-1d&quot;</span>&#125; <span class=\"comment\"># 大于当前时间减去1天（包含），并设置键值</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>: 3,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>: <span class=\"string\">&quot;eq&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>: null,</span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggregations&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;date_range&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;buckets&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;*-2025-04-20 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;to&quot;</span>: 1745118857610,</span><br><span class=\"line\">          <span class=\"string\">&quot;to_as_string&quot;</span>: <span class=\"string\">&quot;2025-04-20 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 4</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;2025-04-20 03:14:17-2025-04-22 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;from&quot;</span>: 1745118857610,</span><br><span class=\"line\">          <span class=\"string\">&quot;from_as_string&quot;</span>: <span class=\"string\">&quot;2025-04-20 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;to&quot;</span>: 1745291657610,</span><br><span class=\"line\">          <span class=\"string\">&quot;to_as_string&quot;</span>: <span class=\"string\">&quot;2025-04-22 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 4</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;now-1d&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;from&quot;</span>: 1745291657610,</span><br><span class=\"line\">          <span class=\"string\">&quot;from_as_string&quot;</span>: <span class=\"string\">&quot;2025-04-22 03:14:17&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 4</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日期格式</span></span><br><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;date_range&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;date_range&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;created_at&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ranges&quot;</span>: [</span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;to&quot;</span>: <span class=\"string\">&quot;2025-04-20 00:00:00&quot;</span>&#125;, <span class=\"comment\"># 注意这里的格式必须与字段格式一致</span></span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;from&quot;</span>: <span class=\"string\">&quot;2025-04-20 00:00:00&quot;</span>,<span class=\"string\">&quot;to&quot;</span>: <span class=\"string\">&quot;2025-04-22 00:00:00&quot;</span>&#125;,</span><br><span class=\"line\">          &#123;<span class=\"string\">&quot;key&quot;</span>:<span class=\"string\">&quot;2025-04-22 00:00:00&quot;</span>,<span class=\"string\">&quot;from&quot;</span>: <span class=\"string\">&quot;2025-04-22 00:00:00&quot;</span>&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"histogram（直方图）\">histogram（直方图）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照间隔进行分组，并统计每个组的数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照价格的间隔进行分组，并统计每个组的数量。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_histogram&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;histogram&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;interval&quot;</span>: 500, <span class=\"comment\"># 间隔500</span></span><br><span class=\"line\">        <span class=\"string\">&quot;extended_bounds&quot;</span>:&#123; <span class=\"comment\"># 设置边界</span></span><br><span class=\"line\">          <span class=\"string\">&quot;min&quot;</span>:0, <span class=\"comment\"># 最小值0</span></span><br><span class=\"line\">          <span class=\"string\">&quot;max&quot;</span>:2000 <span class=\"comment\"># 最大值2000</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>: 2,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>: 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>: 12,</span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>: <span class=\"string\">&quot;eq&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>: null,</span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggregations&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_histogram&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;buckets&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: 0,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 8</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: 500,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 1</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: 1000,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 1</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: 1500,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;key&quot;</span>: 2000,</span><br><span class=\"line\">          <span class=\"string\">&quot;doc_count&quot;</span>: 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"top-hits（分桶取前N条）\">top_hits（分桶取前N条）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按照字段的值进行分组，并返回每个组的前N条数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category进行分组，并返回每个组的前3条数据。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_top_hits&quot;</span>: &#123; <span class=\"comment\"># 自定义名称</span></span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>  <span class=\"comment\"># 按照category字段进行分组</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;top_hits&quot;</span>: &#123; <span class=\"comment\"># 自定义名称</span></span><br><span class=\"line\">          <span class=\"string\">&quot;top_hits&quot;</span>: &#123; <span class=\"comment\"># 返回每个组的前3条数据</span></span><br><span class=\"line\">            <span class=\"string\">&quot;size&quot;</span>: 3, <span class=\"comment\"># 返回前3条数据</span></span><br><span class=\"line\">            <span class=\"string\">&quot;sort&quot;</span>: &#123; <span class=\"comment\"># 按照created_at字段进行排序</span></span><br><span class=\"line\">              <span class=\"string\">&quot;created_at&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;order&quot;</span>: <span class=\"string\">&quot;desc&quot;</span> <span class=\"comment\"># 降序</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"子聚合\">子聚合</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>子聚合：在聚合函数中，还可以再定义一个聚合函数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category进行分组，并统计价格信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_buckets&quot;</span>: &#123; <span class=\"comment\"># 自定义名称</span></span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>  <span class=\"comment\"># 按照category字段进行分组</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123; <span class=\"comment\"># 定义子聚合</span></span><br><span class=\"line\">        <span class=\"string\">&quot;price_stats&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;stats&quot;</span>: &#123; <span class=\"comment\"># 统计价格信息</span></span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多层嵌套</span></span><br><span class=\"line\"><span class=\"comment\"># 先按照category进行分组，再按照address进行分组，并统计价格信息</span></span><br><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>:0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_buckets&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>:<span class=\"string\">&quot;category&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;address_buckets&quot;</span>:&#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;terms&quot;</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>:<span class=\"string\">&quot;address.keyword&quot;</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;aggs&quot;</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;price_stats&quot;</span>:&#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;stats&quot;</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;field&quot;</span>:<span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Pipeline-Aggregation-管道聚合\">Pipeline Aggregation(管道聚合)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>支持对聚合分析的结果，再次进行聚合分析。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pipeline 的分析结果会输出到原结果中，根据位置的不同，分为两类：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Sibling - 结果和现有分析结果同级\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">Max，min，Avg &amp; Sum Bucket</li>\n<li class=\"lvl-6\">Stats，Extended Status Bucket</li>\n<li class=\"lvl-6\">Percentiles Bucket</li>\n</ul>\n</li>\n<li class=\"lvl-4\">Parent -结果内嵌到现有的聚合分析结果之中\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">Derivative(求导)</li>\n<li class=\"lvl-6\">Cumultive Sum(累计求和)</li>\n<li class=\"lvl-6\">Moving Function(移动平均值)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Max，min，Avg-Sum-Bucket\">Max，min，Avg &amp; Sum Bucket</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Max，min，Avg &amp; Sum Bucket：对聚合分析的结果进行最大值、最小值、平均值、求和等操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category进行分组求出商品的平均价格，并找出平均价格最低的分组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>:0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_buckets&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>:<span class=\"string\">&quot;category&quot;</span> <span class=\"comment\"># 按照category字段进行分组</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;price_avg&quot;</span>:&#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>:&#123; <span class=\"comment\"># 求价格平均值</span></span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>:<span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;min_price_in_category&quot;</span>:&#123; <span class=\"comment\"># 找出平均价格最低的分组</span></span><br><span class=\"line\">      <span class=\"string\">&quot;min_bucket&quot;</span>:&#123; <span class=\"comment\"># 对聚合结果进行最小值操作</span></span><br><span class=\"line\">        <span class=\"string\">&quot;buckets_path&quot;</span>:<span class=\"string\">&quot;category_buckets&gt;price_avg&quot;</span> <span class=\"comment\"># 指定路径，对category_buckets聚合结果中的price_avg字段进行最小值操作</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Stats，Extended-Status-Bucket\">Stats，Extended Status Bucket</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stats，Extended Status Bucket：对聚合分析的结果进行统计操作，包括最大值、最小值、平均值、求和、数量等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category进行分组求出商品的平均价格，并对分组结果进行统计操作</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_buckets&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;size&quot;</span>: 10 <span class=\"comment\"># 指定分组数量</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;avg_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;stats_price_by_job&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;stats_bucket&quot;</span>: &#123; <span class=\"comment\"># 对聚合结果进行统计操作</span></span><br><span class=\"line\">        <span class=\"string\">&quot;buckets_path&quot;</span>: <span class=\"string\">&quot;category_buckets&gt;avg_price&quot;</span> <span class=\"comment\"># 指定路径，对category_buckets聚合结果中的avg_price字段进行统计操作</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Percentiles-Bucket\">Percentiles Bucket</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Percentiles Bucket：对聚合分析的结果进行百分比操作，包括百分比、中位数等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：按照category进行分组求出商品的平均价格，并对分组结果进行百分比操作</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category_buckets&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;category&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;size&quot;</span>: 10</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;avg_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;percentiles_price_by_category&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;percentiles_bucket&quot;</span>: &#123; <span class=\"comment\"># 对聚合结果进行统计操作</span></span><br><span class=\"line\">        <span class=\"string\">&quot;buckets_path&quot;</span>: <span class=\"string\">&quot;category_buckets&gt;avg_price&quot;</span> <span class=\"comment\"># 指定路径，对category_buckets聚合结果中的avg_price字段进行统计操作</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cumulative-Sum\">Cumulative Sum</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Cumulative Sum：对聚合分析的结果进行累计求和操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例: 按照价格进行分组，并统计平均价格信息，对分组结果进行累计求和操作。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_histogram&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;histogram&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;interval&quot;</span>: 500, <span class=\"comment\"># 间隔500</span></span><br><span class=\"line\">        <span class=\"string\">&quot;extended_bounds&quot;</span>:&#123; <span class=\"comment\"># 设置边界</span></span><br><span class=\"line\">          <span class=\"string\">&quot;min&quot;</span>:0, <span class=\"comment\"># 最小值0</span></span><br><span class=\"line\">          <span class=\"string\">&quot;max&quot;</span>:2000 <span class=\"comment\"># 最大值2000</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;avg_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;cumulative_sum_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;cumulative_sum&quot;</span>: &#123; <span class=\"comment\"># 对聚合结果进行累计求和操作</span></span><br><span class=\"line\">            <span class=\"string\">&quot;buckets_path&quot;</span>: <span class=\"string\">&quot;avg_price&quot;</span> <span class=\"comment\"># 指定路径，对avg_price字段进行累计求和操作</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Derivative\">Derivative</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Derivative：对聚合分析的结果进行求导操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Derivative 聚合查询是 Elasticsearch 中的一种高级聚合类型，用于计算某个度量值随时间（或其他顺序字段）变化的速率。它通常用于时间序列分析，以揭示度量值的增减趋势。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：显示每天的平均价格以及平均价格的变化趋势</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_over_time&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;date_histogram&quot;</span>: &#123; <span class=\"comment\"># 按照日期进行分组</span></span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;created_at&quot;</span>, <span class=\"comment\"># 指定字段</span></span><br><span class=\"line\">        <span class=\"string\">&quot;calendar_interval&quot;</span>: <span class=\"string\">&quot;day&quot;</span> <span class=\"comment\"># 指定时间间隔，可用的值：year、quarter、month、week、day、hour、minute、second</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;average_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;price_derivative&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;derivative&quot;</span>: &#123; <span class=\"comment\"># 对聚合结果进行求导操作</span></span><br><span class=\"line\">            <span class=\"string\">&quot;buckets_path&quot;</span>: <span class=\"string\">&quot;average_price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Moving-Function\">Moving Function</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Moving Function：对聚合分析的结果进行移动平均值操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Moving Function 聚合查询是 Elasticsearch 中的一种高级聚合类型，用于计算某个度量值在时间窗口内的移动平均值。它通常用于时间序列分析，以了解度量值的变化趋势。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：计算 price 字段的 7 天移动平均值</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /shopping/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;price_over_time&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;date_histogram&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;created_at&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;calendar_interval&quot;</span>: <span class=\"string\">&quot;day&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;daily_avg_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;avg&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;moving_avg_price&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;moving_fn&quot;</span>: &#123; <span class=\"comment\"># 对聚合结果进行移动平均值操作</span></span><br><span class=\"line\">            <span class=\"string\">&quot;buckets_path&quot;</span>: <span class=\"string\">&quot;daily_avg_price&quot;</span>, <span class=\"comment\"># 指定路径，对daily_avg_price字段进行移动平均值操作</span></span><br><span class=\"line\">            <span class=\"string\">&quot;script&quot;</span>: <span class=\"string\">&quot;MovingFunctions.unweightedAvg(values)&quot;</span>, <span class=\"comment\"># 指定脚本，计算移动平均值</span></span><br><span class=\"line\">            <span class=\"string\">&quot;window&quot;</span>: 7, <span class=\"comment\"># 窗口大小，默认为 10</span></span><br><span class=\"line\">            <span class=\"string\">&quot;shift&quot;</span>: 0 <span class=\"comment\"># 窗口偏移量，默认为 0</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES-聚合性能优化\">ES 聚合性能优化</h2>\n<h3 id=\"索引预排序\">索引预排序</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果是 Elasticsearch 6.X 之后版本，可以在插入数据时对索引进行预排序，而不是在查询时再对索引进行排序，这将提高范围查询（range query）和排序操作的性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>但预排序将增加 Elasticsearch 写入的成本，导致大约 40%-50% 的写性能下降，如果应用场景是更关注写性能的业务，开启索引预排序不是一个很好的选择。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /my_index</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;settings&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;index&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;sort.field&quot;</span>: <span class=\"string\">&quot;create_time&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;sort.order&quot;</span>: <span class=\"string\">&quot;desc&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;mappings&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;properties&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;create_time&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;date&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用分片请求缓存\">使用分片请求缓存</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>聚合语句中，设置：size：0，就会使用分片请求缓存缓存结果。size = 0 的含义是：只返回聚合结果，不返回查询结果。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;remark_agg&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;remark.keyword&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拆分聚合，使聚合并行化\">拆分聚合，使聚合并行化</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 查询条件中同时有多个条件聚合，默认情况下聚合不是并行运行的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当为每个聚合提供自己的查询并执行 msearch 时，性能会有显著提升。</p>\n</li>\n<li class=\"lvl-2\">\n<p>因此，在 CPU 资源不是瓶颈的前提下，如果想缩短响应时间，可以将多个聚合拆分为多个查询，借助：msearch 实现并行聚合。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#常规的多条件聚合实现</span></span><br><span class=\"line\">GET /employees/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;size&quot;</span>: 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;aggs&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;job_agg&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;terms&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;job.keyword&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_salary&quot;</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;max&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;salary&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># msearch 拆分多个语句的聚合实现</span></span><br><span class=\"line\">GET _msearch</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;index&quot;</span>:<span class=\"string\">&quot;employees&quot;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;size&quot;</span>:0,<span class=\"string\">&quot;aggs&quot;</span>:&#123;<span class=\"string\">&quot;job_agg&quot;</span>:&#123;<span class=\"string\">&quot;terms&quot;</span>:&#123;<span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;job.keyword&quot;</span>&#125;&#125;&#125;&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;index&quot;</span>:<span class=\"string\">&quot;employees&quot;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;size&quot;</span>:0,<span class=\"string\">&quot;aggs&quot;</span>:&#123;<span class=\"string\">&quot;max_salary&quot;</span>:&#123;<span class=\"string\">&quot;max&quot;</span>:&#123;<span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;salary&quot;</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Elasticsearch 的 REST APIs：聚合查询 Elasticsearch版本8.17.3 官方文档:REST APIs 官方文档:Aggregations Elasticsearch 的 REST APIs 聚合查询 聚合查询，可以让我们极其方便的实现对索引数据的统计、分析、运算等操作。 基本语法包括以下部分： 查询条件：指定需要聚合的文档，可以使用标准的 Elasticsearch 查询语法，如 term、match、range 等等。 聚合函数：指定要执行的聚合操作，如 sum、avg、min、max、terms、date_histogram 等等。每个聚合命令都会生成一个聚合结果。 聚合嵌套：聚合命令可以嵌套，以便更细粒度地分析数据。 123456789101112131415GET &lt;index_name&gt;/_search&#123; &quot;aggs&quot;: &#123; &quot;&lt;aggs_name&gt;&quot;: &#123; &quot;&lt;agg_type&gt;&quot;: &#123; &quot;field&quot;: &quot;&lt;field_name&gt;&quot; &#125; &#125; &#125;&#125;# 说明 # aggs：聚合的根节点，固定写法 # aggs_name：聚合函数的名称，自己随意定义 # agg_type：聚合种类，比如是桶聚合（terms）或者是指标聚合（avg、sum、min、max等） # field_name：字段名称或者叫域名。 聚合的分类 Metric Aggregation：—些数学运算，可以对文档字段进行统计分析，类比Mysql中的 min(), max(), sum() 操作。 Bucket Aggregation：一些满足特定条件的文档的集合放置到一个桶里，每一个桶关联一个key，类比Mysql中的group by操作。 Pipeline Aggregation：对其他的聚合结果进行二次聚合 示例数据准备 我们需要先准备一些数据，才能进行聚合分析。 创建索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 如果存在先删除curl -X DELETE -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27;# 创建索引curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;settings&quot;:&#123; &quot;number_of_shards&quot;:&quot;1&quot;, &quot;number_of_replicas&quot;:&quot;2&quot; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;category&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;price&quot;:&#123; &quot;type&quot;:&quot;double&quot; &#125;, &quot;count&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125;, &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125;, &quot;remark&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;, &quot;tags&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125; &#125; &#125; &#125;&#x27;# 插入数据curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;1&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;2&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;3&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;4&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;5&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;6&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27; Metric Aggregation(指标聚合) 单值分析︰只输出一个分析结果 min, max, avg, sum 123456789101112131415161718192021222324252627# 最大值、最小值、平均值、总和GET /shopping/_search&#123; &quot;size&quot;: 0, # 不返回文档，只返回聚合结果 &quot;aggs&quot;: &#123; &quot;max_price&quot;: &#123; # 自定义名称，这里返回最大值 &quot;max&quot;: &#123; # 指标聚合函数名称 &quot;field&quot;: &quot;price&quot; # 指标聚合字段 &#125; &#125;, &quot;min_price&quot;: &#123; &quot;min&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125;, &quot;avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125;, &quot;sum_price&quot;: &#123; &quot;sum&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125;&#125; Cardinality（类似distinct Count) 1234567891011GET /shopping/_search&#123; &quot;size&quot;: 0, # 不返回文档，只返回聚合结果 &quot;aggs&quot;: &#123; &quot;cardinality_count&quot;: &#123; # 自定义名称，返回去重后的数量 &quot;cardinality&quot;: &#123; # 指标聚合函数名称，cardinality表示去重 &quot;field&quot;: &quot;category&quot; # 指标聚合字段，去重的字段 &#125; &#125; &#125;&#125; 多值分析:输出多个分析结果 stats（统计）, extended stats 123456789101112131415161718192021222324252627282930313233343536373839GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;stats_price&quot;: &#123; &quot;stats&quot;: &#123; # 指标聚合函数名称，stats表示统计，会返回多个指标 &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125;&#125;# 结果&#123; &quot;took&quot;: 15, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 12, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] # 因为设置size 为 0，所以返回的结果为空 &#125;, &quot;aggregations&quot;: &#123; # 聚合结果 &quot;stats_price&quot;: &#123; # 自定义名称，返回多组聚合结果 &quot;count&quot;: 12, &quot;min&quot;: 3.99, &quot;max&quot;: 1999.99, &quot;avg&quot;: 562.1666666666666, &quot;sum&quot;: 6746 &#125; &#125;&#125; percentile （百分位）, percentile rank 1234567891011121314151617GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;percentile_price&quot;: &#123; &quot;percentiles&quot;: &#123; # 指标聚合函数名称，percentiles表示百分位数聚合计算 &quot;field&quot;: &quot;price&quot;, # 指标聚合字段 &quot;percents&quot;: [1, 5, 25, 50, 75, 95, 99] # 需要计算百分位数的数组 &#125; &#125; &#125;&#125;# 百分位数是一个统计学概念，用于描述一个给定集合的排序值。例如：# 第 1 百分位数表示数据中小于这个值的所有数据占总数的 1%。# 第 50 百分位数（中位数）表示数据中的一半小于这个值，另一半大于这个值。# 第 99 百分位数表示数据中小于这个值的所有数据占总数的 99%。# 通过计算这些百分位数，你可以了解 price 字段在整个shopping索引中的分布情况，从而可以用于数据分析、趋势判断等。 top hits(排在前面的示例) 123456789101112GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;top_hits&quot;: &#123; # 自定义名称，返回排在前面的示例 &quot;top_hits&quot;: &#123; # 指标聚合函数名称，top_hits表示返回排在前面的示例 &quot;sort&quot;: [&#123;&quot;price&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;], # 排序，按照price字段降序排序 &quot;size&quot;: 3 # 只返回前3个 &#125; &#125; &#125;&#125; Bucket Aggregation(桶聚合) 按照一定的规则，将文档分配到不同的桶中，从而达到分类的目的。 ES提供的一些常见的 Bucket Aggregation。 terms（词条）, range（范围）, date_range（日期范围）, ip_range（IP范围）, missing（缺失）, histogram（直方图）, date_histogram（日期直方图）, geo_distance（地理距离）, significant_terms（重要词条）, composite（组合） 桶聚合可以用于各种场景，例如： 对数据进行分组统计，比如按照地区、年龄段、性别等字段进行分组统计。 对时间序列数据进行时间段分析，比如按照每小时、每天、每月、每季度、每年等时间段进行分析。 对各种标签信息分类，并统计其数量。 terms（词条） 按照字段的值进行分组，并统计每个组的数量。 示例：按照category字段进行分组，并统计每个组的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;category_count&quot;: &#123; # 自定义名称，返回每个组的数量 &quot;terms&quot;: &#123; # 桶聚合函数名称，terms表示按照字段的值进行分组 &quot;field&quot;: &quot;category&quot;, # 按照category字段进行分组，注意不能是text类型，否则会报错 &quot;size&quot;: 10, # 只返回前10个，默认是10 &quot;order&quot;: &#123;&quot;_count&quot;: &quot;desc&quot;&#125; # 按照数量降序排序，默认是desc，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序 &#125; &#125; &#125;&#125;# 结果&#123; &quot;took&quot;: 15, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 12, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;category_count&quot;: &#123; &quot;doc_count_error_upper_bound&quot;: 0, # 错误上界，表示在聚合过程中可能存在一些错误，但错误数量不会超过这个值 &quot;sum_other_doc_count&quot;: 0, # 表示在聚合过程中，除了返回的10个bucket，还有其他数量，这个数量就是sum_other_doc_count &quot;buckets&quot;: [ # 返回的bucket &#123; &quot;key&quot;: &quot;electronics&quot;, # 分组的key &quot;doc_count&quot;: 4 # 分组的数量 &#125;, &#123; &quot;key&quot;: &quot;books&quot;, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: &quot;fashion&quot;, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: &quot;groceries&quot;, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: &quot;home_appliances&quot;, &quot;doc_count&quot;: 2 &#125; ] &#125; &#125;&#125; 限定聚合范围 1234567891011121314151617181920GET /shopping/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gte&quot;: 100 # 限定价格范围 &#125; &#125; &#125;, &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;category_count&quot;: &#123; # 自定义名称，返回每个组的数量 &quot;terms&quot;: &#123; # 桶聚合函数名称，terms表示按照字段的值进行分组 &quot;field&quot;: &quot;category&quot;, # 按照category字段进行分组 &quot;size&quot;: 10, # 只返回前10个，默认是10 &quot;order&quot;: &#123;&quot;_count&quot;: &quot;desc&quot;&#125; # 按照数量降序排序，默认是desc，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序 &#125; &#125; &#125;&#125; range（范围） 按照字段的值进行分组，并统计每个组的数量。 示例：按照价格范围进行分组，并统计每个组的数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_range&quot;: &#123; # 自定义名称，返回每个组的数量 &quot;range&quot;: &#123; # 桶聚合函数名称，range表示按照字段的值进行分组 &quot;field&quot;: &quot;price&quot;, # 按照price字段进行分组 &quot;ranges&quot;: [ &#123;&quot;to&quot;: 100&#125;, # 小于100 &#123;&quot;from&quot;: 100, &quot;to&quot;: 200&#125;, # 100-200，包括100，不包括200 &#123; &quot;key&quot;:&quot;&gt;=200&quot;, # 设定键值，用于区分不同范围 &quot;from&quot;:200 # 大于等于200 &#125; ] &#125; &#125; &#125;&#125;# 结果&#123; &quot;took&quot;: 5, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 12, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;price_range&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;*-100.0&quot;, &quot;to&quot;: 100, &quot;doc_count&quot;: 6 &#125;, &#123; &quot;key&quot;: &quot;100.0-200.0&quot;, &quot;from&quot;: 100, &quot;to&quot;: 200, &quot;doc_count&quot;: 0 &#125;, &#123; &quot;key&quot;: &quot;&gt;=200&quot;, &quot;from&quot;: 200, &quot;doc_count&quot;: 6 &#125; ] &#125; &#125;&#125; date_range（日期范围） 按照字段的值进行分组，并统计每个组的数量。 示例：按照日期范围进行分组，并统计每个组的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;date_range&quot;: &#123; &quot;date_range&quot;: &#123; &quot;field&quot;: &quot;created_at&quot;, &quot;ranges&quot;: [ &#123;&quot;to&quot;: &quot;now-3d&quot;&#125;, # 小于当前时间减去3天 &#123;&quot;from&quot;: &quot;now-3d&quot;,&quot;to&quot;: &quot;now-1d&quot;&#125;, # 大于当前时间减去3天（包含），小于当前时间减去1天 &#123;&quot;key&quot;:&quot;now-1d&quot;,&quot;from&quot;: &quot;now-1d&quot;&#125; # 大于当前时间减去1天（包含），并设置键值 ] &#125; &#125; &#125;&#125;# 结果&#123; &quot;took&quot;: 3, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 12, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;date_range&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;*-2025-04-20 03:14:17&quot;, &quot;to&quot;: 1745118857610, &quot;to_as_string&quot;: &quot;2025-04-20 03:14:17&quot;, &quot;doc_count&quot;: 4 &#125;, &#123; &quot;key&quot;: &quot;2025-04-20 03:14:17-2025-04-22 03:14:17&quot;, &quot;from&quot;: 1745118857610, &quot;from_as_string&quot;: &quot;2025-04-20 03:14:17&quot;, &quot;to&quot;: 1745291657610, &quot;to_as_string&quot;: &quot;2025-04-22 03:14:17&quot;, &quot;doc_count&quot;: 4 &#125;, &#123; &quot;key&quot;: &quot;now-1d&quot;, &quot;from&quot;: 1745291657610, &quot;from_as_string&quot;: &quot;2025-04-22 03:14:17&quot;, &quot;doc_count&quot;: 4 &#125; ] &#125; &#125;&#125;# 日期格式GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;date_range&quot;: &#123; &quot;date_range&quot;: &#123; &quot;field&quot;: &quot;created_at&quot;, &quot;ranges&quot;: [ &#123;&quot;to&quot;: &quot;2025-04-20 00:00:00&quot;&#125;, # 注意这里的格式必须与字段格式一致 &#123;&quot;from&quot;: &quot;2025-04-20 00:00:00&quot;,&quot;to&quot;: &quot;2025-04-22 00:00:00&quot;&#125;, &#123;&quot;key&quot;:&quot;2025-04-22 00:00:00&quot;,&quot;from&quot;: &quot;2025-04-22 00:00:00&quot;&#125; ] &#125; &#125; &#125;&#125; histogram（直方图） 按照间隔进行分组，并统计每个组的数量。 示例：按照价格的间隔进行分组，并统计每个组的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_histogram&quot;: &#123; &quot;histogram&quot;: &#123; &quot;field&quot;: &quot;price&quot;, &quot;interval&quot;: 500, # 间隔500 &quot;extended_bounds&quot;:&#123; # 设置边界 &quot;min&quot;:0, # 最小值0 &quot;max&quot;:2000 # 最大值2000 &#125; &#125; &#125; &#125;&#125;# 结果&#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 12, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;price_histogram&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: 0, &quot;doc_count&quot;: 8 &#125;, &#123; &quot;key&quot;: 500, &quot;doc_count&quot;: 1 &#125;, &#123; &quot;key&quot;: 1000, &quot;doc_count&quot;: 1 &#125;, &#123; &quot;key&quot;: 1500, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: 2000, &quot;doc_count&quot;: 0 &#125; ] &#125; &#125;&#125; top_hits（分桶取前N条） 按照字段的值进行分组，并返回每个组的前N条数据。 示例：按照category进行分组，并返回每个组的前3条数据。 1234567891011121314151617181920212223GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_top_hits&quot;: &#123; # 自定义名称 &quot;terms&quot;: &#123; &quot;field&quot;: &quot;category&quot; # 按照category字段进行分组 &#125;, &quot;aggs&quot;: &#123; &quot;top_hits&quot;: &#123; # 自定义名称 &quot;top_hits&quot;: &#123; # 返回每个组的前3条数据 &quot;size&quot;: 3, # 返回前3条数据 &quot;sort&quot;: &#123; # 按照created_at字段进行排序 &quot;created_at&quot;: &#123; &quot;order&quot;: &quot;desc&quot; # 降序 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 子聚合 子聚合：在聚合函数中，还可以再定义一个聚合函数。 示例：按照category进行分组，并统计价格信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;category_buckets&quot;: &#123; # 自定义名称 &quot;terms&quot;: &#123; &quot;field&quot;: &quot;category&quot; # 按照category字段进行分组 &#125; &quot;aggs&quot;: &#123; # 定义子聚合 &quot;price_stats&quot;: &#123; &quot;stats&quot;: &#123; # 统计价格信息 &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125;# 多层嵌套# 先按照category进行分组，再按照address进行分组，并统计价格信息GET /shopping/_search&#123; &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;category_buckets&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;:&quot;category&quot; &#125;, &quot;aggs&quot;:&#123; &quot;address_buckets&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;:&quot;address.keyword&quot; &#125;, &quot;aggs&quot;:&#123; &quot;price_stats&quot;:&#123; &quot;stats&quot;:&#123; &quot;field&quot;:&quot;price&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; Pipeline Aggregation(管道聚合) 支持对聚合分析的结果，再次进行聚合分析。 Pipeline 的分析结果会输出到原结果中，根据位置的不同，分为两类： Sibling - 结果和现有分析结果同级 Max，min，Avg &amp; Sum Bucket Stats，Extended Status Bucket Percentiles Bucket Parent -结果内嵌到现有的聚合分析结果之中 Derivative(求导) Cumultive Sum(累计求和) Moving Function(移动平均值) Max，min，Avg &amp; Sum Bucket Max，min，Avg &amp; Sum Bucket：对聚合分析的结果进行最大值、最小值、平均值、求和等操作。 示例：按照category进行分组求出商品的平均价格，并找出平均价格最低的分组 1234567891011121314151617181920212223GET /shopping/_search&#123; &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;category_buckets&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;:&quot;category&quot; # 按照category字段进行分组 &#125;, &quot;aggs&quot;:&#123; &quot;price_avg&quot;:&#123; &quot;avg&quot;:&#123; # 求价格平均值 &quot;field&quot;:&quot;price&quot; &#125; &#125; &#125; &#125;, &quot;min_price_in_category&quot;:&#123; # 找出平均价格最低的分组 &quot;min_bucket&quot;:&#123; # 对聚合结果进行最小值操作 &quot;buckets_path&quot;:&quot;category_buckets&gt;price_avg&quot; # 指定路径，对category_buckets聚合结果中的price_avg字段进行最小值操作 &#125; &#125; &#125;&#125; Stats，Extended Status Bucket Stats，Extended Status Bucket：对聚合分析的结果进行统计操作，包括最大值、最小值、平均值、求和、数量等。 示例：按照category进行分组求出商品的平均价格，并对分组结果进行统计操作 123456789101112131415161718192021222324GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;category_buckets&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;category&quot;, &quot;size&quot;: 10 # 指定分组数量 &#125;, &quot;aggs&quot;: &#123; &quot;avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125;, &quot;stats_price_by_job&quot;:&#123; &quot;stats_bucket&quot;: &#123; # 对聚合结果进行统计操作 &quot;buckets_path&quot;: &quot;category_buckets&gt;avg_price&quot; # 指定路径，对category_buckets聚合结果中的avg_price字段进行统计操作 &#125; &#125; &#125;&#125; Percentiles Bucket Percentiles Bucket：对聚合分析的结果进行百分比操作，包括百分比、中位数等。 示例：按照category进行分组求出商品的平均价格，并对分组结果进行百分比操作 123456789101112131415161718192021222324GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;category_buckets&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;category&quot;, &quot;size&quot;: 10 &#125;, &quot;aggs&quot;: &#123; &quot;avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125;, &quot;percentiles_price_by_category&quot;:&#123; &quot;percentiles_bucket&quot;: &#123; # 对聚合结果进行统计操作 &quot;buckets_path&quot;: &quot;category_buckets&gt;avg_price&quot; # 指定路径，对category_buckets聚合结果中的avg_price字段进行统计操作 &#125; &#125; &#125;&#125; Cumulative Sum Cumulative Sum：对聚合分析的结果进行累计求和操作。 示例: 按照价格进行分组，并统计平均价格信息，对分组结果进行累计求和操作。 12345678910111213141516171819202122232425262728GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_histogram&quot;: &#123; &quot;histogram&quot;: &#123; &quot;field&quot;: &quot;price&quot;, &quot;interval&quot;: 500, # 间隔500 &quot;extended_bounds&quot;:&#123; # 设置边界 &quot;min&quot;:0, # 最小值0 &quot;max&quot;:2000 # 最大值2000 &#125; &#125;, &quot;aggs&quot;: &#123; &quot;avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125;, &quot;cumulative_sum_price&quot;: &#123; &quot;cumulative_sum&quot;: &#123; # 对聚合结果进行累计求和操作 &quot;buckets_path&quot;: &quot;avg_price&quot; # 指定路径，对avg_price字段进行累计求和操作 &#125; &#125; &#125; &#125; &#125;&#125; Derivative Derivative：对聚合分析的结果进行求导操作。 Derivative 聚合查询是 Elasticsearch 中的一种高级聚合类型，用于计算某个度量值随时间（或其他顺序字段）变化的速率。它通常用于时间序列分析，以揭示度量值的增减趋势。 示例：显示每天的平均价格以及平均价格的变化趋势 123456789101112131415161718192021222324GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_over_time&quot;: &#123; &quot;date_histogram&quot;: &#123; # 按照日期进行分组 &quot;field&quot;: &quot;created_at&quot;, # 指定字段 &quot;calendar_interval&quot;: &quot;day&quot; # 指定时间间隔，可用的值：year、quarter、month、week、day、hour、minute、second &#125;, &quot;aggs&quot;: &#123; &quot;average_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125;, &quot;price_derivative&quot;: &#123; &quot;derivative&quot;: &#123; # 对聚合结果进行求导操作 &quot;buckets_path&quot;: &quot;average_price&quot; &#125; &#125; &#125; &#125; &#125;&#125; Moving Function Moving Function：对聚合分析的结果进行移动平均值操作。 Moving Function 聚合查询是 Elasticsearch 中的一种高级聚合类型，用于计算某个度量值在时间窗口内的移动平均值。它通常用于时间序列分析，以了解度量值的变化趋势。 示例：计算 price 字段的 7 天移动平均值 123456789101112131415161718192021222324252627GET /shopping/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;price_over_time&quot;: &#123; &quot;date_histogram&quot;: &#123; &quot;field&quot;: &quot;created_at&quot;, &quot;calendar_interval&quot;: &quot;day&quot; &#125;, &quot;aggs&quot;: &#123; &quot;daily_avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125;, &quot;moving_avg_price&quot;: &#123; &quot;moving_fn&quot;: &#123; # 对聚合结果进行移动平均值操作 &quot;buckets_path&quot;: &quot;daily_avg_price&quot;, # 指定路径，对daily_avg_price字段进行移动平均值操作 &quot;script&quot;: &quot;MovingFunctions.unweightedAvg(values)&quot;, # 指定脚本，计算移动平均值 &quot;window&quot;: 7, # 窗口大小，默认为 10 &quot;shift&quot;: 0 # 窗口偏移量，默认为 0 &#125; &#125; &#125; &#125; &#125;&#125; ES 聚合性能优化 索引预排序 如果是 Elasticsearch 6.X 之后版本，可以在插入数据时对索引进行预排序，而不是在查询时再对索引进行排序，这将提高范围查询（range query）和排序操作的性能。 但预排序将增加 Elasticsearch 写入的成本，导致大约 40%-50% 的写性能下降，如果应用场景是更关注写性能的业务，开启索引预排序不是一个很好的选择。 12345678910111213141516PUT /my_index&#123; &quot;settings&quot;: &#123; &quot;index&quot;:&#123; &quot;sort.field&quot;: &quot;create_time&quot;, &quot;sort.order&quot;: &quot;desc&quot; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;create_time&quot;:&#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;&#125; 使用分片请求缓存 聚合语句中，设置：size：0，就会使用分片请求缓存缓存结果。size = 0 的含义是：只返回聚合结果，不返回查询结果。 1234567891011GET /my_index/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;remark_agg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;remark.keyword&quot; &#125; &#125; &#125;&#125; 拆分聚合，使聚合并行化 Elasticsearch 查询条件中同时有多个条件聚合，默认情况下聚合不是并行运行的。 当为每个聚合提供自己的查询并执行 msearch 时，性能会有显著提升。 因此，在 CPU 资源不是瓶颈的前提下，如果想缩短响应时间，可以将多个聚合拆分为多个查询，借助：msearch 实现并行聚合。 1234567891011121314151617181920212223#常规的多条件聚合实现GET /employees/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;job_agg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;job.keyword&quot; &#125; &#125;, &quot;max_salary&quot;:&#123; &quot;max&quot;: &#123; &quot;field&quot;: &quot;salary&quot; &#125; &#125; &#125;&#125;# msearch 拆分多个语句的聚合实现GET _msearch&#123;&quot;index&quot;:&quot;employees&quot;&#125;&#123;&quot;size&quot;:0,&quot;aggs&quot;:&#123;&quot;job_agg&quot;:&#123;&quot;terms&quot;:&#123;&quot;field&quot;: &quot;job.keyword&quot;&#125;&#125;&#125;&#125;&#123;&quot;index&quot;:&quot;employees&quot;&#125;&#123;&quot;size&quot;:0,&quot;aggs&quot;:&#123;&quot;max_salary&quot;:&#123;&quot;max&quot;:&#123;&quot;field&quot;: &quot;salary&quot;&#125;&#125;&#125;&#125;","summary":"摘要 本文介绍 Elasticsearch 的 REST APIs：聚合查询 Elasticsearch版本8.17.3 官方文档:REST APIs 官方文档:Aggregations Elasticsearch 的 REST APIs","date_published":"2025-04-22T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]},{"id":"https://blog.hanqunfeng.com/2025/04/17/elasticsearch-05-api/","url":"https://blog.hanqunfeng.com/2025/04/17/elasticsearch-05-api/","title":"Elasticsearch 的 REST APIs","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Elasticsearch 的 REST APIs</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/rest-apis.html\">官方文档:REST APIs</a></p>\n</li>\n<li class=\"lvl-2\">\n<a href=\"/2025/04/22/elasticsearch-06-api-aggs/\" title=\"Elasticsearch 的 REST APIs:聚合查询\">Elasticsearch 的 REST APIs:聚合查询</a>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"返回内容格式化\">返回内容格式化</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>返回json信息格式: <code>?pretty</code> 输出格式化后的json，比如：<code>curl http://localhost:9200/_cluster/health?pretty</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>返回行信息格式: <code>?v</code> 输出内容上方会加上标题行，比如：<code>curl http://localhost:9200/_cat/health?v</code></p>\n</li>\n</ul>\n<h2 id=\"CAT-APIs\">CAT APIs</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 提供了 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/cat.html\">CAT APIs</a>，它们提供了一种简单的方式来查看集群状态和集群中的各种资源，比如索引、分片、节点等。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET     /_cat/health             <span class=\"comment\">#查看集群当前状态：红、黄、绿</span></span><br><span class=\"line\">GET     /_cat/master             <span class=\"comment\">#查看master节点信息</span></span><br><span class=\"line\">GET     /_cat/nodes              <span class=\"comment\">#查看所有节点信息</span></span><br><span class=\"line\">GET     /_cat/plugins            <span class=\"comment\">#查看集群各个节点上的plugin信息</span></span><br><span class=\"line\">GET     /_cat/indices            <span class=\"comment\">#查看集群中所有index的详细信息</span></span><br><span class=\"line\">GET     /_cat/indices/&#123;index&#125;    <span class=\"comment\">#查看集群中指定index的详细信息，index：索引名称</span></span><br><span class=\"line\">GET     /_cat/allocation         <span class=\"comment\">#查看单节点的shard分配整体情况</span></span><br><span class=\"line\">GET     /_cat/shards             <span class=\"comment\">#查看各shard的详细情况</span></span><br><span class=\"line\">GET     /_cat/shards/&#123;index&#125;     <span class=\"comment\">#查看指定分片的详细情况</span></span><br><span class=\"line\">GET     /_cat/segments           <span class=\"comment\">#查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘</span></span><br><span class=\"line\">GET     /_cat/segments/&#123;index&#125;   <span class=\"comment\">#查看指定index的segment详细信息</span></span><br><span class=\"line\">GET     /_cat/count              <span class=\"comment\">#查看当前集群的doc数量</span></span><br><span class=\"line\">GET     /_cat/count/&#123;index&#125;      <span class=\"comment\">#查看指定索引的doc数量</span></span><br><span class=\"line\">GET     /_cat/recovery           <span class=\"comment\">#查看集群内每个shard的recovery过程.调整replica。</span></span><br><span class=\"line\">GET     /_cat/recovery/&#123;index&#125;   <span class=\"comment\">#查看指定索引shard的recovery过程</span></span><br><span class=\"line\">GET     /_cat/pending_tasks      <span class=\"comment\">#查看当前集群的pending task</span></span><br><span class=\"line\">GET     /_cat/aliases            <span class=\"comment\">#查看集群中所有alias信息,路由配置等</span></span><br><span class=\"line\">GET     /_cat/aliases/&#123;<span class=\"built_in\">alias</span>&#125;    <span class=\"comment\">#查看指定索引的alias信息</span></span><br><span class=\"line\">GET     /_cat/thread_pool        <span class=\"comment\">#查看集群各节点内部不同类型的threadpool的统计信息,</span></span><br><span class=\"line\">GET     /_cat/fielddata          <span class=\"comment\">#查看当前集群各个节点的fielddata内存使用情况</span></span><br><span class=\"line\">GET     /_cat/fielddata/&#123;fields&#125; <span class=\"comment\">#查看指定field的内存使用情况,里面传field属性对应的值</span></span><br><span class=\"line\">GET     /_cat/nodeattrs          <span class=\"comment\">#查看单节点的自定义属性</span></span><br><span class=\"line\">GET     /_cat/repositories       <span class=\"comment\">#输出集群中注册快照存储库</span></span><br><span class=\"line\">GET     /_cat/templates          <span class=\"comment\">#输出当前正在存在的模板信息</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Cluster-APIs\">Cluster APIs</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 提供了一系列的 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/cluster.html\">Cluster APIs</a>，它们提供了管理和监控集群状态的功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET     /_cluster/health            <span class=\"comment\"># 获取集群的健康状态信息，包括了集群总体的状况如status、number_of_nodes等。</span></span><br><span class=\"line\">GET     /_cluster/stats             <span class=\"comment\"># 提供整个集群层面的统计信息，包含索引、节点和其他高级指标。</span></span><br><span class=\"line\">GET     /_cluster/state             <span class=\"comment\"># 显示集群元数据的状态，包括设置、块、路由表及元数据等，允许用户查看集群的当前视图。</span></span><br><span class=\"line\">POST    /_cluster/reroute           <span class=\"comment\"># POST请求，用于手动改变分片分配情况，可以实现如迁移分片、取消分配等操作。</span></span><br><span class=\"line\">GET     /_cluster/nodes/hot_threads <span class=\"comment\"># 返回集群中各个节点“最热”的线程堆栈跟踪，默认显示前三个CPU时间最长的线程。</span></span><br><span class=\"line\">GET     /_cluster/allocation/explain <span class=\"comment\"># 解释为何某个分片被如此分配，并提供如何调整的建议。</span></span><br><span class=\"line\">GET     /_cluster/pending_tasks     <span class=\"comment\"># 列出所有等待执行的任务列表。</span></span><br><span class=\"line\">GET     /_cluster/settings          <span class=\"comment\"># 查看整个集群级别的设置。</span></span><br><span class=\"line\">PUT     /_cluster/settings          <span class=\"comment\"># 更新整个集群级别的设置。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Index-APIs\">Index APIs</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 提供了 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/indices.html\">Index APIs</a>，它们提供了对索引的创建、更新、查询和删除等操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># 这里 shopping 为索引名称，但此时没有为索引设置分片策略，也没有设置字段信息</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;shards_acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;index&quot;</span>:<span class=\"string\">&quot;shopping&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建索引并设置索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;settings&quot;:&#123;&quot;number_of_shards&quot;:&quot;1&quot;,&quot;number_of_replicas&quot;:&quot;2&quot;&#125;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;shards_acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;index&quot;</span>:<span class=\"string\">&quot;shopping&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建并映射索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># 这里设置索引分片数量为1，副本数量为2，并设置字段信息</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;settings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_shards&quot;:&quot;1&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_replicas&quot;:&quot;2&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;mappings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;properties&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;title&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;text&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;category&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;price&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;double&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;count&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;integer&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\">## settings: 这个参数用于配置索引的设置，包括分片数量和副本数量。</span></span><br><span class=\"line\"><span class=\"comment\">### number_of_shards: 这个参数指定了索引中分片的数量。在这个例子中，number_of_shards 设置为 1，意味着索引将只有一个主分片。</span></span><br><span class=\"line\"><span class=\"comment\">### number_of_replicas: 这个参数指定了每个主分片的副本数量。在这个例子中，number_of_replicas 设置为 2，意味着每个主分片将有两个副本。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## mappings: 这个参数用于定义索引中的字段和字段类型。</span></span><br><span class=\"line\"><span class=\"comment\">### properties: 这个参数定义了索引中的字段和字段类型。在这个例子中，有四个字段：title、category、images 和 price。</span></span><br><span class=\"line\"><span class=\"comment\">### title: 这个字段的类型是 text，表示它是一个全文检索字段。text 适合存储长文本数据，并支持全文搜索。</span></span><br><span class=\"line\"><span class=\"comment\">### category: 这个字段的类型是 keyword，表示它是一个关键字字段，不支持全文检索。keyword 适合存储不需要分词的短文本数据（如标签、类别等），并且可以用于聚合和过滤。</span></span><br><span class=\"line\"><span class=\"comment\">### price: 这个字段的类型是 double，表示它是一个数字字段。double 表示这是一个双精度浮点数字段，适合存储数值数据，如价格</span></span><br><span class=\"line\"><span class=\"comment\">### count: 这个字段的类型是 integer，表示它是一个整数字段。integer 表示这是一个整数字段，适合存储整数数据，如商品数量等。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;shards_acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;index&quot;</span>:<span class=\"string\">&quot;shopping&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>更新索引映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;/_mapping</span></span><br><span class=\"line\"><span class=\"comment\"># 注意该api只能增加新的字段，不能修改已有字段，如果要修改源字段类型或者分词器类型，下文会介绍</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_mapping&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;properties&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;remark&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;:&quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;:&quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;search_analyzer&quot;:&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;address&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;keyword&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;tags&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># 这里为索引添加了4个字段</span></span><br><span class=\"line\"><span class=\"comment\"># remark：新增字段，类型为text，分词器为ik_max_word，搜索分词器为ik_smart</span></span><br><span class=\"line\">  <span class=\"comment\"># analyzer: 索引分词器</span></span><br><span class=\"line\">  <span class=\"comment\"># search_analyzer：搜索分词器</span></span><br><span class=\"line\">  <span class=\"comment\"># ik_max_word：中文分词器，将句子拆分为最多词元，适合长句子</span></span><br><span class=\"line\">  <span class=\"comment\"># ik_smart：中文分词器，将句子拆分为最少词元，适合短句子</span></span><br><span class=\"line\"><span class=\"comment\"># address：新增字段，类型为text，分词器为ik_max_word，搜索分词器未指定，默认与分词器同一个，这里还为address添加了keyword字段，用于存储原始数据，以支持精确搜索</span></span><br><span class=\"line\"><span class=\"comment\"># tags：新增字段，类型为keyword，不支持分词，适合存储短文本数据（如标签、类别等），并且可以用于聚合和过滤，可以存储数组</span></span><br><span class=\"line\"><span class=\"comment\"># created_at：新增字段，类型为date，格式为yyyy-MM-dd HH:mm:ss</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>更新索引设置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;/_settings</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这里不能更新number_of_shards</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_settings&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;number_of_replicas&quot;:&quot;1&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看指定索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping?pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;shopping&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;aliases&quot;</span> : &#123; &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;mappings&quot;</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;properties&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;address&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;fields&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;keyword&quot;</span> : &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;analyzer&quot;</span> : <span class=\"string\">&quot;ik_max_word&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;category&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;count&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;integer&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;created_at&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;date&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;format&quot;</span> : <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;price&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;double&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;remark&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;analyzer&quot;</span> : <span class=\"string\">&quot;ik_max_word&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;search_analyzer&quot;</span> : <span class=\"string\">&quot;ik_smart&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;tags&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;title&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;settings&quot;</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;index&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;routing&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;allocation&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;include&quot;</span> : &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;_tier_preference&quot;</span> : <span class=\"string\">&quot;data_content&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;number_of_shards&quot;</span> : <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;provided_name&quot;</span> : <span class=\"string\">&quot;shopping&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;creation_date&quot;</span> : <span class=\"string\">&quot;1745291743120&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;number_of_replicas&quot;</span> : <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uuid&quot;</span> : <span class=\"string\">&quot;Y1IWrdlQTUm-CbbIWweSxQ&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;version&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;created&quot;</span> : <span class=\"string\">&quot;8525000&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看索引设置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;/_settings</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_settings?pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;shopping&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;mappings&quot;</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;properties&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;address&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;fields&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;keyword&quot;</span> : &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;analyzer&quot;</span> : <span class=\"string\">&quot;ik_max_word&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;category&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;count&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;integer&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;created_at&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;date&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;format&quot;</span> : <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;price&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;double&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;remark&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;analyzer&quot;</span> : <span class=\"string\">&quot;ik_max_word&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;search_analyzer&quot;</span> : <span class=\"string\">&quot;ik_smart&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;tags&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;title&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看字段映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;/_mapping/field/&lt;field&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># shopping 为索引名称，title 为字段名称</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_mapping/field/title?pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;shopping&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;mappings&quot;</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;title&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;full_name&quot;</span> : <span class=\"string\">&quot;title&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;mapping&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;title&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;text&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>判断索引是否存在</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 -I 参数来发送 HEAD 请求，可以获取响应头而不必下载响应体。</span></span><br><span class=\"line\"><span class=\"comment\"># HEAD /&lt;target&gt;</span></span><br><span class=\"line\">curl -I -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">X-elastic-product: Elasticsearch</span><br><span class=\"line\">content-type: application/json</span><br><span class=\"line\">content-length: 603</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这个命令不会返回响应体，但它的 HTTP 响应代码可以告诉你索引的存在情况：</span></span><br><span class=\"line\">  <span class=\"comment\"># 200 OK 表示索引存在。</span></span><br><span class=\"line\">  <span class=\"comment\"># 404 Not Found 表示索引不存在。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># DELETE /&lt;target&gt;</span></span><br><span class=\"line\">curl -X DELETE -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为索引创建别名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意：不同索引可以有相同名称的别名，所以在数据结构一致的情况下，我们可以为不同的索引创建相同的别名，然后根据别名进行数据查询</span></span><br><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_alias/&lt;alias&gt;</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用如下方法</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_aliases&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;actions&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">      &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;add&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;index&quot;: &quot;shopping&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;alias&quot;: &quot;shopping_alias2&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    ]</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看索引别名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;/_alias/&lt;alias&gt;</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias?pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;shopping&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;aliases&quot;</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;shopping_alias&quot;</span> : &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前索引的所有别名</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_alias?pretty&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有索引的别名</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_alias?pretty&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为索引删除别名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># DELETE /&lt;target&gt;/_alias/&lt;alias&gt;</span></span><br><span class=\"line\">curl -X DELETE -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何修改索引字段类型或分词器类型？\">如何修改索引字段类型或分词器类型？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建新的索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里为title字段增加分词器</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping_new&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;settings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_shards&quot;:&quot;1&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;number_of_replicas&quot;:&quot;2&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;mappings&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;properties&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;category&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;price&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;double&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;count&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;integer&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;title&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;:&quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;analyzer&quot;:&quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;search_analyzer&quot;:&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;remark&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;:&quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;:&quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;search_analyzer&quot;:&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;address&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;keyword&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;tags&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将原索引的数据迁移到新索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_reindex&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;source&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;index&quot;: &quot;shopping&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;dest&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;index&quot;: &quot;shopping_new&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;took&quot;</span>:101,<span class=\"string\">&quot;timed_out&quot;</span>:<span class=\"literal\">false</span>,<span class=\"string\">&quot;total&quot;</span>:2,<span class=\"string\">&quot;updated&quot;</span>:0,<span class=\"string\">&quot;created&quot;</span>:2,<span class=\"string\">&quot;deleted&quot;</span>:0,<span class=\"string\">&quot;batches&quot;</span>:1,<span class=\"string\">&quot;version_conflicts&quot;</span>:0,<span class=\"string\">&quot;noops&quot;</span>:0,<span class=\"string\">&quot;retries&quot;</span>:&#123;<span class=\"string\">&quot;bulk&quot;</span>:0,<span class=\"string\">&quot;search&quot;</span>:0&#125;,<span class=\"string\">&quot;throttled_millis&quot;</span>:0,<span class=\"string\">&quot;requests_per_second&quot;</span>:-1.0,<span class=\"string\">&quot;throttled_until_millis&quot;</span>:0,<span class=\"string\">&quot;failures&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除原索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X DELETE -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为新索引创建别名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping_new/_alias/shopping&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;acknowledged&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;errors&quot;</span>:<span class=\"literal\">false</span>&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据增删改基本操作\">数据增删改基本操作</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新增数据</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">1.为指定索引插入一条数据(_doc方式：不指定id默认随机字符串)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># _doc 的方式创建索引数据时，可以不指定id，默认会创建新的id，id类型为随机字符串</span></span><br><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_doc</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_doc?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;category&quot;: &quot;electronics&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;price&quot;: 999.99,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;count&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;title&quot;: &quot;Smartphone X - 128GB&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;_index&quot;</span> : <span class=\"string\">&quot;shopping_new&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_id&quot;</span> : <span class=\"string\">&quot;sImNW5YBmgASmV9McVvI&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_version&quot;</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">&quot;result&quot;</span> : <span class=\"string\">&quot;created&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span> : 3,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span> : 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;_seq_no&quot;</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">&quot;_primary_term&quot;</span> : 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">2.为指定索引插入一条数据(_doc方式：指定id)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># _doc 的方式创建索引数据时，如果指定id，再次执行时会先删除原数据再创建新数据，所以必须全量更新才行。</span></span><br><span class=\"line\"><span class=\"comment\"># PUT /&lt;target&gt;/_doc</span></span><br><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_doc/100?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;category&quot;: &quot;electronics&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;price&quot;: 999.99,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;count&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;title&quot;: &quot;Smartphone X - 128GB&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;_index&quot;</span> : <span class=\"string\">&quot;shopping_new&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_id&quot;</span> : <span class=\"string\">&quot;100&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_version&quot;</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">&quot;result&quot;</span> : <span class=\"string\">&quot;created&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span> : 3,</span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span> : 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;_seq_no&quot;</span> : 2,</span><br><span class=\"line\">  <span class=\"string\">&quot;_primary_term&quot;</span> : 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">\n<p>3.为指定索引插入一条数据(_create方式：指定id)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># _create 的方式创建索引数据时，必须指定id,而且只能执行一次，因为执行过一次后指定id的数据就存在了，不能再次创建</span></span><br><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_create/&lt;id&gt;</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_create/1?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;category&quot;: &quot;electronics&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;price&quot;: 999.99,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;count&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;title&quot;: &quot;Smartphone X - 128GB&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>修改数据</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">1.修改全部数据</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_doc/&lt;id&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># 执行时会先删除原数据再创建新数据，所以必须全量更新才行。</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_doc/sImNW5YBmgASmV9McVvI&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;category&quot;: &quot;electronics&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;price&quot;: 999.99,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;count&quot;: 20,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;title&quot;: &quot;Smartphone X - 128GB&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">2.修改部分数据</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_update/&lt;id&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># 执行时只会修改指定字段，不会删除原数据，所以可以部分更新。</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_update/1&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;doc&quot;:&#123;&quot;count&quot;:100&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>查询指定索引的指定id的数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;/_doc/&lt;id&gt;</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_doc/100?pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;_index&quot;</span> : <span class=\"string\">&quot;shopping_new&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_id&quot;</span> : <span class=\"string\">&quot;100&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_version&quot;</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">&quot;_seq_no&quot;</span> : 2,</span><br><span class=\"line\">  <span class=\"string\">&quot;_primary_term&quot;</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">&quot;found&quot;</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;_source&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;category&quot;</span> : <span class=\"string\">&quot;electronics&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;price&quot;</span> : 999.99,</span><br><span class=\"line\">    <span class=\"string\">&quot;count&quot;</span> : 10,</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span> : <span class=\"string\">&quot;Smartphone X - 128GB&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;remark&quot;</span> : <span class=\"string\">&quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;address&quot;</span> : <span class=\"string\">&quot;123 Electronic Ave, Beijing, China&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;tags&quot;</span> : [</span><br><span class=\"line\">      <span class=\"string\">&quot;latest&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;smartphone&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;technology&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;created_at&quot;</span> : <span class=\"string\">&quot;2025-04-22 03:30:02&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除指定索引的指定id的数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># DELETE /&lt;target&gt;/_doc/&lt;id&gt;</span></span><br><span class=\"line\">curl -X DELETE -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_doc/100&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除索引全部数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_delete_by_query?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"批量操作\">批量操作</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>批量新增数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意数据行要顶行写，前面不要有空格</span></span><br><span class=\"line\"><span class=\"comment\"># POST /_bulk</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;1&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;2&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;3&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;4&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;5&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;6&quot; &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># index: 用于创建新文档或替换已有文档。</span></span><br><span class=\"line\"><span class=\"comment\"># create: 用于创建新文档，如果文档已存在，则返回错误。</span></span><br><span class=\"line\"><span class=\"comment\"># _index: 指定索引名称。</span></span><br><span class=\"line\"><span class=\"comment\"># _id: 指定文档ID。如果不指定则会自动生成一个随机的ID。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量新增数据时也可以在url中指定索引名称</span></span><br><span class=\"line\"><span class=\"comment\"># 此时可以指定id，如果不指定则自动生成一个随机字符串的ID</span></span><br><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_bulk</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>批量修改数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意数据行要顶行写，前面不要有空格</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;Smartphone X2 - 128GB&quot;,&quot;price&quot;:1000.11&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;T-shirt&quot;,&quot;price&quot;:45.99&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># update: 用于更新文档。</span></span><br><span class=\"line\"><span class=\"comment\"># doc: 指定要更新的字段。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>批量删除数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意数据行要顶行写，前面不要有空格</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;4&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># delete: 用于删除文档。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条件更新\">条件更新</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_update_by_query</span></span><br><span class=\"line\"><span class=\"comment\"># 这里将category为华为的数据价格改为1999</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_update_by_query?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;match&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;category&quot;: &quot;books&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;script&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;source&quot;: &quot;ctx._source.price = 20.99&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;lang&quot;: &quot;painless&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\">## &quot;query&quot;: &#123;&#125;  查询条件</span></span><br><span class=\"line\"><span class=\"comment\">## &quot;script&quot;: &#123;&#125;  脚本</span></span><br><span class=\"line\"><span class=\"comment\">### source: 脚本内容</span></span><br><span class=\"line\"><span class=\"comment\">### lang: 脚本语言</span></span><br><span class=\"line\"><span class=\"comment\">#### painless 是 Elasticsearch 官方提供的脚本语言，它提供了许多内置函数和变量，可以方便地实现各种复杂的逻辑操作。https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-lang-spec.html</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条件删除\">条件删除</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># POST /&lt;target&gt;/_delete_by_query</span></span><br><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_delete_by_query?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;books&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条件查询\">条件查询</h2>\n<h3 id=\"match-all-全部匹配查询\">match_all: 全部匹配查询</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET /&lt;target&gt;/_search</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span></span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者简写为</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"term-精确匹配查询（关键字查询，即不分词）\">term: 精确匹配查询（关键字查询，即不分词）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果字段被额外设置 keyword 类型，则需要加上 .keyword 后缀</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;address.keyword&quot;:&quot;广州白云山公园&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># term处理多值字段(数组)时，term查询是包含，不是等于</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;tags&quot;:&quot;technology&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"terms-多关键字精确匹配查询\">terms: 多关键字精确匹配查询</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;terms&quot;:&#123;&quot;category&quot;:[&quot;electronics&quot;,&quot;books&quot;]&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"range-范围查询\">range: 范围查询</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\"># gte: 大于等于</span></span><br><span class=\"line\">  <span class=\"comment\"># lte: 小于等于</span></span><br><span class=\"line\">  <span class=\"comment\"># gt: 大于</span></span><br><span class=\"line\">  <span class=\"comment\"># lt: 小于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时间范围查询</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;created_at&quot;:&#123;&quot;gte&quot;:&quot;2025-04-20 00:00:00&quot;,&quot;lte&quot;:&quot;2025-05-20 23:59:59&quot;&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基于日期数学表达式查询</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;created_at&quot;:&#123;&quot;gte&quot;:&quot;now-1y&quot;&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支持的日期表达式</span></span><br><span class=\"line\"><span class=\"comment\"># - now：当前时间点。</span></span><br><span class=\"line\"><span class=\"comment\"># - now-1d：从当前时间点向前推1天的时间点。</span></span><br><span class=\"line\"><span class=\"comment\"># - now-1w：从当前时间点向前推1周的时间点。</span></span><br><span class=\"line\"><span class=\"comment\"># - now-1M：从当前时间点向前推1个月的时间点。</span></span><br><span class=\"line\"><span class=\"comment\"># - now-1y：从当前时间点向前推1年的时间点。</span></span><br><span class=\"line\"><span class=\"comment\"># - now+1h：从当前时间点向后推1小时的时间点。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"exists-查询字段存在的数据\">exists: 查询字段存在的数据</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;exists&quot;:&#123;&quot;field&quot;:&quot;title&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\"># field: 指定要查询的字段</span></span><br><span class=\"line\">  <span class=\"comment\"># 示例：查询 title 字段存在的文档</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ids-根据一组ID查询\">ids: 根据一组ID查询</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;ids&quot;:&#123;&quot;values&quot;:[&quot;1&quot;,&quot;2&quot;]&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\"># values: 指定要查询的ID列表</span></span><br><span class=\"line\">  <span class=\"comment\"># 示例：查询ID为1和2的文档</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"prefix-前缀查询\">prefix: 前缀查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>仅适用于关键字类型(keyword)的字段</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;category&quot;:&quot;elec&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 仅适用于keyword类型字段，所以下面这个请求查询不到数据</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;address&quot;:&quot;广州白云山&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 因为address被附加了keyword类型，所以需要加上.keyword后缀后可以查询到数据</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;address.keyword&quot;:&quot;广州白云山&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"wildcard-通配符查询\">wildcard: 通配符查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>仅适用于关键字类型(keyword)的字段</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;wildcard&quot;:&#123;&quot;category&quot;:&quot;e?e*&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># ?: 任意单个字符</span></span><br><span class=\"line\"><span class=\"comment\"># *: 任意多个字符</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"regexp-正则表达式查询\">regexp: 正则表达式查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>仅适用于关键字类型(keyword)的字段</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;regexp&quot;:&#123;&quot;category&quot;:&quot;e.e.*&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"fuzzy-支持编辑距离的模糊查询\">fuzzy: 支持编辑距离的模糊查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>仅适用于关键字类型(keyword)的字段</p>\n</li>\n<li class=\"lvl-2\">\n<p>fuzzy检索是一种强大的搜索功能，它能够在用户输入内容存在拼写错误或上下文不一致时，仍然返回与搜索词相似的文档。通过使用编辑距离算法来度量输入词与文档中词条的相似程度，模糊查询在保证搜索结果相关性的同时，有效地提高了搜索容错能力。</p>\n</li>\n<li class=\"lvl-2\">\n<p>编辑距离是指从一个单词转换到另一个单词需要编辑单字符的次数。如中文集团到中威集团编辑距离就是1，只需要修改一个字符；如果fuzziness值在这里设置成2，会把编辑距离为2的东东集团也查出来。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fuzzy&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;category&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;value&quot;:&quot;beeks&quot;,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;fuzziness&quot;:&quot;2&quot;,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;prefix_length&quot;:1</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># fuzziness：用于编辑距离的设置，其默认值为AUTO，支持的数值为[0，1，2]。如果值设置越界会报错。</span></span><br><span class=\"line\"><span class=\"comment\"># prefix_length: 搜索词的前缀长度，在此长度内不会应用模糊匹配。默认是0，即整个词都会被模糊匹配。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"match-全文检索-即分词\">match: 全文检索(即分词)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;address&quot;:&quot;广州白云山公园&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为 desc 的索引分词器是 ik_max_word，查看“广州白云山公园”被分词后的结果</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_analyze?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;text&quot;: &quot;广州白云山公园&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;tokens&quot;</span> : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;token&quot;</span> : <span class=\"string\">&quot;广州&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start_offset&quot;</span> : 0,</span><br><span class=\"line\">      <span class=\"string\">&quot;end_offset&quot;</span> : 2,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;CN_WORD&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span> : 0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;token&quot;</span> : <span class=\"string\">&quot;白云山&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start_offset&quot;</span> : 2,</span><br><span class=\"line\">      <span class=\"string\">&quot;end_offset&quot;</span> : 5,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;CN_WORD&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span> : 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;token&quot;</span> : <span class=\"string\">&quot;白云&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start_offset&quot;</span> : 2,</span><br><span class=\"line\">      <span class=\"string\">&quot;end_offset&quot;</span> : 4,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;CN_WORD&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span> : 2</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;token&quot;</span> : <span class=\"string\">&quot;云山&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start_offset&quot;</span> : 3,</span><br><span class=\"line\">      <span class=\"string\">&quot;end_offset&quot;</span> : 5,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;CN_WORD&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span> : 3</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;token&quot;</span> : <span class=\"string\">&quot;公园&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start_offset&quot;</span> : 5,</span><br><span class=\"line\">      <span class=\"string\">&quot;end_offset&quot;</span> : 7,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;CN_WORD&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;position&quot;</span> : 4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 所以只要desc中包含如上这些内容的数据都会被匹配上</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 但是这样匹配的结果就不够精确，如何尽量匹配更多的分词呢，可以增加 minimum_should_match</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;match&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;address&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;query&quot;: &quot;广州白云山公园&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;minimum_should_match&quot;: 2</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># minimum_should_match: 2 表示至少匹配两个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果希望全部都匹配呢</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;match&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;address&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;query&quot;: &quot;广州白云山公园&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;operator&quot;: &quot;and&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># operator: and 表示全部匹配，此时相当于精确匹配，其默认值是 or</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"multi-match-多字段查询\">multi_match: 多字段查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>multi_match查询在Elasticsearch中用于在多个字段上执行相同的搜索操作。它可以接受一个查询字符串，并在指定的字段集合中搜索这个字符串。multi_match查询提供了灵活的匹配类型和操作符选项，以便根据不同的搜索需求调整搜索行为。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;multi_match&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;: &quot;广州shirt&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;:[&quot;title&quot;,&quot;address&quot;]</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># query: 查询条件</span></span><br><span class=\"line\"><span class=\"comment\"># fields: 指定多个字段进行匹配</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"match-phrase-短语查询\">match_phrase: 短语查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>match_phrase查询在Elasticsearch中用于执行短语搜索，它不仅匹配整个短语，而且还考虑了短语中各个词的顺序和位置。这种查询类型对于搜索精确短语非常有用，尤其是在用户输入的查询与文档中的文本表达方式需要严格匹配时。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;match_phrase&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;address&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;query&quot;:&quot;广州白云山&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 要求查询结果中的数据必须包含&quot;广州白云山&quot;，而且“广州”和“白云山”这两个词是不能分开的，因为 match_phrase 匹配的是相邻词条</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"query-string-支持与或非表达式的查询\">query_string: 支持<code>与或非</code>表达式的查询</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>query_string查询是一种灵活的查询类型，它允许使用Lucene查询语法来构建复杂的搜索查询。这种查询类型支持多种逻辑运算符，包括与（AND）、或（OR）和非（NOT），以及通配符、模糊搜索和正则表达式等功能。query_string查询可以在单个或多个字段上进行搜索，并且可以处理复杂的查询逻辑。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意: 查询字段分词就将查询条件分词查询，查询字段不分词将查询条件不分词查询</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询所有字段中包含 &quot;公园&quot;和 &quot;华为&quot; 的文档</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;query_string&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;:&quot;公园 AND electronics&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定查询的单个字段</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;query_string&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;default_field&quot;:&quot;category&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;:&quot;白云山 OR books&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定查询的多个字段</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;query_string&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;:[&quot;category&quot;,&quot;address&quot;],</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;:&quot;白云山 OR (electronics AND shirt)&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"simple-query-string-类似-query-string，但是会忽略错误的语法，同时只支持部分查询语法\">simple_query_string: 类似 <code>query_string</code>，但是会忽略错误的语法，同时只支持部分查询语法</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;simple_query_string&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;:&quot;广州公园&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;default_operator&quot;:&quot;AND&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># default_operator: 默认为 OR，设置为 AND 则必须同时匹配</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>ES查询结果属性含义</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;took&quot;</span>:16,          <span class=\"comment\"># 表示查询从请求到完成耗时 16 毫秒。</span></span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span>:<span class=\"literal\">false</span>,  <span class=\"comment\"># 表示查询在规定的时间内完成，没有发生超时。如果为 true，则表示查询超时。</span></span><br><span class=\"line\">  <span class=\"string\">&quot;_shards&quot;</span>:&#123;         <span class=\"comment\"># 涉及到查询过程中使用的分片信息</span></span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>:1,        <span class=\"comment\"># 表示查询涉及到的总分片数为 1</span></span><br><span class=\"line\">    <span class=\"string\">&quot;successful&quot;</span>:1,   <span class=\"comment\"># 表示查询成功完成的分片数为 1</span></span><br><span class=\"line\">    <span class=\"string\">&quot;skipped&quot;</span>:0,      <span class=\"comment\"># 表示查询过程中被跳过的分片数为 0</span></span><br><span class=\"line\">    <span class=\"string\">&quot;failed&quot;</span>:0        <span class=\"comment\"># 表示查询过程中失败的分片数为 0</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;hits&quot;</span>:&#123;            <span class=\"comment\"># 包含查询结果的详细信息</span></span><br><span class=\"line\">    <span class=\"string\">&quot;total&quot;</span>:&#123;         <span class=\"comment\"># 包含查询结果的总数</span></span><br><span class=\"line\">      <span class=\"string\">&quot;value&quot;</span>:4,      <span class=\"comment\"># 表示查询结果的总数为 4</span></span><br><span class=\"line\">      <span class=\"string\">&quot;relation&quot;</span>:<span class=\"string\">&quot;eq&quot;</span> <span class=\"comment\"># 表示返回的总数 value 是确切的（equal）。如果为 gte，则表示返回的总数是一个下限值。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;max_score&quot;</span>:0.0,  <span class=\"comment\"># 表示匹配到的文档中最高的得分。如果是排序查询，这个值会有意义。当前结果因为 size: 0，没有实际返回文档，所以得分为 0.0</span></span><br><span class=\"line\">    <span class=\"string\">&quot;hits&quot;</span>:[ ]        <span class=\"comment\"># 包含查询结果的列表，每个结果都是一个对象，包含文档的元数据，如 id、分数等。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"bool-查询\">bool 查询</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>布尔查询可以按照布尔逻辑条件组织多条查询语句，只有符合整个布尔条件的文档才会被搜索出来。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在布尔条件中，可以包含两种不同的上下文。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">1.搜索上下文(query context)：使用搜索上下文时，Elasticsearch需要计算每个文档与搜索条件的相关度得分，这个得分的计算需使用一套复杂的计算公式，有一定的性能开销，带文本分析的全文检索的查询语句很适合放在搜索上下文中。</li>\n<li class=\"lvl-4\">2.过滤上下文(filter context)：使用过滤上下文时，Elasticsearch只需要判断搜索条件跟文档数据是否匹配，例如使用<code>Term query</code>判断一个值是否跟搜索内容一致，使用<code>Range query</code>判断某数据是否位于某个区间等。过滤上下文的查询不需要进行相关度得分计算，还可以使用缓存加快响应速度，很多术语级查询语句都适合放在过滤上下文中。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>bool 查询包含 must、must_not、should、filter 四种子句。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>must</td>\n<td>可包含多个查询条件，每个条件均满足的文档才能被搜索到，每次查询需要计算相关度得分，属于搜索上下文</td>\n</tr>\n<tr>\n<td>should</td>\n<td>可包含多个查询条件，不存在must和fiter条件时，至少要满足多个查询条件中的一个，文档才能被搜索到，否则需满足的条件数量不受限制,匹配到的查询越多相关度越高，也属于搜索上下文</td>\n</tr>\n<tr>\n<td>filter</td>\n<td>可包含多个过滤条件，每个条件均满足的文档才能被搜索到，每个过滤条件不计算相关度得分，结果在一定条件下会被缓存， 属于过滤上下文</td>\n</tr>\n<tr>\n<td>must_not</td>\n<td>可包含多个过滤条件，每个条件均不满足的文档才能被搜索到，每个过滤条件不计算相关度得分，结果在一定条件下会被缓存， 属于过滤上下文</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"must\">must</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两个条件都需要满足</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;bool&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;must&quot;:[</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"must-not\">must_not</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两个条件都不满足</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;bool&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;must_not&quot;:[</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"should\">should</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两个条件满足一个即可</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;bool&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;should&quot;:[</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\">filter</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># filter中的条件为非 match，即不能是全文检索</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;bool&quot;:&#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;filter&quot;:[</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;term&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">          &#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20&#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"分页与排序\">分页与排序</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># from: 从第几条开始，默认0</span></span><br><span class=\"line\"><span class=\"comment\"># size: 取多少条</span></span><br><span class=\"line\"><span class=\"comment\"># sort: 排序，默认为按文档id升序</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;sort&quot;:[&#123;&quot;price&quot;:&quot;address&quot;&#125;],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;from&quot;:0,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;size&quot;:5</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"只返回部分字段\">只返回部分字段</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># _source: 指定要返回的字段列表</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">  &#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;_source&quot;:[&quot;category&quot;,&quot;title&quot;,&quot;price&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"高亮显示\">高亮显示</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 高亮显示仅支持全文检索字段</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;multi_match&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;fields&quot;: [&quot;title&quot;,&quot;address&quot;],</span></span><br><span class=\"line\"><span class=\"string\">        &quot;query&quot;: &quot;公园shirt&quot;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;highlight&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;post_tags&quot;: [&quot;&lt;/span&gt;&quot;],</span></span><br><span class=\"line\"><span class=\"string\">      &quot;pre_tags&quot;: [&quot;&lt;span style=&#x27;</span>color:red<span class=\"string\">&#x27;&gt;&quot;],</span></span><br><span class=\"line\"><span class=\"string\">      &quot;fields&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;*&quot;:&#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"地理空间位置查询\">地理空间位置查询</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>地理空间位置查询是数据库和搜索系统中的一个重要特性，特别是在地理信息系统（GIS）和位置服务中。它允许用户基于地理位置信息来搜索和过滤数据。在Elasticsearch这样的全文搜索引擎中，地理空间位置查询被广泛应用，例如在旅行、房地产、物流和零售等行业，用于提供基于位置的搜索功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在Elasticsearch中，地理空间数据通常存储在<code>geo_point</code>字段类型中。这种字段类型可以存储纬度和经度坐标，用于表示地球上的一个点。</p>\n</li>\n</ul>\n<h3 id=\"示例\">示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个索引，并添加一个<code>geo_point</code>字段：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/tourist_spots&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;mappings&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;properties&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;name&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;location&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;geo_point&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>插入数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/tourist_spots/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;&quot;index&quot;:&#123;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;name&quot;:&quot;雷峰塔&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2615,&quot;lon&quot;:120.1480&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;index&quot;:&#123;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;name&quot;:&quot;西湖&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2614,&quot;lon&quot;:120.1479&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;index&quot;:&#123;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&quot;name&quot;:&quot;苏堤春晓&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2624,&quot;lon&quot;:120.1708&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># lat: 纬度</span></span><br><span class=\"line\"><span class=\"comment\"># lon: 经度</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查询数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询杭州西湖5km附近的景点</span></span><br><span class=\"line\"><span class=\"comment\"># 雷峰塔 - 位于西湖附近，距离约2.8公里。</span></span><br><span class=\"line\"><span class=\"comment\"># 苏堤春晓 - 位于西湖边，距离西湖中心约1公里。</span></span><br><span class=\"line\">curl -X GET -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/tourist_spots/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;bool&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;must&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;match_all&quot;: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;filter&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;geo_distance&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;distance&quot;: &quot;5km&quot;,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;distance_type&quot;: &quot;arc&quot;,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;location&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">              &quot;lat&quot;: 30.2614,</span></span><br><span class=\"line\"><span class=\"string\">              &quot;lon&quot;: 120.1479</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># distance: 5km 表示距离为5公里</span></span><br><span class=\"line\"><span class=\"comment\"># distance_type: arc, plane, sloppy_arc,</span></span><br><span class=\"line\">  <span class=\"comment\"># arc: 默认值，使用haversine公式计算距离，结果是精确的，但计算速度较慢。</span></span><br><span class=\"line\">  <span class=\"comment\"># plane: 使用平面直角坐标系计算距离，结果是粗略的，但计算速度更快。</span></span><br><span class=\"line\">  <span class=\"comment\"># sloppy_arc: 使用haversine公式计算距离，但允许误差。</span></span><br><span class=\"line\"><span class=\"comment\"># location: 搜索条件</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"向量搜索\">向量搜索</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 8.x 引入了一个重要的新特性：向量检索（Vector Search），特别是通过KNN（K-Nearest Neighbors）算法支持向量近邻检索。这一特性使得Elasticsearch在机器学习、数据分析和推荐系统等领域的应用变得更加广泛和强大。</p>\n</li>\n<li class=\"lvl-2\">\n<p>向量检索的基本思路是，将文档（或数据项）表示为高维向量，并使用这些向量来执行相似性搜索。在Elasticsearch中，这些向量被存储在<code>dense_vector</code>类型的字段中，然后使用KNN算法来找到与给定向量最相似的其他向量。</p>\n</li>\n</ul>\n<h3 id=\"示例-2\">示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建索引</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X PUT -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/image-index&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;mappings&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;properties&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;image-vector&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;dense_vector&quot;,</span></span><br><span class=\"line\"><span class=\"string\">          &quot;dims&quot;: 3</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;title&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;text&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;file-type&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;keyword&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;my_label&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;type&quot;: &quot;text&quot;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># dims: 3  表示3维向量，最高支持2048</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/image-index/_bulk&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;image-vector&quot;: [-5, 9, -12], &quot;title&quot;: &quot;Image A&quot;, &quot;file-type&quot;: &quot;jpeg&quot;, &quot;my_label&quot;: &quot;red&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;image-vector&quot;: [10, -2, 3], &quot;title&quot;: &quot;Image B&quot;, &quot;file-type&quot;: &quot;png&quot;, &quot;my_label&quot;: &quot;blue&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;index&quot;: &#123;&#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; &quot;image-vector&quot;: [4, 0, -1], &quot;title&quot;: &quot;Image C&quot;, &quot;file-type&quot;: &quot;gif&quot;, &quot;my_label&quot;: &quot;red&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>向量检索</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/image-index/_search?pretty&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;knn&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;field&quot;: &quot;image-vector&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;query_vector&quot;: [-5, 10, -12],</span></span><br><span class=\"line\"><span class=\"string\">      &quot;k&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;num_candidates&quot;: 100</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;fields&quot;: [ &quot;title&quot;, &quot;file-type&quot; ]</span></span><br><span class=\"line\"><span class=\"string\">  &#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># query: 搜索条件，这里可以不加这个</span></span><br><span class=\"line\"><span class=\"comment\"># knn: 8.8.1 版本开始默认支持</span></span><br><span class=\"line\"><span class=\"comment\"># field: 搜索向量字段</span></span><br><span class=\"line\"><span class=\"comment\"># query_vector: 搜索向量</span></span><br><span class=\"line\"><span class=\"comment\"># k: 搜索结果数量</span></span><br><span class=\"line\"><span class=\"comment\"># num_candidates: 搜索候选数量，用于优化性能</span></span><br><span class=\"line\"><span class=\"comment\"># fields: 搜索结果返回字段</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Elasticsearch 的 REST APIs Elasticsearch版本8.17.3 官方文档:REST APIs Elasticsearch 的 REST APIs:聚合查询 返回内容格式化 返回json信息格式: ?pretty 输出格式化后的json，比如：curl http://localhost:9200/_cluster/health?pretty 返回行信息格式: ?v 输出内容上方会加上标题行，比如：curl http://localhost:9200/_cat/health?v CAT APIs Elasticsearch 提供了 CAT APIs，它们提供了一种简单的方式来查看集群状态和集群中的各种资源，比如索引、分片、节点等。 123456789101112131415161718192021222324GET /_cat/health #查看集群当前状态：红、黄、绿GET /_cat/master #查看master节点信息GET /_cat/nodes #查看所有节点信息GET /_cat/plugins #查看集群各个节点上的plugin信息GET /_cat/indices #查看集群中所有index的详细信息GET /_cat/indices/&#123;index&#125; #查看集群中指定index的详细信息，index：索引名称GET /_cat/allocation #查看单节点的shard分配整体情况GET /_cat/shards #查看各shard的详细情况GET /_cat/shards/&#123;index&#125; #查看指定分片的详细情况GET /_cat/segments #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘GET /_cat/segments/&#123;index&#125; #查看指定index的segment详细信息GET /_cat/count #查看当前集群的doc数量GET /_cat/count/&#123;index&#125; #查看指定索引的doc数量GET /_cat/recovery #查看集群内每个shard的recovery过程.调整replica。GET /_cat/recovery/&#123;index&#125; #查看指定索引shard的recovery过程GET /_cat/pending_tasks #查看当前集群的pending taskGET /_cat/aliases #查看集群中所有alias信息,路由配置等GET /_cat/aliases/&#123;alias&#125; #查看指定索引的alias信息GET /_cat/thread_pool #查看集群各节点内部不同类型的threadpool的统计信息,GET /_cat/fielddata #查看当前集群各个节点的fielddata内存使用情况GET /_cat/fielddata/&#123;fields&#125; #查看指定field的内存使用情况,里面传field属性对应的值GET /_cat/nodeattrs #查看单节点的自定义属性GET /_cat/repositories #输出集群中注册快照存储库GET /_cat/templates #输出当前正在存在的模板信息 Cluster APIs Elasticsearch 提供了一系列的 Cluster APIs，它们提供了管理和监控集群状态的功能 123456789GET /_cluster/health # 获取集群的健康状态信息，包括了集群总体的状况如status、number_of_nodes等。GET /_cluster/stats # 提供整个集群层面的统计信息，包含索引、节点和其他高级指标。GET /_cluster/state # 显示集群元数据的状态，包括设置、块、路由表及元数据等，允许用户查看集群的当前视图。POST /_cluster/reroute # POST请求，用于手动改变分片分配情况，可以实现如迁移分片、取消分配等操作。GET /_cluster/nodes/hot_threads # 返回集群中各个节点“最热”的线程堆栈跟踪，默认显示前三个CPU时间最长的线程。GET /_cluster/allocation/explain # 解释为何某个分片被如此分配，并提供如何调整的建议。GET /_cluster/pending_tasks # 列出所有等待执行的任务列表。GET /_cluster/settings # 查看整个集群级别的设置。PUT /_cluster/settings # 更新整个集群级别的设置。 Index APIs Elasticsearch 提供了 Index APIs，它们提供了对索引的创建、更新、查询和删除等操作。 创建索引 12345# PUT /&lt;target&gt;# 这里 shopping 为索引名称，但此时没有为索引设置分片策略，也没有设置字段信息curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27;# 返回值&#123;&quot;acknowledged&quot;:true,&quot;shards_acknowledged&quot;:true,&quot;index&quot;:&quot;shopping&quot;&#125; 创建索引并设置索引 123456# PUT /&lt;target&gt;curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;settings&quot;:&#123;&quot;number_of_shards&quot;:&quot;1&quot;,&quot;number_of_replicas&quot;:&quot;2&quot;&#125;&#125;&#x27;# 返回值&#123;&quot;acknowledged&quot;:true,&quot;shards_acknowledged&quot;:true,&quot;index&quot;:&quot;shopping&quot;&#125; 创建并映射索引 1234567891011121314151617181920212223242526272829303132333435363738394041# PUT /&lt;target&gt;# 这里设置索引分片数量为1，副本数量为2，并设置字段信息curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;settings&quot;:&#123; &quot;number_of_shards&quot;:&quot;1&quot;, &quot;number_of_replicas&quot;:&quot;2&quot; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125;, &quot;category&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;price&quot;:&#123; &quot;type&quot;:&quot;double&quot; &#125;, &quot;count&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125; &#125; &#125; &#125;&#x27;# 参数说明## settings: 这个参数用于配置索引的设置，包括分片数量和副本数量。### number_of_shards: 这个参数指定了索引中分片的数量。在这个例子中，number_of_shards 设置为 1，意味着索引将只有一个主分片。### number_of_replicas: 这个参数指定了每个主分片的副本数量。在这个例子中，number_of_replicas 设置为 2，意味着每个主分片将有两个副本。## mappings: 这个参数用于定义索引中的字段和字段类型。### properties: 这个参数定义了索引中的字段和字段类型。在这个例子中，有四个字段：title、category、images 和 price。### title: 这个字段的类型是 text，表示它是一个全文检索字段。text 适合存储长文本数据，并支持全文搜索。### category: 这个字段的类型是 keyword，表示它是一个关键字字段，不支持全文检索。keyword 适合存储不需要分词的短文本数据（如标签、类别等），并且可以用于聚合和过滤。### price: 这个字段的类型是 double，表示它是一个数字字段。double 表示这是一个双精度浮点数字段，适合存储数值数据，如价格### count: 这个字段的类型是 integer，表示它是一个整数字段。integer 表示这是一个整数字段，适合存储整数数据，如商品数量等。# 返回值&#123;&quot;acknowledged&quot;:true,&quot;shards_acknowledged&quot;:true,&quot;index&quot;:&quot;shopping&quot;&#125; 更新索引映射 1234567891011121314151617181920212223242526272829303132333435363738# PUT /&lt;target&gt;/_mapping# 注意该api只能增加新的字段，不能修改已有字段，如果要修改源字段类型或者分词器类型，下文会介绍curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_mapping&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;properties&quot;:&#123; &quot;remark&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;, &quot;tags&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125; &#125; &#125;&#x27;# 参数说明# 这里为索引添加了4个字段# remark：新增字段，类型为text，分词器为ik_max_word，搜索分词器为ik_smart # analyzer: 索引分词器 # search_analyzer：搜索分词器 # ik_max_word：中文分词器，将句子拆分为最多词元，适合长句子 # ik_smart：中文分词器，将句子拆分为最少词元，适合短句子# address：新增字段，类型为text，分词器为ik_max_word，搜索分词器未指定，默认与分词器同一个，这里还为address添加了keyword字段，用于存储原始数据，以支持精确搜索# tags：新增字段，类型为keyword，不支持分词，适合存储短文本数据（如标签、类别等），并且可以用于聚合和过滤，可以存储数组# created_at：新增字段，类型为date，格式为yyyy-MM-dd HH:mm:ss# 返回值&#123;&quot;acknowledged&quot;:true&#125; 更新索引设置 1234567# PUT /&lt;target&gt;/_settings# 注意这里不能更新number_of_shardscurl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_settings&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;number_of_replicas&quot;:&quot;1&quot;&#125;&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125; 查看指定索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# GET /&lt;target&gt;curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping?pretty&#x27;# 返回值&#123; &quot;shopping&quot; : &#123; &quot;aliases&quot; : &#123; &#125;, &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;address&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125; &#125;, &quot;analyzer&quot; : &quot;ik_max_word&quot; &#125;, &quot;category&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;count&quot; : &#123; &quot;type&quot; : &quot;integer&quot; &#125;, &quot;created_at&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;price&quot; : &#123; &quot;type&quot; : &quot;double&quot; &#125;, &quot;remark&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot; : &quot;ik_smart&quot; &#125;, &quot;tags&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;title&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;routing&quot; : &#123; &quot;allocation&quot; : &#123; &quot;include&quot; : &#123; &quot;_tier_preference&quot; : &quot;data_content&quot; &#125; &#125; &#125;, &quot;number_of_shards&quot; : &quot;1&quot;, &quot;provided_name&quot; : &quot;shopping&quot;, &quot;creation_date&quot; : &quot;1745291743120&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;Y1IWrdlQTUm-CbbIWweSxQ&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;8525000&quot; &#125; &#125; &#125; &#125;&#125; 查看索引设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344# GET /&lt;target&gt;/_settingscurl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_settings?pretty&#x27;# 返回值&#123; &quot;shopping&quot; : &#123; &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;address&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125; &#125;, &quot;analyzer&quot; : &quot;ik_max_word&quot; &#125;, &quot;category&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;count&quot; : &#123; &quot;type&quot; : &quot;integer&quot; &#125;, &quot;created_at&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;price&quot; : &#123; &quot;type&quot; : &quot;double&quot; &#125;, &quot;remark&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot; : &quot;ik_smart&quot; &#125;, &quot;tags&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;title&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125; &#125;&#125; 查看字段映射 123456789101112131415161718# GET /&lt;target&gt;/_mapping/field/&lt;field&gt;# shopping 为索引名称，title 为字段名称curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_mapping/field/title?pretty&#x27;# 返回值&#123; &quot;shopping&quot; : &#123; &quot;mappings&quot; : &#123; &quot;title&quot; : &#123; &quot;full_name&quot; : &quot;title&quot;, &quot;mapping&quot; : &#123; &quot;title&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125; &#125; &#125;&#125; 判断索引是否存在 12345678910111213# 使用 -I 参数来发送 HEAD 请求，可以获取响应头而不必下载响应体。# HEAD /&lt;target&gt;curl -I -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27;# 返回值HTTP/1.1 200 OKX-elastic-product: Elasticsearchcontent-type: application/jsoncontent-length: 603# 这个命令不会返回响应体，但它的 HTTP 响应代码可以告诉你索引的存在情况： # 200 OK 表示索引存在。 # 404 Not Found 表示索引不存在。 删除索引 1234# DELETE /&lt;target&gt;curl -X DELETE -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125; 为索引创建别名 123456789101112131415161718192021# 注意：不同索引可以有相同名称的别名，所以在数据结构一致的情况下，我们可以为不同的索引创建相同的别名，然后根据别名进行数据查询# POST /&lt;target&gt;/_alias/&lt;alias&gt;curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125;# 也可以使用如下方法curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_aliases&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;actions&quot;: [ &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;shopping&quot;, &quot;alias&quot;: &quot;shopping_alias2&quot; &#125; &#125; ] &#125;&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125; 查看索引别名 12345678910111213141516# GET /&lt;target&gt;/_alias/&lt;alias&gt;curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias?pretty&#x27;# 返回值&#123; &quot;shopping&quot; : &#123; &quot;aliases&quot; : &#123; &quot;shopping_alias&quot; : &#123; &#125; &#125; &#125;&#125;# 查看当前索引的所有别名curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_alias?pretty&#x27;# 查看所有索引的别名curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_alias?pretty&#x27; 为索引删除别名 1234# DELETE /&lt;target&gt;/_alias/&lt;alias&gt;curl -X DELETE -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_alias/shopping_alias&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125; 如何修改索引字段类型或分词器类型？ 创建新的索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 这里为title字段增加分词器curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping_new&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;settings&quot;:&#123; &quot;number_of_shards&quot;:&quot;1&quot;, &quot;number_of_replicas&quot;:&quot;2&quot; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;category&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;price&quot;:&#123; &quot;type&quot;:&quot;double&quot; &#125;, &quot;count&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125;, &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125;, &quot;remark&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;, &quot;tags&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;created_at&quot;: &#123;&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;&#125; &#125; &#125; &#125;&#x27; 将原索引的数据迁移到新索引 123456789101112curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_reindex&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;shopping&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;shopping_new&quot; &#125;&#125;&#x27;# 返回值&#123;&quot;took&quot;:101,&quot;timed_out&quot;:false,&quot;total&quot;:2,&quot;updated&quot;:0,&quot;created&quot;:2,&quot;deleted&quot;:0,&quot;batches&quot;:1,&quot;version_conflicts&quot;:0,&quot;noops&quot;:0,&quot;retries&quot;:&#123;&quot;bulk&quot;:0,&quot;search&quot;:0&#125;,&quot;throttled_millis&quot;:0,&quot;requests_per_second&quot;:-1.0,&quot;throttled_until_millis&quot;:0,&quot;failures&quot;:[]&#125; 删除原索引 123curl -X DELETE -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping&#x27;# 返回值&#123;&quot;acknowledged&quot;:true&#125; 为新索引创建别名 123curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping_new/_alias/shopping&#x27;# 返回值&#123;&quot;acknowledged&quot;:true,&quot;errors&quot;:false&#125; 数据增删改基本操作 新增数据 1.为指定索引插入一条数据(_doc方式：不指定id默认随机字符串) 12345678910111213141516171819202122232425262728# _doc 的方式创建索引数据时，可以不指定id，默认会创建新的id，id类型为随机字符串# POST /&lt;target&gt;/_doccurl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_doc?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27;# 返回值&#123; &quot;_index&quot; : &quot;shopping_new&quot;, &quot;_id&quot; : &quot;sImNW5YBmgASmV9McVvI&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 3, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1&#125; 2.为指定索引插入一条数据(_doc方式：指定id) 12345678910111213141516171819202122232425262728# _doc 的方式创建索引数据时，如果指定id，再次执行时会先删除原数据再创建新数据，所以必须全量更新才行。# PUT /&lt;target&gt;/_doccurl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_doc/100?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27;# 返回值&#123; &quot;_index&quot; : &quot;shopping_new&quot;, &quot;_id&quot; : &quot;100&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 3, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 1&#125; 3.为指定索引插入一条数据(_create方式：指定id) 1234567891011121314# _create 的方式创建索引数据时，必须指定id,而且只能执行一次，因为执行过一次后指定id的数据就存在了，不能再次创建# POST /&lt;target&gt;/_create/&lt;id&gt;curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_create/1?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27; 修改数据 1.修改全部数据 1234567891011121314# POST /&lt;target&gt;/_doc/&lt;id&gt;# 执行时会先删除原数据再创建新数据，所以必须全量更新才行。curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_doc/sImNW5YBmgASmV9McVvI&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 20, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;123 Electronic Ave, Beijing, China&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27; 2.修改部分数据 12345# POST /&lt;target&gt;/_update/&lt;id&gt;# 执行时只会修改指定字段，不会删除原数据，所以可以部分更新。curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_update/1&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;doc&quot;:&#123;&quot;count&quot;:100&#125;&#125;&#x27; 查询指定索引的指定id的数据 12345678910111213141516171819202122232425# GET /&lt;target&gt;/_doc/&lt;id&gt;curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_doc/100?pretty&#x27;# 返回值&#123; &quot;_index&quot; : &quot;shopping_new&quot;, &quot;_id&quot; : &quot;100&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;category&quot; : &quot;electronics&quot;, &quot;price&quot; : 999.99, &quot;count&quot; : 10, &quot;title&quot; : &quot;Smartphone X - 128GB&quot;, &quot;remark&quot; : &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot; : &quot;123 Electronic Ave, Beijing, China&quot;, &quot;tags&quot; : [ &quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot; ], &quot;created_at&quot; : &quot;2025-04-22 03:30:02&quot; &#125;&#125; 删除指定索引的指定id的数据 12# DELETE /&lt;target&gt;/_doc/&lt;id&gt;curl -X DELETE -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_doc/100&#x27; 删除索引全部数据 123curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_delete_by_query?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;&#125;&#x27; 批量操作 批量新增数据 1234567891011121314151617181920212223242526272829303132333435363738394041# 注意数据行要顶行写，前面不要有空格# POST /_bulkcurl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;1&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;2&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;3&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;4&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;5&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;shopping&quot;, &quot;_id&quot;: &quot;6&quot; &#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27;# 参数说明# index: 用于创建新文档或替换已有文档。# create: 用于创建新文档，如果文档已存在，则返回错误。# _index: 指定索引名称。# _id: 指定文档ID。如果不指定则会自动生成一个随机的ID。# 批量新增数据时也可以在url中指定索引名称# 此时可以指定id，如果不指定则自动生成一个随机字符串的ID# POST /&lt;target&gt;/_bulkcurl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 999.99, &quot;count&quot;: 10, &quot;title&quot;: &quot;Smartphone X - 128GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;fashion&quot;, &quot;price&quot;: 49.99, &quot;count&quot;: 25, &quot;title&quot;: &quot;Designer T-shirt&quot;, &quot;remark&quot;: &quot;Trendy designer T-shirt made with high quality fabric.&quot;, &quot;address&quot;: &quot;广州荔湾大厦&quot;, &quot;tags&quot;: [&quot;clothing&quot;, &quot;designer&quot;, &quot;style&quot;], &quot;created_at&quot;: &quot;2025-04-21 12:15:00&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;home_appliances&quot;, &quot;price&quot;: 299.99, &quot;count&quot;: 5, &quot;title&quot;: &quot;Robot Vacuum Cleaner&quot;, &quot;remark&quot;: &quot;Efficient robot vacuum cleaner with smart navigation.&quot;, &quot;address&quot;: &quot;广州白云山公园&quot;, &quot;tags&quot;: [&quot;appliances&quot;, &quot;vacuum&quot;, &quot;robot&quot;], &quot;created_at&quot;: &quot;2025-04-20 08:45:30&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;books&quot;, &quot;price&quot;: 19.99, &quot;count&quot;: 100, &quot;title&quot;: &quot;Inspirational Novel&quot;, &quot;remark&quot;: &quot;A gripping novel that inspires and motivates.&quot;, &quot;address&quot;: &quot;321 Book Rd, Shenzhen, China&quot;, &quot;tags&quot;: [&quot;book&quot;, &quot;novel&quot;, &quot;inspiration&quot;], &quot;created_at&quot;: &quot;2025-04-19 10:05:00&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;groceries&quot;, &quot;price&quot;: 3.99, &quot;count&quot;: 200, &quot;title&quot;: &quot;Organic Apples&quot;, &quot;remark&quot;: &quot;Fresh and crispy organic apples.&quot;, &quot;address&quot;: &quot;654 Grocery Ln, Chengdu, China&quot;, &quot;tags&quot;: [&quot;fruit&quot;, &quot;organic&quot;, &quot;healthy&quot;], &quot;created_at&quot;: &quot;2025-04-18 14:30:45&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;category&quot;: &quot;electronics&quot;, &quot;price&quot;: 1999.99, &quot;count&quot;: 15, &quot;title&quot;: &quot;Smartphone X - 256GB&quot;, &quot;remark&quot;: &quot;This latest Smartphone X comes with a powerful processor and high-resolution camera.&quot;, &quot;address&quot;: &quot;广州天河公园&quot;, &quot;tags&quot;: [&quot;latest&quot;, &quot;smartphone&quot;, &quot;technology&quot;], &quot;created_at&quot;: &quot;2025-04-22 03:30:02&quot; &#125;&#x27; 批量修改数据 1234567891011# 注意数据行要顶行写，前面不要有空格curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;Smartphone X2 - 128GB&quot;,&quot;price&quot;:1000.11&#125;&#125;&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;T-shirt&quot;,&quot;price&quot;:45.99&#125;&#125;&#x27;# 参数说明# update: 用于更新文档。# doc: 指定要更新的字段。 批量删除数据 12345678910# 注意数据行要顶行写，前面不要有空格curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;shopping&quot;,&quot;_id&quot;:&quot;4&quot;&#125;&#125;&#x27;# 参数说明# delete: 用于删除文档。 条件更新 123456789101112131415161718192021# POST /&lt;target&gt;/_update_by_query# 这里将category为华为的数据价格改为1999curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_update_by_query?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;category&quot;: &quot;books&quot; &#125; &#125;, &quot;script&quot;: &#123; &quot;source&quot;: &quot;ctx._source.price = 20.99&quot;, &quot;lang&quot;: &quot;painless&quot; &#125; &#125;&#x27;# 参数说明## &quot;query&quot;: &#123;&#125; 查询条件## &quot;script&quot;: &#123;&#125; 脚本### source: 脚本内容### lang: 脚本语言#### painless 是 Elasticsearch 官方提供的脚本语言，它提供了许多内置函数和变量，可以方便地实现各种复杂的逻辑操作。https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-lang-spec.html 条件删除 1234# POST /&lt;target&gt;/_delete_by_querycurl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_delete_by_query?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;books&quot;&#125;&#125;&#125;&#x27; 条件查询 match_all: 全部匹配查询 1234567# GET /&lt;target&gt;/_searchcurl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;&#125;&#x27;# 或者简写为curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; term: 精确匹配查询（关键字查询，即不分词） 12345678910111213curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;&#125;&#x27;# 如果字段被额外设置 keyword 类型，则需要加上 .keyword 后缀curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;address.keyword&quot;:&quot;广州白云山公园&quot;&#125;&#125;&#125;&#x27;# term处理多值字段(数组)时，term查询是包含，不是等于curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;tags&quot;:&quot;technology&quot;&#125;&#125;&#125;&#x27; terms: 多关键字精确匹配查询 123curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;terms&quot;:&#123;&quot;category&quot;:[&quot;electronics&quot;,&quot;books&quot;]&#125;&#125;&#125;&#x27; range: 范围查询 12345678910111213141516171819202122232425curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;&#125;&#x27; # gte: 大于等于 # lte: 小于等于 # gt: 大于 # lt: 小于# 时间范围查询curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;created_at&quot;:&#123;&quot;gte&quot;:&quot;2025-04-20 00:00:00&quot;,&quot;lte&quot;:&quot;2025-05-20 23:59:59&quot;&#125;&#125;&#125;&#125;&#x27;# 基于日期数学表达式查询curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;created_at&quot;:&#123;&quot;gte&quot;:&quot;now-1y&quot;&#125;&#125;&#125;&#125;&#x27;# 支持的日期表达式# - now：当前时间点。# - now-1d：从当前时间点向前推1天的时间点。# - now-1w：从当前时间点向前推1周的时间点。# - now-1M：从当前时间点向前推1个月的时间点。# - now-1y：从当前时间点向前推1年的时间点。# - now+1h：从当前时间点向后推1小时的时间点。 exists: 查询字段存在的数据 12345curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;exists&quot;:&#123;&quot;field&quot;:&quot;title&quot;&#125;&#125;&#125;&#x27; # field: 指定要查询的字段 # 示例：查询 title 字段存在的文档 ids: 根据一组ID查询 12345curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;ids&quot;:&#123;&quot;values&quot;:[&quot;1&quot;,&quot;2&quot;]&#125;&#125;&#125;&#x27; # values: 指定要查询的ID列表 # 示例：查询ID为1和2的文档 prefix: 前缀查询 仅适用于关键字类型(keyword)的字段 123456789101112curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;category&quot;:&quot;elec&quot;&#125;&#125;&#125;&#x27;# 仅适用于keyword类型字段，所以下面这个请求查询不到数据curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;address&quot;:&quot;广州白云山&quot;&#125;&#125;&#125;&#x27;# 因为address被附加了keyword类型，所以需要加上.keyword后缀后可以查询到数据curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;prefix&quot;:&#123;&quot;address.keyword&quot;:&quot;广州白云山&quot;&#125;&#125;&#125;&#x27; wildcard: 通配符查询 仅适用于关键字类型(keyword)的字段 12345curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;wildcard&quot;:&#123;&quot;category&quot;:&quot;e?e*&quot;&#125;&#125;&#125;&#x27;# ?: 任意单个字符# *: 任意多个字符 regexp: 正则表达式查询 仅适用于关键字类型(keyword)的字段 123curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;regexp&quot;:&#123;&quot;category&quot;:&quot;e.e.*&quot;&#125;&#125;&#125;&#x27; fuzzy: 支持编辑距离的模糊查询 仅适用于关键字类型(keyword)的字段 fuzzy检索是一种强大的搜索功能，它能够在用户输入内容存在拼写错误或上下文不一致时，仍然返回与搜索词相似的文档。通过使用编辑距离算法来度量输入词与文档中词条的相似程度，模糊查询在保证搜索结果相关性的同时，有效地提高了搜索容错能力。 编辑距离是指从一个单词转换到另一个单词需要编辑单字符的次数。如中文集团到中威集团编辑距离就是1，只需要修改一个字符；如果fuzziness值在这里设置成2，会把编辑距离为2的东东集团也查出来。 123456789101112131415curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;fuzzy&quot;:&#123; &quot;category&quot;:&#123; &quot;value&quot;:&quot;beeks&quot;, &quot;fuzziness&quot;:&quot;2&quot;, &quot;prefix_length&quot;:1 &#125; &#125; &#125; &#125;&#x27;# fuzziness：用于编辑距离的设置，其默认值为AUTO，支持的数值为[0，1，2]。如果值设置越界会报错。# prefix_length: 搜索词的前缀长度，在此长度内不会应用模糊匹配。默认是0，即整个词都会被模糊匹配。 match: 全文检索(即分词) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;address&quot;:&quot;广州白云山公园&quot;&#125;&#125;&#125;&#x27;# 因为 desc 的索引分词器是 ik_max_word，查看“广州白云山公园”被分词后的结果curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_analyze?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;广州白云山公园&quot; &#125;&#x27;# 返回值&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;广州&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;白云山&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;白云&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;云山&quot;, &quot;start_offset&quot; : 3, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;公园&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125; ]&#125;# 所以只要desc中包含如上这些内容的数据都会被匹配上# 但是这样匹配的结果就不够精确，如何尽量匹配更多的分词呢，可以增加 minimum_should_matchcurl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;address&quot;:&#123; &quot;query&quot;: &quot;广州白云山公园&quot;, &quot;minimum_should_match&quot;: 2 &#125; &#125; &#125; &#125;&#x27;# minimum_should_match: 2 表示至少匹配两个# 如果希望全部都匹配呢curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;address&quot;:&#123; &quot;query&quot;: &quot;广州白云山公园&quot;, &quot;operator&quot;: &quot;and&quot; &#125; &#125; &#125; &#125;&#x27;# operator: and 表示全部匹配，此时相当于精确匹配，其默认值是 or multi_match: 多字段查询 multi_match查询在Elasticsearch中用于在多个字段上执行相同的搜索操作。它可以接受一个查询字符串，并在指定的字段集合中搜索这个字符串。multi_match查询提供了灵活的匹配类型和操作符选项，以便根据不同的搜索需求调整搜索行为。 123456789101112curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;: &quot;广州shirt&quot;, &quot;fields&quot;:[&quot;title&quot;,&quot;address&quot;] &#125; &#125; &#125;&#x27;# query: 查询条件# fields: 指定多个字段进行匹配 match_phrase: 短语查询 match_phrase查询在Elasticsearch中用于执行短语搜索，它不仅匹配整个短语，而且还考虑了短语中各个词的顺序和位置。这种查询类型对于搜索精确短语非常有用，尤其是在用户输入的查询与文档中的文本表达方式需要严格匹配时。 123456789101112curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;:&#123; &quot;address&quot;:&#123; &quot;query&quot;:&quot;广州白云山&quot; &#125; &#125; &#125; &#125;&#x27;# 要求查询结果中的数据必须包含&quot;广州白云山&quot;，而且“广州”和“白云山”这两个词是不能分开的，因为 match_phrase 匹配的是相邻词条 query_string: 支持与或非表达式的查询 query_string查询是一种灵活的查询类型，它允许使用Lucene查询语法来构建复杂的搜索查询。这种查询类型支持多种逻辑运算符，包括与（AND）、或（OR）和非（NOT），以及通配符、模糊搜索和正则表达式等功能。query_string查询可以在单个或多个字段上进行搜索，并且可以处理复杂的查询逻辑。 注意: 查询字段分词就将查询条件分词查询，查询字段不分词将查询条件不分词查询 12345678910111213141516171819202122232425262728293031323334# 查询所有字段中包含 &quot;公园&quot;和 &quot;华为&quot; 的文档curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;query&quot;:&quot;公园 AND electronics&quot; &#125; &#125; &#125;&#x27;# 指定查询的单个字段curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;:&quot;category&quot;, &quot;query&quot;:&quot;白云山 OR books&quot; &#125; &#125; &#125;&#x27;# 指定查询的多个字段curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;fields&quot;:[&quot;category&quot;,&quot;address&quot;], &quot;query&quot;:&quot;白云山 OR (electronics AND shirt)&quot; &#125; &#125; &#125;&#x27; simple_query_string: 类似 query_string，但是会忽略错误的语法，同时只支持部分查询语法 1234567891011curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;simple_query_string&quot;:&#123; &quot;query&quot;:&quot;广州公园&quot;, &quot;default_operator&quot;:&quot;AND&quot; &#125; &#125; &#125;&#x27;# default_operator: 默认为 OR，设置为 AND 则必须同时匹配 ES查询结果属性含义 123456789101112131415161718&#123; &quot;took&quot;:16, # 表示查询从请求到完成耗时 16 毫秒。 &quot;timed_out&quot;:false, # 表示查询在规定的时间内完成，没有发生超时。如果为 true，则表示查询超时。 &quot;_shards&quot;:&#123; # 涉及到查询过程中使用的分片信息 &quot;total&quot;:1, # 表示查询涉及到的总分片数为 1 &quot;successful&quot;:1, # 表示查询成功完成的分片数为 1 &quot;skipped&quot;:0, # 表示查询过程中被跳过的分片数为 0 &quot;failed&quot;:0 # 表示查询过程中失败的分片数为 0 &#125;, &quot;hits&quot;:&#123; # 包含查询结果的详细信息 &quot;total&quot;:&#123; # 包含查询结果的总数 &quot;value&quot;:4, # 表示查询结果的总数为 4 &quot;relation&quot;:&quot;eq&quot; # 表示返回的总数 value 是确切的（equal）。如果为 gte，则表示返回的总数是一个下限值。 &#125;, &quot;max_score&quot;:0.0, # 表示匹配到的文档中最高的得分。如果是排序查询，这个值会有意义。当前结果因为 size: 0，没有实际返回文档，所以得分为 0.0 &quot;hits&quot;:[ ] # 包含查询结果的列表，每个结果都是一个对象，包含文档的元数据，如 id、分数等。 &#125;&#125; bool 查询 布尔查询可以按照布尔逻辑条件组织多条查询语句，只有符合整个布尔条件的文档才会被搜索出来。 在布尔条件中，可以包含两种不同的上下文。 1.搜索上下文(query context)：使用搜索上下文时，Elasticsearch需要计算每个文档与搜索条件的相关度得分，这个得分的计算需使用一套复杂的计算公式，有一定的性能开销，带文本分析的全文检索的查询语句很适合放在搜索上下文中。 2.过滤上下文(filter context)：使用过滤上下文时，Elasticsearch只需要判断搜索条件跟文档数据是否匹配，例如使用Term query判断一个值是否跟搜索内容一致，使用Range query判断某数据是否位于某个区间等。过滤上下文的查询不需要进行相关度得分计算，还可以使用缓存加快响应速度，很多术语级查询语句都适合放在过滤上下文中。 bool 查询包含 must、must_not、should、filter 四种子句。 类型 说明 must 可包含多个查询条件，每个条件均满足的文档才能被搜索到，每次查询需要计算相关度得分，属于搜索上下文 should 可包含多个查询条件，不存在must和fiter条件时，至少要满足多个查询条件中的一个，文档才能被搜索到，否则需满足的条件数量不受限制,匹配到的查询越多相关度越高，也属于搜索上下文 filter 可包含多个过滤条件，每个条件均满足的文档才能被搜索到，每个过滤条件不计算相关度得分，结果在一定条件下会被缓存， 属于过滤上下文 must_not 可包含多个过滤条件，每个条件均不满足的文档才能被搜索到，每个过滤条件不计算相关度得分，结果在一定条件下会被缓存， 属于过滤上下文 must 12345678910111213# 两个条件都需要满足curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;:[ &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;, &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125; ] &#125; &#125; &#125;&#x27; must_not 12345678910111213# 两个条件都不满足curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must_not&quot;:[ &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;, &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125; ] &#125; &#125; &#125;&#x27; should 12345678910111213# 两个条件满足一个即可curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;should&quot;:[ &#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;, &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;公园&quot;&#125;&#125; ] &#125; &#125; &#125;&#x27; filter 12345678910111213# filter中的条件为非 match，即不能是全文检索curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;filter&quot;:[ &#123;&quot;term&quot;:&#123;&quot;category&quot;:&quot;electronics&quot;&#125;&#125;, &#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20&#125;&#125;&#125; ] &#125; &#125; &#125;&#x27; 分页与排序 1234567891011# from: 从第几条开始，默认0# size: 取多少条# sort: 排序，默认为按文档id升序curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;, &quot;sort&quot;:[&#123;&quot;price&quot;:&quot;address&quot;&#125;], &quot;from&quot;:0, &quot;size&quot;:5 &#125;&#x27; 只返回部分字段 1234567# _source: 指定要返回的字段列表curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27; &#123;&quot;query&quot;:&#123;&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gte&quot;:20,&quot;lte&quot;:30&#125;&#125;&#125;, &quot;_source&quot;:[&quot;category&quot;,&quot;title&quot;,&quot;price&quot;] &#125;&#x27; 高亮显示 123456789101112131415161718# 高亮显示仅支持全文检索字段curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/shopping/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;fields&quot;: [&quot;title&quot;,&quot;address&quot;], &quot;query&quot;: &quot;公园shirt&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;post_tags&quot;: [&quot;&lt;/span&gt;&quot;], &quot;pre_tags&quot;: [&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;], &quot;fields&quot;: &#123; &quot;*&quot;:&#123;&#125; &#125; &#125; &#125;&#x27; 地理空间位置查询 地理空间位置查询是数据库和搜索系统中的一个重要特性，特别是在地理信息系统（GIS）和位置服务中。它允许用户基于地理位置信息来搜索和过滤数据。在Elasticsearch这样的全文搜索引擎中，地理空间位置查询被广泛应用，例如在旅行、房地产、物流和零售等行业，用于提供基于位置的搜索功能。 在Elasticsearch中，地理空间数据通常存储在geo_point字段类型中。这种字段类型可以存储纬度和经度坐标，用于表示地球上的一个点。 示例 创建一个索引，并添加一个geo_point字段： 12345678910111213141516curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/tourist_spots&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;location&quot;: &#123; &quot;type&quot;: &quot;geo_point&quot; &#125; &#125; &#125; &#125;&#x27; 插入数据 1234567891011curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/tourist_spots/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;index&quot;:&#123;&#125;&#125;&#123;&quot;name&quot;:&quot;雷峰塔&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2615,&quot;lon&quot;:120.1480&#125;&#125;&#123;&quot;index&quot;:&#123;&#125;&#125;&#123;&quot;name&quot;:&quot;西湖&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2614,&quot;lon&quot;:120.1479&#125;&#125;&#123;&quot;index&quot;:&#123;&#125;&#125;&#123;&quot;name&quot;:&quot;苏堤春晓&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:30.2624,&quot;lon&quot;:120.1708&#125;&#125;&#x27;# lat: 纬度# lon: 经度 查询数据 12345678910111213141516171819202122232425262728293031# 查询杭州西湖5km附近的景点# 雷峰塔 - 位于西湖附近，距离约2.8公里。# 苏堤春晓 - 位于西湖边，距离西湖中心约1公里。curl -X GET -u elastic:123456 -k &#x27;https://127.0.0.1:9200/tourist_spots/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;filter&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;5km&quot;, &quot;distance_type&quot;: &quot;arc&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.2614, &quot;lon&quot;: 120.1479 &#125; &#125; &#125; &#125; &#125; &#125;&#x27;# distance: 5km 表示距离为5公里# distance_type: arc, plane, sloppy_arc, # arc: 默认值，使用haversine公式计算距离，结果是精确的，但计算速度较慢。 # plane: 使用平面直角坐标系计算距离，结果是粗略的，但计算速度更快。 # sloppy_arc: 使用haversine公式计算距离，但允许误差。# location: 搜索条件 向量搜索 Elasticsearch 8.x 引入了一个重要的新特性：向量检索（Vector Search），特别是通过KNN（K-Nearest Neighbors）算法支持向量近邻检索。这一特性使得Elasticsearch在机器学习、数据分析和推荐系统等领域的应用变得更加广泛和强大。 向量检索的基本思路是，将文档（或数据项）表示为高维向量，并使用这些向量来执行相似性搜索。在Elasticsearch中，这些向量被存储在dense_vector类型的字段中，然后使用KNN算法来找到与给定向量最相似的其他向量。 示例 创建索引 12345678910111213141516171819202122curl -X PUT -u elastic:123456 -k &#x27;https://127.0.0.1:9200/image-index&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;image-vector&quot;: &#123; &quot;type&quot;: &quot;dense_vector&quot;, &quot;dims&quot;: 3 &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;file-type&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;my_label&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125; &#125; &#125;&#x27;# dims: 3 表示3维向量，最高支持2048 添加数据 123456789curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/image-index/_bulk&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;image-vector&quot;: [-5, 9, -12], &quot;title&quot;: &quot;Image A&quot;, &quot;file-type&quot;: &quot;jpeg&quot;, &quot;my_label&quot;: &quot;red&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;image-vector&quot;: [10, -2, 3], &quot;title&quot;: &quot;Image B&quot;, &quot;file-type&quot;: &quot;png&quot;, &quot;my_label&quot;: &quot;blue&quot; &#125;&#123; &quot;index&quot;: &#123;&#125; &#125;&#123; &quot;image-vector&quot;: [4, 0, -1], &quot;title&quot;: &quot;Image C&quot;, &quot;file-type&quot;: &quot;gif&quot;, &quot;my_label&quot;: &quot;red&quot; &#125;&#x27; 向量检索 1234567891011121314151617181920curl -X POST -u elastic:123456 -k &#x27;https://127.0.0.1:9200/image-index/_search?pretty&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;knn&quot;: &#123; &quot;field&quot;: &quot;image-vector&quot;, &quot;query_vector&quot;: [-5, 10, -12], &quot;k&quot;: 10, &quot;num_candidates&quot;: 100 &#125;, &quot;fields&quot;: [ &quot;title&quot;, &quot;file-type&quot; ] &#125;&#x27;# query: 搜索条件，这里可以不加这个# knn: 8.8.1 版本开始默认支持# field: 搜索向量字段# query_vector: 搜索向量# k: 搜索结果数量# num_candidates: 搜索候选数量，用于优化性能# fields: 搜索结果返回字段","summary":"摘要 本文介绍 Elasticsearch 的 REST APIs Elasticsearch版本8.17.3 官方文档:REST APIs Elasticsearch 的 REST APIs:聚合查询","date_published":"2025-04-17T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]},{"id":"https://blog.hanqunfeng.com/2025/04/16/elasticsearch-04-cert/","url":"https://blog.hanqunfeng.com/2025/04/16/elasticsearch-04-cert/","title":"Elasticsearch的证书过期处理方法","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍Elasticsearch证书过期时的处理方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/index.html\">Elasticsearch</a>版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于 <a href=\"/2025/03/20/elasticsearch-01-install/\" title=\"linux下安装Elasticsearch\">linux下安装Elasticsearch</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/update-node-certs.html\">官方文档:Updating node security certificates</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ES证书简介\">ES证书简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 8 默认情况下创建的证书只有3年有效期，过期时需要创建新的证书，为了不必要的麻烦，也可以一开始就创建一个有效期比较长的证书。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 Elasticsearch 8 的配置下，<code>config/certs</code> 目录通常存放的是用于安全通信的证书和密钥文件。这些文件确保了 Elasticsearch 实例之间的通讯以及与外部客户端的通讯能够被加密且经过认证。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>config/certs</code> 目录包含三个文件分别是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>http.p12</code>: 这是一个 PKCS#12 格式的文件（通常带有.p12或.pfx扩展名），包含了 Elasticsearch HTTP 层用来进行 TLS/SSL 通信所需的一切，包括一个私钥、相应的公钥证书（服务器证书）及 CA 证书链。客户端使用这个文件来验证它们正在与正确的服务器进行通信，并且此服务器也信任该客户端。</li>\n<li class=\"lvl-4\"><code>http_ca.crt</code>: CA (Certificate Authority) 根证书或中间证书，用于验证通过 HTTP 协议连接至 Elasticsearch 服务端点的身份。当客户端尝试建立 HTTPS 连接时，它会检查来自 Elasticsearch 的证书是否由这个 CA 签名；这是确保双方通信安全的重要步骤之一。</li>\n<li class=\"lvl-4\"><code>transport.p12</code>: 同样为 PKCS#12 格式，但这个特定的文件是给 Elasticsearch 节点之间内部传输层使用的。在集群内，节点间需<br>\n要相互认证，transport.p12就包含着让不同 Elasticsearch 实例能互相识别所需的私钥和证书。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>总之，<code>http.p12</code>服务于面向 Web 的接口，而<code>transport.p12</code>则处理 Elasticsearch 群集内的交互；两者都依赖于<code>http_ca.crt</code>来进行身份验证过程的一部分。</p>\n</li>\n</ul>\n<h2 id=\"ES证书过期的影响\">ES证书过期的影响</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>‌集群无法增加新节点‌：特别是在重启集群时，节点无法加入集群，导致无法正常重启。‌</p>\n</li>\n<li class=\"lvl-2\">\n<p>‌访问异常‌：如果使用证书连接ES集群，会导致无法正常访问集群。</p>\n</li>\n<li class=\"lvl-2\">\n<p>‌安全风险‌：证书过期会破坏证书链的信任，可能引发安全漏洞。</p>\n</li>\n<li class=\"lvl-2\">\n<p>‌日志干扰‌：会持续出现证书过期的错误日志，干扰问题排查和诊断。</p>\n</li>\n</ul>\n<h2 id=\"查看证书的过期时间\">查看证书的过期时间</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过openssl查看证书的过期时间</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看crt证书到期时间</span></span><br><span class=\"line\"><span class=\"comment\"># -dates: 显示证书的开始时间和结束时间</span></span><br><span class=\"line\"><span class=\"comment\"># -noout: 不输出证书的详细信息</span></span><br><span class=\"line\">openssl x509 -<span class=\"keyword\">in</span> config/certs/http_ca.crt -dates -noout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看p12证书到期时间</span></span><br><span class=\"line\"><span class=\"comment\"># -clcerts: 只显示证书，不显示私钥</span></span><br><span class=\"line\"><span class=\"comment\"># -nokeys: 不输出私钥</span></span><br><span class=\"line\"><span class=\"comment\"># -password pass: 指定私钥的密码，这里为空(因为在创建证书时没有设置密码)，注意密码必须写在pass:的后面，不加这个参数会提示你输入密码，直接回车即可</span></span><br><span class=\"line\">openssl pkcs12 -<span class=\"keyword\">in</span> ca.p12 -password pass: -clcerts -nokeys | openssl x509 -dates -noout</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过ES的API查看证书过期时间</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XGET -k -u <span class=\"string\">&#x27;elastic:123456&#x27;</span> <span class=\"string\">&#x27;https://127.0.0.1:9200/_ssl/certificates?pretty&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"证书过期处理\">证书过期处理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Elasticsearch 8 的证书创建需要使用命令行工具 <code>elasticsearch-certutil</code>，这部分的详细信息可以参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/certutil.html\">官方文档:elasticsearch-certutil</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>当证书过期时，需要重新生成证书，并更新<code>config/certs</code>目录下的文件，更新前要备份原证书。</p>\n</li>\n</ul>\n<h3 id=\"备份原证书\">备份原证书</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cp</span> -r config/certs config/certs.bak</span><br><span class=\"line\">$ <span class=\"built_in\">rm</span> -rf config/certs/*</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成新证书\">生成新证书</h3>\n<h4 id=\"生成CA证书\">生成CA证书</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成crt证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --days 36500: 指定证书的有效期，单位为天，这里设置为 36500 天，大约 10 年</span></span><br><span class=\"line\">$ bin/elasticsearch-certutil ca --pem --out new-ca.zip --days 36500</span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">$ unzip new-ca.zip</span><br><span class=\"line\"><span class=\"comment\"># 将创建的证书移动到指定目录</span></span><br><span class=\"line\">$ <span class=\"built_in\">mv</span> ca/ca.crt config/certs/http_ca.crt</span><br><span class=\"line\">$ <span class=\"built_in\">mv</span> ca/ca.key config/certs/http_ca.key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以生成PKCS#12格式的证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bin/elasticsearch-certutil ca --out config/certs/ca.p12 --days 36500</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成transport证书\">生成transport证书</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基于crt证书</span></span><br><span class=\"line\">$ bin/elasticsearch-certutil cert --ca-cert config/certs/http_ca.crt --ca-key config/certs/http_ca.key --out config/certs/transport.p12 --days 36500</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基于PKCS#12格式的证书</span></span><br><span class=\"line\">$ bin/elasticsearch-certutil cert --ca config/certs/ca.p12 --out config/certs/transport.p12 --days 36500</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成http证书\">生成http证书</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里是交互式命令行</span></span><br><span class=\"line\">$ bin/elasticsearch-certutil http</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>输出说明</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generate a CSR? [y/N]n # 不生成CSR</span><br><span class=\"line\">Use an existing CA? [y/N]y # 使用已有的CA</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">以下区分crt证书和PKCS#12格式的证书</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">crt 证书</span></span><br><span class=\"line\">CA Path: certs/http_ca.crt # CA证书，这里相对路径是相对应 config 目录，也可以是绝对路径</span><br><span class=\"line\">CA Key: certs/http_ca.key # CA密钥，这里相对路径是相对应 config 目录，也可以是绝对路径</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">PKCS#12格式的证书</span></span><br><span class=\"line\">CA Path: certs/ca.p12 # CA证书，这里相对路径是相对应 config 目录，也可以是绝对路径</span><br><span class=\"line\">Password for ca.p12: # CA密码，因为没有设置密码，所以这里直接回车</span><br><span class=\"line\"></span><br><span class=\"line\">For how long should your certificate be valid? [5y] 100y # 证书有效期，单位为年，默认是 5 年，这里设置为 100 年</span><br><span class=\"line\">Generate a certificate per node? [y/N]n # 不为每个节点创建独立的证书，即所有节点都使用同一个证书</span><br><span class=\"line\">Enter all the hostnames that you need, one per line.</span><br><span class=\"line\">When you are done, press &lt;ENTER&gt; once more to move on to the next step.</span><br><span class=\"line\"></span><br><span class=\"line\">localhost # 主机名，这里可以添加多个，回车一行一个，这里应该填写集群内所有节点服务器的hostname，可以通过 hostname 命令查看</span><br><span class=\"line\">ip-10-250-0-17.cn-northwest-1.compute.internal</span><br><span class=\"line\">ip-10-250-0-173.cn-northwest-1.compute.internal</span><br><span class=\"line\">ip-10-250-0-239.cn-northwest-1.compute.internal</span><br><span class=\"line\"></span><br><span class=\"line\">You entered the following hostnames.</span><br><span class=\"line\"></span><br><span class=\"line\"> - localhost</span><br><span class=\"line\"> - ip-10-250-0-17.cn-northwest-1.compute.internal</span><br><span class=\"line\"> - ip-10-250-0-173.cn-northwest-1.compute.internal</span><br><span class=\"line\"> - ip-10-250-0-239.cn-northwest-1.compute.internal</span><br><span class=\"line\"></span><br><span class=\"line\">Is this correct [Y/n]y # 确认主机名是否正确</span><br><span class=\"line\"></span><br><span class=\"line\">Enter all the IP addresses that you need, one per line.</span><br><span class=\"line\">When you are done, press &lt;ENTER&gt; once more to move on to the next step.</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1 # 主机IP，这里可以添加多个，回车一行一个，这里应该填写集群内所有节点服务器的IP地址</span><br><span class=\"line\">10.250.0.17</span><br><span class=\"line\">10.250.0.173</span><br><span class=\"line\">10.250.0.239</span><br><span class=\"line\"></span><br><span class=\"line\">You entered the following IP addresses.</span><br><span class=\"line\"></span><br><span class=\"line\"> - 127.0.0.1</span><br><span class=\"line\"> - 10.250.0.17</span><br><span class=\"line\"> - 10.250.0.173</span><br><span class=\"line\"> - 10.250.0.239</span><br><span class=\"line\"></span><br><span class=\"line\">Is this correct [Y/n]y # 确认IP是否正确</span><br><span class=\"line\"></span><br><span class=\"line\">Do you wish to change any of these options? [y/N]n # 不修改任何选项</span><br><span class=\"line\"></span><br><span class=\"line\">If you wish to use a blank password, simply press &lt;enter&gt; at the prompt below.</span><br><span class=\"line\">Provide a password for the &quot;http.p12&quot; file:  [&lt;ENTER&gt; for none] # 直接回车不设置密码</span><br><span class=\"line\"></span><br><span class=\"line\">What filename should be used for the output zip file? [/usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip] # 输出文件名，这里可以自定义，默认是 elasticsearch-ssl-http.zip</span><br><span class=\"line\"></span><br><span class=\"line\">Zip file written to /usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解压并将http证书拷贝到config/certs目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unzip elasticsearch-ssl-http.zip</span><br><span class=\"line\">Archive:  elasticsearch-ssl-http.zip</span><br><span class=\"line\">   creating: elasticsearch/</span><br><span class=\"line\">  inflating: elasticsearch/README.txt <span class=\"comment\"># 说明文件</span></span><br><span class=\"line\">  inflating: elasticsearch/http.p12  <span class=\"comment\"># http证书</span></span><br><span class=\"line\">  inflating: elasticsearch/sample-elasticsearch.yml <span class=\"comment\"># 示例elasticsearch配置文件</span></span><br><span class=\"line\">   creating: kibana/</span><br><span class=\"line\">  inflating: kibana/README.txt <span class=\"comment\"># 说明文件</span></span><br><span class=\"line\">  inflating: kibana/elasticsearch-ca.pem  <span class=\"comment\"># kibana用于验证ES的证书，即 elasticsearch.ssl.certificateAuthorities 中的配置</span></span><br><span class=\"line\">  inflating: kibana/sample-kibana.yml <span class=\"comment\"># 示例kibana配置文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将http证书拷贝到config/certs目录下</span></span><br><span class=\"line\">$ <span class=\"built_in\">cp</span> elasticsearch/http.p12 config/certs/http.p12</span><br></pre></td></tr></table></figure>\n<h3 id=\"分发到ES集群中的每个节点\">分发到ES集群中的每个节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面创建新的证书时我们只在一个节点上进行即可，之后将生成好的证书分发到ES集群中的其它节点，这里就是 <code>http.p12</code> 和 <code>transport.p12</code>，将其拷贝到每个节点的 <code>config/certs</code> 目录下，拷贝前做好原证书的备份。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如有必要也可以拷贝 <code>ca.p12</code> 或者 <code>http_ca.crt</code> 和 <code>http_ca.key</code> 到每个节点的 <code>config/certs</code> 目录下</p>\n</li>\n</ul>\n<h3 id=\"重启ES服务\">重启ES服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群中的节点依次重启</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bin/elasticsearch -d</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启时可能会报错</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.elasticsearch.ElasticsearchSecurityException: failed to load SSL configuration [xpack.security.transport.ssl] - cannot <span class=\"built_in\">read</span> configured [PKCS12] keystore (as a truststore) [/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/transport.p12] - this is usually caused by an incorrect password; (a keystore password was provided)</span><br><span class=\"line\"><span class=\"comment\"># 虽然我们没有给transport.p12设置密码，但这里依旧提示提供的密码不正确，实际上这里使用的是 secure_password</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用bin/elasticsearch-keystore list查看现有的密钥列表</span></span><br><span class=\"line\">$ bin/elasticsearch-keystore list</span><br><span class=\"line\">keystore.seed</span><br><span class=\"line\">xpack.security.http.ssl.keystore.secure_password</span><br><span class=\"line\">xpack.security.transport.ssl.keystore.secure_password</span><br><span class=\"line\">xpack.security.transport.ssl.truststore.secure_password</span><br><span class=\"line\"><span class=\"comment\"># 删除secure_password后再次重启ES服务就会正常了</span></span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.http.ssl.keystore.secure_password</span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.keystore.secure_password</span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.truststore.secure_password</span><br></pre></td></tr></table></figure>\n<h3 id=\"替换Kibana的证书\">替换Kibana的证书</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将上面创建好的 <code>kibana/elasticsearch-ca.pem</code> 拷贝到Kibana服务器，比如 <code>/usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>修改Kibana配置文件 <code>config/kibana.yml</code> 中的 <code>elasticsearch.ssl.certificateAuthorities</code> 配置，使其指向 <code>/usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem</code></p>\n</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">elasticsearch.ssl.certificateAuthorities:</span> [<span class=\"string\">&quot;/usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启Kibana服务</p>\n</li>\n</ul>\n<h2 id=\"证书格式转换\">证书格式转换</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># p12转换为crt格式</span></span><br><span class=\"line\">$ openssl pkcs12 -<span class=\"keyword\">in</span> config/certs/ca.p12 -out config/certs/http_ca.crt -nokeys</span><br><span class=\"line\"><span class=\"comment\"># p12转换为key格式</span></span><br><span class=\"line\">$ openssl pkcs12 -<span class=\"keyword\">in</span> config/certs/ca.p12 -out config/certs/http_ca.key -nocerts -nodes</span><br><span class=\"line\"><span class=\"comment\"># p12转换为pem格式</span></span><br><span class=\"line\">$ openssl pkcs12 -<span class=\"keyword\">in</span> config/certs/ca.p12 -out config/certs/http_ca.pem -nodes</span><br><span class=\"line\"><span class=\"comment\"># crt转换回PKCS12格式</span></span><br><span class=\"line\">$ openssl pkcs12 -<span class=\"built_in\">export</span> -out config/certs/http_ca.p12 -inkey config/certs/http_ca.key -<span class=\"keyword\">in</span> config/certs/http_ca.crt -name <span class=\"string\">&quot;My CA&quot;</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>生成http证书时为每个节点单独配置证书</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generate a certificate per node? [y/N]y <span class=\"comment\"># 是否为每个节点单独配置证书，这里选择是</span></span><br><span class=\"line\">node <span class=\"comment\">#1 name: node-1 # 节点名称，必须与ES配置文件中的node.name一致</span></span><br><span class=\"line\"></span><br><span class=\"line\">Enter all the hostnames that you need, one per line. <span class=\"comment\"># 输入 node-1 节点的hostname</span></span><br><span class=\"line\">When you are <span class=\"keyword\">done</span>, press &lt;ENTER&gt; once more to move on to the next step.</span><br><span class=\"line\"></span><br><span class=\"line\">localhost                                         <span class=\"comment\"># 习惯加上 localhost</span></span><br><span class=\"line\">ip-10-250-0-239.cn-northwest-1.compute.internal   <span class=\"comment\"># node-1 的 hostname</span></span><br><span class=\"line\"></span><br><span class=\"line\">You entered the following hostnames.</span><br><span class=\"line\"></span><br><span class=\"line\"> - localhost</span><br><span class=\"line\"> - ip-10-250-0-239.cn-northwest-1.compute.internal</span><br><span class=\"line\"></span><br><span class=\"line\">Is this correct [Y/n]y <span class=\"comment\"># 确认是否正确</span></span><br><span class=\"line\"></span><br><span class=\"line\">Enter all the IP addresses that you need, one per line. <span class=\"comment\"># 输入 node-1 节点的IP地址</span></span><br><span class=\"line\">When you are <span class=\"keyword\">done</span>, press &lt;ENTER&gt; once more to move on to the next step.</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1                                         <span class=\"comment\"># 习惯加上 127.0.0.1</span></span><br><span class=\"line\">10.250.0.239                                      <span class=\"comment\"># node-1 的 IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">You entered the following IP addresses.</span><br><span class=\"line\"></span><br><span class=\"line\"> - 127.0.0.1</span><br><span class=\"line\"> - 10.250.0.239</span><br><span class=\"line\"></span><br><span class=\"line\">Is this correct [Y/n]y <span class=\"comment\"># 确认是否正确</span></span><br><span class=\"line\"></span><br><span class=\"line\">Do you wish to change any of these options? [y/N]n <span class=\"comment\"># 不修改任何选项</span></span><br><span class=\"line\">Generate additional certificates? [Y/n]y  <span class=\"comment\"># 是否生成其他证书，这里选择是，接着为其它节点创建证书</span></span><br><span class=\"line\">node <span class=\"comment\">#2 name: node-2 # 节点名称，必须与ES配置文件中的node.name一致</span></span><br><span class=\"line\"><span class=\"comment\"># 依次为每个节点创建证书</span></span><br><span class=\"line\">………………</span><br><span class=\"line\"></span><br><span class=\"line\">Generate additional certificates? [Y/n]n <span class=\"comment\"># 创建好所有节点的证书后，选择n，不再创建新的证书</span></span><br><span class=\"line\"></span><br><span class=\"line\">If you wish to use a blank password, simply press &lt;enter&gt; at the prompt below.</span><br><span class=\"line\">Provide a password <span class=\"keyword\">for</span> the <span class=\"string\">&quot;http.p12&quot;</span> file:  [&lt;ENTER&gt; <span class=\"keyword\">for</span> none] <span class=\"comment\"># 直接回车不设置密码</span></span><br><span class=\"line\"></span><br><span class=\"line\">What filename should be used <span class=\"keyword\">for</span> the output zip file? [/usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip] <span class=\"comment\"># 输出文件名，这里可以自定义，默认是 elasticsearch-ssl-http.zip</span></span><br><span class=\"line\"></span><br><span class=\"line\">Zip file written to /usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">此时解压查看文件结构</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip elasticsearch-ssl-http.zip</span><br><span class=\"line\">Archive:  elasticsearch-ssl-http.zip</span><br><span class=\"line\">   creating: elasticsearch/</span><br><span class=\"line\">   creating: elasticsearch/node-1/</span><br><span class=\"line\">  inflating: elasticsearch/node-1/README.txt</span><br><span class=\"line\">  inflating: elasticsearch/node-1/http.p12  <span class=\"comment\"># node-1 的证书</span></span><br><span class=\"line\">  inflating: elasticsearch/node-1/sample-elasticsearch.yml</span><br><span class=\"line\">   creating: elasticsearch/node-2/</span><br><span class=\"line\">  inflating: elasticsearch/node-2/README.txt</span><br><span class=\"line\">  inflating: elasticsearch/node-2/http.p12 <span class=\"comment\"># node-2 的证书</span></span><br><span class=\"line\">  inflating: elasticsearch/node-2/sample-elasticsearch.yml</span><br><span class=\"line\">  creating: elasticsearch/node-3/</span><br><span class=\"line\">  inflating: elasticsearch/node-3/README.txt</span><br><span class=\"line\">  inflating: elasticsearch/node-3/http.p12 <span class=\"comment\"># node-3 的证书</span></span><br><span class=\"line\">  inflating: elasticsearch/node-3/sample-elasticsearch.yml</span><br><span class=\"line\">   creating: kibana/</span><br><span class=\"line\">  inflating: kibana/README.txt</span><br><span class=\"line\">  inflating: kibana/elasticsearch-ca.pem <span class=\"comment\"># kibana 的证书</span></span><br><span class=\"line\">  inflating: kibana/sample-kibana.yml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>将对应的证书拷贝到对应节点的 <code>config/certs</code> 目录下</p>\n</li>\n</ul>\n</div>\n","content_text":"摘要 本文介绍Elasticsearch证书过期时的处理方法 Elasticsearch版本8.17.3 本文基于 linux下安装Elasticsearch 官方文档:Updating node security certificates ES证书简介 Elasticsearch 8 默认情况下创建的证书只有3年有效期，过期时需要创建新的证书，为了不必要的麻烦，也可以一开始就创建一个有效期比较长的证书。 在 Elasticsearch 8 的配置下，config/certs 目录通常存放的是用于安全通信的证书和密钥文件。这些文件确保了 Elasticsearch 实例之间的通讯以及与外部客户端的通讯能够被加密且经过认证。 config/certs 目录包含三个文件分别是： http.p12: 这是一个 PKCS#12 格式的文件（通常带有.p12或.pfx扩展名），包含了 Elasticsearch HTTP 层用来进行 TLS/SSL 通信所需的一切，包括一个私钥、相应的公钥证书（服务器证书）及 CA 证书链。客户端使用这个文件来验证它们正在与正确的服务器进行通信，并且此服务器也信任该客户端。 http_ca.crt: CA (Certificate Authority) 根证书或中间证书，用于验证通过 HTTP 协议连接至 Elasticsearch 服务端点的身份。当客户端尝试建立 HTTPS 连接时，它会检查来自 Elasticsearch 的证书是否由这个 CA 签名；这是确保双方通信安全的重要步骤之一。 transport.p12: 同样为 PKCS#12 格式，但这个特定的文件是给 Elasticsearch 节点之间内部传输层使用的。在集群内，节点间需 要相互认证，transport.p12就包含着让不同 Elasticsearch 实例能互相识别所需的私钥和证书。 总之，http.p12服务于面向 Web 的接口，而transport.p12则处理 Elasticsearch 群集内的交互；两者都依赖于http_ca.crt来进行身份验证过程的一部分。 ES证书过期的影响 ‌集群无法增加新节点‌：特别是在重启集群时，节点无法加入集群，导致无法正常重启。‌ ‌访问异常‌：如果使用证书连接ES集群，会导致无法正常访问集群。 ‌安全风险‌：证书过期会破坏证书链的信任，可能引发安全漏洞。 ‌日志干扰‌：会持续出现证书过期的错误日志，干扰问题排查和诊断。 查看证书的过期时间 通过openssl查看证书的过期时间 12345678910# 查看crt证书到期时间# -dates: 显示证书的开始时间和结束时间# -noout: 不输出证书的详细信息openssl x509 -in config/certs/http_ca.crt -dates -noout# 查看p12证书到期时间# -clcerts: 只显示证书，不显示私钥# -nokeys: 不输出私钥# -password pass: 指定私钥的密码，这里为空(因为在创建证书时没有设置密码)，注意密码必须写在pass:的后面，不加这个参数会提示你输入密码，直接回车即可openssl pkcs12 -in ca.p12 -password pass: -clcerts -nokeys | openssl x509 -dates -noout 通过ES的API查看证书过期时间 1curl -XGET -k -u &#x27;elastic:123456&#x27; &#x27;https://127.0.0.1:9200/_ssl/certificates?pretty&#x27; 证书过期处理 Elasticsearch 8 的证书创建需要使用命令行工具 elasticsearch-certutil，这部分的详细信息可以参考官方文档:elasticsearch-certutil 当证书过期时，需要重新生成证书，并更新config/certs目录下的文件，更新前要备份原证书。 备份原证书 12$ cp -r config/certs config/certs.bak$ rm -rf config/certs/* 生成新证书 生成CA证书 生成crt证书 1234567# --days 36500: 指定证书的有效期，单位为天，这里设置为 36500 天，大约 10 年$ bin/elasticsearch-certutil ca --pem --out new-ca.zip --days 36500# 解压$ unzip new-ca.zip# 将创建的证书移动到指定目录$ mv ca/ca.crt config/certs/http_ca.crt$ mv ca/ca.key config/certs/http_ca.key 也可以生成PKCS#12格式的证书 1$ bin/elasticsearch-certutil ca --out config/certs/ca.p12 --days 36500 生成transport证书 12345# 基于crt证书$ bin/elasticsearch-certutil cert --ca-cert config/certs/http_ca.crt --ca-key config/certs/http_ca.key --out config/certs/transport.p12 --days 36500# 基于PKCS#12格式的证书$ bin/elasticsearch-certutil cert --ca config/certs/ca.p12 --out config/certs/transport.p12 --days 36500 生成http证书 12# 这里是交互式命令行$ bin/elasticsearch-certutil http 输出说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Generate a CSR? [y/N]n # 不生成CSRUse an existing CA? [y/N]y # 使用已有的CA# 以下区分crt证书和PKCS#12格式的证书# crt 证书CA Path: certs/http_ca.crt # CA证书，这里相对路径是相对应 config 目录，也可以是绝对路径CA Key: certs/http_ca.key # CA密钥，这里相对路径是相对应 config 目录，也可以是绝对路径# PKCS#12格式的证书CA Path: certs/ca.p12 # CA证书，这里相对路径是相对应 config 目录，也可以是绝对路径Password for ca.p12: # CA密码，因为没有设置密码，所以这里直接回车For how long should your certificate be valid? [5y] 100y # 证书有效期，单位为年，默认是 5 年，这里设置为 100 年Generate a certificate per node? [y/N]n # 不为每个节点创建独立的证书，即所有节点都使用同一个证书Enter all the hostnames that you need, one per line.When you are done, press &lt;ENTER&gt; once more to move on to the next step.localhost # 主机名，这里可以添加多个，回车一行一个，这里应该填写集群内所有节点服务器的hostname，可以通过 hostname 命令查看ip-10-250-0-17.cn-northwest-1.compute.internalip-10-250-0-173.cn-northwest-1.compute.internalip-10-250-0-239.cn-northwest-1.compute.internalYou entered the following hostnames. - localhost - ip-10-250-0-17.cn-northwest-1.compute.internal - ip-10-250-0-173.cn-northwest-1.compute.internal - ip-10-250-0-239.cn-northwest-1.compute.internalIs this correct [Y/n]y # 确认主机名是否正确Enter all the IP addresses that you need, one per line.When you are done, press &lt;ENTER&gt; once more to move on to the next step.127.0.0.1 # 主机IP，这里可以添加多个，回车一行一个，这里应该填写集群内所有节点服务器的IP地址10.250.0.1710.250.0.17310.250.0.239You entered the following IP addresses. - 127.0.0.1 - 10.250.0.17 - 10.250.0.173 - 10.250.0.239Is this correct [Y/n]y # 确认IP是否正确Do you wish to change any of these options? [y/N]n # 不修改任何选项If you wish to use a blank password, simply press &lt;enter&gt; at the prompt below.Provide a password for the &quot;http.p12&quot; file: [&lt;ENTER&gt; for none] # 直接回车不设置密码What filename should be used for the output zip file? [/usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip] # 输出文件名，这里可以自定义，默认是 elasticsearch-ssl-http.zipZip file written to /usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip 解压并将http证书拷贝到config/certs目录下 12345678910111213$ unzip elasticsearch-ssl-http.zipArchive: elasticsearch-ssl-http.zip creating: elasticsearch/ inflating: elasticsearch/README.txt # 说明文件 inflating: elasticsearch/http.p12 # http证书 inflating: elasticsearch/sample-elasticsearch.yml # 示例elasticsearch配置文件 creating: kibana/ inflating: kibana/README.txt # 说明文件 inflating: kibana/elasticsearch-ca.pem # kibana用于验证ES的证书，即 elasticsearch.ssl.certificateAuthorities 中的配置 inflating: kibana/sample-kibana.yml # 示例kibana配置文件# 将http证书拷贝到config/certs目录下$ cp elasticsearch/http.p12 config/certs/http.p12 分发到ES集群中的每个节点 上面创建新的证书时我们只在一个节点上进行即可，之后将生成好的证书分发到ES集群中的其它节点，这里就是 http.p12 和 transport.p12，将其拷贝到每个节点的 config/certs 目录下，拷贝前做好原证书的备份。 如有必要也可以拷贝 ca.p12 或者 http_ca.crt 和 http_ca.key 到每个节点的 config/certs 目录下 重启ES服务 集群中的节点依次重启 1$ bin/elasticsearch -d 重启时可能会报错 12org.elasticsearch.ElasticsearchSecurityException: failed to load SSL configuration [xpack.security.transport.ssl] - cannot read configured [PKCS12] keystore (as a truststore) [/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/transport.p12] - this is usually caused by an incorrect password; (a keystore password was provided)# 虽然我们没有给transport.p12设置密码，但这里依旧提示提供的密码不正确，实际上这里使用的是 secure_password 解决方法 12345678910# 使用bin/elasticsearch-keystore list查看现有的密钥列表$ bin/elasticsearch-keystore listkeystore.seedxpack.security.http.ssl.keystore.secure_passwordxpack.security.transport.ssl.keystore.secure_passwordxpack.security.transport.ssl.truststore.secure_password# 删除secure_password后再次重启ES服务就会正常了$ bin/elasticsearch-keystore remove xpack.security.http.ssl.keystore.secure_password$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.keystore.secure_password$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.truststore.secure_password 替换Kibana的证书 将上面创建好的 kibana/elasticsearch-ca.pem 拷贝到Kibana服务器，比如 /usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem 修改Kibana配置文件 config/kibana.yml 中的 elasticsearch.ssl.certificateAuthorities 配置，使其指向 /usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem 1elasticsearch.ssl.certificateAuthorities: [&quot;/usr/local/kibana/kibana-8.17.3/config/certs/elasticsearch-ca.pem&quot;] 重启Kibana服务 证书格式转换 12345678# p12转换为crt格式$ openssl pkcs12 -in config/certs/ca.p12 -out config/certs/http_ca.crt -nokeys# p12转换为key格式$ openssl pkcs12 -in config/certs/ca.p12 -out config/certs/http_ca.key -nocerts -nodes# p12转换为pem格式$ openssl pkcs12 -in config/certs/ca.p12 -out config/certs/http_ca.pem -nodes# crt转换回PKCS12格式$ openssl pkcs12 -export -out config/certs/http_ca.p12 -inkey config/certs/http_ca.key -in config/certs/http_ca.crt -name &quot;My CA&quot; 生成http证书时为每个节点单独配置证书 12345678910111213141516171819202122232425262728293031323334353637383940414243Generate a certificate per node? [y/N]y # 是否为每个节点单独配置证书，这里选择是node #1 name: node-1 # 节点名称，必须与ES配置文件中的node.name一致Enter all the hostnames that you need, one per line. # 输入 node-1 节点的hostnameWhen you are done, press &lt;ENTER&gt; once more to move on to the next step.localhost # 习惯加上 localhostip-10-250-0-239.cn-northwest-1.compute.internal # node-1 的 hostnameYou entered the following hostnames. - localhost - ip-10-250-0-239.cn-northwest-1.compute.internalIs this correct [Y/n]y # 确认是否正确Enter all the IP addresses that you need, one per line. # 输入 node-1 节点的IP地址When you are done, press &lt;ENTER&gt; once more to move on to the next step.127.0.0.1 # 习惯加上 127.0.0.110.250.0.239 # node-1 的 IPYou entered the following IP addresses. - 127.0.0.1 - 10.250.0.239Is this correct [Y/n]y # 确认是否正确Do you wish to change any of these options? [y/N]n # 不修改任何选项Generate additional certificates? [Y/n]y # 是否生成其他证书，这里选择是，接着为其它节点创建证书node #2 name: node-2 # 节点名称，必须与ES配置文件中的node.name一致# 依次为每个节点创建证书………………Generate additional certificates? [Y/n]n # 创建好所有节点的证书后，选择n，不再创建新的证书If you wish to use a blank password, simply press &lt;enter&gt; at the prompt below.Provide a password for the &quot;http.p12&quot; file: [&lt;ENTER&gt; for none] # 直接回车不设置密码What filename should be used for the output zip file? [/usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip] # 输出文件名，这里可以自定义，默认是 elasticsearch-ssl-http.zipZip file written to /usr/local/elasticsearch/elasticsearch-8.17.3/elasticsearch-ssl-http.zip 此时解压查看文件结构 12345678910111213141516171819unzip elasticsearch-ssl-http.zipArchive: elasticsearch-ssl-http.zip creating: elasticsearch/ creating: elasticsearch/node-1/ inflating: elasticsearch/node-1/README.txt inflating: elasticsearch/node-1/http.p12 # node-1 的证书 inflating: elasticsearch/node-1/sample-elasticsearch.yml creating: elasticsearch/node-2/ inflating: elasticsearch/node-2/README.txt inflating: elasticsearch/node-2/http.p12 # node-2 的证书 inflating: elasticsearch/node-2/sample-elasticsearch.yml creating: elasticsearch/node-3/ inflating: elasticsearch/node-3/README.txt inflating: elasticsearch/node-3/http.p12 # node-3 的证书 inflating: elasticsearch/node-3/sample-elasticsearch.yml creating: kibana/ inflating: kibana/README.txt inflating: kibana/elasticsearch-ca.pem # kibana 的证书 inflating: kibana/sample-kibana.yml 将对应的证书拷贝到对应节点的 config/certs 目录下","summary":"摘要 本文介绍Elasticsearch证书过期时的处理方法 Elasticsearch版本8.17.3 本文基于 linux下安装Elasticsearch 官方文档:Updating node security certificates","date_published":"2025-04-16T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]},{"id":"https://blog.hanqunfeng.com/2025/04/07/elk-02-springboot/","url":"https://blog.hanqunfeng.com/2025/04/07/elk-02-springboot/","title":"Springboot整合Logstash实现日志采集","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在Springboot项目中整合LogStash实现日志采集</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于Springboot2.7.x版本进行测试，Logstash版本为8.17.3</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"使用logstash日志插件\">使用logstash日志插件</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/logfellow/logstash-logback-encoder\">SpringBoot的Logstash日志插件</a>，本文只进行简单介绍，更多详细配置可以参考<a href=\"https://github.com/logfellow/logstash-logback-encoder\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>引入依赖，这里需要注意8.x以上的版本需要jdk11，如果是jdk8的话可以使用6.x或7.x版本</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.logstash.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logstash-logback-encoder<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>7.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> <span class=\"comment\">&lt;!-- 版本号根据实际情况修改 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：<br>\nspringboot2.7.x以下版本，建议使用logstash-logback-encoder的7.3以下版本。<br>\nspringboot3.x.x以上版本，建议使用logstash-logback-encoder的7.4及以上版本。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>logback-spring.xml</code>中添加logstash配置</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 控制台输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;STDOUT&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125;：类路径，最大显示50个字符 %M：方法名称 %L：行号 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level [%X&#123;userName&#125;][%X&#123;userLocale&#125;] %logger&#123;50&#125; - %M - %L - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- logstash输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOGSTASH&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">destination</span>&gt;</span>161.189.78.202:4560<span class=\"tag\">&lt;/<span class=\"name\">destination</span>&gt;</span> <span class=\"comment\">&lt;!-- logstash地址和端口 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span> &gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">timestampPattern</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS<span class=\"tag\">&lt;/<span class=\"name\">timestampPattern</span>&gt;</span> <span class=\"comment\">&lt;!-- 时间格式，这个是默认值 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includeMdc</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeMdc</span>&gt;</span>   <span class=\"comment\">&lt;!-- 默认true, true表示输出MDC信息 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span> <span class=\"comment\">&lt;!-- 默认false, true表示输出打印日志的类名、方法名、行号等信息 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">customFields</span>&gt;</span>&#123;&quot;appname&quot;: &quot;springboot-logstash-demo&quot;&#125;<span class=\"tag\">&lt;/<span class=\"name\">customFields</span>&gt;</span> <span class=\"comment\">&lt;!-- 自定义字段 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;LOGSTASH&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加<code>config/springboot-demo.conf</code>配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">  tcp &#123;</span><br><span class=\"line\">    host =&gt; <span class=\"string\">&quot;0.0.0.0&quot;</span> <span class=\"comment\"># 监听任意地址</span></span><br><span class=\"line\">    port =&gt; <span class=\"string\">&quot;4560&quot;</span> <span class=\"comment\"># 监听端口</span></span><br><span class=\"line\">    mode =&gt; <span class=\"string\">&quot;server&quot;</span> <span class=\"comment\"># server模式</span></span><br><span class=\"line\">    codec =&gt; json_lines <span class=\"comment\"># 使用json_lines格式</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">  stdout &#123;</span><br><span class=\"line\">    codec =&gt; rubydebug</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  elasticsearch &#123; <span class=\"comment\"># 输出到ES</span></span><br><span class=\"line\">        index =&gt; <span class=\"string\">&quot;%&#123;[appname]&#125;-%&#123;+YYYY-MM-DD&#125;&quot;</span> <span class=\"comment\"># 索引名,按天分隔，这里使用变量appname作为索引名</span></span><br><span class=\"line\">        hosts =&gt; [<span class=\"string\">&quot;https://10.250.0.239:9200&quot;</span>] <span class=\"comment\"># ES地址</span></span><br><span class=\"line\">        user =&gt; <span class=\"string\">&quot;elastic&quot;</span>                   <span class=\"comment\"># ES用户名</span></span><br><span class=\"line\">        password =&gt; <span class=\"string\">&quot;123456&quot;</span>                <span class=\"comment\"># ES密码</span></span><br><span class=\"line\">        ssl =&gt; <span class=\"literal\">true</span>                         <span class=\"comment\"># 是否启用SSL，因为这里是https访问ES</span></span><br><span class=\"line\">        ssl_certificate_verification =&gt; <span class=\"literal\">false</span> <span class=\"comment\"># 禁用证书验证</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动logstash</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/logstash -f config/springboot-demo.conf --config.reload.automatic</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>logstash启动成功后，会输出类似如下信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;Tomcat started on port(s): 8088 (http) with context path &#x27;/springboot-logstash&#x27;&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;level_value&quot;</span> =&gt; 20000,</span><br><span class=\"line\">            <span class=\"string\">&quot;appname&quot;</span> =&gt; <span class=\"string\">&quot;springboot-logstash-demo&quot;</span>,</span><br><span class=\"line\">              <span class=\"string\">&quot;level&quot;</span> =&gt; <span class=\"string\">&quot;INFO&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;logger_name&quot;</span> =&gt; <span class=\"string\">&quot;org.springframework.boot.web.embedded.tomcat.TomcatWebServer&quot;</span>,</span><br><span class=\"line\">         <span class=\"string\">&quot;@timestamp&quot;</span> =&gt; 2025-04-07T09:39:43.569Z,</span><br><span class=\"line\">           <span class=\"string\">&quot;@version&quot;</span> =&gt; <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;thread_name&quot;</span> =&gt; <span class=\"string\">&quot;restartedMain&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;caller_class_name&quot;</span> =&gt; <span class=\"string\">&quot;org.springframework.boot.web.embedded.tomcat.TomcatWebServer&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;caller_file_name&quot;</span> =&gt; <span class=\"string\">&quot;TomcatWebServer.java&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;caller_method_name&quot;</span> =&gt; <span class=\"string\">&quot;start&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;caller_line_number&quot;</span> =&gt; 220,</span><br><span class=\"line\">        <span class=\"string\">&quot;userName&quot;</span> =&gt; <span class=\"string\">&quot;admin&quot;</span>, <span class=\"comment\"># MDC信息默认会打印</span></span><br><span class=\"line\">        <span class=\"string\">&quot;userLocale&quot;</span> =&gt; <span class=\"string\">&quot;zh_CN&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以访问ES或者Kibana查看索引信息，这里不再赘述。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍如何在Springboot项目中整合LogStash实现日志采集 本文基于Springboot2.7.x版本进行测试，Logstash版本为8.17.3 使用logstash日志插件 SpringBoot的Logstash日志插件，本文只进行简单介绍，更多详细配置可以参考官方文档 引入依赖，这里需要注意8.x以上的版本需要jdk11，如果是jdk8的话可以使用6.x或7.x版本 12345&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;7.3&lt;/version&gt; &lt;!-- 版本号根据实际情况修改 --&gt;&lt;/dependency&gt; 注意： springboot2.7.x以下版本，建议使用logstash-logback-encoder的7.3以下版本。 springboot3.x.x以上版本，建议使用logstash-logback-encoder的7.4及以上版本。 logback-spring.xml中添加logstash配置 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot;&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125;：类路径，最大显示50个字符 %M：方法名称 %L：行号 %msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level [%X&#123;userName&#125;][%X&#123;userLocale&#125;] %logger&#123;50&#125; - %M - %L - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logstash输出 --&gt; &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt; &lt;destination&gt;161.189.78.202:4560&lt;/destination&gt; &lt;!-- logstash地址和端口 --&gt; &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot; &gt; &lt;timestampPattern&gt;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&lt;/timestampPattern&gt; &lt;!-- 时间格式，这个是默认值 --&gt; &lt;includeMdc&gt;true&lt;/includeMdc&gt; &lt;!-- 默认true, true表示输出MDC信息 --&gt; &lt;includeCallerData&gt;true&lt;/includeCallerData&gt; &lt;!-- 默认false, true表示输出打印日志的类名、方法名、行号等信息 --&gt; &lt;customFields&gt;&#123;&quot;appname&quot;: &quot;springboot-logstash-demo&quot;&#125;&lt;/customFields&gt; &lt;!-- 自定义字段 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 添加config/springboot-demo.conf配置 123456789101112131415161718192021input &#123; tcp &#123; host =&gt; &quot;0.0.0.0&quot; # 监听任意地址 port =&gt; &quot;4560&quot; # 监听端口 mode =&gt; &quot;server&quot; # server模式 codec =&gt; json_lines # 使用json_lines格式 &#125;&#125;output &#123; stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; # 输出到ES index =&gt; &quot;%&#123;[appname]&#125;-%&#123;+YYYY-MM-DD&#125;&quot; # 索引名,按天分隔，这里使用变量appname作为索引名 hosts =&gt; [&quot;https://10.250.0.239:9200&quot;] # ES地址 user =&gt; &quot;elastic&quot; # ES用户名 password =&gt; &quot;123456&quot; # ES密码 ssl =&gt; true # 是否启用SSL，因为这里是https访问ES ssl_certificate_verification =&gt; false # 禁用证书验证 &#125;&#125; 启动logstash 1bin/logstash -f config/springboot-demo.conf --config.reload.automatic logstash启动成功后，会输出类似如下信息 12345678910111213141516&#123; &quot;message&quot; =&gt; &quot;Tomcat started on port(s): 8088 (http) with context path &#x27;/springboot-logstash&#x27;&quot;, &quot;level_value&quot; =&gt; 20000, &quot;appname&quot; =&gt; &quot;springboot-logstash-demo&quot;, &quot;level&quot; =&gt; &quot;INFO&quot;, &quot;logger_name&quot; =&gt; &quot;org.springframework.boot.web.embedded.tomcat.TomcatWebServer&quot;, &quot;@timestamp&quot; =&gt; 2025-04-07T09:39:43.569Z, &quot;@version&quot; =&gt; &quot;1&quot;, &quot;thread_name&quot; =&gt; &quot;restartedMain&quot;, &quot;caller_class_name&quot; =&gt; &quot;org.springframework.boot.web.embedded.tomcat.TomcatWebServer&quot;, &quot;caller_file_name&quot; =&gt; &quot;TomcatWebServer.java&quot;, &quot;caller_method_name&quot; =&gt; &quot;start&quot;, &quot;caller_line_number&quot; =&gt; 220, &quot;userName&quot; =&gt; &quot;admin&quot;, # MDC信息默认会打印 &quot;userLocale&quot; =&gt; &quot;zh_CN&quot;&#125; 可以访问ES或者Kibana查看索引信息，这里不再赘述。","summary":"摘要 本文介绍如何在Springboot项目中整合LogStash实现日志采集 本文基于Springboot2.7.x版本进行测试，Logstash版本为8.17.3","date_published":"2025-04-07T13:30:05.000Z","tags":["技术","springboot","logstash","springboot","logstash"]},{"id":"https://blog.hanqunfeng.com/2025/03/27/elk-01/","url":"https://blog.hanqunfeng.com/2025/03/27/elk-01/","title":"一文搞懂ELK","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在linux下安装LogStash和FileBeat</p>\n</li>\n<li class=\"lvl-2\">\n<p>通过示例讲解ELK的经典架构和高并发架构的实现过程</p>\n</li>\n<li class=\"lvl-2\">\n<p>LogStash版本8.17.3，FileBeat版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3，<a href=\"/2025/03/20/elasticsearch-01-install/\" title=\"linux下安装Elasticsearch\">linux下安装Elasticsearch</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Kibana版本8.17.3，<a href=\"/2025/03/21/kibana-01-install/\" title=\"linux下安装Kibana\">linux下安装Kibana</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch集群搭建，<a href=\"/2025/03/24/elasticsearch-02-install-cluster/\" title=\"linux下安装Elasticsearch集群\">linux下安装Elasticsearch集群</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Logstash概述\">Logstash概述</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/cn/logstash\">Logstash</a> 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的存储库中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Logstash数据传输原理<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/image-2.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.数据采集与输入：Logstash支持各种输入选择，能够以连续的流式传输方式，轻松地从日志、指标、Web应用以及数据存储中采集数据。</span><br><span class=\"line\">2.实时解析和数据转换：通过Logstash过滤器解析各个事件，识别已命名的字段来构建结构，并将它们转换成通用格式，最终将数据从源端传输到存储库中。</span><br><span class=\"line\">3.存储与数据导出：Logstash提供多种输出选择，可以将数据发送到指定的地方。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%9B%BE-3.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Logstash通过管道完成数据的采集与处理，管道配置中包含input、output和filter（可选）插件，input和output用来配置输入和输出数据源、filter用来对数据进行过滤或预处理。</p>\n</li>\n</ul>\n<h2 id=\"Logstash下载安装\">Logstash下载安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载地址：<a href=\"https://www.elastic.co/cn/downloads/past-releases#logstash\">https://www.elastic.co/cn/downloads/past-releases#logstash</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>选择对应的版本：这里选择当前的最新版<code>LogStash 8.17.3</code>，之后选择对应的操作系统<code>LINUX X86_64</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://artifacts.elastic.co/downloads/logstash/logstash-8.17.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载完成后解压到<code>/usr/local/logstash</code>目录下，解压命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/logstash</span><br><span class=\"line\">tar -zxvf logstash-8.17.3-linux-x86_64.tar.gz -C /usr/local/logstash</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>elasticsearch和kibana都不能用root用户启动，为了统一管理，logstash也使用这个用户（非必要）</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建用户<code>elastic</code>，并设置密码，这一步我们在安装elasticsearch的时候已经配置过了，这里就不再赘述了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd elastic</span><br><span class=\"line\">passwd elastic</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改logstash安装目录的用户权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> -R elastic:elastic /usr/local/logstash</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>切换到elastic用户下执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换用户</span></span><br><span class=\"line\">su - elastic</span><br><span class=\"line\"><span class=\"comment\"># 进入logstash安装目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/logstash/logstash-8.17.3/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行一个简单的测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -e: 直接把配置放在命令中，这样可以有效快速进行测试</span></span><br><span class=\"line\"><span class=\"comment\"># input &#123; stdin &#123; &#125; &#125;: 输入插件，从标准输入中读取数据</span></span><br><span class=\"line\"><span class=\"comment\"># output &#123; stdout &#123;&#125; &#125;: 输出插件，将数据输出到标准输出</span></span><br><span class=\"line\"><span class=\"comment\"># 这里只包含了 input 和 output 两个部分，实际使用中还需要添加 filter 部分</span></span><br><span class=\"line\">./bin/logstash -e <span class=\"string\">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">。。。。。。。 <span class=\"comment\"># 输出启动信息</span></span><br><span class=\"line\">The stdin plugin is now waiting <span class=\"keyword\">for</span> input: <span class=\"comment\"># 输出提示信息，提示你输入内容</span></span><br><span class=\"line\">hello world  <span class=\"comment\"># 我输入内容</span></span><br><span class=\"line\"><span class=\"comment\"># logstash输出内容</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;hello world&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;@version&quot;</span> =&gt; <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">         <span class=\"string\">&quot;event&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;original&quot;</span> =&gt; <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;host&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;hostname&quot;</span> =&gt; <span class=\"string\">&quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;@timestamp&quot;</span> =&gt; 2025-03-27T06:48:12.810617855Z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以通过配置文件启动logstash</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim test.conf</span></span><br><span class=\"line\">input &#123;</span><br><span class=\"line\">  stdin &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># codec =&gt; rubydebug : 是指定了一个编码器（Codec）为 rubydebug。</span></span><br><span class=\"line\"><span class=\"comment\"># 编码器负责如何格式化输出的数据。</span></span><br><span class=\"line\"><span class=\"comment\"># Rubydebug 编码器是一种特别适合开发和调试目的的编码器，因为它能以相当易读的形式展示复杂的结构化数据，比如嵌套的哈希表或者数组。</span></span><br><span class=\"line\"><span class=\"comment\"># 除了 Rubydebug 编码器，Logstash 还提供了其他几种编码器，比如 json、plain、multiline 等等。</span></span><br><span class=\"line\"><span class=\"comment\"># 具体可以参考官方文档：https://www.elastic.co/guide/en/logstash/current/codec-plugins.html</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/logstash -f ./test.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"Logstash插件\">Logstash插件</h2>\n<h3 id=\"Input-Plugins\">Input Plugins</h3>\n<blockquote>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/8.17/input-plugins.html\">https://www.elastic.co/guide/en/logstash/8.17/input-plugins.html</a></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 Pipeline可以有多个input插件</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Stdin / File</span><br><span class=\"line\">- Beats / Log4J /Elasticsearch / JDBC / Kafka /Rabbitmq /Redis</span><br><span class=\"line\">- JMX/ HTTP / Websocket / UDP / TCP</span><br><span class=\"line\">- Google Cloud Storage / S3</span><br><span class=\"line\">- Github / Twitter</span><br></pre></td></tr></table></figure>\n<h3 id=\"Filter-Plugins\">Filter Plugins</h3>\n<blockquote>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/8.17/filter-plugins.html\">https://www.elastic.co/guide/en/logstash/8.17/filter-plugins.html</a></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Filter Plugin可以对Logstash Event进行各种处理，例如解析，删除字段，类型转换</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Date: 日期解析</span><br><span class=\"line\">- Dissect: 分割符解析</span><br><span class=\"line\">- Grok: 正则匹配解析</span><br><span class=\"line\">- Mutate: 对字段做各种操作</span><br><span class=\"line\">- Convert : 类型转换</span><br><span class=\"line\">- Gsub : 字符串替换</span><br><span class=\"line\">- Split / Join /Merge:  字符串切割，数组合并字符串，数组合并数组</span><br><span class=\"line\">- Rename: 字段重命名</span><br><span class=\"line\">- Update / Replace: 字段内容更新替换</span><br><span class=\"line\">- Remove_field: 字段删除</span><br><span class=\"line\">- Ruby: 利用Ruby 代码来动态修改Event</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output-Plugins\">Output Plugins</h3>\n<blockquote>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/8.17/output-plugins.html\">https://www.elastic.co/guide/en/logstash/8.17/output-plugins.html</a></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将Event发送到特定的目的地，是 Pipeline 的最后一个阶段。常见 Output Plugins：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Elasticsearch</span><br><span class=\"line\">- Email / Pageduty</span><br><span class=\"line\">- Influxdb / Kafka / Mongodb / Opentsdb / Zabbix</span><br><span class=\"line\">- Http / TCP / Websocket</span><br></pre></td></tr></table></figure>\n<h3 id=\"Codec-Plugins\">Codec Plugins</h3>\n<blockquote>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/8.17/codec-plugins.html\">https://www.elastic.co/guide/en/logstash/8.17/codec-plugins.html</a></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将原始数据decode成Event;将Event encode成目标数据，内置的Codec Plugins:</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Line / Multiline</span><br><span class=\"line\">- JSON / Avro / Cef (ArcSight Common Event Format)</span><br><span class=\"line\">- Dots / Rubydebug</span><br></pre></td></tr></table></figure>\n<h2 id=\"FileBeat概述\">FileBeat概述</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/cn/beats\">Beats</a> 是一个免费且开放的平台，集合了多种单一用途的数据采集器。它们从成百上千或成千上万台机器和系统向 Logstash 或 Elasticsearch 发送数据。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iEmI1C.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/cn/beats/filebeat\">FileBeat</a> 专门用于转发和收集日志数据的轻量级采集工具。它可以作为代理安装在服务器上，FileBeat监视指定路径的日志文件，收集日志数据，并将收集到的日志转发到Elasticsearch或者Logstash。</p>\n</li>\n</ul>\n<h2 id=\"logstash-vs-FileBeat\">logstash vs FileBeat</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Logstash是在jvm上运行的，资源消耗比较大。而FileBeat是基于golang编写的，功能较少但资源消耗也比较小，更轻量级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Logstash 和Filebeat都具有日志收集功能，Filebeat更轻量，占用资源更少</p>\n</li>\n<li class=\"lvl-2\">\n<p>Logstash 具有Filter功能，能过滤分析日志</p>\n</li>\n<li class=\"lvl-2\">\n<p>一般结构都是Filebeat采集日志，然后发送到消息队列、Redis、MQ中，然后Logstash去获取，利用Filter功能过滤分析，然后存储到Elasticsearch中</p>\n</li>\n<li class=\"lvl-2\">\n<p>FileBeat和Logstash配合，实现背压机制。当将数据发送到Logstash或 Elasticsearch时，Filebeat使用背压敏感协议，以应对更多的数据量。如果Logstash正在忙于处理数据，则会告诉Filebeat 减慢读取速度。一旦拥堵得到解决，Filebeat就会恢复到原来的步伐并继续传输数据。</p>\n</li>\n</ul>\n<h2 id=\"FileBeat下载和安装\">FileBeat下载和安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载地址：<a href=\"https://www.elastic.co/cn/downloads/past-releases#filebeat\">https://www.elastic.co/cn/downloads/past-releases#filebeat</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>选择对应的版本：这里选择当前的最新版<code>FileBeat 8.17.3</code>，之后选择对应的操作系统<code>LINUX X86_64</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.17.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载完成后解压到<code>/usr/local/filebeat</code>目录下，解压命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/filebeat</span><br><span class=\"line\">tar -zxvf filebeat-8.17.3-linux-x86_64.tar.gz -C /usr/local/filebeat</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改logstash安装目录的用户权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> -R elastic:elastic /usr/local/filebeat</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>切换到elastic用户下执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换用户</span></span><br><span class=\"line\">su - elastic</span><br><span class=\"line\"><span class=\"comment\"># 进入 filebeat 安装目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/filebeat/filebeat-8.17.3-linux-x86_64/</span><br></pre></td></tr></table></figure>\n<h2 id=\"经典的ELK架构\">经典的ELK架构</h2>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%9B%BE.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Filebeat日志收集：Filebeat作为轻量级的日志收集代理，部署在客户端上，消耗资源少，能够高效地收集日志数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Logstash数据处理：Logstash作为数据处理管道，负责将Filebeat收集的日志数据进行过滤、转换等操作，然后发送到Elasticsearch进行存储。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch存储与搜索：Elasticsearch是一个基于Lucene的分布式搜索和分析引擎，提供强大的数据存储和搜索能力。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kibana可视化：Kibana为Elasticsearch提供Web可视化界面，允许用户通过图表、仪表盘等方式直观地查看和分析日志数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：经典的ELK架构主要适用于数据量较小的开发环境。然而，由于缺少消息队列的缓冲机制，当Logstash或Elasticsearch出现故障时，可能存在数据丢失的风险。</p>\n</li>\n</ul>\n<h2 id=\"一个经典ELK架构示例\">一个经典ELK架构示例</h2>\n<h3 id=\"FileBeat采集Nginx服务器日志并发送到Logstash\">FileBeat采集Nginx服务器日志并发送到Logstash</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建配置文件<code>filebeat-nginx.yml</code>，将其保存到Filebeat安装目录下的conf目录下。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 因为Nginx的access.log日志都是以IP地址开头的，所以我们需要修改下匹配字段。</span></span><br><span class=\"line\"><span class=\"comment\"># 不以ip地址开头的行追加到上一行</span></span><br><span class=\"line\"><span class=\"attr\">filebeat.inputs:</span> <span class=\"comment\"># 输入源配置</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">log</span> <span class=\"comment\"># 日志类型</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 是否启用</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span> <span class=\"comment\"># 采集路径</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/var/log/nginx/access*.*</span></span><br><span class=\"line\">  <span class=\"attr\">exclude_files:</span> [<span class=\"string\">&quot;.gz$&quot;</span>] <span class=\"comment\"># 排除以.gz 结尾的文件</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.pattern:</span> <span class=\"string\">&#x27;^\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\s&#x27;</span> <span class=\"comment\"># 匹配以IP地址开头，并紧跟一个空白字符</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.negate:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 不以ip地址开头的行追加到上一行</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.match:</span> <span class=\"string\">after</span> <span class=\"comment\"># 追加到上一行的后面</span></span><br><span class=\"line\">  <span class=\"comment\"># multiline: 多行日志配置，这里实际上不需要配置多行设置，因为nginx的access日志都是单行日志，这里只做演示</span></span><br><span class=\"line\">    <span class=\"comment\"># pattern: 正则表达式</span></span><br><span class=\"line\">    <span class=\"comment\"># negate: false，匹配pattern的行合并到上一行；true，不匹配pattern的行合并到上一行</span></span><br><span class=\"line\">    <span class=\"comment\"># match: after，合并到上一行的末尾；before，合并到上一行的开头</span></span><br><span class=\"line\">  <span class=\"attr\">scan_frequency:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每 10 秒扫描一次日志文件</span></span><br><span class=\"line\">  <span class=\"attr\">clean_removed:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 在日志文件被删除后是否从其内部状态中移除该文件的记录</span></span><br><span class=\"line\">  <span class=\"attr\">clean_inactive:</span> <span class=\"string\">2h</span> <span class=\"comment\"># 在日志文件处于非活动状态多长时间后将其从状态数据库中移,设置为比 ignore_older + scan_frequency 更大的值</span></span><br><span class=\"line\">  <span class=\"attr\">ignore_older:</span> <span class=\"string\">1h</span> <span class=\"comment\"># 忽略那些比当前时间早于 1 小时的日志文件</span></span><br><span class=\"line\"><span class=\"attr\">output.logstash:</span> <span class=\"comment\"># 输出配置，这里是发送到Logstash</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 是否启用</span></span><br><span class=\"line\">  <span class=\"attr\">hosts:</span> [<span class=\"string\">&quot;10.250.0.239:5044&quot;</span>] <span class=\"comment\"># Logstash服务地址</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为FileBeat的用户分配日志目录的读取权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 setfacl命令为elastic用户分配日志目录的读取权限</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> setfacl -d -m u:elastic:r-x -R /var/log/nginx/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动FileBeat</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./filebeat -e -c conf/filebeat-nginx.yml</span><br><span class=\"line\"><span class=\"comment\"># 后台启动</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> ./filebeat -e -c conf/filebeat-nginx.yml &amp;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在启动filebeat时可能会遇到如下错误</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exiting: error loading config file: config file (<span class=\"string\">&quot;conf/filebeat-nginx.yml&quot;</span>) can only be writable by the owner but the permissions are <span class=\"string\">&quot;-rw-rw-r--&quot;</span> (to fix the permissions use: <span class=\"string\">&#x27;chmod go-w /usr/local/filebeat/filebeat-8.17.3-linux-x86_64/conf/filebeat-nginx.yml&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-4\">\n<p>因为安全原因不要其他用户写的权限，去掉写的权限就可以了</p>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> go-w conf/filebeat-nginx.yml</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Logstash接收FileBeat收集的数据并打印\">配置Logstash接收FileBeat收集的数据并打印</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建配置文件<code>logstash-nginx.conf</code>，将其保存到Logstash安装目录下的config目录下。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入logstash安装目录</span></span><br><span class=\"line\"><span class=\"comment\"># vim config/logstash-nginx.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 配置从FileBeat接收数据</span></span><br><span class=\"line\">input &#123; <span class=\"comment\"># 输入源配置</span></span><br><span class=\"line\">    beats &#123; <span class=\"comment\"># 从FileBeat接收数据</span></span><br><span class=\"line\">      port =&gt; 5044 <span class=\"comment\"># 监听5044端口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123; <span class=\"comment\"># 输出配置</span></span><br><span class=\"line\">    stdout &#123; <span class=\"comment\"># 打印到控制台</span></span><br><span class=\"line\">      codec =&gt; rubydebug <span class=\"comment\"># 指定编码器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试logstash配置是否正确</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/logstash -f config/logstash-nginx.conf --config.test_and_exit</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动logstash</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># reload.automatic：修改配置文件时自动重新加载</span></span><br><span class=\"line\">bin/logstash -f config/logstash-nginx.conf --config.reload.automatic</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时在控制台会看到如下输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">         <span class=\"string\">&quot;input&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span> =&gt; <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;@version&quot;</span> =&gt; <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">       <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;1.119.161.30 - elastic [27/Mar/2025:08:52:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot;</span>,</span><br><span class=\"line\">           <span class=\"string\">&quot;log&quot;</span> =&gt; &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;file&quot;</span> =&gt; &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;path&quot;</span> =&gt; <span class=\"string\">&quot;/var/log/nginx/access.log&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;offset&quot;</span> =&gt; 42985</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;tags&quot;</span> =&gt; [</span><br><span class=\"line\">        [0] <span class=\"string\">&quot;beats_input_codec_plain_applied&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;@timestamp&quot;</span> =&gt; 2025-03-27T08:52:42.947Z,</span><br><span class=\"line\">           <span class=\"string\">&quot;ecs&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;version&quot;</span> =&gt; <span class=\"string\">&quot;8.0.0&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">         <span class=\"string\">&quot;agent&quot;</span> =&gt; &#123;</span><br><span class=\"line\">                  <span class=\"string\">&quot;id&quot;</span> =&gt; <span class=\"string\">&quot;4dbe185b-900d-4990-b841-c13bf9618fc6&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;name&quot;</span> =&gt; <span class=\"string\">&quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ephemeral_id&quot;</span> =&gt; <span class=\"string\">&quot;6bb04808-7da7-4acb-95fd-f3f915651457&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;type&quot;</span> =&gt; <span class=\"string\">&quot;filebeat&quot;</span>,</span><br><span class=\"line\">             <span class=\"string\">&quot;version&quot;</span> =&gt; <span class=\"string\">&quot;8.17.3&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">         <span class=\"string\">&quot;event&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;original&quot;</span> =&gt; <span class=\"string\">&quot;1.119.161.30 - elastic [27/Mar/2025:08:52:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;host&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;name&quot;</span> =&gt; <span class=\"string\">&quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"利用Logstash过滤器解析日志\">利用Logstash过滤器解析日志</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从打印结果看到包含了大量的无关数据，此时可以利用Logstash过滤器解析日志，这里使用<code>Grok</code>插件</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/logstash/8.17/plugins-filters-grok.html\">Grok</a>是一种将非结构化日志解析为结构化的插件。这个工具非常适合用来解析系统日志、Web服务器日志、MySQL或者是任意其他的日志格式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Grok是通过模式匹配的方式来识别日志中的数据,可以把Grok插件简单理解为升级版本的正则表达式。它拥有更多的模式，默认Logstash拥有120个模式。如果这些模式不满足我们解析日志的需求，我们可以直接使用正则表达式来进行匹配。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://help.aliyun.com/zh/sls/user-guide/grok-patterns\">GROK模式参考</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>grok模式的语法是:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%&#123;SYNTAX:SEMANTIC&#125;</span><br><span class=\"line\"><span class=\"comment\"># SYNTAX（语法）指的是Grok模式名称，SEMANTIC（语义）是给模式匹配到的文本字段名。例如：</span></span><br><span class=\"line\">%&#123;NUMBER:duration&#125; %&#123;IP:client&#125;</span><br><span class=\"line\"><span class=\"comment\"># duration表示：匹配一个数字，client表示匹配一个IP地址。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配nginx日志</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nginx access日志格式</span></span><br><span class=\"line\">1.119.161.30 - elastic [27/Mar/2025:03:05:36 +0000] <span class=\"string\">&quot;GET /_cluster/stats HTTP/1.1&quot;</span> 200 7446 <span class=\"string\">&quot;-&quot;</span> <span class=\"string\">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&quot;</span> <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># grok</span></span><br><span class=\"line\">%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;</span><br><span class=\"line\"><span class=\"comment\"># 解释每个部分的作用：</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;IP:client_ip&#125;：匹配客户端 IP 地址。</span></span><br><span class=\"line\"><span class=\"comment\"># -：匹配一个破折号（-），表示匿名用户或未认证用户。</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;USER:remote_user&#125;：匹配远程用户名， - 表示匿名用户。</span></span><br><span class=\"line\"><span class=\"comment\"># \\[%&#123;HTTPDATE:timestamp&#125;\\]：匹配请求的时间戳，格式为 [27/Mar/2025:03:05:36 +0000]。</span></span><br><span class=\"line\"><span class=\"comment\"># \\&quot;%&#123;WORD:verb&#125; : 匹配请求方法 (GET)</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;URIPATHPARAM:request&#125; : 匹配请求路径 (/_cluster/stats)</span></span><br><span class=\"line\"><span class=\"comment\"># HTTP/%&#123;NUMBER:httpversion&#125;\\\\\\&quot;：匹配 HTTP 版本 (HTTP/1.1)。</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;INT:http_status&#125;：匹配 HTTP 响应状态码 (200)。</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;INT:body_bytes_sent&#125;：匹配响应体的字节数 (7446)。</span></span><br><span class=\"line\"><span class=\"comment\"># \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot;：匹配引用页 (Referer) 字段，这里为空 (&quot;-&quot;)。</span></span><br><span class=\"line\"><span class=\"comment\"># \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot;：匹配用户代理 (User-Agent) 字段。GREEDYDATA 会匹配尽可能多的数据，直到遇到下一个分隔符。</span></span><br><span class=\"line\"><span class=\"comment\"># %&#123;QUOTEDSTRING:x_forwarded_for&#125;：匹配 X-Forwarded-For 头字段，这里为空 (&quot;-&quot;)。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 匹配结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;request&quot;</span>: <span class=\"string\">&quot;/_cluster/stats&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;agent&quot;</span>: <span class=\"string\">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;body_bytes_sent&quot;</span>: <span class=\"string\">&quot;7446&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;verb&quot;</span>: <span class=\"string\">&quot;GET&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;x_forwarded_for&quot;</span>: <span class=\"string\">&quot;\\&quot;-\\&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;remote_user&quot;</span>: <span class=\"string\">&quot;elastic&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;referrer&quot;</span>: <span class=\"string\">&quot;-&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;client_ip&quot;</span>: <span class=\"string\">&quot;1.119.161.30&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;httpversion&quot;</span>: <span class=\"string\">&quot;1.1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;http_status&quot;</span>: <span class=\"string\">&quot;200&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;timestamp&quot;</span>: <span class=\"string\">&quot;27/Mar/2025:03:05:36 +0000&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配Grok模式是个非常繁琐的过程，我们可以使用Kibana来进行可视化的Grok调试<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nhgnKY.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>grok配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grok &#123;</span><br><span class=\"line\">    match =&gt; &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用mutate插件过滤掉不需要的字段\">使用mutate插件过滤掉不需要的字段</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>除了nginx日志本身的格式外，logstash还会打印许多我们不需要的字段，此时可以使用<code>mutate</code>插件来过滤掉不需要的字段。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutate &#123;</span><br><span class=\"line\">    enable_metric =&gt; <span class=\"string\">&quot;false&quot;</span> <span class=\"comment\"># 禁用指标上报</span></span><br><span class=\"line\">    remove_field =&gt; [<span class=\"string\">&quot;message&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;tags&quot;</span>, <span class=\"string\">&quot;input&quot;</span>, <span class=\"string\">&quot;agent&quot;</span>, <span class=\"string\">&quot;host&quot;</span>, <span class=\"string\">&quot;ecs&quot;</span>, <span class=\"string\">&quot;@version&quot;</span>] <span class=\"comment\"># 移除不需要的字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Date插件对时间进行格式转换\">使用Date插件对时间进行格式转换</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">date</span> &#123;</span><br><span class=\"line\">    match =&gt; [<span class=\"string\">&quot;timestamp&quot;</span>,<span class=\"string\">&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;</span>,<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>] <span class=\"comment\"># 时间格式转换</span></span><br><span class=\"line\">    target =&gt; <span class=\"string\">&quot;timestamp&quot;</span> <span class=\"comment\"># 目标字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"完整的Logstash配置\">完整的Logstash配置</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入logstash安装目录</span></span><br><span class=\"line\"><span class=\"comment\"># vim config/logstsh-nginx.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 配置从FileBeat接收数据</span></span><br><span class=\"line\">input &#123; <span class=\"comment\"># 输入源配置</span></span><br><span class=\"line\">    beats &#123; <span class=\"comment\"># 从FileBeat接收数据</span></span><br><span class=\"line\">      port =&gt; 5044 <span class=\"comment\"># 监听5044端口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">filter &#123; <span class=\"comment\"># 过滤器配置</span></span><br><span class=\"line\">    grok &#123;</span><br><span class=\"line\">        match =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutate &#123;</span><br><span class=\"line\">        enable_metric =&gt; <span class=\"string\">&quot;false&quot;</span> <span class=\"comment\"># 禁用指标上报</span></span><br><span class=\"line\">        remove_field =&gt; [<span class=\"string\">&quot;message&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;tags&quot;</span>, <span class=\"string\">&quot;input&quot;</span>, <span class=\"string\">&quot;agent&quot;</span>, <span class=\"string\">&quot;host&quot;</span>, <span class=\"string\">&quot;ecs&quot;</span>, <span class=\"string\">&quot;@version&quot;</span>] <span class=\"comment\"># 移除不需要的字段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">date</span> &#123;</span><br><span class=\"line\">        match =&gt; [<span class=\"string\">&quot;timestamp&quot;</span>,<span class=\"string\">&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;</span>,<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>] <span class=\"comment\"># 时间格式转换</span></span><br><span class=\"line\">        target =&gt; <span class=\"string\">&quot;timestamp&quot;</span> <span class=\"comment\"># 目标字段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123; <span class=\"comment\"># 输出配置</span></span><br><span class=\"line\">    stdout &#123; <span class=\"comment\"># 打印到控制台</span></span><br><span class=\"line\">      codec =&gt; rubydebug <span class=\"comment\"># 指定编码器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重新启动logstash后得到如下结果：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;event&quot;</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;original&quot;</span> =&gt; <span class=\"string\">&quot;1.119.161.30 - elastic [27/Mar/2025:09:49:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;client_ip&quot;</span> =&gt; <span class=\"string\">&quot;1.119.161.30&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;request&quot;</span> =&gt; <span class=\"string\">&quot;/_cluster/stats&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;http_status&quot;</span> =&gt; <span class=\"string\">&quot;200&quot;</span>,</span><br><span class=\"line\">         <span class=\"string\">&quot;@timestamp&quot;</span> =&gt; 2025-03-27T09:49:45.751Z,</span><br><span class=\"line\">    <span class=\"string\">&quot;body_bytes_sent&quot;</span> =&gt; <span class=\"string\">&quot;7445&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;x_forwarded_for&quot;</span> =&gt; <span class=\"string\">&quot;\\&quot;-\\&quot;&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;timestamp&quot;</span> =&gt; 2025-03-27T09:49:41.000Z,</span><br><span class=\"line\">           <span class=\"string\">&quot;referrer&quot;</span> =&gt; <span class=\"string\">&quot;-&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;remote_user&quot;</span> =&gt; <span class=\"string\">&quot;elastic&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;httpversion&quot;</span> =&gt; <span class=\"string\">&quot;1.1&quot;</span>,</span><br><span class=\"line\">               <span class=\"string\">&quot;verb&quot;</span> =&gt; <span class=\"string\">&quot;GET&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"将结果输出到ES\">将结果输出到ES</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在输出配置中添加ES输出配置</span></span><br><span class=\"line\">output &#123; <span class=\"comment\"># 输出配置</span></span><br><span class=\"line\">    stdout &#123; <span class=\"comment\"># 打印到控制台</span></span><br><span class=\"line\">      codec =&gt; rubydebug <span class=\"comment\"># 指定编码器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    elasticsearch &#123; <span class=\"comment\"># 输出到ES</span></span><br><span class=\"line\">        index =&gt; <span class=\"string\">&quot;nginx_access_log_%&#123;+YYYY-MM&#125;&quot;</span> <span class=\"comment\"># 索引名,按月分隔</span></span><br><span class=\"line\">        hosts =&gt; [<span class=\"string\">&quot;https://10.250.0.239:9200&quot;</span>] <span class=\"comment\"># ES地址</span></span><br><span class=\"line\">        user =&gt; <span class=\"string\">&quot;elastic&quot;</span>                   <span class=\"comment\"># ES用户名</span></span><br><span class=\"line\">        password =&gt; <span class=\"string\">&quot;123456&quot;</span>                <span class=\"comment\"># ES密码</span></span><br><span class=\"line\">        ssl =&gt; <span class=\"literal\">true</span>                         <span class=\"comment\"># 是否启用SSL，因为这里是https访问ES</span></span><br><span class=\"line\">        ssl_certificate_verification =&gt; <span class=\"literal\">false</span> <span class=\"comment\"># 禁用证书验证</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果需要开启证书校验，可以通过如下方法进行配置</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">获取 Elasticsearch 的 SSL 证书：</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从 Elasticsearch 的配置文件或证书文件路径中获取证书（通常是 .pem 或 .crt 文件）。</span></span><br><span class=\"line\">/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">导入证书到 Java 信任库：注意这里要导入到启动Logstash的JAVA进程的信任库</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># logstash的jdk路径，默认在logstash的安装目录下</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/logstash/logstash-8.17.3/jdk</span><br><span class=\"line\"></span><br><span class=\"line\">bin/keytool -importcert -<span class=\"built_in\">alias</span> es-cert -keystore /usr/local/logstash/logstash-8.17.3/logstash.keystore -file /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Enter keystore password:  <span class=\"comment\"># 输入密码 这里是123456</span></span><br><span class=\"line\">Re-enter new password:</span><br><span class=\"line\">Owner: CN=Elasticsearch security auto-configuration HTTP CA</span><br><span class=\"line\">Issuer: CN=Elasticsearch security auto-configuration HTTP CA</span><br><span class=\"line\">Serial number: 89d5c501a2efd5d45a6ee5e08daa16bd605d8c28</span><br><span class=\"line\">Valid from: Thu Mar 20 08:53:26 UTC 2025 <span class=\"keyword\">until</span>: Sun Mar 19 08:53:26 UTC 2028</span><br><span class=\"line\">Certificate fingerprints:</span><br><span class=\"line\">    SHA1: DE:73:0C:EC:46:59:69:83:52:7C:C4:CC:6B:65:EC:B6:31:BE:10:22</span><br><span class=\"line\">    SHA256: 3F:14:1C:16:DF:C6:E1:65:89:4B:C1:67:20:84:B2:20:DC:DD:22:FF:E0:21:16:D5:1A:C1:80:03:CF:AA:5A:1D</span><br><span class=\"line\">Signature algorithm name: SHA256withRSA</span><br><span class=\"line\">Subject Public Key Algorithm: 4096-bit RSA key</span><br><span class=\"line\">Version: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Extensions:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#1: ObjectId: 2.5.29.35 Criticality=false</span></span><br><span class=\"line\">AuthorityKeyIdentifier [</span><br><span class=\"line\">KeyIdentifier [</span><br><span class=\"line\">0000: 25 EF BA 81 AE 5E 14 1C   7E FF A1 87 12 F8 D0 2E  %....^..........</span><br><span class=\"line\">0010: 3A D7 54 5F                                        :.T_</span><br><span class=\"line\">]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2: ObjectId: 2.5.29.19 Criticality=true</span></span><br><span class=\"line\">BasicConstraints:[</span><br><span class=\"line\">CA:<span class=\"literal\">true</span></span><br><span class=\"line\">PathLen: no <span class=\"built_in\">limit</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3: ObjectId: 2.5.29.14 Criticality=false</span></span><br><span class=\"line\">SubjectKeyIdentifier [</span><br><span class=\"line\">KeyIdentifier [</span><br><span class=\"line\">0000: 25 EF BA 81 AE 5E 14 1C   7E FF A1 87 12 F8 D0 2E  %....^..........</span><br><span class=\"line\">0010: 3A D7 54 5F                                        :.T_</span><br><span class=\"line\">]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Trust this certificate? [no]:  <span class=\"built_in\">yes</span> <span class=\"comment\"># yes确认</span></span><br><span class=\"line\">Certificate was added to keystore</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>配置 Logstash 使用信任库</p>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output &#123;</span><br><span class=\"line\">    elasticsearch &#123;</span><br><span class=\"line\">        index =&gt; <span class=\"string\">&quot;nginx_access_log_%&#123;+YYYY-MM&#125;&quot;</span> <span class=\"comment\"># 索引名,按月分隔</span></span><br><span class=\"line\">        hosts =&gt; [<span class=\"string\">&quot;https://10.250.0.239:9200&quot;</span>] <span class=\"comment\"># ES地址</span></span><br><span class=\"line\">        user =&gt; <span class=\"string\">&quot;elastic&quot;</span>                     <span class=\"comment\"># ES用户名</span></span><br><span class=\"line\">        password =&gt; <span class=\"string\">&quot;123456&quot;</span>                  <span class=\"comment\"># ES密码</span></span><br><span class=\"line\">        ssl =&gt; <span class=\"literal\">true</span>                           <span class=\"comment\"># 是否启用SSL，因为这里是https访问ES</span></span><br><span class=\"line\">        ssl_certificate_verification =&gt; <span class=\"literal\">true</span>  <span class=\"comment\"># 启用证书校验</span></span><br><span class=\"line\">        ssl_truststore_path =&gt; <span class=\"string\">&quot;/usr/local/logstash/logstash-8.17.3/logstash.keystore&quot;</span> <span class=\"comment\"># 指定信任库路径</span></span><br><span class=\"line\">        ssl_truststore_password =&gt; <span class=\"string\">&quot;123456&quot;</span>   <span class=\"comment\"># 信任库密码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"整合消息队列-Nginx的ELK架构\">整合消息队列+Nginx的ELK架构</h2>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%9B%BE-2.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消息队列：引入消息队列作为缓冲机制，确保即使在Logstash或Elasticsearch出现故障时，日志数据也不会丢失。消息队列能够均衡网络传输，降低数据丢失的可能性。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nginx：Nginx作为高性能的Web和反向代理服务器，可以进一步优化整个系统的性能和可用性。它可以在负载均衡、缓存等方面发挥作用，提升用户访问体验。</p>\n</li>\n<li class=\"lvl-2\">\n<p>扩展性：由于引入了消息队列和Nginx等组件，整个架构的扩展性得到增强。可以根据实际需求动态调整各组件的资源分配和部署规模。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：整合消息队列+Nginx的架构主要适用于生产环境，特别是需要处理大数据量的场景。它能够确保数据的安全性和完整性，同时提供高性能的日志处理和可视化分析服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>总结来说就是</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">filebeat将采集的日志发送到Redis\\RabbitMQ\\Kafka等</li>\n<li class=\"lvl-4\">Logstash再从Redis\\RabbitMQ\\Kafka中读取日志数据，并进行解析后发送到ES中。</li>\n<li class=\"lvl-4\">ES集群使用nginx进行负载均衡，以实现高可用和高性能。具体实现方法查看：<a href=\"/2025/03/24/elasticsearch-02-install-cluster/\" title=\"linux下安装Elasticsearch集群\">linux下安装Elasticsearch集群</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基于Redis的ELK架构示例\">基于Redis的ELK架构示例</h2>\n<h3 id=\"filebeat将采集的日志发送到Redis\">filebeat将采集的日志发送到Redis</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建配置文件<code>filebeat-nginx-to-redis.yml</code>，将其保存到Filebeat安装目录下的conf目录下。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 因为Nginx的access.log日志都是以IP地址开头的，所以我们需要修改下匹配字段。</span></span><br><span class=\"line\"><span class=\"comment\"># 不以ip地址开头的行追加到上一行</span></span><br><span class=\"line\"><span class=\"attr\">filebeat.inputs:</span> <span class=\"comment\"># 输入源配置</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">log</span> <span class=\"comment\"># 日志类型</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 是否启用</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span> <span class=\"comment\"># 采集路径</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/var/log/nginx/access*.*</span></span><br><span class=\"line\">  <span class=\"attr\">exclude_files:</span> [<span class=\"string\">&quot;.gz$&quot;</span>] <span class=\"comment\"># 排除以.gz 结尾的文件</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.pattern:</span> <span class=\"string\">&#x27;^\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\s&#x27;</span> <span class=\"comment\"># 匹配以IP地址开头，并紧跟一个空白字符</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.negate:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 不以ip地址开头的行追加到上一行</span></span><br><span class=\"line\">  <span class=\"attr\">multiline.match:</span> <span class=\"string\">after</span> <span class=\"comment\"># 追加到上一行的后面</span></span><br><span class=\"line\">  <span class=\"comment\"># multiline: 多行日志配置，这里实际上不需要配置多行设置，因为nginx的access日志都是单行日志，这里只做演示</span></span><br><span class=\"line\">    <span class=\"comment\"># pattern: 正则表达式</span></span><br><span class=\"line\">    <span class=\"comment\"># negate: false，匹配pattern的行合并到上一行；true，不匹配pattern的行合并到上一行</span></span><br><span class=\"line\">    <span class=\"comment\"># match: after，合并到上一行的末尾；before，合并到上一行的开头</span></span><br><span class=\"line\">  <span class=\"attr\">scan_frequency:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每 10 秒扫描一次日志文件</span></span><br><span class=\"line\">  <span class=\"attr\">clean_removed:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 在日志文件被删除后是否从其内部状态中移除该文件的记录</span></span><br><span class=\"line\">  <span class=\"attr\">clean_inactive:</span> <span class=\"string\">2h</span> <span class=\"comment\"># 在日志文件处于非活动状态多长时间后将其从状态数据库中移,设置为比 ignore_older + scan_frequency 更大的值</span></span><br><span class=\"line\">  <span class=\"attr\">ignore_older:</span> <span class=\"string\">1h</span> <span class=\"comment\"># 忽略那些比当前时间早于 1 小时的日志文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">output.redis:</span> <span class=\"comment\"># Redis输出配置</span></span><br><span class=\"line\">  <span class=\"attr\">hosts:</span> [<span class=\"string\">&quot;10.250.0.214:6379&quot;</span>] <span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\">  <span class=\"attr\">password:</span> <span class=\"string\">&quot;123456&quot;</span> <span class=\"comment\"># Redis密码</span></span><br><span class=\"line\">  <span class=\"attr\">key:</span> <span class=\"string\">&quot;filebeat_nginx&quot;</span> <span class=\"comment\"># Redis的key，类型为 list</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"number\">3</span> <span class=\"comment\"># Redis数据库</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"number\">3</span> <span class=\"comment\"># Redis连接超时时间，单位秒</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动Filebeat，并查看日志输出。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./filebeat -e -c conf/filebeat-nginx-to-redis.yml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看Redis中的数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli -h 10.250.0.214 -p 6379 -a 123456</span><br><span class=\"line\">10.250.0.214:6379&gt; <span class=\"keyword\">select</span> 3</span><br><span class=\"line\">OK</span><br><span class=\"line\">10.250.0.214:6379[3]&gt; keys filebeat*</span><br><span class=\"line\">1) <span class=\"string\">&quot;filebeat_nginx&quot;</span></span><br><span class=\"line\">10.250.0.214:6379[3]&gt; <span class=\"built_in\">type</span> filebeat_nginx</span><br><span class=\"line\">list</span><br><span class=\"line\">10.250.0.214:6379[3]&gt; LLEN filebeat_nginx</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 14</span><br><span class=\"line\">10.250.0.214:6379[3]&gt; LINDEX filebeat_nginx 1</span><br><span class=\"line\"><span class=\"string\">&quot;&#123;\\&quot;@timestamp\\&quot;:\\&quot;2025-03-28T09:15:23.402Z\\&quot;,\\&quot;@metadata\\&quot;:&#123;\\&quot;beat\\&quot;:\\&quot;filebeat\\&quot;,\\&quot;type\\&quot;:\\&quot;_doc\\&quot;,\\&quot;version\\&quot;:\\&quot;8.17.3\\&quot;&#125;,\\&quot;host\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;ip-10-250-0-239.cn-northwest-1.compute.internal\\&quot;&#125;,\\&quot;agent\\&quot;:&#123;\\&quot;version\\&quot;:\\&quot;8.17.3\\&quot;,\\&quot;ephemeral_id\\&quot;:\\&quot;c0a521fe-690b-46b1-aadc-bbe16ef1db9a\\&quot;,\\&quot;id\\&quot;:\\&quot;4dbe185b-900d-4990-b841-c13bf9618fc6\\&quot;,\\&quot;name\\&quot;:\\&quot;ip-10-250-0-239.cn-northwest-1.compute.internal\\&quot;,\\&quot;type\\&quot;:\\&quot;filebeat\\&quot;&#125;,\\&quot;log\\&quot;:&#123;\\&quot;offset\\&quot;:46745,\\&quot;file\\&quot;:&#123;\\&quot;path\\&quot;:\\&quot;/var/log/nginx/access.log\\&quot;&#125;&#125;,\\&quot;message\\&quot;:\\&quot;1.119.161.30 - elastic [28/Mar/2025:09:15:13 +0000] \\\\\\&quot;GET /_cluster/stats HTTP/1.1\\\\\\&quot; 200 7457 \\\\\\&quot;-\\\\\\&quot; \\\\\\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\\\\\&quot; \\\\\\&quot;-\\\\\\&quot;\\&quot;,\\&quot;input\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;log\\&quot;&#125;,\\&quot;ecs\\&quot;:&#123;\\&quot;version\\&quot;:\\&quot;8.0.0\\&quot;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Logstash从Redis中读取日志并写入Elasticsearch\">Logstash从Redis中读取日志并写入Elasticsearch</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建配置文件<code>logstash-nginx-redis-to-es.conf</code>，将其保存到Logstash安装目录下的conf目录下。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入logstash安装目录</span></span><br><span class=\"line\"><span class=\"comment\"># vim logstash-nginx-redis-to-es.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 配置从 redis 接收数据</span></span><br><span class=\"line\">input &#123; <span class=\"comment\"># 输入源配置</span></span><br><span class=\"line\">    redis &#123; <span class=\"comment\"># Redis输入配置</span></span><br><span class=\"line\">        host =&gt; <span class=\"string\">&#x27;10.250.0.214&#x27;</span> <span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\">        port =&gt; <span class=\"string\">&quot;6379&quot;</span> <span class=\"comment\"># Redis服务器端口</span></span><br><span class=\"line\">        password =&gt; <span class=\"string\">&quot;123456&quot;</span> <span class=\"comment\"># Redis密码</span></span><br><span class=\"line\">        db =&gt; <span class=\"string\">&quot;3&quot;</span>           <span class=\"comment\"># Redis数据库</span></span><br><span class=\"line\">        data_type =&gt; <span class=\"string\">&#x27;list&#x27;</span> <span class=\"comment\"># 数据类型为list</span></span><br><span class=\"line\">        key =&gt; <span class=\"string\">&quot;filebeat_nginx&quot;</span>   <span class=\"comment\"># Redis的key</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">filter &#123; <span class=\"comment\"># 过滤器配置</span></span><br><span class=\"line\">    grok &#123;</span><br><span class=\"line\">        match =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;message&quot;</span> =&gt; <span class=\"string\">&quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutate &#123;</span><br><span class=\"line\">        enable_metric =&gt; <span class=\"string\">&quot;false&quot;</span> <span class=\"comment\"># 禁用指标上报</span></span><br><span class=\"line\">        remove_field =&gt; [<span class=\"string\">&quot;message&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;tags&quot;</span>, <span class=\"string\">&quot;input&quot;</span>, <span class=\"string\">&quot;agent&quot;</span>, <span class=\"string\">&quot;host&quot;</span>, <span class=\"string\">&quot;ecs&quot;</span>, <span class=\"string\">&quot;@version&quot;</span>] <span class=\"comment\"># 移除不需要的字段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">date</span> &#123;</span><br><span class=\"line\">        match =&gt; [<span class=\"string\">&quot;timestamp&quot;</span>,<span class=\"string\">&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;</span>,<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>] <span class=\"comment\"># 时间格式转换</span></span><br><span class=\"line\">        target =&gt; <span class=\"string\">&quot;timestamp&quot;</span> <span class=\"comment\"># 目标字段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在输出配置中添加ES输出配置</span></span><br><span class=\"line\">output &#123; <span class=\"comment\"># 输出配置</span></span><br><span class=\"line\">    stdout &#123; <span class=\"comment\"># 打印到控制台</span></span><br><span class=\"line\">      codec =&gt; rubydebug <span class=\"comment\"># 指定编码器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    elasticsearch &#123; <span class=\"comment\"># 输出到ES</span></span><br><span class=\"line\">        index =&gt; <span class=\"string\">&quot;redis_nginx_access_log_%&#123;+YYYY-MM&#125;&quot;</span> <span class=\"comment\"># 索引名,按月分隔</span></span><br><span class=\"line\">        hosts =&gt; [<span class=\"string\">&quot;https://10.250.0.239:9200&quot;</span>] <span class=\"comment\"># ES地址</span></span><br><span class=\"line\">        user =&gt; <span class=\"string\">&quot;elastic&quot;</span>                   <span class=\"comment\"># ES用户名</span></span><br><span class=\"line\">        password =&gt; <span class=\"string\">&quot;123456&quot;</span>                <span class=\"comment\"># ES密码</span></span><br><span class=\"line\">        ssl =&gt; <span class=\"literal\">true</span>                         <span class=\"comment\"># 是否启用SSL，因为这里是https访问ES</span></span><br><span class=\"line\">        ssl_certificate_verification =&gt; <span class=\"literal\">false</span> <span class=\"comment\"># 禁用证书验证</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试logstash配置是否正确</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/logstash -f config/logstash-nginx-redis-to-es.conf --config.test_and_exit</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动logstash</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># reload.automatic：修改配置文件时自动重新加载</span></span><br><span class=\"line\">bin/logstash -f config/logstash-nginx-redis-to-es.conf --config.reload.automatic</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍如何在linux下安装LogStash和FileBeat 通过示例讲解ELK的经典架构和高并发架构的实现过程 LogStash版本8.17.3，FileBeat版本8.17.3 Elasticsearch版本8.17.3，linux下安装Elasticsearch Kibana版本8.17.3，linux下安装Kibana Elasticsearch集群搭建，linux下安装Elasticsearch集群 Logstash概述 Logstash 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的存储库中。 Logstash数据传输原理 1231.数据采集与输入：Logstash支持各种输入选择，能够以连续的流式传输方式，轻松地从日志、指标、Web应用以及数据存储中采集数据。2.实时解析和数据转换：通过Logstash过滤器解析各个事件，识别已命名的字段来构建结构，并将它们转换成通用格式，最终将数据从源端传输到存储库中。3.存储与数据导出：Logstash提供多种输出选择，可以将数据发送到指定的地方。 Logstash通过管道完成数据的采集与处理，管道配置中包含input、output和filter（可选）插件，input和output用来配置输入和输出数据源、filter用来对数据进行过滤或预处理。 Logstash下载安装 下载地址：https://www.elastic.co/cn/downloads/past-releases#logstash 选择对应的版本：这里选择当前的最新版LogStash 8.17.3，之后选择对应的操作系统LINUX X86_64 1wget https://artifacts.elastic.co/downloads/logstash/logstash-8.17.3-linux-x86_64.tar.gz 下载完成后解压到/usr/local/logstash目录下，解压命令如下： 12mkdir /usr/local/logstashtar -zxvf logstash-8.17.3-linux-x86_64.tar.gz -C /usr/local/logstash elasticsearch和kibana都不能用root用户启动，为了统一管理，logstash也使用这个用户（非必要） 创建用户elastic，并设置密码，这一步我们在安装elasticsearch的时候已经配置过了，这里就不再赘述了 12useradd elasticpasswd elastic 修改logstash安装目录的用户权限 1chown -R elastic:elastic /usr/local/logstash 切换到elastic用户下执行命令 1234# 切换用户su - elastic# 进入logstash安装目录cd /usr/local/logstash/logstash-8.17.3/ 运行一个简单的测试 123456789101112131415161718192021# -e: 直接把配置放在命令中，这样可以有效快速进行测试# input &#123; stdin &#123; &#125; &#125;: 输入插件，从标准输入中读取数据# output &#123; stdout &#123;&#125; &#125;: 输出插件，将数据输出到标准输出# 这里只包含了 input 和 output 两个部分，实际使用中还需要添加 filter 部分./bin/logstash -e &#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;# 输出：。。。。。。。 # 输出启动信息The stdin plugin is now waiting for input: # 输出提示信息，提示你输入内容hello world # 我输入内容# logstash输出内容&#123; &quot;message&quot; =&gt; &quot;hello world&quot;, &quot;@version&quot; =&gt; &quot;1&quot;, &quot;event&quot; =&gt; &#123; &quot;original&quot; =&gt; &quot;hello world&quot; &#125;, &quot;host&quot; =&gt; &#123; &quot;hostname&quot; =&gt; &quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot; &#125;, &quot;@timestamp&quot; =&gt; 2025-03-27T06:48:12.810617855Z&#125; 也可以通过配置文件启动logstash 1234567891011121314# vim test.confinput &#123; stdin &#123; &#125;&#125;output &#123; stdout &#123; codec =&gt; rubydebug &#125;&#125;# codec =&gt; rubydebug : 是指定了一个编码器（Codec）为 rubydebug。# 编码器负责如何格式化输出的数据。# Rubydebug 编码器是一种特别适合开发和调试目的的编码器，因为它能以相当易读的形式展示复杂的结构化数据，比如嵌套的哈希表或者数组。# 除了 Rubydebug 编码器，Logstash 还提供了其他几种编码器，比如 json、plain、multiline 等等。# 具体可以参考官方文档：https://www.elastic.co/guide/en/logstash/current/codec-plugins.html 1./bin/logstash -f ./test.conf Logstash插件 Input Plugins https://www.elastic.co/guide/en/logstash/8.17/input-plugins.html 一个 Pipeline可以有多个input插件 12345- Stdin / File- Beats / Log4J /Elasticsearch / JDBC / Kafka /Rabbitmq /Redis- JMX/ HTTP / Websocket / UDP / TCP- Google Cloud Storage / S3- Github / Twitter Filter Plugins https://www.elastic.co/guide/en/logstash/8.17/filter-plugins.html Filter Plugin可以对Logstash Event进行各种处理，例如解析，删除字段，类型转换 1234567891011- Date: 日期解析- Dissect: 分割符解析- Grok: 正则匹配解析- Mutate: 对字段做各种操作- Convert : 类型转换- Gsub : 字符串替换- Split / Join /Merge: 字符串切割，数组合并字符串，数组合并数组- Rename: 字段重命名- Update / Replace: 字段内容更新替换- Remove_field: 字段删除- Ruby: 利用Ruby 代码来动态修改Event Output Plugins https://www.elastic.co/guide/en/logstash/8.17/output-plugins.html 将Event发送到特定的目的地，是 Pipeline 的最后一个阶段。常见 Output Plugins： 1234- Elasticsearch- Email / Pageduty- Influxdb / Kafka / Mongodb / Opentsdb / Zabbix- Http / TCP / Websocket Codec Plugins https://www.elastic.co/guide/en/logstash/8.17/codec-plugins.html 将原始数据decode成Event;将Event encode成目标数据，内置的Codec Plugins: 123- Line / Multiline- JSON / Avro / Cef (ArcSight Common Event Format)- Dots / Rubydebug FileBeat概述 Beats 是一个免费且开放的平台，集合了多种单一用途的数据采集器。它们从成百上千或成千上万台机器和系统向 Logstash 或 Elasticsearch 发送数据。 FileBeat 专门用于转发和收集日志数据的轻量级采集工具。它可以作为代理安装在服务器上，FileBeat监视指定路径的日志文件，收集日志数据，并将收集到的日志转发到Elasticsearch或者Logstash。 logstash vs FileBeat Logstash是在jvm上运行的，资源消耗比较大。而FileBeat是基于golang编写的，功能较少但资源消耗也比较小，更轻量级。 Logstash 和Filebeat都具有日志收集功能，Filebeat更轻量，占用资源更少 Logstash 具有Filter功能，能过滤分析日志 一般结构都是Filebeat采集日志，然后发送到消息队列、Redis、MQ中，然后Logstash去获取，利用Filter功能过滤分析，然后存储到Elasticsearch中 FileBeat和Logstash配合，实现背压机制。当将数据发送到Logstash或 Elasticsearch时，Filebeat使用背压敏感协议，以应对更多的数据量。如果Logstash正在忙于处理数据，则会告诉Filebeat 减慢读取速度。一旦拥堵得到解决，Filebeat就会恢复到原来的步伐并继续传输数据。 FileBeat下载和安装 下载地址：https://www.elastic.co/cn/downloads/past-releases#filebeat 选择对应的版本：这里选择当前的最新版FileBeat 8.17.3，之后选择对应的操作系统LINUX X86_64 1wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.17.3-linux-x86_64.tar.gz 下载完成后解压到/usr/local/filebeat目录下，解压命令如下： 12mkdir /usr/local/filebeattar -zxvf filebeat-8.17.3-linux-x86_64.tar.gz -C /usr/local/filebeat 修改logstash安装目录的用户权限 1chown -R elastic:elastic /usr/local/filebeat 切换到elastic用户下执行命令 1234# 切换用户su - elastic# 进入 filebeat 安装目录cd /usr/local/filebeat/filebeat-8.17.3-linux-x86_64/ 经典的ELK架构 Filebeat日志收集：Filebeat作为轻量级的日志收集代理，部署在客户端上，消耗资源少，能够高效地收集日志数据。 Logstash数据处理：Logstash作为数据处理管道，负责将Filebeat收集的日志数据进行过滤、转换等操作，然后发送到Elasticsearch进行存储。 Elasticsearch存储与搜索：Elasticsearch是一个基于Lucene的分布式搜索和分析引擎，提供强大的数据存储和搜索能力。 Kibana可视化：Kibana为Elasticsearch提供Web可视化界面，允许用户通过图表、仪表盘等方式直观地查看和分析日志数据。 适用场景：经典的ELK架构主要适用于数据量较小的开发环境。然而，由于缺少消息队列的缓冲机制，当Logstash或Elasticsearch出现故障时，可能存在数据丢失的风险。 一个经典ELK架构示例 FileBeat采集Nginx服务器日志并发送到Logstash 创建配置文件filebeat-nginx.yml，将其保存到Filebeat安装目录下的conf目录下。 12345678910111213141516171819202122# 因为Nginx的access.log日志都是以IP地址开头的，所以我们需要修改下匹配字段。# 不以ip地址开头的行追加到上一行filebeat.inputs: # 输入源配置- type: log # 日志类型 enabled: true # 是否启用 paths: # 采集路径 - /var/log/nginx/access*.* exclude_files: [&quot;.gz$&quot;] # 排除以.gz 结尾的文件 multiline.pattern: &#x27;^\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\s&#x27; # 匹配以IP地址开头，并紧跟一个空白字符 multiline.negate: true # 不以ip地址开头的行追加到上一行 multiline.match: after # 追加到上一行的后面 # multiline: 多行日志配置，这里实际上不需要配置多行设置，因为nginx的access日志都是单行日志，这里只做演示 # pattern: 正则表达式 # negate: false，匹配pattern的行合并到上一行；true，不匹配pattern的行合并到上一行 # match: after，合并到上一行的末尾；before，合并到上一行的开头 scan_frequency: 10s # 每 10 秒扫描一次日志文件 clean_removed: true # 在日志文件被删除后是否从其内部状态中移除该文件的记录 clean_inactive: 2h # 在日志文件处于非活动状态多长时间后将其从状态数据库中移,设置为比 ignore_older + scan_frequency 更大的值 ignore_older: 1h # 忽略那些比当前时间早于 1 小时的日志文件output.logstash: # 输出配置，这里是发送到Logstash enabled: true # 是否启用 hosts: [&quot;10.250.0.239:5044&quot;] # Logstash服务地址 为FileBeat的用户分配日志目录的读取权限 12# 使用 setfacl命令为elastic用户分配日志目录的读取权限sudo setfacl -d -m u:elastic:r-x -R /var/log/nginx/ 启动FileBeat 123./filebeat -e -c conf/filebeat-nginx.yml# 后台启动nohup ./filebeat -e -c conf/filebeat-nginx.yml &amp; 在启动filebeat时可能会遇到如下错误 1Exiting: error loading config file: config file (&quot;conf/filebeat-nginx.yml&quot;) can only be writable by the owner but the permissions are &quot;-rw-rw-r--&quot; (to fix the permissions use: &#x27;chmod go-w /usr/local/filebeat/filebeat-8.17.3-linux-x86_64/conf/filebeat-nginx.yml&#x27;) 因为安全原因不要其他用户写的权限，去掉写的权限就可以了 1chmod go-w conf/filebeat-nginx.yml 配置Logstash接收FileBeat收集的数据并打印 创建配置文件logstash-nginx.conf，将其保存到Logstash安装目录下的config目录下。 1234567891011121314# 进入logstash安装目录# vim config/logstash-nginx.conf# 配置从FileBeat接收数据input &#123; # 输入源配置 beats &#123; # 从FileBeat接收数据 port =&gt; 5044 # 监听5044端口 &#125;&#125;output &#123; # 输出配置 stdout &#123; # 打印到控制台 codec =&gt; rubydebug # 指定编码器 &#125;&#125; 测试logstash配置是否正确 1bin/logstash -f config/logstash-nginx.conf --config.test_and_exit 启动logstash 12345678910111213141516171819202122232425262728293031323334353637# reload.automatic：修改配置文件时自动重新加载bin/logstash -f config/logstash-nginx.conf --config.reload.automatic# 此时在控制台会看到如下输出：&#123; &quot;input&quot; =&gt; &#123; &quot;type&quot; =&gt; &quot;log&quot; &#125;, &quot;@version&quot; =&gt; &quot;1&quot;, &quot;message&quot; =&gt; &quot;1.119.161.30 - elastic [27/Mar/2025:08:52:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot;, &quot;log&quot; =&gt; &#123; &quot;file&quot; =&gt; &#123; &quot;path&quot; =&gt; &quot;/var/log/nginx/access.log&quot; &#125;, &quot;offset&quot; =&gt; 42985 &#125;, &quot;tags&quot; =&gt; [ [0] &quot;beats_input_codec_plain_applied&quot; ], &quot;@timestamp&quot; =&gt; 2025-03-27T08:52:42.947Z, &quot;ecs&quot; =&gt; &#123; &quot;version&quot; =&gt; &quot;8.0.0&quot; &#125;, &quot;agent&quot; =&gt; &#123; &quot;id&quot; =&gt; &quot;4dbe185b-900d-4990-b841-c13bf9618fc6&quot;, &quot;name&quot; =&gt; &quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot;, &quot;ephemeral_id&quot; =&gt; &quot;6bb04808-7da7-4acb-95fd-f3f915651457&quot;, &quot;type&quot; =&gt; &quot;filebeat&quot;, &quot;version&quot; =&gt; &quot;8.17.3&quot; &#125;, &quot;event&quot; =&gt; &#123; &quot;original&quot; =&gt; &quot;1.119.161.30 - elastic [27/Mar/2025:08:52:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot; &#125;, &quot;host&quot; =&gt; &#123; &quot;name&quot; =&gt; &quot;ip-10-250-0-239.cn-northwest-1.compute.internal&quot; &#125;&#125; 利用Logstash过滤器解析日志 从打印结果看到包含了大量的无关数据，此时可以利用Logstash过滤器解析日志，这里使用Grok插件 Grok是一种将非结构化日志解析为结构化的插件。这个工具非常适合用来解析系统日志、Web服务器日志、MySQL或者是任意其他的日志格式。 Grok是通过模式匹配的方式来识别日志中的数据,可以把Grok插件简单理解为升级版本的正则表达式。它拥有更多的模式，默认Logstash拥有120个模式。如果这些模式不满足我们解析日志的需求，我们可以直接使用正则表达式来进行匹配。 GROK模式参考 grok模式的语法是: 1234%&#123;SYNTAX:SEMANTIC&#125;# SYNTAX（语法）指的是Grok模式名称，SEMANTIC（语义）是给模式匹配到的文本字段名。例如：%&#123;NUMBER:duration&#125; %&#123;IP:client&#125;# duration表示：匹配一个数字，client表示匹配一个IP地址。 匹配nginx日志 123456789101112131415161718192021222324252627282930313233# nginx access日志格式1.119.161.30 - elastic [27/Mar/2025:03:05:36 +0000] &quot;GET /_cluster/stats HTTP/1.1&quot; 200 7446 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&quot; &quot;-&quot;# grok%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;# 解释每个部分的作用：# %&#123;IP:client_ip&#125;：匹配客户端 IP 地址。# -：匹配一个破折号（-），表示匿名用户或未认证用户。# %&#123;USER:remote_user&#125;：匹配远程用户名， - 表示匿名用户。# \\[%&#123;HTTPDATE:timestamp&#125;\\]：匹配请求的时间戳，格式为 [27/Mar/2025:03:05:36 +0000]。# \\&quot;%&#123;WORD:verb&#125; : 匹配请求方法 (GET)# %&#123;URIPATHPARAM:request&#125; : 匹配请求路径 (/_cluster/stats)# HTTP/%&#123;NUMBER:httpversion&#125;\\\\\\&quot;：匹配 HTTP 版本 (HTTP/1.1)。# %&#123;INT:http_status&#125;：匹配 HTTP 响应状态码 (200)。# %&#123;INT:body_bytes_sent&#125;：匹配响应体的字节数 (7446)。# \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot;：匹配引用页 (Referer) 字段，这里为空 (&quot;-&quot;)。# \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot;：匹配用户代理 (User-Agent) 字段。GREEDYDATA 会匹配尽可能多的数据，直到遇到下一个分隔符。# %&#123;QUOTEDSTRING:x_forwarded_for&#125;：匹配 X-Forwarded-For 头字段，这里为空 (&quot;-&quot;)。# 匹配结果&#123; &quot;request&quot;: &quot;/_cluster/stats&quot;, &quot;agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&quot;, &quot;body_bytes_sent&quot;: &quot;7446&quot;, &quot;verb&quot;: &quot;GET&quot;, &quot;x_forwarded_for&quot;: &quot;\\&quot;-\\&quot;&quot;, &quot;remote_user&quot;: &quot;elastic&quot;, &quot;referrer&quot;: &quot;-&quot;, &quot;client_ip&quot;: &quot;1.119.161.30&quot;, &quot;httpversion&quot;: &quot;1.1&quot;, &quot;http_status&quot;: &quot;200&quot;, &quot;timestamp&quot;: &quot;27/Mar/2025:03:05:36 +0000&quot;&#125; 匹配Grok模式是个非常繁琐的过程，我们可以使用Kibana来进行可视化的Grok调试 grok配置 12345grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot; &#125;&#125; 使用mutate插件过滤掉不需要的字段 除了nginx日志本身的格式外，logstash还会打印许多我们不需要的字段，此时可以使用mutate插件来过滤掉不需要的字段。 1234mutate &#123; enable_metric =&gt; &quot;false&quot; # 禁用指标上报 remove_field =&gt; [&quot;message&quot;, &quot;log&quot;, &quot;tags&quot;, &quot;input&quot;, &quot;agent&quot;, &quot;host&quot;, &quot;ecs&quot;, &quot;@version&quot;] # 移除不需要的字段&#125; 使用Date插件对时间进行格式转换 1234date &#123; match =&gt; [&quot;timestamp&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;,&quot;yyyy-MM-dd HH:mm:ss&quot;] # 时间格式转换 target =&gt; &quot;timestamp&quot; # 目标字段&#125; 完整的Logstash配置 1234567891011121314151617181920212223242526272829303132# 进入logstash安装目录# vim config/logstsh-nginx.conf# 配置从FileBeat接收数据input &#123; # 输入源配置 beats &#123; # 从FileBeat接收数据 port =&gt; 5044 # 监听5044端口 &#125;&#125;filter &#123; # 过滤器配置 grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot; &#125; &#125; mutate &#123; enable_metric =&gt; &quot;false&quot; # 禁用指标上报 remove_field =&gt; [&quot;message&quot;, &quot;log&quot;, &quot;tags&quot;, &quot;input&quot;, &quot;agent&quot;, &quot;host&quot;, &quot;ecs&quot;, &quot;@version&quot;] # 移除不需要的字段 &#125; date &#123; match =&gt; [&quot;timestamp&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;,&quot;yyyy-MM-dd HH:mm:ss&quot;] # 时间格式转换 target =&gt; &quot;timestamp&quot; # 目标字段 &#125;&#125;output &#123; # 输出配置 stdout &#123; # 打印到控制台 codec =&gt; rubydebug # 指定编码器 &#125;&#125; 重新启动logstash后得到如下结果： 12345678910111213141516&#123; &quot;event&quot; =&gt; &#123; &quot;original&quot; =&gt; &quot;1.119.161.30 - elastic [27/Mar/2025:09:49:41 +0000] \\&quot;GET /_cluster/stats HTTP/1.1\\&quot; 200 7445 \\&quot;-\\&quot; \\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\&quot; \\&quot;-\\&quot;&quot; &#125;, &quot;client_ip&quot; =&gt; &quot;1.119.161.30&quot;, &quot;request&quot; =&gt; &quot;/_cluster/stats&quot;, &quot;http_status&quot; =&gt; &quot;200&quot;, &quot;@timestamp&quot; =&gt; 2025-03-27T09:49:45.751Z, &quot;body_bytes_sent&quot; =&gt; &quot;7445&quot;, &quot;x_forwarded_for&quot; =&gt; &quot;\\&quot;-\\&quot;&quot;, &quot;timestamp&quot; =&gt; 2025-03-27T09:49:41.000Z, &quot;referrer&quot; =&gt; &quot;-&quot;, &quot;remote_user&quot; =&gt; &quot;elastic&quot;, &quot;httpversion&quot; =&gt; &quot;1.1&quot;, &quot;verb&quot; =&gt; &quot;GET&quot;&#125; 将结果输出到ES 1234567891011121314# 在输出配置中添加ES输出配置output &#123; # 输出配置 stdout &#123; # 打印到控制台 codec =&gt; rubydebug # 指定编码器 &#125; elasticsearch &#123; # 输出到ES index =&gt; &quot;nginx_access_log_%&#123;+YYYY-MM&#125;&quot; # 索引名,按月分隔 hosts =&gt; [&quot;https://10.250.0.239:9200&quot;] # ES地址 user =&gt; &quot;elastic&quot; # ES用户名 password =&gt; &quot;123456&quot; # ES密码 ssl =&gt; true # 是否启用SSL，因为这里是https访问ES ssl_certificate_verification =&gt; false # 禁用证书验证 &#125;&#125; 如果需要开启证书校验，可以通过如下方法进行配置 获取 Elasticsearch 的 SSL 证书： 12# 从 Elasticsearch 的配置文件或证书文件路径中获取证书（通常是 .pem 或 .crt 文件）。/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt 导入证书到 Java 信任库：注意这里要导入到启动Logstash的JAVA进程的信任库 1234567891011121314151617181920212223242526272829303132333435363738394041424344# logstash的jdk路径，默认在logstash的安装目录下cd /usr/local/logstash/logstash-8.17.3/jdkbin/keytool -importcert -alias es-cert -keystore /usr/local/logstash/logstash-8.17.3/logstash.keystore -file /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt# 输出Enter keystore password: # 输入密码 这里是123456Re-enter new password:Owner: CN=Elasticsearch security auto-configuration HTTP CAIssuer: CN=Elasticsearch security auto-configuration HTTP CASerial number: 89d5c501a2efd5d45a6ee5e08daa16bd605d8c28Valid from: Thu Mar 20 08:53:26 UTC 2025 until: Sun Mar 19 08:53:26 UTC 2028Certificate fingerprints: SHA1: DE:73:0C:EC:46:59:69:83:52:7C:C4:CC:6B:65:EC:B6:31:BE:10:22 SHA256: 3F:14:1C:16:DF:C6:E1:65:89:4B:C1:67:20:84:B2:20:DC:DD:22:FF:E0:21:16:D5:1A:C1:80:03:CF:AA:5A:1DSignature algorithm name: SHA256withRSASubject Public Key Algorithm: 4096-bit RSA keyVersion: 3Extensions:#1: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: 25 EF BA 81 AE 5E 14 1C 7E FF A1 87 12 F8 D0 2E %....^..........0010: 3A D7 54 5F :.T_]]#2: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[CA:truePathLen: no limit]#3: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 25 EF BA 81 AE 5E 14 1C 7E FF A1 87 12 F8 D0 2E %....^..........0010: 3A D7 54 5F :.T_]]Trust this certificate? [no]: yes # yes确认Certificate was added to keystore 配置 Logstash 使用信任库 123456789101112output &#123; elasticsearch &#123; index =&gt; &quot;nginx_access_log_%&#123;+YYYY-MM&#125;&quot; # 索引名,按月分隔 hosts =&gt; [&quot;https://10.250.0.239:9200&quot;] # ES地址 user =&gt; &quot;elastic&quot; # ES用户名 password =&gt; &quot;123456&quot; # ES密码 ssl =&gt; true # 是否启用SSL，因为这里是https访问ES ssl_certificate_verification =&gt; true # 启用证书校验 ssl_truststore_path =&gt; &quot;/usr/local/logstash/logstash-8.17.3/logstash.keystore&quot; # 指定信任库路径 ssl_truststore_password =&gt; &quot;123456&quot; # 信任库密码 &#125;&#125; 整合消息队列+Nginx的ELK架构 消息队列：引入消息队列作为缓冲机制，确保即使在Logstash或Elasticsearch出现故障时，日志数据也不会丢失。消息队列能够均衡网络传输，降低数据丢失的可能性。 Nginx：Nginx作为高性能的Web和反向代理服务器，可以进一步优化整个系统的性能和可用性。它可以在负载均衡、缓存等方面发挥作用，提升用户访问体验。 扩展性：由于引入了消息队列和Nginx等组件，整个架构的扩展性得到增强。可以根据实际需求动态调整各组件的资源分配和部署规模。 适用场景：整合消息队列+Nginx的架构主要适用于生产环境，特别是需要处理大数据量的场景。它能够确保数据的安全性和完整性，同时提供高性能的日志处理和可视化分析服务。 总结来说就是 filebeat将采集的日志发送到Redis\\RabbitMQ\\Kafka等 Logstash再从Redis\\RabbitMQ\\Kafka中读取日志数据，并进行解析后发送到ES中。 ES集群使用nginx进行负载均衡，以实现高可用和高性能。具体实现方法查看：linux下安装Elasticsearch集群 基于Redis的ELK架构示例 filebeat将采集的日志发送到Redis 创建配置文件filebeat-nginx-to-redis.yml，将其保存到Filebeat安装目录下的conf目录下。 1234567891011121314151617181920212223242526# 因为Nginx的access.log日志都是以IP地址开头的，所以我们需要修改下匹配字段。# 不以ip地址开头的行追加到上一行filebeat.inputs: # 输入源配置- type: log # 日志类型 enabled: true # 是否启用 paths: # 采集路径 - /var/log/nginx/access*.* exclude_files: [&quot;.gz$&quot;] # 排除以.gz 结尾的文件 multiline.pattern: &#x27;^\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\s&#x27; # 匹配以IP地址开头，并紧跟一个空白字符 multiline.negate: true # 不以ip地址开头的行追加到上一行 multiline.match: after # 追加到上一行的后面 # multiline: 多行日志配置，这里实际上不需要配置多行设置，因为nginx的access日志都是单行日志，这里只做演示 # pattern: 正则表达式 # negate: false，匹配pattern的行合并到上一行；true，不匹配pattern的行合并到上一行 # match: after，合并到上一行的末尾；before，合并到上一行的开头 scan_frequency: 10s # 每 10 秒扫描一次日志文件 clean_removed: true # 在日志文件被删除后是否从其内部状态中移除该文件的记录 clean_inactive: 2h # 在日志文件处于非活动状态多长时间后将其从状态数据库中移,设置为比 ignore_older + scan_frequency 更大的值 ignore_older: 1h # 忽略那些比当前时间早于 1 小时的日志文件output.redis: # Redis输出配置 hosts: [&quot;10.250.0.214:6379&quot;] # Redis服务器地址 password: &quot;123456&quot; # Redis密码 key: &quot;filebeat_nginx&quot; # Redis的key，类型为 list db: 3 # Redis数据库 timeout: 3 # Redis连接超时时间，单位秒 启动Filebeat，并查看日志输出。 1./filebeat -e -c conf/filebeat-nginx-to-redis.yml 查看Redis中的数据 1234567891011$ redis-cli -h 10.250.0.214 -p 6379 -a 12345610.250.0.214:6379&gt; select 3OK10.250.0.214:6379[3]&gt; keys filebeat*1) &quot;filebeat_nginx&quot;10.250.0.214:6379[3]&gt; type filebeat_nginxlist10.250.0.214:6379[3]&gt; LLEN filebeat_nginx(integer) 1410.250.0.214:6379[3]&gt; LINDEX filebeat_nginx 1&quot;&#123;\\&quot;@timestamp\\&quot;:\\&quot;2025-03-28T09:15:23.402Z\\&quot;,\\&quot;@metadata\\&quot;:&#123;\\&quot;beat\\&quot;:\\&quot;filebeat\\&quot;,\\&quot;type\\&quot;:\\&quot;_doc\\&quot;,\\&quot;version\\&quot;:\\&quot;8.17.3\\&quot;&#125;,\\&quot;host\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;ip-10-250-0-239.cn-northwest-1.compute.internal\\&quot;&#125;,\\&quot;agent\\&quot;:&#123;\\&quot;version\\&quot;:\\&quot;8.17.3\\&quot;,\\&quot;ephemeral_id\\&quot;:\\&quot;c0a521fe-690b-46b1-aadc-bbe16ef1db9a\\&quot;,\\&quot;id\\&quot;:\\&quot;4dbe185b-900d-4990-b841-c13bf9618fc6\\&quot;,\\&quot;name\\&quot;:\\&quot;ip-10-250-0-239.cn-northwest-1.compute.internal\\&quot;,\\&quot;type\\&quot;:\\&quot;filebeat\\&quot;&#125;,\\&quot;log\\&quot;:&#123;\\&quot;offset\\&quot;:46745,\\&quot;file\\&quot;:&#123;\\&quot;path\\&quot;:\\&quot;/var/log/nginx/access.log\\&quot;&#125;&#125;,\\&quot;message\\&quot;:\\&quot;1.119.161.30 - elastic [28/Mar/2025:09:15:13 +0000] \\\\\\&quot;GET /_cluster/stats HTTP/1.1\\\\\\&quot; 200 7457 \\\\\\&quot;-\\\\\\&quot; \\\\\\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\\\\\\&quot; \\\\\\&quot;-\\\\\\&quot;\\&quot;,\\&quot;input\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;log\\&quot;&#125;,\\&quot;ecs\\&quot;:&#123;\\&quot;version\\&quot;:\\&quot;8.0.0\\&quot;&#125;&#125;&quot; Logstash从Redis中读取日志并写入Elasticsearch 创建配置文件logstash-nginx-redis-to-es.conf，将其保存到Logstash安装目录下的conf目录下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 进入logstash安装目录# vim logstash-nginx-redis-to-es.conf# 配置从 redis 接收数据input &#123; # 输入源配置 redis &#123; # Redis输入配置 host =&gt; &#x27;10.250.0.214&#x27; # Redis服务器地址 port =&gt; &quot;6379&quot; # Redis服务器端口 password =&gt; &quot;123456&quot; # Redis密码 db =&gt; &quot;3&quot; # Redis数据库 data_type =&gt; &#x27;list&#x27; # 数据类型为list key =&gt; &quot;filebeat_nginx&quot; # Redis的key &#125;&#125;filter &#123; # 过滤器配置 grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;IP:client_ip&#125; - %&#123;USER:remote_user&#125; \\[%&#123;HTTPDATE:timestamp&#125;\\] \\&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\\&quot; %&#123;INT:http_status&#125; %&#123;INT:body_bytes_sent&#125; \\&quot;%&#123;NOTSPACE:referrer&#125;\\&quot; \\&quot;%&#123;GREEDYDATA:agent&#125;\\&quot; %&#123;QUOTEDSTRING:x_forwarded_for&#125;&quot; &#125; &#125; mutate &#123; enable_metric =&gt; &quot;false&quot; # 禁用指标上报 remove_field =&gt; [&quot;message&quot;, &quot;log&quot;, &quot;tags&quot;, &quot;input&quot;, &quot;agent&quot;, &quot;host&quot;, &quot;ecs&quot;, &quot;@version&quot;] # 移除不需要的字段 &#125; date &#123; match =&gt; [&quot;timestamp&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;,&quot;yyyy-MM-dd HH:mm:ss&quot;] # 时间格式转换 target =&gt; &quot;timestamp&quot; # 目标字段 &#125;&#125;# 在输出配置中添加ES输出配置output &#123; # 输出配置 stdout &#123; # 打印到控制台 codec =&gt; rubydebug # 指定编码器 &#125; elasticsearch &#123; # 输出到ES index =&gt; &quot;redis_nginx_access_log_%&#123;+YYYY-MM&#125;&quot; # 索引名,按月分隔 hosts =&gt; [&quot;https://10.250.0.239:9200&quot;] # ES地址 user =&gt; &quot;elastic&quot; # ES用户名 password =&gt; &quot;123456&quot; # ES密码 ssl =&gt; true # 是否启用SSL，因为这里是https访问ES ssl_certificate_verification =&gt; false # 禁用证书验证 &#125;&#125; 测试logstash配置是否正确 1bin/logstash -f config/logstash-nginx-redis-to-es.conf --config.test_and_exit 启动logstash 12# reload.automatic：修改配置文件时自动重新加载bin/logstash -f config/logstash-nginx-redis-to-es.conf --config.reload.automatic","summary":"摘要 本文介绍如何在linux下安装LogStash和FileBeat 通过示例讲解ELK的经典架构和高并发架构的实现过程 LogStash版本8.17.3，FileBeat版本8.17.3 Elasticsearch版本8.17.3，linux下安装Elasticsearch Kibana版本8.17.3，linux下安装Kibana Elasticsearch集群搭建，linux下安装Elasticsearch集群","date_published":"2025-03-27T13:30:05.000Z","tags":["技术","elastic","kibana","logstash","elasticsearch","kibana","logstash"]},{"id":"https://blog.hanqunfeng.com/2025/03/25/elasticsearch-03-plugins/","url":"https://blog.hanqunfeng.com/2025/03/25/elasticsearch-03-plugins/","title":"linux下Elasticsearch插件安装","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在linux为Elasticsearch安装插件</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装Elasticsearch核心库插件\">安装Elasticsearch核心库插件</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以安装 <code>analysis-icu</code> 这个分词插件为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入Elasticsearch安装目录，插件的安装路径在 plugins 目录下</span></span><br><span class=\"line\"><span class=\"comment\"># 安装插件</span></span><br><span class=\"line\">bin/elasticsearch-plugin install analysis-icu</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装或卸载插件后，需要重启Elasticsearch服务</p>\n</li>\n</ul>\n<h2 id=\"安装其它来源的插件\">安装其它来源的插件</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以安装 <code>analysis-ik</code> 这个中文分词插件为例</p>\n</li>\n<li class=\"lvl-2\">\n<p>从<a href=\"https://release.infinilabs.com/analysis-ik/stable/\">https://release.infinilabs.com/analysis-ik/stable/</a>找到对应版本的插件连接，这里以<code>8.17.3</code>为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.基于url安装插件</span></span><br><span class=\"line\">bin/elasticsearch-plugin install https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-8.17.3.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.基于本地文件安装插件，我们可以先将插件下载的本地目录</span></span><br><span class=\"line\">wget https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-8.17.3.zip -P /tmp/</span><br><span class=\"line\">bin/elasticsearch-plugin install file:///tmp/elasticsearch-analysis-ik-8.17.3.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.可以将下载好的包解压到plugins目录下，然后重启Elasticsearch服务</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/elasticsearch/elasticsearch-8.17.3/plugins/analysis-ik</span><br><span class=\"line\">unzip elasticsearch-analysis-ik-8.17.3.zip -d /usr/local/elasticsearch/elasticsearch-8.17.3/plugins/analysis-ik</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看和卸载插件\">查看和卸载插件</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有插件</span></span><br><span class=\"line\">bin/elasticsearch-plugin list</span><br><span class=\"line\"><span class=\"comment\"># 卸载插件</span></span><br><span class=\"line\">bin/elasticsearch-plugin remove analysis-ik</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过curl命令查看插件信息</span></span><br><span class=\"line\">curl -u elastic:123456 -k https://localhost:9200/_cat/plugins?v</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装或卸载插件后，需要重启Elasticsearch服务</p>\n</li>\n</ul>\n<h2 id=\"analysis-ik-中文分词插件的使用\"><code>analysis-ik</code> 中文分词插件的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试分词效果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ES的默认分词器是standard，会单字拆分</span></span><br><span class=\"line\">POST _analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;analyzer&quot;</span>: <span class=\"string\">&quot;standard&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;text&quot;</span>: <span class=\"string\">&quot;中华人民共和国&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#analysis-ik的ik_smart分词器:会做最粗粒度的拆</span></span><br><span class=\"line\">POST _analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;analyzer&quot;</span>: <span class=\"string\">&quot;ik_smart&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;text&quot;</span>: <span class=\"string\">&quot;中华人民共和国&quot;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#analysis-ik的ik_max_word分词器:会将文本做最细粒度的拆分</span></span><br><span class=\"line\">POST _analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;analyzer&quot;</span>: <span class=\"string\">&quot;ik_max_word&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;text&quot;</span>: <span class=\"string\">&quot;中华人民共和国&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置索引的分词器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建索引，并指定默认分词器为ik_max_word</span></span><br><span class=\"line\">PUT /test_index</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;settings&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;index&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;analysis.analyzer.default.type&quot;</span>: <span class=\"string\">&quot;ik_max_word&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 查看索引setting信息</span></span><br><span class=\"line\">GET /test_index/_settings</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置索引字段的分词器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建索引</span></span><br><span class=\"line\">PUT /index</span><br><span class=\"line\"><span class=\"comment\"># 指定content字段使用ik分词器</span></span><br><span class=\"line\">POST /index/_mapping</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;properties&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;content&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;text&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;analyzer&quot;</span>: <span class=\"string\">&quot;ik_max_word&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;search_analyzer&quot;</span>: <span class=\"string\">&quot;ik_smart&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#索引文档，也就是插入文档</span></span><br><span class=\"line\">POST /index/_create/1</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;content&quot;</span>:<span class=\"string\">&quot;美国留给伊拉克的是个烂摊子吗&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">POST /index/_create/2</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;content&quot;</span>:<span class=\"string\">&quot;公安部：各地校车将享最高路权&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">POST /index/_create/3</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;content&quot;</span>:<span class=\"string\">&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">POST /index/_create/4</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;content&quot;</span>:<span class=\"string\">&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#带高亮的查询</span></span><br><span class=\"line\">POST /index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;query&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;match&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;content&quot;</span>: <span class=\"string\">&quot;中国&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;highlight&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;pre_tags&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;tag1&gt;&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;tag2&gt;&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;post_tags&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;/tag1&gt;&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;/tag2&gt;&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;fields&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;content&quot;</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍如何在linux为Elasticsearch安装插件 Elasticsearch版本8.17.3 安装Elasticsearch核心库插件 以安装 analysis-icu 这个分词插件为例 123# 进入Elasticsearch安装目录，插件的安装路径在 plugins 目录下# 安装插件bin/elasticsearch-plugin install analysis-icu 安装或卸载插件后，需要重启Elasticsearch服务 安装其它来源的插件 以安装 analysis-ik 这个中文分词插件为例 从https://release.infinilabs.com/analysis-ik/stable/找到对应版本的插件连接，这里以8.17.3为例 12345678910# 1.基于url安装插件bin/elasticsearch-plugin install https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-8.17.3.zip# 2.基于本地文件安装插件，我们可以先将插件下载的本地目录wget https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-8.17.3.zip -P /tmp/bin/elasticsearch-plugin install file:///tmp/elasticsearch-analysis-ik-8.17.3.zip# 3.可以将下载好的包解压到plugins目录下，然后重启Elasticsearch服务mkdir /usr/local/elasticsearch/elasticsearch-8.17.3/plugins/analysis-ikunzip elasticsearch-analysis-ik-8.17.3.zip -d /usr/local/elasticsearch/elasticsearch-8.17.3/plugins/analysis-ik 查看和卸载插件 1234567# 列出所有插件bin/elasticsearch-plugin list# 卸载插件bin/elasticsearch-plugin remove analysis-ik# 通过curl命令查看插件信息curl -u elastic:123456 -k https://localhost:9200/_cat/plugins?v 安装或卸载插件后，需要重启Elasticsearch服务 analysis-ik 中文分词插件的使用 测试分词效果 1234567891011121314151617181920#ES的默认分词器是standard，会单字拆分POST _analyze&#123; &quot;analyzer&quot;: &quot;standard&quot;, &quot;text&quot;: &quot;中华人民共和国&quot;&#125;#analysis-ik的ik_smart分词器:会做最粗粒度的拆POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;中华人民共和国&quot; &#125;#analysis-ik的ik_max_word分词器:会将文本做最细粒度的拆分POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;中华人民共和国&quot;&#125; 配置索引的分词器 1234567891011# 创建索引，并指定默认分词器为ik_max_wordPUT /test_index&#123; &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;analysis.analyzer.default.type&quot;: &quot;ik_max_word&quot; &#125; &#125;&#125;# 查看索引setting信息GET /test_index/_settings 配置索引字段的分词器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#创建索引PUT /index# 指定content字段使用ik分词器POST /index/_mapping&#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125; &#125;&#125;#索引文档，也就是插入文档POST /index/_create/1&#123;&quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;&#125;POST /index/_create/2&#123;&quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;&#125;POST /index/_create/3&#123;&quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;&#125;POST /index/_create/4&#123;&quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125;#带高亮的查询POST /index/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;中国&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;pre_tags&quot;: [ &quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot; ], &quot;post_tags&quot;: [ &quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot; ], &quot;fields&quot;: &#123; &quot;content&quot;: &#123;&#125; &#125; &#125;&#125;","summary":"摘要 本文介绍如何在linux为Elasticsearch安装插件 Elasticsearch版本8.17.3","date_published":"2025-03-25T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]},{"id":"https://blog.hanqunfeng.com/2025/03/24/elasticsearch-02-install-cluster/","url":"https://blog.hanqunfeng.com/2025/03/24/elasticsearch-02-install-cluster/","title":"linux下安装Elasticsearch集群","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在linux下安装Elasticsearch集群(三节点)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p>单节点安装参考<a href=\"/2025/03/20/elasticsearch-01-install/\" title=\"linux下安装Elasticsearch\">linux下安装Elasticsearch</a>，本文在此基础上完成集群安装</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"集群安装\">集群安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>三个节点分别安照单节点的安装方式完成下载，用户配置，环境变量配置，系统参数配置，等等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>任选一个节点作为集群的master节点，我们命名为<code>node-1</code>，其它节点命名为<code>node-2</code>和<code>node-3</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>先配置<code>node-1</code>节点的配置文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群名称</span></span><br><span class=\"line\">cluster.name: test-elk</span><br><span class=\"line\"><span class=\"comment\"># 节点名称</span></span><br><span class=\"line\">node.name: node-1</span><br><span class=\"line\"><span class=\"comment\"># 数据存储路径，默认值 $ES_HOME/data</span></span><br><span class=\"line\">path.data: /usr/local/elasticsearch/data</span><br><span class=\"line\"><span class=\"comment\"># 日志存储路径，默认值 $ES_HOME/logs</span></span><br><span class=\"line\">path.logs: /usr/local/elasticsearch/logs</span><br><span class=\"line\"><span class=\"comment\"># 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为false</span></span><br><span class=\"line\">bootstrap.memory_lock: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 允许通过任何地址访问，开启远程访问</span></span><br><span class=\"line\">network.host: 0.0.0.0</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的http端口，默认 9200</span></span><br><span class=\"line\">http.port: 9200</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的tcp端口，默认 9300</span></span><br><span class=\"line\">transport.port: 9300</span><br><span class=\"line\"><span class=\"comment\"># 集群内的主机列表，开启安全认证时无需配置，注意这里不要进行配置</span></span><br><span class=\"line\"><span class=\"comment\"># discovery.seed_hosts: [&quot;127.0.0.1&quot;]</span></span><br><span class=\"line\"><span class=\"comment\"># 第一次启动时需要参与选主的节点名称，这里只配置node-1</span></span><br><span class=\"line\">cluster.initial_master_nodes: [<span class=\"string\">&quot;node-1&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\">#解决跨域问题</span></span><br><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置<code>node-2</code>节点的配置文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群名称</span></span><br><span class=\"line\">cluster.name: test-elk</span><br><span class=\"line\"><span class=\"comment\"># 节点名称</span></span><br><span class=\"line\">node.name: node-2</span><br><span class=\"line\"><span class=\"comment\"># 数据存储路径，默认值 $ES_HOME/data</span></span><br><span class=\"line\">path.data: /usr/local/elasticsearch/data</span><br><span class=\"line\"><span class=\"comment\"># 日志存储路径，默认值 $ES_HOME/logs</span></span><br><span class=\"line\">path.logs: /usr/local/elasticsearch/logs</span><br><span class=\"line\"><span class=\"comment\"># 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为false</span></span><br><span class=\"line\">bootstrap.memory_lock: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 允许通过任何地址访问，开启远程访问</span></span><br><span class=\"line\">network.host: 0.0.0.0</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的http端口，默认 9200</span></span><br><span class=\"line\">http.port: 9200</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的tcp端口，默认 9300</span></span><br><span class=\"line\">transport.port: 9300</span><br><span class=\"line\"><span class=\"comment\">#解决跨域问题</span></span><br><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置<code>node-3</code>节点的配置文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群名称</span></span><br><span class=\"line\">cluster.name: test-elk</span><br><span class=\"line\"><span class=\"comment\"># 节点名称</span></span><br><span class=\"line\">node.name: node-3</span><br><span class=\"line\"><span class=\"comment\"># 数据存储路径，默认值 $ES_HOME/data</span></span><br><span class=\"line\">path.data: /usr/local/elasticsearch/data</span><br><span class=\"line\"><span class=\"comment\"># 日志存储路径，默认值 $ES_HOME/logs</span></span><br><span class=\"line\">path.logs: /usr/local/elasticsearch/logs</span><br><span class=\"line\"><span class=\"comment\"># 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为false</span></span><br><span class=\"line\">bootstrap.memory_lock: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 允许通过任何地址访问，开启远程访问</span></span><br><span class=\"line\">network.host: 0.0.0.0</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的http端口，默认 9200</span></span><br><span class=\"line\">http.port: 9200</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的tcp端口，默认 9300</span></span><br><span class=\"line\">transport.port: 9300</span><br><span class=\"line\"><span class=\"comment\">#解决跨域问题</span></span><br><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动<code>node-1</code>，启动成功后我们会在日志中看到如下安全认证信息信息，记录其中的加入集群的节点的token信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><br><span class=\"line\"><span class=\"comment\"># 这些日志信息提供了 Elasticsearch 8 在首次启动时自动配置的安全特性、生成的默认密码、证书指纹以及如何配置 Kibana 和其他节点加入集群的详细说明。</span></span><br><span class=\"line\">✅ Elasticsearch security features have been automatically configured!</span><br><span class=\"line\">✅ Authentication is enabled and cluster connections are encrypted.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是 elastic 用户的默认密码。系统建议你使用 bin/elasticsearch-reset-password -u elastic 命令来重置此密码。</span></span><br><span class=\"line\">ℹ️  Password <span class=\"keyword\">for</span> the elastic user (reset with `bin/elasticsearch-reset-password -u elastic`):</span><br><span class=\"line\">  BNb=*qz6_M*mXL9uZiSP <span class=\"comment\"># 这里会打印出ES自动生成的密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是 HTTP CA 证书的 SHA-256 指纹。CA 证书用于验证 HTTPS 连接的身份。</span></span><br><span class=\"line\">ℹ️  HTTP CA certificate SHA-256 fingerprint:</span><br><span class=\"line\">  3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提供了将 Kibana 配置为使用此 Elasticsearch 集群的步骤。</span></span><br><span class=\"line\">ℹ️  Configure Kibana to use this cluster:</span><br><span class=\"line\"><span class=\"comment\"># 启动 Kibana 并按照终端中显示的配置链接进行操作。</span></span><br><span class=\"line\">• Run Kibana and click the configuration <span class=\"built_in\">link</span> <span class=\"keyword\">in</span> the terminal when Kibana starts.</span><br><span class=\"line\"><span class=\"comment\"># 复制提供的注册令牌，并在浏览器中打开 Kibana 时粘贴此令牌。令牌在接下来的 30 分钟内有效。</span></span><br><span class=\"line\"><span class=\"comment\"># 补充说明：生成新的kibana注册令牌：bin/elasticsearch-create-enrollment-token -s kibana</span></span><br><span class=\"line\">• Copy the following enrollment token and <span class=\"built_in\">paste</span> it into Kibana <span class=\"keyword\">in</span> your browser (valid <span class=\"keyword\">for</span> the next 30 minutes):</span><br><span class=\"line\">  eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImFSWFBzcFVCTVVmc1d5aUJnbjBtOmRzbVBLQV95UXhDZkJpXzQyWDNEMVEifQ==</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提供了将新的 Elasticsearch 节点加入现有集群的步骤。</span></span><br><span class=\"line\">ℹ️ Configure other nodes to <span class=\"built_in\">join</span> this cluster:</span><br><span class=\"line\"><span class=\"comment\"># 使用 bin/elasticsearch --enrollment-token &lt;token&gt; 命令启动新的 Elasticsearch 节点。令牌在接下来的 30 分钟内有效。</span></span><br><span class=\"line\"><span class=\"comment\"># 补充说明：生成新的节点注册令牌：bin/elasticsearch-create-enrollment-token -s node</span></span><br><span class=\"line\">• Copy the following enrollment token and start new Elasticsearch nodes with `bin/elasticsearch --enrollment-token &lt;token&gt;` (valid <span class=\"keyword\">for</span> the next 30 minutes):</span><br><span class=\"line\">  eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImF4WFBzcFVCTVVmc1d5aUJnbjFtOkFEallPdnpzUzh1MGJqOFpfVFE4a3cifQ==</span><br><span class=\"line\"><span class=\"comment\"># 如果你在 Docker 中运行 Elasticsearch，可以使用 docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3 命令启动新节点。</span></span><br><span class=\"line\">  If you<span class=\"string\">&#x27;re running in Docker, copy the enrollment token and run:</span></span><br><span class=\"line\"><span class=\"string\">  `docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3`</span></span><br><span class=\"line\"><span class=\"string\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>token信息有效时间只有30分钟，超时后可以使用如下命令重新生成新的token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入node-1节点的ES安装目录，此命令会生成新的节点注册令牌</span></span><br><span class=\"line\">bin/elasticsearch-create-enrollment-token -s node</span><br><span class=\"line\">eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6IlpoRVZ4NVVCeXRPajdLeTBqb3BvOmdHRW44ZW5mU0RDZHA2Yy1uSDF4eGcifQ==</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动<code>node-2</code>节点，启动时要带上token信息，<code>node-3</code>与此一样。这里要注意，只有第一次加入集群时启动才需要带上注册令牌，后续启动不需要token信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入node-2节点的ES安装目录，此命令会启动ES节点，并加入到集群中</span></span><br><span class=\"line\"><span class=\"comment\"># bin/elasticsearch --enrollment-token &lt;token&gt;</span></span><br><span class=\"line\">bin/elasticsearch --enrollment-token eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6IlpoRVZ4NVVCeXRPajdLeTBqb3BvOmdHRW44ZW5mU0RDZHA2Yy1uSDF4eGcifQ==</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>加入集群失败</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">在执行<code>bin/elasticsearch --enrollment-token &lt;token&gt;</code>时有可能会遇到如下异常：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Aborting auto configuration because the node keystore contains password settings already, with <span class=\"built_in\">exit</span> code 78</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">这通常意味着节点的 <code>keystore</code> 已经包含了密码设置，因此自动配置过程被中止。</li>\n<li class=\"lvl-2\">产生这种错误的原因大概率是当前ES是从已经安装好的服务器上拷贝过来的，而不是全新安装的，此时我们除了需要清空<code>data</code>目录外，还需要删除 <code>keystore</code> 中的密码</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看keystore中的密码</span></span><br><span class=\"line\">$ bin/elasticsearch-keystore list</span><br><span class=\"line\">keystore.seed</span><br><span class=\"line\">xpack.security.http.ssl.keystore.secure_password</span><br><span class=\"line\">xpack.security.transport.ssl.keystore.secure_password</span><br><span class=\"line\">xpack.security.transport.ssl.truststore.secure_password</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除keystore中的密码</span></span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.http.ssl.keystore.secure_password</span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.keystore.secure_password</span><br><span class=\"line\">$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.truststore.secure_password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>再次执行<code>bin/elasticsearch --enrollment-token &lt;token&gt;</code>即可。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外还可能遇到如下报错：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Aborting enrolling to cluster. Could not communicate with the node on any of the addresses from the enrollment token. All of [10.250.0.239:9200] were attempted., with <span class=\"built_in\">exit</span> code 69</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">这是由于token过期了，重新生成新的token即可</li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动成功后会在<code>node-2</code>的配置文件中看到如下配置信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#----------------------- BEGIN SECURITY AUTO CONFIGURATION -----------------------</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The following settings, TLS certificates, and keys have been automatically</span></span><br><span class=\"line\"><span class=\"comment\"># generated to configure Elasticsearch security features on 24-03-2025 07:45:11</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># --------------------------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable security features</span></span><br><span class=\"line\">xpack.security.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">xpack.security.enrollment.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents</span></span><br><span class=\"line\">xpack.security.http.ssl:</span><br><span class=\"line\">  enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">  keystore.path: certs/http.p12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable encryption and mutual authentication between cluster nodes</span></span><br><span class=\"line\">xpack.security.transport.ssl:</span><br><span class=\"line\">  enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">  verification_mode: certificate</span><br><span class=\"line\">  keystore.path: certs/transport.p12</span><br><span class=\"line\">  truststore.path: certs/transport.p12</span><br><span class=\"line\"><span class=\"comment\"># Discover existing nodes in the cluster</span></span><br><span class=\"line\">discovery.seed_hosts: [<span class=\"string\">&quot;10.250.0.239:9300&quot;</span>] <span class=\"comment\"># 这里是node-1节点的IP地址和端口号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 而node-3这里会显示如下信息，也就是越是后来加入进来的，这里就会加上之前所有节点的IP地址和端口号</span></span><br><span class=\"line\">discovery.seed_hosts: [<span class=\"string\">&quot;10.250.0.239:9300&quot;</span>, <span class=\"string\">&quot;10.250.0.17:9300&quot;</span>] <span class=\"comment\"># 这里是node-1和node-2节点的IP地址和端口号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------------- END SECURITY AUTO CONFIGURATION -------------------------</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"验证集群状态\">验证集群状态</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动完成后，可以通过如下命令查看集群状态：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看集群状态</span></span><br><span class=\"line\">$ curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt  https://127.0.0.1:9200/_cluster/health?pretty</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;cluster_name&quot;</span> : <span class=\"string\">&quot;test-elk&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;status&quot;</span> : <span class=\"string\">&quot;green&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;timed_out&quot;</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;number_of_nodes&quot;</span> : 3,</span><br><span class=\"line\">  <span class=\"string\">&quot;number_of_data_nodes&quot;</span> : 3,</span><br><span class=\"line\">  <span class=\"string\">&quot;active_primary_shards&quot;</span> : 31,</span><br><span class=\"line\">  <span class=\"string\">&quot;active_shards&quot;</span> : 62,</span><br><span class=\"line\">  <span class=\"string\">&quot;relocating_shards&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;initializing_shards&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;unassigned_shards&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;unassigned_primary_shards&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;delayed_unassigned_shards&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;number_of_pending_tasks&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;number_of_in_flight_fetch&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;task_max_waiting_in_queue_millis&quot;</span> : 0,</span><br><span class=\"line\">  <span class=\"string\">&quot;active_shards_percent_as_number&quot;</span> : 100.0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 查看节点信息，其中 * 表示当前节点为master节点</span></span><br><span class=\"line\">$ curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt  https://127.0.0.1:9200/_cat/nodes?v</span><br><span class=\"line\">ip           heap.percent ram.percent cpu load_1m load_5m load_15m node.role   master name</span><br><span class=\"line\">10.250.0.17             8          63  28    1.03    0.38     0.14 cdfhilmrstw -      node-2</span><br><span class=\"line\">10.250.0.173            9          63  22    0.86    0.37     0.19 cdfhilmrstw -      node-3</span><br><span class=\"line\">10.250.0.239            9          78   6    0.38    0.22     0.16 cdfhilmrstw *      node-1</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要说明\">重要说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群一旦创建完成，则至少需要两个节点运行才能保证集群可用性，否则集群将无法运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果<code>node-1</code>节点挂了，集群中剩下的两个节点会重新选择一个新的<code>master</code>节点，不会影响集群的可用性。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一旦关闭<code>node-1</code>，则重新启动<code>node-1</code>节点前要修改其配置文件，否则无法启动成功。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注释掉该配置</span></span><br><span class=\"line\"><span class=\"comment\"># cluster.initial_master_nodes: [&quot;node-1&quot;]</span></span><br><span class=\"line\"><span class=\"comment\"># 加入该配置，实际上最好在重启每个节点前，将每个节点都配置为这样</span></span><br><span class=\"line\">discovery.seed_hosts: [<span class=\"string\">&quot;10.250.0.239:9300&quot;</span>, <span class=\"string\">&quot;10.250.0.17:9300&quot;</span>, <span class=\"string\">&quot;10.250.0.173:9300&quot;</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kibana关联ES集群\">Kibana关联ES集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kibana 关联单节点ES参考 <a href=\"/2025/03/21/kibana-01-install/\" title=\"linux下安装Kibana\">linux下安装Kibana</a>，在此基础上对配置文件进行如下修改：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关联集群的节点地址，将集群内所有节点的地址都配置到该字段中</span></span><br><span class=\"line\">elasticsearch.hosts: [<span class=\"string\">&#x27;https://10.250.0.239:9200&#x27;</span>, <span class=\"string\">&#x27;https://10.250.0.173:9200&#x27;</span>, <span class=\"string\">&#x27;https://10.250.0.17:9200&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 关联集群的输出地址，将集群内所有节点的地址都配置到该字段中</span></span><br><span class=\"line\">xpack.fleet.outputs: [&#123;<span class=\"built_in\">id</span>: fleet-default-output, name: default, is_default: <span class=\"literal\">true</span>, is_default_monitoring: <span class=\"literal\">true</span>, <span class=\"built_in\">type</span>: elasticsearch, hosts: [<span class=\"string\">&#x27;https://10.250.0.239:9200&#x27;</span>, <span class=\"string\">&#x27;https://10.250.0.173:9200&#x27;</span>, <span class=\"string\">&#x27;https://10.250.0.17:9200&#x27;</span>], ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d&#125;]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启Kibana</p>\n</li>\n<li class=\"lvl-2\">\n<p>只要保证集群内至少有两个ES节点工作正常，即可正常访问Kibana</p>\n</li>\n</ul>\n<h2 id=\"nginx反向代理ES集群\">nginx反向代理ES集群</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/nginx/conf.d/es.conf <span class=\"comment\"># 添加如下内容</span></span><br><span class=\"line\">upstream es &#123;</span><br><span class=\"line\">    server 10.250.0.239:9200;</span><br><span class=\"line\">    server 10.250.0.173:9200;</span><br><span class=\"line\">    server 10.250.0.17:9200;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       8888;</span><br><span class=\"line\">        server_name  localhost es.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass https://es; <span class=\"comment\">#这个名称和要上面 upstream es 对应，注意这里是 https 协议</span></span><br><span class=\"line\">            proxy_redirect     default;</span><br><span class=\"line\">            proxy_http_version 1.1;</span><br><span class=\"line\"></span><br><span class=\"line\">            proxy_set_header   Host              <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            proxy_set_header   X-Real-IP         <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            proxy_set_header   X-Forwarded-For   <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            proxy_set_header   X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">            proxy_max_temp_file_size 0;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#this is the maximum upload size</span></span><br><span class=\"line\">            client_max_body_size       10m;</span><br><span class=\"line\">            client_body_buffer_size    128k;</span><br><span class=\"line\"></span><br><span class=\"line\">            proxy_connect_timeout      90;</span><br><span class=\"line\">            proxy_send_timeout         90;</span><br><span class=\"line\">            proxy_read_timeout         90;</span><br><span class=\"line\">            proxy_buffering            off;</span><br><span class=\"line\">            proxy_request_buffering    off; <span class=\"comment\"># Required for HTTP CLI commands</span></span><br><span class=\"line\">            proxy_set_header Connection <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\"># Clear for keepalive</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启nginx</span></span><br><span class=\"line\">systemctl restart nginx</span><br><span class=\"line\"><span class=\"comment\"># 访问ES集群</span></span><br><span class=\"line\">curl -u elastic:123456 http://127.0.0.1:8888/_cluster/health?pretty</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍如何在linux下安装Elasticsearch集群(三节点) Elasticsearch版本8.17.3 单节点安装参考linux下安装Elasticsearch，本文在此基础上完成集群安装 集群安装 三个节点分别安照单节点的安装方式完成下载，用户配置，环境变量配置，系统参数配置，等等。 任选一个节点作为集群的master节点，我们命名为node-1，其它节点命名为node-2和node-3 先配置node-1节点的配置文件 1234567891011121314151617181920212223# 集群名称cluster.name: test-elk# 节点名称node.name: node-1# 数据存储路径，默认值 $ES_HOME/datapath.data: /usr/local/elasticsearch/data# 日志存储路径，默认值 $ES_HOME/logspath.logs: /usr/local/elasticsearch/logs# 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为falsebootstrap.memory_lock: false# 允许通过任何地址访问，开启远程访问network.host: 0.0.0.0# 配置当前ES节点对外提供服务的http端口，默认 9200http.port: 9200# 配置当前ES节点对外提供服务的tcp端口，默认 9300transport.port: 9300# 集群内的主机列表，开启安全认证时无需配置，注意这里不要进行配置# discovery.seed_hosts: [&quot;127.0.0.1&quot;]# 第一次启动时需要参与选主的节点名称，这里只配置node-1cluster.initial_master_nodes: [&quot;node-1&quot;]#解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 配置node-2节点的配置文件 12345678910111213141516171819# 集群名称cluster.name: test-elk# 节点名称node.name: node-2# 数据存储路径，默认值 $ES_HOME/datapath.data: /usr/local/elasticsearch/data# 日志存储路径，默认值 $ES_HOME/logspath.logs: /usr/local/elasticsearch/logs# 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为falsebootstrap.memory_lock: false# 允许通过任何地址访问，开启远程访问network.host: 0.0.0.0# 配置当前ES节点对外提供服务的http端口，默认 9200http.port: 9200# 配置当前ES节点对外提供服务的tcp端口，默认 9300transport.port: 9300#解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 配置node-3节点的配置文件 12345678910111213141516171819# 集群名称cluster.name: test-elk# 节点名称node.name: node-3# 数据存储路径，默认值 $ES_HOME/datapath.data: /usr/local/elasticsearch/data# 日志存储路径，默认值 $ES_HOME/logspath.logs: /usr/local/elasticsearch/logs# 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为falsebootstrap.memory_lock: false# 允许通过任何地址访问，开启远程访问network.host: 0.0.0.0# 配置当前ES节点对外提供服务的http端口，默认 9200http.port: 9200# 配置当前ES节点对外提供服务的tcp端口，默认 9300transport.port: 9300#解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 启动node-1，启动成功后我们会在日志中看到如下安全认证信息信息，记录其中的加入集群的节点的token信息 1234567891011121314151617181920212223242526272829303132━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━# 这些日志信息提供了 Elasticsearch 8 在首次启动时自动配置的安全特性、生成的默认密码、证书指纹以及如何配置 Kibana 和其他节点加入集群的详细说明。✅ Elasticsearch security features have been automatically configured!✅ Authentication is enabled and cluster connections are encrypted.# 这是 elastic 用户的默认密码。系统建议你使用 bin/elasticsearch-reset-password -u elastic 命令来重置此密码。ℹ️ Password for the elastic user (reset with `bin/elasticsearch-reset-password -u elastic`): BNb=*qz6_M*mXL9uZiSP # 这里会打印出ES自动生成的密码# 这是 HTTP CA 证书的 SHA-256 指纹。CA 证书用于验证 HTTPS 连接的身份。ℹ️ HTTP CA certificate SHA-256 fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d# 提供了将 Kibana 配置为使用此 Elasticsearch 集群的步骤。ℹ️ Configure Kibana to use this cluster:# 启动 Kibana 并按照终端中显示的配置链接进行操作。• Run Kibana and click the configuration link in the terminal when Kibana starts.# 复制提供的注册令牌，并在浏览器中打开 Kibana 时粘贴此令牌。令牌在接下来的 30 分钟内有效。# 补充说明：生成新的kibana注册令牌：bin/elasticsearch-create-enrollment-token -s kibana• Copy the following enrollment token and paste it into Kibana in your browser (valid for the next 30 minutes): eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImFSWFBzcFVCTVVmc1d5aUJnbjBtOmRzbVBLQV95UXhDZkJpXzQyWDNEMVEifQ==# 提供了将新的 Elasticsearch 节点加入现有集群的步骤。ℹ️ Configure other nodes to join this cluster:# 使用 bin/elasticsearch --enrollment-token &lt;token&gt; 命令启动新的 Elasticsearch 节点。令牌在接下来的 30 分钟内有效。# 补充说明：生成新的节点注册令牌：bin/elasticsearch-create-enrollment-token -s node• Copy the following enrollment token and start new Elasticsearch nodes with `bin/elasticsearch --enrollment-token &lt;token&gt;` (valid for the next 30 minutes): eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImF4WFBzcFVCTVVmc1d5aUJnbjFtOkFEallPdnpzUzh1MGJqOFpfVFE4a3cifQ==# 如果你在 Docker 中运行 Elasticsearch，可以使用 docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3 命令启动新节点。 If you&#x27;re running in Docker, copy the enrollment token and run: `docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ token信息有效时间只有30分钟，超时后可以使用如下命令重新生成新的token 123# 进入node-1节点的ES安装目录，此命令会生成新的节点注册令牌bin/elasticsearch-create-enrollment-token -s nodeeyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6IlpoRVZ4NVVCeXRPajdLeTBqb3BvOmdHRW44ZW5mU0RDZHA2Yy1uSDF4eGcifQ== 启动node-2节点，启动时要带上token信息，node-3与此一样。这里要注意，只有第一次加入集群时启动才需要带上注册令牌，后续启动不需要token信息 123# 进入node-2节点的ES安装目录，此命令会启动ES节点，并加入到集群中# bin/elasticsearch --enrollment-token &lt;token&gt;bin/elasticsearch --enrollment-token eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6IlpoRVZ4NVVCeXRPajdLeTBqb3BvOmdHRW44ZW5mU0RDZHA2Yy1uSDF4eGcifQ== 加入集群失败 在执行bin/elasticsearch --enrollment-token &lt;token&gt;时有可能会遇到如下异常： 1ERROR: Aborting auto configuration because the node keystore contains password settings already, with exit code 78 这通常意味着节点的 keystore 已经包含了密码设置，因此自动配置过程被中止。 产生这种错误的原因大概率是当前ES是从已经安装好的服务器上拷贝过来的，而不是全新安装的，此时我们除了需要清空data目录外，还需要删除 keystore 中的密码 1234567891011# 查看keystore中的密码$ bin/elasticsearch-keystore listkeystore.seedxpack.security.http.ssl.keystore.secure_passwordxpack.security.transport.ssl.keystore.secure_passwordxpack.security.transport.ssl.truststore.secure_password# 删除keystore中的密码$ bin/elasticsearch-keystore remove xpack.security.http.ssl.keystore.secure_password$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.keystore.secure_password$ bin/elasticsearch-keystore remove xpack.security.transport.ssl.truststore.secure_password 再次执行bin/elasticsearch --enrollment-token &lt;token&gt;即可。 另外还可能遇到如下报错： 1ERROR: Aborting enrolling to cluster. Could not communicate with the node on any of the addresses from the enrollment token. All of [10.250.0.239:9200] were attempted., with exit code 69 这是由于token过期了，重新生成新的token即可 启动成功后会在node-2的配置文件中看到如下配置信息 123456789101112131415161718192021222324252627282930#----------------------- BEGIN SECURITY AUTO CONFIGURATION -----------------------## The following settings, TLS certificates, and keys have been automatically# generated to configure Elasticsearch security features on 24-03-2025 07:45:11## --------------------------------------------------------------------------------# Enable security featuresxpack.security.enabled: truexpack.security.enrollment.enabled: true# Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agentsxpack.security.http.ssl: enabled: true keystore.path: certs/http.p12# Enable encryption and mutual authentication between cluster nodesxpack.security.transport.ssl: enabled: true verification_mode: certificate keystore.path: certs/transport.p12 truststore.path: certs/transport.p12# Discover existing nodes in the clusterdiscovery.seed_hosts: [&quot;10.250.0.239:9300&quot;] # 这里是node-1节点的IP地址和端口号## 而node-3这里会显示如下信息，也就是越是后来加入进来的，这里就会加上之前所有节点的IP地址和端口号discovery.seed_hosts: [&quot;10.250.0.239:9300&quot;, &quot;10.250.0.17:9300&quot;] # 这里是node-1和node-2节点的IP地址和端口号#----------------------- END SECURITY AUTO CONFIGURATION ------------------------- 验证集群状态 启动完成后，可以通过如下命令查看集群状态： 1234567891011121314151617181920212223242526# 查看集群状态$ curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt https://127.0.0.1:9200/_cluster/health?pretty&#123; &quot;cluster_name&quot; : &quot;test-elk&quot;, &quot;status&quot; : &quot;green&quot;, &quot;timed_out&quot; : false, &quot;number_of_nodes&quot; : 3, &quot;number_of_data_nodes&quot; : 3, &quot;active_primary_shards&quot; : 31, &quot;active_shards&quot; : 62, &quot;relocating_shards&quot; : 0, &quot;initializing_shards&quot; : 0, &quot;unassigned_shards&quot; : 0, &quot;unassigned_primary_shards&quot; : 0, &quot;delayed_unassigned_shards&quot; : 0, &quot;number_of_pending_tasks&quot; : 0, &quot;number_of_in_flight_fetch&quot; : 0, &quot;task_max_waiting_in_queue_millis&quot; : 0, &quot;active_shards_percent_as_number&quot; : 100.0&#125;# 查看节点信息，其中 * 表示当前节点为master节点$ curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt https://127.0.0.1:9200/_cat/nodes?vip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name10.250.0.17 8 63 28 1.03 0.38 0.14 cdfhilmrstw - node-210.250.0.173 9 63 22 0.86 0.37 0.19 cdfhilmrstw - node-310.250.0.239 9 78 6 0.38 0.22 0.16 cdfhilmrstw * node-1 重要说明 集群一旦创建完成，则至少需要两个节点运行才能保证集群可用性，否则集群将无法运行。 如果node-1节点挂了，集群中剩下的两个节点会重新选择一个新的master节点，不会影响集群的可用性。 一旦关闭node-1，则重新启动node-1节点前要修改其配置文件，否则无法启动成功。 1234# 注释掉该配置# cluster.initial_master_nodes: [&quot;node-1&quot;]# 加入该配置，实际上最好在重启每个节点前，将每个节点都配置为这样discovery.seed_hosts: [&quot;10.250.0.239:9300&quot;, &quot;10.250.0.17:9300&quot;, &quot;10.250.0.173:9300&quot;] Kibana关联ES集群 Kibana 关联单节点ES参考 linux下安装Kibana，在此基础上对配置文件进行如下修改： 1234# 关联集群的节点地址，将集群内所有节点的地址都配置到该字段中elasticsearch.hosts: [&#x27;https://10.250.0.239:9200&#x27;, &#x27;https://10.250.0.173:9200&#x27;, &#x27;https://10.250.0.17:9200&#x27;]# 关联集群的输出地址，将集群内所有节点的地址都配置到该字段中xpack.fleet.outputs: [&#123;id: fleet-default-output, name: default, is_default: true, is_default_monitoring: true, type: elasticsearch, hosts: [&#x27;https://10.250.0.239:9200&#x27;, &#x27;https://10.250.0.173:9200&#x27;, &#x27;https://10.250.0.17:9200&#x27;], ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d&#125;] 重启Kibana 只要保证集群内至少有两个ES节点工作正常，即可正常访问Kibana nginx反向代理ES集群 123456789101112131415161718192021222324252627282930313233343536373839vim /etc/nginx/conf.d/es.conf # 添加如下内容upstream es &#123; server 10.250.0.239:9200; server 10.250.0.173:9200; server 10.250.0.17:9200;&#125;server &#123; listen 8888; server_name localhost es.domain; location / &#123; proxy_pass https://es; #这个名称和要上面 upstream es 对应，注意这里是 https 协议 proxy_redirect default; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_max_temp_file_size 0; #this is the maximum upload size client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffering off; proxy_request_buffering off; # Required for HTTP CLI commands proxy_set_header Connection &quot;&quot;; # Clear for keepalive &#125;&#125;# 重启nginxsystemctl restart nginx# 访问ES集群curl -u elastic:123456 http://127.0.0.1:8888/_cluster/health?pretty","summary":"摘要 本文介绍如何在linux下安装Elasticsearch集群(三节点) Elasticsearch版本8.17.3 单节点安装参考linux下安装Elasticsearch，本文在此基础上完成集群安装","date_published":"2025-03-24T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]},{"id":"https://blog.hanqunfeng.com/2025/03/21/kibana-01-install/","url":"https://blog.hanqunfeng.com/2025/03/21/kibana-01-install/","title":"linux下安装Kibana","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在linux下安装Kibana</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kibana版本8.17.3</p>\n</li>\n<li class=\"lvl-2\">\n<p>Elasticsearch版本8.17.3，<a href=\"/2025/03/20/elasticsearch-01-install/\" title=\"linux下安装Elasticsearch\">linux下安装Elasticsearch</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"下载\">下载</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载地址：<a href=\"https://www.elastic.co/cn/downloads/past-releases#kibana\">https://www.elastic.co/cn/downloads/past-releases#kibana</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>选择对应的版本：这里选择当前的最新版<code>Kibana 8.17.3</code>，之后选择对应的操作系统<code>LINUX X86_64</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://artifacts.elastic.co/downloads/kibana/kibana-8.17.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载完成后解压到<code>/usr/local/kibana</code>目录下，解压命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/kibana</span><br><span class=\"line\">tar -zxvf kibana-8.17.3-linux-x86_64.tar.gz -C /usr/local/kibana</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建启动用户\">创建启动用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>elasticsearch和kibana都不能用root用户启动</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建用户<code>elastic</code>，并设置密码，这一步我们在安装elasticsearch的时候已经配置过了，这里就不再赘述了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd elastic</span><br><span class=\"line\">passwd elastic</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改kibana安装目录的用户权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> -R elastic:elastic /usr/local/kibana</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>切换到elastic用户下执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su - elastic</span><br></pre></td></tr></table></figure>\n<h2 id=\"关联Kibana和Elasticsearch\">关联Kibana和Elasticsearch</h2>\n<h3 id=\"方法1：注册令牌Token关联-官方推荐\">方法1：注册令牌Token关联[官方推荐]</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注意此方法要求<code>elasticsearch</code>必须开启安全认证，而且<code>xpack.security.http.ssl.enabled</code> 必须设置为 true</p>\n</li>\n<li class=\"lvl-2\">\n<p>配置启动文件，进入<code>/usr/local/kibana/kibana-8.17.3/config</code>目录，根据需要修改<code>kibana.yml</code>文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认5601</span></span><br><span class=\"line\">server.port: 5601</span><br><span class=\"line\"><span class=\"comment\"># kibana服务器的ip，4个0表示任何一个网卡都可以访问，默认为localhost</span></span><br><span class=\"line\">server.host: <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 中文，默认为 en</span></span><br><span class=\"line\">i18n.locale: <span class=\"string\">&quot;zh-CN&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 配置https，默认值为 certificate</span></span><br><span class=\"line\">elasticsearch.ssl.verificationMode: <span class=\"string\">&#x27;certificate&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还记得我们第一次启动ES时日志信息中的有关kibana注册令牌的信息吗？那个令牌只有30分钟有效期，过期后可以进入elasticsearch安装目录，重新创建kibana注册令牌</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/elasticsearch-create-enrollment-token -s kibana</span><br><span class=\"line\"><span class=\"comment\"># 输出结果如下</span></span><br><span class=\"line\">eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImxlTWh1SlVCcVJWQUw4WGFjMk1HOkVHYTYxcWlfVEotQWQ1Y3dQdXcyckEifQ==</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入kibana安装目录，通过下面的命令注册 Kibana</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bin/kibana-setup --enrollment-token &lt;enrollment-token&gt;</span></span><br><span class=\"line\">bin/kibana-setup --enrollment-token eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImxlTWh1SlVCcVJWQUw4WGFjMk1HOkVHYTYxcWlfVEotQWQ1Y3dQdXcyckEifQ==</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注册成功会输出</span></span><br><span class=\"line\">✔ Kibana configured successfully.</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>如果ES的<code>xpack.security.http.ssl.enabled</code> 设置为 false，注册Kibana时会报错，报错信息如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">✖ Unable to connect to Elasticsearch with the provided enrollment token: Unable to connect to any of the provided hosts.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">注册成功后会在<code>/usr/local/kibana/kibana-8.17.3/config/kibana.yml</code>文件中添加如下内容：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This section was automatically generated during setup.</span></span><br><span class=\"line\"><span class=\"comment\"># ES服务URL</span></span><br><span class=\"line\">elasticsearch.hosts: [<span class=\"string\">&#x27;https://10.250.0.239:9200&#x27;</span>] <span class=\"comment\"># 10.250.0.239是本机的内网IP</span></span><br><span class=\"line\"><span class=\"comment\"># 指定用于认证的服务账户令牌</span></span><br><span class=\"line\">elasticsearch.serviceAccountToken: AAEAAWVsYXN0aWMva2liYW5hL2Vucm9sbC1wcm9jZXNzLXRva2VuLTE3NDI1NTA5ODU0MTg6Z2lJUERGaG1TR3VNcC1sb0RyMnMydw</span><br><span class=\"line\"><span class=\"comment\"># 指定用来验证 Elasticsearch 服务器 SSL 证书的 CA 证书路径</span></span><br><span class=\"line\">elasticsearch.ssl.certificateAuthorities: [/usr/local/kibana/kibana-8.17.3/data/ca_1742550986498.crt]</span><br><span class=\"line\"><span class=\"comment\"># 配置 Fleet 的输出目标。Fleet 是 Elastic 的一个管理工具，用于管理和监控弹性栈（Elastic Stack）。这个配置定义了 Fleet 默认输出的目标，即 Elasticsearch。</span></span><br><span class=\"line\">xpack.fleet.outputs: [&#123;<span class=\"built_in\">id</span>: fleet-default-output, name: default, is_default: <span class=\"literal\">true</span>, is_default_monitoring: <span class=\"literal\">true</span>, <span class=\"built_in\">type</span>: elasticsearch, hosts: [<span class=\"string\">&#x27;https://10.250.0.239:9200&#x27;</span>], ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d&#125;]</span><br><span class=\"line\">  <span class=\"comment\"># id: fleet-default-output：输出的唯一标识符。</span></span><br><span class=\"line\">  <span class=\"comment\"># name: default：输出的名称。</span></span><br><span class=\"line\">  <span class=\"comment\"># is_default: true：表示这是默认输出。</span></span><br><span class=\"line\">  <span class=\"comment\"># is_default_monitoring: true：表示这是默认的监控输出。</span></span><br><span class=\"line\">  <span class=\"comment\"># type: elasticsearch：输出类型是 Elasticsearch。</span></span><br><span class=\"line\">  <span class=\"comment\"># hosts: [&#x27;https://10.250.0.239:9200&#x27;]：连接到的 Elasticsearch 主机地址。</span></span><br><span class=\"line\">  <span class=\"comment\"># ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d：CA 证书的信任指纹，用于验证 CA 证书的身份。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法2：用户名密码关联\">方法2：用户名密码关联</h3>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>创建kibana连接elasticsearch的用户密码，不能用 <code>elastic</code> 这个用户，因为这个是超级用户，要使用 kibana_system 用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入elasticsearch安装目录，执行下面的命令重置 kibana_system 用户的密码</span></span><br><span class=\"line\">bin/elasticsearch-reset-password -u kibana_system -i</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>配置启动文件，进入<code>/usr/local/kibana/kibana-8.17.3/config</code>目录，修改<code>kibana.yml</code>文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认5601</span></span><br><span class=\"line\">server.port: 5601</span><br><span class=\"line\"><span class=\"comment\"># kibana服务器的ip，4个0表示任何一个网卡都可以访问</span></span><br><span class=\"line\">server.host: <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># elasctisearch关联</span></span><br><span class=\"line\"><span class=\"comment\"># ES服务地址，注意这里是https</span></span><br><span class=\"line\">elasticsearch.hosts: [<span class=\"string\">&quot;https://10.250.0.239:9200&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 指定https证书路径，可以从ES的证书目录中获取</span></span><br><span class=\"line\">elasticsearch.ssl.certificateAuthorities: [<span class=\"string\">&quot;/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 用户名密码</span></span><br><span class=\"line\">elasticsearch.username: <span class=\"string\">&quot;kibana_system&quot;</span></span><br><span class=\"line\">elasticsearch.password: <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 中文</span></span><br><span class=\"line\">i18n.locale: <span class=\"string\">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>如果ES没有开启安全认证，则只需要进行如下配置即可：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认5601</span></span><br><span class=\"line\">server.port: 5601</span><br><span class=\"line\"><span class=\"comment\"># kibana服务器的ip，4个0表示任何一个网卡都可以访问</span></span><br><span class=\"line\">server.host: <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># ES服务地址，注意这里是http</span></span><br><span class=\"line\">elasticsearch.hosts: [<span class=\"string\">&quot;http://10.250.0.239:9200&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 中文</span></span><br><span class=\"line\">i18n.locale: <span class=\"string\">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"启动Kibana服务\">启动Kibana服务</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入<code>/usr/local/kibana/kibana-8.17.3</code>目录，执行以下命令启动服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/kibana</span><br><span class=\"line\"><span class=\"comment\"># 后台启动，并将日志写入到logs/kibana.log</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> bin/kibana &gt; logs/kibana.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问地址：<a href=\"http://localhost:5601\">http://localhost:5601</a>，这里注意登录用户需要使用：<code>elastic</code>，而不是<code>kibana_system</code>。</p>\n</li>\n</ul>\n<h2 id=\"启动Kibana服务后的日志告警\">启动Kibana服务后的日志告警</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kibana服务启动后，会在<code>/usr/local/kibana/kibana-8.17.3/logs/kibana.log</code>文件中记录一些错误日志，如果出现错误，可以查看日志，解决错误。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[WARN ][plugins.fleet] xpack.encryptedSavedObjects.encryptionKey is not configured, private key passphrase is being stored <span class=\"keyword\">in</span> plain text</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这个警告信息表明 Kibana 的某些插件（如 Fleet）在缺少 <code>xpack.encryptedSavedObjects.encryptionKey</code> 配置的情况下运行，导致私钥密码和代理卸载令牌以明文形式存储。为了提高安全性，建议配置一个加密密钥。</p>\n</li>\n<li class=\"lvl-2\">\n<p>生成加密密钥</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bin/kibana-encryption-keys generate</span><br><span class=\"line\">Kibana is currently running with legacy OpenSSL providers enabled! For details and instructions on how to <span class=\"built_in\">disable</span> see https://www.elastic.co/guide/en/kibana/8.17/production.html#openssl-legacy-provider</span><br><span class=\"line\"><span class=\"comment\">## Kibana Encryption Key Generation Utility</span></span><br><span class=\"line\"></span><br><span class=\"line\">The <span class=\"string\">&#x27;generate&#x27;</span> <span class=\"built_in\">command</span> guides you through the process of setting encryption keys <span class=\"keyword\">for</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">xpack.encryptedSavedObjects.encryptionKey</span><br><span class=\"line\">    Used to encrypt stored objects such as dashboards and visualizations</span><br><span class=\"line\">    https://www.elastic.co/guide/en/kibana/current/xpack-security-secure-saved-objects.html#xpack-security-secure-saved-objects</span><br><span class=\"line\"></span><br><span class=\"line\">xpack.reporting.encryptionKey</span><br><span class=\"line\">    Used to encrypt saved reports</span><br><span class=\"line\">    https://www.elastic.co/guide/en/kibana/current/reporting-settings-kb.html#general-reporting-settings</span><br><span class=\"line\"></span><br><span class=\"line\">xpack.security.encryptionKey</span><br><span class=\"line\">    Used to encrypt session information</span><br><span class=\"line\">    https://www.elastic.co/guide/en/kibana/current/security-settings-kb.html#security-session-and-cookie-settings</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Already defined settings are ignored and can be regenerated using the --force flag.  Check the documentation links <span class=\"keyword\">for</span> instructions on how to rotate encryption keys.</span><br><span class=\"line\">Definitions should be <span class=\"built_in\">set</span> <span class=\"keyword\">in</span> the kibana.yml used configure Kibana.</span><br><span class=\"line\"></span><br><span class=\"line\">Settings:</span><br><span class=\"line\">xpack.encryptedSavedObjects.encryptionKey: 47967e4b78bd26decb622b78f0ddd324</span><br><span class=\"line\">xpack.reporting.encryptionKey: 78b5f603f3b0e6ad76c13a0f5d00cde0</span><br><span class=\"line\">xpack.security.encryptionKey: 8aa7f4dfbc4e734a2a9f92a2730b36af</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置 Kibana 以使用加密密钥，添加到 kibana.yml 文件中：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xpack.encryptedSavedObjects.encryptionKey: 47967e4b78bd26decb622b78f0ddd324</span><br><span class=\"line\">xpack.reporting.encryptionKey: 78b5f603f3b0e6ad76c13a0f5d00cde0</span><br><span class=\"line\">xpack.security.encryptionKey: 8aa7f4dfbc4e734a2a9f92a2730b36af</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启 Kibana 服务 以应用更改。</p>\n</li>\n</ul>\n<h2 id=\"Kibana-自启动脚本\">Kibana 自启动脚本</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建服务文件</span></span><br><span class=\"line\">$ vim /usr/lib/systemd/system/kibana.service</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=kibana</span><br><span class=\"line\">Documentation=https://www.elastic.co</span><br><span class=\"line\">After=es.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">PrivateTmp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 指定ES用户</span></span><br><span class=\"line\">User=elastic</span><br><span class=\"line\">Group=elastic</span><br><span class=\"line\">LimitNOFILE=100000</span><br><span class=\"line\">LimitNPROC=100000</span><br><span class=\"line\">Restart=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 启动命令</span></span><br><span class=\"line\">ExecStart=/usr/local/kibana/kibana-8.17.3/bin/kibana</span><br><span class=\"line\">ExecRestart=/bin/kill -s HUP <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\">ExecStop=/bin/kill -s QUIT <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新加载</span></span><br><span class=\"line\">$ systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">$ systemctl start kibana</span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">$ systemctl stop kibana</span><br><span class=\"line\"><span class=\"comment\"># 查看状态</span></span><br><span class=\"line\">$ systemctl status kibana</span><br><span class=\"line\"><span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">$ systemctl <span class=\"built_in\">enable</span> kibana</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍如何在linux下安装Kibana Kibana版本8.17.3 Elasticsearch版本8.17.3，linux下安装Elasticsearch 下载 下载地址：https://www.elastic.co/cn/downloads/past-releases#kibana 选择对应的版本：这里选择当前的最新版Kibana 8.17.3，之后选择对应的操作系统LINUX X86_64 1wget https://artifacts.elastic.co/downloads/kibana/kibana-8.17.3-linux-x86_64.tar.gz 下载完成后解压到/usr/local/kibana目录下，解压命令如下： 12mkdir /usr/local/kibanatar -zxvf kibana-8.17.3-linux-x86_64.tar.gz -C /usr/local/kibana 创建启动用户 elasticsearch和kibana都不能用root用户启动 创建用户elastic，并设置密码，这一步我们在安装elasticsearch的时候已经配置过了，这里就不再赘述了 12useradd elasticpasswd elastic 修改kibana安装目录的用户权限 1chown -R elastic:elastic /usr/local/kibana 切换到elastic用户下执行命令 1su - elastic 关联Kibana和Elasticsearch 方法1：注册令牌Token关联[官方推荐] 注意此方法要求elasticsearch必须开启安全认证，而且xpack.security.http.ssl.enabled 必须设置为 true 配置启动文件，进入/usr/local/kibana/kibana-8.17.3/config目录，根据需要修改kibana.yml文件 12345678# 端口，默认5601server.port: 5601# kibana服务器的ip，4个0表示任何一个网卡都可以访问，默认为localhostserver.host: &quot;0.0.0.0&quot;# 中文，默认为 eni18n.locale: &quot;zh-CN&quot;# 配置https，默认值为 certificateelasticsearch.ssl.verificationMode: &#x27;certificate&#x27; 还记得我们第一次启动ES时日志信息中的有关kibana注册令牌的信息吗？那个令牌只有30分钟有效期，过期后可以进入elasticsearch安装目录，重新创建kibana注册令牌 123bin/elasticsearch-create-enrollment-token -s kibana# 输出结果如下eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImxlTWh1SlVCcVJWQUw4WGFjMk1HOkVHYTYxcWlfVEotQWQ1Y3dQdXcyckEifQ== 进入kibana安装目录，通过下面的命令注册 Kibana 12345# bin/kibana-setup --enrollment-token &lt;enrollment-token&gt;bin/kibana-setup --enrollment-token eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImxlTWh1SlVCcVJWQUw4WGFjMk1HOkVHYTYxcWlfVEotQWQ1Y3dQdXcyckEifQ==# 注册成功会输出✔ Kibana configured successfully. 如果ES的xpack.security.http.ssl.enabled 设置为 false，注册Kibana时会报错，报错信息如下： 1✖ Unable to connect to Elasticsearch with the provided enrollment token: Unable to connect to any of the provided hosts. 注册成功后会在/usr/local/kibana/kibana-8.17.3/config/kibana.yml文件中添加如下内容： 12345678910111213141516# This section was automatically generated during setup.# ES服务URLelasticsearch.hosts: [&#x27;https://10.250.0.239:9200&#x27;] # 10.250.0.239是本机的内网IP# 指定用于认证的服务账户令牌elasticsearch.serviceAccountToken: AAEAAWVsYXN0aWMva2liYW5hL2Vucm9sbC1wcm9jZXNzLXRva2VuLTE3NDI1NTA5ODU0MTg6Z2lJUERGaG1TR3VNcC1sb0RyMnMydw# 指定用来验证 Elasticsearch 服务器 SSL 证书的 CA 证书路径elasticsearch.ssl.certificateAuthorities: [/usr/local/kibana/kibana-8.17.3/data/ca_1742550986498.crt]# 配置 Fleet 的输出目标。Fleet 是 Elastic 的一个管理工具，用于管理和监控弹性栈（Elastic Stack）。这个配置定义了 Fleet 默认输出的目标，即 Elasticsearch。xpack.fleet.outputs: [&#123;id: fleet-default-output, name: default, is_default: true, is_default_monitoring: true, type: elasticsearch, hosts: [&#x27;https://10.250.0.239:9200&#x27;], ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d&#125;] # id: fleet-default-output：输出的唯一标识符。 # name: default：输出的名称。 # is_default: true：表示这是默认输出。 # is_default_monitoring: true：表示这是默认的监控输出。 # type: elasticsearch：输出类型是 Elasticsearch。 # hosts: [&#x27;https://10.250.0.239:9200&#x27;]：连接到的 Elasticsearch 主机地址。 # ca_trusted_fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d：CA 证书的信任指纹，用于验证 CA 证书的身份。 方法2：用户名密码关联 创建kibana连接elasticsearch的用户密码，不能用 elastic 这个用户，因为这个是超级用户，要使用 kibana_system 用户 12# 进入elasticsearch安装目录，执行下面的命令重置 kibana_system 用户的密码bin/elasticsearch-reset-password -u kibana_system -i 配置启动文件，进入/usr/local/kibana/kibana-8.17.3/config目录，修改kibana.yml文件 123456789101112131415# 端口，默认5601server.port: 5601# kibana服务器的ip，4个0表示任何一个网卡都可以访问server.host: &quot;0.0.0.0&quot;# elasctisearch关联# ES服务地址，注意这里是httpselasticsearch.hosts: [&quot;https://10.250.0.239:9200&quot;]# 指定https证书路径，可以从ES的证书目录中获取elasticsearch.ssl.certificateAuthorities: [&quot;/usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt&quot;]# 用户名密码elasticsearch.username: &quot;kibana_system&quot;elasticsearch.password: &quot;123456&quot;# 中文i18n.locale: &quot;zh-CN&quot; 如果ES没有开启安全认证，则只需要进行如下配置即可： 12345678# 端口，默认5601server.port: 5601# kibana服务器的ip，4个0表示任何一个网卡都可以访问server.host: &quot;0.0.0.0&quot;# ES服务地址，注意这里是httpelasticsearch.hosts: [&quot;http://10.250.0.239:9200&quot;]# 中文i18n.locale: &quot;zh-CN&quot; 启动Kibana服务 进入/usr/local/kibana/kibana-8.17.3目录，执行以下命令启动服务 123./bin/kibana# 后台启动，并将日志写入到logs/kibana.lognohup bin/kibana &gt; logs/kibana.log 2&gt;&amp;1 &amp; 访问地址：http://localhost:5601，这里注意登录用户需要使用：elastic，而不是kibana_system。 启动Kibana服务后的日志告警 Kibana服务启动后，会在/usr/local/kibana/kibana-8.17.3/logs/kibana.log文件中记录一些错误日志，如果出现错误，可以查看日志，解决错误。 1[WARN ][plugins.fleet] xpack.encryptedSavedObjects.encryptionKey is not configured, private key passphrase is being stored in plain text 这个警告信息表明 Kibana 的某些插件（如 Fleet）在缺少 xpack.encryptedSavedObjects.encryptionKey 配置的情况下运行，导致私钥密码和代理卸载令牌以明文形式存储。为了提高安全性，建议配置一个加密密钥。 生成加密密钥 1234567891011121314151617181920212223242526$ bin/kibana-encryption-keys generateKibana is currently running with legacy OpenSSL providers enabled! For details and instructions on how to disable see https://www.elastic.co/guide/en/kibana/8.17/production.html#openssl-legacy-provider## Kibana Encryption Key Generation UtilityThe &#x27;generate&#x27; command guides you through the process of setting encryption keys for:xpack.encryptedSavedObjects.encryptionKey Used to encrypt stored objects such as dashboards and visualizations https://www.elastic.co/guide/en/kibana/current/xpack-security-secure-saved-objects.html#xpack-security-secure-saved-objectsxpack.reporting.encryptionKey Used to encrypt saved reports https://www.elastic.co/guide/en/kibana/current/reporting-settings-kb.html#general-reporting-settingsxpack.security.encryptionKey Used to encrypt session information https://www.elastic.co/guide/en/kibana/current/security-settings-kb.html#security-session-and-cookie-settingsAlready defined settings are ignored and can be regenerated using the --force flag. Check the documentation links for instructions on how to rotate encryption keys.Definitions should be set in the kibana.yml used configure Kibana.Settings:xpack.encryptedSavedObjects.encryptionKey: 47967e4b78bd26decb622b78f0ddd324xpack.reporting.encryptionKey: 78b5f603f3b0e6ad76c13a0f5d00cde0xpack.security.encryptionKey: 8aa7f4dfbc4e734a2a9f92a2730b36af 配置 Kibana 以使用加密密钥，添加到 kibana.yml 文件中： 123xpack.encryptedSavedObjects.encryptionKey: 47967e4b78bd26decb622b78f0ddd324xpack.reporting.encryptionKey: 78b5f603f3b0e6ad76c13a0f5d00cde0xpack.security.encryptionKey: 8aa7f4dfbc4e734a2a9f92a2730b36af 重启 Kibana 服务 以应用更改。 Kibana 自启动脚本 1234567891011121314151617181920212223242526272829303132333435# 创建服务文件$ vim /usr/lib/systemd/system/kibana.service[Unit]Description=kibanaDocumentation=https://www.elastic.coAfter=es.service[Service]Type=simplePrivateTmp=true# 指定ES用户User=elasticGroup=elasticLimitNOFILE=100000LimitNPROC=100000Restart=yes# 启动命令ExecStart=/usr/local/kibana/kibana-8.17.3/bin/kibanaExecRestart=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPID[Install]WantedBy=multi-user.target# 重新加载$ systemctl daemon-reload# 启动$ systemctl start kibana# 停止$ systemctl stop kibana# 查看状态$ systemctl status kibana# 设置开机启动$ systemctl enable kibana","summary":"摘要 本文介绍如何在linux下安装Kibana Kibana版本8.17.3 Elasticsearch版本8.17.3，linux下安装Elasticsearch","date_published":"2025-03-21T13:30:05.000Z","tags":["技术","elastic","kibana","elasticsearch","kibana"]},{"id":"https://blog.hanqunfeng.com/2025/03/20/elasticsearch-01-install/","url":"https://blog.hanqunfeng.com/2025/03/20/elasticsearch-01-install/","title":"linux下安装Elasticsearch","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何在linux下安装Elasticsearch</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/8.17/index.html\">Elasticsearch</a>版本8.17.3</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"下载\">下载</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载地址：<a href=\"https://www.elastic.co/cn/downloads/past-releases#elasticsearch\">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>选择对应的版本：这里选择当前的最新版<code>Elasticsearch 8.17.3</code>，之后选择对应的操作系统<code>LINUX X86_64</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-8.17.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下载完成后解压到<code>/usr/local/elasticsearch</code>目录下，解压命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/elasticsearch</span><br><span class=\"line\">tar -zxvf elasticsearch-8.17.3-linux-x86_64.tar.gz -C /usr/local/elasticsearch</span><br></pre></td></tr></table></figure>\n<h2 id=\"ElasticSearch目录结构\">ElasticSearch目录结构</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin        <span class=\"comment\"># 脚本文件，包括启动elasticsearch，安装插件，运行统计数据等</span></span><br><span class=\"line\">config     <span class=\"comment\"># 配置文件目录，如elasticsearch配置、角色配置、jvm配置、证书等。</span></span><br><span class=\"line\">data       <span class=\"comment\"># 数据目录，默认值 $ES_HOME/data，包含节点、分片、索引、文档的所有数据，生产环境建议修改</span></span><br><span class=\"line\">jdk        <span class=\"comment\"># JDK目录，用于运行Elasticsearch，7.x以后自带</span></span><br><span class=\"line\">lib        <span class=\"comment\"># Elasticsearch依赖的JAR包</span></span><br><span class=\"line\">logs       <span class=\"comment\"># 日志目录，默认值 $ES_HOME/logs，生产环境建议修改</span></span><br><span class=\"line\">modules    <span class=\"comment\"># 包含所有的Elasticsearch模块，如Cluster、Discovery、Indices等</span></span><br><span class=\"line\">plugins    <span class=\"comment\"># 已安装插件目录</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建启动用户\">创建启动用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>elasticsearch和kibana都不能用root用户启动</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建用户<code>elastic</code>，并设置密码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd elastic</span><br><span class=\"line\">passwd elastic</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改elasticsearch安装目录的用户权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> -R elastic:elastic /usr/local/elasticsearch</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置环境变量\">配置环境变量</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入elastic用户主目录，/home/elastic目录下，设置用户级别的环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到elastic用户</span></span><br><span class=\"line\">su - elastic</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>vim .bash_profile</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Elasticsearch安装目录，它用于定位Elasticsearch的配置文件、插件和其他相关资源。</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> ES_HOME=/usr/local/elasticsearch/elasticsearch-8.17.3</span><br><span class=\"line\"><span class=\"comment\"># Elasticsearch使用的JDK安装目录，在启动Elasticsearch时，它会检查ES_JAVA_HOME环境变量并使用其中的Java路径。</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> ES_JAVA_HOME=/usr/local/elasticsearch/elasticsearch-8.17.3/jdk/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>执行以下命令使配置生效</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> .bash_profile</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置JVM参数（可选）\">配置JVM参数（可选）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ES比较耗内存，建议虚拟机4G或以上内存，jvm1g以上的内存分配</p>\n</li>\n<li class=\"lvl-2\">\n<p>进入<code>/usr/local/elasticsearch/elasticsearch-8.17.3/config</code>目录，修改<code>jvm.options</code>文件，调整jvm堆内存大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4g <span class=\"comment\"># 设置最小堆内存，默认4g，不能小于1g</span></span><br><span class=\"line\">-Xmx4g <span class=\"comment\"># 设置最大堆内存，默认4g，Xmx不要超过机器内存的50%，不要超过30g</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建数据和日志存储目录\">创建数据和日志存储目录</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到elastic用户</span></span><br><span class=\"line\">su - elastic</span><br><span class=\"line\"><span class=\"comment\"># 创建目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/elasticsearch/data /usr/local/elasticsearch/log</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置启动文件\">配置启动文件</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果是本地开发环境，也可以不做任何修改直接启动，因为大部分配置项都有默认值，但为了更好的控制ES，推荐按如下方式进行配置</p>\n</li>\n<li class=\"lvl-2\">\n<p>进入<code>/usr/local/elasticsearch/elasticsearch-8.17.3/config</code>目录，修改<code>elasticsearch.yml</code>文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群名称，多个节点如果要组成同一个集群，那么集群名称一定要配置成相同，默认值elasticsearch</span></span><br><span class=\"line\">cluster.name: test-elk</span><br><span class=\"line\"><span class=\"comment\"># 节点名称，默认值当前节点部署所在机器的主机名</span></span><br><span class=\"line\">node.name: node-1</span><br><span class=\"line\"><span class=\"comment\"># 数据存储路径，默认值 $ES_HOME/data</span></span><br><span class=\"line\">path.data: /usr/local/elasticsearch/data</span><br><span class=\"line\"><span class=\"comment\"># 日志存储路径，默认值 $ES_HOME/logs</span></span><br><span class=\"line\">path.logs: /usr/local/elasticsearch/logs</span><br><span class=\"line\"><span class=\"comment\"># 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为false</span></span><br><span class=\"line\">bootstrap.memory_lock: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 允许通过任何地址访问，开启远程访问</span></span><br><span class=\"line\">network.host: 0.0.0.0</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的http端口，默认 9200</span></span><br><span class=\"line\">http.port: 9200</span><br><span class=\"line\"><span class=\"comment\"># 配置当前ES节点对外提供服务的tcp端口，默认 9300</span></span><br><span class=\"line\">transport.port: 9300</span><br><span class=\"line\"><span class=\"comment\"># 集群内的主机列表，单节点启动时可以不配置</span></span><br><span class=\"line\"><span class=\"comment\"># discovery.seed_hosts: [&quot;127.0.0.1&quot;]</span></span><br><span class=\"line\"><span class=\"comment\"># 第一次启动时需要参与选主的节点名称</span></span><br><span class=\"line\">cluster.initial_master_nodes: [<span class=\"string\">&quot;node-1&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#解决跨域问题</span></span><br><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"启动ElasticSearch服务\">启动ElasticSearch服务</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入<code>/usr/local/elasticsearch/elasticsearch-8.17.3</code>目录，执行以下命令启动服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/elasticsearch</span><br><span class=\"line\"><span class=\"comment\"># 后台启动</span></span><br><span class=\"line\">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES启动前的引导检查\">ES启动前的引导检查</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ES启动时，默认会进行引导检查，所谓引导检查就是在服务启动之前对一些重要的配置项进行检查，检查其配置值是否是合理的。引导检查包括对JVM大小、内存锁、虚拟内存、最大线程数、集群发现相关配置等相关的检查，如果某一项或者几项的配置不合理，ES会拒绝启动服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果启动服务时，报以下错误，则需要解决引导检查中的问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>1.max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144];</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">原因：最大虚拟内存太小,调大系统的虚拟内存</li>\n<li class=\"lvl-6\">解决办法：</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># root用户下运行</span></span><br><span class=\"line\">vim /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"comment\"># 追加以下内容：</span></span><br><span class=\"line\">vm.max_map_count=262144</span><br><span class=\"line\"><span class=\"comment\"># 保存退出之后执行如下命令：</span></span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>2.max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">原因：文件描述符太小，调大系统的文件描述符</li>\n<li class=\"lvl-6\">解决办法：</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># root用户下运行</span></span><br><span class=\"line\">vim /etc/security/limits.conf</span><br><span class=\"line\"><span class=\"comment\"># 末尾添加如下配置：</span></span><br><span class=\"line\">* soft nofile 65536</span><br><span class=\"line\">* hard nofile 65536</span><br><span class=\"line\">* soft <span class=\"built_in\">nproc</span> 4096</span><br><span class=\"line\">* hard <span class=\"built_in\">nproc</span> 4096</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是单节点的开发环境，则可以关闭引导检查，生成环境不建议这样做，因为关闭引导检查后，ES服务将无法保证集群的高可用性。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入elasticsearch安装目录</span></span><br><span class=\"line\">vim config/elasticsearch.yml</span><br><span class=\"line\"><span class=\"comment\"># 添加如下配置：</span></span><br><span class=\"line\"><span class=\"comment\"># 指定节点为单节点，可以绕过引导检查</span></span><br><span class=\"line\">discovery.type: single-node</span><br></pre></td></tr></table></figure>\n<h2 id=\"服务正常启动后仍然不能正常访问\">服务正常启动后仍然不能正常访问</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://127.0.0.1:9200</span><br><span class=\"line\">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看日志<code>/usr/local/elasticsearch/elasticsearch-8.17.3/logs/test-elk.log</code>，发现报如下警告：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[WARN ][o.e.h.n.Netty4HttpServerTransport] [node-1] received plaintext http traffic on an https channel, closing connection Netty4HttpChannel&#123;localAddress=/127.0.0.1:9200, remoteAddress=/127.0.0.1:38426&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>原因是ES在启动服务时默认开启了 <code>X-Pack 安全功能</code>，查看配置文件<code>/usr/local/elasticsearch/elasticsearch-8.17.3/config/elasticsearch.yml</code>，发现配置项<code>xpack.security.xxx</code>相关配置项被自动添加了，如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#----------------------- BEGIN SECURITY AUTO CONFIGURATION -----------------------</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The following settings, TLS certificates, and keys have been automatically</span></span><br><span class=\"line\"><span class=\"comment\"># generated to configure Elasticsearch security features on 20-03-2025 08:53:20</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># --------------------------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable security features</span></span><br><span class=\"line\"><span class=\"comment\"># 启用 Elasticsearch 的安全特性，包括用户认证、角色管理、加密等。</span></span><br><span class=\"line\"><span class=\"comment\"># 开启了 X-Pack 安全功能，这意味着你需要进行用户认证才能访问 Elasticsearch。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果需要关闭 X-Pack 安全功能，你可以将 xpack.security.enabled 设置为 false。</span></span><br><span class=\"line\">xpack.security.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 启用安全注册功能，允许通过交互式向导来配置安全设置。</span></span><br><span class=\"line\"><span class=\"comment\"># 这使得你可以通过 Kibana 或命令行工具来自动配置 SSL 证书和其他安全设置。</span></span><br><span class=\"line\">xpack.security.enrollment.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents</span></span><br><span class=\"line\"><span class=\"comment\"># 启用 HTTP API 客户端连接的加密</span></span><br><span class=\"line\"><span class=\"comment\"># Kibana、Logstash 和其他通过 HTTP API 连接到 Elasticsearch 的客户端将使用 HTTPS 进行通信，增强安全性。</span></span><br><span class=\"line\">xpack.security.http.ssl:</span><br><span class=\"line\">  enabled: <span class=\"literal\">true</span> <span class=\"comment\"># 启用 HTTP 层的 SSL 加密，即https访问，确保客户端与 Elasticsearch 之间的通信是加密的。设置为false时，关闭加密，即http访问</span></span><br><span class=\"line\">  keystore.path: certs/http.p12 <span class=\"comment\"># 指定用于 HTTP 层加密的密钥库文件路径。这是一个 PKCS12 文件，包含用于加密和验证的公钥和私钥。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable encryption and mutual authentication between cluster nodes</span></span><br><span class=\"line\"><span class=\"comment\"># 启用节点间的加密和双向认证</span></span><br><span class=\"line\"><span class=\"comment\"># Elasticsearch 集群中的节点之间的通信将使用 SSL 加密，并且每个节点都会验证其他节点的身份，从而增强集群的安全性。</span></span><br><span class=\"line\"><span class=\"comment\"># 所有节点要配置相同的证书</span></span><br><span class=\"line\">xpack.security.transport.ssl:</span><br><span class=\"line\">  enabled: <span class=\"literal\">true</span> <span class=\"comment\"># 启用传输层的 SSL 加密，确保节点之间的内部通信是加密的。</span></span><br><span class=\"line\">  verification_mode: certificate <span class=\"comment\"># 设置验证模式为 certificate，这意味着节点之间需要双向认证（即每个节点都需要验证对方的身份）。</span></span><br><span class=\"line\">  keystore.path: certs/transport.p12 <span class=\"comment\"># 指定用于传输层加密的密钥库文件路径。这是另一个 PKCS12 文件，包含用于加密和验证的公钥和私钥。</span></span><br><span class=\"line\">  truststore.path: certs/transport.p12 <span class=\"comment\"># 指定用于存储信任证书的信任库文件路径。这通常与密钥库相同，但可以不同。</span></span><br><span class=\"line\"><span class=\"comment\">#----------------------- END SECURITY AUTO CONFIGURATION -------------------------</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1.不想开启安全认证，将 <code>xpack.security.enabled</code> 设置为 false，这样即便下面的配置都设置为true也不会有效。</li>\n<li class=\"lvl-6\">2.不想https访问，将 <code>xpack.security.http.ssl.enabled</code> 设置为 false，但这样会导致无法通过认证Token添加其它节点或Kibana。</li>\n<li class=\"lvl-6\">3.不想节点间通信加密，将 <code>xpack.security.transport.ssl.enabled</code> 设置为 false</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>为了保证ES的安全，我这里就开启安全认证，并且通过https访问ES，但此时我们访问ES的API就需要带上认证用户，那么用户名和密码是什么呢？</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上在ES第一次正常启动时其日志中就打印了自动配置的安全相关的信息提示，里面就给出了登录用户和初始的密码，如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><br><span class=\"line\"><span class=\"comment\"># 这些日志信息提供了 Elasticsearch 8 在首次启动时自动配置的安全特性、生成的默认密码、证书指纹以及如何配置 Kibana 和其他节点加入集群的详细说明。</span></span><br><span class=\"line\">✅ Elasticsearch security features have been automatically configured!</span><br><span class=\"line\">✅ Authentication is enabled and cluster connections are encrypted.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是 elastic 用户的默认密码。系统建议你使用 bin/elasticsearch-reset-password -u elastic 命令来重置此密码。</span></span><br><span class=\"line\">ℹ️  Password <span class=\"keyword\">for</span> the elastic user (reset with `bin/elasticsearch-reset-password -u elastic`):</span><br><span class=\"line\">  BNb=*qz6_M*mXL9uZiSP <span class=\"comment\"># 这里会打印出ES自动生成的密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是 HTTP CA 证书的 SHA-256 指纹。CA 证书用于验证 HTTPS 连接的身份。</span></span><br><span class=\"line\">ℹ️  HTTP CA certificate SHA-256 fingerprint:</span><br><span class=\"line\">  3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提供了将 Kibana 配置为使用此 Elasticsearch 集群的步骤。</span></span><br><span class=\"line\">ℹ️  Configure Kibana to use this cluster:</span><br><span class=\"line\"><span class=\"comment\"># 启动 Kibana 并按照终端中显示的配置链接进行操作。</span></span><br><span class=\"line\">• Run Kibana and click the configuration <span class=\"built_in\">link</span> <span class=\"keyword\">in</span> the terminal when Kibana starts.</span><br><span class=\"line\"><span class=\"comment\"># 复制提供的注册令牌，并在浏览器中打开 Kibana 时粘贴此令牌。令牌在接下来的 30 分钟内有效。</span></span><br><span class=\"line\"><span class=\"comment\"># 补充说明：生成新的kibana注册令牌：bin/elasticsearch-create-enrollment-token -s kibana</span></span><br><span class=\"line\">• Copy the following enrollment token and <span class=\"built_in\">paste</span> it into Kibana <span class=\"keyword\">in</span> your browser (valid <span class=\"keyword\">for</span> the next 30 minutes):</span><br><span class=\"line\">  eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImFSWFBzcFVCTVVmc1d5aUJnbjBtOmRzbVBLQV95UXhDZkJpXzQyWDNEMVEifQ==</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提供了将新的 Elasticsearch 节点加入现有集群的步骤。</span></span><br><span class=\"line\">ℹ️ Configure other nodes to <span class=\"built_in\">join</span> this cluster:</span><br><span class=\"line\"><span class=\"comment\"># 使用 bin/elasticsearch --enrollment-token &lt;token&gt; 命令启动新的 Elasticsearch 节点。令牌在接下来的 30 分钟内有效。</span></span><br><span class=\"line\"><span class=\"comment\"># 补充说明：生成新的节点注册令牌：bin/elasticsearch-create-enrollment-token -s node</span></span><br><span class=\"line\">• Copy the following enrollment token and start new Elasticsearch nodes with `bin/elasticsearch --enrollment-token &lt;token&gt;` (valid <span class=\"keyword\">for</span> the next 30 minutes):</span><br><span class=\"line\">  eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImF4WFBzcFVCTVVmc1d5aUJnbjFtOkFEallPdnpzUzh1MGJqOFpfVFE4a3cifQ==</span><br><span class=\"line\"><span class=\"comment\"># 如果你在 Docker 中运行 Elasticsearch，可以使用 docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3 命令启动新节点。</span></span><br><span class=\"line\">  If you<span class=\"string\">&#x27;re running in Docker, copy the enrollment token and run:</span></span><br><span class=\"line\"><span class=\"string\">  `docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3`</span></span><br><span class=\"line\"><span class=\"string\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录用户为<code>elastic</code>[其角色为超级用户]，我们可以通过日志查看初始的密码，也可以通过如下命令重置密码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重置密码，密码自动生成</span></span><br><span class=\"line\">bin/elasticsearch-reset-password -u elastic</span><br><span class=\"line\"><span class=\"comment\"># 重置密码，自己输入要设置的密码，比如我这里这是为 123456</span></span><br><span class=\"line\">bin/elasticsearch-reset-password -u elastic -i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过curl重置密码</span></span><br><span class=\"line\">curl -X PUT -u elastic:old_password -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/user/elastic/_password&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">  -d <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;password&quot;: &quot;new_password&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>curl 访问ES服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -k 忽略证书校验</span></span><br><span class=\"line\">curl -u elastic:123456 -k https://127.0.0.1:9200</span><br><span class=\"line\"><span class=\"comment\"># 或者 将认证信息通过header传递，elastic:123456 通过base64加密</span></span><br><span class=\"line\">curl -k https://127.0.0.1:9200 -H <span class=\"string\">&#x27;Authorization: Basic ZWxhc3RpYzoxMjM0NTY=&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 也可以通过证书访问https服务，这个证书就是ES在开启安全认证启动时自动生成的</span></span><br><span class=\"line\">curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt  https://127.0.0.1:9200</span><br><span class=\"line\"><span class=\"comment\"># 输出如下：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;node-1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cluster_name&quot;</span> : <span class=\"string\">&quot;test-elk&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cluster_uuid&quot;</span> : <span class=\"string\">&quot;RykjCSPnSCi4Hsi37uziWw&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;version&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;number&quot;</span> : <span class=\"string\">&quot;8.17.3&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_flavor&quot;</span> : <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_type&quot;</span> : <span class=\"string\">&quot;tar&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_hash&quot;</span> : <span class=\"string\">&quot;a091390de485bd4b127884f7e565c0cad59b10d2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_date&quot;</span> : <span class=\"string\">&quot;2025-02-28T10:07:26.089129809Z&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_snapshot&quot;</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;lucene_version&quot;</span> : <span class=\"string\">&quot;9.12.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;minimum_wire_compatibility_version&quot;</span> : <span class=\"string\">&quot;7.17.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;minimum_index_compatibility_version&quot;</span> : <span class=\"string\">&quot;7.0.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;tagline&quot;</span> : <span class=\"string\">&quot;You Know, for Search&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>开发模式和生产模式</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">开发模式：如果用户只是出于学习目的，可以在配置文件中添加 <code>discovery.type=single-node</code> ，表示单节点模式，即开发模式。此模式可以绕过引导检查。</li>\n<li class=\"lvl-2\">生产模式：当用户配置了有关集群的相关配置项时就会触发生产模式，在生产模式下，服务启动会触发ES的引导检查或者叫启动检查（bootstrap checks），引导检查十分严格，即某些检查项不通过则ES服务将无法启动。\n<ul class=\"lvl-3\">\n<li class=\"lvl-4\">引导检查：在服务启动之前对一些重要的配置项进行检查，检查其配置值是否是合理的。引导检查包括对JVM大小、内存锁、虚拟内存、最大线程数、集群发现相关配置等相关的检查，如果某一项或者几项的配置不合理，ES会拒绝启动服务，并且在开发模式下的某些警告信息会升级成错误信息输出。引导检查十分严格，之所以宁可拒绝服务也要阻止用户启动服务是为了防止用户在对ES的基本使用不了解的前提下启动服务而导致的后期性能问题无法解决或者解决起来很麻烦。因为一旦服务以某种不合理的配置启动，时间久了之后可能会产生较大的性能问题，但此时集群已经变得难以维护和扩展，ES为了避免这种情况而做出了引导检查的设置，本来在开发模式下为警告的启动日志会升级为报错（Error）。这种设定虽然增加了用户的使用门槛，但是避免了日后产生更大的问题。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"ES浏览器插件\">ES浏览器插件</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://elasticvue.com/\">Elasticvue</a> : chrome/edge 插件，用于在浏览器中查看ES集群信息，功能非常强大</p>\n</li>\n</ul>\n<h2 id=\"ES自启动脚本\">ES自启动脚本</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建服务文件</span></span><br><span class=\"line\">$ vim /usr/lib/systemd/system/es.service</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=elasticsearch</span><br><span class=\"line\">Documentation=https://www.elastic.co</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">PrivateTmp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 指定ES用户</span></span><br><span class=\"line\">User=elastic</span><br><span class=\"line\">Group=elastic</span><br><span class=\"line\">LimitNOFILE=100000</span><br><span class=\"line\">LimitNPROC=100000</span><br><span class=\"line\">Restart=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 启动命令</span></span><br><span class=\"line\">ExecStart=/usr/local/elasticsearch/elasticsearch-8.17.3/bin/elasticsearch</span><br><span class=\"line\">ExecRestart=/bin/kill -s HUP <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\">ExecStop=/bin/kill -s QUIT <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新加载</span></span><br><span class=\"line\">$ systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">$ systemctl start es</span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">$ systemctl stop es</span><br><span class=\"line\"><span class=\"comment\"># 查看状态</span></span><br><span class=\"line\">$ systemctl status es</span><br><span class=\"line\"><span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">$ systemctl <span class=\"built_in\">enable</span> es</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过ApiKey访问ES\">通过ApiKey访问ES</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于ApiKey的详细介绍，可以参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>创建ApiKey</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27;</span> \\</span><br><span class=\"line\">-u elastic:123456 \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;name&quot;: &quot;elastic_api_key&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;expiration&quot;: &quot;1d&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 请求参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># name: ApiKey的名称</span></span><br><span class=\"line\"><span class=\"comment\"># expiration: ApiKey的过期时间，这里设置为一天，如果不设置，则永不过期</span></span><br><span class=\"line\"><span class=\"comment\"># 请求参数中还有一个重要的参数 `role_descriptors`，其含义是，指定ApiKey所拥有的权限，即角色。如果不进行设置，则默认使用当前认证用户的的角色</span></span><br><span class=\"line\"><span class=\"comment\"># metadata: ApiKey的元数据，即自定义的键值对，这里可以不设置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span>:<span class=\"string\">&quot;70It0ZUBrL2GcOxX0d1L&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;elastic_api_key&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;expiration&quot;</span>:1743057595723,</span><br><span class=\"line\">  <span class=\"string\">&quot;api_key&quot;</span>:<span class=\"string\">&quot;s85lqVkmQISkBlgXCTJmDQ&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;encoded&quot;</span>:<span class=\"string\">&quot;NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ==&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 输出参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># id: ApiKey的id</span></span><br><span class=\"line\"><span class=\"comment\"># name: ApiKey的名称</span></span><br><span class=\"line\"><span class=\"comment\"># expiration: ApiKey的过期时间，单位为毫秒</span></span><br><span class=\"line\"><span class=\"comment\"># api_key: ApiKey的密钥</span></span><br><span class=\"line\"><span class=\"comment\"># encoded: 对 `id:api_key` 进行base64编码，即可得到 `encoded`</span></span><br><span class=\"line\">    <span class=\"comment\"># echo -n &#x27;70It0ZUBrL2GcOxX0d1L:s85lqVkmQISkBlgXCTJmDQ&#x27; | base64</span></span><br><span class=\"line\">    <span class=\"comment\"># 输出：</span></span><br><span class=\"line\">    <span class=\"comment\"># NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ==</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用ApiKey访问ES</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里的ApiKey，就是上面输出的encoded</span></span><br><span class=\"line\">curl -k <span class=\"string\">&#x27;https://127.0.0.1:9200?pretty&#x27;</span> \\</span><br><span class=\"line\">-H <span class=\"string\">&#x27;Authorization: ApiKey NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ==&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;node-1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cluster_name&quot;</span> : <span class=\"string\">&quot;test-elk&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cluster_uuid&quot;</span> : <span class=\"string\">&quot;RykjCSPnSCi4Hsi37uziWw&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;version&quot;</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;number&quot;</span> : <span class=\"string\">&quot;8.17.3&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_flavor&quot;</span> : <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_type&quot;</span> : <span class=\"string\">&quot;tar&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_hash&quot;</span> : <span class=\"string\">&quot;a091390de485bd4b127884f7e565c0cad59b10d2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_date&quot;</span> : <span class=\"string\">&quot;2025-02-28T10:07:26.089129809Z&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build_snapshot&quot;</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;lucene_version&quot;</span> : <span class=\"string\">&quot;9.12.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;minimum_wire_compatibility_version&quot;</span> : <span class=\"string\">&quot;7.17.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;minimum_index_compatibility_version&quot;</span> : <span class=\"string\">&quot;7.0.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;tagline&quot;</span> : <span class=\"string\">&quot;You Know, for Search&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看ApiKey信息，参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html\">官方文档</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?name=elastic_api_key&amp;pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 请求参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># name: ApiKey的名称，不同的ApiKey可以拥有相同的名称，但id不同，所以通过name进行查询可能会返回多个结果</span></span><br><span class=\"line\"><span class=\"comment\"># 或者 id: ApiKey的id，建议通过id进行查询，id唯一，所以通过id进行查询只会返回一个结果</span></span><br><span class=\"line\"><span class=\"comment\"># username: 查询指定用户的ApiKey</span></span><br><span class=\"line\"><span class=\"comment\"># owner: 是否只查询当前认证用户名下的ApiKey，默认为false，为false时必须至少设置name\\ids\\username中的一个参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不加任何参数进行查询，则返回所有ApiKey的信息</span></span><br><span class=\"line\">curl -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>更新ApiKey，参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-api-key.html\">官方文档</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -u elastic:123456 -X PUT -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key/&#123;ApiKeyId&#125;?pretty&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;expiration&quot;: &quot;1h&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;role_descriptors&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;role-a&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;indices&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">            &#123;</span></span><br><span class=\"line\"><span class=\"string\">                &quot;names&quot;: [&quot;*&quot;],</span></span><br><span class=\"line\"><span class=\"string\">                &quot;privileges&quot;: [&quot;write&quot;]</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">        ]</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;metadata&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;environment&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;level&quot;: 2,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;trusted&quot;: true,</span></span><br><span class=\"line\"><span class=\"string\">            &quot;tags&quot;: [&quot;production&quot;]</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以更新的参数有：</span></span><br><span class=\"line\"><span class=\"comment\"># expiration: ApiKey的过期时间，如果已经设置过expiration，此时希望使其永不过期，则只能将其设置为一个比较大的时间，比如 &quot;expiration&quot;: &quot;100y&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># role_descriptors: ApiKey所拥有的角色，原先设置了role_descriptors，更新时希望其使用认证用户的角色，则此时可以将其设置为 &quot;role_descriptors&quot;: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># metadata: ApiKey的元数据，原先设置了 metadata ，更新时希望去除所有 metadata 信息，则此时可以将其设置为 &quot;metadata&quot;: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：三个参数可以只更新其中任何一个，更新哪个就只替换哪个，没有被更新的参数不会受到修改，当然也可以同时更新全部</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>置ApiKey无效，参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html\">官方文档</a>，官方没有提供删除ApiKey的接口，只有置无效的接口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -u elastic:123456 -X DELETE -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;name&quot;: &quot;elastic_api_key&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 请求参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># name: ApiKey的名称，会</span></span><br><span class=\"line\"><span class=\"comment\"># 或者使用  &quot;ids&quot; : [ &quot;70It0ZUBrL2GcOxX0d1L&quot; ] ，通过id进行删除，此时可以一次删除多个ApiKey</span></span><br><span class=\"line\"><span class=\"comment\"># username: 删除指定用户的ApiKey</span></span><br><span class=\"line\"><span class=\"comment\"># owner: 是否只删除当前认证用户名下的ApiKey，默认为false，为false时必须至少设置name\\ids\\username中的一个参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;invalidated_api_keys&quot;</span>:[</span><br><span class=\"line\">    <span class=\"string\">&quot;70It0ZUBrL2GcOxX0d1L&quot;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">&quot;previously_invalidated_api_keys&quot;</span>:[ ],</span><br><span class=\"line\">  <span class=\"string\">&quot;error_count&quot;</span>:0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 输出参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># invalidated_api_keys: 被删除的ApiKey的id列表</span></span><br><span class=\"line\"><span class=\"comment\"># previously_invalidated_api_keys: 之前被删除的ApiKey的id列表</span></span><br><span class=\"line\"><span class=\"comment\"># error_count: 错误数量，如果为0，则表示成功</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用ApiKey的优缺点</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">优点</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安全性:</span><br><span class=\"line\">    细粒度控制: API Key 可以与特定的角色描述符关联，允许非常细化的权限控制。这有助于遵循最小权限原则，只授予必要的访问权限。</span><br><span class=\"line\">    时间限制: 可以为 API Key 设置过期时间，确保密钥不会永远有效，减少长期泄露的风险。</span><br><span class=\"line\">    可撤销性: 如果怀疑某个 API Key 被泄露或不再需要，可以随时撤销该密钥，提高安全性。</span><br><span class=\"line\">方便性:</span><br><span class=\"line\">    易于生成和管理: 创建和管理 API Key 的过程通常很简单，可以通过 REST API 或 Kibana 界面进行。</span><br><span class=\"line\">    无需用户交互: 一旦生成，API Key 可以直接用于自动化脚本或应用程序，无需用户手动登录或提供凭据。</span><br><span class=\"line\">审计和监控:</span><br><span class=\"line\">    跟踪使用情况: 通过日志记录和审计功能，可以跟踪哪个 API Key 进行了哪些操作，便于安全审计和问题排查。</span><br><span class=\"line\">    活动监控: 可以监控 API Key 的活动，及时发现异常行为，并采取相应的措施。</span><br><span class=\"line\">灵活性:</span><br><span class=\"line\">    多种用途: API Key 可以用于各种用途，如应用程序集成、数据导入导出、监控工具等。</span><br><span class=\"line\">    多环境支持: 可以为不同的环境（开发、测试、生产）生成独立的 API Key，确保各环境之间的隔离。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">缺点</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安全性风险:</span><br><span class=\"line\">    密钥存储: API Key 需要安全地存储和传输，如果密钥被泄露，攻击者可以利用它进行未授权的操作。</span><br><span class=\"line\">    静态凭证: 与动态的身份验证机制（如 OAuth 令牌）相比，API Key 是静态的，一旦泄露可能会导致长期的安全风险。</span><br><span class=\"line\">管理复杂性:</span><br><span class=\"line\">    密钥管理: 随着时间和使用规模的增长，管理和维护大量 API Key 可能会变得复杂。需要定期更新和撤销老旧的密钥。</span><br><span class=\"line\">    角色分配: 细粒度的权限控制虽然提供了安全性，但也增加了配置和管理的复杂性。</span><br><span class=\"line\">缺乏用户上下文:</span><br><span class=\"line\">    匿名性: API Key 通常没有用户上下文信息，不像基于用户的认证机制（如 Basic Auth 或 OAuth），这可能不利于某些依赖用户身份的功能。</span><br><span class=\"line\">依赖客户端配置:</span><br><span class=\"line\">    易错性: 如果客户端配置不当，如错误地处理或暴露 API Key，可能会导致安全漏洞。</span><br><span class=\"line\">    更新挑战: 更新 API Key 后，所有使用该密钥的客户端都需要同步更新，这在大规模环境中可能是一个挑战。</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>何时使用 API Key</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">当您需要为自动化脚本、第三方服务或应用程序提供访问权限时。</li>\n<li class=\"lvl-6\">当您希望实现细粒度的权限控制并能够轻松管理密钥的生命周期时。</li>\n<li class=\"lvl-6\">当不需要用户上下文或复杂的用户会话管理时。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建ApiKey</span></span><br><span class=\"line\">curl -X POST -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27;</span> \\</span><br><span class=\"line\">-u elastic:123456 \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;name&quot;: &quot;my-api-key&quot;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;expiration&quot;: &quot;1d&quot;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;role_descriptors&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;role-a&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;cluster&quot;: [&quot;all&quot;],</span></span><br><span class=\"line\"><span class=\"string\">      &quot;indices&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;names&quot;: [&quot;index-a*&quot;],</span></span><br><span class=\"line\"><span class=\"string\">          &quot;privileges&quot;: [&quot;read&quot;]</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;role-b&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;cluster&quot;: [&quot;all&quot;],</span></span><br><span class=\"line\"><span class=\"string\">      &quot;indices&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123;</span></span><br><span class=\"line\"><span class=\"string\">          &quot;names&quot;: [&quot;index-b*&quot;],</span></span><br><span class=\"line\"><span class=\"string\">          &quot;privileges&quot;: [&quot;all&quot;]</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;metadata&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;application&quot;: &quot;my-application&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;environment&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">       &quot;level&quot;: 1,</span></span><br><span class=\"line\"><span class=\"string\">       &quot;trusted&quot;: true,</span></span><br><span class=\"line\"><span class=\"string\">       &quot;tags&quot;: [&quot;dev&quot;, &quot;staging&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># name: ApiKey的名称</span></span><br><span class=\"line\"><span class=\"comment\"># expiration: ApiKey的过期时间，支持的时间单位为：s（秒），m（分钟），h（小时），d（天），w（周），M（月），y（年）</span></span><br><span class=\"line\">    <span class=\"comment\"># expiration不能设置小于1分钟的时间，如果省略expiration，则表示无过期时间</span></span><br><span class=\"line\"><span class=\"comment\"># role_descriptors: 角色描述符，包含多个角色</span></span><br><span class=\"line\">    <span class=\"comment\"># role-a: 角色描述符名称，包含集群和索引的权限描述</span></span><br><span class=\"line\">        <span class=\"comment\"># cluster: 集群权限</span></span><br><span class=\"line\">            <span class=\"comment\"># all: 表示拥有全部集群权限</span></span><br><span class=\"line\">            <span class=\"comment\"># manage: 可以管理集群设置、模板和节点上的分片分配。</span></span><br><span class=\"line\">            <span class=\"comment\"># monitor: 可以监视集群的状态。</span></span><br><span class=\"line\">            <span class=\"comment\"># manage_security: 可以管理安全设置，如用户、角色和角色映射。</span></span><br><span class=\"line\">            <span class=\"comment\"># manage_api_key: 管理 API Key</span></span><br><span class=\"line\">        <span class=\"comment\"># indices: 索引权限，包含names和privileges，</span></span><br><span class=\"line\">            <span class=\"comment\"># names: 表示索引名称，index-a*表示所有以index-a开头的索引，all表示所有索引</span></span><br><span class=\"line\">            <span class=\"comment\"># privileges: 表示索引权限</span></span><br><span class=\"line\">                <span class=\"comment\"># read: 表示拥有索引的读取权限</span></span><br><span class=\"line\">                <span class=\"comment\"># write: 表示拥有索引的写入权限</span></span><br><span class=\"line\">                <span class=\"comment\"># delete: 表示拥有索引的删除权限</span></span><br><span class=\"line\">                <span class=\"comment\"># index: 表示拥有索引的索引权限</span></span><br><span class=\"line\">                <span class=\"comment\"># manage: 表示拥有索引的设置和映射权限</span></span><br><span class=\"line\">                <span class=\"comment\"># monitor: 表示拥有索引的监控权限</span></span><br><span class=\"line\">                <span class=\"comment\"># create_index: 表示允许创建索引</span></span><br><span class=\"line\">                <span class=\"comment\"># crud: 组合了 read, index, delete 权限</span></span><br><span class=\"line\">                <span class=\"comment\"># all: 表示拥有全部索引权限</span></span><br><span class=\"line\">            <span class=\"comment\"># allow_restricted_indices: 表示是否允许对 restricted indices(受限制索引，比如以.开头的索引) 进行操作，true表示允许，false表示不允许</span></span><br><span class=\"line\"><span class=\"comment\"># metadata: 元数据</span></span><br><span class=\"line\">    <span class=\"comment\"># application: 表示应用程序名称</span></span><br><span class=\"line\">    <span class=\"comment\"># environment: 表示环境信息</span></span><br><span class=\"line\">        <span class=\"comment\"># level: 表示环境级别</span></span><br><span class=\"line\">        <span class=\"comment\"># trusted: 表示是否受信任</span></span><br><span class=\"line\">        <span class=\"comment\"># tags: 表示环境标签</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span> : <span class=\"string\">&quot;-kKu0ZUBrL2GcOxX0t1R&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;my-api-key&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;expiration&quot;</span> : 1743066050130,</span><br><span class=\"line\">  <span class=\"string\">&quot;api_key&quot;</span> : <span class=\"string\">&quot;03eNOYg_SCCHdzc0orsRvw&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;encoded&quot;</span> : <span class=\"string\">&quot;LWtLdTBaVUJyTDJHY094WDB0MVI6MDNlTk9ZZ19TQ0NIZHpjMG9yc1J2dw==&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ApiKey信息，根据id查询只会返回一个ApiKey，根据name查询会返回多个ApiKey</span></span><br><span class=\"line\">curl -u elastic:123456 -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?id=-kKu0ZUBrL2GcOxX0t1R&amp;pretty&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;api_keys&quot;</span> : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;id&quot;</span> : <span class=\"string\">&quot;-kKu0ZUBrL2GcOxX0t1R&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;my-api-key&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span> : <span class=\"string\">&quot;rest&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;creation&quot;</span> : 1742979650130,</span><br><span class=\"line\">      <span class=\"string\">&quot;expiration&quot;</span> : 1743066050130,</span><br><span class=\"line\">      <span class=\"string\">&quot;invalidated&quot;</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;username&quot;</span> : <span class=\"string\">&quot;elastic&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;realm&quot;</span> : <span class=\"string\">&quot;reserved&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;realm_type&quot;</span> : <span class=\"string\">&quot;reserved&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;metadata&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;environment&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;level&quot;</span> : 1,</span><br><span class=\"line\">          <span class=\"string\">&quot;trusted&quot;</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;tags&quot;</span> : [</span><br><span class=\"line\">            <span class=\"string\">&quot;dev&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;staging&quot;</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;application&quot;</span> : <span class=\"string\">&quot;my-application&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&quot;role_descriptors&quot;</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;role-a&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;cluster&quot;</span> : [</span><br><span class=\"line\">            <span class=\"string\">&quot;all&quot;</span></span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"string\">&quot;indices&quot;</span> : [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;names&quot;</span> : [</span><br><span class=\"line\">                <span class=\"string\">&quot;index-a*&quot;</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"string\">&quot;privileges&quot;</span> : [</span><br><span class=\"line\">                <span class=\"string\">&quot;read&quot;</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"string\">&quot;allow_restricted_indices&quot;</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"string\">&quot;applications&quot;</span> : [ ],</span><br><span class=\"line\">          <span class=\"string\">&quot;run_as&quot;</span> : [ ],</span><br><span class=\"line\">          <span class=\"string\">&quot;metadata&quot;</span> : &#123; &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;transient_metadata&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;enabled&quot;</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;role-b&quot;</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;cluster&quot;</span> : [</span><br><span class=\"line\">            <span class=\"string\">&quot;all&quot;</span></span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"string\">&quot;indices&quot;</span> : [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;names&quot;</span> : [</span><br><span class=\"line\">                <span class=\"string\">&quot;index-b*&quot;</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"string\">&quot;privileges&quot;</span> : [</span><br><span class=\"line\">                <span class=\"string\">&quot;all&quot;</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"string\">&quot;allow_restricted_indices&quot;</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"string\">&quot;applications&quot;</span> : [ ],</span><br><span class=\"line\">          <span class=\"string\">&quot;run_as&quot;</span> : [ ],</span><br><span class=\"line\">          <span class=\"string\">&quot;metadata&quot;</span> : &#123; &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;transient_metadata&quot;</span> : &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;enabled&quot;</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新ApiKey</span></span><br><span class=\"line\">curl -u elastic:123456 -X PUT -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key/-kKu0ZUBrL2GcOxX0t1R?pretty&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;metadata&quot;: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;updated&quot;</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 置ApiKey无效</span></span><br><span class=\"line\">curl -u elastic:123456 -X DELETE -k <span class=\"string\">&#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span><br><span class=\"line\">--data <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">   &quot;ids&quot; : [ &quot;-kKu0ZUBrL2GcOxX0t1R&quot; ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;invalidated_api_keys&quot;</span> : [</span><br><span class=\"line\">    <span class=\"string\">&quot;-kKu0ZUBrL2GcOxX0t1R&quot;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">&quot;previously_invalidated_api_keys&quot;</span> : [ ],</span><br><span class=\"line\">  <span class=\"string\">&quot;error_count&quot;</span> : 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍如何在linux下安装Elasticsearch Elasticsearch版本8.17.3 下载 下载地址：https://www.elastic.co/cn/downloads/past-releases#elasticsearch 选择对应的版本：这里选择当前的最新版Elasticsearch 8.17.3，之后选择对应的操作系统LINUX X86_64 1wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-8.17.3-linux-x86_64.tar.gz 下载完成后解压到/usr/local/elasticsearch目录下，解压命令如下： 12mkdir /usr/local/elasticsearchtar -zxvf elasticsearch-8.17.3-linux-x86_64.tar.gz -C /usr/local/elasticsearch ElasticSearch目录结构 12345678bin # 脚本文件，包括启动elasticsearch，安装插件，运行统计数据等config # 配置文件目录，如elasticsearch配置、角色配置、jvm配置、证书等。data # 数据目录，默认值 $ES_HOME/data，包含节点、分片、索引、文档的所有数据，生产环境建议修改jdk # JDK目录，用于运行Elasticsearch，7.x以后自带lib # Elasticsearch依赖的JAR包logs # 日志目录，默认值 $ES_HOME/logs，生产环境建议修改modules # 包含所有的Elasticsearch模块，如Cluster、Discovery、Indices等plugins # 已安装插件目录 创建启动用户 elasticsearch和kibana都不能用root用户启动 创建用户elastic，并设置密码 12useradd elasticpasswd elastic 修改elasticsearch安装目录的用户权限 1chown -R elastic:elastic /usr/local/elasticsearch 配置环境变量 进入elastic用户主目录，/home/elastic目录下，设置用户级别的环境变量 12# 切换到elastic用户su - elastic vim .bash_profile 1234# Elasticsearch安装目录，它用于定位Elasticsearch的配置文件、插件和其他相关资源。export ES_HOME=/usr/local/elasticsearch/elasticsearch-8.17.3# Elasticsearch使用的JDK安装目录，在启动Elasticsearch时，它会检查ES_JAVA_HOME环境变量并使用其中的Java路径。export ES_JAVA_HOME=/usr/local/elasticsearch/elasticsearch-8.17.3/jdk/ 执行以下命令使配置生效 1source .bash_profile 配置JVM参数（可选） ES比较耗内存，建议虚拟机4G或以上内存，jvm1g以上的内存分配 进入/usr/local/elasticsearch/elasticsearch-8.17.3/config目录，修改jvm.options文件，调整jvm堆内存大小 12-Xms4g # 设置最小堆内存，默认4g，不能小于1g-Xmx4g # 设置最大堆内存，默认4g，Xmx不要超过机器内存的50%，不要超过30g 创建数据和日志存储目录 1234# 切换到elastic用户su - elastic# 创建目录mkdir /usr/local/elasticsearch/data /usr/local/elasticsearch/log 配置启动文件 如果是本地开发环境，也可以不做任何修改直接启动，因为大部分配置项都有默认值，但为了更好的控制ES，推荐按如下方式进行配置 进入/usr/local/elasticsearch/elasticsearch-8.17.3/config目录，修改elasticsearch.yml文件 123456789101112131415161718192021222324# 集群名称，多个节点如果要组成同一个集群，那么集群名称一定要配置成相同，默认值elasticsearchcluster.name: test-elk# 节点名称，默认值当前节点部署所在机器的主机名node.name: node-1# 数据存储路径，默认值 $ES_HOME/datapath.data: /usr/local/elasticsearch/data# 日志存储路径，默认值 $ES_HOME/logspath.logs: /usr/local/elasticsearch/logs# 配置ES启动时是否进行内存锁定检查，默认值true，本机内存比较小时设置为falsebootstrap.memory_lock: false# 允许通过任何地址访问，开启远程访问network.host: 0.0.0.0# 配置当前ES节点对外提供服务的http端口，默认 9200http.port: 9200# 配置当前ES节点对外提供服务的tcp端口，默认 9300transport.port: 9300# 集群内的主机列表，单节点启动时可以不配置# discovery.seed_hosts: [&quot;127.0.0.1&quot;]# 第一次启动时需要参与选主的节点名称cluster.initial_master_nodes: [&quot;node-1&quot;]#解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 启动ElasticSearch服务 进入/usr/local/elasticsearch/elasticsearch-8.17.3目录，执行以下命令启动服务 123./bin/elasticsearch# 后台启动./bin/elasticsearch -d ES启动前的引导检查 ES启动时，默认会进行引导检查，所谓引导检查就是在服务启动之前对一些重要的配置项进行检查，检查其配置值是否是合理的。引导检查包括对JVM大小、内存锁、虚拟内存、最大线程数、集群发现相关配置等相关的检查，如果某一项或者几项的配置不合理，ES会拒绝启动服务。 如果启动服务时，报以下错误，则需要解决引导检查中的问题 1.max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]; 原因：最大虚拟内存太小,调大系统的虚拟内存 解决办法： 123456# root用户下运行vim /etc/sysctl.conf# 追加以下内容：vm.max_map_count=262144# 保存退出之后执行如下命令：sysctl -p 2.max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536] 原因：文件描述符太小，调大系统的文件描述符 解决办法： 1234567# root用户下运行vim /etc/security/limits.conf# 末尾添加如下配置：* soft nofile 65536* hard nofile 65536* soft nproc 4096* hard nproc 4096 如果只是单节点的开发环境，则可以关闭引导检查，生成环境不建议这样做，因为关闭引导检查后，ES服务将无法保证集群的高可用性。 12345# 进入elasticsearch安装目录vim config/elasticsearch.yml# 添加如下配置：# 指定节点为单节点，可以绕过引导检查discovery.type: single-node 服务正常启动后仍然不能正常访问 访问服务 12curl http://127.0.0.1:9200curl: (52) Empty reply from server 查看日志/usr/local/elasticsearch/elasticsearch-8.17.3/logs/test-elk.log，发现报如下警告： 1[WARN ][o.e.h.n.Netty4HttpServerTransport] [node-1] received plaintext http traffic on an https channel, closing connection Netty4HttpChannel&#123;localAddress=/127.0.0.1:9200, remoteAddress=/127.0.0.1:38426&#125; 原因是ES在启动服务时默认开启了 X-Pack 安全功能，查看配置文件/usr/local/elasticsearch/elasticsearch-8.17.3/config/elasticsearch.yml，发现配置项xpack.security.xxx相关配置项被自动添加了，如下： 123456789101112131415161718192021222324252627282930313233#----------------------- BEGIN SECURITY AUTO CONFIGURATION -----------------------## The following settings, TLS certificates, and keys have been automatically# generated to configure Elasticsearch security features on 20-03-2025 08:53:20## --------------------------------------------------------------------------------# Enable security features# 启用 Elasticsearch 的安全特性，包括用户认证、角色管理、加密等。# 开启了 X-Pack 安全功能，这意味着你需要进行用户认证才能访问 Elasticsearch。# 如果需要关闭 X-Pack 安全功能，你可以将 xpack.security.enabled 设置为 false。xpack.security.enabled: true# 启用安全注册功能，允许通过交互式向导来配置安全设置。# 这使得你可以通过 Kibana 或命令行工具来自动配置 SSL 证书和其他安全设置。xpack.security.enrollment.enabled: true# Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents# 启用 HTTP API 客户端连接的加密# Kibana、Logstash 和其他通过 HTTP API 连接到 Elasticsearch 的客户端将使用 HTTPS 进行通信，增强安全性。xpack.security.http.ssl: enabled: true # 启用 HTTP 层的 SSL 加密，即https访问，确保客户端与 Elasticsearch 之间的通信是加密的。设置为false时，关闭加密，即http访问 keystore.path: certs/http.p12 # 指定用于 HTTP 层加密的密钥库文件路径。这是一个 PKCS12 文件，包含用于加密和验证的公钥和私钥。# Enable encryption and mutual authentication between cluster nodes# 启用节点间的加密和双向认证# Elasticsearch 集群中的节点之间的通信将使用 SSL 加密，并且每个节点都会验证其他节点的身份，从而增强集群的安全性。# 所有节点要配置相同的证书xpack.security.transport.ssl: enabled: true # 启用传输层的 SSL 加密，确保节点之间的内部通信是加密的。 verification_mode: certificate # 设置验证模式为 certificate，这意味着节点之间需要双向认证（即每个节点都需要验证对方的身份）。 keystore.path: certs/transport.p12 # 指定用于传输层加密的密钥库文件路径。这是另一个 PKCS12 文件，包含用于加密和验证的公钥和私钥。 truststore.path: certs/transport.p12 # 指定用于存储信任证书的信任库文件路径。这通常与密钥库相同，但可以不同。#----------------------- END SECURITY AUTO CONFIGURATION ------------------------- 解决方法： 1.不想开启安全认证，将 xpack.security.enabled 设置为 false，这样即便下面的配置都设置为true也不会有效。 2.不想https访问，将 xpack.security.http.ssl.enabled 设置为 false，但这样会导致无法通过认证Token添加其它节点或Kibana。 3.不想节点间通信加密，将 xpack.security.transport.ssl.enabled 设置为 false 为了保证ES的安全，我这里就开启安全认证，并且通过https访问ES，但此时我们访问ES的API就需要带上认证用户，那么用户名和密码是什么呢？ 实际上在ES第一次正常启动时其日志中就打印了自动配置的安全相关的信息提示，里面就给出了登录用户和初始的密码，如下： 1234567891011121314151617181920212223242526272829303132━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━# 这些日志信息提供了 Elasticsearch 8 在首次启动时自动配置的安全特性、生成的默认密码、证书指纹以及如何配置 Kibana 和其他节点加入集群的详细说明。✅ Elasticsearch security features have been automatically configured!✅ Authentication is enabled and cluster connections are encrypted.# 这是 elastic 用户的默认密码。系统建议你使用 bin/elasticsearch-reset-password -u elastic 命令来重置此密码。ℹ️ Password for the elastic user (reset with `bin/elasticsearch-reset-password -u elastic`): BNb=*qz6_M*mXL9uZiSP # 这里会打印出ES自动生成的密码# 这是 HTTP CA 证书的 SHA-256 指纹。CA 证书用于验证 HTTPS 连接的身份。ℹ️ HTTP CA certificate SHA-256 fingerprint: 3f141c16dfc6e165894bc1672084b220dcdd22ffe02116d51ac18003cfaa5a1d# 提供了将 Kibana 配置为使用此 Elasticsearch 集群的步骤。ℹ️ Configure Kibana to use this cluster:# 启动 Kibana 并按照终端中显示的配置链接进行操作。• Run Kibana and click the configuration link in the terminal when Kibana starts.# 复制提供的注册令牌，并在浏览器中打开 Kibana 时粘贴此令牌。令牌在接下来的 30 分钟内有效。# 补充说明：生成新的kibana注册令牌：bin/elasticsearch-create-enrollment-token -s kibana• Copy the following enrollment token and paste it into Kibana in your browser (valid for the next 30 minutes): eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImFSWFBzcFVCTVVmc1d5aUJnbjBtOmRzbVBLQV95UXhDZkJpXzQyWDNEMVEifQ==# 提供了将新的 Elasticsearch 节点加入现有集群的步骤。ℹ️ Configure other nodes to join this cluster:# 使用 bin/elasticsearch --enrollment-token &lt;token&gt; 命令启动新的 Elasticsearch 节点。令牌在接下来的 30 分钟内有效。# 补充说明：生成新的节点注册令牌：bin/elasticsearch-create-enrollment-token -s node• Copy the following enrollment token and start new Elasticsearch nodes with `bin/elasticsearch --enrollment-token &lt;token&gt;` (valid for the next 30 minutes): eyJ2ZXIiOiI4LjE0LjAiLCJhZHIiOlsiMTAuMjUwLjAuMjM5OjkyMDAiXSwiZmdyIjoiM2YxNDFjMTZkZmM2ZTE2NTg5NGJjMTY3MjA4NGIyMjBkY2RkMjJmZmUwMjExNmQ1MWFjMTgwMDNjZmFhNWExZCIsImtleSI6ImF4WFBzcFVCTVVmc1d5aUJnbjFtOkFEallPdnpzUzh1MGJqOFpfVFE4a3cifQ==# 如果你在 Docker 中运行 Elasticsearch，可以使用 docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3 命令启动新节点。 If you&#x27;re running in Docker, copy the enrollment token and run: `docker run -e &quot;ENROLLMENT_TOKEN=&lt;token&gt;&quot; docker.elastic.co/elasticsearch/elasticsearch:8.17.3`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 登录用户为elastic[其角色为超级用户]，我们可以通过日志查看初始的密码，也可以通过如下命令重置密码 1234567891011# 重置密码，密码自动生成bin/elasticsearch-reset-password -u elastic# 重置密码，自己输入要设置的密码，比如我这里这是为 123456bin/elasticsearch-reset-password -u elastic -i# 通过curl重置密码curl -X PUT -u elastic:old_password -k &#x27;https://127.0.0.1:9200/_security/user/elastic/_password&#x27; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123; &quot;password&quot;: &quot;new_password&quot; &#125;&#x27; curl 访问ES服务 123456789101112131415161718192021222324# -k 忽略证书校验curl -u elastic:123456 -k https://127.0.0.1:9200# 或者 将认证信息通过header传递，elastic:123456 通过base64加密curl -k https://127.0.0.1:9200 -H &#x27;Authorization: Basic ZWxhc3RpYzoxMjM0NTY=&#x27;# 也可以通过证书访问https服务，这个证书就是ES在开启安全认证启动时自动生成的curl -u elastic:123456 --cacert /usr/local/elasticsearch/elasticsearch-8.17.3/config/certs/http_ca.crt https://127.0.0.1:9200# 输出如下：&#123; &quot;name&quot; : &quot;node-1&quot;, &quot;cluster_name&quot; : &quot;test-elk&quot;, &quot;cluster_uuid&quot; : &quot;RykjCSPnSCi4Hsi37uziWw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;8.17.3&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;a091390de485bd4b127884f7e565c0cad59b10d2&quot;, &quot;build_date&quot; : &quot;2025-02-28T10:07:26.089129809Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;9.12.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;7.17.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;7.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 开发模式和生产模式 开发模式：如果用户只是出于学习目的，可以在配置文件中添加 discovery.type=single-node ，表示单节点模式，即开发模式。此模式可以绕过引导检查。 生产模式：当用户配置了有关集群的相关配置项时就会触发生产模式，在生产模式下，服务启动会触发ES的引导检查或者叫启动检查（bootstrap checks），引导检查十分严格，即某些检查项不通过则ES服务将无法启动。 引导检查：在服务启动之前对一些重要的配置项进行检查，检查其配置值是否是合理的。引导检查包括对JVM大小、内存锁、虚拟内存、最大线程数、集群发现相关配置等相关的检查，如果某一项或者几项的配置不合理，ES会拒绝启动服务，并且在开发模式下的某些警告信息会升级成错误信息输出。引导检查十分严格，之所以宁可拒绝服务也要阻止用户启动服务是为了防止用户在对ES的基本使用不了解的前提下启动服务而导致的后期性能问题无法解决或者解决起来很麻烦。因为一旦服务以某种不合理的配置启动，时间久了之后可能会产生较大的性能问题，但此时集群已经变得难以维护和扩展，ES为了避免这种情况而做出了引导检查的设置，本来在开发模式下为警告的启动日志会升级为报错（Error）。这种设定虽然增加了用户的使用门槛，但是避免了日后产生更大的问题。 ES浏览器插件 Elasticvue : chrome/edge 插件，用于在浏览器中查看ES集群信息，功能非常强大 ES自启动脚本 1234567891011121314151617181920212223242526272829303132333435# 创建服务文件$ vim /usr/lib/systemd/system/es.service[Unit]Description=elasticsearchDocumentation=https://www.elastic.coAfter=network.target[Service]Type=simplePrivateTmp=true# 指定ES用户User=elasticGroup=elasticLimitNOFILE=100000LimitNPROC=100000Restart=yes# 启动命令ExecStart=/usr/local/elasticsearch/elasticsearch-8.17.3/bin/elasticsearchExecRestart=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPID[Install]WantedBy=multi-user.target# 重新加载$ systemctl daemon-reload# 启动$ systemctl start es# 停止$ systemctl stop es# 查看状态$ systemctl status es# 设置开机启动$ systemctl enable es 通过ApiKey访问ES 关于ApiKey的详细介绍，可以参考官方文档 创建ApiKey 123456789101112131415161718192021222324252627282930curl -k &#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27; \\-u elastic:123456 \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;name&quot;: &quot;elastic_api_key&quot;, &quot;expiration&quot;: &quot;1d&quot;&#125;&#x27;# 请求参数说明：# name: ApiKey的名称# expiration: ApiKey的过期时间，这里设置为一天，如果不设置，则永不过期# 请求参数中还有一个重要的参数 `role_descriptors`，其含义是，指定ApiKey所拥有的权限，即角色。如果不进行设置，则默认使用当前认证用户的的角色# metadata: ApiKey的元数据，即自定义的键值对，这里可以不设置# 输出：&#123; &quot;id&quot;:&quot;70It0ZUBrL2GcOxX0d1L&quot;, &quot;name&quot;:&quot;elastic_api_key&quot;, &quot;expiration&quot;:1743057595723, &quot;api_key&quot;:&quot;s85lqVkmQISkBlgXCTJmDQ&quot;, &quot;encoded&quot;:&quot;NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ==&quot;&#125;# 输出参数说明：# id: ApiKey的id# name: ApiKey的名称# expiration: ApiKey的过期时间，单位为毫秒# api_key: ApiKey的密钥# encoded: 对 `id:api_key` 进行base64编码，即可得到 `encoded` # echo -n &#x27;70It0ZUBrL2GcOxX0d1L:s85lqVkmQISkBlgXCTJmDQ&#x27; | base64 # 输出： # NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ== 使用ApiKey访问ES 123456789101112131415161718192021# 这里的ApiKey，就是上面输出的encodedcurl -k &#x27;https://127.0.0.1:9200?pretty&#x27; \\-H &#x27;Authorization: ApiKey NzBJdDBaVUJyTDJHY094WDBkMUw6czg1bHFWa21RSVNrQmxnWENUSm1EUQ==&#x27;# 输出&#123; &quot;name&quot; : &quot;node-1&quot;, &quot;cluster_name&quot; : &quot;test-elk&quot;, &quot;cluster_uuid&quot; : &quot;RykjCSPnSCi4Hsi37uziWw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;8.17.3&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;a091390de485bd4b127884f7e565c0cad59b10d2&quot;, &quot;build_date&quot; : &quot;2025-02-28T10:07:26.089129809Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;9.12.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;7.17.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;7.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 查看ApiKey信息，参考官方文档 123456789curl -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_security/api_key?name=elastic_api_key&amp;pretty&#x27;# 请求参数说明：# name: ApiKey的名称，不同的ApiKey可以拥有相同的名称，但id不同，所以通过name进行查询可能会返回多个结果# 或者 id: ApiKey的id，建议通过id进行查询，id唯一，所以通过id进行查询只会返回一个结果# username: 查询指定用户的ApiKey# owner: 是否只查询当前认证用户名下的ApiKey，默认为false，为false时必须至少设置name\\ids\\username中的一个参数# 不加任何参数进行查询，则返回所有ApiKey的信息curl -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27; 更新ApiKey，参考官方文档 12345678910111213141516171819202122232425262728curl -u elastic:123456 -X PUT -k &#x27;https://127.0.0.1:9200/_security/api_key/&#123;ApiKeyId&#125;?pretty&#x27; \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;expiration&quot;: &quot;1h&quot;, &quot;role_descriptors&quot;: &#123; &quot;role-a&quot;: &#123; &quot;indices&quot;: [ &#123; &quot;names&quot;: [&quot;*&quot;], &quot;privileges&quot;: [&quot;write&quot;] &#125; ] &#125; &#125;, &quot;metadata&quot;: &#123; &quot;environment&quot;: &#123; &quot;level&quot;: 2, &quot;trusted&quot;: true, &quot;tags&quot;: [&quot;production&quot;] &#125; &#125;&#125;&#x27;# 可以更新的参数有：# expiration: ApiKey的过期时间，如果已经设置过expiration，此时希望使其永不过期，则只能将其设置为一个比较大的时间，比如 &quot;expiration&quot;: &quot;100y&quot;# role_descriptors: ApiKey所拥有的角色，原先设置了role_descriptors，更新时希望其使用认证用户的角色，则此时可以将其设置为 &quot;role_descriptors&quot;: &#123;&#125;# metadata: ApiKey的元数据，原先设置了 metadata ，更新时希望去除所有 metadata 信息，则此时可以将其设置为 &quot;metadata&quot;: &#123;&#125;# 注意：三个参数可以只更新其中任何一个，更新哪个就只替换哪个，没有被更新的参数不会受到修改，当然也可以同时更新全部 置ApiKey无效，参考官方文档，官方没有提供删除ApiKey的接口，只有置无效的接口 1234567891011121314151617181920212223curl -u elastic:123456 -X DELETE -k &#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27; \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;name&quot;: &quot;elastic_api_key&quot;&#125;&#x27;# 请求参数说明：# name: ApiKey的名称，会# 或者使用 &quot;ids&quot; : [ &quot;70It0ZUBrL2GcOxX0d1L&quot; ] ，通过id进行删除，此时可以一次删除多个ApiKey# username: 删除指定用户的ApiKey# owner: 是否只删除当前认证用户名下的ApiKey，默认为false，为false时必须至少设置name\\ids\\username中的一个参数# 输出：&#123; &quot;invalidated_api_keys&quot;:[ &quot;70It0ZUBrL2GcOxX0d1L&quot; ], &quot;previously_invalidated_api_keys&quot;:[ ], &quot;error_count&quot;:0&#125;# 输出参数说明：# invalidated_api_keys: 被删除的ApiKey的id列表# previously_invalidated_api_keys: 之前被删除的ApiKey的id列表# error_count: 错误数量，如果为0，则表示成功 使用ApiKey的优缺点 优点 12345678910111213安全性: 细粒度控制: API Key 可以与特定的角色描述符关联，允许非常细化的权限控制。这有助于遵循最小权限原则，只授予必要的访问权限。 时间限制: 可以为 API Key 设置过期时间，确保密钥不会永远有效，减少长期泄露的风险。 可撤销性: 如果怀疑某个 API Key 被泄露或不再需要，可以随时撤销该密钥，提高安全性。方便性: 易于生成和管理: 创建和管理 API Key 的过程通常很简单，可以通过 REST API 或 Kibana 界面进行。 无需用户交互: 一旦生成，API Key 可以直接用于自动化脚本或应用程序，无需用户手动登录或提供凭据。审计和监控: 跟踪使用情况: 通过日志记录和审计功能，可以跟踪哪个 API Key 进行了哪些操作，便于安全审计和问题排查。 活动监控: 可以监控 API Key 的活动，及时发现异常行为，并采取相应的措施。灵活性: 多种用途: API Key 可以用于各种用途，如应用程序集成、数据导入导出、监控工具等。 多环境支持: 可以为不同的环境（开发、测试、生产）生成独立的 API Key，确保各环境之间的隔离。 缺点 1234567891011安全性风险: 密钥存储: API Key 需要安全地存储和传输，如果密钥被泄露，攻击者可以利用它进行未授权的操作。 静态凭证: 与动态的身份验证机制（如 OAuth 令牌）相比，API Key 是静态的，一旦泄露可能会导致长期的安全风险。管理复杂性: 密钥管理: 随着时间和使用规模的增长，管理和维护大量 API Key 可能会变得复杂。需要定期更新和撤销老旧的密钥。 角色分配: 细粒度的权限控制虽然提供了安全性，但也增加了配置和管理的复杂性。缺乏用户上下文: 匿名性: API Key 通常没有用户上下文信息，不像基于用户的认证机制（如 Basic Auth 或 OAuth），这可能不利于某些依赖用户身份的功能。依赖客户端配置: 易错性: 如果客户端配置不当，如错误地处理或暴露 API Key，可能会导致安全漏洞。 更新挑战: 更新 API Key 后，所有使用该密钥的客户端都需要同步更新，这在大规模环境中可能是一个挑战。 何时使用 API Key 当您需要为自动化脚本、第三方服务或应用程序提供访问权限时。 当您希望实现细粒度的权限控制并能够轻松管理密钥的生命周期时。 当不需要用户上下文或复杂的用户会话管理时。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177# 创建ApiKeycurl -X POST -k &#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27; \\-u elastic:123456 \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;name&quot;: &quot;my-api-key&quot;, &quot;expiration&quot;: &quot;1d&quot;, &quot;role_descriptors&quot;: &#123; &quot;role-a&quot;: &#123; &quot;cluster&quot;: [&quot;all&quot;], &quot;indices&quot;: [ &#123; &quot;names&quot;: [&quot;index-a*&quot;], &quot;privileges&quot;: [&quot;read&quot;] &#125; ] &#125;, &quot;role-b&quot;: &#123; &quot;cluster&quot;: [&quot;all&quot;], &quot;indices&quot;: [ &#123; &quot;names&quot;: [&quot;index-b*&quot;], &quot;privileges&quot;: [&quot;all&quot;] &#125; ] &#125; &#125;, &quot;metadata&quot;: &#123; &quot;application&quot;: &quot;my-application&quot;, &quot;environment&quot;: &#123; &quot;level&quot;: 1, &quot;trusted&quot;: true, &quot;tags&quot;: [&quot;dev&quot;, &quot;staging&quot;] &#125; &#125;&#125;&#x27;# name: ApiKey的名称# expiration: ApiKey的过期时间，支持的时间单位为：s（秒），m（分钟），h（小时），d（天），w（周），M（月），y（年） # expiration不能设置小于1分钟的时间，如果省略expiration，则表示无过期时间# role_descriptors: 角色描述符，包含多个角色 # role-a: 角色描述符名称，包含集群和索引的权限描述 # cluster: 集群权限 # all: 表示拥有全部集群权限 # manage: 可以管理集群设置、模板和节点上的分片分配。 # monitor: 可以监视集群的状态。 # manage_security: 可以管理安全设置，如用户、角色和角色映射。 # manage_api_key: 管理 API Key # indices: 索引权限，包含names和privileges， # names: 表示索引名称，index-a*表示所有以index-a开头的索引，all表示所有索引 # privileges: 表示索引权限 # read: 表示拥有索引的读取权限 # write: 表示拥有索引的写入权限 # delete: 表示拥有索引的删除权限 # index: 表示拥有索引的索引权限 # manage: 表示拥有索引的设置和映射权限 # monitor: 表示拥有索引的监控权限 # create_index: 表示允许创建索引 # crud: 组合了 read, index, delete 权限 # all: 表示拥有全部索引权限 # allow_restricted_indices: 表示是否允许对 restricted indices(受限制索引，比如以.开头的索引) 进行操作，true表示允许，false表示不允许# metadata: 元数据 # application: 表示应用程序名称 # environment: 表示环境信息 # level: 表示环境级别 # trusted: 表示是否受信任 # tags: 表示环境标签# 输出：&#123; &quot;id&quot; : &quot;-kKu0ZUBrL2GcOxX0t1R&quot;, &quot;name&quot; : &quot;my-api-key&quot;, &quot;expiration&quot; : 1743066050130, &quot;api_key&quot; : &quot;03eNOYg_SCCHdzc0orsRvw&quot;, &quot;encoded&quot; : &quot;LWtLdTBaVUJyTDJHY094WDB0MVI6MDNlTk9ZZ19TQ0NIZHpjMG9yc1J2dw==&quot;&#125;# 查看ApiKey信息，根据id查询只会返回一个ApiKey，根据name查询会返回多个ApiKeycurl -u elastic:123456 -k &#x27;https://127.0.0.1:9200/_security/api_key?id=-kKu0ZUBrL2GcOxX0t1R&amp;pretty&#x27;# 输出：&#123; &quot;api_keys&quot; : [ &#123; &quot;id&quot; : &quot;-kKu0ZUBrL2GcOxX0t1R&quot;, &quot;name&quot; : &quot;my-api-key&quot;, &quot;type&quot; : &quot;rest&quot;, &quot;creation&quot; : 1742979650130, &quot;expiration&quot; : 1743066050130, &quot;invalidated&quot; : false, &quot;username&quot; : &quot;elastic&quot;, &quot;realm&quot; : &quot;reserved&quot;, &quot;realm_type&quot; : &quot;reserved&quot;, &quot;metadata&quot; : &#123; &quot;environment&quot; : &#123; &quot;level&quot; : 1, &quot;trusted&quot; : true, &quot;tags&quot; : [ &quot;dev&quot;, &quot;staging&quot; ] &#125;, &quot;application&quot; : &quot;my-application&quot; &#125;, &quot;role_descriptors&quot; : &#123; &quot;role-a&quot; : &#123; &quot;cluster&quot; : [ &quot;all&quot; ], &quot;indices&quot; : [ &#123; &quot;names&quot; : [ &quot;index-a*&quot; ], &quot;privileges&quot; : [ &quot;read&quot; ], &quot;allow_restricted_indices&quot; : false &#125; ], &quot;applications&quot; : [ ], &quot;run_as&quot; : [ ], &quot;metadata&quot; : &#123; &#125;, &quot;transient_metadata&quot; : &#123; &quot;enabled&quot; : true &#125; &#125;, &quot;role-b&quot; : &#123; &quot;cluster&quot; : [ &quot;all&quot; ], &quot;indices&quot; : [ &#123; &quot;names&quot; : [ &quot;index-b*&quot; ], &quot;privileges&quot; : [ &quot;all&quot; ], &quot;allow_restricted_indices&quot; : false &#125; ], &quot;applications&quot; : [ ], &quot;run_as&quot; : [ ], &quot;metadata&quot; : &#123; &#125;, &quot;transient_metadata&quot; : &#123; &quot;enabled&quot; : true &#125; &#125; &#125; &#125; ]&#125;# 更新ApiKeycurl -u elastic:123456 -X PUT -k &#x27;https://127.0.0.1:9200/_security/api_key/-kKu0ZUBrL2GcOxX0t1R?pretty&#x27; \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;metadata&quot;: &#123;&#125;&#125;&#x27;# 输出：&#123; &quot;updated&quot; : true&#125;# 置ApiKey无效curl -u elastic:123456 -X DELETE -k &#x27;https://127.0.0.1:9200/_security/api_key?pretty&#x27; \\--header &#x27;Content-Type: application/json&#x27; \\--data &#x27;&#123; &quot;ids&quot; : [ &quot;-kKu0ZUBrL2GcOxX0t1R&quot; ]&#125;&#x27;# 输出：&#123; &quot;invalidated_api_keys&quot; : [ &quot;-kKu0ZUBrL2GcOxX0t1R&quot; ], &quot;previously_invalidated_api_keys&quot; : [ ], &quot;error_count&quot; : 0&#125;","summary":"摘要 本文介绍如何在linux下安装Elasticsearch Elasticsearch版本8.17.3","date_published":"2025-03-20T13:30:05.000Z","tags":["技术","elastic","elasticsearch","elasticsearch"]}]}