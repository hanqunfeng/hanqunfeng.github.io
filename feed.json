{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","url":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","title":"Maven 新一代构建工具 mvnd","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Maven 新一代构建工具 mvnd</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/maven-mvnd\">mvnd GitHub</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://mvnd.apache.org/\">mvnd 官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文安装的是 mvnd 1.0.3。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"mvnd-简介\">mvnd 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 是 Maven 新一代构建工具，基于 Netty 构建，使用 Java 语言编写。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p>\n</li>\n</ul>\n<h3 id=\"架构概述\">架构概述</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际构建发生在一个长驻后台进程中，又名守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种架构带来了以下优点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">不需要每次构建重新启动 JVM，大大节省时间。</li>\n<li class=\"lvl-6\">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li>\n<li class=\"lvl-6\">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p>\n</li>\n</ul>\n<h2 id=\"mvnd-安装\">mvnd 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 安装包下载地址：<a href=\"https://github.com/apache/maven-mvnd/releases\">mvnd Github Release</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文以 macOS 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 mvnd 对应的安装包</span></span><br><span class=\"line\">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class=\"line\"><span class=\"comment\"># 添加 mvnd 到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br><span class=\"line\"><span class=\"comment\"># 检查 mvnd 是否安装成功</span></span><br><span class=\"line\">mvnd --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"variable\">$MVND_HOME</span>/conf/mvnd.properties <span class=\"variable\">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>默认值</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>mvnd.noBuffering</strong> <code>[*]</code></td>\n<td>false</td>\n<td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td>\n</tr>\n<tr>\n<td><strong>mvnd.rollingWindowSize</strong></td>\n<td>0</td>\n<td>构建并行模块时，每个模块显示的日志行数</td>\n</tr>\n<tr>\n<td><strong>mvnd.logPurgePeriod</strong></td>\n<td>7d</td>\n<td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.noDaemon</strong></td>\n<td>false</td>\n<td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td>\n</tr>\n<tr>\n<td><strong>mvnd.debug</strong></td>\n<td>false</td>\n<td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.idleTimeout</strong></td>\n<td>3 hours</td>\n<td>守护进程在空闲多久后自动关闭</td>\n</tr>\n<tr>\n<td><strong>mvnd.keepAlive</strong></td>\n<td>100 ms</td>\n<td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxLostKeepAlive</strong></td>\n<td>30</td>\n<td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td>\n</tr>\n<tr>\n<td><strong>mvnd.minThreads</strong></td>\n<td>1</td>\n<td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td>\n</tr>\n<tr>\n<td><strong>mvnd.threads</strong> <code>[*]</code></td>\n<td>未设置</td>\n<td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td>\n</tr>\n<tr>\n<td><strong>mvnd.builder</strong></td>\n<td>smart</td>\n<td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td>\n</tr>\n<tr>\n<td><strong>mvnd.minHeapSize</strong></td>\n<td>128M</td>\n<td>守护进程 JVM 的最小堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td>\n<td>2G</td>\n<td>守护进程 JVM 的最大堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.threadStackSize</strong></td>\n<td>1M</td>\n<td>守护进程线程栈大小</td>\n</tr>\n<tr>\n<td><strong>mvnd.jvmArgs</strong></td>\n<td>未设置</td>\n<td>传递给 daemon 的额外 JVM 参数</td>\n</tr>\n<tr>\n<td><strong>mvnd.enableAssertions</strong></td>\n<td>false</td>\n<td>是否为 daemon 启用 JVM 断言（-ea）</td>\n</tr>\n<tr>\n<td><strong>mvnd.expirationCheckDelay</strong></td>\n<td>10 seconds</td>\n<td>守护进程检测自身是否需要过期的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.duplicateDaemonGracePeriod</strong></td>\n<td>10 seconds</td>\n<td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td>\n</tr>\n<tr>\n<td><strong>mvnd.home</strong></td>\n<td>自动设置</td>\n<td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td>\n</tr>\n<tr>\n<td><strong>java.home</strong></td>\n<td>使用环境变量</td>\n<td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td>\n</tr>\n<tr>\n<td><strong>maven.settings</strong> <code>[*]</code></td>\n<td>~/.m2/settings.xml</td>\n<td>maven 的 settings.xml 路径</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"mvnd-使用\">mvnd 使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行使用方式与 mvn 一样，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvnd clean install</span><br><span class=\"line\">mvnd clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 还有些特殊用法，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class=\"line\">mvnd --status</span><br><span class=\"line\"><span class=\"comment\"># 手动停止所有运行的守护进程</span></span><br><span class=\"line\">mvnd --stop</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"mvnd-与-mvnw-的区别\">mvnd 与 mvnw 的区别</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class=\"line\">mvnw： linux 脚本文件</span><br><span class=\"line\">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>mvnw</code>使用方式如下:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>mvnd</th>\n<th>mvnw（Maven Wrapper）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是什么</td>\n<td>一个「常驻的 Maven 守护进程」</td>\n<td>一个「Maven 启动脚本」</td>\n</tr>\n<tr>\n<td>是否常驻</td>\n<td>✅ 是（daemon）</td>\n<td>❌ 否（一次性）</td>\n</tr>\n<tr>\n<td>是否下载 Maven</td>\n<td>❌ 不下载，自己就是程序</td>\n<td>✅ 会自动下载指定版本</td>\n</tr>\n<tr>\n<td>主要目的</td>\n<td>加速构建</td>\n<td>保证版本一致</td>\n</tr>\n<tr>\n<td>是否推荐在 CI</td>\n<td>一般不建议</td>\n<td>✅ 非常推荐</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td><code>mvnd clean install</code></td>\n<td><code>./mvnw clean install</code></td>\n</tr>\n<tr>\n<td>是否与项目绑定</td>\n<td>❌ 全局使用</td>\n<td>✅ 和项目绑定</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub mvnd 官网 本文安装的是 mvnd 1.0.3。 mvnd 简介 mvnd 是 Maven 新一代构建工具，基于 Netty 构建，使用 Java 语言编写。 mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。 架构概述 mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。 实际构建发生在一个长驻后台进程中，又名守护程序。 一个守护程序实例可以服务来自mvnd客户端的多个连续请求。 mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。 如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。 这种架构带来了以下优点： 不需要每次构建重新启动 JVM，大大节省时间。 持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。 JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。 默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: availableProcessors - 1 mvnd 安装 mvnd 安装包下载地址：mvnd Github Release 本文以 macOS 为例 123456789# 下载 mvnd 对应的安装包curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xzln -s mvnd-1.0.3-darwin-amd64 mvnd# 添加 mvnd 到环境变量echo &#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27; &gt;&gt; ~/.zshrcecho &#x27;export PATH=$MVND_HOME/bin:$PATH&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc# 检查 mvnd 是否安装成功mvnd --version mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 ~/.m2/settings.xml ，由于本机之前安装过 Maven，所以这一步就省略了。 [推荐]将 mvnd 的配置文件拷贝到 ~/.m2 目录下 12# 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`cp $MVND_HOME/conf/mvnd.properties $HOME/.m2/mvnd.properties mvnd 配置项说明，一般不需要修改，可能会修改的我用 [*] 做了标注 配置项 默认值 中文解释 mvnd.noBuffering [*] false 是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 -B 或 --batch-mode 也会启用此行为 mvnd.rollingWindowSize 0 构建并行模块时，每个模块显示的日志行数 mvnd.logPurgePeriod 7d 自动清理日志的周期（如：7天），日志保存路径： $HOME/.m2/mvnd/registry/1.0.3/ mvnd.noDaemon false 禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效 mvnd.debug false 使用调试模式启动 daemon，JVM 参数为：-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000 mvnd.idleTimeout 3 hours 守护进程在空闲多久后自动关闭 mvnd.keepAlive 100 ms 如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔 mvnd.maxLostKeepAlive 30 允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败 mvnd.minThreads 1 构建时要使用的最少线程数量。如果显式指定了 -T、--threads 或 mvnd.threads，该值将被忽略 mvnd.threads [*] 未设置 传递给 daemon 的线程数，与 Maven 的 -T / --threads 语法一致 mvnd.builder smart 指定使用的 Maven 构建器名称（等同于 -b 或 --builder） mvnd.minHeapSize 128M 守护进程 JVM 的最小堆内存 mvnd.maxHeapSize [*] 2G 守护进程 JVM 的最大堆内存 mvnd.threadStackSize 1M 守护进程线程栈大小 mvnd.jvmArgs 未设置 传递给 daemon 的额外 JVM 参数 mvnd.enableAssertions false 是否为 daemon 启用 JVM 断言（-ea） mvnd.expirationCheckDelay 10 seconds 守护进程检测自身是否需要过期的时间间隔 mvnd.duplicateDaemonGracePeriod 10 seconds 多个 daemon 存在时，多余 daemon 的宽限退出时间 mvnd.home 自动设置 mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置 java.home 使用环境变量 启动 daemon 的 Java 目录（等同 JAVA_HOME） maven.settings [*] ~/.m2/settings.xml maven 的 settings.xml 路径 mvnd 使用 命令行使用方式与 mvn 一样，比如： 12mvnd clean installmvnd clean package -Dmaven.test.skip=true mvnd 的 daemon 缓存了一切，所以运行 mvnd clean install 后，之后再次运行 mvnd clean install 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。 mvnd 还有些特殊用法，比如： 1234# 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭mvnd --status# 手动停止所有运行的守护进程mvnd --stop 在IDEA中使用mvnd，在Maven设置中将mvnd的安装目录添加到 Maven Home Path 中 mvnd 与 mvnw 的区别 我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件 123.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明 mvn 的 urlmvnw： linux 脚本文件mvnw.cmd： windows 脚本文件 实际上 mvnw 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。 第一次使用mvnw时会通过wrapper/maven-wrapper.properties 文件中的声明自动下载maven，并保存在 ~/.m2/wrapper/dists/ 目录下 mvnw使用方式如下: 1./mvnw clean install 运行速度： mvnd &gt;&gt; mvnw ≈ mvn 对比项 mvnd mvnw（Maven Wrapper） 是什么 一个「常驻的 Maven 守护进程」 一个「Maven 启动脚本」 是否常驻 ✅ 是（daemon） ❌ 否（一次性） 是否下载 Maven ❌ 不下载，自己就是程序 ✅ 会自动下载指定版本 主要目的 加速构建 保证版本一致 是否推荐在 CI 一般不建议 ✅ 非常推荐 使用方式 mvnd clean install ./mvnw clean install 是否与项目绑定 ❌ 全局使用 ✅ 和项目绑定","summary":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub mvnd 官网 本文安装的是 mvnd 1.0.3。","date_published":"2025-12-07T14:30:05.000Z","tags":["技术","maven","mvnd","mavne","mvnd"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","url":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","title":"Redis 7 + ACL 简介","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 简介</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Redis-ACL-简介\">Redis ACL 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ACL 可以控制的维度包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">谁能登录（用户、密码）</li>\n<li class=\"lvl-5\">可以执行哪些命令</li>\n<li class=\"lvl-5\">可以访问哪些 key（按前缀 / 正则）</li>\n<li class=\"lvl-5\">可否通过网络访问</li>\n<li class=\"lvl-5\">是否启用 / 禁用某个用户</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p>\n</li>\n</ul>\n<h2 id=\"Redis-ACL-的使用\">Redis ACL 的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>redis.conf</code> 中添加如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 ACL 文件</span></span><br><span class=\"line\">aclfile /etc/redis/users.acl</span><br><span class=\"line\"><span class=\"comment\"># 关闭 密码</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p>\n</li>\n</ul>\n<h3 id=\"ACL-的配置方式\">ACL 的配置方式</h3>\n<h4 id=\"直接编辑-aclfile\">直接编辑 aclfile</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置一个管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个应用用户</span></span><br><span class=\"line\">user appuser on  ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span> &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个只读用户</span></span><br><span class=\"line\">user <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p>\n</li>\n<li class=\"lvl-2\">\n<p>格式说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用 off: 禁用</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+<span class=\"built_in\">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class=\"built_in\">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class=\"built_in\">cat</span> 命令查看，以@开头，比如 @<span class=\"built_in\">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class=\"line\">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上就是一个超级管理员权限</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class=\"line\"><span class=\"comment\"># 如果设置了 requirepass 密码</span></span><br><span class=\"line\">user default on sanitize-payload <span class=\"comment\">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 连接时直接登录, --pass == -a</span></span><br><span class=\"line\">redis-cli --user username --pass password -h host -p port</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"><span class=\"comment\"># 本机登录</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@</span><br><span class=\"line\"><span class=\"comment\"># 本机登录时端口不是默认的6379时</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@:6380</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先连接后登录</span></span><br><span class=\"line\">redis-cli -h host -p port</span><br><span class=\"line\">&gt; auth username password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ACL 规则中文说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>规则 / 语法</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>on</code></td>\n<td>启用用户：可以使用该用户进行认证登录</td>\n</tr>\n<tr>\n<td><code>off</code></td>\n<td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td>\n</tr>\n<tr>\n<td><code>skip-sanitize-payload</code></td>\n<td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td>\n</tr>\n<tr>\n<td><code>sanitize-payload</code></td>\n<td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;</code></td>\n<td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td>\n</tr>\n<tr>\n<td><code>-&lt;command&gt;</code></td>\n<td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td>\n</tr>\n<tr>\n<td><code>+@&lt;category&gt;</code></td>\n<td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td>\n</tr>\n<tr>\n<td><code>@all</code></td>\n<td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;|first-arg</code></td>\n<td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td>\n</tr>\n<tr>\n<td><code>allcommands</code></td>\n<td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td>\n</tr>\n<tr>\n<td><code>nocommands</code></td>\n<td><code>-@all</code> 的别名，禁止所有命令</td>\n</tr>\n<tr>\n<td><code>~&lt;pattern&gt;</code></td>\n<td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td>\n</tr>\n<tr>\n<td><code>%R~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许读取</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>%W~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许写入</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>allkeys</code></td>\n<td><code>~*</code> 的别名，允许所有 key</td>\n</tr>\n<tr>\n<td><code>resetkeys</code></td>\n<td>清空允许访问的 key 模式</td>\n</tr>\n<tr>\n<td><code>&amp;&lt;pattern&gt;</code></td>\n<td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td>\n</tr>\n<tr>\n<td><code>allchannels</code></td>\n<td><code>&amp;*</code> 的别名，允许所有 channel</td>\n</tr>\n<tr>\n<td><code>resetchannels</code></td>\n<td>清空 Pub/Sub channel 模式列表</td>\n</tr>\n<tr>\n<td><code>&gt;&lt;password&gt;</code></td>\n<td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;password&gt;</code></td>\n<td>移除指定密码</td>\n</tr>\n<tr>\n<td><code>nopass</code></td>\n<td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td>\n</tr>\n<tr>\n<td><code>resetpass</code></td>\n<td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td>\n</tr>\n<tr>\n<td><code>(&lt;options&gt;)</code></td>\n<td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td>\n</tr>\n<tr>\n<td><code>clearselectors</code></td>\n<td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通过-ACL-命令\">通过 ACL 命令</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png\" alt=\"\"></p>\n<h5 id=\"ACL-SETUSER\">ACL SETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建/修改用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 default 用户</span></span><br><span class=\"line\">ACL SETUSER default off</span><br><span class=\"line\"><span class=\"comment\"># 创建一个管理员</span></span><br><span class=\"line\">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 创建一个普通用户</span></span><br><span class=\"line\">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个只读用户</span></span><br><span class=\"line\">ACL SETUSER <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一次执行</span></span><br><span class=\"line\">ACL SETUSER testuser on ~* -@all +@<span class=\"built_in\">read</span> +ping  &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 第二次执行，只添加新的权限</span></span><br><span class=\"line\">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行后的结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"修改用户权限\">修改用户权限</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重置权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重置所有权限</span></span><br><span class=\"line\">ACL SETUSER testuser reset</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>取消密码，但保留权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser nopass</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：取消密码</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有频道</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LIST\">ACL LIST</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以通过如下命令查看当前 Redis 中所有的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LIST</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用</span><br><span class=\"line\">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class=\"line\">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOAD\">ACL LOAD</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SAVE</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p>\n</li>\n</ul>\n<h5 id=\"ACL-SAVE\">ACL SAVE</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOAD</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-USERS\">ACL USERS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>列出所有已创建的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL USERS</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;appuser&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;default&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-GETUSER\">ACL GETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取指定用户的权限信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL GETUSER appuser</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;flags&quot;</span></span><br><span class=\"line\"> 2) 1) <span class=\"string\">&quot;on&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;sanitize-payload&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;passwords&quot;</span></span><br><span class=\"line\"> 4) 1) <span class=\"string\">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;commands&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;-@all +get +set&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;keys&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;~cache:*&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;channels&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;&amp;app:*&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;selectors&quot;</span></span><br><span class=\"line\">12) (empty array)</span><br></pre></td></tr></table></figure>\n<h6 id=\"selectors-选择器规则\">selectors(选择器规则)</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以前 = 一个用户一条规则</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根权限（全局规则）</span></span><br><span class=\"line\">ACL SETUSER selectoruser on ~cache:* +get +<span class=\"built_in\">set</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>现在 = 一个用户可以有多个“权限分身”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 选择器规则</span></span><br><span class=\"line\"><span class=\"comment\"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class=\"line\">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class=\"built_in\">set</span>) &gt;123456</span><br><span class=\"line\"><span class=\"comment\">## 翻译后的结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DELUSER\">ACL DELUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除一个用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-WHOAMI\">ACL WHOAMI</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取当前登录的用户名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL WHOAMI</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-CAT\">ACL CAT</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取所有权限类别</p>\n</li>\n<li class=\"lvl-2\">\n<p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有权限类别</span></span><br><span class=\"line\">ACL CAT</span><br><span class=\"line\"><span class=\"comment\"># 获取指定类别中的命令列表</span></span><br><span class=\"line\">ACL CAT 分类名称</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DRYRUN\">ACL DRYRUN</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 7.0.0 新增。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class=\"line\"><span class=\"string\">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOG\">ACL LOG</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOG          <span class=\"comment\"># 查看默认最新的 ACL 日志条目</span></span><br><span class=\"line\">ACL LOG RESET    <span class=\"comment\"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>日志格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) <span class=\"string\">&quot;count&quot;</span> =&gt; 1</span><br><span class=\"line\">   2) <span class=\"string\">&quot;reason&quot;</span> =&gt; <span class=\"string\">&quot;command&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;context&quot;</span> =&gt; <span class=\"string\">&quot;toplevel&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;object&quot;</span> =&gt; <span class=\"string\">&quot;acl|log&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;username&quot;</span> =&gt; <span class=\"string\">&quot;selectoruser&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class=\"line\">   7) <span class=\"string\">&quot;client-info&quot;</span> =&gt; <span class=\"string\">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class=\"line\">   8) <span class=\"string\">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class=\"line\">   9) <span class=\"string\">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class=\"line\">   10) <span class=\"string\">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>count</code></td>\n<td>触发该日志的次数。比如同一事件触发 1 次就是 1</td>\n</tr>\n<tr>\n<td><code>reason</code></td>\n<td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td>\n</tr>\n<tr>\n<td><code>object</code></td>\n<td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td>触发事件的用户</td>\n</tr>\n<tr>\n<td><code>age-seconds</code></td>\n<td>事件距离当前的时间（秒），越大表示越久远</td>\n</tr>\n<tr>\n<td><code>client-info</code></td>\n<td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td>\n</tr>\n<tr>\n<td><code>entry-id</code></td>\n<td>日志条目 ID</td>\n</tr>\n<tr>\n<td><code>timestamp-created</code></td>\n<td>日志创建时间（毫秒）</td>\n</tr>\n<tr>\n<td><code>timestamp-last-updated</code></td>\n<td>日志最后更新时间（毫秒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"ACL-GENPASS\">ACL GENPASS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成一个随机的 ACL 密码</p>\n</li>\n<li class=\"lvl-2\">\n<p>生成复杂密码的工具有很多，没必要用这玩意。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class=\"line\">&gt; ACL GENPASS</span><br><span class=\"line\"><span class=\"string\">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，32/4 = 8</span></span><br><span class=\"line\">&gt; ACL GENPASS 32</span><br><span class=\"line\"><span class=\"string\">&quot;355ef3dd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class=\"line\">&gt; ACL GENPASS 5</span><br><span class=\"line\"><span class=\"string\">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis ACL 简介 从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。 ACL 可以控制的维度包括： 谁能登录（用户、密码） 可以执行哪些命令 可以访问哪些 key（按前缀 / 正则） 可否通过网络访问 是否启用 / 禁用某个用户 一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离 Redis ACL 的使用 在 redis.conf 中添加如下内容： 1234# 指定 ACL 文件aclfile /etc/redis/users.acl# 关闭 密码# requirepass foobared 也可以不配置 aclfile，而是将用户信息直接编写在 redis.conf 中，但不建议这样做。 ACL 的配置方式 直接编辑 aclfile 创建一个 users.acl 文件，并写入如下内容： 123456# 配置一个管理员user admin on ~* &amp;* +@all &gt;password# 配置一个应用用户user appuser on ~cache:* &amp;app:* +get +set &gt;password# 配置一个只读用户user readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。 格式说明 1234567user: 固定前缀username: 用户名on: 启用 off: 禁用~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格 为了兼容以前的版本，Redis 提供了一个默认的用户：default，不指定用户名的时候，默认使用的就是 default 用户，其对应的acl权限为 1234# 实际上就是一个超级管理员权限user default on nopass sanitize-payload ~* &amp;* +@all# 如果设置了 requirepass 密码user default on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all 开启ACL后，推荐关闭 default 用户。 12# 关闭默认用户，禁止匿名访问user default off 登录redis 12345678910111213# 连接时直接登录, --pass == -aredis-cli --user username --pass password -h host -p port# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 本机登录redis-cli -u redis://admin:123456@# 本机登录时端口不是默认的6379时redis-cli -u redis://admin:123456@:6380# 先连接后登录redis-cli -h host -p port&gt; auth username password Redis ACL 规则中文说明 规则 / 语法 中文说明 on 启用用户：可以使用该用户进行认证登录 off 禁用用户：无法再使用该用户认证，但已认证的连接仍然有效 skip-sanitize-payload 跳过对 RESTORE 命令的 dump 数据载荷过滤（跳过安全检查） sanitize-payload 对 RESTORE 命令的 dump 数据载荷进行过滤（默认） +&lt;command&gt; 允许执行指定命令；可以指定子命令，例如：+config | get -&lt;command&gt; 禁止执行指定命令；可以指定子命令，例如：-config | set +@&lt;category&gt; 允许一个命令分类的所有命令，如：@admin, @set, @sortedset 等。完整分类在 server.c 的命令表中 @all 特殊分类，表示所有当前已有命令 + 未来模块加载的命令 +&lt;command&gt;|first-arg 只允许使用某命令的第一个参数（已废弃，将可能移除）；只支持新增，不支持禁止（如 -SELECT|1 不允许） allcommands +@all 的别名，允许所有命令（包括将来可能加载的模块命令） nocommands -@all 的别名，禁止所有命令 ~&lt;pattern&gt; 添加允许访问的 key 模式（glob 风格），如：~user:*；可以有多个 %R~&lt;pattern&gt; 添加允许读取的 key 模式 %W~&lt;pattern&gt; 添加允许写入的 key 模式 allkeys ~* 的别名，允许所有 key resetkeys 清空允许访问的 key 模式 &amp;&lt;pattern&gt; 添加可访问的 Pub/Sub channel 模式（glob 风格），可多个 allchannels &amp;* 的别名，允许所有 channel resetchannels 清空 Pub/Sub channel 模式列表 &gt;&lt;password&gt; 添加密码，例如：&gt;mypass；此指令会清除 nopass 标志 &lt;&lt;password&gt; 移除指定密码 nopass 移除所有密码，且任何密码都可登录。如果用于 default 用户，则新连接无需 AUTH 即自动登录为 default resetpass 清空所有密码，并移除 nopass 状态。此后没有密码将无法认证 reset 重置所有设置：包括 resetpass、resetkeys、resetchannels、allchannels（如果开启 acl-pubsub-default）、off、clearseletors、-@all (&lt;options&gt;) 创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则 clearselectors 删除所有 selector，但不会影响根权限（直接赋给用户的权限） 通过 ACL 命令 ACL SETUSER 创建/修改用户 12345678# 关闭 default 用户ACL SETUSER default off# 创建一个管理员ACL SETUSER admin on ~* &amp;* +@all &gt;password# 创建一个普通用户ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +set# 创建一个只读用户ACL SETUSER readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 可以看的出来，ACL SETUSER 后面的命令格式与直接编辑 users.acl 文件是一样的 这里要注意 ACL SETUSER 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如： 1234# 第一次执行ACL SETUSER testuser on ~* -@all +@read +ping &gt;password# 第二次执行，只添加新的权限ACL SETUSER testuser +info +client +config|get 运行后的结果 1&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 修改用户权限 重置权限 1234# 重置所有权限ACL SETUSER testuser reset## 运行结果：去除所有频道和命令权限，禁止登录&quot;user testuser off sanitize-payload resetchannels -@all&quot; 取消密码，但保留权限 123ACL SETUSER testuser nopass## 运行结果：取消密码&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot; 去除所有频道 1ACL SETUSER testuser resetchannels 去除所有selectors，关于selectors后面会详细介绍 1ACL SETUSER testuser clearselectors ACL LIST 可以通过如下命令查看当前 Redis 中所有的用户 123456ACL LIST## 输出1) &quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;2) &quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;3) &quot;user default off sanitize-payload resetchannels -@all&quot;4) &quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式 123456789user: 固定前缀username: 用户名on: 启用sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 keyresetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令 ACL LOAD 当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 users.acl 文件中 1ACL SAVE 此时保存的文件内容就是 ACL LIST 命令的输出 ACL SAVE 当修改了 users.acl 文件后，可以通过如下命令将其重新加载到 Redis 中 1ACL LOAD ACL USERS 列出所有已创建的用户 123456ACL USERS## 输出1) &quot;admin&quot;2) &quot;appuser&quot;3) &quot;default&quot;4) &quot;readonly&quot; ACL GETUSER 获取指定用户的权限信息 123456789101112131415ACL GETUSER appuser## 输出1) &quot;flags&quot; 2) 1) &quot;on&quot; 2) &quot;sanitize-payload&quot; 3) &quot;passwords&quot; 4) 1) &quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot; 5) &quot;commands&quot; 6) &quot;-@all +get +set&quot; 7) &quot;keys&quot; 8) &quot;~cache:*&quot; 9) &quot;channels&quot;10) &quot;&amp;app:*&quot;11) &quot;selectors&quot;12) (empty array) selectors(选择器规则) 这里看到最后有一个selectors，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。 以前 = 一个用户一条规则 12# 根权限（全局规则）ACL SETUSER selectoruser on ~cache:* +get +set 现在 = 一个用户可以有多个“权限分身” 12345# 选择器规则# 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +set) &gt;123456## 翻译后的结果&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot; &gt;123456 如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。 ACL DELUSER 删除一个用户 1ACL DELUSER 用户名 ACL WHOAMI 获取当前登录的用户名 1ACL WHOAMI ACL CAT 获取所有权限类别 前面我们在为用户授权时介绍过，@ 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。 ACL CAT 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。 1234# 获取所有权限类别ACL CAT# 获取指定类别中的命令列表ACL CAT 分类名称 这里有一个特殊的权限类别 @all 并不在列出的权限类别中，其表示所有命令。 ACL DRYRUN ACL DRYRUN 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。 Redis 7.0.0 新增。 123456&gt; ACL SETUSER VIRGINIA +SET ~*&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA SET foo bar&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA GET foo&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot; ACL LOG ACL LOG 命令可以查看 ACL 命令执行日志。 它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。 12ACL LOG # 查看默认最新的 ACL 日志条目ACL LOG RESET # 清空 ACL 日志 日志格式 123456789101) &quot;count&quot; =&gt; 1 2) &quot;reason&quot; =&gt; &quot;command&quot; 3) &quot;context&quot; =&gt; &quot;toplevel&quot; 4) &quot;object&quot; =&gt; &quot;acl|log&quot; 5) &quot;username&quot; =&gt; &quot;selectoruser&quot; 6) &quot;age-seconds&quot; =&gt; 1589.819 7) &quot;client-info&quot; =&gt; &quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot; 8) &quot;entry-id&quot; =&gt; 3 9) &quot;timestamp-created&quot; =&gt; 1765089007352 10) &quot;timestamp-last-updated&quot; =&gt; 1765089007352 字段 含义 count 触发该日志的次数。比如同一事件触发 1 次就是 1 reason 日志触发的原因，通常是 command 表示某个命令被执行或被 ACL 检查 context 执行命令的上下文，toplevel 表示直接在客户端执行 object 触发事件的对象，例如 acl|log表示执行了ACL LOG 命令，acl|list表示执行了ACL LIST username 触发事件的用户 age-seconds 事件距离当前的时间（秒），越大表示越久远 client-info 客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等 entry-id 日志条目 ID timestamp-created 日志创建时间（毫秒） timestamp-last-updated 日志最后更新时间（毫秒） ACL GENPASS 生成一个随机的 ACL 密码 生成复杂密码的工具有很多，没必要用这玩意。 该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。 123456789# 默认64个十六进制字符，相当于 ACL GENPASS 256&gt; ACL GENPASS&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;# 指定长度，32/4 = 8&gt; ACL GENPASS 32&quot;355ef3dd&quot;# 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2&gt; ACL GENPASS 5&quot;90&quot;","summary":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-07T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","url":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","title":"Redis 7 + ACL 单节点、主从、哨兵、集群构建方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">传统的非ACL版本，可以参考 <a href=\"/2022/09/09/redis5-config/\" title=\"Redis单节点、主从、哨兵、集群构建方法\">Redis单节点、主从、哨兵、集群构建方法</a></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"redis安装\">redis安装</h2>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载到指定目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft</span><br><span class=\"line\">tar -zxvf redis-7.4.7.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install gcc gcc-c++ -y</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-7.4.7</span><br><span class=\"line\"><span class=\"comment\"># 编译，会将编译好的可执行文件放在src目录下</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir</span><br><span class=\"line\">make install PREFIX=$(<span class=\"built_in\">pwd</span>)/build_dir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> redis.conf redis-6379.conf</span><br><span class=\"line\">vim redis-6379.conf <span class=\"comment\">#见下面的配置信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">redis-cli --version</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">redis-cli 7.4.7</span><br></pre></td></tr></table></figure>\n<h2 id=\"单节点\">单节点</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis-6379.conf 的主要配置</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认 6379</span></span><br><span class=\"line\">port 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动，默认 no</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yes: 当没有 bind / requirepass / ACL 时，只允许本机访问</span></span><br><span class=\"line\"><span class=\"comment\"># no: 允许任意访问</span></span><br><span class=\"line\"><span class=\"comment\"># 这里会启用ACL，所以设置为 yes，默认 yes</span></span><br><span class=\"line\">protected-mode <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置</span></span><br><span class=\"line\"><span class=\"comment\">#bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 可以配置为，本机IP 内网IP 外网IP</span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1 10.250.0.103 18.163.188.20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照</span></span><br><span class=\"line\"><span class=\"comment\"># 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件</span></span><br><span class=\"line\">save <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no</span></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复</span></span><br><span class=\"line\"><span class=\"comment\"># 生成环境必须开启</span></span><br><span class=\"line\">appendonly <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># aof文件名称，默认 appendonly.aof</span></span><br><span class=\"line\">appendfilename <span class=\"string\">&quot;appendonly.aof&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir</span></span><br><span class=\"line\"><span class=\"comment\"># redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.incr.aof：记录每个写操作命令</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)</span></span><br><span class=\"line\">appenddirname <span class=\"string\">&quot;appendonlydir&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysec</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令</span></span><br><span class=\"line\"><span class=\"comment\"># 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令</span></span><br><span class=\"line\"><span class=\"comment\"># 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mb</span></span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br><span class=\"line\"><span class=\"comment\"># aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aof</span></span><br><span class=\"line\">aof-use-rdb-preamble <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 防止 AOF 意外截断导致 Redis 起不来，默认 yes</span></span><br><span class=\"line\">aof-load-truncated <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径，默认 /var/run/redis_6379.pid</span></span><br><span class=\"line\">pidfile <span class=\"string\">&quot;redis_6379.pid&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称，默认 &quot;&quot;</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;6379.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定最大内存，单位bytes，这里设置4G</span></span><br><span class=\"line\"><span class=\"comment\"># 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降</span></span><br><span class=\"line\">maxmemory 4294967296</span><br><span class=\"line\"><span class=\"comment\"># 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间</span></span><br><span class=\"line\"><span class=\"comment\"># volatile-lru: 只会淘汰「设置了过期时间」的 key</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的</span></span><br><span class=\"line\"><span class=\"comment\"># noeviction: 不淘汰，默认</span></span><br><span class=\"line\">maxmemory-policy allkeys-lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 慢查询日志</span></span><br><span class=\"line\"><span class=\"comment\"># 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来</span></span><br><span class=\"line\">slowlog-log-slower-than 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录</span></span><br><span class=\"line\">slowlog-max-len 1024</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 性能优化</span></span><br><span class=\"line\"><span class=\"comment\"># Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了</span></span><br><span class=\"line\">io-threads 4</span><br><span class=\"line\"><span class=\"comment\"># 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端</span></span><br><span class=\"line\"><span class=\"comment\"># 推荐&gt;=4核才开启，否则开了反而更慢</span></span><br><span class=\"line\">io-threads-do-reads <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着</span></span><br><span class=\"line\">tcp-keepalive 60</span><br><span class=\"line\"><span class=\"comment\"># 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0</span></span><br><span class=\"line\"><span class=\"comment\"># 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放</span></span><br><span class=\"line\"><span class=\"built_in\">timeout</span> 0</span><br><span class=\"line\"><span class=\"comment\"># 最大客户端连接数，默认 10000</span></span><br><span class=\"line\">maxclients 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令</span></span><br><span class=\"line\">rename-command FLUSHALL <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">rename-command FLUSHDB <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SHUTDOWN &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command CONFIG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command KEYS &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command BGSAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command DEBUG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command EVAL &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SCRIPT &quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启 ACL 文件</span></span><br><span class=\"line\">aclfile /usr/local/soft/redis-7.4.7/users.acl</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 7 支持的淘汰策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>是否只淘汰带 TTL 的 key</th>\n<th>淘汰规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>noeviction</strong></td>\n<td>❌ 不淘汰</td>\n<td>不删任何 key</td>\n<td>内存满了直接返回错误（默认）</td>\n</tr>\n<tr>\n<td><strong>allkeys-lru</strong></td>\n<td>❌ 所有 key</td>\n<td>最近最久未使用</td>\n<td>✅ 最常用</td>\n</tr>\n<tr>\n<td><strong>allkeys-lfu</strong></td>\n<td>❌ 所有 key</td>\n<td>访问频率最少</td>\n<td>✅ 热点场景最好</td>\n</tr>\n<tr>\n<td><strong>allkeys-random</strong></td>\n<td>❌ 所有 key</td>\n<td>随机删除</td>\n<td>❌ 很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-lru</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>最近最久未使用</td>\n<td>你之前用的</td>\n</tr>\n<tr>\n<td><strong>volatile-lfu</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>访问频率最少</td>\n<td>较少使用</td>\n</tr>\n<tr>\n<td><strong>volatile-random</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>随机删除</td>\n<td>很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-ttl</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>TTL 最小（马上过期的）</td>\n<td>特殊场景用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>users.acl 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 <a href=\"/2025/12/07/redis7-acl/\" title=\"Redis 7 + ACL 简介\">Redis 7 + ACL 简介</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br><span class=\"line\"><span class=\"comment\"># 超级管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis 服务启动与关闭</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">redis-server redis-6379.conf</span><br><span class=\"line\"><span class=\"comment\"># 登录服务，本机访问可以省略 -h -p</span></span><br><span class=\"line\">redis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭服务</span></span><br><span class=\"line\"><span class=\"comment\"># shutdown == shutdown save</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown</span><br><span class=\"line\"><span class=\"comment\"># 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正常下线（生产）</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>已开 AOF</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>数据很大</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>单机调试</td>\n<td><code>shutdown</code></td>\n</tr>\n<tr>\n<td>确定要生成快照</td>\n<td><code>shutdown save</code></td>\n</tr>\n<tr>\n<td>强制杀死(redis卡死)</td>\n<td><code>kill -9</code>（极端情况）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"单节点优点\">单节点优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单机部署简单方便</p>\n</li>\n</ul>\n<h3 id=\"单节点缺点\">单节点缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不保证数据的可靠性，不适用于数据可靠性要求高的场景</p>\n</li>\n<li class=\"lvl-2\">\n<p>单点故障导致无法提供服务，或者硬盘损坏导致数据丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流</p>\n</li>\n</ul>\n<h2 id=\"主从\">主从</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从配置时，主节点不需要做任何修改</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点配置文件增加同步主节点信息，其余配置与主节点相同</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号</span></span><br><span class=\"line\">replicaof 10.250.0.235 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致</span></span><br><span class=\"line\">replica-read-only <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时启动从节点<code>redis-server redis-6379.conf</code>，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时登录master的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master     <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">connected_slaves:1 <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 <span class=\"comment\"># 从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点切换状态，无</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:56  <span class=\"comment\"># 主节点复制的偏移量</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1  <span class=\"comment\"># 是否开启复制回放</span></span><br><span class=\"line\">repl_backlog_size:1048576 <span class=\"comment\"># 复制回放缓冲区大小</span></span><br><span class=\"line\">repl_backlog_first_byte_offset:1 <span class=\"comment\"># 复制回放缓冲区第一个字节的偏移量</span></span><br><span class=\"line\">repl_backlog_histlen:56 <span class=\"comment\"># 复制回放缓冲区历史长度</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时登录从节点的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave               <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">master_host:10.250.0.235 <span class=\"comment\"># 主节点的ip</span></span><br><span class=\"line\">master_port:6379         <span class=\"comment\"># 主节点的端口</span></span><br><span class=\"line\">master_link_status:up    <span class=\"comment\"># 主从节点连接状态，up 表示已经连接上主节点</span></span><br><span class=\"line\">master_last_io_seconds_ago:6 <span class=\"comment\"># 主从节点最后一次io操作时间</span></span><br><span class=\"line\">master_sync_in_progress:0 <span class=\"comment\"># 主从节点是否正在同步数据，0表示已完成</span></span><br><span class=\"line\">slave_read_repl_offset:112 <span class=\"comment\"># 从节点已经读取的复制偏移量</span></span><br><span class=\"line\">slave_repl_offset:112   <span class=\"comment\"># 从节点已经写入的复制偏移量</span></span><br><span class=\"line\">slave_priority:100      <span class=\"comment\"># 从节点的优先级</span></span><br><span class=\"line\">slave_read_only:1       <span class=\"comment\"># 从节点是否只读</span></span><br><span class=\"line\">replica_announced:1     <span class=\"comment\"># 从节点是否被其他节点所代理</span></span><br><span class=\"line\">connected_slaves:0      <span class=\"comment\"># 从节点所代理的从节点数量</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点的故障转移状态，no-failover表示没有进行故障转移</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:112  <span class=\"comment\"># 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:15</span><br><span class=\"line\">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从数据同步是否完成判断规则，在从节点上执行命令<code>info replication</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>正常值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>role</code></td>\n<td>slave</td>\n<td>表示当前是从节点</td>\n</tr>\n<tr>\n<td><code>master_link_status</code></td>\n<td>up</td>\n<td>表示已经连上主库</td>\n</tr>\n<tr>\n<td><code>master_sync_in_progress</code></td>\n<td>0</td>\n<td>同步不在进行中 = 已完成</td>\n</tr>\n<tr>\n<td><code>slave_read_repl_offset</code> ≈ <code>master_repl_offset</code></td>\n<td>接近</td>\n<td>说明数据已追上</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参照上面的配置，再添加一个从节点后，在主节点执行命令 <code>info replication</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2  <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0</span><br><span class=\"line\">slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0  <span class=\"comment\"># 第二个从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover</span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67</span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:4313</span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:1</span><br><span class=\"line\">repl_backlog_histlen:4313</span><br></pre></td></tr></table></figure>\n<h3 id=\"主从优点\">主从优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对请求进行读写分离，提高处理效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以提供多个副本，提高数据安全性</p>\n</li>\n</ul>\n<h3 id=\"主从缺点\">主从缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p>\n</li>\n</ul>\n<h2 id=\"哨兵\">哨兵</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br><span class=\"line\">sentinel1 10.250.0.71</span><br><span class=\"line\">sentinel2 10.250.0.131</span><br><span class=\"line\">sentinel3 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别编辑各自的 <code>sentinel.conf</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口号</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir，需要提前创建好</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/sentinel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径</span></span><br><span class=\"line\">pidfile redis-sentinel.pid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;sentinel.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1</span></span><br><span class=\"line\">sentinel monitor mymaster 10.250.0.235 6379 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主观下线时间（5秒），默认30秒</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 故障转移超时时间 60秒，默认180秒</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 60000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每次允许多少个slave重新同步，默认就是 1</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># acl用户名和密码，这里为了方便也是用的管理员帐号</span></span><br><span class=\"line\">sentinel auth-user mymaster admin</span><br><span class=\"line\">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动三个哨兵节点<code>redis-sentinel sentinel.conf</code>，此时登录哨兵节点<code>redis-cli -p 26379</code>，并执行<code>info Sentinel</code>命令，查看其是否正确识别了主从</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sentinel</span></span><br><span class=\"line\">sentinel_masters:1      <span class=\"comment\"># 哨兵集群中主从节点的数量</span></span><br><span class=\"line\">sentinel_tilt:0         <span class=\"comment\"># 是否处于 tilt 状态</span></span><br><span class=\"line\">sentinel_tilt_since_seconds:-1 <span class=\"comment\"># tilt 状态的开始时间</span></span><br><span class=\"line\">sentinel_running_scripts:0 <span class=\"comment\"># 正在运行的脚本数量</span></span><br><span class=\"line\">sentinel_scripts_queue_length:0 <span class=\"comment\"># 脚本队列长度</span></span><br><span class=\"line\">sentinel_simulate_failure_flags:0 <span class=\"comment\"># 模拟故障的标志</span></span><br><span class=\"line\">master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 <span class=\"comment\"># 主节点的地址，从节点数量和哨兵数量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>sentinel.conf</code>可以在文件最后看到从节点信息和其它的哨兵节点信息(<em><strong>但实测无法感知其它哨兵节点</strong></em>)，类似于</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9  <span class=\"comment\"># 延迟追踪信息百分比</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all <span class=\"comment\"># 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码</span></span><br><span class=\"line\">sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 <span class=\"comment\"># 本节点的id</span></span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br><span class=\"line\">sentinel current-epoch 0</span><br><span class=\"line\"><span class=\"comment\"># 一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.58 6379</span><br><span class=\"line\"><span class=\"comment\"># 另一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.36 6379</span><br><span class=\"line\"><span class=\"comment\"># 一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a</span><br><span class=\"line\"><span class=\"comment\"># 另一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看<code>info Sentinel</code>，就会发现master节点变成了从节点其中的一个了</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9</span><br><span class=\"line\">replicaof 10.250.0.36 6379</span><br><span class=\"line\">save 3600 1</span><br><span class=\"line\">save 300 100</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>顺便说一下，关闭哨兵服务的命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -p 26379 shutdown</span><br></pre></td></tr></table></figure>\n<h3 id=\"哨兵优点\">哨兵优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主节点故障，可以自动在从节点中重新选主</p>\n</li>\n</ul>\n<h3 id=\"哨兵缺点\">哨兵缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离</p>\n</li>\n</ul>\n<h2 id=\"集群\">集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>搭建6个redis的集群，3主3从</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis1 10.250.0.235</span><br><span class=\"line\">redis2 10.250.0.58</span><br><span class=\"line\">redis3 10.250.0.36</span><br><span class=\"line\">redis4 10.250.0.71</span><br><span class=\"line\">redis5 10.250.0.131</span><br><span class=\"line\">redis6 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ACL认证，所有节点都要配置</span></span><br><span class=\"line\">masteruser <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">masterauth <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动集群模式</span></span><br><span class=\"line\">cluster-enabled <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点信息文件，这里最好和port对应上</span></span><br><span class=\"line\">cluster-config-file nodes-6379.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰</span></span><br><span class=\"line\">cluster-node-timeout 15000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置</span></span><br><span class=\"line\"><span class=\"comment\"># 开启这个配置可以预防集群脑裂问题，默认为3</span></span><br><span class=\"line\">min-replicas-to-write 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能</span></span><br><span class=\"line\"><span class=\"comment\"># 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败</span></span><br><span class=\"line\">cluster-require-full-coverage <span class=\"built_in\">yes</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动6个redis服务</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(<em><strong>删除dir配置的目录中的所有文件即可</strong></em>)，然后在任意一个redis执行</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时会列出集群内主从和槽位的分配方案，输入<code>yes</code>即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: Using a password with <span class=\"string\">&#x27;-a&#x27;</span> or <span class=\"string\">&#x27;-u&#x27;</span> option on the <span class=\"built_in\">command</span> line interface may not be safe.</span><br><span class=\"line\">&gt;&gt;&gt; Performing <span class=\"built_in\">hash</span> slots allocation on 6 nodes...</span><br><span class=\"line\">Master[0] -&gt; Slots 0 - 5460</span><br><span class=\"line\">Master[1] -&gt; Slots 5461 - 10922</span><br><span class=\"line\">Master[2] -&gt; Slots 10923 - 16383</span><br><span class=\"line\">Adding replica 10.250.0.131:6379 to 10.250.0.235:6379</span><br><span class=\"line\">Adding replica 10.250.0.63:6379 to 10.250.0.58:6379</span><br><span class=\"line\">Adding replica 10.250.0.71:6379 to 10.250.0.36:6379</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">Can I <span class=\"built_in\">set</span> the above configuration? (<span class=\"built_in\">type</span> <span class=\"string\">&#x27;yes&#x27;</span> to accept): <span class=\"built_in\">yes</span></span><br><span class=\"line\">&gt;&gt;&gt; Nodes configuration updated</span><br><span class=\"line\">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class=\"line\">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class=\"built_in\">join</span> the cluster</span><br><span class=\"line\">Waiting <span class=\"keyword\">for</span> the cluster to <span class=\"built_in\">join</span></span><br><span class=\"line\">.</span><br><span class=\"line\">&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">[OK] All nodes agree about slots configuration.</span><br><span class=\"line\">&gt;&gt;&gt; Check <span class=\"keyword\">for</span> open slots...</span><br><span class=\"line\">&gt;&gt;&gt; Check slots coverage...</span><br><span class=\"line\">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录集群并查询集群配置信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -c 表示以集群模式登录，-h 集群内任意ip</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456 -c -h 10.250.0.235</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster info</span><br><span class=\"line\"><span class=\"comment\"># 输出集群状态</span></span><br><span class=\"line\">cluster_state:ok                                <span class=\"comment\"># 集群整体状态：ok 表示集群当前可用、健康</span></span><br><span class=\"line\">cluster_slots_assigned:16384                    <span class=\"comment\"># 已分配的哈希槽数量（总槽数固定为 16384）</span></span><br><span class=\"line\">cluster_slots_ok:16384                          <span class=\"comment\"># 正常工作的槽数量（等于已分配槽，说明全部正常）</span></span><br><span class=\"line\">cluster_slots_pfail:0                           <span class=\"comment\"># 处于“疑似失败(pfail)”状态的槽数量</span></span><br><span class=\"line\">cluster_slots_fail:0                            <span class=\"comment\"># 被判定为失败(fail)的槽数量</span></span><br><span class=\"line\">cluster_known_nodes:6                           <span class=\"comment\"># 当前节点已知的集群节点总数（主节点 + 从节点）</span></span><br><span class=\"line\">cluster_size:3                                  <span class=\"comment\"># 主节点数量（3 主节点，典型的 3 主 3 从结构）</span></span><br><span class=\"line\">cluster_current_epoch:6                         <span class=\"comment\"># 集群当前的全局纪元（用于选举和配置同步）</span></span><br><span class=\"line\">cluster_my_epoch:1                              <span class=\"comment\"># 当前这个节点所在的纪元</span></span><br><span class=\"line\">cluster_stats_messages_ping_sent:159           <span class=\"comment\"># 当前节点已发送的 PING 消息数量（心跳）</span></span><br><span class=\"line\">cluster_stats_messages_pong_sent:156           <span class=\"comment\"># 当前节点已发送的 PONG 消息数量（心跳响应）</span></span><br><span class=\"line\">cluster_stats_messages_sent:315                <span class=\"comment\"># 当前节点发送的所有集群消息总数</span></span><br><span class=\"line\">cluster_stats_messages_ping_received:151       <span class=\"comment\"># 当前节点收到的 PING 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_pong_received:159       <span class=\"comment\"># 当前节点收到的 PONG 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_meet_received:5         <span class=\"comment\"># 当前节点收到的 MEET 消息数量（新节点加入发现）</span></span><br><span class=\"line\">cluster_stats_messages_received:315            <span class=\"comment\"># 当前节点收到的所有集群消息总数</span></span><br><span class=\"line\">total_cluster_links_buffer_limit_exceeded:0    <span class=\"comment\"># 因输出缓冲区超限被强制断开的集群连接数（0 = 正常）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看节点列表</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\"># 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）</span></span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）</span></span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）</span></span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 10923-16383（集群中第三段槽位）</span></span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 5461-10922（集群中第二段槽位）</span></span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>nodes-6379.conf</code>也会看到和上面一样的节点信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时关闭其中一个master节点，比如<code>10.250.0.36</code>，则其对应的slave节点<code>10.250.0.71</code>会切换为新的master节点，此时<code>10.250.0.36</code>的状态最终变为<code>fail</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再次启动<code>10.250.0.36</code>，其会变成<code>10.250.0.71</code>的slave节点</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HASH_SLOT=CRC16(key) mod 16384</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 跳转重定位</span></span><br><span class=\"line\">10.250.0.235:6379&gt; <span class=\"built_in\">set</span> name zhangsan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">-&gt; Redirected to slot [5798] located at 10.250.0.58:6379</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关闭集群，6个redis分别关闭</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启集群，6个redis分别启动即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mset/mget要求key都落在同一个slot上，每个key都加上前缀<code>&#123;prefix&#125;</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; mset name1 lisi name2 wangwu</span><br><span class=\"line\">(error) CROSSSLOT Keys <span class=\"keyword\">in</span> request don<span class=\"string\">&#x27;t hash to the same slot</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwu</span></span><br><span class=\"line\"><span class=\"string\">OK</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2</span></span><br><span class=\"line\"><span class=\"string\">-&gt; Redirected to slot [5474] located at 10.250.0.58:6379</span></span><br><span class=\"line\"><span class=\"string\">1) &quot;lisi&quot;</span></span><br><span class=\"line\"><span class=\"string\">2) &quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群通过<code>10000+port</code>这个端口号进行集群间通信，所以除了要开放<code>prot</code>这个端口，还要开放<code>10000+port</code>这个端口</p>\n</li>\n<li class=\"lvl-2\">\n<p>有关redis集群及其水平扩展的进一步说明，可以参看<a href=\"/2018/12/27/redis-cluster/\" title=\"Redis集群\">Redis集群</a></p>\n</li>\n</ul>\n<h3 id=\"集群优点\">集群优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无中心架构，集群内部自行维护数据的分片和主从的切换</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据分片存储，提供很高的访问效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>高可用性，可实现部分节点不可用时，集群仍可用</p>\n</li>\n<li class=\"lvl-2\">\n<p>高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持</p>\n</li>\n</ul>\n<h3 id=\"集群缺点\">集群缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据通过异步复制，不保证数据的强一致性</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能</p>\n</li>\n<li class=\"lvl-2\">\n<p>不建议使用pipeline和multi-keys操作</p>\n</li>\n</ul>\n","content_text":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/ redis安装 1234567891011121314151617181920212223242526272829# 下载到指定目录mkdir -p /usr/local/softwget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft# 解压cd /usr/local/softtar -zxvf redis-7.4.7.tar.gz# 编译sudo yum install gcc gcc-c++ -ycd redis-7.4.7# 编译，会将编译好的可执行文件放在src目录下make# 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下mkdir build_dirmake install PREFIX=$(pwd)/build_dir# 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件cp redis.conf redis-6379.confvim redis-6379.conf #见下面的配置信息# 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析echo &#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27; &gt;&gt; /etc/bashrcsource /etc/bashrc# 验证redis-cli --version# 输出redis-cli 7.4.7 单节点 redis-6379.conf 的主要配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# 端口，默认 6379port 6379# 后台启动，默认 nodaemonize yes# yes: 当没有 bind / requirepass / ACL 时，只允许本机访问# no: 允许任意访问# 这里会启用ACL，所以设置为 yes，默认 yesprotected-mode yes# 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置#bind 127.0.0.1# 可以配置为，本机IP 内网IP 外网IP# bind 127.0.0.1 10.250.0.103 18.163.188.20# 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照# 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件save &quot;&quot;# 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录dir /usr/local/soft/dir-redis7/6379# 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no# 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复# 生成环境必须开启appendonly yes# aof文件名称，默认 appendonly.aofappendfilename &quot;appendonly.aof&quot;# aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir# redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：# appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件# appendonly.aof.N.incr.aof：记录每个写操作命令# appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)appenddirname &quot;appendonlydir&quot;# aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysecappendfsync everysec# 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令# 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb# 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令# 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb# aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mbauto-aof-rewrite-min-size 64mb# aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100auto-aof-rewrite-percentage 100# 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes# 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aofaof-use-rdb-preamble yes# 防止 AOF 意外截断导致 Redis 起不来，默认 yesaof-load-truncated yes# pid文件路径，默认 /var/run/redis_6379.pidpidfile &quot;redis_6379.pid&quot;# 日志文件名称，默认 &quot;&quot;logfile &quot;6379.log&quot;# 指定最大内存，单位bytes，这里设置4G# 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降maxmemory 4294967296# 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间# volatile-lru: 只会淘汰「设置了过期时间」的 key# allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的# allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的# noeviction: 不淘汰，默认maxmemory-policy allkeys-lru# 慢查询日志# 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来slowlog-log-slower-than 10000# 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录slowlog-max-len 1024# 性能优化# Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了io-threads 4# 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端# 推荐&gt;=4核才开启，否则开了反而更慢io-threads-do-reads yes# 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着tcp-keepalive 60# 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0# 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放timeout 0# 最大客户端连接数，默认 10000maxclients 10000# 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;# rename-command SHUTDOWN &quot;&quot;# rename-command CONFIG &quot;&quot;# rename-command KEYS &quot;&quot;# rename-command SAVE &quot;&quot;# rename-command BGSAVE &quot;&quot;# rename-command DEBUG &quot;&quot;# rename-command EVAL &quot;&quot;# rename-command SCRIPT &quot;&quot;# 开启 ACL 文件aclfile /usr/local/soft/redis-7.4.7/users.acl Redis 7 支持的淘汰策略 策略 是否只淘汰带 TTL 的 key 淘汰规则 说明 noeviction ❌ 不淘汰 不删任何 key 内存满了直接返回错误（默认） allkeys-lru ❌ 所有 key 最近最久未使用 ✅ 最常用 allkeys-lfu ❌ 所有 key 访问频率最少 ✅ 热点场景最好 allkeys-random ❌ 所有 key 随机删除 ❌ 很少用 volatile-lru ✅ 只淘汰有 TTL 的 最近最久未使用 你之前用的 volatile-lfu ✅ 只淘汰有 TTL 的 访问频率最少 较少使用 volatile-random ✅ 只淘汰有 TTL 的 随机删除 很少用 volatile-ttl ✅ 只淘汰有 TTL 的 TTL 最小（马上过期的） 特殊场景用 users.acl 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 Redis 7 + ACL 简介 1234# 关闭默认用户，禁止匿名访问user default off# 超级管理员user admin on ~* &amp;* +@all &gt;123456 redis 服务启动与关闭 123456789101112# 启动服务redis-server redis-6379.conf# 登录服务，本机访问可以省略 -h -predis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 关闭服务# shutdown == shutdown saveredis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown# 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave 场景 推荐命令 正常下线（生产） shutdown nosave 已开 AOF shutdown nosave 数据很大 shutdown nosave 单机调试 shutdown 确定要生成快照 shutdown save 强制杀死(redis卡死) kill -9（极端情况） 单节点优点 单机部署简单方便 单节点缺点 不保证数据的可靠性，不适用于数据可靠性要求高的场景 单点故障导致无法提供服务，或者硬盘损坏导致数据丢失 redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流 主从 规划 123master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36 主从配置时，主节点不需要做任何修改 从节点配置文件增加同步主节点信息，其余配置与主节点相同 123456789# 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号replicaof 10.250.0.235 6379# 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致replica-read-only yes# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 此时启动从节点redis-server redis-6379.conf，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步 主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点 主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点 从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式 此时登录master的redis并执行info replication命令 12345678910111213# Replicationrole:master # 表示当前是从节点connected_slaves:1 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 # 从节点信息master_failover_state:no-failover # 主节点切换状态，无master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:56 # 主节点复制的偏移量second_repl_offset:-1repl_backlog_active:1 # 是否开启复制回放repl_backlog_size:1048576 # 复制回放缓冲区大小repl_backlog_first_byte_offset:1 # 复制回放缓冲区第一个字节的偏移量repl_backlog_histlen:56 # 复制回放缓冲区历史长度 此时登录从节点的redis并执行info replication命令 12345678910111213141516171819202122# Replicationrole:slave # 表示当前是从节点master_host:10.250.0.235 # 主节点的ipmaster_port:6379 # 主节点的端口master_link_status:up # 主从节点连接状态，up 表示已经连接上主节点master_last_io_seconds_ago:6 # 主从节点最后一次io操作时间master_sync_in_progress:0 # 主从节点是否正在同步数据，0表示已完成slave_read_repl_offset:112 # 从节点已经读取的复制偏移量slave_repl_offset:112 # 从节点已经写入的复制偏移量slave_priority:100 # 从节点的优先级slave_read_only:1 # 从节点是否只读replica_announced:1 # 从节点是否被其他节点所代理connected_slaves:0 # 从节点所代理的从节点数量master_failover_state:no-failover # 主节点的故障转移状态，no-failover表示没有进行故障转移master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112 # 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:15repl_backlog_histlen:98 主从数据同步是否完成判断规则，在从节点上执行命令info replication 字段 正常值 说明 role slave 表示当前是从节点 master_link_status up 表示已经连上主库 master_sync_in_progress 0 同步不在进行中 = 已完成 slave_read_repl_offset ≈ master_repl_offset 接近 说明数据已追上 参照上面的配置，再添加一个从节点后，在主节点执行命令 info replication 1234567891011121314# Replicationrole:masterconnected_slaves:2 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0 # 第二个从节点信息master_failover_state:no-failovermaster_replid:93e564c18d27418e52fc40254c764d76c1dc3f67master_replid2:0000000000000000000000000000000000000000master_repl_offset:4313second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:4313 主从优点 对请求进行读写分离，提高处理效率 可以提供多个副本，提高数据安全性 主从缺点 不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预 哨兵 创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵 规划 123456master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36sentinel1 10.250.0.71sentinel2 10.250.0.131sentinel3 10.250.0.63 分别编辑各自的 sentinel.conf 123456789101112131415161718192021222324252627282930# 端口号port 26379# 后台启动daemonize yes# dir，需要提前创建好dir /usr/local/soft/dir-redis7/sentinel# pid文件路径pidfile redis-sentinel.pid# 日志文件名称logfile &quot;sentinel.log&quot;# 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1sentinel monitor mymaster 10.250.0.235 6379 2# 主观下线时间（5秒），默认30秒sentinel down-after-milliseconds mymaster 5000# 故障转移超时时间 60秒，默认180秒sentinel failover-timeout mymaster 60000# 每次允许多少个slave重新同步，默认就是 1sentinel parallel-syncs mymaster 1# acl用户名和密码，这里为了方便也是用的管理员帐号sentinel auth-user mymaster adminsentinel auth-pass mymaster 123456 分别启动三个哨兵节点redis-sentinel sentinel.conf，此时登录哨兵节点redis-cli -p 26379，并执行info Sentinel命令，查看其是否正确识别了主从 12345678# Sentinelsentinel_masters:1 # 哨兵集群中主从节点的数量sentinel_tilt:0 # 是否处于 tilt 状态sentinel_tilt_since_seconds:-1 # tilt 状态的开始时间sentinel_running_scripts:0 # 正在运行的脚本数量sentinel_scripts_queue_length:0 # 脚本队列长度sentinel_simulate_failure_flags:0 # 模拟故障的标志master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 # 主节点的地址，从节点数量和哨兵数量 此时查看sentinel.conf可以在文件最后看到从节点信息和其它的哨兵节点信息(但实测无法感知其它哨兵节点)，类似于 123456789101112131415# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9 # 延迟追踪信息百分比user default on nopass sanitize-payload ~* &amp;* +@all # 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 # 本节点的idsentinel config-epoch mymaster 0sentinel leader-epoch mymaster 0sentinel current-epoch 0# 一个从节点信息sentinel known-replica mymaster 10.250.0.58 6379# 另一个从节点信息sentinel known-replica mymaster 10.250.0.36 6379# 一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a# 另一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8 此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看info Sentinel，就会发现master节点变成了从节点其中的一个了 此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更 123456# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9replicaof 10.250.0.36 6379save 3600 1save 300 100save 60 10000 这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave 123# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 顺便说一下，关闭哨兵服务的命令如下： 1redis-cli -p 26379 shutdown 哨兵优点 主节点故障，可以自动在从节点中重新选主 哨兵缺点 哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载 从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离 集群 搭建6个redis的集群，3主3从 规划 123456redis1 10.250.0.235redis2 10.250.0.58redis3 10.250.0.36redis4 10.250.0.71redis5 10.250.0.131redis6 10.250.0.63 还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息 123456789101112131415161718192021# ACL认证，所有节点都要配置masteruser &quot;admin&quot;masterauth &quot;123456&quot;# 启动集群模式cluster-enabled yes# 集群节点信息文件，这里最好和port对应上cluster-config-file nodes-6379.conf# 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰cluster-node-timeout 15000# 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，# 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置# 开启这个配置可以预防集群脑裂问题，默认为3min-replicas-to-write 1# 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能# 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败cluster-require-full-coverage yes 分别启动6个redis服务 1redis-server redis-6379.conf 创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(删除dir配置的目录中的所有文件即可)，然后在任意一个redis执行 1redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379 此时会列出集群内主从和槽位的分配方案，输入yes即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 10.250.0.131:6379 to 10.250.0.235:6379Adding replica 10.250.0.63:6379 to 10.250.0.58:6379Adding replica 10.250.0.71:6379 to 10.250.0.36:6379M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) masterM: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) masterM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) masterS: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceS: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 replicates 2527142b7cffaf6bb92608550c919a0db0607c39Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 slots: (0 slots) slave replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 slots: (0 slots) slave replicates 2527142b7cffaf6bb92608550c919a0db0607c39S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 slots: (0 slots) slave replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 登录集群并查询集群配置信息 12# -c 表示以集群模式登录，-h 集群内任意ipredis-cli --user admin --pass 123456 -c -h 10.250.0.235 查看集群信息 1234567891011121314151617181910.250.0.235:6379&gt; cluster info# 输出集群状态cluster_state:ok # 集群整体状态：ok 表示集群当前可用、健康cluster_slots_assigned:16384 # 已分配的哈希槽数量（总槽数固定为 16384）cluster_slots_ok:16384 # 正常工作的槽数量（等于已分配槽，说明全部正常）cluster_slots_pfail:0 # 处于“疑似失败(pfail)”状态的槽数量cluster_slots_fail:0 # 被判定为失败(fail)的槽数量cluster_known_nodes:6 # 当前节点已知的集群节点总数（主节点 + 从节点）cluster_size:3 # 主节点数量（3 主节点，典型的 3 主 3 从结构）cluster_current_epoch:6 # 集群当前的全局纪元（用于选举和配置同步）cluster_my_epoch:1 # 当前这个节点所在的纪元cluster_stats_messages_ping_sent:159 # 当前节点已发送的 PING 消息数量（心跳）cluster_stats_messages_pong_sent:156 # 当前节点已发送的 PONG 消息数量（心跳响应）cluster_stats_messages_sent:315 # 当前节点发送的所有集群消息总数cluster_stats_messages_ping_received:151 # 当前节点收到的 PING 消息数量cluster_stats_messages_pong_received:159 # 当前节点收到的 PONG 消息数量cluster_stats_messages_meet_received:5 # 当前节点收到的 MEET 消息数量（新节点加入发现）cluster_stats_messages_received:315 # 当前节点收到的所有集群消息总数total_cluster_links_buffer_limit_exceeded:0 # 因输出缓冲区超限被强制断开的集群连接数（0 = 正常） 查看节点列表 1234567891011121310.250.0.235:6379&gt; cluster nodes# 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460# 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected# 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected# 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected# 主节点（master），负责槽位 10923-16383（集群中第三段槽位）88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383# 主节点（master），负责槽位 5461-10922（集群中第二段槽位）2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922 此时查看nodes-6379.conf也会看到和上面一样的节点信息 此时关闭其中一个master节点，比如10.250.0.36，则其对应的slave节点10.250.0.71会切换为新的master节点，此时10.250.0.36的状态最终变为fail 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922 再次启动10.250.0.36，其会变成10.250.0.71的slave节点 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922 redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot 1234567HASH_SLOT=CRC16(key) mod 16384# 跳转重定位10.250.0.235:6379&gt; set name zhangsan# 输出-&gt; Redirected to slot [5798] located at 10.250.0.58:6379OK 关闭集群，6个redis分别关闭 1redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown 重启集群，6个redis分别启动即可 1redis-server redis-6379.conf mset/mget要求key都落在同一个slot上，每个key都加上前缀&#123;prefix&#125; 1234567891010.250.0.235:6379&gt; mset name1 lisi name2 wangwu(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwuOK10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2-&gt; Redirected to slot [5474] located at 10.250.0.58:63791) &quot;lisi&quot;2) &quot;wangwu&quot; 集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源 集群通过10000+port这个端口号进行集群间通信，所以除了要开放prot这个端口，还要开放10000+port这个端口 有关redis集群及其水平扩展的进一步说明，可以参看Redis集群 集群优点 无中心架构，集群内部自行维护数据的分片和主从的切换 数据分片存储，提供很高的访问效率 高可用性，可实现部分节点不可用时，集群仍可用 高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持 集群缺点 数据通过异步复制，不保证数据的强一致性 不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0 不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作 Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点 Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能 不建议使用pipeline和multi-keys操作","summary":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/","date_published":"2025-12-05T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","url":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","title":"brew -- 创建自己的 Formula","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n-->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://brew.sh\">brew</a>是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如<code>git</code>、<code>node</code>、<code>python</code>等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文介绍如何在macos下创建自己的 Formula</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。</p>\n</li>\n<li class=\"lvl-2\">\n<p>关于 brew 的安装及使用可以参考 <a href=\"/2024/11/28/brew/\" title=\"MacOS软件包管理器--brew\">MacOS软件包管理器--brew</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"从一个简单示例开始\">从一个简单示例开始</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看<a href=\"https://github.com/hanqunfeng/color_echo/blob/main/bin/color_echo\">color_echo</a>，这是一个用于终端打印彩色文本的命令。</p>\n</li>\n</ul>\n<h3 id=\"创建一个Github仓库，用于存储-color-echo-命令\">创建一个Github仓库，用于存储 color_echo 命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 <code>color_echo</code> 命令文件，仓库名称: <code>hanqunfeng/color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>编写命令文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> color_echo_dir</span><br><span class=\"line\"><span class=\"built_in\">cd</span> color_echo_dir</span><br><span class=\"line\"><span class=\"comment\"># 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了</span></span><br><span class=\"line\"><span class=\"comment\"># 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到</span></span><br><span class=\"line\">bin/color_echo</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提交代码并打Tag</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 color_echo_dir 目录下初始化仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Initial commit&quot;</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\"># 创建Tag</span></span><br><span class=\"line\">git tag v1.0.0</span><br><span class=\"line\"><span class=\"comment\"># 推送Tag</span></span><br><span class=\"line\">git push --tags</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取tag的sha256值</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz</span><br><span class=\"line\">shasum -a 256 v1.0.0.tar.gz</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d  v1.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"发布-color-echo\">发布 color_echo</h3>\n<blockquote>\n<p><code>brew create</code> 命令已经失效，需要手工创建</p>\n</blockquote>\n<h4 id=\"创建-tap-仓库\">创建 tap 仓库</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap-new hanqunfeng/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Warning: tap-new is a developer <span class=\"built_in\">command</span>, so Homebrew<span class=\"string\">&#x27;s</span></span><br><span class=\"line\"><span class=\"string\">developer mode has been automatically turned on.      # 提示开发者模式已自动打开</span></span><br><span class=\"line\"><span class=\"string\">To turn developer mode off, run:</span></span><br><span class=\"line\"><span class=\"string\">  brew developer off  # 如后续需要关闭开发者模式可以运行该命令</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 初始化仓库</span></span><br><span class=\"line\"><span class=\"string\">Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/</span></span><br><span class=\"line\"><span class=\"string\">[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap</span></span><br><span class=\"line\"><span class=\"string\"> 3 files changed, 107 insertions(+)</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/publish.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/tests.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 README.md</span></span><br><span class=\"line\"><span class=\"string\">==&gt; Created hanqunfeng/color_echo</span></span><br><span class=\"line\"><span class=\"string\">/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">When a pull request making changes to a formula (or formulae) becomes green</span></span><br><span class=\"line\"><span class=\"string\">(all checks passed), then you can publish the built bottles.</span></span><br><span class=\"line\"><span class=\"string\">To do so, label your PR as `pr-pull` and the workflow will be triggered.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"手写一个-Formula-文件\">手写一个 Formula 文件</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formula</span><br><span class=\"line\"><span class=\"built_in\">touch</span> color_echo.rb</span><br></pre></td></tr></table></figure>\n<p>写入内容（模板）：模板格式后面会详细介绍</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\">  desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span></span><br><span class=\"line\">  homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span></span><br><span class=\"line\">  url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span></span><br><span class=\"line\">  sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span></span><br><span class=\"line\">  license <span class=\"string\">&quot;MIT&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  def install</span><br><span class=\"line\">    bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">test</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交-Formula-文件到Github仓库\">提交 Formula 文件到Github仓库</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 Formula 文件: <code>hanqunfeng/homebrew-color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>添加 Formula 文件到仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> $(brew --repo hanqunfeng/color_echo)</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add color_echo 1.0.0&quot;</span></span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)</span><br><span class=\"line\">error: failed to push some refs to <span class=\"string\">&#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限<code>repo</code> 和 <code>workflow</code>，重新推送</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥</span></span><br><span class=\"line\">git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">* [new branch]      main -&gt; main</span><br><span class=\"line\">branch <span class=\"string\">&#x27;main&#x27;</span> <span class=\"built_in\">set</span> up to track <span class=\"string\">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-Formula\">安装 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echo</span></span><br><span class=\"line\">brew tap hanqunfeng/color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索</span></span><br><span class=\"line\">brew search color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">hanqunfeng/color_echo/color_echo              color-code</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整包名搜索</span></span><br><span class=\"line\">brew search hanqunfeng/color_echo/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">brew install color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Fetching downloads <span class=\"keyword\">for</span>: color_echo</span><br><span class=\"line\">✔︎ Formula color_echo (1.0.0)                                   [Verifying     2.1KB/  2.1KB]</span><br><span class=\"line\">==&gt; Installing color_echo from hanqunfeng/color_echo</span><br><span class=\"line\">🍺  /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built <span class=\"keyword\">in</span> 5 seconds</span><br><span class=\"line\">==&gt; Running `brew cleanup color_echo`...</span><br><span class=\"line\">Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.</span><br><span class=\"line\">Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`).</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试-Formula\">测试 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color_echo --<span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">用法: color_echo [参数] 内容</span><br><span class=\"line\"></span><br><span class=\"line\">参数说明:</span><br><span class=\"line\">  -c, --color &lt;color&gt;        设置前景色（文字颜色）</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">  -b, --<span class=\"built_in\">bg</span> &lt;color&gt;           设置背景色</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">      --bold                 加粗字体</span><br><span class=\"line\">      --underline            下划线</span><br><span class=\"line\">      --italic               斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持）</span><br><span class=\"line\"></span><br><span class=\"line\">  -n                         不换行输出，兼容 <span class=\"built_in\">echo</span> 的 -n 参数</span><br><span class=\"line\"></span><br><span class=\"line\">  -h, --<span class=\"built_in\">help</span>                 显示帮助信息</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\">  color_echo --color green <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\">  color_echo -c red -b yellow --bold <span class=\"string\">&quot;Error Message&quot;</span></span><br><span class=\"line\">  color_echo --underline <span class=\"string\">&quot;This is underlined&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"formula-文件模板\">formula 文件模板</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ruby语法，定义一个Formula的子类</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class 子类 &lt; 父类</span></span><br><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加属性</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span>  <span class=\"comment\"># 描述</span></span><br><span class=\"line\">homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span>  <span class=\"comment\"># 项目地址</span></span><br><span class=\"line\">url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span>  <span class=\"comment\"># 下载地址，安装时会自动下载并解压</span></span><br><span class=\"line\">sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span>  <span class=\"comment\"># sha256，校验v1.0.0.tar.gz</span></span><br><span class=\"line\">license <span class=\"string\">&quot;MIT&quot;</span>   <span class=\"comment\"># 许可</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加安装方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def install  <span class=\"comment\"># Homebrew 会执行的安装步骤，工作目录为解压后的文件目录</span></span><br><span class=\"line\">  <span class=\"comment\"># 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install</span></span><br><span class=\"line\">  bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span> <span class=\"comment\"># 将 bin/color_echo 安装到 /usr/local/bin/color_echo</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果要指定安装后的命令名称，可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 如果需要执行系统命令可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># system &quot;echo&quot;, &quot;hello world&quot;</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加测试方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"keyword\">do</span>  <span class=\"comment\"># Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码</span></span><br><span class=\"line\">  <span class=\"comment\"># system 指令用于执行系统命令，逗号分隔相当于空格</span></span><br><span class=\"line\">  system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span>  <span class=\"comment\"># 相当于执行 color_echo --help</span></span><br><span class=\"line\">  <span class=\"comment\"># 断言测试</span></span><br><span class=\"line\">  <span class=\"comment\"># assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>#{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>系统 / 架构</th>\n<th>实际路径示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Intel Mac</td>\n<td><code>/usr/local/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Apple Silicon</td>\n<td><code>/opt/homebrew/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Linuxbrew</td>\n<td><code>/home/linuxbrew/.linuxbrew/Cellar/.../bin</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放在 def install 方法之前</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> <span class=\"comment\"># 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :build   <span class=\"comment\"># 只在构建时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :<span class=\"built_in\">test</span>    <span class=\"comment\"># 测试时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; [:build, :<span class=\"built_in\">test</span>] <span class=\"comment\"># 构建和测试都需要</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境约束</span></span><br><span class=\"line\">depends_on macos: :sonoma          <span class=\"comment\"># 仅 macOS Sonoma</span></span><br><span class=\"line\">depends_on <span class=\"built_in\">arch</span>: :x86_64           <span class=\"comment\"># 仅 x86_64</span></span><br><span class=\"line\">depends_on xcode: [<span class=\"string\">&quot;9.3&quot;</span>, :build]  <span class=\"comment\"># 仅当 Xcode≥9.3 且用于 build</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 依赖第三方库中的命令要用完整包名</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;hanqunfeng/color_echo/color_echo&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于更多的 Formula 文件模板，可以参考：<a href=\"https://docs.brew.sh/Formula-Cookbook\">https://docs.brew.sh/Formula-Cookbook</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>同时也可以通过 <code>brew edit xxx</code> 命令查看该 Formula 文件的内容进行学习</p>\n</li>\n</ul>\n","content_text":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew 从一个简单示例开始 这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看color_echo，这是一个用于终端打印彩色文本的命令。 创建一个Github仓库，用于存储 color_echo 命令 创建一个Github仓库，用于存储 color_echo 命令文件，仓库名称: hanqunfeng/color_echo 编写命令文件 12345mkdir color_echo_dircd color_echo_dir# 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了# 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到bin/color_echo 提交代码并打Tag 1234567891011# 在 color_echo_dir 目录下初始化仓库git initgit add .git commit -m &quot;Initial commit&quot;git branch -M maingit remote add origin https://github.com/hanqunfeng/color_echo.gitgit push -u origin main# 创建Taggit tag v1.0.0# 推送Taggit push --tags 获取tag的sha256值 1234wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gzshasum -a 256 v1.0.0.tar.gz## 输出9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d v1.0.0.tar.gz 发布 color_echo brew create 命令已经失效，需要手工创建 创建 tap 仓库 1234567891011121314151617181920brew tap-new hanqunfeng/color_echo## 输出Warning: tap-new is a developer command, so Homebrew&#x27;sdeveloper mode has been automatically turned on. # 提示开发者模式已自动打开To turn developer mode off, run: brew developer off # 如后续需要关闭开发者模式可以运行该命令## 初始化仓库Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap 3 files changed, 107 insertions(+) create mode 100644 .github/workflows/publish.yml create mode 100644 .github/workflows/tests.yml create mode 100644 README.md==&gt; Created hanqunfeng/color_echo/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echoWhen a pull request making changes to a formula (or formulae) becomes green(all checks passed), then you can publish the built bottles.To do so, label your PR as `pr-pull` and the workflow will be triggered. 手写一个 Formula 文件 12cd /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formulatouch color_echo.rb 写入内容（模板）：模板格式后面会详细介绍 123456789101112131415class ColorEcho &lt; Formula desc &quot;Print colorful text in terminal&quot; homepage &quot;https://github.com/hanqunfeng/color_echo&quot; url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; license &quot;MIT&quot; def install bin.install &quot;bin/color_echo&quot; end test do system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; endend 提交 Formula 文件到Github仓库 创建一个Github仓库，用于存储 Formula 文件: hanqunfeng/homebrew-color_echo 添加 Formula 文件到仓库 123456789101112131415cd $(brew --repo hanqunfeng/color_echo)git add .git commit -m &quot;Add color_echo 1.0.0&quot;git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)error: failed to push some refs to &#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27; 提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限repo 和 workflow，重新推送 12345678910111213# 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git* [new branch] main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 安装 Formula 12345678910111213141516171819202122232425# 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echobrew tap hanqunfeng/color_echo# 搜索brew search color_echo## 输出==&gt; Formulaehanqunfeng/color_echo/color_echo color-code# 完整包名搜索brew search hanqunfeng/color_echo/color_echo## 输出==&gt; Formulaecolor_echo# 安装brew install color_echo## 输出==&gt; Fetching downloads for: color_echo✔︎ Formula color_echo (1.0.0) [Verifying 2.1KB/ 2.1KB]==&gt; Installing color_echo from hanqunfeng/color_echo🍺 /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built in 5 seconds==&gt; Running `brew cleanup color_echo`...Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`). 测试 Formula 1234567891011121314151617181920212223color_echo --help## 输出用法: color_echo [参数] 内容参数说明: -c, --color &lt;color&gt; 设置前景色（文字颜色） 可选颜色: black red green yellow blue magenta cyan white -b, --bg &lt;color&gt; 设置背景色 可选颜色: black red green yellow blue magenta cyan white --bold 加粗字体 --underline 下划线 --italic 斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持） -n 不换行输出，兼容 echo 的 -n 参数 -h, --help 显示帮助信息示例: color_echo --color green &quot;Hello World&quot; color_echo -c red -b yellow --bold &quot;Error Message&quot; color_echo --underline &quot;This is underlined&quot; formula 文件模板 Ruby语法，定义一个Formula的子类 1234# class 子类 &lt; 父类class ColorEcho &lt; Formulaend 添加属性 12345desc &quot;Print colorful text in terminal&quot; # 描述homepage &quot;https://github.com/hanqunfeng/color_echo&quot; # 项目地址url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; # 下载地址，安装时会自动下载并解压sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; # sha256，校验v1.0.0.tar.gzlicense &quot;MIT&quot; # 许可 添加安装方法 123456789def install # Homebrew 会执行的安装步骤，工作目录为解压后的文件目录 # 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install bin.install &quot;bin/color_echo&quot; # 将 bin/color_echo 安装到 /usr/local/bin/color_echo # 如果要指定安装后的命令名称，可以使用如下方式 # bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot; # 如果需要执行系统命令可以使用如下方式 # system &quot;echo&quot;, &quot;hello world&quot;end 添加测试方法 123456test do # Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码 # system 指令用于执行系统命令，逗号分隔相当于空格 system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; # 相当于执行 color_echo --help # 断言测试 # assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)end #{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同 系统 / 架构 实际路径示例 Intel Mac /usr/local/Cellar/color_echo/1.0.0/bin Apple Silicon /opt/homebrew/Cellar/color_echo/1.0.0/bin Linuxbrew /home/linuxbrew/.linuxbrew/Cellar/.../bin 如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖 123456789101112131415# 放在 def install 方法之前depends_on &quot;jq&quot; # 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用depends_on &quot;jq&quot; =&gt; :build # 只在构建时需要depends_on &quot;jq&quot; =&gt; :test # 测试时需要depends_on &quot;jq&quot; =&gt; [:build, :test] # 构建和测试都需要# 环境约束depends_on macos: :sonoma # 仅 macOS Sonomadepends_on arch: :x86_64 # 仅 x86_64depends_on xcode: [&quot;9.3&quot;, :build] # 仅当 Xcode≥9.3 且用于 build# 依赖第三方库中的命令要用完整包名depends_on &quot;hanqunfeng/color_echo/color_echo&quot; 后记 关于更多的 Formula 文件模板，可以参考：https://docs.brew.sh/Formula-Cookbook 同时也可以通过 brew edit xxx 命令查看该 Formula 文件的内容进行学习","summary":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew","date_published":"2025-12-02T13:55:05.000Z","tags":["macos","macos","brew"]},{"id":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","url":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","title":"Linux常用命令--lsof","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 lsof 命令的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于CentOS8。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"lsof-是什么？\">lsof 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>lsof = list open files</p>\n</li>\n<li class=\"lvl-2\">\n<p>它用来查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">当前系统中所有进程打开的文件</li>\n<li class=\"lvl-4\">包含普通文件、目录、socket、管道、网络连接、设备等</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>在 Linux 中：“一切皆文件”</p>\n</li>\n<li class=\"lvl-2\">\n<p>所以你可以用 lsof 查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">谁在占用你的端口？</li>\n<li class=\"lvl-4\">哪个进程正在读/写某个文件？</li>\n<li class=\"lvl-4\">为什么文件删除了却还占磁盘？</li>\n<li class=\"lvl-4\">哪个文件被锁住？</li>\n<li class=\"lvl-4\">哪些程序在访问某个目录？</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install lsof -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"lsof-的基本用法\">lsof 的基本用法</h2>\n<h3 id=\"查看被删除但仍被占用的文件\">查看被删除但仍被占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了<code>rm</code>命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> 中看不到</span><br><span class=\"line\"><span class=\"built_in\">du</span> 不会统计空间</span><br><span class=\"line\">只有 lsof 能看到，这是典型的 “deleted but still open” 状态。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时可以通过如下命令查询哪些被删除的文件还被占用：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有 link count 小于 1 的（deleted）文件</span></span><br><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\"># 列出所有被删除的文件</span></span><br><span class=\"line\">lsof | grep deleted</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果查询到这种文件，则需要停止进程，才能真正删除文件。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>记一次线上服务器磁盘空间告警问题排查</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">监控系统告警磁盘空间小于15%，通过如下命令查看确实如此</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">df</span> -hT</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Filesystem Type  Size Used Avail Use% Mounted on</span><br><span class=\"line\">/dev/xvda1 ext4  7.9G 3.3G 4.6G  42%  /</span><br><span class=\"line\">tmpfs      tmpfs 2.0G 0    2.0G  0%   /dev/shm</span><br><span class=\"line\">/dev/xvdf1 ext4  99G  80G  15G   85%  /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">du</span> -sh /usr/local/boss/logs</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">2.3G    /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\">## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄</span></span><br><span class=\"line\">COMMAND    PID      USER    FD      TYPE    DEVICE  SIZE/OFF      NLINK   NODE    NAME</span><br><span class=\"line\">java       1836     boss    1w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br><span class=\"line\">java       1836     boss    2w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。</li>\n</ul>\n</div>\n<h3 id=\"查端口被哪个进程占用\">查端口被哪个进程占用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出指定端口对应的进程</span></span><br><span class=\"line\">lsof -i tcp:8080</span><br><span class=\"line\"><span class=\"comment\"># 协议可以省略</span></span><br><span class=\"line\">lsof -i :8080</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:webcache (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将服务名称替换为端口</span></span><br><span class=\"line\">lsof -i :8080 -P</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:8080 (LISTEN)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看某个进程打开的所有文件\">查看某个进程打开的所有文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -p &lt;PID&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE  SIZE/OFF       NODE NAME</span><br><span class=\"line\">java    18548 boss  cwd    DIR      202,1      4096      35377 /home/boss</span><br><span class=\"line\">java    18548 boss  rtd    DIR      202,1      4096          2 /</span><br><span class=\"line\">java    18548 boss  mem    REG      202,1 106065056      60671 /usr/lib/locale/locale-archive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能看到这个进程：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">打开的日志文件</li>\n<li class=\"lvl-4\">使用的 jar 文件</li>\n<li class=\"lvl-4\">使用的 socket</li>\n<li class=\"lvl-4\">使用的 config 文件</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>输出结果字段说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COMMAND</td>\n<td>程序名（java）</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>进程号（18548）</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>运行用户（boss）</td>\n</tr>\n<tr>\n<td>FD</td>\n<td>文件描述符</td>\n</tr>\n<tr>\n<td>TYPE</td>\n<td>文件类型</td>\n</tr>\n<tr>\n<td>DEVICE</td>\n<td>所在磁盘分区 ID</td>\n</tr>\n<tr>\n<td>SIZE/OFF</td>\n<td>文件大小（字节）</td>\n</tr>\n<tr>\n<td>NODE</td>\n<td>inode 编号</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>文件名（或网络连接信息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看指定用户占用的文件\">查看指定用户占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出用户 boss 所有进程打开的文件</span></span><br><span class=\"line\">lsof -u &lt;USER&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看指定程序-COMMAND-打开的文件\">查看指定程序(COMMAND)打开的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -c &lt;<span class=\"built_in\">command</span>&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查某个目录或文件正在被哪些进程占用\">查某个目录或文件正在被哪些进程占用</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录 +D</span></span><br><span class=\"line\"><span class=\"comment\"># 能显示所有正在访问该目录中文件的进程</span></span><br><span class=\"line\">lsof +D /home/boss/logs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件</span></span><br><span class=\"line\">lsof /home/boss/logs/access.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只列出 nginx 用户占用的文件目录中的哪些文件</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u nginx +D /usr/local/nginx/logs</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看网络连接\">查看网络连接</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 过滤协议</span></span><br><span class=\"line\">lsof -i tcp</span><br><span class=\"line\">lsof -i udp</span><br><span class=\"line\"><span class=\"comment\"># 过滤状态</span></span><br><span class=\"line\">lsof -i -s tcp:listen</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有监听端口，</span></span><br><span class=\"line\"><span class=\"comment\"># -i: 显示网络相关的文件</span></span><br><span class=\"line\"><span class=\"comment\"># -P: 显示端口(不加-P则显示的是服务名)</span></span><br><span class=\"line\"><span class=\"comment\"># -n: 不将 IP 映射成主机名（禁用 DNS 查询）</span></span><br><span class=\"line\"><span class=\"comment\"># -s: 过滤显示连接状态</span></span><br><span class=\"line\">lsof -i -P -n -s tcp:listen</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">mongod     1782     root    5u  IPv4       8697      0t0  TCP *:27017 (LISTEN)</span><br><span class=\"line\">java       1808     boss   36u  IPv6       9221      0t0  TCP *:8082 (LISTEN)</span><br><span class=\"line\">java       1808     boss   39u  IPv6       9230      0t0  TCP 127.0.0.1:7093 (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出用户 boss 的网络连接</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u boss -i</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用参数详解\">常用参数详解</h2>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-i</code></td>\n<td>查看网络相关文件/端口</td>\n<td><code>lsof -i</code></td>\n</tr>\n<tr>\n<td><code>-i :端口</code></td>\n<td>查看指定端口</td>\n<td><code>lsof -i :8080</code></td>\n</tr>\n<tr>\n<td><code>-p PID</code></td>\n<td>查看某个进程所有打开文件</td>\n<td><code>lsof -p 1836</code></td>\n</tr>\n<tr>\n<td><code>-u 用户名</code></td>\n<td>查看某个用户进程的打开文件</td>\n<td><code>lsof -u nginx</code></td>\n</tr>\n<tr>\n<td><code>-c 进程名关键字</code></td>\n<td>查看某个进程名相关的文件</td>\n<td><code>lsof -c java</code></td>\n</tr>\n<tr>\n<td><code>+D 目录</code></td>\n<td>查看目录中所有被访问的文件</td>\n<td><code>lsof +D /usr/local/netqin/boss/netqin/logs</code></td>\n</tr>\n<tr>\n<td><code>+L1</code></td>\n<td>查找已删除但仍被打开的文件</td>\n<td><code>lsof +L1</code>（=查找“(deleted)”占盘问题）</td>\n</tr>\n<tr>\n<td><code>-d FD</code></td>\n<td>查看指定文件描述符</td>\n<td><code>lsof -d 1 -p 1836</code>（看进程 stdout）</td>\n</tr>\n<tr>\n<td><code>-n</code></td>\n<td>不做 DNS 解析，提高速度</td>\n<td><code>lsof -i -n</code></td>\n</tr>\n<tr>\n<td><code>-P</code></td>\n<td>显示端口号（不解析为服务名）</td>\n<td><code>lsof -i -P</code></td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>按连接状态过滤（TCP/UDP）</td>\n<td><code>lsof -i -sTCP:LISTEN</code></td>\n</tr>\n<tr>\n<td><code>-r</code></td>\n<td>持续输出（实时监控）</td>\n<td><code>lsof -i -r 1</code>（每秒刷新网络连接）</td>\n</tr>\n<tr>\n<td><code>-a</code></td>\n<td>逻辑 AND，不加 -a 都是 逻辑 OR</td>\n<td><code>lsof -u boss -i</code>（列出用户 boss 的网络连接）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-FD-字段详细解释\">lsof 文件 FD 字段详细解释</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FD（文件描述符）格式总规则：数字 + 标志位</p>\n</li>\n<li class=\"lvl-2\">\n<p>lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10r   → FD=10，<span class=\"built_in\">read</span> only（只读）</span><br><span class=\"line\">1w    → FD=1，write only（只写）</span><br><span class=\"line\">36u   → FD=36，<span class=\"built_in\">read</span>/write（可读可写）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解释</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>部分</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数字（0、1、2、3、10、36…）</strong></td>\n<td>文件描述符编号</td>\n</tr>\n<tr>\n<td><strong>字母（r / w / u）</strong></td>\n<td>访问模式：读/写/读写</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>FD 编号</th>\n<th>标准含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td>stdin（标准输入）</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td>stdout（标准输出）</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>stderr（标准错误输出）</td>\n</tr>\n<tr>\n<td><strong>3</strong> 及以上</td>\n<td>进程打开的普通文件、日志、socket、管道等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>特殊 FD 类型（没有数字）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cwd</code></td>\n<td>当前工作目录，说明进程在这个目录下运行</td>\n</tr>\n<tr>\n<td><code>rtd</code></td>\n<td>进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs</td>\n</tr>\n<tr>\n<td><code>txt</code></td>\n<td>可执行文件本体</td>\n</tr>\n<tr>\n<td><code>mem</code></td>\n<td>内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-TYPE-字段详细解释\">lsof 文件 TYPE 字段详细解释</h2>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>全称</th>\n<th>含义</th>\n<th>常见场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>REG</strong></td>\n<td>Regular file</td>\n<td>普通文件</td>\n<td>日志、配置、可执行程序等</td>\n</tr>\n<tr>\n<td><strong>DIR</strong></td>\n<td>Directory</td>\n<td>目录</td>\n<td>进程访问的目录，例如当前工作目录</td>\n</tr>\n<tr>\n<td><strong>CHR</strong></td>\n<td>Character special file</td>\n<td>字符设备文件</td>\n<td><code>/dev/null</code>、<code>/dev/tty</code>、串口、键盘等</td>\n</tr>\n<tr>\n<td><strong>BLK</strong></td>\n<td>Block special file</td>\n<td>块设备文件</td>\n<td><code>/dev/sda</code>、硬盘、分区等</td>\n</tr>\n<tr>\n<td><strong>FIFO</strong></td>\n<td>Named pipe</td>\n<td>命名管道</td>\n<td>Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信</td>\n</tr>\n<tr>\n<td><strong>sock</strong></td>\n<td>Socket</td>\n<td>套接字（Unix 域 socket）</td>\n<td><code>/var/run/docker.sock</code>、MySQL UNix socket</td>\n</tr>\n<tr>\n<td><strong>IPv4</strong></td>\n<td>IPv4 socket</td>\n<td>IPv4 网络连接/监听</td>\n<td><code>TCP *:80</code>、<code>UDP 127.0.0.1:53</code></td>\n</tr>\n<tr>\n<td><strong>IPv6</strong></td>\n<td>IPv6 socket</td>\n<td>IPv6 网络连接/监听</td>\n<td><code>TCP [::]:22</code></td>\n</tr>\n<tr>\n<td><strong>unix</strong></td>\n<td>Unix domain socket</td>\n<td>本地进程通信</td>\n<td><code>/run/systemd/journal/stdout</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。 lsof 是什么？ lsof = list open files 它用来查看： 当前系统中所有进程打开的文件 包含普通文件、目录、socket、管道、网络连接、设备等 在 Linux 中：“一切皆文件” 所以你可以用 lsof 查看： 谁在占用你的端口？ 哪个进程正在读/写某个文件？ 为什么文件删除了却还占磁盘？ 哪个文件被锁住？ 哪些程序在访问某个目录？ CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装 1yum install lsof -y lsof 的基本用法 查看被删除但仍被占用的文件 如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了rm命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。 文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在： 123ls 中看不到du 不会统计空间只有 lsof 能看到，这是典型的 “deleted but still open” 状态。 此时可以通过如下命令查询哪些被删除的文件还被占用： 1234# 列出所有 link count 小于 1 的（deleted）文件lsof +L1# 列出所有被删除的文件lsof | grep deleted 如果查询到这种文件，则需要停止进程，才能真正删除文件。 记一次线上服务器磁盘空间告警问题排查 监控系统告警磁盘空间小于15%，通过如下命令查看确实如此 123456$ df -hT# 输出Filesystem Type Size Used Avail Use% Mounted on/dev/xvda1 ext4 7.9G 3.3G 4.6G 42% /tmpfs tmpfs 2.0G 0 2.0G 0% /dev/shm/dev/xvdf1 ext4 99G 80G 15G 85% /usr/local/boss/logs 但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多 123$ du -sh /usr/local/boss/logs# 输出2.3G /usr/local/boss/logs 此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看： 12345lsof +L1## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄COMMAND PID USER FD TYPE DEVICE SIZE/OFF NLINK NODE NAMEjava 1836 boss 1w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted)java 1836 boss 2w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted) 结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。 查端口被哪个进程占用 通过如下命令查询： 1234567891011121314# 列出指定端口对应的进程lsof -i tcp:8080# 协议可以省略lsof -i :8080## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:webcache (LISTEN)# 将服务名称替换为端口lsof -i :8080 -P## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:8080 (LISTEN) 查看某个进程打开的所有文件 通过如下命令查询： 12345678lsof -p &lt;PID&gt;## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss cwd DIR 202,1 4096 35377 /home/bossjava 18548 boss rtd DIR 202,1 4096 2 /java 18548 boss mem REG 202,1 106065056 60671 /usr/lib/locale/locale-archive 能看到这个进程： 打开的日志文件 使用的 jar 文件 使用的 socket 使用的 config 文件 输出结果字段说明 字段 含义 COMMAND 程序名（java） PID 进程号（18548） USER 运行用户（boss） FD 文件描述符 TYPE 文件类型 DEVICE 所在磁盘分区 ID SIZE/OFF 文件大小（字节） NODE inode 编号 NAME 文件名（或网络连接信息） 查看指定用户占用的文件 通过如下命令查询： 12# 列出用户 boss 所有进程打开的文件lsof -u &lt;USER&gt; 查看指定程序(COMMAND)打开的文件 通过如下命令查询： 1lsof -c &lt;command&gt; 查某个目录或文件正在被哪些进程占用 1234567891011# 目录 +D# 能显示所有正在访问该目录中文件的进程lsof +D /home/boss/logs# 文件lsof /home/boss/logs/access.log# 只列出 nginx 用户占用的文件目录中的哪些文件# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u nginx +D /usr/local/nginx/logs 查看网络连接 12345678910111213141516171819202122lsof -i# 过滤协议lsof -i tcplsof -i udp# 过滤状态lsof -i -s tcp:listen# 列出所有监听端口，# -i: 显示网络相关的文件# -P: 显示端口(不加-P则显示的是服务名)# -n: 不将 IP 映射成主机名（禁用 DNS 查询）# -s: 过滤显示连接状态lsof -i -P -n -s tcp:listen## 输出示例mongod 1782 root 5u IPv4 8697 0t0 TCP *:27017 (LISTEN)java 1808 boss 36u IPv6 9221 0t0 TCP *:8082 (LISTEN)java 1808 boss 39u IPv6 9230 0t0 TCP 127.0.0.1:7093 (LISTEN)# 列出用户 boss 的网络连接# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u boss -i 常用参数详解 参数 作用 示例 -i 查看网络相关文件/端口 lsof -i -i :端口 查看指定端口 lsof -i :8080 -p PID 查看某个进程所有打开文件 lsof -p 1836 -u 用户名 查看某个用户进程的打开文件 lsof -u nginx -c 进程名关键字 查看某个进程名相关的文件 lsof -c java +D 目录 查看目录中所有被访问的文件 lsof +D /usr/local/netqin/boss/netqin/logs +L1 查找已删除但仍被打开的文件 lsof +L1（=查找“(deleted)”占盘问题） -d FD 查看指定文件描述符 lsof -d 1 -p 1836（看进程 stdout） -n 不做 DNS 解析，提高速度 lsof -i -n -P 显示端口号（不解析为服务名） lsof -i -P -s 按连接状态过滤（TCP/UDP） lsof -i -sTCP:LISTEN -r 持续输出（实时监控） lsof -i -r 1（每秒刷新网络连接） -a 逻辑 AND，不加 -a 都是 逻辑 OR lsof -u boss -i（列出用户 boss 的网络连接） lsof 文件 FD 字段详细解释 FD（文件描述符）格式总规则：数字 + 标志位 lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。 示例 12310r → FD=10，read only（只读）1w → FD=1，write only（只写）36u → FD=36，read/write（可读可写） 解释 部分 含义 数字（0、1、2、3、10、36…） 文件描述符编号 字母（r / w / u） 访问模式：读/写/读写 FD 编号 标准含义 0 stdin（标准输入） 1 stdout（标准输出） 2 stderr（标准错误输出） 3 及以上 进程打开的普通文件、日志、socket、管道等 特殊 FD 类型（没有数字） 字段 含义 cwd 当前工作目录，说明进程在这个目录下运行 rtd 进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs txt 可执行文件本体 mem 内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件 lsof 文件 TYPE 字段详细解释 文件类型 全称 含义 常见场景 REG Regular file 普通文件 日志、配置、可执行程序等 DIR Directory 目录 进程访问的目录，例如当前工作目录 CHR Character special file 字符设备文件 /dev/null、/dev/tty、串口、键盘等 BLK Block special file 块设备文件 /dev/sda、硬盘、分区等 FIFO Named pipe 命名管道 Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信 sock Socket 套接字（Unix 域 socket） /var/run/docker.sock、MySQL UNix socket IPv4 IPv4 socket IPv4 网络连接/监听 TCP *:80、UDP 127.0.0.1:53 IPv6 IPv6 socket IPv6 网络连接/监听 TCP [::]:22 unix Unix domain socket 本地进程通信 /run/systemd/journal/stdout","summary":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。","date_published":"2025-11-26T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2025/11/20/utc/","url":"https://blog.hanqunfeng.com/2025/11/20/utc/","title":"什么是 UTC？一篇人人都能看懂的科普文章","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"一、为什么世界需要统一时间？\">一、为什么世界需要统一时间？</h2>\n<p>早期，每个城市甚至每个乡镇都根据 <strong>太阳位置</strong>确定时间：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>太阳在头顶就是 12 点</p>\n</li>\n<li class=\"lvl-2\">\n<p>不同地方经度不同，每地时间都不同</p>\n</li>\n</ul>\n<p>这种方法在本地没问题，但到了 <strong>跨区域铁路、通信、航海、航空、互联网时代</strong>，问题巨大：</p>\n<blockquote>\n<p>两地时间不统一，火车、舰队、订单、通信都没法同步记录。</p>\n</blockquote>\n<p>因此世界需要：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 <strong>全球统一、精确的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>所有人、所有系统都能对齐使用</p>\n</li>\n</ul>\n<p>UTC 就是在这个背景下诞生的。</p>\n<hr>\n<h2 id=\"二、UTC-是什么？\">二、UTC 是什么？</h2>\n<p>UTC 的全称：</p>\n<blockquote>\n<p><strong>Coordinated Universal Time（协调世界时）</strong></p>\n</blockquote>\n<p>它是当今全球使用的 <strong>标准时间系统</strong>。</p>\n<p>它的主要特点：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不是某个国家的时间</p>\n</li>\n<li class=\"lvl-2\">\n<p>是国际组织共同维护</p>\n</li>\n<li class=\"lvl-2\">\n<p>全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准</p>\n</li>\n</ul>\n<p>一句话：</p>\n<blockquote>\n<p><strong>UTC 是现代世界共同使用的“世界时间”。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"三、UTC-和-GMT-的关系\">三、UTC 和 GMT 的关系</h2>\n<p>很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>GMT</th>\n<th>UTC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>出现年代</td>\n<td>19 世纪</td>\n<td>1972 年</td>\n</tr>\n<tr>\n<td>基准</td>\n<td>地球自转（天文时间）</td>\n<td>原子钟（更精确）</td>\n</tr>\n<tr>\n<td>是否仍是标准</td>\n<td>已被替代</td>\n<td>当前唯一标准</td>\n</tr>\n</tbody>\n</table>\n<p>但在日常使用中：</p>\n<blockquote>\n<p><strong>UTC ≈ GMT（同为零时区）</strong></p>\n</blockquote>\n<p>所以：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>英国冬季使用 GMT（UTC+0）</p>\n</li>\n<li class=\"lvl-2\">\n<p>技术系统使用 UTC（UTC+0）</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、UTC-是如何确定的？\">四、UTC 是如何确定的？</h2>\n<p>UTC 并不是按太阳走，而是：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>由全世界 <strong>原子钟网络统一生成</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>每秒误差小于 <strong>十亿分之一秒</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>然后根据地球自转误差偶尔加“闰秒”</p>\n</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-12-31 23:59:60 UTC   ← 曾经加过闰秒</span><br></pre></td></tr></table></figure>\n<p>这样：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>保证时间极其准确</p>\n</li>\n<li class=\"lvl-2\">\n<p>又不会与地球真实昼夜偏离太多</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"五、UTC-与时区\">五、UTC 与时区</h2>\n<p>UTC 是 0 时区。</p>\n<p>所有时区都是 <strong>在 UTC 基础上加减偏移</strong>：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>北京时间：UTC + 8</p>\n</li>\n<li class=\"lvl-2\">\n<p>纽约时间：UTC – 5（冬季）或 –4（夏令时）</p>\n</li>\n<li class=\"lvl-2\">\n<p>日本时间：UTC + 9</p>\n</li>\n</ul>\n<p>所以你常看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8 或 UTC-5</span><br></pre></td></tr></table></figure>\n<p>表示该地区比 UTC 早或晚多少小时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8  &gt;  UTC+0  &gt;  UTC−5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>换成生活语言：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC+8（例如北京时间）比 UTC 早 8 小时</li>\n<li class=\"lvl-4\">UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>举例：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC(即UTC+0) 时间是 12:00</li>\n<li class=\"lvl-4\">UTC+8 = 20:00（已经晚上）</li>\n<li class=\"lvl-4\">UTC−5 = 07:00（还在早上）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"六、UTC-在计算机世界的重要性\">六、UTC 在计算机世界的重要性</h2>\n<p>几乎所有 IT 系统都推荐：</p>\n<blockquote>\n<p><strong>存储用 UTC，展示给用户再转换成当地时区。</strong></p>\n</blockquote>\n<p>原因很简单：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>全球一致，不会混乱</p>\n</li>\n<li class=\"lvl-2\">\n<p>不受时区或夏令时影响</p>\n</li>\n<li class=\"lvl-2\">\n<p>跨国系统日志可对齐分析</p>\n</li>\n</ul>\n<p>你在日志里经常见到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2025-11-20T08:30:00Z</span><br></pre></td></tr></table></figure>\n<p>结尾的 <code>Z</code> 就表示：</p>\n<blockquote>\n<p><strong>这是 UTC 时间</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"七、UTC、GMT、CST-总结对比\">七、UTC、GMT、CST 总结对比</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>全称</th>\n<th>现在地位</th>\n<th>是否标准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTC</td>\n<td>Coordinated Universal Time</td>\n<td>全球标准</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>GMT</td>\n<td>Greenwich Mean Time</td>\n<td>被 UTC 替代</td>\n<td>✖（历史含义）</td>\n</tr>\n<tr>\n<td>CST</td>\n<td>China Standard Time（中国）或 Central Standard Time（美国）</td>\n<td>本地时区</td>\n<td>不是世界统一基准</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<blockquote>\n<p>“CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。</p>\n</blockquote>\n<hr>\n<h2 id=\"八、一句话总结\">八、一句话总结</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>UTC 是现代全球统一的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>所有时区都是相对于 UTC 偏移</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>计算机领域普遍使用 UTC 存储时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>GMT 是 UTC 的历史前身</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>北京时间 = UTC + 8</strong></p>\n</li>\n</ul>\n<p>只要理解这几点，你已经掌握了世界时间体系的核心。</p>\n","content_text":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。 一、为什么世界需要统一时间？ 早期，每个城市甚至每个乡镇都根据 太阳位置确定时间： 太阳在头顶就是 12 点 不同地方经度不同，每地时间都不同 这种方法在本地没问题，但到了 跨区域铁路、通信、航海、航空、互联网时代，问题巨大： 两地时间不统一，火车、舰队、订单、通信都没法同步记录。 因此世界需要： 一个 全球统一、精确的标准时间 所有人、所有系统都能对齐使用 UTC 就是在这个背景下诞生的。 二、UTC 是什么？ UTC 的全称： Coordinated Universal Time（协调世界时） 它是当今全球使用的 标准时间系统。 它的主要特点： 不是某个国家的时间 是国际组织共同维护 全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准 一句话： UTC 是现代世界共同使用的“世界时间”。 三、UTC 和 GMT 的关系 很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。 项目 GMT UTC 出现年代 19 世纪 1972 年 基准 地球自转（天文时间） 原子钟（更精确） 是否仍是标准 已被替代 当前唯一标准 但在日常使用中： UTC ≈ GMT（同为零时区） 所以： 英国冬季使用 GMT（UTC+0） 技术系统使用 UTC（UTC+0） 四、UTC 是如何确定的？ UTC 并不是按太阳走，而是： 由全世界 原子钟网络统一生成 每秒误差小于 十亿分之一秒 然后根据地球自转误差偶尔加“闰秒” 例如： 12016-12-31 23:59:60 UTC ← 曾经加过闰秒 这样： 保证时间极其准确 又不会与地球真实昼夜偏离太多 五、UTC 与时区 UTC 是 0 时区。 所有时区都是 在 UTC 基础上加减偏移： 北京时间：UTC + 8 纽约时间：UTC – 5（冬季）或 –4（夏令时） 日本时间：UTC + 9 所以你常看到： 1UTC+8 或 UTC-5 表示该地区比 UTC 早或晚多少小时。 1UTC+8 &gt; UTC+0 &gt; UTC−5 换成生活语言： UTC+8（例如北京时间）比 UTC 早 8 小时 UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时 举例： UTC(即UTC+0) 时间是 12:00 UTC+8 = 20:00（已经晚上） UTC−5 = 07:00（还在早上） 六、UTC 在计算机世界的重要性 几乎所有 IT 系统都推荐： 存储用 UTC，展示给用户再转换成当地时区。 原因很简单： 全球一致，不会混乱 不受时区或夏令时影响 跨国系统日志可对齐分析 你在日志里经常见到： 12025-11-20T08:30:00Z 结尾的 Z 就表示： 这是 UTC 时间 七、UTC、GMT、CST 总结对比 名称 全称 现在地位 是否标准 UTC Coordinated Universal Time 全球标准 ✔ GMT Greenwich Mean Time 被 UTC 替代 ✖（历史含义） CST China Standard Time（中国）或 Central Standard Time（美国） 本地时区 不是世界统一基准 注意： “CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。 八、一句话总结 UTC 是现代全球统一的标准时间 所有时区都是相对于 UTC 偏移 计算机领域普遍使用 UTC 存储时间 GMT 是 UTC 的历史前身 北京时间 = UTC + 8 只要理解这几点，你已经掌握了世界时间体系的核心。","summary":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。","date_published":"2025-11-20T14:30:05.000Z","tags":["技术","UTC","UTC"]},{"id":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","url":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","title":"RocketMQ ACL 2.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-2-0-简介\">ACL 2.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href=\"https://rocketmq.apache.org/zh/docs/bestPractice/03access\">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在阿里云上找到一篇参考资料：<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a></p>\n</li>\n</ul>\n<h2 id=\"配置步骤\">配置步骤</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 认证配置</span></span><br><span class=\"line\">authenticationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class=\"line\">initAuthenticationUser = &#123;<span class=\"string\">&quot;username&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;password&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">innerClientAuthenticationCredentials = &#123;<span class=\"string\">&quot;accessKey&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;secretKey&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class=\"line\"><span class=\"comment\"># 授权配置</span></span><br><span class=\"line\">authorizationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class=\"line\">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数定义</th>\n<th style=\"text-align:left\">参数名称</th>\n<th style=\"text-align:left\">参数描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationEnabled</strong></td>\n<td style=\"text-align:left\">是否打开认证开关</td>\n<td style=\"text-align:left\">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationProvider</strong></td>\n<td style=\"text-align:left\">认证方式提供者</td>\n<td style=\"text-align:left\">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>initAuthenticationUser</strong></td>\n<td style=\"text-align:left\">系统初始化用户</td>\n<td style=\"text-align:left\">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>innerClientAuthenticationCredentials</strong></td>\n<td style=\"text-align:left\">组件间认证用户</td>\n<td style=\"text-align:left\">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationMetadataProvider</strong></td>\n<td style=\"text-align:left\">认证元数据提供者</td>\n<td style=\"text-align:left\">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationStrategy</strong></td>\n<td style=\"text-align:left\">认证策略</td>\n<td style=\"text-align:left\">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启启动所有 Broker</p>\n</li>\n</ul>\n<h2 id=\"命令行管理用户\">命令行管理用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"用户管理\">用户管理</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口定义</th>\n<th style=\"text-align:left\">接口名称</th>\n<th style=\"text-align:left\">接口参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>createUser</strong></td>\n<td style=\"text-align:left\">创建用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>updateUser</strong></td>\n<td style=\"text-align:left\">更新用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>deleteUser</strong></td>\n<td style=\"text-align:left\">删除用户</td>\n<td style=\"text-align:left\">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>getUser</strong></td>\n<td style=\"text-align:left\">查询用户详情</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>listUser</strong></td>\n<td style=\"text-align:left\">查询用户列表</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 创建用户，指定用户类型</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class=\"line\"><span class=\"comment\"># 更新用户</span></span><br><span class=\"line\">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class=\"line\"><span class=\"comment\"># 删除用户</span></span><br><span class=\"line\">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户详情</span></span><br><span class=\"line\">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure>\n<h3 id=\"权限管理\">权限管理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令名称</th>\n<th style=\"text-align:left\">操作定义</th>\n<th style=\"text-align:left\">命令参数及解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><code>createAcl</code></strong></td>\n<td style=\"text-align:left\">创建授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>updateAcl</code></strong></td>\n<td style=\"text-align:left\">更新授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>deleteAcl</code></strong></td>\n<td style=\"text-align:left\">删除授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>listAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权列表</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>getAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权详情</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建授权</span></span><br><span class=\"line\">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class=\"line\"><span class=\"comment\"># 更新授权</span></span><br><span class=\"line\">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class=\"line\"><span class=\"comment\"># 删除授权</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 删除授权，指定资源</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权详情</span></span><br><span class=\"line\">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n<li class=\"lvl-2\">\n<p>按照这篇文章<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;innerClientAuthenticationCredentials&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>异常信息如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.zcw159357.com/article/1/2025-03-15-0048.html\">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.csdn.net/icebamboo2015/article/details/152118732\">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p>\n</li>\n</ul>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 2.0 简介 在 RocketMQ官网 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: https://rocketmq.apache.org/zh/docs/bestPractice/03access。 在阿里云上找到一篇参考资料：Apache RocketMQ ACL 2.0 全新升级 配置步骤 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 2.0。 在所有 Broker 的配置文件broker.conf中增加认证与授权配置: 1234567891011# broker.conf# 认证配置authenticationEnabled = trueauthenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProviderinitAuthenticationUser = &#123;&quot;username&quot;:&quot;mqadmin&quot;,&quot;password&quot;:&quot;1234567&quot;&#125;innerClientAuthenticationCredentials = &#123;&quot;accessKey&quot;:&quot;mqadmin&quot;,&quot;secretKey&quot;:&quot;1234567&quot;&#125;authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider# 授权配置authorizationEnabled = trueauthorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProviderauthorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider 参数定义 参数名称 参数描述 authenticationEnabled 是否打开认证开关 用于判断认证是否打开。可选值：• true – 是• false – 否 authenticationProvider 认证方式提供者 用于提供请求访问时的认证方式。可选值：• org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider – 默认的认证方式 initAuthenticationUser 系统初始化用户 用于系统初始化时自动创建的用户账号。示例：&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125; innerClientAuthenticationCredentials 组件间认证用户 用于设置集群内组件之间的访问凭证。示例：&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125; authenticationMetadataProvider 认证元数据提供者 用于提供认证相关的元数据（如用户）。可选值：• org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider – 本地认证元数据提供者• org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider – Proxy认证元数据提供者 authenticationStrategy 认证策略 用于指定请求访问时的认证策略。可选值：• org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy – 每次请求认证策略• org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy – 首次请求认证策略 重启启动所有 Broker 命令行管理用户 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 用户管理 接口定义 接口名称 接口参数 createUser 创建用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） updateUser 更新用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） deleteUser 删除用户 -b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 getUser 查询用户详情 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 listUser 查询用户列表 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-f 过滤条件（支持用户名称模糊查询，可选） 示例 1234567891011121314# 创建用户sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq# 创建用户，指定用户类型sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super# 更新用户sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678# 删除用户sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户详情sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户列表sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster# 查询用户列表，带过滤条件sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq 权限管理 管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。 命令名称 操作定义 命令参数及解释 createAcl 创建授权 -n 127.0.0.1:9876：NameServer 地址（多个以 ; 分隔）-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户（User:rocketmq 表示给用户 rocketmq 授权）-r Topic:*,Group:：资源类型与名称，* 表示所有 Topic 和 Group-a Pub,Sub：授权操作类型，Pub 表示发布权限，Sub 表示订阅权限-i 192.168.1.0/24：授权的 IP 地址范围-d Allow：授权类型，Allow 允许，Deny 拒绝 updateAcl 更新授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:*,Group:：资源类型与名称-a Pub,Sub：授权操作类型-i 192.168.1.0/24：IP 地址范围-d Deny：授权类型，更新为 Deny deleteAcl 删除授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定删除某个资源（如 Topic）授权 listAcl 查询授权列表 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定资源类型（如 Topic） getAcl 查询授权详情 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户 示例 1234567891011121314# 创建授权sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow# 更新授权sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny# 删除授权sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq# 删除授权，指定资源sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权列表sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster# 查询授权列表，带过滤条件sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权详情sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。 12345678910111213# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 按照这篇文章Apache RocketMQ ACL 2.0 全新升级的介绍，在所有 Proxy 的配置文件rmq-proxy.json中增加认证与授权配置依旧没有解决该问题。 123456789&#123; &quot;authenticationEnabled&quot;: true, &quot;authenticationProvider&quot;: &quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;, &quot;authenticationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;, &quot;innerClientAuthenticationCredentials&quot;: &quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;, &quot;authorizationEnabled&quot;: true, &quot;authorizationProvider&quot;: &quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;, &quot;authorizationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;&#125; 异常信息如下： 1Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again. 之后通过这篇文章 rocketmq部署踩坑(二) acl配置 的介绍，需要在 rmq-proxy.json 中增加如下配置： 1&quot;enableAclRpcHookForClusterMode&quot;: true 配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。 之后通过这篇文章 关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理 的说明，将所有 broker.conf 中 authorizationEnabled 配置改为 false，重启 Broker，问题解决。 后记 笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。","summary":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-31T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","url":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","title":"RocketMQ ACL 1.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 1.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-1-0-简介\">ACL 1.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。</p>\n</li>\n</ul>\n<h2 id=\"ACL-1-0-使用方法\">ACL 1.0 使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 1.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>首先需要在 Broker 节点开启 ACL 权限，在 <code>broker.conf</code> 文件中添加如下配置，并重启 Broker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aclEnable=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限配置文件为 <code>conf/plain_acl.yml</code>，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 白名单内的 IP 都可以访问，无需配置帐号</span></span><br><span class=\"line\"><span class=\"attr\">globalWhiteRemoteAddresses:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10.10</span><span class=\"number\">.103</span><span class=\"string\">.*</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"string\">.*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局白名单外的IP,需要账号访问</span></span><br><span class=\"line\"><span class=\"comment\"># 账号配置，数组形式</span></span><br><span class=\"line\"><span class=\"attr\">accounts:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">RocketMQ</span> <span class=\"comment\"># 用户名</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span> <span class=\"comment\"># 密码</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"comment\"># 当前帐号的白名单</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">false</span>        <span class=\"comment\"># 是否是管理员</span></span><br><span class=\"line\">    <span class=\"attr\">defaultTopicPerm:</span> <span class=\"string\">DENY</span> <span class=\"comment\"># 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">defaultGroupPerm:</span> <span class=\"string\">SUB</span>  <span class=\"comment\"># 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">topicPerms:</span>            <span class=\"comment\"># 特定的 topic 权限</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicA=DENY</span>        <span class=\"comment\"># topicName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicC=SUB</span></span><br><span class=\"line\">    <span class=\"attr\">groupPerms:</span>            <span class=\"comment\"># 特定的 ConsumerGroup 权限</span></span><br><span class=\"line\">      <span class=\"comment\"># the group should convert to retry topic</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupA=DENY</span>        <span class=\"comment\"># groupName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupC=SUB</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">rocketmq2</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"string\">.*</span></span><br><span class=\"line\">    <span class=\"comment\"># if it is admin, it could access all resources</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">true</span>         <span class=\"comment\"># 是否是管理员,true 表示管理员,管理员可以访问所有资源</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限定义</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限值</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>DENY</strong></td>\n<td style=\"text-align:left\">拒绝</td>\n<td style=\"text-align:left\">禁止对该 Topic 的任何操作（无论是发送还是订阅）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>ANY</strong></td>\n<td style=\"text-align:left\">任意权限</td>\n<td style=\"text-align:left\">具有发布（PUB）和订阅（SUB）双重权限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>PUB</strong></td>\n<td style=\"text-align:left\">发送权限</td>\n<td style=\"text-align:left\">允许生产者向该 Topic 发送消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SUB</strong></td>\n<td style=\"text-align:left\">订阅权限</td>\n<td style=\"text-align:left\">允许消费者订阅并消费该 Topic 的消息</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>defaultGroupPerm: SUB</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。</li>\n</ul>\n</div>\n<h3 id=\"命令行配置-ACL\">命令行配置 ACL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以下命令执行后会自动修改 <code>conf/plain_acl.yml</code> 文件</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加白名单</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*,10.252.*.*,10.20.0.31</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Broker 地址</strong></td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Cluster 名称</strong>，集群内所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要设置的全局白名单地址列表，支持通配符</td>\n<td style=\"text-align:left\"><code>&quot;10.10.103.*,192.168.0.*&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 ACL 配置文件路径（Broker 端对应的配置文件路径）</td>\n<td style=\"text-align:left\"><code>/home/rocketmq/conf/plain_acl.yml</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建管理员</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin \\</span><br><span class=\"line\">    -s 1234567 \\</span><br><span class=\"line\">    -m <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建普通用户</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">  -c DefaultCluster \\</span><br><span class=\"line\">  -a rocketmq_user \\</span><br><span class=\"line\">  -s 12345678 \\</span><br><span class=\"line\">  -i <span class=\"string\">&quot;PUB|SUB&quot;</span> \\</span><br><span class=\"line\">  -u SUB \\</span><br><span class=\"line\">  -t <span class=\"string\">&quot;topicA=PUB|SUB,topicB=DENY&quot;</span> \\</span><br><span class=\"line\">  -g <span class=\"string\">&quot;groupA=SUB,groupB=DENY&quot;</span> \\</span><br><span class=\"line\">  -w <span class=\"string\">&quot;192.168.0.*&quot;</span> \\</span><br><span class=\"line\">  -n 127.0.0.1:9876</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">密码（secretKey）</td>\n<td style=\"text-align:left\"><code>12345678</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称，集群中所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Group 权限列表</td>\n<td style=\"text-align:left\"><code>groupA=SUB,groupB=DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Topic 权限列表</td>\n<td style=\"text-align:left\">`topicA=PUB</td>\n<td>SUB,topicB=DENY`</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Group 权限</td>\n<td style=\"text-align:left\"><code>SUB</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Topic 权限</td>\n<td style=\"text-align:left\"><code>DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置 IP 白名单</td>\n<td style=\"text-align:left\"><code>&quot;10.10.10.*,192.168.1.*&quot;</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">是否设置为管理员账号</td>\n<td style=\"text-align:left\"><code>true</code> 或 <code>false</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteAccessConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要删除的用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称（删除整个集群上的该账号）</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n</ul>\n<h3 id=\"目前有两种没什么意义的解决方法：\">目前有两种没什么意义的解决方法：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">为 Proxy 开启 <code>enableAclRpcHookForClusterMode</code></li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/rmq-proxy.json</code>文件，添加<code>enableAclRpcHookForClusterMode</code>参数</li>\n</ul>\n  <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/tools.yml</code>文件，配置帐号信息：</li>\n</ul>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">重新启动Proxy即可</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 1.0 简介 ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。 一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。 ACL 1.0 使用方法 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 1.0。 首先需要在 Broker 节点开启 ACL 权限，在 broker.conf 文件中添加如下配置，并重启 Broker 1aclEnable=true 权限配置文件为 conf/plain_acl.yml，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下： 123456789101112131415161718192021222324252627282930# 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1# 白名单内的 IP 都可以访问，无需配置帐号globalWhiteRemoteAddresses: - 10.10.103.* - 192.168.0.*# 全局白名单外的IP,需要账号访问# 账号配置，数组形式accounts: - accessKey: RocketMQ # 用户名 secretKey: 12345678 # 密码 whiteRemoteAddress: # 当前帐号的白名单 admin: false # 是否是管理员 defaultTopicPerm: DENY # 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB defaultGroupPerm: SUB # 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB topicPerms: # 特定的 topic 权限 - topicA=DENY # topicName=perm - topicB=PUB|SUB - topicC=SUB groupPerms: # 特定的 ConsumerGroup 权限 # the group should convert to retry topic - groupA=DENY # groupName=perm - groupB=PUB|SUB - groupC=SUB - accessKey: rocketmq2 secretKey: 12345678 whiteRemoteAddress: 192.168.1.* # if it is admin, it could access all resources admin: true # 是否是管理员,true 表示管理员,管理员可以访问所有资源 权限定义 权限值 含义 说明 DENY 拒绝 禁止对该 Topic 的任何操作（无论是发送还是订阅） ANY 任意权限 具有发布（PUB）和订阅（SUB）双重权限 PUB 发送权限 允许生产者向该 Topic 发送消息 SUB 订阅权限 允许消费者订阅并消费该 Topic 的消息 defaultGroupPerm: SUB 表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。 命令行配置 ACL 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 以下命令执行后会自动修改 conf/plain_acl.yml 文件 添加白名单 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.*,10.252.*.*,10.20.0.31 参数 是否必填 含义 示例 -b 二选一必填 指定要更新白名单的 Broker 地址 127.0.0.1:10911 -c 二选一必填 指定要更新白名单的 Cluster 名称，集群内所有 Broker 都会被更新 DefaultCluster -g ✅ 必填 要设置的全局白名单地址列表，支持通配符 &quot;10.10.103.*,192.168.0.*&quot; -n 可选 NameServer 地址 127.0.0.1:9876 -p 可选 指定 ACL 配置文件路径（Broker 端对应的配置文件路径） /home/rocketmq/conf/plain_acl.yml -h 否 打印帮助信息 — 创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位 1234567891011121314151617181920# 创建管理员sh bin/mqadmin updateAclConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin \\ -s 1234567 \\ -m true# 创建普通用户sh bin/mqadmin updateAclConfig \\ -c DefaultCluster \\ -a rocketmq_user \\ -s 12345678 \\ -i &quot;PUB|SUB&quot; \\ -u SUB \\ -t &quot;topicA=PUB|SUB,topicB=DENY&quot; \\ -g &quot;groupA=SUB,groupB=DENY&quot; \\ -w &quot;192.168.0.*&quot; \\ -n 127.0.0.1:9876 参数 是否必填 含义 示例 -a ✅ 必填 用户名（accessKey） rocketmq_user -s ✅ 必填 密码（secretKey） 12345678 -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称，集群中所有 Broker 都会被更新 DefaultCluster -g 可选 指定 Group 权限列表 groupA=SUB,groupB=DENY -t 可选 指定 Topic 权限列表 `topicA=PUB SUB,topicB=DENY` -u 可选 设置默认 Group 权限 SUB -i 可选 设置默认 Topic 权限 DENY -w 可选 设置 IP 白名单 &quot;10.10.10.*,192.168.1.*&quot; -m 可选 是否设置为管理员账号 true 或 false -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — 删除用户 1234sh bin/mqadmin deleteAccessConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin 参数 是否必填 含义 示例 -a ✅ 必填 要删除的用户名（accessKey） rocketmq_user -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称（删除整个集群上的该账号） DefaultCluster -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。 1234567891011121314# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 目前有两种没什么意义的解决方法： 将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.* 为 Proxy 开启 enableAclRpcHookForClusterMode 修改conf/rmq-proxy.json文件，添加enableAclRpcHookForClusterMode参数 1&quot;enableAclRpcHookForClusterMode&quot;: true 修改conf/tools.yml文件，配置帐号信息： 12accessKey: mqadminsecretKey: 1234567 重新启动Proxy即可 两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息 但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置","summary":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-29T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","title":"RocketMQ Admin Tool","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Admin Tool 的常用命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RocketMQ-Admin-Tool-简介\">RocketMQ Admin Tool 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool\">RocketMQ Admin Tool</a> 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。</p>\n</li>\n</ul>\n<h2 id=\"Topic-相关命令\">Topic 相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新 Topic</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全称</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">可选值 / 格式</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\"><code>-t MyTopic</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的 Broker 地址（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>ip:port</code></td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-b 192.168.1.10:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的集群名（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-c DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址列表</td>\n<td style=\"text-align:left\">多个地址用 <code>;</code> 分隔</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-n 192.168.1.1:9876;192.168.1.2:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--readQueueNums</code></td>\n<td style=\"text-align:left\">读队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-r 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--writeQueueNums</code></td>\n<td style=\"text-align:left\">写队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-w 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--perm</code></td>\n<td style=\"text-align:left\">Topic 权限，默认为6</td>\n<td style=\"text-align:left\">2：写（W）<br>4：读（R）<br>6：读写（RW）</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-p 6</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--order</code></td>\n<td style=\"text-align:left\">是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO”</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-o false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unit</code></td>\n<td style=\"text-align:left\">是否为单元（Unit）Topic（用于多租户隔离）</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-u false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--hasUnitSub</code></td>\n<td style=\"text-align:left\">是否有 Unit 订阅</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-s false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">额外属性设置，用 <code>+</code> 表示添加、<code>-</code> 表示删除</td>\n<td style=\"text-align:left\">例：<code>+a=b,+c=d,-e</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-a &quot;+message.type=NORMAL&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><code>-h</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topic</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic  -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic</span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMAL</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a <span class=\"string\">&quot;+message.type=NORMAL&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a <span class=\"string\">&quot;+message.type=FIFO&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定权限，默认为 6：读写</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看与删除 Topic</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，此时只打印 topic 列表</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Group</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876 -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 Topic，删除指定集群下的指定Topic</span></span><br><span class=\"line\">sh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其它 Topic 命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Topic 路由信息</span></span><br><span class=\"line\">sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;brokerDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.188:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.31:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.31:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.188:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">&quot;filterServerTable&quot;</span>:&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"string\">&quot;queueDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Topic 消息队列offset</span></span><br><span class=\"line\">sh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Min Offset           #Max Offset             #Last Updated</span></span><br><span class=\"line\">broker-a                          0     0                     3                       2025-10-27 03:08:43,112</span><br><span class=\"line\">broker-a                          1     0                     4                       2025-10-27 06:13:21,968</span><br><span class=\"line\">broker-a                          2     0                     2                       2025-10-27 06:13:34,685</span><br><span class=\"line\">broker-a                          3     0                     2                       2025-10-26 05:44:17,222</span><br><span class=\"line\">broker-a                          4     0                     1                       2025-10-26 05:44:45,513</span><br><span class=\"line\">broker-a                          5     0                     1                       2025-10-26 06:13:10,541</span><br><span class=\"line\">broker-a                          6     0                     2                       2025-10-26 02:58:34,393</span><br><span class=\"line\">broker-a                          7     0                     1                       2025-10-25 12:42:41,189</span><br><span class=\"line\">broker-b                          0     0                     1                       2025-10-25 14:01:24,836</span><br><span class=\"line\">broker-b                          1     0                     2                       2025-10-26 06:14:24,411</span><br><span class=\"line\">broker-b                          2     0                     0</span><br><span class=\"line\">broker-b                          3     0                     0</span><br><span class=\"line\">broker-b                          4     0                     0</span><br><span class=\"line\">broker-b                          5     0                     1                       2025-10-25 12:30:57,672</span><br><span class=\"line\">broker-b                          6     0                     1                       2025-10-26 06:19:47,051</span><br><span class=\"line\">broker-b                          7     0                     1                       2025-10-26 06:14:49,216</span><br></pre></td></tr></table></figure>\n<h2 id=\"集群相关命令\">集群相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群信息</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               2.60(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.03         0.3300          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                1     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  67.03         0.3200         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.80(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3200          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                1     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3300         <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\"><span class=\"comment\">#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)</span></span><br><span class=\"line\"><span class=\"comment\">#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)</span></span><br><span class=\"line\"><span class=\"comment\">#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计</span></span><br><span class=\"line\"><span class=\"comment\">#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好</span></span><br><span class=\"line\"><span class=\"comment\">#Hour: 表示 Broker 已运行的时长</span></span><br><span class=\"line\"><span class=\"comment\">#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%</span></span><br><span class=\"line\"><span class=\"comment\">#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群统计信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name     #Broker Name                       #InTotalYest  #OutTotalYest  #InTotalToday #OutTotalToday</span></span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0            369              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0              0              0              0</span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"消息相关\">消息相关</h2>\n<h3 id=\"发送消息\">发送消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">消息要发送的 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必须指定目标 Topic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--body</code></td>\n<td style=\"text-align:left\">消息体内容（UTF-8 字符串）</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>&quot;Hello RocketMQ&quot;</code></td>\n<td style=\"text-align:left\">实际消息内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">不指定则用默认配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--broker</code></td>\n<td style=\"text-align:left\">指定发送到哪个 broker</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">一般用于测试 Broker 状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--qid</code></td>\n<td style=\"text-align:left\">指定发送到的队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">一般不需要设置，RocketMQ 会自动选择</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--tags</code></td>\n<td style=\"text-align:left\">消息的标签（tag）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>testTag</code></td>\n<td style=\"text-align:left\">用于消息过滤</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k</code></td>\n<td style=\"text-align:left\"><code>--key</code></td>\n<td style=\"text-align:left\">消息的业务键（key）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>order123</code></td>\n<td style=\"text-align:left\">可用于追踪消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--msgTraceEnable</code></td>\n<td style=\"text-align:left\">是否开启消息轨迹</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">默认 <code>false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送消息</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Send Result            #MsgId</span></span><br><span class=\"line\">broker-b                          2     SEND_OK                 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\"><span class=\"comment\">## 输出解释</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name: Broker 名称</span></span><br><span class=\"line\"><span class=\"comment\">#QID: 队列 ID</span></span><br><span class=\"line\"><span class=\"comment\">#Send Result: 发送结果，SEND_OK 表示成功</span></span><br><span class=\"line\"><span class=\"comment\">#MsgId: 消息 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 tags、key</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span> -c testTag -k order123</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费消息\">消费消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议填写以避免默认配置不生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">可指定消费组（影响消费位点）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerName</code></td>\n<td style=\"text-align:left\">Broker 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">指定从哪个 broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--queueId</code></td>\n<td style=\"text-align:left\">队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">默认从 0 号队列开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--offset</code></td>\n<td style=\"text-align:left\">队列起始偏移量（offset）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">指定从哪个位置开始消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--MessageNumber</code></td>\n<td style=\"text-align:left\">消费消息数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10</code></td>\n<td style=\"text-align:left\">默认通常为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--beginTimestamp</code></td>\n<td style=\"text-align:left\">起始时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#10:00:00:000</code></td>\n<td style=\"text-align:left\">格式或时间戳均可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e</code></td>\n<td style=\"text-align:left\"><code>--endTimestamp</code></td>\n<td style=\"text-align:left\">结束时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#12:00:00:000</code></td>\n<td style=\"text-align:left\">与 <code>-s</code> 一起使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认从队列 0 开始消费，拉取全部消息</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic</span><br><span class=\"line\"><span class=\"comment\"># 拉取指定条数的消息，-c 指定拉取条数</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10</span><br><span class=\"line\"><span class=\"comment\"># 指定偏移量，此时必须同时指定 brokerName、queueId、offset</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3</span><br><span class=\"line\"><span class=\"comment\"># 指定消费者组</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup</span><br><span class=\"line\"><span class=\"comment\"># 指定时间范围</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000</span><br></pre></td></tr></table></figure>\n<h4 id=\"消费结果\">消费结果</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consume ok</span><br><span class=\"line\">MSGID: 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0,</span><br><span class=\"line\">  bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362,</span><br><span class=\"line\">  storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011,</span><br><span class=\"line\">  msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881,</span><br><span class=\"line\">  bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0,</span><br><span class=\"line\">  toString()=Message&#123;topic=<span class=\"string\">&#x27;TestTopic&#x27;</span>, flag=0,</span><br><span class=\"line\">    properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000,</span><br><span class=\"line\">      CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>, MAX_OFFSET=1&#125;,</span><br><span class=\"line\">    body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81],</span><br><span class=\"line\">    transactionId=<span class=\"string\">&#x27;null&#x27;</span>&#125;]</span><br><span class=\"line\">BODY: Hello RocketMQ</span><br><span class=\"line\"></span><br><span class=\"line\">MessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] <span class=\"built_in\">print</span> msg finished. status=NO_NEW_MSG, offset=1</span><br><span class=\"line\">The older -1 message of the 2 queue will be provided</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📘 字段解析表格</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>MSGID</strong></td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">消息唯一标识（客户端生成）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>brokerName</strong></td>\n<td style=\"text-align:left\"><code>broker-b</code></td>\n<td style=\"text-align:left\">消息存储在哪个 Broker 上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueId</strong></td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">存储的队列编号（TestTopic 有多个队列时的第 3 个）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">队列中的偏移量（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeSize</strong></td>\n<td style=\"text-align:left\"><code>228</code></td>\n<td style=\"text-align:left\">消息在磁盘中的存储字节大小</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>sysFlag</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">消息系统标志位（内部用途）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706671</code></td>\n<td style=\"text-align:left\">消息在生产者端创建的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者客户端的 IP 和端口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706691</code></td>\n<td style=\"text-align:left\">消息被 Broker 存储的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">Broker 的存储节点地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>msgId</strong></td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">消息在 Broker 存储系统生成的唯一 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>commitLogOffset</strong></td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">消息在 commitLog 文件中的偏移量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bodyCRC</strong></td>\n<td style=\"text-align:left\"><code>1774740973</code></td>\n<td style=\"text-align:left\">消息体的 CRC 校验码（用于校验数据一致性）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>reconsumeTimes</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">被重新消费的次数（0 表示第一次消费）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>preparedTransactionOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">如果是事务消息，这里会记录预提交偏移量；普通消息为 0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>topic</strong></td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>properties</strong></td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125;</code></td>\n<td style=\"text-align:left\">消息属性，包括系统属性与用户属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>body</strong></td>\n<td style=\"text-align:left\"><code>[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81]</code></td>\n<td style=\"text-align:left\">消息体的字节数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BODY（解码后）</strong></td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">实际消息内容（UTF-8 字符串）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚙️ 消息状态说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">输出信息</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>Consume ok</code></td>\n<td style=\"text-align:left\">表示成功从 Broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>status=NO_NEW_MSG</code></td>\n<td style=\"text-align:left\">当前队列（queueId=2）中已经没有比 offset=1 更新的消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>offset=1</code></td>\n<td style=\"text-align:left\">当前队列消费到 offset=1（下次消费从此开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>The older -1 message of the 2 queue will be provided</code></td>\n<td style=\"text-align:left\">这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查询消息\">查询消息</h3>\n<h4 id=\"根据消息-ID-查询消息-queryMsgById\">根据消息 ID 查询消息(queryMsgById)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--msgId</code></td>\n<td style=\"text-align:left\">要查询的消息 ID</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">必填，用于精确定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--cluster</code></td>\n<td style=\"text-align:left\">集群名称或 LMQ 父 Topic</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">在多集群场景下使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">当用于消费者关联查询时可指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--clientId</code></td>\n<td style=\"text-align:left\">消费者客户端 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>192.168.0.1@12345</code></td>\n<td style=\"text-align:left\">辅助定位消费实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-f</code></td>\n<td style=\"text-align:left\"><code>--bodyFormat</code></td>\n<td style=\"text-align:left\">消息体输出格式</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>UTF-8</code> / <code>HEX</code> / <code>BASE64</code></td>\n<td style=\"text-align:left\">默认 UTF-8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--sendMessage</code></td>\n<td style=\"text-align:left\">是否重新发送消息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">调试时可使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unitName</code></td>\n<td style=\"text-align:left\">单元名（多单元部署时使用）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>unit01</code></td>\n<td style=\"text-align:left\">一般场景可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">OffsetID:            0AFA00BC00002B0300000000000CA1E9</span><br><span class=\"line\">Topic:               TestTopic</span><br><span class=\"line\">Tags:                [null]</span><br><span class=\"line\">Keys:                [null]</span><br><span class=\"line\">Queue ID:            2</span><br><span class=\"line\">Queue Offset:        0</span><br><span class=\"line\">CommitLog Offset:    827881</span><br><span class=\"line\">Reconsume Times:     0</span><br><span class=\"line\">Born Timestamp:      2025-10-28 08:05:06,671</span><br><span class=\"line\">Store Timestamp:     2025-10-28 08:05:06,691</span><br><span class=\"line\">Born Host:           10.250.0.175:41362</span><br><span class=\"line\">Store Host:          10.250.0.188:11011</span><br><span class=\"line\">System Flag:         0</span><br><span class=\"line\">Properties:          &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">Message Body Path:   /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">Message Body:        Hello RocketMQ</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>输出字段详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段名</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>OffsetID</strong></td>\n<td style=\"text-align:left\">消息在 CommitLog 中的偏移标识（内部定位使用）</td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">可用于 broker 内部追踪定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Topic</strong></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属的主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Tags</strong></td>\n<td style=\"text-align:left\">消息标签</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">若生产消息时未设置 tag，则为 null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Keys</strong></td>\n<td style=\"text-align:left\">消息键</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">通常可用于业务层索引查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue ID</strong></td>\n<td style=\"text-align:left\">消息所在的队列编号</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">对应 topic 的第 3 个队列（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue Offset</strong></td>\n<td style=\"text-align:left\">队列偏移量</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示是该队列的第一条消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>CommitLog Offset</strong></td>\n<td style=\"text-align:left\">消息在 commitlog 文件中的偏移量</td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">broker 存储层位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Reconsume Times</strong></td>\n<td style=\"text-align:left\">被重新消费的次数</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示未重试消费过</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Timestamp</strong></td>\n<td style=\"text-align:left\">消息生成时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,671</code></td>\n<td style=\"text-align:left\">生产者发送消息的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Timestamp</strong></td>\n<td style=\"text-align:left\">消息存储时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,691</code></td>\n<td style=\"text-align:left\">broker 写入消息的时间（通常相差几毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Host</strong></td>\n<td style=\"text-align:left\">生产者客户端 IP:端口</td>\n<td style=\"text-align:left\"><code>10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者所在机器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Host</strong></td>\n<td style=\"text-align:left\">broker 存储该消息的地址</td>\n<td style=\"text-align:left\"><code>10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">对应的 broker 服务端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>System Flag</strong></td>\n<td style=\"text-align:left\">系统标志位</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用（标识压缩/事务等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Properties</strong></td>\n<td style=\"text-align:left\">消息属性</td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;</code></td>\n<td style=\"text-align:left\">包含 RocketMQ 自动附加的元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body Path</strong></td>\n<td style=\"text-align:left\">消息体在本地保存的文件路径</td>\n<td style=\"text-align:left\"><code>/tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body</strong></td>\n<td style=\"text-align:left\">消息内容</td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">消息内容</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"根据消息-Key-查询消息-queryMsgByKey\">根据消息 Key 查询消息(queryMsgByKey)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t, --topic</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">要查询的主题名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k, --msgKey</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>order_10001</code></td>\n<td style=\"text-align:left\">发送消息时设置的业务 Key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n, --namesrvAddr</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c, --cluster</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">指定集群名称（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b, --beginTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730083200000</code></td>\n<td style=\"text-align:left\">查询起始时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e, --endTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730173200000</code></td>\n<td style=\"text-align:left\">查询结束时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m, --maxNum</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>64</code></td>\n<td style=\"text-align:left\">返回的最大消息数，默认 64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h, --help</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123</span><br><span class=\"line\"><span class=\"comment\">## 查询结果</span></span><br><span class=\"line\"><span class=\"comment\">#Message ID                                        #QID                                  #Offset</span></span><br><span class=\"line\">0AFA00AFCF781EB44E468CC902A30000                      7                                        1</span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者\">消费者</h2>\n<h4 id=\"创建或更新消费者订阅组-updateSubGroup\">创建或更新消费者订阅组(updateSubGroup)</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">消费顺序（顺序/并发）</li>\n<li class=\"lvl-6\">广播模式</li>\n<li class=\"lvl-6\">消费使能</li>\n<li class=\"lvl-6\">消费重试策略</li>\n<li class=\"lvl-6\">延迟消费队列等</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--groupName</code></td>\n<td style=\"text-align:left\">消费者组名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestConsumerGroup</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定 Broker 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10.250.0.188:10911</code></td>\n<td style=\"text-align:left\">仅对单 Broker 更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定 Cluster 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">对整个集群更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--consumeBroadcastEnable</code></td>\n<td style=\"text-align:left\">是否广播消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">true 表示广播，false 表示集群模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--consumeMessageOrderly</code></td>\n<td style=\"text-align:left\">是否顺序消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">顺序消费只在同队列中生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--brokerId</code></td>\n<td style=\"text-align:left\">从哪个 Broker 获取订阅信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部用途，通常不用设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--consumeFromMinEnable</code></td>\n<td style=\"text-align:left\">是否从最小 offset 消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">新组首次消费时生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--groupRetryPolicy</code></td>\n<td style=\"text-align:left\">消费组重试策略 JSON</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;</code></td>\n<td style=\"text-align:left\">可以自定义重试间隔</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-q</code></td>\n<td style=\"text-align:left\"><code>--retryQueueNums</code></td>\n<td style=\"text-align:left\">重试队列数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1</code> ~ <code>16</code></td>\n<td style=\"text-align:left\">默认为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--retryMaxTimes</code></td>\n<td style=\"text-align:left\">最大重试次数</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>16</code></td>\n<td style=\"text-align:left\">默认 16 次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--consumeEnable</code></td>\n<td style=\"text-align:left\">是否使能消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">false 表示暂停消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--whichBrokerWhenConsumeSlowly</code></td>\n<td style=\"text-align:left\">慢消费选择 Broker ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--notifyConsumerIdsChanged</code></td>\n<td style=\"text-align:left\">通知 ConsumerId 改变</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可触发消费者刷新订阅信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">其他自定义属性</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>attr1=val1,attr2=val2</code></td>\n<td style=\"text-align:left\">可设置自定义配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">显示命令帮助</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建普通消费者组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 创建顺序消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建广播消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建自定义属性的消费者组，这里配置了重试策略</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d <span class=\"literal\">true</span> -o <span class=\"literal\">true</span> -m <span class=\"literal\">true</span> -p <span class=\"string\">&#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27;</span> -q 1 -r 16 -s <span class=\"literal\">true</span> -w 0 -a <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"删除消费者订阅组-deleteSubGroup\">删除消费者订阅组(deleteSubGroup)</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要说明\">重要说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ Admin Tool 简介 RocketMQ Admin Tool 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。 Topic 相关命令 创建或更新 Topic 参数 全称 说明 可选值 / 格式 是否必填 示例 -t --topic 主题名称 字符串 ✅ 必填 -t MyTopic -b --brokerAddr 指定创建 Topic 的 Broker 地址（与 -c 二选一） ip:port ✅ 必填（与 -c 二选一） -b 192.168.1.10:10911 -c --clusterName 指定创建 Topic 的集群名（与 -b 二选一） 字符串 ✅ 必填（与 -b 二选一） -c DefaultCluster -n --namesrvAddr NameServer 地址列表 多个地址用 ; 分隔 可选 -n 192.168.1.1:9876;192.168.1.2:9876 -r --readQueueNums 读队列数量，默认为8，始终保持 r == w 整数 可选 -r 4 -w --writeQueueNums 写队列数量，默认为8，始终保持 r == w 整数 可选 -w 4 -p --perm Topic 权限，默认为6 2：写（W）4：读（R）6：读写（RW） 可选 -p 6 -o --order 是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO” true / false 可选 -o false -u --unit 是否为单元（Unit）Topic（用于多租户隔离） true / false 可选 -u false -s --hasUnitSub 是否有 Unit 订阅 true / false 可选 -s false -a --attributes 额外属性设置，用 + 表示添加、- 表示删除 例：+a=b,+c=d,-e 可选 -a &quot;+message.type=NORMAL&quot; -h --help 打印帮助信息 无 否 -h 示例 12345678910# 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topicsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster# 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic# 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMALsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a &quot;+message.type=NORMAL&quot;# 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a &quot;+message.type=FIFO&quot;# 指定权限，默认为 6：读写sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6 查看与删除 Topic 1234567# 查看所有 Topic，此时只打印 topic 列表sh bin/mqadmin topicList -n 127.0.0.1:9876# 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Groupsh bin/mqadmin topicList -n 127.0.0.1:9876 -c# 删除 Topic，删除指定集群下的指定Topicsh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster 其它 Topic 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 查看 Topic 路由信息sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic## 输出&#123; &quot;brokerDatas&quot;:[ &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.188:11011&quot;,1:&quot;10.250.0.31:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125;, &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.31:11011&quot;,1:&quot;10.250.0.188:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125; ], &quot;filterServerTable&quot;:&#123;&#125;, &quot;queueDatas&quot;:[ &#123; &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125;, &#123; &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125; ]&#125;# 查看 Topic 消息队列offsetsh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic## 输出#Broker Name #QID #Min Offset #Max Offset #Last Updatedbroker-a 0 0 3 2025-10-27 03:08:43,112broker-a 1 0 4 2025-10-27 06:13:21,968broker-a 2 0 2 2025-10-27 06:13:34,685broker-a 3 0 2 2025-10-26 05:44:17,222broker-a 4 0 1 2025-10-26 05:44:45,513broker-a 5 0 1 2025-10-26 06:13:10,541broker-a 6 0 2 2025-10-26 02:58:34,393broker-a 7 0 1 2025-10-25 12:42:41,189broker-b 0 0 1 2025-10-25 14:01:24,836broker-b 1 0 2 2025-10-26 06:14:24,411broker-b 2 0 0broker-b 3 0 0broker-b 4 0 0broker-b 5 0 1 2025-10-25 12:30:57,672broker-b 6 0 1 2025-10-26 06:19:47,051broker-b 7 0 1 2025-10-26 06:14:49,216 集群相关命令 查看集群信息，集群、BrokerName、BrokerId、TPS等信息 123456789101112131415161718# 集群信息sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster## 输出#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 2.60(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.03 0.3300 trueDefaultCluster broker-a 1 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 67.03 0.3200 falseDefaultCluster broker-b 0 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.80(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3200 trueDefaultCluster broker-b 1 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3300 false## Broker 统计信息#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好#Hour: 表示 Broker 已运行的时长#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master 查看集群统计信息 123456789101112sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m## 输出#Cluster Name #Broker Name #InTotalYest #OutTotalYest #InTotalToday #OutTotalTodayDefaultCluster broker-a 0 0 0 0DefaultCluster broker-a 0 0 0 0DefaultCluster broker-b 0 369 0 0DefaultCluster broker-b 0 0 0 0## Broker 统计信息#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数 消息相关 发送消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 消息要发送的 Topic 名称 ✅ TestTopic 必须指定目标 Topic -p --body 消息体内容（UTF-8 字符串） ✅ &quot;Hello RocketMQ&quot; 实际消息内容 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 不指定则用默认配置 -b --broker 指定发送到哪个 broker ❌ broker-a 一般用于测试 Broker 状态 -i --qid 指定发送到的队列 ID ❌ 2 一般不需要设置，RocketMQ 会自动选择 -c --tags 消息的标签（tag） ❌ testTag 用于消息过滤 -k --key 消息的业务键（key） ❌ order123 可用于追踪消息 -m --msgTraceEnable 是否开启消息轨迹 ❌ true 默认 false -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 1234567891011121314# 发送消息sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot;## 输出#Broker Name #QID #Send Result #MsgIdbroker-b 2 SEND_OK 0AFA00AFCF171EB44E468CC7D5EE0000## 输出解释#Broker Name: Broker 名称#QID: 队列 ID#Send Result: 发送结果，SEND_OK 表示成功#MsgId: 消息 ID# 指定 tags、keysh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot; -c testTag -k order123 消费消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议填写以避免默认配置不生效 -g --consumerGroup 消费组名称 ❌ TestGroup 可指定消费组（影响消费位点） -b --brokerName Broker 名称 ❌ broker-a 指定从哪个 broker 拉取消息 -i --queueId 队列 ID ❌ 0 默认从 0 号队列开始 -o --offset 队列起始偏移量（offset） ❌ 0 指定从哪个位置开始消费 -c --MessageNumber 消费消息数量 ❌ 10 默认通常为 1 -s --beginTimestamp 起始时间 ❌ 2025-10-28#10:00:00:000 格式或时间戳均可 -e --endTimestamp 结束时间 ❌ 2025-10-28#12:00:00:000 与 -s 一起使用 -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 12345678910# 默认从队列 0 开始消费，拉取全部消息sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic# 拉取指定条数的消息，-c 指定拉取条数sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10# 指定偏移量，此时必须同时指定 brokerName、queueId、offsetsh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3# 指定消费者组sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup# 指定时间范围sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000 消费结果 12345678910111213141516Consume okMSGID: 0AFA00AFCF171EB44E468CC7D5EE0000MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0, bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362, storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011, msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881, bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TestTopic&#x27;, flag=0, properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=true, TRACE_ON=true, MAX_OFFSET=1&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81], transactionId=&#x27;null&#x27;&#125;]BODY: Hello RocketMQMessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] print msg finished. status=NO_NEW_MSG, offset=1The older -1 message of the 2 queue will be provided 📘 字段解析表格 字段 示例值 说明 MSGID 0AFA00AFCF171EB44E468CC7D5EE0000 消息唯一标识（客户端生成） brokerName broker-b 消息存储在哪个 Broker 上 queueId 2 存储的队列编号（TestTopic 有多个队列时的第 3 个） queueOffset 0 队列中的偏移量（从 0 开始） storeSize 228 消息在磁盘中的存储字节大小 sysFlag 0 消息系统标志位（内部用途） bornTimestamp 1761638706671 消息在生产者端创建的时间（毫秒） bornHost /10.250.0.175:41362 生产者客户端的 IP 和端口 storeTimestamp 1761638706691 消息被 Broker 存储的时间（毫秒） storeHost /10.250.0.188:11011 Broker 的存储节点地址 msgId 0AFA00BC00002B0300000000000CA1E9 消息在 Broker 存储系统生成的唯一 ID commitLogOffset 827881 消息在 commitLog 文件中的偏移量 bodyCRC 1774740973 消息体的 CRC 校验码（用于校验数据一致性） reconsumeTimes 0 被重新消费的次数（0 表示第一次消费） preparedTransactionOffset 0 如果是事务消息，这里会记录预提交偏移量；普通消息为 0 topic TestTopic 消息所属主题 properties &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125; 消息属性，包括系统属性与用户属性 body [72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81] 消息体的字节数组 BODY（解码后） Hello RocketMQ 实际消息内容（UTF-8 字符串） ⚙️ 消息状态说明 输出信息 含义 Consume ok 表示成功从 Broker 拉取消息 status=NO_NEW_MSG 当前队列（queueId=2）中已经没有比 offset=1 更新的消息 offset=1 当前队列消费到 offset=1（下次消费从此开始） The older -1 message of the 2 queue will be provided 这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息） 查询消息 根据消息 ID 查询消息(queryMsgById) 参数 全写 说明 是否必填 示例值 备注 -i --msgId 要查询的消息 ID ✅ 0AFA00AFCF171EB44E468CC7D5EE0000 必填，用于精确定位消息 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -c --cluster 集群名称或 LMQ 父 Topic ❌ DefaultCluster 在多集群场景下使用 -g --consumerGroup 消费组名称 ❌ TestGroup 当用于消费者关联查询时可指定 -d --clientId 消费者客户端 ID ❌ 192.168.0.1@12345 辅助定位消费实例 -f --bodyFormat 消息体输出格式 ❌ UTF-8 / HEX / BASE64 默认 UTF-8 -s --sendMessage 是否重新发送消息 ❌ true 调试时可使用 -u --unitName 单元名（多单元部署时使用） ❌ unit01 一般场景可忽略 -h --help 打印帮助信息 ❌ 无 显示命令说明 示例 123456789101112131415161718sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8## 输出OffsetID: 0AFA00BC00002B0300000000000CA1E9Topic: TestTopicTags: [null]Keys: [null]Queue ID: 2Queue Offset: 0CommitLog Offset: 827881Reconsume Times: 0Born Timestamp: 2025-10-28 08:05:06,671Store Timestamp: 2025-10-28 08:05:06,691Born Host: 10.250.0.175:41362Store Host: 10.250.0.188:11011System Flag: 0Properties: &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;Message Body Path: /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000Message Body: Hello RocketMQ 输出字段详解 字段名 含义 示例 说明 OffsetID 消息在 CommitLog 中的偏移标识（内部定位使用） 0AFA00BC00002B0300000000000CA1E9 可用于 broker 内部追踪定位消息 Topic 主题名称 TestTopic 消息所属的主题 Tags 消息标签 [null] 若生产消息时未设置 tag，则为 null Keys 消息键 [null] 通常可用于业务层索引查询 Queue ID 消息所在的队列编号 2 对应 topic 的第 3 个队列（从 0 开始） Queue Offset 队列偏移量 0 表示是该队列的第一条消息 CommitLog Offset 消息在 commitlog 文件中的偏移量 827881 broker 存储层位置 Reconsume Times 被重新消费的次数 0 表示未重试消费过 Born Timestamp 消息生成时间 2025-10-28 08:05:06,671 生产者发送消息的时间 Store Timestamp 消息存储时间 2025-10-28 08:05:06,691 broker 写入消息的时间（通常相差几毫秒） Born Host 生产者客户端 IP:端口 10.250.0.175:41362 生产者所在机器 Store Host broker 存储该消息的地址 10.250.0.188:11011 对应的 broker 服务端 System Flag 系统标志位 0 内部使用（标识压缩/事务等） Properties 消息属性 &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125; 包含 RocketMQ 自动附加的元数据 Message Body Path 消息体在本地保存的文件路径 /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000 RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看 Message Body 消息内容 Hello RocketMQ 消息内容 根据消息 Key 查询消息(queryMsgByKey) 参数 必填 示例 说明 -t, --topic ✅ TestTopic 要查询的主题名称 -k, --msgKey ✅ order_10001 发送消息时设置的业务 Key -n, --namesrvAddr ❌ 127.0.0.1:9876 NameServer 地址 -c, --cluster ❌ DefaultCluster 指定集群名称（可选） -b, --beginTimestamp ❌ 1730083200000 查询起始时间戳（ms） -e, --endTimestamp ❌ 1730173200000 查询结束时间戳（ms） -m, --maxNum ❌ 64 返回的最大消息数，默认 64 -h, --help ❌ - 打印帮助信息 示例 1234sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123## 查询结果#Message ID #QID #Offset0AFA00AFCF781EB44E468CC902A30000 7 1 消费者 创建或更新消费者订阅组(updateSubGroup) 消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如： 消费顺序（顺序/并发） 广播模式 消费使能 消费重试策略 延迟消费队列等 参数 全写 说明 是否必填 示例值 备注 -g --groupName 消费者组名称 ✅ TestConsumerGroup 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -b --brokerAddr 指定 Broker 地址 ❌ 10.250.0.188:10911 仅对单 Broker 更新 -c --clusterName 指定 Cluster 名称 ❌ DefaultCluster 对整个集群更新 -d --consumeBroadcastEnable 是否广播消费 ❌ true / false true 表示广播，false 表示集群模式 -o --consumeMessageOrderly 是否顺序消费 ❌ true / false 顺序消费只在同队列中生效 -i --brokerId 从哪个 Broker 获取订阅信息 ❌ 0 内部用途，通常不用设置 -m --consumeFromMinEnable 是否从最小 offset 消费 ❌ true / false 新组首次消费时生效 -p --groupRetryPolicy 消费组重试策略 JSON ❌ &#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125; 可以自定义重试间隔 -q --retryQueueNums 重试队列数量 ❌ 1 ~ 16 默认为 1 -r --retryMaxTimes 最大重试次数 ❌ 16 默认 16 次 -s --consumeEnable 是否使能消费 ❌ true / false false 表示暂停消费 -w --whichBrokerWhenConsumeSlowly 慢消费选择 Broker ID ❌ 0 内部使用 -a --notifyConsumerIdsChanged 通知 ConsumerId 改变 ❌ true / false 可触发消费者刷新订阅信息 --attributes --attributes 其他自定义属性 ❌ attr1=val1,attr2=val2 可设置自定义配置 -h --help 打印帮助 ❌ - 显示命令帮助 示例 12345678910# 创建普通消费者组sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876# 创建顺序消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o true# 创建广播消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d true# 创建自定义属性的消费者组，这里配置了重试策略sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d true -o true -m true -p &#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27; -q 1 -r 16 -s true -w 0 -a true 删除消费者订阅组(deleteSubGroup) 1sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster 重要说明 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567","summary":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","title":"RocketMQ Proxy 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Proxy 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外在源码 <code>rocketmq-all-5.3.2-source-release/proxy</code> 的启动类 <code>org.apache.rocketmq.proxy.ProxyStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.rocketmq.proxy.config.ProxyConfig</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">优化建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础信息</strong></td>\n<td style=\"text-align:left\"><code>rocketMQClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Broker 集群名称（Proxy 用于关联 RocketMQ 集群）</td>\n<td style=\"text-align:left\">若有多个集群，应唯一命名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Proxy 所属集群名称（与 brokerClusterName 可不同）</td>\n<td style=\"text-align:left\">✅建议独立命名，区分 Proxy 集群</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyName</code></td>\n<td style=\"text-align:left\">主机名（例：<code>ip-10-250-0-175...</code>）</td>\n<td style=\"text-align:left\">Proxy 实例名称，用于唯一标识</td>\n<td style=\"text-align:left\">✅建议设置唯一名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>localServeAddr</code></td>\n<td style=\"text-align:left\">本地 IP</td>\n<td style=\"text-align:left\">Proxy 本地服务地址（Remoting 通信使用）</td>\n<td style=\"text-align:left\">✅建议显式指定 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Namesrv</strong></td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\">多个地址（分号分隔）</td>\n<td style=\"text-align:left\">NameServer 地址，Proxy 通过它同步路由</td>\n<td style=\"text-align:left\">✅推荐配置为可访问的内网地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomain</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">NameServer 域名（可用于动态解析）</td>\n<td style=\"text-align:left\">可选，DNS 方式时使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomainSubgroup</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">子域分组（多集群域名发现用）</td>\n<td style=\"text-align:left\">一般可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TLS 配置</strong></td>\n<td style=\"text-align:left\"><code>tlsTestModeEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">测试模式下跳过验证（仅用于本地测试）</td>\n<td style=\"text-align:left\">❗生产应设为 false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsKeyPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.key</code></td>\n<td style=\"text-align:left\">TLS 私钥路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsCertPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.crt</code></td>\n<td style=\"text-align:left\">TLS 证书路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>gRPC 基础</strong></td>\n<td style=\"text-align:left\"><code>proxyMode</code></td>\n<td style=\"text-align:left\"><code>CLUSTER</code></td>\n<td style=\"text-align:left\">Proxy 模式：CLUSTER / LOCAL / REMOTING</td>\n<td style=\"text-align:left\">✅生产推荐 CLUSTER</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcServerPort</code></td>\n<td style=\"text-align:left\">8081</td>\n<td style=\"text-align:left\">gRPC 服务端监听端口</td>\n<td style=\"text-align:left\">若冲突可修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcShutdownTimeSeconds</code></td>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\">优雅关闭等待时间</td>\n<td style=\"text-align:left\">可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableGrpcEpoll</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用 Linux epoll I/O 模型</td>\n<td style=\"text-align:left\">✅Linux 建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcMaxInboundMessageSize</code></td>\n<td style=\"text-align:left\">136314880 (~130MB)</td>\n<td style=\"text-align:left\">最大入站消息大小</td>\n<td style=\"text-align:left\">根据消息大小调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息限制</strong></td>\n<td style=\"text-align:left\"><code>maxMessageSize</code></td>\n<td style=\"text-align:left\">4194304 (4MB)</td>\n<td style=\"text-align:left\">最大消息体大小</td>\n<td style=\"text-align:left\">✅应与 Broker 一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableMessageBodyEmptyCheck</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">校验消息体是否为空</td>\n<td style=\"text-align:left\">保持默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxUserPropertySize</code></td>\n<td style=\"text-align:left\">16384 (16KB)</td>\n<td style=\"text-align:left\">用户属性最大长度</td>\n<td style=\"text-align:left\">根据业务复杂度调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>userPropertyMaxNum</code></td>\n<td style=\"text-align:left\">128</td>\n<td style=\"text-align:left\">单条消息最大属性数量</td>\n<td style=\"text-align:left\">可适当调低防止性能损耗</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxMessageGroupSize</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">最大消息组大小（批量 pop 使用）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息可见性与延迟</strong></td>\n<td style=\"text-align:left\"><code>defaultInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">60000 (60s)</td>\n<td style=\"text-align:left\">pop 消息默认不可见时间</td>\n<td style=\"text-align:left\">✅高并发时可调低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">43200000 (12h)</td>\n<td style=\"text-align:left\">最大不可见时长</td>\n<td style=\"text-align:left\">✅可根据业务降低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxDelayTimeMills</code></td>\n<td style=\"text-align:left\">86400000 (1d)</td>\n<td style=\"text-align:left\">最大延迟时间</td>\n<td style=\"text-align:left\">与 Broker 保持一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useDelayLevel</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否使用延迟等级模式</td>\n<td style=\"text-align:left\">若 Broker 启用等级延迟则开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>messageDelayLevel</code></td>\n<td style=\"text-align:left\"><code>&quot;1s 5s 10s ... 2h&quot;</code></td>\n<td style=\"text-align:left\">延迟等级配置表</td>\n<td style=\"text-align:left\">✅需与 broker.conf 对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（gRPC 模块）</strong></td>\n<td style=\"text-align:left\"><code>grpcBossLoopNum</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">Netty boss 线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcWorkerLoopNum</code></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">gRPC worker 线程</td>\n<td style=\"text-align:left\">✅CPU&gt;4 时可调高至核数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">gRPC 业务线程数</td>\n<td style=\"text-align:left\">✅建议 ≈ CPU 核数×2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolQueueCapacity</code></td>\n<td style=\"text-align:left\">100000</td>\n<td style=\"text-align:left\">队列容量</td>\n<td style=\"text-align:left\">⚠️建议 ≤20000，防 OOM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（内部模块）</strong></td>\n<td style=\"text-align:left\"><code>producerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">生产者处理线程</td>\n<td style=\"text-align:left\">✅可根据QPS调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>consumerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">消费者处理线程</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicRouteServiceThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">路由服务线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>renewThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">自动续期线程</td>\n<td style=\"text-align:left\">高并发时可调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>缓存配置</strong></td>\n<td style=\"text-align:left\"><code>topicRouteServiceCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">路由缓存有效期</td>\n<td style=\"text-align:left\">✅可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">Topic 配置缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>subscriptionGroupConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">订阅组缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>aclCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">ACL 缓存有效期</td>\n<td style=\"text-align:left\">✅同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>事务与心跳</strong></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳线程数</td>\n<td style=\"text-align:left\">✅根据事务量调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatPeriodSecond</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳周期</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionDataExpireMillis</code></td>\n<td style=\"text-align:left\">30000</td>\n<td style=\"text-align:left\">事务数据过期时间</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>指标与监控</strong></td>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">DISABLE</td>\n<td style=\"text-align:left\">指标导出方式：DISABLE / PROM / GRPC / LOG</td>\n<td style=\"text-align:left\">✅建议启用 PROM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">Prometheus 导出端口</td>\n<td style=\"text-align:left\">✅建议暴露监控</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsInDelta</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否按增量导出指标</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Remoting 模式</strong></td>\n<td style=\"text-align:left\"><code>enableRemotingLocalProxyGrpc</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">启用本地 Proxy gRPC 转发</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>remotingListenPort</code></td>\n<td style=\"text-align:left\">8080</td>\n<td style=\"text-align:left\">Remoting 通信端口</td>\n<td style=\"text-align:left\">若冲突修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>sendLatencyEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用发送延迟探测（LoadBalance 优化）</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>startDetectorEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用启动探测功能</td>\n<td style=\"text-align:left\">可选，测试阶段使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可观测性</strong></td>\n<td style=\"text-align:left\"><code>traceOn</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用链路追踪</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enablePrintJstack</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">打印线程堆栈（用于诊断）</td>\n<td style=\"text-align:left\">✅可延长周期减少日志</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>综合优化建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方向</th>\n<th style=\"text-align:left\">建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>性能调优</strong></td>\n<td style=\"text-align:left\">启用 <code>enableGrpcEpoll=true</code>；合理配置线程池（如减少队列长度）；设置合适的 <code>grpcThreadPoolNums</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可靠性</strong></td>\n<td style=\"text-align:left\">开启 <code>traceOn</code> 与 <code>sendLatencyEnable</code> 监控；使用 Prometheus 指标导出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全性</strong></td>\n<td style=\"text-align:left\">禁用 <code>tlsTestModeEnable</code>，使用真实 TLS 证书。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>资源管理</strong></td>\n<td style=\"text-align:left\">限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可维护性</strong></td>\n<td style=\"text-align:left\">使用独立的 <code>proxyClusterName</code>，并在配置文件 <code>rmq-proxy.json</code> 中明确各项端口和路径。</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 配置项项目源码简介 当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。 另外在源码 rocketmq-all-5.3.2-source-release/proxy 的启动类 org.apache.rocketmq.proxy.ProxyStartup中 可以看到其启动时会初始化如下配置项的类 1org.apache.rocketmq.proxy.config.ProxyConfig 配置项说明 Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式 分类 参数名 默认值 说明 优化建议 基础信息 rocketMQClusterName DefaultCluster Broker 集群名称（Proxy 用于关联 RocketMQ 集群） 若有多个集群，应唯一命名 proxyClusterName DefaultCluster Proxy 所属集群名称（与 brokerClusterName 可不同） ✅建议独立命名，区分 Proxy 集群 proxyName 主机名（例：ip-10-250-0-175...） Proxy 实例名称，用于唯一标识 ✅建议设置唯一名称 localServeAddr 本地 IP Proxy 本地服务地址（Remoting 通信使用） ✅建议显式指定 IP Namesrv namesrvAddr 多个地址（分号分隔） NameServer 地址，Proxy 通过它同步路由 ✅推荐配置为可访问的内网地址 namesrvDomain 空 NameServer 域名（可用于动态解析） 可选，DNS 方式时使用 namesrvDomainSubgroup 空 子域分组（多集群域名发现用） 一般可忽略 TLS 配置 tlsTestModeEnable true 测试模式下跳过验证（仅用于本地测试） ❗生产应设为 false tlsKeyPath /conf/tls/rocketmq.key TLS 私钥路径 ✅根据证书路径调整 tlsCertPath /conf/tls/rocketmq.crt TLS 证书路径 ✅根据证书路径调整 gRPC 基础 proxyMode CLUSTER Proxy 模式：CLUSTER / LOCAL / REMOTING ✅生产推荐 CLUSTER grpcServerPort 8081 gRPC 服务端监听端口 若冲突可修改 grpcShutdownTimeSeconds 30 优雅关闭等待时间 可适当调大 enableGrpcEpoll false 启用 Linux epoll I/O 模型 ✅Linux 建议开启 grpcMaxInboundMessageSize 136314880 (~130MB) 最大入站消息大小 根据消息大小调整 消息限制 maxMessageSize 4194304 (4MB) 最大消息体大小 ✅应与 Broker 一致 enableMessageBodyEmptyCheck true 校验消息体是否为空 保持默认即可 maxUserPropertySize 16384 (16KB) 用户属性最大长度 根据业务复杂度调整 userPropertyMaxNum 128 单条消息最大属性数量 可适当调低防止性能损耗 maxMessageGroupSize 64 最大消息组大小（批量 pop 使用） 默认即可 消息可见性与延迟 defaultInvisibleTimeMills 60000 (60s) pop 消息默认不可见时间 ✅高并发时可调低 maxInvisibleTimeMills 43200000 (12h) 最大不可见时长 ✅可根据业务降低 maxDelayTimeMills 86400000 (1d) 最大延迟时间 与 Broker 保持一致 useDelayLevel false 是否使用延迟等级模式 若 Broker 启用等级延迟则开启 messageDelayLevel &quot;1s 5s 10s ... 2h&quot; 延迟等级配置表 ✅需与 broker.conf 对齐 线程池（gRPC 模块） grpcBossLoopNum 1 Netty boss 线程 默认即可 grpcWorkerLoopNum 4 gRPC worker 线程 ✅CPU&gt;4 时可调高至核数 grpcThreadPoolNums 20 gRPC 业务线程数 ✅建议 ≈ CPU 核数×2 grpcThreadPoolQueueCapacity 100000 队列容量 ⚠️建议 ≤20000，防 OOM 线程池（内部模块） producerProcessorThreadPoolNums 2 生产者处理线程 ✅可根据QPS调整 consumerProcessorThreadPoolNums 2 消费者处理线程 同上 topicRouteServiceThreadPoolNums 2 路由服务线程 默认即可 renewThreadPoolNums 2 自动续期线程 高并发时可调大 缓存配置 topicRouteServiceCacheExpiredSeconds 300 路由缓存有效期 ✅可适当调大 topicConfigCacheExpiredSeconds 300 Topic 配置缓存有效期 同上 subscriptionGroupConfigCacheExpiredSeconds 300 订阅组缓存有效期 同上 aclCacheExpiredSeconds 300 ACL 缓存有效期 ✅同上 事务与心跳 transactionHeartbeatThreadPoolNums 20 事务心跳线程数 ✅根据事务量调整 transactionHeartbeatPeriodSecond 20 事务心跳周期 默认即可 transactionDataExpireMillis 30000 事务数据过期时间 默认即可 指标与监控 metricsExporterType DISABLE 指标导出方式：DISABLE / PROM / GRPC / LOG ✅建议启用 PROM metricsPromExporterPort 5557 Prometheus 导出端口 ✅建议暴露监控 metricsInDelta false 是否按增量导出指标 默认即可 Remoting 模式 enableRemotingLocalProxyGrpc true 启用本地 Proxy gRPC 转发 默认即可 remotingListenPort 8080 Remoting 通信端口 若冲突修改 sendLatencyEnable false 启用发送延迟探测（LoadBalance 优化） ✅建议开启 startDetectorEnable false 启用启动探测功能 可选，测试阶段使用 可观测性 traceOn false 启用链路追踪 ✅建议开启 enablePrintJstack true 打印线程堆栈（用于诊断） ✅可延长周期减少日志 综合优化建议 方向 建议 性能调优 启用 enableGrpcEpoll=true；合理配置线程池（如减少队列长度）；设置合适的 grpcThreadPoolNums。 可靠性 开启 traceOn 与 sendLatencyEnable 监控；使用 Prometheus 指标导出。 安全性 禁用 tlsTestModeEnable，使用真实 TLS 证书。 资源管理 限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。 可维护性 使用独立的 proxyClusterName，并在配置文件 rmq-proxy.json 中明确各项端口和路径。","summary":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:33:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-05-controller-config/","title":"RocketMQ Controller 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Controller 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-Controller-配置项\">查看 Controller 配置项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看全部默认配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全部默认配置项</span></span><br><span class=\"line\">sh bin/mqcontroller -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class=\"line\">sh bin/mqcontroller -p -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/controller</code> 的启动类 <code>org.apache.rocketmq.controller.ControllerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ControllerConfig</span> <span class=\"variable\">controllerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControllerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">JraftConfig</span> <span class=\"variable\">jraftConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JraftConfig</span>();</span><br><span class=\"line\">controllerConfig.setJraftConfig(jraftConfig);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyServerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyClientConfig</span>();</span><br><span class=\"line\">nettyServerConfig.setListenPort(<span class=\"number\">19876</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Controller 配置参数说明与优化建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础信息</strong></td>\n<td style=\"text-align:left\"><code>rocketmqHome</code></td>\n<td style=\"text-align:left\">/usr/local/soft/rocketmq/rocketmq5</td>\n<td style=\"text-align:left\">RocketMQ 根路径</td>\n<td style=\"text-align:left\">保持默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>configStorePath</code></td>\n<td style=\"text-align:left\">/root/controller/controller.properties</td>\n<td style=\"text-align:left\">Controller 配置文件路径</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/controller/controller.properties</code>，避免使用 <code>/root</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerType</code></td>\n<td style=\"text-align:left\">DLedger</td>\n<td style=\"text-align:left\">Controller 类型（DLedger / STANDALONE）</td>\n<td style=\"text-align:left\">✅ 建议使用 DLedger（高可用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerStorePath</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Controller 元数据存储路径</td>\n<td style=\"text-align:left\">✅ 建议 <code>/data/rocketmq/controller/store</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>DLedger 选举配置</strong></td>\n<td style=\"text-align:left\"><code>controllerDLegerGroup</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Controller 集群组名</td>\n<td style=\"text-align:left\">✅ 必填，例如：<code>controllerGroup01</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerDLegerPeers</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">集群节点列表，格式：<code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td>\n<td style=\"text-align:left\">✅ 必填（3 节点推荐）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerDLegerSelfId</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">当前节点 ID，如 <code>n0</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>mappedFileSize</code></td>\n<td style=\"text-align:left\">1073741824</td>\n<td style=\"text-align:left\">DLedger 存储文件大小 (1GB)</td>\n<td style=\"text-align:left\">可保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>electMasterMaxRetryCount</code></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Master 选举最大重试次数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableElectUncleanMaster</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否允许选举非同步 Master</td>\n<td style=\"text-align:left\">✅ 建议保持 false（避免数据丢失）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Broker 管理</strong></td>\n<td style=\"text-align:left\"><code>scanNotActiveBrokerInterval</code></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">扫描不活跃 Broker 的间隔(ms)</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>scanInactiveMasterInterval</code></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">检测失活 Master 间隔(ms)</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>notifyBrokerRoleChanged</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否通知 Broker 角色变更</td>\n<td style=\"text-align:left\">✅ 建议开启（保持同步）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>isProcessReadEvent</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否处理读事件</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程与性能</strong></td>\n<td style=\"text-align:left\"><code>controllerThreadPoolNums</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">控制线程池大小</td>\n<td style=\"text-align:left\">可调至 8–32 视规模而定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>controllerRequestThreadPoolQueueCapacity</code></td>\n<td style=\"text-align:left\">50000</td>\n<td style=\"text-align:left\">控制线程池队列容量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Metrics 监控</strong></td>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">DISABLE</td>\n<td style=\"text-align:left\">指标输出方式（DISABLE / PROM / GRPC / LOG）</td>\n<td style=\"text-align:left\">✅ 建议设为 <code>PROM</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">Prometheus 端口</td>\n<td style=\"text-align:left\">✅ 若启用监控，可用默认 5557</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterHost</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Prometheus 绑定主机</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricLoggingExporterIntervalInMills</code></td>\n<td style=\"text-align:left\">10000</td>\n<td style=\"text-align:left\">日志输出指标间隔</td>\n<td style=\"text-align:left\">可调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsGrpcExporterTarget</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">gRPC 监控目标</td>\n<td style=\"text-align:left\">可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsInDelta</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否以增量输出指标</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>JRaft 配置（底层一致性协议）</strong></td>\n<td style=\"text-align:left\"><code>jRaftGroupId</code></td>\n<td style=\"text-align:left\">jRaft-Controller</td>\n<td style=\"text-align:left\">Raft 组名</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftServerId</code></td>\n<td style=\"text-align:left\">localhost:9880</td>\n<td style=\"text-align:left\">当前节点 ID</td>\n<td style=\"text-align:left\">✅ 修改为实际 IP，例如 <code>10.0.0.1:9880</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftInitConf</code></td>\n<td style=\"text-align:left\">localhost:9880,localhost:9881,localhost:9882</td>\n<td style=\"text-align:left\">集群配置</td>\n<td style=\"text-align:left\">✅ 修改为实际节点 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftControllerRPCAddr</code></td>\n<td style=\"text-align:left\">localhost:9770,localhost:9771,localhost:9772</td>\n<td style=\"text-align:left\">Controller RPC 地址</td>\n<td style=\"text-align:left\">✅ 修改为实际节点 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftElectionTimeoutMs</code></td>\n<td style=\"text-align:left\">1000</td>\n<td style=\"text-align:left\">选举超时（ms）</td>\n<td style=\"text-align:left\">默认即可（过低可能频繁选举）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftScanWaitTimeoutMs</code></td>\n<td style=\"text-align:left\">1000</td>\n<td style=\"text-align:left\">扫描等待超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>jRaftSnapshotIntervalSecs</code></td>\n<td style=\"text-align:left\">3600</td>\n<td style=\"text-align:left\">快照间隔时间（秒）</td>\n<td style=\"text-align:left\">✅ 可设为 600（10分钟）加快日志压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络配置</strong></td>\n<td style=\"text-align:left\"><code>bindAddress</code></td>\n<td style=\"text-align:left\">0.0.0.0</td>\n<td style=\"text-align:left\">绑定监听地址</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>listenPort</code></td>\n<td style=\"text-align:left\">19876</td>\n<td style=\"text-align:left\">Controller 服务端口</td>\n<td style=\"text-align:left\">✅ 确保未冲突</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverWorkerThreads</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">Netty 工作线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverSelectorThreads</code></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Selector 线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>serverSocketBacklog</code></td>\n<td style=\"text-align:left\">1024</td>\n<td style=\"text-align:left\">Socket backlog 队列</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否使用 Epoll</td>\n<td style=\"text-align:left\">✅ Linux 环境建议 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">优雅停机</td>\n<td style=\"text-align:left\">✅ 建议 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>客户端通信</strong></td>\n<td style=\"text-align:left\"><code>clientWorkerThreads</code></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">客户端工作线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>clientAsyncSemaphoreValue</code></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">异步请求信号量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>clientCloseSocketIfTimeout</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">连接超时关闭</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>connectTimeoutMillis</code></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">连接超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useTLS</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 TLS</td>\n<td style=\"text-align:left\">✅ 若生产环境有安全要求，建议启用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>其他</strong></td>\n<td style=\"text-align:left\"><code>configBlackList</code></td>\n<td style=\"text-align:left\">configBlackList;configStorePath</td>\n<td style=\"text-align:left\">配置黑名单项</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxReconnectIntervalTimeSeconds</code></td>\n<td style=\"text-align:left\">60</td>\n<td style=\"text-align:left\">最大重连间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableReconnectForGoAway</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否为 GOAWAY 连接启用重连</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">项目</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>controllerType</code></td>\n<td style=\"text-align:left\">DLedger</td>\n<td style=\"text-align:left\">高可用模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerGroup</code></td>\n<td style=\"text-align:left\">controllerGroup01</td>\n<td style=\"text-align:left\">集群分组名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerPeers</code></td>\n<td style=\"text-align:left\"><code>n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876</code></td>\n<td style=\"text-align:left\">三节点推荐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerDLegerSelfId</code></td>\n<td style=\"text-align:left\">n0 / n1 / n2</td>\n<td style=\"text-align:left\">对应节点 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>enableElectUncleanMaster</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止脏主选举</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>notifyBrokerRoleChanged</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">保持集群一致性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">PROM</td>\n<td style=\"text-align:left\">便于 Prometheus 监控</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">Linux 性能优化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">优雅停机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>controllerStorePath</code></td>\n<td style=\"text-align:left\">/data/rocketmq/controller/store</td>\n<td style=\"text-align:left\">避免使用 <code>/root</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>jRaftSnapshotIntervalSecs</code></td>\n<td style=\"text-align:left\">600</td>\n<td style=\"text-align:left\">提高快照频率</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Controller 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 Controller 配置项 查看全部默认配置项 1234# 查看全部默认配置项sh bin/mqcontroller -p# 查看加载了指定配置文件后的全部配置项sh bin/mqcontroller -p -c conf/broker.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/controller 的启动类 org.apache.rocketmq.controller.ControllerStartup中 可以看到其启动时会初始化如下配置项的类 123456final ControllerConfig controllerConfig = new ControllerConfig();final JraftConfig jraftConfig = new JraftConfig();controllerConfig.setJraftConfig(jraftConfig);final NettyServerConfig nettyServerConfig = new NettyServerConfig();final NettyClientConfig nettyClientConfig = new NettyClientConfig();nettyServerConfig.setListenPort(19876); 配置项说明 Controller 配置参数说明与优化建议 分类 参数名 默认值 说明 优化 / 建议 基础信息 rocketmqHome /usr/local/soft/rocketmq/rocketmq5 RocketMQ 根路径 保持默认即可 configStorePath /root/controller/controller.properties Controller 配置文件路径 ✅ 改为 /data/rocketmq/controller/controller.properties，避免使用 /root controllerType DLedger Controller 类型（DLedger / STANDALONE） ✅ 建议使用 DLedger（高可用） controllerStorePath (空) Controller 元数据存储路径 ✅ 建议 /data/rocketmq/controller/store DLedger 选举配置 controllerDLegerGroup (空) Controller 集群组名 ✅ 必填，例如：controllerGroup01 controllerDLegerPeers (空) 集群节点列表，格式：n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876 ✅ 必填（3 节点推荐） controllerDLegerSelfId (空) 当前节点 ID，如 n0 ✅ 必填 mappedFileSize 1073741824 DLedger 存储文件大小 (1GB) 可保持默认 electMasterMaxRetryCount 3 Master 选举最大重试次数 默认即可 enableElectUncleanMaster false 是否允许选举非同步 Master ✅ 建议保持 false（避免数据丢失） Broker 管理 scanNotActiveBrokerInterval 5000 扫描不活跃 Broker 的间隔(ms) 默认即可 scanInactiveMasterInterval 5000 检测失活 Master 间隔(ms) 默认即可 notifyBrokerRoleChanged true 是否通知 Broker 角色变更 ✅ 建议开启（保持同步） isProcessReadEvent false 是否处理读事件 默认即可 线程与性能 controllerThreadPoolNums 16 控制线程池大小 可调至 8–32 视规模而定 controllerRequestThreadPoolQueueCapacity 50000 控制线程池队列容量 默认即可 Metrics 监控 metricsExporterType DISABLE 指标输出方式（DISABLE / PROM / GRPC / LOG） ✅ 建议设为 PROM metricsPromExporterPort 5557 Prometheus 端口 ✅ 若启用监控，可用默认 5557 metricsPromExporterHost (空) Prometheus 绑定主机 默认即可 metricLoggingExporterIntervalInMills 10000 日志输出指标间隔 可调整 metricsGrpcExporterTarget (空) gRPC 监控目标 可忽略 metricsInDelta false 是否以增量输出指标 默认即可 JRaft 配置（底层一致性协议） jRaftGroupId jRaft-Controller Raft 组名 默认即可 jRaftServerId localhost:9880 当前节点 ID ✅ 修改为实际 IP，例如 10.0.0.1:9880 jRaftInitConf localhost:9880,localhost:9881,localhost:9882 集群配置 ✅ 修改为实际节点 IP jRaftControllerRPCAddr localhost:9770,localhost:9771,localhost:9772 Controller RPC 地址 ✅ 修改为实际节点 IP jRaftElectionTimeoutMs 1000 选举超时（ms） 默认即可（过低可能频繁选举） jRaftScanWaitTimeoutMs 1000 扫描等待超时 默认即可 jRaftSnapshotIntervalSecs 3600 快照间隔时间（秒） ✅ 可设为 600（10分钟）加快日志压缩 网络配置 bindAddress 0.0.0.0 绑定监听地址 默认即可 listenPort 19876 Controller 服务端口 ✅ 确保未冲突 serverWorkerThreads 8 Netty 工作线程 默认即可 serverSelectorThreads 3 Selector 线程数 默认即可 serverSocketBacklog 1024 Socket backlog 队列 默认即可 useEpollNativeSelector false 是否使用 Epoll ✅ Linux 环境建议 true enableShutdownGracefully false 优雅停机 ✅ 建议 true 客户端通信 clientWorkerThreads 4 客户端工作线程 默认即可 clientAsyncSemaphoreValue 65535 异步请求信号量 默认即可 clientCloseSocketIfTimeout true 连接超时关闭 默认即可 connectTimeoutMillis 3000 连接超时 默认即可 useTLS false 是否启用 TLS ✅ 若生产环境有安全要求，建议启用 其他 configBlackList configBlackList;configStorePath 配置黑名单项 默认即可 maxReconnectIntervalTimeSeconds 60 最大重连间隔 默认即可 enableReconnectForGoAway true 是否为 GOAWAY 连接启用重连 默认即可 推荐重点优化的关键项 项目 推荐值 说明 controllerType DLedger 高可用模式 controllerDLegerGroup controllerGroup01 集群分组名 controllerDLegerPeers n0-10.0.0.1:19876;n1-10.0.0.2:19876;n2-10.0.0.3:19876 三节点推荐 controllerDLegerSelfId n0 / n1 / n2 对应节点 ID enableElectUncleanMaster false 防止脏主选举 notifyBrokerRoleChanged true 保持集群一致性 metricsExporterType PROM 便于 Prometheus 监控 metricsPromExporterPort 5557 默认即可 useEpollNativeSelector true Linux 性能优化 enableShutdownGracefully true 优雅停机 controllerStorePath /data/rocketmq/controller/store 避免使用 /root jRaftSnapshotIntervalSecs 600 提高快照频率","summary":"摘要 本文介绍 RocketMQ Controller 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:32:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-04-broker-config/","title":"RocketMQ Broker 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Broker 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-Broker-配置项\">查看 Broker 配置项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看全部默认配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全部默认配置项</span></span><br><span class=\"line\">sh bin/mqbroker -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的全部配置项</span></span><br><span class=\"line\">sh bin/mqbroker -p -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看重要的配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看重要的默认配置项</span></span><br><span class=\"line\">sh bin/mqbroker -m</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的重要配置项</span></span><br><span class=\"line\">sh bin/mqbroker -m -c conf/broker.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/broker</code> 的启动类 <code>org.apache.rocketmq.broker.BrokerStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">BrokerConfig</span> <span class=\"variable\">brokerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BrokerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyServerConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NettyClientConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">MessageStoreConfig</span> <span class=\"variable\">messageStoreConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageStoreConfig</span>();</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">AuthConfig</span> <span class=\"variable\">authConfig</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AuthConfig</span>();</span><br><span class=\"line\">nettyServerConfig.setListenPort(<span class=\"number\">10911</span>);</span><br><span class=\"line\">messageStoreConfig.setHaListenPort(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker的全部配置项非常多，这里仅列出了重要的配置项。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">参数说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础配置</strong></td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">NameServer 地址列表（多个用 <code>;</code> 分隔）</td>\n<td style=\"text-align:left\">✅ <strong>必须设置</strong>，否则 broker 无法注册到 nameserver。例：<code>namesrvAddr=10.250.0.10:9876;10.250.0.11:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>listenPort</code></td>\n<td style=\"text-align:left\">6888</td>\n<td style=\"text-align:left\">Broker 监听客户端连接的端口</td>\n<td style=\"text-align:left\">✅ 建议保持默认或显式设置为 10911（经典端口）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>brokerIP1</code></td>\n<td style=\"text-align:left\">10.250.0.188</td>\n<td style=\"text-align:left\">Broker 对外通信 IP</td>\n<td style=\"text-align:left\">✅ 在多网卡环境务必指定公网/内网 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>recoverConcurrently</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否并发恢复 CommitLog</td>\n<td style=\"text-align:left\">默认即可（高安全性）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Topic &amp; 订阅</strong></td>\n<td style=\"text-align:left\"><code>autoCreateTopicEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否允许自动创建 Topic</td>\n<td style=\"text-align:left\">✅ 生产建议设为 <strong>false</strong>，防止误创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>autoCreateSubscriptionGroup</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否自动创建订阅组</td>\n<td style=\"text-align:left\">✅ 同上，建议 <strong>false</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>msgTraceTopicName</code></td>\n<td style=\"text-align:left\">RMQ_SYS_TRACE_TOPIC</td>\n<td style=\"text-align:left\">消息轨迹主题名</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>traceTopicEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启消息轨迹功能</td>\n<td style=\"text-align:left\">✅ 建议设为 <strong>true</strong> 以便问题排查</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>事务消息</strong></td>\n<td style=\"text-align:left\"><code>rejectTransactionMessage</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否拒绝事务消息</td>\n<td style=\"text-align:left\">若不使用事务可设为 true 减少负担</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionTimeOut</code></td>\n<td style=\"text-align:left\">6000</td>\n<td style=\"text-align:left\">事务超时时间（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionCheckMax</code></td>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">事务最大回查次数</td>\n<td style=\"text-align:left\">可调高（20）提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionCheckInterval</code></td>\n<td style=\"text-align:left\">30000</td>\n<td style=\"text-align:left\">事务回查间隔（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>访问控制</strong></td>\n<td style=\"text-align:left\"><code>aclEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 ACL 权限验证</td>\n<td style=\"text-align:left\">✅ 生产环境 <strong>必须 true</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>存储路径</strong></td>\n<td style=\"text-align:left\"><code>storePathRootDir</code></td>\n<td style=\"text-align:left\">/root/store</td>\n<td style=\"text-align:left\">消息存储根目录</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/store</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathCommitLog</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">CommitLog 存储路径</td>\n<td style=\"text-align:left\">若为空则使用上面的根目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathDLedgerCommitLog</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">DLedger 模式存储路径</td>\n<td style=\"text-align:left\">DLedger 模式才需要</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathEpochFile</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">epoch 文件路径</td>\n<td style=\"text-align:left\">Controller 模式使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storePathBrokerIdentity</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Broker 身份文件路径</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>disappearTimeAfterStart</code></td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">Broker 启动后失效等待时间</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>storeType</code></td>\n<td style=\"text-align:left\">default</td>\n<td style=\"text-align:left\">存储类型（default / dledger）</td>\n<td style=\"text-align:left\">✅ 多副本部署建议 dledger</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>刷盘与写入</strong></td>\n<td style=\"text-align:left\"><code>flushIntervalCommitLog</code></td>\n<td style=\"text-align:left\">500</td>\n<td style=\"text-align:left\">异步 flush 周期（ms）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>commitIntervalCommitLog</code></td>\n<td style=\"text-align:left\">200</td>\n<td style=\"text-align:left\">commit 间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>flushCommitLogTimed</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否定时 flush</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>文件清理</strong></td>\n<td style=\"text-align:left\"><code>deleteWhen</code></td>\n<td style=\"text-align:left\">04</td>\n<td style=\"text-align:left\">删除过期文件时间点</td>\n<td style=\"text-align:left\">每天凌晨 4 点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>fileReservedTime</code></td>\n<td style=\"text-align:left\">72</td>\n<td style=\"text-align:left\">文件保留时间（小时）</td>\n<td style=\"text-align:left\">✅ 可改为 48 减少磁盘压力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>deleteFileBatchMax</code></td>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">删除文件批量数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息访问性能</strong></td>\n<td style=\"text-align:left\"><code>maxTransferBytesOnMessageInMemory</code></td>\n<td style=\"text-align:left\">262144</td>\n<td style=\"text-align:left\">内存消息读取最大字节</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferCountOnMessageInMemory</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">内存消息读取最大条数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferBytesOnMessageInDisk</code></td>\n<td style=\"text-align:left\">65536</td>\n<td style=\"text-align:left\">磁盘消息读取最大字节</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxTransferCountOnMessageInDisk</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">磁盘消息读取最大条数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>accessMessageInMemoryMaxRatio</code></td>\n<td style=\"text-align:left\">40</td>\n<td style=\"text-align:left\">内存访问比例阈值</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>索引管理</strong></td>\n<td style=\"text-align:left\"><code>messageIndexEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用消息索引</td>\n<td style=\"text-align:left\">✅ 建议开启（提高按 key 查询性能）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>messageIndexSafe</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否安全模式索引</td>\n<td style=\"text-align:left\">若磁盘可靠性差可设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>主从复制</strong></td>\n<td style=\"text-align:left\"><code>haMasterAddress</code></td>\n<td style=\"text-align:left\"><em>(空)</em></td>\n<td style=\"text-align:left\">Master 地址（Slave 模式使用）</td>\n<td style=\"text-align:left\">仅从节点配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>brokerRole</code></td>\n<td style=\"text-align:left\">ASYNC_MASTER</td>\n<td style=\"text-align:left\">Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE）</td>\n<td style=\"text-align:left\">✅ 主节点建议 SYNC_MASTER 提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>flushDiskType</code></td>\n<td style=\"text-align:left\">ASYNC_FLUSH</td>\n<td style=\"text-align:left\">刷盘策略（SYNC_FLUSH / ASYNC_FLUSH）</td>\n<td style=\"text-align:left\">✅ 高可靠建议 SYNC_FLUSH</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>cleanFileForciblyEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否强制清理文件</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transientStorePoolEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 transient pool（堆外内存）</td>\n<td style=\"text-align:left\">✅ 可设为 true 提升性能（需足够内存）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>dispatchFromSenderThread</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否由发送线程分发</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>wakeCommitWhenPutMessage</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否在消息写入时唤醒 commit</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>wakeFlushWhenPutMessage</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否写入后立即 flush</td>\n<td style=\"text-align:left\">✅ 对延迟敏感业务可设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消费进度清理</strong></td>\n<td style=\"text-align:left\"><code>enableCleanExpiredOffset</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 offset 清理</td>\n<td style=\"text-align:left\">默认 false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>副本参数</strong></td>\n<td style=\"text-align:left\"><code>totalReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">副本总数</td>\n<td style=\"text-align:left\">✅ 多节点建议设为 3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>inSyncReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">同步副本数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>minInSyncReplicas</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">最小同步副本</td>\n<td style=\"text-align:left\">✅ 建议设为 2 提高可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>allAckInSyncStateSet</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否要求所有 ISR 确认</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableAutoInSyncReplicas</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否自动管理 ISR</td>\n<td style=\"text-align:left\">可保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>HA 与流控</strong></td>\n<td style=\"text-align:left\"><code>haFlowControlEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启主从流控</td>\n<td style=\"text-align:left\">✅ 多副本建议 true</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">注册</td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\">必填</td>\n<td style=\"text-align:left\">Broker 必须向 NameServer 注册</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>aclEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">启用访问控制</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自动创建</td>\n<td style=\"text-align:left\"><code>autoCreateTopicEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止误创建 topic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自动订阅</td>\n<td style=\"text-align:left\"><code>autoCreateSubscriptionGroup</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">防止误消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">刷盘策略</td>\n<td style=\"text-align:left\"><code>flushDiskType</code></td>\n<td style=\"text-align:left\">SYNC_FLUSH</td>\n<td style=\"text-align:left\">保证可靠性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">主从</td>\n<td style=\"text-align:left\"><code>brokerRole</code></td>\n<td style=\"text-align:left\">SYNC_MASTER（主） / SLAVE（从）</td>\n<td style=\"text-align:left\">提升可用性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">存储路径</td>\n<td style=\"text-align:left\"><code>storePathRootDir</code></td>\n<td style=\"text-align:left\"><code>/data/rocketmq/store</code></td>\n<td style=\"text-align:left\">避免 <code>/root</code> 权限问题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">延迟优化</td>\n<td style=\"text-align:left\"><code>transientStorePoolEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">堆外内存加速写入</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理</td>\n<td style=\"text-align:left\"><code>fileReservedTime</code></td>\n<td style=\"text-align:left\">48</td>\n<td style=\"text-align:left\">减少磁盘占用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息轨迹</td>\n<td style=\"text-align:left\"><code>traceTopicEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">便于追踪消息链路</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Broker 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 Broker 配置项 查看全部默认配置项 1234# 查看全部默认配置项sh bin/mqbroker -p# 查看加载了指定配置文件后的全部配置项sh bin/mqbroker -p -c conf/broker.conf 查看重要的配置项 1234# 查看重要的默认配置项sh bin/mqbroker -m# 查看加载了指定配置文件后的重要配置项sh bin/mqbroker -m -c conf/broker.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/broker 的启动类 org.apache.rocketmq.broker.BrokerStartup中 可以看到其启动时会初始化如下配置项的类 1234567final BrokerConfig brokerConfig = new BrokerConfig();final NettyServerConfig nettyServerConfig = new NettyServerConfig();final NettyClientConfig nettyClientConfig = new NettyClientConfig();final MessageStoreConfig messageStoreConfig = new MessageStoreConfig();final AuthConfig authConfig = new AuthConfig();nettyServerConfig.setListenPort(10911);messageStoreConfig.setHaListenPort(0); 配置项说明 Broker的全部配置项非常多，这里仅列出了重要的配置项。 分类 参数名 默认值 参数说明 优化 / 建议 基础配置 namesrvAddr (空) NameServer 地址列表（多个用 ; 分隔） ✅ 必须设置，否则 broker 无法注册到 nameserver。例：namesrvAddr=10.250.0.10:9876;10.250.0.11:9876 listenPort 6888 Broker 监听客户端连接的端口 ✅ 建议保持默认或显式设置为 10911（经典端口） brokerIP1 10.250.0.188 Broker 对外通信 IP ✅ 在多网卡环境务必指定公网/内网 IP recoverConcurrently false 是否并发恢复 CommitLog 默认即可（高安全性） Topic &amp; 订阅 autoCreateTopicEnable true 是否允许自动创建 Topic ✅ 生产建议设为 false，防止误创建 autoCreateSubscriptionGroup true 是否自动创建订阅组 ✅ 同上，建议 false msgTraceTopicName RMQ_SYS_TRACE_TOPIC 消息轨迹主题名 默认即可 traceTopicEnable false 是否开启消息轨迹功能 ✅ 建议设为 true 以便问题排查 事务消息 rejectTransactionMessage false 是否拒绝事务消息 若不使用事务可设为 true 减少负担 transactionTimeOut 6000 事务超时时间（ms） 默认即可 transactionCheckMax 15 事务最大回查次数 可调高（20）提高可靠性 transactionCheckInterval 30000 事务回查间隔（ms） 默认即可 访问控制 aclEnable false 是否启用 ACL 权限验证 ✅ 生产环境 必须 true 存储路径 storePathRootDir /root/store 消息存储根目录 ✅ 改为 /data/rocketmq/store storePathCommitLog (空) CommitLog 存储路径 若为空则使用上面的根目录 storePathDLedgerCommitLog (空) DLedger 模式存储路径 DLedger 模式才需要 storePathEpochFile (空) epoch 文件路径 Controller 模式使用 storePathBrokerIdentity (空) Broker 身份文件路径 默认即可 disappearTimeAfterStart -1 Broker 启动后失效等待时间 默认即可 storeType default 存储类型（default / dledger） ✅ 多副本部署建议 dledger 刷盘与写入 flushIntervalCommitLog 500 异步 flush 周期（ms） 默认即可 commitIntervalCommitLog 200 commit 间隔 默认即可 flushCommitLogTimed true 是否定时 flush 默认即可 文件清理 deleteWhen 04 删除过期文件时间点 每天凌晨 4 点 fileReservedTime 72 文件保留时间（小时） ✅ 可改为 48 减少磁盘压力 deleteFileBatchMax 10 删除文件批量数 默认即可 消息访问性能 maxTransferBytesOnMessageInMemory 262144 内存消息读取最大字节 默认即可 maxTransferCountOnMessageInMemory 32 内存消息读取最大条数 默认即可 maxTransferBytesOnMessageInDisk 65536 磁盘消息读取最大字节 默认即可 maxTransferCountOnMessageInDisk 8 磁盘消息读取最大条数 默认即可 accessMessageInMemoryMaxRatio 40 内存访问比例阈值 默认即可 索引管理 messageIndexEnable true 是否启用消息索引 ✅ 建议开启（提高按 key 查询性能） messageIndexSafe false 是否安全模式索引 若磁盘可靠性差可设为 true 主从复制 haMasterAddress (空) Master 地址（Slave 模式使用） 仅从节点配置 brokerRole ASYNC_MASTER Broker 角色（ASYNC_MASTER / SYNC_MASTER / SLAVE） ✅ 主节点建议 SYNC_MASTER 提高可靠性 flushDiskType ASYNC_FLUSH 刷盘策略（SYNC_FLUSH / ASYNC_FLUSH） ✅ 高可靠建议 SYNC_FLUSH cleanFileForciblyEnable true 是否强制清理文件 默认即可 transientStorePoolEnable false 是否启用 transient pool（堆外内存） ✅ 可设为 true 提升性能（需足够内存） dispatchFromSenderThread false 是否由发送线程分发 默认即可 wakeCommitWhenPutMessage true 是否在消息写入时唤醒 commit 默认即可 wakeFlushWhenPutMessage false 是否写入后立即 flush ✅ 对延迟敏感业务可设为 true 消费进度清理 enableCleanExpiredOffset false 是否启用 offset 清理 默认 false 副本参数 totalReplicas 1 副本总数 ✅ 多节点建议设为 3 inSyncReplicas 1 同步副本数 默认即可 minInSyncReplicas 1 最小同步副本 ✅ 建议设为 2 提高可靠性 allAckInSyncStateSet false 是否要求所有 ISR 确认 默认即可 enableAutoInSyncReplicas false 是否自动管理 ISR 可保持默认 HA 与流控 haFlowControlEnable false 是否开启主从流控 ✅ 多副本建议 true 推荐重点优化的关键项 类别 参数 推荐值 原因 注册 namesrvAddr 必填 Broker 必须向 NameServer 注册 安全 aclEnable true 启用访问控制 自动创建 autoCreateTopicEnable false 防止误创建 topic 自动订阅 autoCreateSubscriptionGroup false 防止误消费 刷盘策略 flushDiskType SYNC_FLUSH 保证可靠性 主从 brokerRole SYNC_MASTER（主） / SLAVE（从） 提升可用性 存储路径 storePathRootDir /data/rocketmq/store 避免 /root 权限问题 延迟优化 transientStorePoolEnable true 堆外内存加速写入 清理 fileReservedTime 48 减少磁盘占用 消息轨迹 traceTopicEnable true 便于追踪消息链路","summary":"摘要 本文介绍 RocketMQ Broker 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:31:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-03-namesvr-config/","title":"RocketMQ NameServer 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ NameServer 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"查看-NameServer-配置项\">查看 NameServer 配置项</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看默认配置项</span></span><br><span class=\"line\">sh bin/mqnamesrv -p</span><br><span class=\"line\"><span class=\"comment\"># 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项</span></span><br><span class=\"line\">sh bin/mqnamesrv -p -c conf/namesvr.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在源码 <code>rocketmq-all-5.3.2-source-release/namesrv</code> 的启动类 <code>org.apache.rocketmq.namesrv.NamesrvStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NamesrvConfig</span> <span class=\"variable\">namesrvConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NettyServerConfig</span> <span class=\"variable\">nettyServerConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">NettyClientConfig</span> <span class=\"variable\">nettyClientConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ControllerConfig</span> <span class=\"variable\">controllerConfig</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NameServer 配置项说明与建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">参数说明</th>\n<th style=\"text-align:left\">优化 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>rocketmqHome</strong></td>\n<td style=\"text-align:left\">/usr/local/soft/rocketmq/rocketmq5</td>\n<td style=\"text-align:left\">RocketMQ 安装目录</td>\n<td style=\"text-align:left\">不建议修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>kvConfigPath</strong></td>\n<td style=\"text-align:left\">/root/namesrv/kvConfig.json</td>\n<td style=\"text-align:left\">KV 配置存储路径</td>\n<td style=\"text-align:left\">✅ 改为 <code>/data/rocketmq/namesrv/kvConfig.json</code> 更规范</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>configStorePath</strong></td>\n<td style=\"text-align:left\">/root/namesrv/namesrv.properties</td>\n<td style=\"text-align:left\">NameServer 启动配置文件路径</td>\n<td style=\"text-align:left\">✅ 放在非 root 路径下 <code>/etc/rocketmq/namesrv.properties</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>productEnvName</strong></td>\n<td style=\"text-align:left\">center</td>\n<td style=\"text-align:left\">产品环境名称标识</td>\n<td style=\"text-align:left\">可用于区分环境（dev/test/prod）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clusterTest</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用集群测试模式</td>\n<td style=\"text-align:left\">默认 false，生产勿启用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>orderMessageEnable</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否开启顺序消息功能</td>\n<td style=\"text-align:left\">NameServer 一般无需开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>returnOrderTopicConfigToBroker</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否返回顺序消息主题配置给 broker</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientRequestThreadPoolNums</strong></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">客户端请求线程数</td>\n<td style=\"text-align:left\">✅ 若 NameServer 负载高可增至 16~32</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>defaultThreadPoolNums</strong></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">默认线程池线程数</td>\n<td style=\"text-align:left\">视 CPU 核心数调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientRequestThreadPoolQueueCapacity</strong></td>\n<td style=\"text-align:left\">50000</td>\n<td style=\"text-align:left\">客户端请求队列长度</td>\n<td style=\"text-align:left\">✅ 高并发环境可调高至 100000</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>defaultThreadPoolQueueCapacity</strong></td>\n<td style=\"text-align:left\">10000</td>\n<td style=\"text-align:left\">默认任务队列长度</td>\n<td style=\"text-align:left\">适度提高防止拒绝任务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>scanNotActiveBrokerInterval</strong></td>\n<td style=\"text-align:left\">5000</td>\n<td style=\"text-align:left\">扫描失效 Broker 的间隔（ms）</td>\n<td style=\"text-align:left\">默认 5s，可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>unRegisterBrokerQueueCapacity</strong></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">Broker 注销队列容量</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>supportActingMaster</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否支持 ActingMaster 功能</td>\n<td style=\"text-align:left\">✅ 若启用 controller 建议设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableAllTopicList</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用所有主题列表接口</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableTopicList</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否允许主题列表查询</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>notifyMinBrokerIdChanged</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否通知最小 brokerId 变化</td>\n<td style=\"text-align:left\">一般无需开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableControllerInNamesrv</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否在 NameServer 中启用 Controller 模块</td>\n<td style=\"text-align:left\">✅ 若部署简化集群可考虑 true（测试环境）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>needWaitForService</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否等待服务就绪再启动</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>waitSecondsForService</strong></td>\n<td style=\"text-align:left\">45</td>\n<td style=\"text-align:left\">启动等待时间</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>deleteTopicWithBrokerRegistration</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">注册时是否删除 topic</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>configBlackList</strong></td>\n<td style=\"text-align:left\">configBlackList;configStorePath;kvConfigPath</td>\n<td style=\"text-align:left\">黑名单配置项</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bindAddress</strong></td>\n<td style=\"text-align:left\">0.0.0.0</td>\n<td style=\"text-align:left\">绑定的监听地址</td>\n<td style=\"text-align:left\">✅ 生产环境建议绑定内网 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>listenPort</strong></td>\n<td style=\"text-align:left\">9876</td>\n<td style=\"text-align:left\">NameServer 监听端口</td>\n<td style=\"text-align:left\">✅ 可通过防火墙限制外部访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverWorkerThreads</strong></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">服务端业务处理线程数</td>\n<td style=\"text-align:left\">可根据负载调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverCallbackExecutorThreads</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">回调执行线程数</td>\n<td style=\"text-align:left\">0 表示自动设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSelectorThreads</strong></td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">Selector 线程数</td>\n<td style=\"text-align:left\">一般 2~4 即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverOnewaySemaphoreValue</strong></td>\n<td style=\"text-align:left\">256</td>\n<td style=\"text-align:left\">单向请求并发限制</td>\n<td style=\"text-align:left\">可保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverAsyncSemaphoreValue</strong></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">异步请求并发限制</td>\n<td style=\"text-align:left\">可保持或略增</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverChannelMaxIdleTimeSeconds</strong></td>\n<td style=\"text-align:left\">120</td>\n<td style=\"text-align:left\">连接空闲关闭时间</td>\n<td style=\"text-align:left\">可调大到 300 提高容错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketSndBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">TCP 发送缓冲区大小</td>\n<td style=\"text-align:left\">0 表示使用系统默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketRcvBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">TCP 接收缓冲区大小</td>\n<td style=\"text-align:left\">建议 131072（128KB）以上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>writeBufferHighWaterMark</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">写缓冲高水位标记</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>writeBufferLowWaterMark</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">写缓冲低水位标记</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverSocketBacklog</strong></td>\n<td style=\"text-align:left\">1024</td>\n<td style=\"text-align:left\">TCP 连接等待队列</td>\n<td style=\"text-align:left\">✅ 高并发场景可调大至 2048</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverNettyWorkerGroupEnable</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 Netty worker 线程组</td>\n<td style=\"text-align:left\">默认 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>serverPooledByteBufAllocatorEnable</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 Netty 池化内存</td>\n<td style=\"text-align:left\">建议保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableShutdownGracefully</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否优雅关闭</td>\n<td style=\"text-align:left\">✅ 建议设为 true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>shutdownWaitTimeSeconds</strong></td>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\">优雅关闭等待时间</td>\n<td style=\"text-align:left\">建议 30~60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>useEpollNativeSelector</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 Linux Epoll</td>\n<td style=\"text-align:left\">✅ Linux 环境建议设为 true 提高性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientWorkerThreads</strong></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">客户端 worker 线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientCallbackExecutorThreads</strong></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">客户端回调线程数</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientOnewaySemaphoreValue</strong></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">客户端单向请求并发限制</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientAsyncSemaphoreValue</strong></td>\n<td style=\"text-align:left\">65535</td>\n<td style=\"text-align:left\">客户端异步请求并发限制</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>connectTimeoutMillis</strong></td>\n<td style=\"text-align:left\">3000</td>\n<td style=\"text-align:left\">连接超时（ms）</td>\n<td style=\"text-align:left\">✅ 可提高至 5000 增加容错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>channelNotActiveInterval</strong></td>\n<td style=\"text-align:left\">60000</td>\n<td style=\"text-align:left\">检查通道非活动间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>isScanAvailableNameSrv</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否扫描可用 NameServer</td>\n<td style=\"text-align:left\">保持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientChannelMaxIdleTimeSeconds</strong></td>\n<td style=\"text-align:left\">120</td>\n<td style=\"text-align:left\">客户端空闲连接超时</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientSocketSndBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">客户端 TCP 发送缓冲区</td>\n<td style=\"text-align:left\">建议 131072</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientSocketRcvBufSize</strong></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">客户端 TCP 接收缓冲区</td>\n<td style=\"text-align:left\">建议 131072</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientPooledByteBufAllocatorEnable</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">客户端是否启用池化</td>\n<td style=\"text-align:left\">✅ 建议设为 true 提高性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>clientCloseSocketIfTimeout</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">超时是否关闭 socket</td>\n<td style=\"text-align:left\">保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>useTLS</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否启用 TLS 通信</td>\n<td style=\"text-align:left\">✅ 若公网部署强烈建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>socksProxyConfig</strong></td>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">SOCKS 代理配置</td>\n<td style=\"text-align:left\">内网部署无需设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>disableCallbackExecutor</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否禁用回调执行器</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>disableNettyWorkerGroup</strong></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否禁用 Netty worker group</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>maxReconnectIntervalTimeSeconds</strong></td>\n<td style=\"text-align:left\">60</td>\n<td style=\"text-align:left\">最大重连间隔</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>enableReconnectForGoAway</strong></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">是否启用 goaway 自动重连</td>\n<td style=\"text-align:left\">保持 true 增强健壮性</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐重点优化的关键项</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">推荐值</th>\n<th style=\"text-align:left\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td style=\"text-align:left\"><code>useEpollNativeSelector</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">Linux 性能显著提升</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>bindAddress</code></td>\n<td style=\"text-align:left\">内网 IP</td>\n<td style=\"text-align:left\">防止暴露公网</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全</td>\n<td style=\"text-align:left\"><code>useTLS</code></td>\n<td style=\"text-align:left\">true（公网）</td>\n<td style=\"text-align:left\">启用加密传输</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">健壮性</td>\n<td style=\"text-align:left\"><code>enableShutdownGracefully</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">防止强制关闭导致状态不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">负载</td>\n<td style=\"text-align:left\"><code>clientRequestThreadPoolNums</code></td>\n<td style=\"text-align:left\">16~32</td>\n<td style=\"text-align:left\">提高并发能力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">网络</td>\n<td style=\"text-align:left\"><code>serverSocketBacklog</code></td>\n<td style=\"text-align:left\">2048</td>\n<td style=\"text-align:left\">减少连接拒绝</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">缓冲</td>\n<td style=\"text-align:left\"><code>serverSocketSndBufSize</code> / <code>RcvBufSize</code></td>\n<td style=\"text-align:left\">131072</td>\n<td style=\"text-align:left\">提高网络吞吐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件路径</td>\n<td style=\"text-align:left\"><code>kvConfigPath</code> / <code>configStorePath</code></td>\n<td style=\"text-align:left\">非 root 路径</td>\n<td style=\"text-align:left\">避免权限问题</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ NameServer 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 查看 NameServer 配置项 1234# 查看默认配置项sh bin/mqnamesrv -p# 查看加载了指定配置文件后的配置项，即配置文件中的配置项会覆盖默认配置项sh bin/mqnamesrv -p -c conf/namesvr.conf 配置项项目源码简介 在源码 rocketmq-all-5.3.2-source-release/namesrv 的启动类 org.apache.rocketmq.namesrv.NamesrvStartup中 可以看到其启动时会初始化如下配置项的类 1234private static NamesrvConfig namesrvConfig = null;private static NettyServerConfig nettyServerConfig = null;private static NettyClientConfig nettyClientConfig = null;private static ControllerConfig controllerConfig = null; 配置项说明 NameServer 配置项说明与建议 参数名 默认值 参数说明 优化 / 建议 rocketmqHome /usr/local/soft/rocketmq/rocketmq5 RocketMQ 安装目录 不建议修改 kvConfigPath /root/namesrv/kvConfig.json KV 配置存储路径 ✅ 改为 /data/rocketmq/namesrv/kvConfig.json 更规范 configStorePath /root/namesrv/namesrv.properties NameServer 启动配置文件路径 ✅ 放在非 root 路径下 /etc/rocketmq/namesrv.properties productEnvName center 产品环境名称标识 可用于区分环境（dev/test/prod） clusterTest false 是否启用集群测试模式 默认 false，生产勿启用 orderMessageEnable false 是否开启顺序消息功能 NameServer 一般无需开启 returnOrderTopicConfigToBroker true 是否返回顺序消息主题配置给 broker 保持默认 clientRequestThreadPoolNums 8 客户端请求线程数 ✅ 若 NameServer 负载高可增至 16~32 defaultThreadPoolNums 16 默认线程池线程数 视 CPU 核心数调整 clientRequestThreadPoolQueueCapacity 50000 客户端请求队列长度 ✅ 高并发环境可调高至 100000 defaultThreadPoolQueueCapacity 10000 默认任务队列长度 适度提高防止拒绝任务 scanNotActiveBrokerInterval 5000 扫描失效 Broker 的间隔（ms） 默认 5s，可保持 unRegisterBrokerQueueCapacity 3000 Broker 注销队列容量 默认即可 supportActingMaster false 是否支持 ActingMaster 功能 ✅ 若启用 controller 建议设为 true enableAllTopicList true 是否启用所有主题列表接口 可保持 enableTopicList true 是否允许主题列表查询 可保持 notifyMinBrokerIdChanged false 是否通知最小 brokerId 变化 一般无需开启 enableControllerInNamesrv false 是否在 NameServer 中启用 Controller 模块 ✅ 若部署简化集群可考虑 true（测试环境） needWaitForService false 是否等待服务就绪再启动 可保持 waitSecondsForService 45 启动等待时间 可保持 deleteTopicWithBrokerRegistration false 注册时是否删除 topic 默认即可 configBlackList configBlackList;configStorePath;kvConfigPath 黑名单配置项 保持默认 bindAddress 0.0.0.0 绑定的监听地址 ✅ 生产环境建议绑定内网 IP listenPort 9876 NameServer 监听端口 ✅ 可通过防火墙限制外部访问 serverWorkerThreads 8 服务端业务处理线程数 可根据负载调整 serverCallbackExecutorThreads 0 回调执行线程数 0 表示自动设置 serverSelectorThreads 3 Selector 线程数 一般 2~4 即可 serverOnewaySemaphoreValue 256 单向请求并发限制 可保持 serverAsyncSemaphoreValue 64 异步请求并发限制 可保持或略增 serverChannelMaxIdleTimeSeconds 120 连接空闲关闭时间 可调大到 300 提高容错 serverSocketSndBufSize 0 TCP 发送缓冲区大小 0 表示使用系统默认 serverSocketRcvBufSize 0 TCP 接收缓冲区大小 建议 131072（128KB）以上 writeBufferHighWaterMark 0 写缓冲高水位标记 默认即可 writeBufferLowWaterMark 0 写缓冲低水位标记 默认即可 serverSocketBacklog 1024 TCP 连接等待队列 ✅ 高并发场景可调大至 2048 serverNettyWorkerGroupEnable true 是否启用 Netty worker 线程组 默认 true serverPooledByteBufAllocatorEnable true 是否启用 Netty 池化内存 建议保持 enableShutdownGracefully false 是否优雅关闭 ✅ 建议设为 true shutdownWaitTimeSeconds 30 优雅关闭等待时间 建议 30~60 useEpollNativeSelector false 是否启用 Linux Epoll ✅ Linux 环境建议设为 true 提高性能 clientWorkerThreads 4 客户端 worker 线程数 默认即可 clientCallbackExecutorThreads 2 客户端回调线程数 默认即可 clientOnewaySemaphoreValue 65535 客户端单向请求并发限制 默认即可 clientAsyncSemaphoreValue 65535 客户端异步请求并发限制 默认即可 connectTimeoutMillis 3000 连接超时（ms） ✅ 可提高至 5000 增加容错 channelNotActiveInterval 60000 检查通道非活动间隔 默认即可 isScanAvailableNameSrv true 是否扫描可用 NameServer 保持 clientChannelMaxIdleTimeSeconds 120 客户端空闲连接超时 默认即可 clientSocketSndBufSize 0 客户端 TCP 发送缓冲区 建议 131072 clientSocketRcvBufSize 0 客户端 TCP 接收缓冲区 建议 131072 clientPooledByteBufAllocatorEnable false 客户端是否启用池化 ✅ 建议设为 true 提高性能 clientCloseSocketIfTimeout true 超时是否关闭 socket 保持默认 useTLS false 是否启用 TLS 通信 ✅ 若公网部署强烈建议开启 socksProxyConfig {} SOCKS 代理配置 内网部署无需设置 disableCallbackExecutor false 是否禁用回调执行器 默认即可 disableNettyWorkerGroup false 是否禁用 Netty worker group 默认即可 maxReconnectIntervalTimeSeconds 60 最大重连间隔 默认即可 enableReconnectForGoAway true 是否启用 goaway 自动重连 保持 true 增强健壮性 推荐重点优化的关键项 类别 参数 推荐值 原因 性能 useEpollNativeSelector true Linux 性能显著提升 安全 bindAddress 内网 IP 防止暴露公网 安全 useTLS true（公网） 启用加密传输 健壮性 enableShutdownGracefully true 防止强制关闭导致状态不一致 负载 clientRequestThreadPoolNums 16~32 提高并发能力 网络 serverSocketBacklog 2048 减少连接拒绝 缓冲 serverSocketSndBufSize / RcvBufSize 131072 提高网络吞吐 文件路径 kvConfigPath / configStorePath 非 root 路径 避免权限问题","summary":"摘要 本文介绍 RocketMQ NameServer 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/","url":"https://blog.hanqunfeng.com/2025/10/24/rocketmq-02-dashboard/","title":"RocketMQ Dashboard 的安装及使用","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RocketMQ-Dashboard-简介\">RocketMQ Dashboard 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>功能概览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>面板</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>运维</strong></td>\n<td>修改 <strong>NameServer 地址</strong>；选择 <strong>VIPChannel</strong> 等运维配置。</td>\n</tr>\n<tr>\n<td><strong>驾驶舱</strong></td>\n<td>查看 <strong>Broker、Topic 消息量</strong> 等运行总览信息。</td>\n</tr>\n<tr>\n<td><strong>集群</strong></td>\n<td>查看 <strong>集群分布</strong>、Broker 配置、运行状态及详细信息。</td>\n</tr>\n<tr>\n<td><strong>主题（Topic）</strong></td>\n<td>搜索、筛选、删除、更新/新增主题；查看 <strong>消息路由</strong>；执行 <strong>发送消息</strong>、<strong>重置消费位点</strong> 等操作。</td>\n</tr>\n<tr>\n<td><strong>消费者（Consumer）</strong></td>\n<td>搜索、删除、新增/更新消费者组；查看 <strong>终端信息、消费详情、配置项</strong>。</td>\n</tr>\n<tr>\n<td><strong>消息（Message）</strong></td>\n<td>查看 <strong>消息记录、死信消息、消息轨迹</strong> 等消息级详情。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>系统要求 与 网络配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>系统要求</strong></td>\n<td>操作系统</td>\n<td>Linux / Unix / macOS</td>\n</tr>\n<tr>\n<td></td>\n<td>JDK</td>\n<td>64 位 JDK, 1.x 版本需要<strong>1.8+</strong>，2.x版本需要 <strong>17+</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>构建工具</td>\n<td><strong>Maven 3.2.x</strong> 或更高版本</td>\n</tr>\n<tr>\n<td></td>\n<td>启动项</td>\n<td>启动 <strong>RocketMQ</strong>（包括 NameServer 与 Broker）</td>\n</tr>\n<tr>\n<td><strong>网络配置</strong></td>\n<td>网络访问</td>\n<td>云服务器需可远程访问，或本地虚拟机需可 <strong>PING 通外网</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RocketMQ-Dashboard-的安装\">RocketMQ Dashboard 的安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>部署 RocketMQ Dashboard 2.x，需要安装 JDK17</p>\n</li>\n<li class=\"lvl-2\">\n<p>源码安装，<a href=\"https://github.com/apache/rocketmq-dashboard\">源码下载</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载源码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq</span><br><span class=\"line\">wget https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-2.1.0.tar.gz</span><br><span class=\"line\">tar -zxvf rocketmq-dashboard-2.1.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s rocketmq-dashboard-rocketmq-dashboard-2.1.0 rocketmq-dashboard</span><br><span class=\"line\"><span class=\"built_in\">cd</span> rocketmq-dashboard</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>bug 修复，当前<code>2.1.0</code>版本存在bug，只能通过<code>http://localhost:8082</code>访问，如果需要ip或域名访问，则需要修改源码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> frontend-new/src/api/remoteApi</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s|apiBaseUrl: &#x27;</span>\\&#x27;<span class=\"string\">&#x27;http://localhost:8082&#x27;</span>\\&#x27;<span class=\"string\">&#x27;|apiBaseUrl: process.env.REACT_APP_API_BASE_URL \\|\\| window.location.origin|&#x27;</span> remoteApi.js.bck</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 替换前：</span></span><br><span class=\"line\">const appConfig = &#123;</span><br><span class=\"line\">    apiBaseUrl: <span class=\"string\">&#x27;http://localhost:8082&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\"># 替换后：</span></span><br><span class=\"line\">const appConfig = &#123;</span><br><span class=\"line\">    apiBaseUrl: process.env.REACT_APP_API_BASE_URL || window.location.origin</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>环境</th>\n<th>环境变量值</th>\n<th>结果 (<code>appConfig.apiBaseUrl</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发环境</td>\n<td><code>REACT_APP_API_BASE_URL=http://localhost:8080</code></td>\n<td><code>http://localhost:8080</code></td>\n</tr>\n<tr>\n<td>测试环境</td>\n<td><code>REACT_APP_API_BASE_URL=https://api.test.example.com</code></td>\n<td><code>https://api.test.example.com</code></td>\n</tr>\n<tr>\n<td>未设置变量</td>\n<td><em>(无该环境变量)</em> 则使用默认的 <code>window.location.origin</code>，其表示 当前网页的 协议 + 域名 + 端口号</td>\n<td>自动使用当前网站地址，如 <code>https://myapp.example.com</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>目前<code>2.1.0</code>版本的bug还比较多，GitHub仓库中的代码已经修复了包括该bug在内的部分bug，不过还没有发布到 release。<br>\n着急的小伙伴可以通过 <code>git clone</code> 项目，编译并运行，或者等待作者发布新版本。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/apache/rocketmq-dashboard.git</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq/rocketmq-dashboard</span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/jdk/jdk17 mvn clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 将jar包复制到run目录下，以避免重新编译时被覆盖</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> run</span><br><span class=\"line\"><span class=\"built_in\">cp</span> target/rocketmq-dashboard-2.1.0.jar run/</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按需替换配置，</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\"><span class=\"comment\">#    accessKey: mqadmin</span></span><br><span class=\"line\"><span class=\"comment\">#    secretKey: 1234567</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>users.properties</code> 文件格式如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class=\"line\"><span class=\"comment\"># 格式， 每行定义一个用户， username=password[,N]  #N是可选项，可以为0 (普通用户)； 1 （管理员）</span></span><br><span class=\"line\"><span class=\"comment\"># 定义管理员，管理员拥有全部权限</span></span><br><span class=\"line\">super=passwd,1</span><br><span class=\"line\"><span class=\"comment\"># 定义普通用户，普通用户的权限需要在 dataPath 下的 role-permission.yml 文件中定义，如果该目录下不存在此文件，则默认使用resources/role-permission.yml文件</span></span><br><span class=\"line\">user1=passwd</span><br><span class=\"line\">user2=passwd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>role-permission.yml</code> 文件格式如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该文件支持热修改，即添加和修改用户时，不需要重新启动console</span></span><br><span class=\"line\"><span class=\"comment\"># 格式，如果增加和删除接口权限，直接在列表中增加和删除接口地址即可。</span></span><br><span class=\"line\"><span class=\"comment\"># 接口路径配置支持通配符</span></span><br><span class=\"line\"><span class=\"comment\"># * 表示匹配0或多个不是/的字符</span></span><br><span class=\"line\"><span class=\"comment\"># ** 表示匹配0或多个任意字符</span></span><br><span class=\"line\"><span class=\"comment\"># ? 表示匹配1个任意字符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rolePerms:</span></span><br><span class=\"line\">  <span class=\"comment\"># 普通用户，以下权限为默认权限，基本上就只是查询的权限</span></span><br><span class=\"line\">  <span class=\"attr\">Normal:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/rocketmq/nsaddr</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/ops/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/dashboard/**</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/topic/*.query</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/topic/sendTopicMessage.do</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/producer/*.query</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/message/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/messageTrace/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/monitor/*</span></span><br><span class=\"line\">    <span class=\"string\">....</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> run</span><br><span class=\"line\"><span class=\"comment\"># 启动，默认会加载与jar包同级目录下的application.yaml文件</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> /usr/local/jdk/jdk17/bin/java -jar rocketmq-dashboard-2.1.0.jar 1&gt;dashboard.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\"><span class=\"built_in\">tail</span> -f dashboard.log</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/9F26eh.png\" alt=\"\" width=\"1400\" height=\"800\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/rocketmq-dashboard/blob/master/docs/1_0_0/UserGuide_CN.md\">Dashboard 使用手册</a></p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ Dashboard 简介 官方文档 RocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。 功能概览 面板 功能说明 运维 修改 NameServer 地址；选择 VIPChannel 等运维配置。 驾驶舱 查看 Broker、Topic 消息量 等运行总览信息。 集群 查看 集群分布、Broker 配置、运行状态及详细信息。 主题（Topic） 搜索、筛选、删除、更新/新增主题；查看 消息路由；执行 发送消息、重置消费位点 等操作。 消费者（Consumer） 搜索、删除、新增/更新消费者组；查看 终端信息、消费详情、配置项。 消息（Message） 查看 消息记录、死信消息、消息轨迹 等消息级详情。 系统要求 与 网络配置 类别 项目 说明 系统要求 操作系统 Linux / Unix / macOS JDK 64 位 JDK, 1.x 版本需要1.8+，2.x版本需要 17+ 构建工具 Maven 3.2.x 或更高版本 启动项 启动 RocketMQ（包括 NameServer 与 Broker） 网络配置 网络访问 云服务器需可远程访问，或本地虚拟机需可 PING 通外网 RocketMQ Dashboard 的安装 部署 RocketMQ Dashboard 2.x，需要安装 JDK17 源码安装，源码下载 123456# 下载源码cd /usr/local/soft/rocketmqwget https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-2.1.0.tar.gztar -zxvf rocketmq-dashboard-2.1.0.tar.gzln -s rocketmq-dashboard-rocketmq-dashboard-2.1.0 rocketmq-dashboardcd rocketmq-dashboard bug 修复，当前2.1.0版本存在bug，只能通过http://localhost:8082访问，如果需要ip或域名访问，则需要修改源码 1234567891011cd frontend-new/src/api/remoteApised -i &#x27;s|apiBaseUrl: &#x27;\\&#x27;&#x27;http://localhost:8082&#x27;\\&#x27;&#x27;|apiBaseUrl: process.env.REACT_APP_API_BASE_URL \\|\\| window.location.origin|&#x27; remoteApi.js.bck# 替换前：const appConfig = &#123; apiBaseUrl: &#x27;http://localhost:8082&#x27;&#125;;# 替换后：const appConfig = &#123; apiBaseUrl: process.env.REACT_APP_API_BASE_URL || window.location.origin&#125;; 环境 环境变量值 结果 (appConfig.apiBaseUrl) 开发环境 REACT_APP_API_BASE_URL=http://localhost:8080 http://localhost:8080 测试环境 REACT_APP_API_BASE_URL=https://api.test.example.com https://api.test.example.com 未设置变量 (无该环境变量) 则使用默认的 window.location.origin，其表示 当前网页的 协议 + 域名 + 端口号 自动使用当前网站地址，如 https://myapp.example.com 目前2.1.0版本的bug还比较多，GitHub仓库中的代码已经修复了包括该bug在内的部分bug，不过还没有发布到 release。 着急的小伙伴可以通过 git clone 项目，编译并运行，或者等待作者发布新版本。 1git clone https://github.com/apache/rocketmq-dashboard.git 编译 123456cd /usr/local/soft/rocketmq/rocketmq-dashboard# 编译JAVA_HOME=/usr/local/jdk/jdk17 mvn clean package -Dmaven.test.skip=true# 将jar包复制到run目录下，以避免重新编译时被覆盖mkdir runcp target/rocketmq-dashboard-2.1.0.jar run/ 按需替换配置， 12345678910111213# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey# accessKey: mqadmin# secretKey: 1234567 users.properties 文件格式如下： 1234567# 该文件支持热修改，即添加和修改用户时，不需要重新启动console# 格式， 每行定义一个用户， username=password[,N] #N是可选项，可以为0 (普通用户)； 1 （管理员）# 定义管理员，管理员拥有全部权限super=passwd,1# 定义普通用户，普通用户的权限需要在 dataPath 下的 role-permission.yml 文件中定义，如果该目录下不存在此文件，则默认使用resources/role-permission.yml文件user1=passwduser2=passwd role-permission.yml 文件格式如下： 1234567891011121314151617181920# 该文件支持热修改，即添加和修改用户时，不需要重新启动console# 格式，如果增加和删除接口权限，直接在列表中增加和删除接口地址即可。# 接口路径配置支持通配符# * 表示匹配0或多个不是/的字符# ** 表示匹配0或多个任意字符# ? 表示匹配1个任意字符rolePerms: # 普通用户，以下权限为默认权限，基本上就只是查询的权限 Normal: - /rocketmq/nsaddr - /ops/* - /dashboard/** - /topic/*.query - /topic/sendTopicMessage.do - /producer/*.query - /message/* - /messageTrace/* - /monitor/* .... 启动 123456cd run# 启动，默认会加载与jar包同级目录下的application.yaml文件nohup /usr/local/jdk/jdk17/bin/java -jar rocketmq-dashboard-2.1.0.jar 1&gt;dashboard.log 2&gt;&amp;1 &amp;# 查看日志tail -f dashboard.log Dashboard 使用手册","summary":"摘要 本文介绍 CentOS9 中 RocketMQ Dashboard 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-24T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/","url":"https://blog.hanqunfeng.com/2025/10/23/rocketmq-01-install/","title":"RocketMQ 的安装及使用","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 RocketMQ 的安装与使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Apache-RocketMQ-简介\">Apache RocketMQ 简介</h2>\n<h3 id=\"一、RocketMQ-是什么？\">一、RocketMQ 是什么？</h3>\n<p>RocketMQ 是一个<strong>分布式、队列模型的消息中间件</strong>。它由阿里巴巴在2012年开源，并于2017年正式成为 Apache 基金会的顶级项目。</p>\n<p>你可以把它想象成一个在分布式系统中负责可靠传递消息的“邮局”或“快递系统”。当系统A需要发送数据给系统B，但它们之间不直接通信时，就可以通过 RocketMQ 来中转，确保消息不丢失、不重复，并且能按顺序送达。</p>\n<p><strong>RocketMQ 是一个高性能、高可靠、高实时的分布式消息中间件</strong>。它就像分布式系统的“中枢神经系统”，负责在各个服务之间可靠、高效地传递数据，是现代互联网架构中不可或缺的基础组件之一。</p>\n<p><strong>RocketMQ 5.x 通过引入 Proxy 模式，极大地提升了架构的灵活性、多语言支持能力和云原生亲和力</strong>，是其在消息中间件领域持续演进的重要里程碑。</p>\n<p>它与 Kafka、RabbitMQ 等都是业界顶级的消息队列，但各有侧重。RocketMQ 在事务消息、顺序消息和对在线业务的稳定性支持方面表现尤为出色。</p>\n<hr>\n<h3 id=\"二、核心特点与优势\">二、核心特点与优势</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">典型场景</th>\n<th style=\"text-align:left\">主要作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>1</strong></td>\n<td style=\"text-align:left\"><strong>削峰填谷</strong></td>\n<td style=\"text-align:left\">电商秒杀、大促活动时大量下单请求瞬间涌入</td>\n<td style=\"text-align:left\">将突发请求先缓存为消息，后端系统按自身能力平稳消费，避免系统过载崩溃</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>2</strong></td>\n<td style=\"text-align:left\"><strong>异步解耦</strong></td>\n<td style=\"text-align:left\">用户注册后触发多系统任务（邮件、优惠券、积分）</td>\n<td style=\"text-align:left\">主流程只负责发送消息，其他系统独立异步处理，降低系统间耦合、提高扩展性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>3</strong></td>\n<td style=\"text-align:left\"><strong>顺序消息</strong></td>\n<td style=\"text-align:left\">订单状态变更（创建 → 付款 → 发货 → 收货）</td>\n<td style=\"text-align:left\">同一业务键（如订单ID）的消息按顺序发送和消费，保证业务逻辑正确性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>4</strong></td>\n<td style=\"text-align:left\"><strong>持久化与高可靠性</strong></td>\n<td style=\"text-align:left\">关键业务消息必须不丢失（交易、支付、日志）</td>\n<td style=\"text-align:left\">所有消息写入磁盘并支持主从复制，即使服务器重启也能恢复，保证高可用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>5</strong></td>\n<td style=\"text-align:left\"><strong>消息回溯</strong></td>\n<td style=\"text-align:left\">消费逻辑出错、数据重算、补偿任务</td>\n<td style=\"text-align:left\">支持重置消费位点，重新消费历史消息，实现业务补偿与追溯</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>6</strong></td>\n<td style=\"text-align:left\"><strong>海量消息堆积能力</strong></td>\n<td style=\"text-align:left\">大规模异步日志收集、IoT 数据汇聚、埋点分析</td>\n<td style=\"text-align:left\">支持万亿级消息堆积，性能稳定不衰减，适用于大规模数据场景</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"三、核心架构与概念\">三、核心架构与概念</h3>\n<p>要理解 RocketMQ，需要知道几个关键角色：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/frTwo1.png\" alt=\"\"></p>\n<h4 id=\"经典核心组件\">经典核心组件</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:left\">组件名称</th>\n<th style=\"text-align:left\">主要作用</th>\n<th style=\"text-align:left\">说明 / 特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>1</strong></td>\n<td style=\"text-align:left\"><strong>Producer（生产者）</strong></td>\n<td style=\"text-align:left\">发送消息的客户端</td>\n<td style=\"text-align:left\">负责将业务系统的消息发送到指定的 <strong>Topic</strong>，支持同步、异步、单向三种发送方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>2</strong></td>\n<td style=\"text-align:left\"><strong>Consumer（消费者）</strong></td>\n<td style=\"text-align:left\">接收并消费消息的客户端</td>\n<td style=\"text-align:left\">从 Broker 拉取消息并进行业务处理，可分为 <strong>Push</strong> 和 <strong>Pull</strong> 两种消费模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>3</strong></td>\n<td style=\"text-align:left\"><strong>Consumer Group（消费者组）</strong></td>\n<td style=\"text-align:left\">实现负载均衡与高可用消费</td>\n<td style=\"text-align:left\">多个消费者订阅同一 Topic 时组成消费者组，一个分区只会被组内一个消费者消费</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>4</strong></td>\n<td style=\"text-align:left\"><strong>Broker（消息服务器）</strong></td>\n<td style=\"text-align:left\">存储和转发消息</td>\n<td style=\"text-align:left\">RocketMQ 的核心组件，负责消息的持久化、转发、主从复制和高可用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>5</strong></td>\n<td style=\"text-align:left\"><strong>Topic（主题）</strong></td>\n<td style=\"text-align:left\">消息的分类与路由单元</td>\n<td style=\"text-align:left\">Producer 发送消息到指定 Topic，Consumer 订阅 Topic 消费消息；一个 Topic 可包含多个消息队列（分区）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>6</strong></td>\n<td style=\"text-align:left\"><strong>Name Server（名字服务）</strong></td>\n<td style=\"text-align:left\">管理 Broker 地址信息</td>\n<td style=\"text-align:left\">类似轻量级注册中心，维护 Broker 元数据，帮助 Producer 和 Consumer 定位消息存储位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>7</strong></td>\n<td style=\"text-align:left\"><strong>Controller（控制器）</strong></td>\n<td style=\"text-align:left\">主从自动切换与高可用控制</td>\n<td style=\"text-align:left\">RocketMQ 5.x 引入，基于 Raft（DLedger）协议实现 Broker 自动选主和元数据管理</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>8</strong></td>\n<td style=\"text-align:left\"><strong>Proxy（代理层）</strong></td>\n<td style=\"text-align:left\">客户端访问入口与协议转换</td>\n<td style=\"text-align:left\">RocketMQ 5.x 新组件，无状态，可横向扩展；统一接入层，支持多协议（如 HTTP、gRPC），隔离客户端与 Broker</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>引入 Proxy 模式的优势：</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**架构解耦与语言无关**：Proxy 作为通用代理，将复杂的 Broker 协议封装成更简单的接口（如 gRPC），使得用不同编程语言（如 Go, Python, C++ 等）开发的客户端更容易接入，而无需实现复杂的原生协议。</span><br><span class=\"line\">**简化客户端**：客户端不再需要感知 Name Server 和 Broker 的地址变化，只需连接固定的 Proxy 地址即可，大大降低了客户端的复杂度。</span><br><span class=\"line\">**增强安全性**：可以在 Proxy 层统一实现安全认证、限流、审计等策略，作为Broker集群的安全屏障。</span><br><span class=\"line\">**云原生友好**：无状态的 Proxy 非常适合在 Kubernetes 等容器化环境中进行部署和弹性伸缩。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"消息中间件功能对比表（ActiveMQ-vs-Kafka-vs-RabbitMQ-vs-RocketMQ）\">消息中间件功能对比表（ActiveMQ vs Kafka vs RabbitMQ vs RocketMQ）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://support.huaweicloud.com/intl/zh-cn/productdesc-hrm/hrm_pd_012.html\">参考资料</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能项</th>\n<th style=\"text-align:left\">ActiveMQ</th>\n<th style=\"text-align:left\">Kafka</th>\n<th style=\"text-align:left\">RabbitMQ</th>\n<th style=\"text-align:left\">RocketMQ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">客户端 SDK</td>\n<td style=\"text-align:left\">Java、.NET、C++ 等</td>\n<td style=\"text-align:left\">Java、Scala 等</td>\n<td style=\"text-align:left\">Java、.NET、Go、Python、C 等</td>\n<td style=\"text-align:left\">Java、C++、Go</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通信协议与规范</td>\n<td style=\"text-align:left\">推送模型（Push），支持 OpenWire、STOMP、AMQP、MQTT、JMS</td>\n<td style=\"text-align:left\">拉取模型（Pull），支持 TCP</td>\n<td style=\"text-align:left\">推送模型（Push），支持 AMQP、MQTT、STOMP、HTTP、WebSocket</td>\n<td style=\"text-align:left\">拉取模型（Pull），支持 TCP、JMS、OpenMessaging</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息有序性</td>\n<td style=\"text-align:left\">通过独占消费者（Exclusive Consumer）或独占队列（Exclusive Queues）保证顺序</td>\n<td style=\"text-align:left\">保证分区内消息顺序</td>\n<td style=\"text-align:left\">单队列内消息天然有序</td>\n<td style=\"text-align:left\">严格顺序消息，可平滑扩展</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">定时/延迟消息</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（使用延迟插件）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">批量消息</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（异步生产者）</td>\n<td style=\"text-align:left\">支持（Publisher Confirms 模式下）</td>\n<td style=\"text-align:left\">支持（同步模式可避免消息丢失）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">广播消息</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（Fanout 交换机）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息过滤</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（可用 Kafka Streams 实现）</td>\n<td style=\"text-align:left\">支持（基于 Exchange 的路由键或 Header）</td>\n<td style=\"text-align:left\">支持（基于 SQL92 属性过滤）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">服务器端触发重投递</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（Nack 或 TTL+DLX）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息存储</td>\n<td style=\"text-align:left\">支持高性能持久化（JDBC + LevelDB/KahaDB）</td>\n<td style=\"text-align:left\">高性能文件存储</td>\n<td style=\"text-align:left\">内存+磁盘混合存储（Mnesia/基于 Erlang 的日志）</td>\n<td style=\"text-align:left\">高性能、低延迟文件存储</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息回溯（历史消息查询）</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（通过 offset）</td>\n<td style=\"text-align:left\">不支持（消息被消费后无法回溯）</td>\n<td style=\"text-align:left\">支持（时间戳与 offset）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息优先级</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持（优先级队列）</td>\n<td style=\"text-align:left\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">高可用与故障转移</td>\n<td style=\"text-align:left\">依赖存储，如 LevelDB 需 ZooKeeper</td>\n<td style=\"text-align:left\">需要 ZooKeeper</td>\n<td style=\"text-align:left\">支持镜像队列（Classic / Quorum 模式）</td>\n<td style=\"text-align:left\">支持主从模式（无需额外组件）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">消息轨迹（Message Track）</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">不支持（可通过插件扩展）</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置复杂度</td>\n<td style=\"text-align:left\">默认配置较低，需手动优化</td>\n<td style=\"text-align:left\">配置为键值对，可文件或代码提供</td>\n<td style=\"text-align:left\">开箱即用，配置灵活但选项较多</td>\n<td style=\"text-align:left\">开箱即用，仅需关注少量配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">管理与运维工具</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">支持（命令行监控）</td>\n<td style=\"text-align:left\">支持（Web 管理控制台、CLI）</td>\n<td style=\"text-align:left\">支持（丰富的 Web 与命令行工具）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RocketMQ-的安装\">RocketMQ 的安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5.x 依赖 JDK 1.8+。</p>\n</li>\n</ul>\n<h3 id=\"单机安装\">单机安装</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/quickStart/01quickstart\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>下载RocketMQ</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/rocketmq/</span><br><span class=\"line\">wget https://dist.apache.org/repos/dist/release/rocketmq/5.3.2/rocketmq-all-5.3.2-bin-release.zip</span><br><span class=\"line\">unzip rocketmq-all-5.3.2-bin-release.zip</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s rocketmq-all-5.3.2-bin-release rocketmq5</span><br><span class=\"line\"><span class=\"built_in\">cd</span> rocketmq5</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">默认脚本中，NameServer需要4G内存，Broker 需要8G内存，如果内存不够，可以进入bin目录，对其中的<code>runserver.sh</code>和<code>runbroker.sh</code>两个脚本进行一下修改</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用vi runserver.sh指令，编辑这个脚本，找到下面的一行配置，调整Java进程的内存大小。</span></span><br><span class=\"line\"><span class=\"comment\"># NameServer,Controller,Proxy 都使用这个脚本启动</span></span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\">修改为：</span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接下来，同样调整runbroker.sh中的内存大小。Broker 使用这个脚本启动</span></span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms8g -Xmx8g&quot;</span></span><br><span class=\"line\">修改为：</span><br><span class=\"line\">JAVA_OPT=<span class=\"string\">&quot;<span class=\"variable\">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g&quot;</span></span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 NameServer</p>\n</li>\n</ul>\n<blockquote>\n<p>安装完RocketMQ包后，我们启动NameServer</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 启动namesrv</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class=\"line\"><span class=\"comment\">## 指定配置文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqnamesrv -c namesrv.conf &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 验证namesrv是否启动成功</span></span><br><span class=\"line\">$ <span class=\"built_in\">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\"><span class=\"comment\"># 我们可以在namesrv.log 中看到 &#x27;The Name Server boot success..&#x27;， 表示NameServer 已成功启动。</span></span><br><span class=\"line\">The Name Server boot success. serializeType=JSON, address 0.0.0.0:9876</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>namesrv.conf 示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The port of nameserver</span></span><br><span class=\"line\">listenPort = 9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Broker+Proxy</p>\n</li>\n</ul>\n<blockquote>\n<p>NameServer成功启动后，我们启动Broker和Proxy。这里我们使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 先启动broker</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;</span><br><span class=\"line\"><span class=\"comment\"># 指定配置文件， 默认就是 conf/broker.conf</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqbroker -n localhost:9876 -c conf/broker.conf --enable-proxy &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上面的启动方式与下面的启动方式效果一样</span></span><br><span class=\"line\">$ <span class=\"built_in\">nohup</span> sh bin/mqproxy -n localhost:9876 -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json -bc /usr/local/soft/rocketmq/rocketmq5/conf/broker.conf -pm <span class=\"built_in\">local</span> &amp;</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># -n, --namesrvAddr NameServer 的地址</span></span><br><span class=\"line\"><span class=\"comment\"># -pc, --proxyConfigPath Proxy 配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -bc, --brokerConfigPath Broker 配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -pm, --proxyMode Proxy 模式，local or cluster</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span><br><span class=\"line\">$ <span class=\"built_in\">tail</span> -f ~/logs/rocketmqlogs/proxy.log</span><br><span class=\"line\"><span class=\"comment\"># 我们可以在 proxy.log 中看到“The broker[brokerName,ip:port] boot success..”，这表明 broker 已成功启动。</span></span><br><span class=\"line\">The broker[broker-a, 10.250.0.175:10911] boot success. serializeType=JSON and name server is localhost:9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关闭服务器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先停止 Broker</span></span><br><span class=\"line\">$ sh bin/mqshutdown broker</span><br><span class=\"line\"><span class=\"comment\"># 停止 NameServer</span></span><br><span class=\"line\">$ sh bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群安装-多节点（集群）多副本模式-异步复制\">集群安装:多节点（集群）多副本模式-异步复制</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/01deploy\">官网文档</a> 对集群安装的方式介绍了多种，本文仅实战一种：<code>多节点（集群）多副本模式-异步复制</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>每个Master配置一个Slave，有多组 Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>\n<li class=\"lvl-6\">缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>该模式下，Master 节点和 Slave 节点之间是异步复制的，Master 节点挂掉后，Slave 节点不会自动切换为 Master 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># NameServer 3 台</span></span><br><span class=\"line\">NameServer1 10.250.0.175</span><br><span class=\"line\">NameServer2 10.250.0.188</span><br><span class=\"line\">NameServer3 10.250.0.31</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Broker 2 Master 2 Replicas</span></span><br><span class=\"line\">Broker1 10.250.0.188 broker-a,broker-b-s</span><br><span class=\"line\">Broker2 10.250.0.31  broker-b,broker-a-s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Proxy 3 台</span></span><br><span class=\"line\">Proxy1 10.250.0.175</span><br><span class=\"line\">Proxy2 10.250.0.188</span><br><span class=\"line\">Proxy3 10.250.0.31</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署-NameServer\">部署 NameServer</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在三台服务器上分别启动RocketMQ NameServer</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/rocketmq/rocketmq5</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署Broker\">部署Broker</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-a.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-a              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=0                       <span class=\"comment\"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class=\"line\">deleteWhen=04                    <span class=\"comment\"># 表示凌晨 4 点清理</span></span><br><span class=\"line\">fileReservedTime=48              <span class=\"comment\"># 表示保存 48 小时的数据</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER          <span class=\"comment\"># 角色，表示异步复制的主节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH        <span class=\"comment\"># 表示异步刷盘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径，后面会介绍</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=10911</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-a-s.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-a              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=1                       <span class=\"comment\"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE                 <span class=\"comment\"># 角色，表示异步复制的从节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-a</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-a/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-a/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-a/abort</span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=11011</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-b.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-b              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=0                       <span class=\"comment\"># brokerId 必须唯一 ，且 master 的 brokerId 必须为 0</span></span><br><span class=\"line\">deleteWhen=04                    <span class=\"comment\"># 表示凌晨 4 点清理</span></span><br><span class=\"line\">fileReservedTime=48              <span class=\"comment\"># 表示保存 48 小时的数据</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER          <span class=\"comment\"># 角色，表示异步复制的主节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH        <span class=\"comment\"># 表示异步刷盘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=10911</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>broker-b-s.properties</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster <span class=\"comment\"># 集群名称必须一致</span></span><br><span class=\"line\">brokerName=broker-b              <span class=\"comment\"># broker 名称，master 和 slave 的 brokerName 必须一致</span></span><br><span class=\"line\">brokerId=1                       <span class=\"comment\"># brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE                 <span class=\"comment\"># 角色，表示异步复制的从节点</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口</span></span><br><span class=\"line\"><span class=\"comment\"># 存储数据路径</span></span><br><span class=\"line\">storePathRootDir=/usr/local/soft/rocketmq/data/store-b</span><br><span class=\"line\">storePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlog</span><br><span class=\"line\">storePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeue</span><br><span class=\"line\">storePathIndex=/usr/local/soft/rocketmq/data/store-b/index</span><br><span class=\"line\">storePathConfig=/usr/local/soft/rocketmq/data/store-b/config</span><br><span class=\"line\">storeCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpoint</span><br><span class=\"line\">abortFile=/usr/local/soft/rocketmq/data/store-b/abort</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口</span></span><br><span class=\"line\">listenPort=11011</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Broker1 10.250.0.188 上启动 broker-a 和 broker-b-s</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动 broker-a</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class=\"line\"><span class=\"comment\"># 启动 broker-b-s</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## nohup.out 中的输出类似与下面这种就表示启动成功</span></span><br><span class=\"line\">The broker[broker-a, 10.250.0.31:11011] boot success. serializeType=JSON and name server is 10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Broker2 10.250.0.31 上启动 broker-b 和 broker-a-s</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动 broker-b</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class=\"line\"><span class=\"comment\"># 启动 broker-a-s</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqbroker -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动成功后，可以通过如下命令检查机器状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                1     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489250.72     0.2600          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                1     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489250.72     0.2900         <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置-Proxy\">配置 Proxy</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在三台服务器上分别启动RocketMQ NameServer</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqproxy -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 指定配置文件，这里要注意，集群的名称要与 conf/rmq-proxy.json 中配置的集群名称必须一致，默认是 DefaultCluster</span></span><br><span class=\"line\"><span class=\"comment\">## 默认的配置文件就是 conf/rmq-proxy.json，但如果通过 -pc 指定配置文件，则必须使用绝对路径</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqproxy -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 查看日志，输出如下内容就表示启动成功，tail -f nohup.out</span></span><br><span class=\"line\">rocketmq-proxy startup successfully</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rmq-proxy.json 示例</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;rocketMQClusterName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;DefaultCluster&quot;</span><span class=\"punctuation\">,</span> # 集群名称</span><br><span class=\"line\">  <span class=\"attr\">&quot;remotingListenPort&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">8080</span><span class=\"punctuation\">,</span>              # 监听端口，默认 <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;grpcServerPort&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">8081</span>                   # grpc 监听端口，默认 <span class=\"number\">8081</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>停止Proxy</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止 Proxy</span></span><br><span class=\"line\">sh bin/mqshutdown proxy</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群安装-主备自动切换模式部署\">集群安装:主备自动切换模式部署</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5.x 提供了一种新的部署方式 <code>Controller</code>，可以在主从模式下实现主备自动切换，当主节点挂掉时，自动切换到从节点上运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/03autofailover\">官方文档:主备自动切换模式部署</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 组件提供选主能力，若需要保证 Controller 具备容错能力，Controller 部署需要三副本及以上（遵循 Raft 的多数派协议）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文在上文“集群安装:多节点（集群）多副本模式-异步复制”的基础上进行修改</p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 部署有两种方式。一种是嵌入于 NameServer 进行部署，另一种是独立部署，本文采用独立部署 Controller 组件的方式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Controller 3 台</span></span><br><span class=\"line\">Controller1 10.250.0.175</span><br><span class=\"line\">Controller2 10.250.0.188</span><br><span class=\"line\">Controller3 10.250.0.31</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别在每台机器上创建<code>controller.conf</code>配置文件，内容如下(注意修改节点Id)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># controller.conf</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># DLedger Raft Group 的名字，同一集群保持一致</span></span><br><span class=\"line\">controllerDLegerGroup = group1</span><br><span class=\"line\"><span class=\"comment\"># 集群中三个节点的成员定义，每个节点都必须一致</span></span><br><span class=\"line\">controllerDLegerPeers = n0-10.250.0.175:9877;n1-10.250.0.188:9877;n2-10.250.0.31:9877</span><br><span class=\"line\"><span class=\"comment\"># 节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一</span></span><br><span class=\"line\">controllerDLegerSelfId = n0</span><br><span class=\"line\"><span class=\"comment\"># Controller 数据存储路径（非常关键！不要删除）</span></span><br><span class=\"line\">controllerStorePath = /usr/local/soft/rocketmq/data/DledgerController</span><br><span class=\"line\"><span class=\"comment\"># 是否允许从 SyncStateSet 外选举 Master</span></span><br><span class=\"line\"><span class=\"comment\"># true 会加快选举但可能丢消息，建议生产保持 false</span></span><br><span class=\"line\">enableElectUncleanMaster = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 当 Broker 副本角色变化时是否主动通知（建议开启）</span></span><br><span class=\"line\">notifyBrokerRoleChanged = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 启动端口，端口不能与 NameServer、Broker、Proxy 端口冲突</span></span><br><span class=\"line\">listenPort = 9877</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动每台机器上的 Controller</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">nohup</span> sh bin/mqcontroller -n <span class=\"string\">&quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot;</span> -c conf/controller.conf &amp;</span><br><span class=\"line\"><span class=\"comment\">## 启动成功后，查看 nohup.out 文件，输出如下内容就表示启动成功</span></span><br><span class=\"line\">load config properties file OK, conf/controller.conf</span><br><span class=\"line\">The Controller Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改 broker 配置文件，以 <code>broker-a.properties</code> 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 去掉如下配置，Controller 模式下 会自动分配</span></span><br><span class=\"line\"><span class=\"comment\"># brokerId=1                       # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0</span></span><br><span class=\"line\"><span class=\"comment\"># brokerRole=ASYNC_MASTER          # 角色，表示异步复制的主节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加如下配置</span></span><br><span class=\"line\"><span class=\"comment\"># 启用 Controller 模式（自动主从切换模式的总开关）</span></span><br><span class=\"line\">enableControllerMode = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># Controller 集群地址列表（建议与 Controller 集群保持一致）</span></span><br><span class=\"line\">controllerAddr = 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>RocketMQ 5 Broker Controller 模式配置参数表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">备注 / 建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>enableControllerMode</strong></td>\n<td style=\"text-align:left\">是否启用 Controller 模式（自动主从切换总开关）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">必须设为 <code>true</code> 才能启用自动主从切换</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>controllerAddr</strong></td>\n<td style=\"text-align:left\">Controller 集群地址列表（以分号分隔）</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:left\">所有 Broker 配置应一致，例如 <code>10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncBrokerMetadataPeriod</strong></td>\n<td style=\"text-align:left\">向 Controller 同步 Broker 副本信息的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>5000</code> (5s)</td>\n<td style=\"text-align:left\">保持默认即可；用于上报心跳与元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>checkSyncStateSetPeriod</strong></td>\n<td style=\"text-align:left\">检查同步状态集（SyncStateSet）的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>5000</code> (5s)</td>\n<td style=\"text-align:left\">Controller 会定期剔除落后副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncControllerMetadataPeriod</strong></td>\n<td style=\"text-align:left\">同步 Controller 元数据的时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>10000</code> (10s)</td>\n<td style=\"text-align:left\">Broker 定期从集群获取当前活跃 Controller 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>haMaxTimeSlaveNotCatchup</strong></td>\n<td style=\"text-align:left\">Slave 未跟上 Master 的最大时间间隔（毫秒）</td>\n<td style=\"text-align:center\"><code>15000</code> (15s)</td>\n<td style=\"text-align:left\">超过该时间将 Slave 移出 SyncStateSet</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathEpochFile</strong></td>\n<td style=\"text-align:left\">Epoch 文件存储路径</td>\n<td style=\"text-align:center\"><code>store/epochFile</code></td>\n<td style=\"text-align:left\">非常重要！不要删除；存储主从任期、epoch 等元信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>allAckInSyncStateSet</strong></td>\n<td style=\"text-align:left\">是否要求所有同步副本都 ACK 后才返回成功</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\"><code>true</code> 可保证强一致但性能下降；建议保持默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>syncFromLastFile</strong></td>\n<td style=\"text-align:left\">Slave 是否从最后一个文件开始复制（空盘启动时）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">若历史日志很大且 Slave 新建，可设为 <code>true</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>asyncLearner</strong></td>\n<td style=\"text-align:left\">是否为异步 learner 副本（不参与选主）</td>\n<td style=\"text-align:center\"><code>false</code></td>\n<td style=\"text-align:left\">用于远程灾备副本，不会被选举为 Master</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>inSyncReplicas</strong></td>\n<td style=\"text-align:left\">需保持同步的副本组数量</td>\n<td style=\"text-align:center\"><code>1</code></td>\n<td style=\"text-align:left\">若 <code>allAckInSyncStateSet=true</code>，该参数无效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>minInSyncReplicas</strong></td>\n<td style=\"text-align:left\">最小同步副本数量，低于该值则拒绝写入</td>\n<td style=\"text-align:center\"><code>1</code></td>\n<td style=\"text-align:left\">防止写入过多未同步副本导致数据丢失风险</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重新启动 Broker，为保证主从数据一致性在重启时不被破坏，启动顺序应为先重新原Master，再重启原Slave</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动成功后，可以通过如下命令检查机器状态，可以看到集群内部自动分配了主从</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  2-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.48     0.2700          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                2     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  489268.48     0.2900         <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>验证主备自动切换，此时关闭 <code>broker-b</code> 的 Master，并查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin clusterList -n 10.250.0.175:9876</span><br><span class=\"line\"><span class=\"comment\">## 输出类似如下，可以看到`broker-b`原来的 Slave 被切换为 Master</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                2     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  489268.58     0.2700         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  0-0(0.0w, 0.0, 0.0)               0  489268.58     0.2900          <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重新启动刚才关闭的 <code>broker-b</code> ，节点会自动加入集群，角色为 Slave</p>\n</li>\n<li class=\"lvl-2\">\n<p>停止 Controller</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止 PrControlleroxy</span></span><br><span class=\"line\">sh bin/mqshutdown controller</span><br></pre></td></tr></table></figure>\n<h2 id=\"端口说明\">端口说明</h2>\n<table>\n<thead>\n<tr>\n<th>端口号</th>\n<th>协议</th>\n<th>组件/服务</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>9876</strong></td>\n<td>TCP</td>\n<td><strong>NameServer</strong></td>\n<td>RocketMQ 集群的 <strong>NameServer</strong> 服务端口。<br>用于 Broker 注册、客户端路由发现。<br>Producer/Consumer 连接此端口以获取 Broker 地址。</td>\n</tr>\n<tr>\n<td><strong>8080</strong></td>\n<td>TCP</td>\n<td><strong>Proxy (gRPC / HTTP)</strong></td>\n<td>RocketMQ 5 引入的 <strong>Proxy 服务</strong> 默认端口之一。<br>用于 <strong>HTTP/gRPC 客户端接入</strong>，例如 RocketMQ Proxy REST API、异步消息接口等。</td>\n</tr>\n<tr>\n<td><strong>8081</strong></td>\n<td>TCP</td>\n<td><strong>Proxy Admin / Dashboard / gRPC Alt</strong></td>\n<td>通常是 Proxy 的 <strong>管理接口</strong> 或 <strong>gRPC 辅助端口</strong>（依配置而定）。<br>也可能是控制面接口，用于与 Console 或控制工具通信。</td>\n</tr>\n<tr>\n<td><strong>10909</strong></td>\n<td>TCP</td>\n<td><strong>Broker HA (High Availability)</strong></td>\n<td>Broker <strong>主从同步端口</strong>（Master ↔ Slave 之间的数据复制）。<br>用于消息数据与元数据的同步。</td>\n</tr>\n<tr>\n<td><strong>10911</strong></td>\n<td>TCP</td>\n<td><strong>Broker 服务端口</strong></td>\n<td>Broker 的 <strong>主通信端口</strong>，客户端连接发送消息、消费消息、心跳等。<br>Producer 和 Consumer 通过 NameServer 获取该端口地址后进行通信。</td>\n</tr>\n<tr>\n<td><strong>10912</strong></td>\n<td>TCP</td>\n<td><strong>Broker HA 客户端端口</strong></td>\n<td>Broker <strong>主从复制中的 Slave 连接 Master</strong> 时使用的 <strong>客户端监听端口</strong>。<br>通常与 10909 配合使用，一主多从模式中 Slave 主动连接 Master。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"日志及数据存储路径\">日志及数据存储路径</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RocketMQ 5 主要有三类服务组件需要关注它们的存储目录</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">组件</th>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">默认存储内容</th>\n<th style=\"text-align:left\">默认路径（Linux 环境）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>NameServer</strong></td>\n<td style=\"text-align:left\">路由服务（注册中心）</td>\n<td style=\"text-align:left\">各个组件的的注册</td>\n<td style=\"text-align:left\">日志文件：<code>~/logs/rocketmqlogs/namesrv.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.namesrv.logback.xml</code> <br> 配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/namesrv.conf</code>（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Broker</strong></td>\n<td style=\"text-align:left\">核心消息存储与转发服务</td>\n<td style=\"text-align:left\">消息数据（CommitLog、ConsumeQueue、Index、Config）<br><strong>目录结构：</strong><br>├── <code>commitlog/</code> → 消息物理文件<br>├── <code>consumequeue/</code> → 消费队列索引<br>├── <code>index/</code> → 消息索引<br>├── <code>config/</code> → topic、offset、subscription 信息<br>├── <code>checkpoint</code> → 存储校验点<br>├── <code>abort</code> → 异常退出标志</td>\n<td style=\"text-align:left\"><strong>数据目录</strong>：<code>~/store</code><br>日志文件：<code>~/logs/rocketmqlogs/broker.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.broker.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/broker.conf</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Proxy</strong></td>\n<td style=\"text-align:left\">客户端访问入口层（无状态代理）<br>（5.x 新引入组件）</td>\n<td style=\"text-align:left\">转发日志、访问日志</td>\n<td style=\"text-align:left\">日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.proxy.logback.xml</code><br>日志文件：<code>~/logs/rocketmqlogs/proxy.log</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq-proxy.json</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Controller</strong></td>\n<td style=\"text-align:left\"><strong>Broker 主从协调与高可用管理</strong><br>（5.x 新引入组件）</td>\n<td style=\"text-align:left\">- 集群主从元数据（主从关系、broker注册信息）<br>- Controller 自身运行状态与选举元数据</td>\n<td style=\"text-align:left\"><strong>数据目录</strong>：<code>~/store/controller</code><br>日志文件：<code>~/logs/rocketmqlogs/controller.log</code><br>日志配置：<code>$&#123;ROCKETMQ_HOME&#125;/conf/rmq.controller.logback.xml</code><br>配置文件：<code>$&#123;ROCKETMQ_HOME&#125;/conf/controller.conf</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NameServer 和 Proxy 都是无状态（stateless）组件，不会持久化业务数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Broker 数据路径说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置项</th>\n<th style=\"text-align:left\">默认路径</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">主要作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>storePathRootDir</strong></td>\n<td style=\"text-align:left\"><code>/home/rocketmq/store</code><br>（默认）</td>\n<td style=\"text-align:left\">消息存储的根目录</td>\n<td style=\"text-align:left\">作为所有存储文件的父级目录，其他路径若未单独配置，则在此目录下创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathCommitLog</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/commitlog</code></td>\n<td style=\"text-align:left\">CommitLog 文件存放路径</td>\n<td style=\"text-align:left\">存储消息主体内容，是最核心的数据文件（顺序写入）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathConsumeQueue</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/consumequeue</code></td>\n<td style=\"text-align:left\">消费队列文件存放路径</td>\n<td style=\"text-align:left\">存储消息在队列中的索引（逻辑队列），指向 CommitLog 的物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathIndex</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/index</code></td>\n<td style=\"text-align:left\">索引文件存放路径</td>\n<td style=\"text-align:left\">提供按 Key 查询消息的索引结构，便于通过 Message Key 快速检索消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storePathConfig</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/config</code></td>\n<td style=\"text-align:left\">Broker 运行时配置存储路径</td>\n<td style=\"text-align:left\">存储运行时生成的配置文件，如 topic、consumerOffset、subscriptionGroup 等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeCheckpoint</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/checkpoint</code></td>\n<td style=\"text-align:left\">Checkpoint 文件路径</td>\n<td style=\"text-align:left\">记录 CommitLog、ConsumeQueue、Index 三者的刷盘进度，用于崩溃恢复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>abortFile</strong></td>\n<td style=\"text-align:left\"><code>$&#123;storePathRootDir&#125;/abort</code></td>\n<td style=\"text-align:left\">异常退出标志文件路径</td>\n<td style=\"text-align:left\">用于标识 Broker 是否异常退出，启动时据此判断是否执行恢复流程</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"安装过程中遇到的问题\">安装过程中遇到的问题</h2>\n<h3 id=\"1-启动-Proxy-失败\">1.启动 Proxy 失败</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无论是 <code>Broker+Proxy</code> 启动，还是 单独启动 <code>Proxy</code>，都报如下错误：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 错误会在 nohup.out 中输出</span></span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.UnsatisfiedLinkError: failed to load the required native library</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64_fedora, netty_tcnative_linux_x86_64, netty_tcnative_x86_64, netty_tcnative]</span><br><span class=\"line\"></span><br><span class=\"line\">Suppressed: java.lang.UnsatisfiedLinkError: /tmp/libnetty_tcnative_linux_x86_642308675901892111861.so: libcrypt.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>原因分析</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">\n<ol>\n<li class=\"lvl-7\">Netty-tcnative 的编译依赖：RocketMQ 使用的 Netty 的 tcnative 模块是在较旧的环境中编译的，而动态链接的版本锁定：编译时链接的是 libcrypt.so.1，运行时必须找到相同主版本号的库</li>\n</ol>\n</li>\n<li class=\"lvl-4\">\n<ol start=\"2\">\n<li class=\"lvl-7\">而我当前使用的系统为 Amazon Linux 2023，基于更新的 glibc，其加密功能已经迁移到 libcrypt.so.2。（Amazon Linux 2：基于较旧的 glibc 版本，libcrypt.so.1 是主要的加密库）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检查 libcrypt 是否存在</span></span><br><span class=\"line\">$ ldconfig -p | grep libcrypt</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class=\"line\">\tlibcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class=\"line\">\tlibcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class=\"line\">\tlibcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class=\"line\">\tlibcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决办法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装兼容性包</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install libxcrypt-compat</span><br><span class=\"line\"><span class=\"comment\"># 检查 libcrypt 是否存在</span></span><br><span class=\"line\">$ ldconfig -p | grep libcrypt</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">  libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12</span><br><span class=\"line\">\tlibcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3</span><br><span class=\"line\">\tlibcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so</span><br><span class=\"line\">\tlibcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2</span><br><span class=\"line\">\tlibcrypt.so.1 (libc6,x86-64) =&gt; /lib64/libcrypt.so.1</span><br><span class=\"line\">\tlibcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-写入消息失败，并报如下错误\">2.写入消息失败，并报如下错误</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.rocketmq.client.exception.MQBrokerException: CODE: 14 DESC: service not available now. It may be caused by one of the following reasons: the broker<span class=\"string\">&#x27;s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00], messages are put to the slave, message store has been shut down, etc. BROKER: 10.250.0.175:10911</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>错误原因</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">RocketMQ 返回的 CODE: 14 表示：Broker 当前 不接受消息写入（服务暂不可用）。</li>\n<li class=\"lvl-4\">the broker’s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00]: Broker 的磁盘已满</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CL: 0.95 → CommitLog 95% 已使用</span><br><span class=\"line\">CQ: 0.95 → ConsumeQueue 95% 已使用</span><br><span class=\"line\">INDEX: -1.00 → 索引异常或未采集</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>含义</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>diskMaxUsedSpaceRatio</code></td>\n<td>Broker 磁盘最大可用比例（超过后禁止写入）</td>\n<td><strong>75%</strong></td>\n</tr>\n<tr>\n<td><code>storePathCommitLog</code></td>\n<td>消息存储路径（CommitLog）</td>\n<td><code>~/store/commitlog</code></td>\n</tr>\n<tr>\n<td><code>storePathConsumeQueue</code></td>\n<td>消费队列路径（ConsumeQueue）</td>\n<td><code>~/store/consumequeue</code></td>\n</tr>\n<tr>\n<td><code>storePathIndex</code></td>\n<td>索引路径</td>\n<td><code>~/store/index</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-4\">\n<p>总结：可以确认是 磁盘使用率过高 导致 Broker 自动进入 “写保护” 模式。</p>\n</li>\n</ul>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<ol>\n<li class=\"lvl-9\">清理磁盘：确认磁盘使用率过高，并清理磁盘空间，既降低磁盘使用率</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"2\">\n<li class=\"lvl-9\">磁盘扩容：如果清理磁盘空间后，磁盘使用率依然过高，则需要扩容磁盘</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"3\">\n<li class=\"lvl-9\">配置调整：调整 Broker 配置(<code>broker.conf</code>)，将 <code>diskMaxUsedSpaceRatio</code> 配置适当提高，如 96%(<code>diskMaxUsedSpaceRatio=96</code>)，调整后重启 Broker。仅建议在紧急情况下临时解决。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 RocketMQ 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 Apache RocketMQ 简介 一、RocketMQ 是什么？ RocketMQ 是一个分布式、队列模型的消息中间件。它由阿里巴巴在2012年开源，并于2017年正式成为 Apache 基金会的顶级项目。 你可以把它想象成一个在分布式系统中负责可靠传递消息的“邮局”或“快递系统”。当系统A需要发送数据给系统B，但它们之间不直接通信时，就可以通过 RocketMQ 来中转，确保消息不丢失、不重复，并且能按顺序送达。 RocketMQ 是一个高性能、高可靠、高实时的分布式消息中间件。它就像分布式系统的“中枢神经系统”，负责在各个服务之间可靠、高效地传递数据，是现代互联网架构中不可或缺的基础组件之一。 RocketMQ 5.x 通过引入 Proxy 模式，极大地提升了架构的灵活性、多语言支持能力和云原生亲和力，是其在消息中间件领域持续演进的重要里程碑。 它与 Kafka、RabbitMQ 等都是业界顶级的消息队列，但各有侧重。RocketMQ 在事务消息、顺序消息和对在线业务的稳定性支持方面表现尤为出色。 二、核心特点与优势 序号 特性 典型场景 主要作用 1 削峰填谷 电商秒杀、大促活动时大量下单请求瞬间涌入 将突发请求先缓存为消息，后端系统按自身能力平稳消费，避免系统过载崩溃 2 异步解耦 用户注册后触发多系统任务（邮件、优惠券、积分） 主流程只负责发送消息，其他系统独立异步处理，降低系统间耦合、提高扩展性 3 顺序消息 订单状态变更（创建 → 付款 → 发货 → 收货） 同一业务键（如订单ID）的消息按顺序发送和消费，保证业务逻辑正确性 4 持久化与高可靠性 关键业务消息必须不丢失（交易、支付、日志） 所有消息写入磁盘并支持主从复制，即使服务器重启也能恢复，保证高可用 5 消息回溯 消费逻辑出错、数据重算、补偿任务 支持重置消费位点，重新消费历史消息，实现业务补偿与追溯 6 海量消息堆积能力 大规模异步日志收集、IoT 数据汇聚、埋点分析 支持万亿级消息堆积，性能稳定不衰减，适用于大规模数据场景 三、核心架构与概念 要理解 RocketMQ，需要知道几个关键角色： 经典核心组件 序号 组件名称 主要作用 说明 / 特点 1 Producer（生产者） 发送消息的客户端 负责将业务系统的消息发送到指定的 Topic，支持同步、异步、单向三种发送方式 2 Consumer（消费者） 接收并消费消息的客户端 从 Broker 拉取消息并进行业务处理，可分为 Push 和 Pull 两种消费模式 3 Consumer Group（消费者组） 实现负载均衡与高可用消费 多个消费者订阅同一 Topic 时组成消费者组，一个分区只会被组内一个消费者消费 4 Broker（消息服务器） 存储和转发消息 RocketMQ 的核心组件，负责消息的持久化、转发、主从复制和高可用 5 Topic（主题） 消息的分类与路由单元 Producer 发送消息到指定 Topic，Consumer 订阅 Topic 消费消息；一个 Topic 可包含多个消息队列（分区） 6 Name Server（名字服务） 管理 Broker 地址信息 类似轻量级注册中心，维护 Broker 元数据，帮助 Producer 和 Consumer 定位消息存储位置 7 Controller（控制器） 主从自动切换与高可用控制 RocketMQ 5.x 引入，基于 Raft（DLedger）协议实现 Broker 自动选主和元数据管理 8 Proxy（代理层） 客户端访问入口与协议转换 RocketMQ 5.x 新组件，无状态，可横向扩展；统一接入层，支持多协议（如 HTTP、gRPC），隔离客户端与 Broker 引入 Proxy 模式的优势： 1234**架构解耦与语言无关**：Proxy 作为通用代理，将复杂的 Broker 协议封装成更简单的接口（如 gRPC），使得用不同编程语言（如 Go, Python, C++ 等）开发的客户端更容易接入，而无需实现复杂的原生协议。**简化客户端**：客户端不再需要感知 Name Server 和 Broker 的地址变化，只需连接固定的 Proxy 地址即可，大大降低了客户端的复杂度。**增强安全性**：可以在 Proxy 层统一实现安全认证、限流、审计等策略，作为Broker集群的安全屏障。**云原生友好**：无状态的 Proxy 非常适合在 Kubernetes 等容器化环境中进行部署和弹性伸缩。 消息中间件功能对比表（ActiveMQ vs Kafka vs RabbitMQ vs RocketMQ） 参考资料 功能项 ActiveMQ Kafka RabbitMQ RocketMQ 客户端 SDK Java、.NET、C++ 等 Java、Scala 等 Java、.NET、Go、Python、C 等 Java、C++、Go 通信协议与规范 推送模型（Push），支持 OpenWire、STOMP、AMQP、MQTT、JMS 拉取模型（Pull），支持 TCP 推送模型（Push），支持 AMQP、MQTT、STOMP、HTTP、WebSocket 拉取模型（Pull），支持 TCP、JMS、OpenMessaging 消息有序性 通过独占消费者（Exclusive Consumer）或独占队列（Exclusive Queues）保证顺序 保证分区内消息顺序 单队列内消息天然有序 严格顺序消息，可平滑扩展 定时/延迟消息 支持 不支持 支持（使用延迟插件） 支持 批量消息 不支持 支持（异步生产者） 支持（Publisher Confirms 模式下） 支持（同步模式可避免消息丢失） 广播消息 支持 不支持 支持（Fanout 交换机） 支持 消息过滤 支持 支持（可用 Kafka Streams 实现） 支持（基于 Exchange 的路由键或 Header） 支持（基于 SQL92 属性过滤） 服务器端触发重投递 不支持 不支持 支持（Nack 或 TTL+DLX） 支持 消息存储 支持高性能持久化（JDBC + LevelDB/KahaDB） 高性能文件存储 内存+磁盘混合存储（Mnesia/基于 Erlang 的日志） 高性能、低延迟文件存储 消息回溯（历史消息查询） 支持 支持（通过 offset） 不支持（消息被消费后无法回溯） 支持（时间戳与 offset） 消息优先级 支持 不支持 支持（优先级队列） 不支持 高可用与故障转移 依赖存储，如 LevelDB 需 ZooKeeper 需要 ZooKeeper 支持镜像队列（Classic / Quorum 模式） 支持主从模式（无需额外组件） 消息轨迹（Message Track） 不支持 不支持 不支持（可通过插件扩展） 支持 配置复杂度 默认配置较低，需手动优化 配置为键值对，可文件或代码提供 开箱即用，配置灵活但选项较多 开箱即用，仅需关注少量配置 管理与运维工具 支持 支持（命令行监控） 支持（Web 管理控制台、CLI） 支持（丰富的 Web 与命令行工具） RocketMQ 的安装 RocketMQ 5.x 依赖 JDK 1.8+。 单机安装 官方文档 下载RocketMQ 12345mkdir -p /usr/local/soft/rocketmq/wget https://dist.apache.org/repos/dist/release/rocketmq/5.3.2/rocketmq-all-5.3.2-bin-release.zipunzip rocketmq-all-5.3.2-bin-release.zipln -s rocketmq-all-5.3.2-bin-release rocketmq5cd rocketmq5 小贴士 默认脚本中，NameServer需要4G内存，Broker 需要8G内存，如果内存不够，可以进入bin目录，对其中的runserver.sh和runbroker.sh两个脚本进行一下修改 12345678910# 使用vi runserver.sh指令，编辑这个脚本，找到下面的一行配置，调整Java进程的内存大小。# NameServer,Controller,Proxy 都使用这个脚本启动JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;修改为：JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;# 接下来，同样调整runbroker.sh中的内存大小。Broker 使用这个脚本启动JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot;修改为：JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g&quot; 启动 NameServer 安装完RocketMQ包后，我们启动NameServer 123456789### 启动namesrv$ nohup sh bin/mqnamesrv &amp;## 指定配置文件$ nohup sh bin/mqnamesrv -c namesrv.conf &amp;### 验证namesrv是否启动成功$ tail -f ~/logs/rocketmqlogs/namesrv.log# 我们可以在namesrv.log 中看到 &#x27;The Name Server boot success..&#x27;， 表示NameServer 已成功启动。The Name Server boot success. serializeType=JSON, address 0.0.0.0:9876 namesrv.conf 示例 12# The port of nameserverlistenPort = 9876 启动 Broker+Proxy NameServer成功启动后，我们启动Broker和Proxy。这里我们使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。 1234567891011121314151617### 先启动broker$ nohup sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;# 指定配置文件， 默认就是 conf/broker.conf$ nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf --enable-proxy &amp;# 上面的启动方式与下面的启动方式效果一样$ nohup sh bin/mqproxy -n localhost:9876 -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json -bc /usr/local/soft/rocketmq/rocketmq5/conf/broker.conf -pm local &amp;## 参数说明# -n, --namesrvAddr NameServer 的地址# -pc, --proxyConfigPath Proxy 配置文件路径# -bc, --brokerConfigPath Broker 配置文件路径# -pm, --proxyMode Proxy 模式，local or cluster### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a$ tail -f ~/logs/rocketmqlogs/proxy.log# 我们可以在 proxy.log 中看到“The broker[brokerName,ip:port] boot success..”，这表明 broker 已成功启动。The broker[broker-a, 10.250.0.175:10911] boot success. serializeType=JSON and name server is localhost:9876 关闭服务器 1234# 先停止 Broker$ sh bin/mqshutdown broker# 停止 NameServer$ sh bin/mqshutdown namesrv 集群安装:多节点（集群）多副本模式-异步复制 官网文档 对集群安装的方式介绍了多种，本文仅实战一种：多节点（集群）多副本模式-异步复制 每个Master配置一个Slave，有多组 Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下： 优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样； 缺点：Master宕机，磁盘损坏情况下会丢失少量消息。 该模式下，Master 节点和 Slave 节点之间是异步复制的，Master 节点挂掉后，Slave 节点不会自动切换为 Master 节点。 集群规划 12345678910111213# NameServer 3 台NameServer1 10.250.0.175NameServer2 10.250.0.188NameServer3 10.250.0.31# Broker 2 Master 2 ReplicasBroker1 10.250.0.188 broker-a,broker-b-sBroker2 10.250.0.31 broker-b,broker-a-s# Proxy 3 台Proxy1 10.250.0.175Proxy2 10.250.0.188Proxy3 10.250.0.31 部署 NameServer 在三台服务器上分别启动RocketMQ NameServer 12cd /usr/local/soft/rocketmq/rocketmq5nohup sh bin/mqnamesrv &amp; 部署Broker broker-a.properties 12345678910111213141516171819brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-a # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=0 # brokerId 必须唯一 ，且 master 的 brokerId 必须为 0deleteWhen=04 # 表示凌晨 4 点清理fileReservedTime=48 # 表示保存 48 小时的数据brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点flushDiskType=ASYNC_FLUSH # 表示异步刷盘# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径，后面会介绍storePathRootDir=/usr/local/soft/rocketmq/data/store-astorePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-a/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-a/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpointabortFile=/usr/local/soft/rocketmq/data/store-a/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=10911 broker-a-s.properties 12345678910111213141516171819brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-a # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0deleteWhen=04fileReservedTime=48brokerRole=SLAVE # 角色，表示异步复制的从节点flushDiskType=ASYNC_FLUSH# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-astorePathCommitLog=/usr/local/soft/rocketmq/data/store-a/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-a/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-a/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-a/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-a/checkpointabortFile=/usr/local/soft/rocketmq/data/store-a/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=11011 broker-b.properties 1234567891011121314151617181920brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-b # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=0 # brokerId 必须唯一 ，且 master 的 brokerId 必须为 0deleteWhen=04 # 表示凌晨 4 点清理fileReservedTime=48 # 表示保存 48 小时的数据brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点flushDiskType=ASYNC_FLUSH # 表示异步刷盘# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-bstorePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-b/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-b/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpointabortFile=/usr/local/soft/rocketmq/data/store-b/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=10911 broker-b-s.properties 1234567891011121314151617181920brokerClusterName=DefaultCluster # 集群名称必须一致brokerName=broker-b # broker 名称，master 和 slave 的 brokerName 必须一致brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0deleteWhen=04fileReservedTime=48brokerRole=SLAVE # 角色，表示异步复制的从节点flushDiskType=ASYNC_FLUSH# 因为同一台服务器上启动多个 Broker，所以需要指定不同的存储路径和端口# 存储数据路径storePathRootDir=/usr/local/soft/rocketmq/data/store-bstorePathCommitLog=/usr/local/soft/rocketmq/data/store-b/commitlogstorePathConsumeQueue=/usr/local/soft/rocketmq/data/store-b/consumequeuestorePathIndex=/usr/local/soft/rocketmq/data/store-b/indexstorePathConfig=/usr/local/soft/rocketmq/data/store-b/configstoreCheckpoint=/usr/local/soft/rocketmq/data/store-b/checkpointabortFile=/usr/local/soft/rocketmq/data/store-b/abort#Broker 对外服务的监听端口，同一台机器上启动多个Broker，需要指定不同的端口listenPort=11011 在 Broker1 10.250.0.188 上启动 broker-a 和 broker-b-s 1234567# 启动 broker-anohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-a.properties &amp;# 启动 broker-b-snohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-b-s.properties &amp;## nohup.out 中的输出类似与下面这种就表示启动成功The broker[broker-a, 10.250.0.31:11011] boot success. serializeType=JSON and name server is 10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876 在 Broker2 10.250.0.31 上启动 broker-b 和 broker-a-s 1234# 启动 broker-bnohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-b.properties &amp;# 启动 broker-a-snohup sh bin/mqbroker -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/2m-2s-async/broker-a-s.properties &amp; 启动成功后，可以通过如下命令检查机器状态 12345678# 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489250.72 0.2900 trueDefaultCluster broker-a 1 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489250.72 0.2600 falseDefaultCluster broker-b 0 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489250.72 0.2600 trueDefaultCluster broker-b 1 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489250.72 0.2900 false 配置 Proxy 在三台服务器上分别启动RocketMQ NameServer 12345678nohup sh bin/mqproxy -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; &amp;## 指定配置文件，这里要注意，集群的名称要与 conf/rmq-proxy.json 中配置的集群名称必须一致，默认是 DefaultCluster## 默认的配置文件就是 conf/rmq-proxy.json，但如果通过 -pc 指定配置文件，则必须使用绝对路径nohup sh bin/mqproxy -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -pc /usr/local/soft/rocketmq/rocketmq5/conf/rmq-proxy.json &amp;## 查看日志，输出如下内容就表示启动成功，tail -f nohup.outrocketmq-proxy startup successfully rmq-proxy.json 示例 12345&#123; &quot;rocketMQClusterName&quot;: &quot;DefaultCluster&quot;, # 集群名称 &quot;remotingListenPort&quot;: 8080, # 监听端口，默认 8080 &quot;grpcServerPort&quot;: 8081 # grpc 监听端口，默认 8081&#125; 停止Proxy 12# 停止 Proxysh bin/mqshutdown proxy 集群安装:主备自动切换模式部署 RocketMQ 5.x 提供了一种新的部署方式 Controller，可以在主从模式下实现主备自动切换，当主节点挂掉时，自动切换到从节点上运行。 官方文档:主备自动切换模式部署 Controller 组件提供选主能力，若需要保证 Controller 具备容错能力，Controller 部署需要三副本及以上（遵循 Raft 的多数派协议）。 本文在上文“集群安装:多节点（集群）多副本模式-异步复制”的基础上进行修改 Controller 部署有两种方式。一种是嵌入于 NameServer 进行部署，另一种是独立部署，本文采用独立部署 Controller 组件的方式。 集群规划 1234# Controller 3 台Controller1 10.250.0.175Controller2 10.250.0.188Controller3 10.250.0.31 分别在每台机器上创建controller.conf配置文件，内容如下(注意修改节点Id) 1234567891011121314151617# controller.conf# ---------------------------------------------------------# DLedger Raft Group 的名字，同一集群保持一致controllerDLegerGroup = group1# 集群中三个节点的成员定义，每个节点都必须一致controllerDLegerPeers = n0-10.250.0.175:9877;n1-10.250.0.188:9877;n2-10.250.0.31:9877# 节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一controllerDLegerSelfId = n0# Controller 数据存储路径（非常关键！不要删除）controllerStorePath = /usr/local/soft/rocketmq/data/DledgerController# 是否允许从 SyncStateSet 外选举 Master# true 会加快选举但可能丢消息，建议生产保持 falseenableElectUncleanMaster = false# 当 Broker 副本角色变化时是否主动通知（建议开启）notifyBrokerRoleChanged = true# 启动端口，端口不能与 NameServer、Broker、Proxy 端口冲突listenPort = 9877 分别启动每台机器上的 Controller 1234nohup sh bin/mqcontroller -n &quot;10.250.0.175:9876;10.250.0.188:9876;10.250.0.31:9876&quot; -c conf/controller.conf &amp;## 启动成功后，查看 nohup.out 文件，输出如下内容就表示启动成功load config properties file OK, conf/controller.confThe Controller Server boot success. serializeType=JSON 修改 broker 配置文件，以 broker-a.properties 为例 123456789# 去掉如下配置，Controller 模式下 会自动分配# brokerId=1 # brokerId 必须唯一 ，且 slave 的 brokerId 必须大于 0# brokerRole=ASYNC_MASTER # 角色，表示异步复制的主节点# 添加如下配置# 启用 Controller 模式（自动主从切换模式的总开关）enableControllerMode = true# Controller 集群地址列表（建议与 Controller 集群保持一致）controllerAddr = 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877 RocketMQ 5 Broker Controller 模式配置参数表 参数名 说明 默认值 备注 / 建议 enableControllerMode 是否启用 Controller 模式（自动主从切换总开关） false 必须设为 true 才能启用自动主从切换 controllerAddr Controller 集群地址列表（以分号分隔） 无 所有 Broker 配置应一致，例如 10.250.0.175:9877;10.250.0.188:9877;10.250.0.31:9877 syncBrokerMetadataPeriod 向 Controller 同步 Broker 副本信息的时间间隔（毫秒） 5000 (5s) 保持默认即可；用于上报心跳与元数据 checkSyncStateSetPeriod 检查同步状态集（SyncStateSet）的时间间隔（毫秒） 5000 (5s) Controller 会定期剔除落后副本 syncControllerMetadataPeriod 同步 Controller 元数据的时间间隔（毫秒） 10000 (10s) Broker 定期从集群获取当前活跃 Controller 地址 haMaxTimeSlaveNotCatchup Slave 未跟上 Master 的最大时间间隔（毫秒） 15000 (15s) 超过该时间将 Slave 移出 SyncStateSet storePathEpochFile Epoch 文件存储路径 store/epochFile 非常重要！不要删除；存储主从任期、epoch 等元信息 allAckInSyncStateSet 是否要求所有同步副本都 ACK 后才返回成功 false true 可保证强一致但性能下降；建议保持默认 syncFromLastFile Slave 是否从最后一个文件开始复制（空盘启动时） false 若历史日志很大且 Slave 新建，可设为 true asyncLearner 是否为异步 learner 副本（不参与选主） false 用于远程灾备副本，不会被选举为 Master inSyncReplicas 需保持同步的副本组数量 1 若 allAckInSyncStateSet=true，该参数无效 minInSyncReplicas 最小同步副本数量，低于该值则拒绝写入 1 防止写入过多未同步副本导致数据丢失风险 重新启动 Broker，为保证主从数据一致性在重启时不被破坏，启动顺序应为先重新原Master，再重启原Slave 启动成功后，可以通过如下命令检查机器状态，可以看到集群内部自动分配了主从 12345678# 确认 Broker 是否已经成功注册到 Nameserver，执行以下命令（在任意一台机器上）sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.48 0.2900 trueDefaultCluster broker-a 2 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 2-0(0.0w, 0.0, 0.0) 0 489268.48 0.2700 falseDefaultCluster broker-b 0 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.48 0.2700 trueDefaultCluster broker-b 2 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 489268.48 0.2900 false 验证主备自动切换，此时关闭 broker-b 的 Master，并查看集群状态 123456sh bin/mqadmin clusterList -n 10.250.0.175:9876## 输出类似如下，可以看到`broker-b`原来的 Slave 被切换为 Master#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.58 0.2900 trueDefaultCluster broker-a 2 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 489268.58 0.2700 falseDefaultCluster broker-b 0 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 0-0(0.0w, 0.0, 0.0) 0 489268.58 0.2900 true 重新启动刚才关闭的 broker-b ，节点会自动加入集群，角色为 Slave 停止 Controller 12# 停止 PrControlleroxysh bin/mqshutdown controller 端口说明 端口号 协议 组件/服务 作用说明 9876 TCP NameServer RocketMQ 集群的 NameServer 服务端口。用于 Broker 注册、客户端路由发现。Producer/Consumer 连接此端口以获取 Broker 地址。 8080 TCP Proxy (gRPC / HTTP) RocketMQ 5 引入的 Proxy 服务 默认端口之一。用于 HTTP/gRPC 客户端接入，例如 RocketMQ Proxy REST API、异步消息接口等。 8081 TCP Proxy Admin / Dashboard / gRPC Alt 通常是 Proxy 的 管理接口 或 gRPC 辅助端口（依配置而定）。也可能是控制面接口，用于与 Console 或控制工具通信。 10909 TCP Broker HA (High Availability) Broker 主从同步端口（Master ↔ Slave 之间的数据复制）。用于消息数据与元数据的同步。 10911 TCP Broker 服务端口 Broker 的 主通信端口，客户端连接发送消息、消费消息、心跳等。Producer 和 Consumer 通过 NameServer 获取该端口地址后进行通信。 10912 TCP Broker HA 客户端端口 Broker 主从复制中的 Slave 连接 Master 时使用的 客户端监听端口。通常与 10909 配合使用，一主多从模式中 Slave 主动连接 Master。 日志及数据存储路径 RocketMQ 5 主要有三类服务组件需要关注它们的存储目录 组件 功能 默认存储内容 默认路径（Linux 环境） NameServer 路由服务（注册中心） 各个组件的的注册 日志文件：~/logs/rocketmqlogs/namesrv.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.namesrv.logback.xml 配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/namesrv.conf（可选） Broker 核心消息存储与转发服务 消息数据（CommitLog、ConsumeQueue、Index、Config）目录结构：├── commitlog/ → 消息物理文件├── consumequeue/ → 消费队列索引├── index/ → 消息索引├── config/ → topic、offset、subscription 信息├── checkpoint → 存储校验点├── abort → 异常退出标志 数据目录：~/store日志文件：~/logs/rocketmqlogs/broker.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.broker.logback.xml配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/broker.conf Proxy 客户端访问入口层（无状态代理）（5.x 新引入组件） 转发日志、访问日志 日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.proxy.logback.xml日志文件：~/logs/rocketmqlogs/proxy.log配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/rmq-proxy.json Controller Broker 主从协调与高可用管理（5.x 新引入组件） - 集群主从元数据（主从关系、broker注册信息）- Controller 自身运行状态与选举元数据 数据目录：~/store/controller日志文件：~/logs/rocketmqlogs/controller.log日志配置：$&#123;ROCKETMQ_HOME&#125;/conf/rmq.controller.logback.xml配置文件：$&#123;ROCKETMQ_HOME&#125;/conf/controller.conf NameServer 和 Proxy 都是无状态（stateless）组件，不会持久化业务数据。 Broker 数据路径说明 配置项 默认路径 说明 主要作用 storePathRootDir /home/rocketmq/store（默认） 消息存储的根目录 作为所有存储文件的父级目录，其他路径若未单独配置，则在此目录下创建 storePathCommitLog $&#123;storePathRootDir&#125;/commitlog CommitLog 文件存放路径 存储消息主体内容，是最核心的数据文件（顺序写入） storePathConsumeQueue $&#123;storePathRootDir&#125;/consumequeue 消费队列文件存放路径 存储消息在队列中的索引（逻辑队列），指向 CommitLog 的物理位置 storePathIndex $&#123;storePathRootDir&#125;/index 索引文件存放路径 提供按 Key 查询消息的索引结构，便于通过 Message Key 快速检索消息 storePathConfig $&#123;storePathRootDir&#125;/config Broker 运行时配置存储路径 存储运行时生成的配置文件，如 topic、consumerOffset、subscriptionGroup 等 storeCheckpoint $&#123;storePathRootDir&#125;/checkpoint Checkpoint 文件路径 记录 CommitLog、ConsumeQueue、Index 三者的刷盘进度，用于崩溃恢复 abortFile $&#123;storePathRootDir&#125;/abort 异常退出标志文件路径 用于标识 Broker 是否异常退出，启动时据此判断是否执行恢复流程 安装过程中遇到的问题 1.启动 Proxy 失败 无论是 Broker+Proxy 启动，还是 单独启动 Proxy，都报如下错误： 123456# 错误会在 nohup.out 中输出Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: failed to load the required native libraryCaused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64_fedora, netty_tcnative_linux_x86_64, netty_tcnative_x86_64, netty_tcnative]Suppressed: java.lang.UnsatisfiedLinkError: /tmp/libnetty_tcnative_linux_x86_642308675901892111861.so: libcrypt.so.1: cannot open shared object file: No such file or directory 原因分析 Netty-tcnative 的编译依赖：RocketMQ 使用的 Netty 的 tcnative 模块是在较旧的环境中编译的，而动态链接的版本锁定：编译时链接的是 libcrypt.so.1，运行时必须找到相同主版本号的库 而我当前使用的系统为 Amazon Linux 2023，基于更新的 glibc，其加密功能已经迁移到 libcrypt.so.2。（Amazon Linux 2：基于较旧的 glibc 版本，libcrypt.so.1 是主要的加密库） 12345678# 检查 libcrypt 是否存在$ ldconfig -p | grep libcrypt## 输出 libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12 libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3 libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2 libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so 解决办法 1234567891011# 安装兼容性包sudo yum install libxcrypt-compat# 检查 libcrypt 是否存在$ ldconfig -p | grep libcrypt## 输出 libcryptsetup.so.12 (libc6,x86-64) =&gt; /lib64/libcryptsetup.so.12 libcrypto.so.3 (libc6,x86-64) =&gt; /lib64/libcrypto.so.3 libcrypto.so (libc6,x86-64) =&gt; /lib64/libcrypto.so libcrypt.so.2 (libc6,x86-64) =&gt; /lib64/libcrypt.so.2 libcrypt.so.1 (libc6,x86-64) =&gt; /lib64/libcrypt.so.1 libcrypt.so (libc6,x86-64) =&gt; /lib64/libcrypt.so 2.写入消息失败，并报如下错误 1Caused by: org.apache.rocketmq.client.exception.MQBrokerException: CODE: 14 DESC: service not available now. It may be caused by one of the following reasons: the broker&#x27;s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00], messages are put to the slave, message store has been shut down, etc. BROKER: 10.250.0.175:10911 错误原因 RocketMQ 返回的 CODE: 14 表示：Broker 当前 不接受消息写入（服务暂不可用）。 the broker’s disk is full [CL: 0.95 CQ: 0.95 INDEX: -1.00]: Broker 的磁盘已满 123CL: 0.95 → CommitLog 95% 已使用CQ: 0.95 → ConsumeQueue 95% 已使用INDEX: -1.00 → 索引异常或未采集 配置项 含义 默认值 diskMaxUsedSpaceRatio Broker 磁盘最大可用比例（超过后禁止写入） 75% storePathCommitLog 消息存储路径（CommitLog） ~/store/commitlog storePathConsumeQueue 消费队列路径（ConsumeQueue） ~/store/consumequeue storePathIndex 索引路径 ~/store/index 总结：可以确认是 磁盘使用率过高 导致 Broker 自动进入 “写保护” 模式。 解决方法 清理磁盘：确认磁盘使用率过高，并清理磁盘空间，既降低磁盘使用率 磁盘扩容：如果清理磁盘空间后，磁盘使用率依然过高，则需要扩容磁盘 配置调整：调整 Broker 配置(broker.conf)，将 diskMaxUsedSpaceRatio 配置适当提高，如 96%(diskMaxUsedSpaceRatio=96)，调整后重启 Broker。仅建议在紧急情况下临时解决。","summary":"摘要 本文介绍 CentOS9 中 RocketMQ 的安装与使用。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-23T13:30:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/","url":"https://blog.hanqunfeng.com/2025/10/16/kafka-06-zk-to-kraft/","title":"Kafka 从 Zookeeper 迁移到 KRaft","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org/39/documentation.html#kraft_zk_migration\">官方文档：ZooKeeper到KRaft迁移</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"从-Zookeeper-模式迁移到-KRaft-模式（平滑迁移）\">从 Zookeeper 模式迁移到 KRaft 模式（平滑迁移）</h2>\n<p><em><strong>！！！迁移后将无法再恢复到 ZooKeeper 模式！！！</strong></em></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 官方在 3.4+ 引入了完整的 Zookeeper → KRaft 平滑迁移机制，称为 <code>ZK to KRaft (ZkMigration)</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>迁移背景与前提</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">项目</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">支持版本</td>\n<td style=\"text-align:left\">Kafka <strong>3.4.0+</strong>（建议至少使用 <strong>3.6.x ，目前最新版为 3.9.x</strong>）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迁移目的</td>\n<td style=\"text-align:left\">摆脱 ZooKeeper，完全切换为 KRaft 自管理模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迁移模式</td>\n<td style=\"text-align:left\"><strong>在线迁移</strong>（无停机或最小停机）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">最终目标</td>\n<td style=\"text-align:left\">Kafka 的控制器与元数据完全由 KRaft 管理，不再依赖 ZooKeeper。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>整体迁移流程概览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>控制器类型</th>\n<th>Broker 模式</th>\n<th>ZooKeeper 角色</th>\n<th>KRaft 角色</th>\n<th>特征说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>初始阶段</strong></td>\n<td>ZooKeeper 控制器</td>\n<td>全部为 ZK 模式</td>\n<td>管理所有元数据</td>\n<td>尚未启用</td>\n<td>所有 Broker 都运行在 ZK 模式下，由 ZK 控制器管理集群。</td>\n</tr>\n<tr>\n<td><strong>初始元数据加载阶段</strong></td>\n<td>KRaft 控制器开始加载</td>\n<td>部分（或全部）仍为 ZK 模式</td>\n<td>提供元数据源</td>\n<td>从 ZK 加载元数据</td>\n<td>KRaft 法定节点（controller.quorum.voters）从 ZK 中读取并同步当前集群元数据。</td>\n</tr>\n<tr>\n<td><strong>混合阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>部分 ZK 模式，部分 KRaft 模式</td>\n<td>保留只读元数据</td>\n<td>管理并更新元数据</td>\n<td>KRaft 控制器成为主控，ZK 仍存在但只提供读取，Broker 可处于不同模式（混合状态）。</td>\n</tr>\n<tr>\n<td><strong>双写阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>全部为 KRaft 模式</td>\n<td>接收 KRaft 同步写入</td>\n<td>管理元数据并写入 ZK</td>\n<td>所有 Broker 都运行在 KRaft 模式，控制器将元数据同时写入 ZK 和 KRaft 日志。</td>\n</tr>\n<tr>\n<td><strong>迁移完成阶段</strong></td>\n<td>KRaft 控制器</td>\n<td>全部为 KRaft 模式</td>\n<td>不再使用</td>\n<td>独立运行</td>\n<td>停止向 ZK 写入元数据，ZK 可安全关闭，Kafka 完全运行在无 Zookeeper 的 KRaft 模式下。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"开始迁移\">开始迁移</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里以前文 <a href=\"/2025/10/13/kafka-01-install-zookeeper/\" title=\"Kafka 的安装：基于 Zookeeper\">Kafka 的安装：基于 Zookeeper</a> 中的3个节点的集群为例。</p>\n</li>\n</ul>\n<h3 id=\"启动一个-Controller-节点\">启动一个 Controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在任意一个节点上启动一个 Controller 节点，这里为 worker1</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动前需要先获取当前 Kafka 集群的 Cluster ID</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ zookeeper-shell.sh localhost:2181 get /cluster/id</span><br><span class=\"line\">Connecting to localhost:2181</span><br><span class=\"line\"></span><br><span class=\"line\">WATCHER::</span><br><span class=\"line\"></span><br><span class=\"line\">WatchedEvent state:SyncConnected <span class=\"built_in\">type</span>:None path:null</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;version&quot;</span>:<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"string\">&quot;hp_Q0pihQ0ORcIvXlfHobQ&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>准备好 Controller 节点的配置文件，这里可以用 <code>config/kraft/controller.properties</code> 为模板进行修改</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色，这里只能是controller</span></span><br><span class=\"line\">process.roles=controller</span><br><span class=\"line\"><span class=\"comment\"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class=\"line\">node.id=3000</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点，因为我们当前只启动了一个controller节点，所以只能配置一个投票节点</span></span><br><span class=\"line\">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class=\"line\"><span class=\"comment\"># 配置监听器，注意端口不能重复</span></span><br><span class=\"line\">listeners=CONTROLLER://:9098</span><br><span class=\"line\">advertised.listeners=CONTROLLER://worker1:9098</span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"><span class=\"comment\"># 日志存放目录，这里存放的是元数据，在格式化时这个目录必须为空目录</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\">zookeeper.metadata.migration.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ZooKeeper client 连接</span></span><br><span class=\"line\">zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 其它参数尽量保持与旧集群的配置一致</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Controller 节点</p>\n</li>\n</ul>\n<blockquote>\n<p>千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 <a href=\"http://kafka-storage.sh\">kafka-storage.sh</a> format ，那会把原有数据结构重置或踩坏。<br>\n必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式化元数据目录，log.dirs 参数指定元数据存放目录，首次运行前必须为空目录</span></span><br><span class=\"line\"><span class=\"comment\"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class=\"line\">kafka-storage.sh format --standalone -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br><span class=\"line\"><span class=\"comment\"># 启动，这里没有后台启动是为了方便观察日志输出</span></span><br><span class=\"line\">kafka-server-start.sh /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>format 命令</th>\n<th>quorum 状态</th>\n<th>是否从 ZK 加载</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>迁移阶段（standalone）</td>\n<td><code>--standalone</code></td>\n<td>无（单节点）</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>正式 KRaft 模式</td>\n<td>无 <code>--standalone</code></td>\n<td>✅ 多节点</td>\n<td>❌ 否（独立运行）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将原先的三个节点作为-Broker-节点重新启动\">将原先的三个节点作为 Broker 节点重新启动</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改原先的配置文件 <code>server.properties</code>，只需要修改如下内容即可</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在最后加入 CONTROLLER:PLAINTEXT</span></span><br><span class=\"line\">listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,CONTROLLER:PLAINTEXT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 以下是新加入的 配置项</span></span><br><span class=\"line\"><span class=\"comment\"># Set the IBP，当前 kafka 版本是 3.9.1，所以这里设置为 3.9</span></span><br><span class=\"line\">inter.broker.protocol.version=3.9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\">zookeeper.metadata.migration.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># KRaft controller quorum configuration，因为目前只启动了一个 controller 节点，所以只能配置一个投票节点</span></span><br><span class=\"line\">controller.quorum.bootstrap.servers=worker1:9098</span><br><span class=\"line\"><span class=\"comment\"># 控制器监听器名称，要与 contreller 节点配置文件 controller.properties 中的配置一致</span></span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别重新启动三个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 kafka</span></span><br><span class=\"line\">kafka-server-stop.sh</span><br><span class=\"line\"><span class=\"comment\"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class=\"line\">ps -ef | grep kafka | grep  <span class=\"string\">&quot;server\\.properties&quot;</span> | grep -v grep | awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span> -9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新启动 kafka</span></span><br><span class=\"line\">kafka-server-start.sh /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当三个节点都以必要的配置重新启动后，迁移将自动开始。迁移完成后，可以在 Controller(worker1)节点 上看到类似如下日志：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ✅ 意味：从 ZooKeeper 到 KRaft 的初始元数据迁移已成功，共写入 62 条记录，当前 KRaft metadata offset 为 3179。这是迁移成功的明确证据。</span></span><br><span class=\"line\">Completed migration of metadata from ZooKeeper to KRaft. 62 records were generated <span class=\"keyword\">in</span> 300 ms across 1 batches. The average time spent waiting on a batch was 97.00 ms. The record types were &#123;TOPIC_RECORD=3, PARTITION_RECORD=56, CONFIG_RECORD=3&#125;. The current metadata offset is now 3179 with an epoch of 2. Saw 3 brokers <span class=\"keyword\">in</span> the migrated metadata [1, 2, 3]. (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：控制器已加载并生效新元数据与 feature set（与 offset 3179 对应）。</span></span><br><span class=\"line\">Loaded new metadata Features(metadataVersion=3.9-IV0, finalizedFeatures=&#123;metadata.version=21&#125;, finalizedFeaturesEpoch=3179). (org.apache.kafka.metadata.publisher.FeaturesPublisher)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：内部迁移状态已更新，KRaft 上有了写入位置记录。</span></span><br><span class=\"line\">Finished initial migration of ZK metadata to KRaft <span class=\"keyword\">in</span> 3486479 ns. Transitioned migration state from ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=-1, kraftMetadataEpoch=-1, lastUpdatedTimeMs=1760682050169, migrationZkVersion=1, controllerZkEpoch=3, controllerZkVersion=3&#125; to ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=3179, kraftMetadataEpoch=2, lastUpdatedTimeMs=1760682050169, migrationZkVersion=2, controllerZkEpoch=3, controllerZkVersion=3&#125; (org.apache.kafka.metadata.migration.KRaftMigrationDriver)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ✅ 意味：迁移流程按预期推进：先把 KRaft 的元数据与 ZK 对齐（sync），然后与 brokers 建立通信，最终进入 DUAL_WRITE（双写）。DUAL_WRITE 阶段表示控制器在写入 KRaft metadata log 的同时，仍然会把必要的写操作也写回 ZooKeeper（双写）——直到迁移完全完成并确认可以停止写 ZK 为止。</span></span><br><span class=\"line\">3000 transitioning from ZK_MIGRATION to SYNC_KRAFT_TO_ZK state</span><br><span class=\"line\">...</span><br><span class=\"line\">Performing a full metadata <span class=\"built_in\">sync</span> from KRaft to ZK.</span><br><span class=\"line\">Did not make any ZK writes when reconciling with KRaft state.</span><br><span class=\"line\">3000 transitioning ... to KRAFT_CONTROLLER_TO_BROKER_COMM</span><br><span class=\"line\">...</span><br><span class=\"line\">Sending RPCs to broker before moving to dual-write mode using at offset and epoch OffsetAndEpoch(offset=3179, epoch=2)</span><br><span class=\"line\">...</span><br><span class=\"line\">3000 transitioning ... to DUAL_WRITE state</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面的日志总体上表明，元数据迁移已成功完成并且控制器进入了双写（DUAL_WRITE）阶段。</p>\n</li>\n</ul>\n<h3 id=\"将三个Broker节点的配置修改为-KRaft-模式的-broker-节点\">将三个Broker节点的配置修改为 KRaft 模式的 broker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改三个节点的配置文件 <code>server.properties</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加process.roles=broker</span></span><br><span class=\"line\">process.roles=broker</span><br><span class=\"line\"><span class=\"comment\"># 用 node.id 替换 broker.id，注意，node.id 需要与 broker.id 一致</span></span><br><span class=\"line\"><span class=\"comment\"># broker.id=1</span></span><br><span class=\"line\">node.id=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 去掉 zookeeper 相关配置</span></span><br><span class=\"line\"><span class=\"comment\"># Don&#x27;t set the IBP, KRaft uses &quot;metadata.version&quot; feature flag</span></span><br><span class=\"line\"><span class=\"comment\"># inter.broker.protocol.version=3.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Remove the migration enabled flag</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.metadata.migration.enable=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Remove ZooKeeper client configuration</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别重新启动三个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 kafka</span></span><br><span class=\"line\">kafka-server-stop.sh</span><br><span class=\"line\"><span class=\"comment\"># 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.properties</span></span><br><span class=\"line\">ps -ef | grep kafka | grep  <span class=\"string\">&quot;server\\.properties&quot;</span> | grep -v grep | awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span> -9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新启动 kafka</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n<h3 id=\"将-Controller-节点的配置修改为-KRaft-模式的-controller-节点\">将 Controller 节点的配置修改为 KRaft 模式的 controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改 controller 节点的配置文件 <code>controller.properties</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 去掉去下内容</span></span><br><span class=\"line\"><span class=\"comment\"># 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.metadata.migration.enable=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ZooKeeper client 连接</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启启动 controller 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭后重新启动</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时你可以关闭 zookeeper 集群了，新的 kafka 集群将不再使用 ZooKeeper，也无法在恢复到 ZooKeeper 模式。</p>\n</li>\n</ul>\n<h3 id=\"加入新的-Controller-节点\">加入新的 Controller 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Controller 尽量保持 奇数个节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之前已经在 <code>worker1</code> 节点上启动了 controller ，现在 <code>worker2</code> 和 <code>worker3</code> 上也来启动 controller 节点，并将它们加入到 kafka 集群中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在开始配置前，先将上面的 controller 节点 和 三个 broker 节点 的如下配置进行修改，并重启启动。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 controller.quorum.bootstrap.servers 替换为 controller.quorum.voters</span></span><br><span class=\"line\">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.bootstrap.servers=worker1:9098</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.voters = 谁是正式投票成员（固定配置）</span></span><br><span class=\"line\"><span class=\"comment\"># controller.quorum.bootstrap.servers = 临时找谁引导连接（迁移或初始化用）</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n<th>适用阶段</th>\n<th>是否必需</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>controller.quorum.voters</code></strong></td>\n<td>定义 <strong>正式的 KRaft 控制器投票成员列表（voter set）</strong></td>\n<td>集群正常运行时</td>\n<td>✅ 是</td>\n<td>所有节点必须配置相同的值</td>\n</tr>\n<tr>\n<td><strong><code>controller.quorum.bootstrap.servers</code></strong></td>\n<td>定义 <strong>迁移阶段或初始化阶段的控制器连接地址（bootstrap controller endpoint）</strong></td>\n<td><strong>ZK → KRaft 迁移阶段</strong> 或 <strong>KRaft 集群初次启动</strong></td>\n<td>⚙️ 可选（仅特定阶段）</td>\n<td>用于在 controller quorum 尚未形成时的临时发现</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参考 worker1 上的 controller 节点的配置文件 <code>controller.properties</code>，配置 woker2 的 controller 节点配置文件<code>controller.properties</code> ，worker3 也是类似的。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色，这里只能是controller</span></span><br><span class=\"line\">process.roles=controller</span><br><span class=\"line\"><span class=\"comment\"># 节点ID，不能与现有Broker节点的ID一致</span></span><br><span class=\"line\">node.id=3001</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点</span></span><br><span class=\"line\">controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># 配置监听器，注意端口不能重复</span></span><br><span class=\"line\">listeners=CONTROLLER://:9098</span><br><span class=\"line\">advertised.listeners=CONTROLLER://worker2:9098</span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"><span class=\"comment\"># 日志存放目录，这里存放的是元数据</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-meta</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这里要与原先的 server.properties 中配置的监听器名称一致</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>初始化日志目录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只有 Controller 节点才需要初始化日志目录</span></span><br><span class=\"line\"><span class=\"comment\"># -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster ID</span></span><br><span class=\"line\">kafka-storage.sh format -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动 worker2 和 worker3 上的 controller 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时新的 controller 节点不会立刻加入选举队列，新节点初始状态默认是 observer，需要执行下面的命令将节点加入选举队列</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 worker2 和 worker3 上执行</span></span><br><span class=\"line\">kafka-metadata-quorum.sh --bootstrap-server localhost:9092 --command-config /usr/local/kafka/kafka3/config/kraft/controller.properties add-controller</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群节点状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --replication</span><br><span class=\"line\">NodeId\tDirectoryId           \tLogEndOffset\tLag\tLastFetchTimestamp\tLastCaughtUpTimestamp\tStatus</span><br><span class=\"line\">3000  \tRJ4oOPGgTw-KxHFNn4SmiQ\t27820       \t0  \t1760696136345     \t1760696136345        \tLeader</span><br><span class=\"line\">3001  \tzGnWA7zYmRHG6bcTlFV2qA\t27820       \t0  \t1760696136259     \t1760696136259        \tFollower</span><br><span class=\"line\">3002  \tgIDkhOQJEHqg-GJBdezU1Q\t27820       \t0  \t1760696136257     \t1760696136257        \tFollower</span><br><span class=\"line\">2     \t9KeeAYKEQHT92DxqNSwYuA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\">1     \tQ8lr8JQ2vrDS35_DrI1MxA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\">3     \trgQR5wd_i5hLgU97dCKIvA\t27820       \t0  \t1760696136257     \t1760696136257        \tObserver</span><br><span class=\"line\"></span><br><span class=\"line\">$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --status</span><br><span class=\"line\">ClusterId:              hp_Q0pihQ0ORcIvXlfHobQ</span><br><span class=\"line\">LeaderId:               3000</span><br><span class=\"line\">LeaderEpoch:            5</span><br><span class=\"line\">HighWatermark:          30094</span><br><span class=\"line\">MaxFollowerLag:         0</span><br><span class=\"line\">MaxFollowerLagTimeMs:   0</span><br><span class=\"line\">CurrentVoters:          [&#123;<span class=\"string\">&quot;id&quot;</span>: 3000, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;RJ4oOPGgTw-KxHFNn4SmiQ&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker1:9098&quot;</span>]&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3001, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;zGnWA7zYmRHG6bcTlFV2qA&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker2:9098&quot;</span>]&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3002, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;gIDkhOQJEHqg-GJBdezU1Q&quot;</span>, <span class=\"string\">&quot;endpoints&quot;</span>: [<span class=\"string\">&quot;CONTROLLER://worker3:9098&quot;</span>]&#125;]</span><br><span class=\"line\">CurrentObservers:       [&#123;<span class=\"string\">&quot;id&quot;</span>: 2, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;9KeeAYKEQHT92DxqNSwYuA&quot;</span>&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 1, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;Q8lr8JQ2vrDS35_DrI1MxA&quot;</span>&#125;, &#123;<span class=\"string\">&quot;id&quot;</span>: 3, <span class=\"string\">&quot;directoryId&quot;</span>: <span class=\"string\">&quot;rgQR5wd_i5hLgU97dCKIvA&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"加入-新的-Broker-节点\">加入 新的 Broker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建新的 Broker 节点时，参考其它 Broker 节点 配置好配置文件 <code>server.properties</code>，并启动 Broker 节点即可。</p>\n</li>\n<li class=\"lvl-2\">\n<p>无需运行日志目录初始化命令，因为 Broker 节点只存放 消息 数据。</p>\n</li>\n</ul>\n<h2 id=\"迁移后注意事项\">迁移后注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>迁移完成后，Kafka 客户端（Producer / Consumer / AdminClient）依然连接的是 Broker 节点，而不是 Controller 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 在 ZooKeeper 模式与 KRaft 模式下的区别主要在于：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">控制平面（Control Plane）：ZK 模式下由 ZooKeeper + Controller Broker 共同管理；KRaft 模式下由 独立的 Controller 进程或角色 管理（通过 Raft 协议同步元数据）。</li>\n<li class=\"lvl-4\">数据平面（Data Plane）：无论是哪个模式，客户端发送、消费消息仍然是通过 Broker 节点 完成的。</li>\n<li class=\"lvl-4\">也就是说，Controller 管理集群元数据（主题、分区、副本、Leader 选举等），而 Broker 节点处理实际的消息流。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 官方文档：ZooKeeper到KRaft迁移 从 Zookeeper 模式迁移到 KRaft 模式（平滑迁移） ！！！迁移后将无法再恢复到 ZooKeeper 模式！！！ Kafka 官方在 3.4+ 引入了完整的 Zookeeper → KRaft 平滑迁移机制，称为 ZK to KRaft (ZkMigration)。 迁移背景与前提 项目 说明 支持版本 Kafka 3.4.0+（建议至少使用 3.6.x ，目前最新版为 3.9.x） 迁移目的 摆脱 ZooKeeper，完全切换为 KRaft 自管理模式 迁移模式 在线迁移（无停机或最小停机） 最终目标 Kafka 的控制器与元数据完全由 KRaft 管理，不再依赖 ZooKeeper。 整体迁移流程概览 阶段 控制器类型 Broker 模式 ZooKeeper 角色 KRaft 角色 特征说明 初始阶段 ZooKeeper 控制器 全部为 ZK 模式 管理所有元数据 尚未启用 所有 Broker 都运行在 ZK 模式下，由 ZK 控制器管理集群。 初始元数据加载阶段 KRaft 控制器开始加载 部分（或全部）仍为 ZK 模式 提供元数据源 从 ZK 加载元数据 KRaft 法定节点（controller.quorum.voters）从 ZK 中读取并同步当前集群元数据。 混合阶段 KRaft 控制器 部分 ZK 模式，部分 KRaft 模式 保留只读元数据 管理并更新元数据 KRaft 控制器成为主控，ZK 仍存在但只提供读取，Broker 可处于不同模式（混合状态）。 双写阶段 KRaft 控制器 全部为 KRaft 模式 接收 KRaft 同步写入 管理元数据并写入 ZK 所有 Broker 都运行在 KRaft 模式，控制器将元数据同时写入 ZK 和 KRaft 日志。 迁移完成阶段 KRaft 控制器 全部为 KRaft 模式 不再使用 独立运行 停止向 ZK 写入元数据，ZK 可安全关闭，Kafka 完全运行在无 Zookeeper 的 KRaft 模式下。 开始迁移 这里以前文 Kafka 的安装：基于 Zookeeper 中的3个节点的集群为例。 启动一个 Controller 节点 在任意一个节点上启动一个 Controller 节点，这里为 worker1 启动前需要先获取当前 Kafka 集群的 Cluster ID 1234567$ zookeeper-shell.sh localhost:2181 get /cluster/idConnecting to localhost:2181WATCHER::WatchedEvent state:SyncConnected type:None path:null&#123;&quot;version&quot;:&quot;1&quot;,&quot;id&quot;:&quot;hp_Q0pihQ0ORcIvXlfHobQ&quot;&#125; 准备好 Controller 节点的配置文件，这里可以用 config/kraft/controller.properties 为模板进行修改 123456789101112131415161718192021222324# 配置当前节点的角色，这里只能是controllerprocess.roles=controller# 节点ID，不能与现有Broker节点的ID一致node.id=3000# 配置集群的投票节点，因为我们当前只启动了一个controller节点，所以只能配置一个投票节点controller.quorum.bootstrap.servers=worker1:9098# 配置监听器，注意端口不能重复listeners=CONTROLLER://:9098advertised.listeners=CONTROLLER://worker1:9098controller.listener.names=CONTROLLER# 日志存放目录，这里存放的是元数据，在格式化时这个目录必须为空目录log.dirs=/usr/local/kafka/dataDir/kraft-meta# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程zookeeper.metadata.migration.enable=true# ZooKeeper client 连接zookeeper.connect=worker1:2181,worker2:2181,worker3:2181# 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。# 注意这里要与原先的 server.properties 中配置的监听器名称一致inter.broker.listener.name=PLAINTEXT# 其它参数尽量保持与旧集群的配置一致 启动 Controller 节点 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。 12345# 格式化元数据目录，log.dirs 参数指定元数据存放目录，首次运行前必须为空目录# -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster IDkafka-storage.sh format --standalone -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties# 启动，这里没有后台启动是为了方便观察日志输出kafka-server-start.sh /usr/local/kafka/kafka3/config/kraft/controller.properties 模式 format 命令 quorum 状态 是否从 ZK 加载 迁移阶段（standalone） --standalone 无（单节点） ✅ 是 正式 KRaft 模式 无 --standalone ✅ 多节点 ❌ 否（独立运行） 将原先的三个节点作为 Broker 节点重新启动 修改原先的配置文件 server.properties，只需要修改如下内容即可 1234567891011121314# 在最后加入 CONTROLLER:PLAINTEXTlistener.security.protocol.map=PLAINTEXT:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,CONTROLLER:PLAINTEXT## 以下是新加入的 配置项# Set the IBP，当前 kafka 版本是 3.9.1，所以这里设置为 3.9inter.broker.protocol.version=3.9# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程zookeeper.metadata.migration.enable=true# KRaft controller quorum configuration，因为目前只启动了一个 controller 节点，所以只能配置一个投票节点controller.quorum.bootstrap.servers=worker1:9098# 控制器监听器名称，要与 contreller 节点配置文件 controller.properties 中的配置一致controller.listener.names=CONTROLLER 分别重新启动三个节点 1234567# 关闭 kafkakafka-server-stop.sh# 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.propertiesps -ef | grep kafka | grep &quot;server\\.properties&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9# 重新启动 kafkakafka-server-start.sh /usr/local/kafka/kafka3/config/server.properties 当三个节点都以必要的配置重新启动后，迁移将自动开始。迁移完成后，可以在 Controller(worker1)节点 上看到类似如下日志： 1234567891011121314151617181920# ✅ 意味：从 ZooKeeper 到 KRaft 的初始元数据迁移已成功，共写入 62 条记录，当前 KRaft metadata offset 为 3179。这是迁移成功的明确证据。Completed migration of metadata from ZooKeeper to KRaft. 62 records were generated in 300 ms across 1 batches. The average time spent waiting on a batch was 97.00 ms. The record types were &#123;TOPIC_RECORD=3, PARTITION_RECORD=56, CONFIG_RECORD=3&#125;. The current metadata offset is now 3179 with an epoch of 2. Saw 3 brokers in the migrated metadata [1, 2, 3]. (org.apache.kafka.metadata.migration.KRaftMigrationDriver)# ✅ 意味：控制器已加载并生效新元数据与 feature set（与 offset 3179 对应）。Loaded new metadata Features(metadataVersion=3.9-IV0, finalizedFeatures=&#123;metadata.version=21&#125;, finalizedFeaturesEpoch=3179). (org.apache.kafka.metadata.publisher.FeaturesPublisher)# ✅ 意味：内部迁移状态已更新，KRaft 上有了写入位置记录。Finished initial migration of ZK metadata to KRaft in 3486479 ns. Transitioned migration state from ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=-1, kraftMetadataEpoch=-1, lastUpdatedTimeMs=1760682050169, migrationZkVersion=1, controllerZkEpoch=3, controllerZkVersion=3&#125; to ZkMigrationLeadershipState&#123;kraftControllerId=3000, kraftControllerEpoch=2, kraftMetadataOffset=3179, kraftMetadataEpoch=2, lastUpdatedTimeMs=1760682050169, migrationZkVersion=2, controllerZkEpoch=3, controllerZkVersion=3&#125; (org.apache.kafka.metadata.migration.KRaftMigrationDriver)# ✅ 意味：迁移流程按预期推进：先把 KRaft 的元数据与 ZK 对齐（sync），然后与 brokers 建立通信，最终进入 DUAL_WRITE（双写）。DUAL_WRITE 阶段表示控制器在写入 KRaft metadata log 的同时，仍然会把必要的写操作也写回 ZooKeeper（双写）——直到迁移完全完成并确认可以停止写 ZK 为止。3000 transitioning from ZK_MIGRATION to SYNC_KRAFT_TO_ZK state...Performing a full metadata sync from KRaft to ZK.Did not make any ZK writes when reconciling with KRaft state.3000 transitioning ... to KRAFT_CONTROLLER_TO_BROKER_COMM...Sending RPCs to broker before moving to dual-write mode using at offset and epoch OffsetAndEpoch(offset=3179, epoch=2)...3000 transitioning ... to DUAL_WRITE state 上面的日志总体上表明，元数据迁移已成功完成并且控制器进入了双写（DUAL_WRITE）阶段。 将三个Broker节点的配置修改为 KRaft 模式的 broker 节点 修改三个节点的配置文件 server.properties 123456789101112131415# 添加process.roles=brokerprocess.roles=broker# 用 node.id 替换 broker.id，注意，node.id 需要与 broker.id 一致# broker.id=1node.id=1# 去掉 zookeeper 相关配置# Don&#x27;t set the IBP, KRaft uses &quot;metadata.version&quot; feature flag# inter.broker.protocol.version=3.9# Remove the migration enabled flag# zookeeper.metadata.migration.enable=true# Remove ZooKeeper client configuration# zookeeper.connect=worker1:2181,worker2:2181,worker3:2181 分别重新启动三个节点 1234567# 关闭 kafkakafka-server-stop.sh# 这里要注意 worker1 上不要使用 kafka-server-stop.sh 进行关闭，因为 worker1 上的 controller 节点 也在运行，会有两个 kafka 进程运行，可以用如下命令进行关闭；因为 controller 节点 启动使用的是 controller.propertiesps -ef | grep kafka | grep &quot;server\\.properties&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9# 重新启动 kafkakafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties 将 Controller 节点的配置修改为 KRaft 模式的 controller 节点 修改 controller 节点的配置文件 controller.properties 123456## 去掉去下内容# 控制是否启用 ZooKeeper → KRaft 的元数据迁移过程# zookeeper.metadata.migration.enable=true# ZooKeeper client 连接# zookeeper.connect=worker1:2181,worker2:2181,worker3:2181 重启启动 controller 节点 12# 关闭后重新启动kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties 此时你可以关闭 zookeeper 集群了，新的 kafka 集群将不再使用 ZooKeeper，也无法在恢复到 ZooKeeper 模式。 加入新的 Controller 节点 Controller 尽量保持 奇数个节点。 之前已经在 worker1 节点上启动了 controller ，现在 worker2 和 worker3 上也来启动 controller 节点，并将它们加入到 kafka 集群中。 在开始配置前，先将上面的 controller 节点 和 三个 broker 节点 的如下配置进行修改，并重启启动。 123456# 将 controller.quorum.bootstrap.servers 替换为 controller.quorum.voterscontroller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098# controller.quorum.bootstrap.servers=worker1:9098# controller.quorum.voters = 谁是正式投票成员（固定配置）# controller.quorum.bootstrap.servers = 临时找谁引导连接（迁移或初始化用） 配置项 作用 适用阶段 是否必需 说明 controller.quorum.voters 定义 正式的 KRaft 控制器投票成员列表（voter set） 集群正常运行时 ✅ 是 所有节点必须配置相同的值 controller.quorum.bootstrap.servers 定义 迁移阶段或初始化阶段的控制器连接地址（bootstrap controller endpoint） ZK → KRaft 迁移阶段 或 KRaft 集群初次启动 ⚙️ 可选（仅特定阶段） 用于在 controller quorum 尚未形成时的临时发现 参考 worker1 上的 controller 节点的配置文件 controller.properties，配置 woker2 的 controller 节点配置文件controller.properties ，worker3 也是类似的。 12345678910111213141516# 配置当前节点的角色，这里只能是controllerprocess.roles=controller# 节点ID，不能与现有Broker节点的ID一致node.id=3001# 配置集群的投票节点controller.quorum.voters=3000@worker1:9098,3001@worker2:9098,3002@worker3:9098# 配置监听器，注意端口不能重复listeners=CONTROLLER://:9098advertised.listeners=CONTROLLER://worker2:9098controller.listener.names=CONTROLLER# 日志存放目录，这里存放的是元数据log.dirs=/usr/local/kafka/dataDir/kraft-meta# 指定 Kafka 集群内部（broker 与 broker、KRaft 控制器与 broker）通信所使用的监听器（listener）名称。# 注意这里要与原先的 server.properties 中配置的监听器名称一致inter.broker.listener.name=PLAINTEXT 初始化日志目录 123# 只有 Controller 节点才需要初始化日志目录# -t 参数指定集群的 Cluster ID，就是前面获取的 Cluster IDkafka-storage.sh format -t hp_Q0pihQ0ORcIvXlfHobQ -c /usr/local/kafka/kafka3/config/kraft/controller.properties 分别启动 worker2 和 worker3 上的 controller 节点 1kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/controller.properties 此时新的 controller 节点不会立刻加入选举队列，新节点初始状态默认是 observer，需要执行下面的命令将节点加入选举队列 12# 分别在 worker2 和 worker3 上执行kafka-metadata-quorum.sh --bootstrap-server localhost:9092 --command-config /usr/local/kafka/kafka3/config/kraft/controller.properties add-controller 查看集群节点状态 123456789101112131415161718$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --replicationNodeId DirectoryId LogEndOffset Lag LastFetchTimestamp LastCaughtUpTimestamp Status3000 RJ4oOPGgTw-KxHFNn4SmiQ 27820 0 1760696136345 1760696136345 Leader3001 zGnWA7zYmRHG6bcTlFV2qA 27820 0 1760696136259 1760696136259 Follower3002 gIDkhOQJEHqg-GJBdezU1Q 27820 0 1760696136257 1760696136257 Follower2 9KeeAYKEQHT92DxqNSwYuA 27820 0 1760696136257 1760696136257 Observer1 Q8lr8JQ2vrDS35_DrI1MxA 27820 0 1760696136257 1760696136257 Observer3 rgQR5wd_i5hLgU97dCKIvA 27820 0 1760696136257 1760696136257 Observer$ kafka-metadata-quorum.sh --bootstrap-server worker1:9092 describe --statusClusterId: hp_Q0pihQ0ORcIvXlfHobQLeaderId: 3000LeaderEpoch: 5HighWatermark: 30094MaxFollowerLag: 0MaxFollowerLagTimeMs: 0CurrentVoters: [&#123;&quot;id&quot;: 3000, &quot;directoryId&quot;: &quot;RJ4oOPGgTw-KxHFNn4SmiQ&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker1:9098&quot;]&#125;, &#123;&quot;id&quot;: 3001, &quot;directoryId&quot;: &quot;zGnWA7zYmRHG6bcTlFV2qA&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker2:9098&quot;]&#125;, &#123;&quot;id&quot;: 3002, &quot;directoryId&quot;: &quot;gIDkhOQJEHqg-GJBdezU1Q&quot;, &quot;endpoints&quot;: [&quot;CONTROLLER://worker3:9098&quot;]&#125;]CurrentObservers: [&#123;&quot;id&quot;: 2, &quot;directoryId&quot;: &quot;9KeeAYKEQHT92DxqNSwYuA&quot;&#125;, &#123;&quot;id&quot;: 1, &quot;directoryId&quot;: &quot;Q8lr8JQ2vrDS35_DrI1MxA&quot;&#125;, &#123;&quot;id&quot;: 3, &quot;directoryId&quot;: &quot;rgQR5wd_i5hLgU97dCKIvA&quot;&#125;] 加入 新的 Broker 节点 创建新的 Broker 节点时，参考其它 Broker 节点 配置好配置文件 server.properties，并启动 Broker 节点即可。 无需运行日志目录初始化命令，因为 Broker 节点只存放 消息 数据。 迁移后注意事项 迁移完成后，Kafka 客户端（Producer / Consumer / AdminClient）依然连接的是 Broker 节点，而不是 Controller 节点。 Kafka 在 ZooKeeper 模式与 KRaft 模式下的区别主要在于： 控制平面（Control Plane）：ZK 模式下由 ZooKeeper + Controller Broker 共同管理；KRaft 模式下由 独立的 Controller 进程或角色 管理（通过 Raft 协议同步元数据）。 数据平面（Data Plane）：无论是哪个模式，客户端发送、消费消息仍然是通过 Broker 节点 完成的。 也就是说，Controller 管理集群元数据（主题、分区、副本、Leader 选举等），而 Broker 节点处理实际的消息流。","summary":"摘要 本文介绍 如何将 Kafka 集群从 Zookeeper 模式迁移到 KRaft 模式 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 官方文档：ZooKeeper到KRaft迁移","date_published":"2025-10-16T14:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/","url":"https://blog.hanqunfeng.com/2025/10/16/kafka-05-install-kraft/","title":"Kafka 的安装：基于 KRaft 模式","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"KRaft-简介\">KRaft 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kraft 是 Kafka 从 2.8.0 版本 开始⽀持的⼀种新的集群架构⽅式。其⽬的主要是为了摆脱Kafka对Zookeeper的依赖。因为以往基于Zookeeper搭建的集群，增加了Kafka演进与运维的难度，逐渐开始成为Kakfa拥抱云原⽣的⼀种障碍。使⽤Kraft集群后，Kafka集群就不再需要依赖Zookeeper，将之前基于Zookeeper管理的集群数据，转为由Kafka集群⾃⼰管理。</p>\n</li>\n<li class=\"lvl-2\">\n<p>传统的Kafka集群，会将每个节点的状态信息统一保存在Zookeeper中，并通过Zookeeper动态选举产生一个Controller节点，通过Controller节点来管理Kafka集群，比如触发Partition的选举。而在Kraft集群中，会固定配置几台Broker节点来共同担任Controller的角色，各组Partition的Leader节点就会由这些Controller选举产生。原本保存在Zookeeper中的元数据也转而保存到Controller节点中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>🧭 Kafka KRaft 模式 vs Zookeeper 模式 对比表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对比项</th>\n<th style=\"text-align:left\"><strong>KRaft 模式（Kafka Raft 模式）</strong></th>\n<th style=\"text-align:left\"><strong>Zookeeper 模式（传统模式）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>架构结构</strong></td>\n<td style=\"text-align:left\">去中心化架构，Kafka 自身内置控制平面，不依赖外部 Zookeeper。</td>\n<td style=\"text-align:left\">控制平面依赖外部 Zookeeper 集群，Kafka Broker 只负责数据平面。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>组件数量</strong></td>\n<td style=\"text-align:left\">无需部署 Zookeeper，只有 Kafka Broker 节点。</td>\n<td style=\"text-align:left\">需要单独维护 Zookeeper 集群。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>元数据存储</strong></td>\n<td style=\"text-align:left\">元数据存储在 Kafka 自身的内置日志中（<code>__cluster_metadata</code> topic）。</td>\n<td style=\"text-align:left\">元数据存储在 Zookeeper 的 znode 树结构中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>一致性协议</strong></td>\n<td style=\"text-align:left\">使用 Kafka 自己实现的 Raft 协议（KRaft）来保证元数据一致性。</td>\n<td style=\"text-align:left\">使用 ZAB（Zookeeper Atomic Broadcast）协议保证一致性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>启动速度</strong></td>\n<td style=\"text-align:left\">更快，控制器内嵌于 Broker 中，不需要等待外部 Zookeeper 启动。</td>\n<td style=\"text-align:left\">启动依赖 Zookeeper，启动顺序和连通性要求更严格。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>容错性</strong></td>\n<td style=\"text-align:left\">Raft 控制器具备日志复制机制，容错性与 Kafka 数据副本一致。</td>\n<td style=\"text-align:left\">容错性由 Zookeeper 决定，Zookeeper 挂掉可能导致 Kafka 控制面不可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>扩展性</strong></td>\n<td style=\"text-align:left\">元数据存储在 Kafka 主题中，水平扩展能力更强。</td>\n<td style=\"text-align:left\">Zookeeper 在高分区数场景下易成为性能瓶颈。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>运维复杂度</strong></td>\n<td style=\"text-align:left\">无需维护 Zookeeper 集群，统一运维 Kafka 即可。</td>\n<td style=\"text-align:left\">需要额外维护 Zookeeper 集群（监控、扩容、升级）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据恢复</strong></td>\n<td style=\"text-align:left\">元数据恢复与 Kafka 主题一致，可通过日志回放恢复。</td>\n<td style=\"text-align:left\">Zookeeper 数据恢复相对复杂，依赖快照和事务日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全机制</strong></td>\n<td style=\"text-align:left\">统一 Kafka 的安全机制（SASL、SSL、ACL 等）。</td>\n<td style=\"text-align:left\">Zookeeper 有独立的安全配置体系，需单独管理。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>性能表现</strong></td>\n<td style=\"text-align:left\">元数据操作延迟更低（控制器与 Broker 本地通信）。</td>\n<td style=\"text-align:left\">元数据操作需要跨进程网络通信，延迟更高。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>控制器角色</strong></td>\n<td style=\"text-align:left\">由 Broker 中的控制器 quorum 选举产生（支持多控制器候选）。</td>\n<td style=\"text-align:left\">由 Zookeeper 选举控制器（单点控制器）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>分区与副本管理</strong></td>\n<td style=\"text-align:left\">全部元数据存储在 Kafka 自身，可实现更快的分区变更和扩容。</td>\n<td style=\"text-align:left\">分区、副本元数据同步依赖 Zookeeper，性能相对较低。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>版本支持</strong></td>\n<td style=\"text-align:left\">从 Kafka 2.8 开始引入，Kafka 3.3+ 已经非常稳定，Kafka 3.5+ 默认推荐。</td>\n<td style=\"text-align:left\">Kafka 3.5 开始标记为“Legacy”，未来版本计划移除支持。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>兼容性</strong></td>\n<td style=\"text-align:left\">可通过元数据迁移工具从 Zookeeper 模式平滑迁移。</td>\n<td style=\"text-align:left\">不能直接迁移到 KRaft，需要工具辅助。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>运维监控</strong></td>\n<td style=\"text-align:left\">单一系统可监控（Kafka 自带的 JMX、Prometheus 等）。</td>\n<td style=\"text-align:left\">Kafka 与 Zookeeper 各自需要独立监控体系。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>未来发展方向</strong></td>\n<td style=\"text-align:left\">官方推荐和默认模式（Zookeeper 模式将逐步淘汰）。</td>\n<td style=\"text-align:left\">官方已不再建议新集群使用。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Kafka-的-KRaft-集群配置\">Kafka 的 KRaft 集群配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在Kafka的config目录下，提供了一个kraft的文件夹，在这里面提供了三个Kraft协议的参考配置文件</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">broker.properties: 数据节点，client连接时只连接broker数据节点</li>\n<li class=\"lvl-4\">controller.properties: Controller控制节点</li>\n<li class=\"lvl-4\">server.properties: 即可以是数据节点，又可以是Controller控制节点。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>实际上这些配置文件中的配置项基本与 serrver.properties 一致，只是去除了与 zookeeper 相关的配置项，同时增加了一些 Kraft 模式下的配置项。关于 server.properties 的配置项，请参考 <a href=\"https://kafka.apache.org/39/documentation/#brokerconfigs\">Kafka 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>这里以 <code>kraft/serrver.properties</code> 为例进行修改，配置三个节点的Kafka集群，每个节点即是 controller 节点，也可以是 broker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下面这四个配置项是 kraft 模式下新增加的</span></span><br><span class=\"line\"><span class=\"comment\"># 配置当前节点的角色。Controller相当于Zookeeper的功能，负责集群管理。Broker提供具体的消息转发服务。</span></span><br><span class=\"line\"><span class=\"comment\"># 一个节点可以即是 Controller 又是 Broker，也可以只是 Controller 或 Broker。</span></span><br><span class=\"line\">process.roles=broker,controller</span><br><span class=\"line\"><span class=\"comment\"># 配置当前节点的id。与普通集群一样，要求集群内每个节点的ID不能重复。</span></span><br><span class=\"line\">node.id=1</span><br><span class=\"line\"><span class=\"comment\"># 配置集群的投票节点。其中@前面的是节点的id，后面是节点的地址和端口，这个端口跟客户端访问的端口是不一样的，要与 CONTROLLER 协议对应的端口一致，这里配置为 9098</span></span><br><span class=\"line\"><span class=\"comment\"># 通常将集群内的所有Controllor节点都配置进去。</span></span><br><span class=\"line\">controller.quorum.voters=1@worker1:9098,2@worker2:9098,3@worker3:9098</span><br><span class=\"line\"><span class=\"comment\"># Controller服务协议的别名。默认就是CONTROLLER</span></span><br><span class=\"line\">controller.listener.names=CONTROLLER</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下配置项与之前一样，按需进行配置即可</span></span><br><span class=\"line\"><span class=\"comment\"># 集群间通信仍使用内网</span></span><br><span class=\"line\">inter.broker.listener.name=PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 配置监听服务。不同的服务可以绑定不同的接口。这种配置方式在端口前面是省略了一个主机IP的，主机IP默认是使用的java.net.InetAddress.getCanonicalHostName()，这里同时开启外网访问，关于 sasl_plaintext 、sasl_ssl协议 的配置方式参考前文 kafka 通信协议</span></span><br><span class=\"line\">listeners=PLAINTEXT://:9092,CONTROLLER://:9098,EXTERNAL://0.0.0.0:9093</span><br><span class=\"line\"><span class=\"comment\"># Broker对客户端暴露的服务地址。基于PLAINTEXT协议。这里要替换为各个节点的IP地址</span></span><br><span class=\"line\">advertised.listeners=PLAINTEXT://worker1:9092,CONTROLLER://worker1:9098,EXTERNAL://161.189.227.200:9093</span><br><span class=\"line\"><span class=\"comment\"># 将监听器名称映射到安全协议类型，这里 CONTROLLER 协议对应的安全协议类型为 PLAINTEXT</span></span><br><span class=\"line\">listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,EXTERNAL:PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 数据文件地址。默认配置在/tmp目录下。</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kraft-logs</span><br><span class=\"line\"><span class=\"comment\"># topic默认的partition分区数。</span></span><br><span class=\"line\">num.partitions=2</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动Kafka集群\">启动Kafka集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动前要对日志目录进行格式化</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在worker1节点上生成集群ID</span></span><br><span class=\"line\">$ kafka-storage.sh random-uuid</span><br><span class=\"line\">oGwJsVANRDKYwE7Lhn2zIA</span><br><span class=\"line\"><span class=\"comment\"># 然后在集群的每个节点上执行如下命令，格式化日志目录，注意 --cluster-id 必须一致</span></span><br><span class=\"line\"><span class=\"comment\"># 必须在第一次启动前执行</span></span><br><span class=\"line\"><span class=\"comment\"># 不可以重复执行，否则会清空数据目录并破坏已有元数据</span></span><br><span class=\"line\"><span class=\"comment\"># 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。</span></span><br><span class=\"line\"><span class=\"comment\"># 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。</span></span><br><span class=\"line\">$ kafka-storage.sh format --cluster-id oGwJsVANRDKYwE7Lhn2zIA --config /usr/local/kafka/kafka3/config/kraft/server.properties</span><br><span class=\"line\"><span class=\"comment\">## 格式化后会在日志目录下生成两个文件</span></span><br><span class=\"line\"><span class=\"comment\"># bootstrap.checkpoint # 存储元数据日志（Metadata Log）对应的初始快照偏移量（snapshot offset）。用于控制器在启动时恢复状态的起点。</span></span><br><span class=\"line\"><span class=\"comment\"># meta.properties # 存储节点元信息：cluster.id、node.id、version 等</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动集群，所以节点启动 kafka 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/server.properties</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\">注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 集群的启动顺序不能乱，必须先启动 Controller 节点，再启动 Broker 节点，我们这里是将节点同时做为Controller 和 Broker ，实际生产环境建议分开。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Controller 节点至少3个，建议配置为奇数个。Broker 节点数量任意，但建议至少2个以上，以保证分区的备份可以分开存储。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Client 仅能与 Broker 节点通信，不能与 Controller 节点通信。</p>\n</li>\n</ul>\n<h2 id=\"Kafka-4-0-的新特性\">Kafka 4.0 的新特性</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>彻底以 KRaft（Kafka Raft）取代 ZooKeeper（KRaft 成为默认且唯一的元数据管理）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：4.x 系列标志性变化是完全移除 ZooKeeper，元数据由 KRaft 管理（Controller 与 Broker 更紧密集成）。对运维而言：不再部署/维护 ZooKeeper 集群、元数据迁移/格式化步骤是升级时的关键。</li>\n<li class=\"lvl-4\">影响/提示：必须按官方迁移流程把元数据从 ZK 导入 KRaft（若从旧版本升级）。测试迁移/备份元数据是必须项。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>新的 consumer-group 协议（更高效的 rebalance/群组管理）与消费模型改进（包括“Queues/Shared Group”支持）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：引入/稳定了新的 Consumer Group 协议（相关 KIP），显著改善大群组下的重平衡延迟与稳定性；同时引入了类似“队列/共享组（Queues for Kafka）”的消费模式（用例：点对点消费），允许多消费者同时处理同一分区消息。</li>\n<li class=\"lvl-4\">影响/提示：如果你有大规模消费者群组或依赖旧 rebalance 行为，需要测试新协议行为；某些客户端配置/行为可能需要调整。</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标类别</th>\n<th>旧协议（Eager Rebalance）</th>\n<th>新协议（Incremental / Cooperative Rebalance）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重平衡延迟（大规模群组）</td>\n<td>约 <strong>60 秒</strong>（万级消费者规模）</td>\n<td>小于 <strong>1 秒</strong>（测试显示在千级任务时可在一分钟内完成） (<a href=\"https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/?utm_source=chatgpt.com\" title=\"Incremental Cooperative Rebalancing in Apache Kafka\">Confluent</a>)</td>\n</tr>\n<tr>\n<td>资源消耗（CPU）</td>\n<td>较高（在重平衡期间系统停止或大规模迁移资源）</td>\n<td>据称可降低约 <strong>70%</strong> 的 CPU／系统中断负荷（社区经验）</td>\n</tr>\n<tr>\n<td>消费者群组扩展上限</td>\n<td>适用于“千级消费者”规模</td>\n<td>可扩展至“十万级消费者”规模（理论/社区宣称）</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>传统消费者组（Consumer Group）</strong></th>\n<th><strong>共享组（Shared Group / Queues for Kafka）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>并行消费模型</strong></td>\n<td>分区数 = 消费者数（一个分区只能被一个消费者消费）</td>\n<td>消费者数 &gt; 分区数（同一分区可由多个消费者并行处理）</td>\n</tr>\n<tr>\n<td><strong>消息确认机制</strong></td>\n<td>通过提交偏移量（Offset Commit）实现确认</td>\n<td>每条消息单独确认（ACK/NACK 机制）</td>\n</tr>\n<tr>\n<td><strong>投递语义</strong></td>\n<td><strong>At-Least-Once</strong>（至少一次投递）</td>\n<td><strong>Exactly-Once（可选）</strong>，支持精确一次处理</td>\n</tr>\n<tr>\n<td><strong>典型场景</strong></td>\n<td>流式日志、监控、顺序性要求高的场景</td>\n<td>任务队列、并行计算、高吞吐任务处理</td>\n</tr>\n<tr>\n<td><strong>实现方式</strong></td>\n<td>基于 Topic-Partition 分配与偏移管理</td>\n<td>基于共享队列模型，允许多消费者竞争消费同一分区</td>\n</tr>\n<tr>\n<td><strong>Kafka 版本支持</strong></td>\n<td>Kafka ≤ 3.x</td>\n<td>Kafka 4.x 引入（KIP-932 “Queues for Kafka”）</td>\n</tr>\n<tr>\n<td><strong>优势</strong></td>\n<td>顺序保证强、模型成熟稳定</td>\n<td>并行能力强、吞吐提升、支持精确一次语义</td>\n</tr>\n<tr>\n<td><strong>劣势</strong></td>\n<td>分区限制吞吐，扩展受限</td>\n<td>顺序性可能减弱，实现更复杂</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除长期弃用的旧 API / 协议（向后不兼容的清理）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：4.x 移除了那些已弃用 ≥12 个月的接口/协议，旨在简化代码库并鼓励采用新功能。</li>\n<li class=\"lvl-4\">影响/提示：升级前务必检查你使用到的 Broker/Client/Streams/Connect API 是否依赖被移除的功能；测试客户端与第三方 Connector/插件兼容性。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Java 运行环境最低版本更新：Clients/Streams 与 Broker/Tools 的 JDK 要求提高</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：Kafka 4.x 将客户端（Kafka Clients、Kafka Streams）与 Broker/Connect/工具分别提出了更高的 Java baseline（Clients/Streams 最低 Java 11，Broker/Connect/Tools 最低 Java 17 等）。</li>\n<li class=\"lvl-4\">影响/提示：升级集群前先统一平台 JDK 版本，CI/CD/容器镜像也要对应更新。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>许多新的 KIP（功能增强）与性能/可观测性改进</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">说明：包含改进的 Streams rebalance、更多 Admin/运维命令、节点注册/列举能力、插件/指标扩展点等（多项 KIP 在 4.0/4.1 陆续落地）。这些改进覆盖 Broker、Controller、Producer、Consumer、Admin 和 Streams 子系统。</li>\n<li class=\"lvl-4\">影响/提示：运维与监控面板可能受益（新增可观测指标/API）；如果你有自定义插件或监控接入，需要检查新的插件/metrics 注册机制。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。 KRaft 简介 Kraft 是 Kafka 从 2.8.0 版本 开始⽀持的⼀种新的集群架构⽅式。其⽬的主要是为了摆脱Kafka对Zookeeper的依赖。因为以往基于Zookeeper搭建的集群，增加了Kafka演进与运维的难度，逐渐开始成为Kakfa拥抱云原⽣的⼀种障碍。使⽤Kraft集群后，Kafka集群就不再需要依赖Zookeeper，将之前基于Zookeeper管理的集群数据，转为由Kafka集群⾃⼰管理。 传统的Kafka集群，会将每个节点的状态信息统一保存在Zookeeper中，并通过Zookeeper动态选举产生一个Controller节点，通过Controller节点来管理Kafka集群，比如触发Partition的选举。而在Kraft集群中，会固定配置几台Broker节点来共同担任Controller的角色，各组Partition的Leader节点就会由这些Controller选举产生。原本保存在Zookeeper中的元数据也转而保存到Controller节点中。 🧭 Kafka KRaft 模式 vs Zookeeper 模式 对比表 对比项 KRaft 模式（Kafka Raft 模式） Zookeeper 模式（传统模式） 架构结构 去中心化架构，Kafka 自身内置控制平面，不依赖外部 Zookeeper。 控制平面依赖外部 Zookeeper 集群，Kafka Broker 只负责数据平面。 组件数量 无需部署 Zookeeper，只有 Kafka Broker 节点。 需要单独维护 Zookeeper 集群。 元数据存储 元数据存储在 Kafka 自身的内置日志中（__cluster_metadata topic）。 元数据存储在 Zookeeper 的 znode 树结构中。 一致性协议 使用 Kafka 自己实现的 Raft 协议（KRaft）来保证元数据一致性。 使用 ZAB（Zookeeper Atomic Broadcast）协议保证一致性。 启动速度 更快，控制器内嵌于 Broker 中，不需要等待外部 Zookeeper 启动。 启动依赖 Zookeeper，启动顺序和连通性要求更严格。 容错性 Raft 控制器具备日志复制机制，容错性与 Kafka 数据副本一致。 容错性由 Zookeeper 决定，Zookeeper 挂掉可能导致 Kafka 控制面不可用。 扩展性 元数据存储在 Kafka 主题中，水平扩展能力更强。 Zookeeper 在高分区数场景下易成为性能瓶颈。 运维复杂度 无需维护 Zookeeper 集群，统一运维 Kafka 即可。 需要额外维护 Zookeeper 集群（监控、扩容、升级）。 数据恢复 元数据恢复与 Kafka 主题一致，可通过日志回放恢复。 Zookeeper 数据恢复相对复杂，依赖快照和事务日志。 安全机制 统一 Kafka 的安全机制（SASL、SSL、ACL 等）。 Zookeeper 有独立的安全配置体系，需单独管理。 性能表现 元数据操作延迟更低（控制器与 Broker 本地通信）。 元数据操作需要跨进程网络通信，延迟更高。 控制器角色 由 Broker 中的控制器 quorum 选举产生（支持多控制器候选）。 由 Zookeeper 选举控制器（单点控制器）。 分区与副本管理 全部元数据存储在 Kafka 自身，可实现更快的分区变更和扩容。 分区、副本元数据同步依赖 Zookeeper，性能相对较低。 版本支持 从 Kafka 2.8 开始引入，Kafka 3.3+ 已经非常稳定，Kafka 3.5+ 默认推荐。 Kafka 3.5 开始标记为“Legacy”，未来版本计划移除支持。 兼容性 可通过元数据迁移工具从 Zookeeper 模式平滑迁移。 不能直接迁移到 KRaft，需要工具辅助。 运维监控 单一系统可监控（Kafka 自带的 JMX、Prometheus 等）。 Kafka 与 Zookeeper 各自需要独立监控体系。 未来发展方向 官方推荐和默认模式（Zookeeper 模式将逐步淘汰）。 官方已不再建议新集群使用。 Kafka 的 KRaft 集群配置 在Kafka的config目录下，提供了一个kraft的文件夹，在这里面提供了三个Kraft协议的参考配置文件 broker.properties: 数据节点，client连接时只连接broker数据节点 controller.properties: Controller控制节点 server.properties: 即可以是数据节点，又可以是Controller控制节点。 实际上这些配置文件中的配置项基本与 serrver.properties 一致，只是去除了与 zookeeper 相关的配置项，同时增加了一些 Kraft 模式下的配置项。关于 server.properties 的配置项，请参考 Kafka 官方文档 这里以 kraft/serrver.properties 为例进行修改，配置三个节点的Kafka集群，每个节点即是 controller 节点，也可以是 broker 节点 12345678910111213141516171819202122232425# 下面这四个配置项是 kraft 模式下新增加的# 配置当前节点的角色。Controller相当于Zookeeper的功能，负责集群管理。Broker提供具体的消息转发服务。# 一个节点可以即是 Controller 又是 Broker，也可以只是 Controller 或 Broker。process.roles=broker,controller# 配置当前节点的id。与普通集群一样，要求集群内每个节点的ID不能重复。node.id=1# 配置集群的投票节点。其中@前面的是节点的id，后面是节点的地址和端口，这个端口跟客户端访问的端口是不一样的，要与 CONTROLLER 协议对应的端口一致，这里配置为 9098# 通常将集群内的所有Controllor节点都配置进去。controller.quorum.voters=1@worker1:9098,2@worker2:9098,3@worker3:9098# Controller服务协议的别名。默认就是CONTROLLERcontroller.listener.names=CONTROLLER# 以下配置项与之前一样，按需进行配置即可# 集群间通信仍使用内网inter.broker.listener.name=PLAINTEXT# 配置监听服务。不同的服务可以绑定不同的接口。这种配置方式在端口前面是省略了一个主机IP的，主机IP默认是使用的java.net.InetAddress.getCanonicalHostName()，这里同时开启外网访问，关于 sasl_plaintext 、sasl_ssl协议 的配置方式参考前文 kafka 通信协议listeners=PLAINTEXT://:9092,CONTROLLER://:9098,EXTERNAL://0.0.0.0:9093# Broker对客户端暴露的服务地址。基于PLAINTEXT协议。这里要替换为各个节点的IP地址advertised.listeners=PLAINTEXT://worker1:9092,CONTROLLER://worker1:9098,EXTERNAL://161.189.227.200:9093# 将监听器名称映射到安全协议类型，这里 CONTROLLER 协议对应的安全协议类型为 PLAINTEXTlistener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL,EXTERNAL:PLAINTEXT# 数据文件地址。默认配置在/tmp目录下。log.dirs=/usr/local/kafka/dataDir/kraft-logs# topic默认的partition分区数。num.partitions=2 启动Kafka集群 启动前要对日志目录进行格式化 123456789101112# 在worker1节点上生成集群ID$ kafka-storage.sh random-uuidoGwJsVANRDKYwE7Lhn2zIA# 然后在集群的每个节点上执行如下命令，格式化日志目录，注意 --cluster-id 必须一致# 必须在第一次启动前执行# 不可以重复执行，否则会清空数据目录并破坏已有元数据# 千万不要在已有 broker 的数据目录（包含消息数据的 log.dirs）上运行 kafka-storage.sh format ，那会把原有数据结构重置或踩坏。# 必须明确：格式化只针对 新 controller 的 metadata 目录（且该目录必须为空）。$ kafka-storage.sh format --cluster-id oGwJsVANRDKYwE7Lhn2zIA --config /usr/local/kafka/kafka3/config/kraft/server.properties## 格式化后会在日志目录下生成两个文件# bootstrap.checkpoint # 存储元数据日志（Metadata Log）对应的初始快照偏移量（snapshot offset）。用于控制器在启动时恢复状态的起点。# meta.properties # 存储节点元信息：cluster.id、node.id、version 等 启动集群，所以节点启动 kafka 服务 1kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/kraft/server.properties 注意事项 Kafka 集群的启动顺序不能乱，必须先启动 Controller 节点，再启动 Broker 节点，我们这里是将节点同时做为Controller 和 Broker ，实际生产环境建议分开。 Controller 节点至少3个，建议配置为奇数个。Broker 节点数量任意，但建议至少2个以上，以保证分区的备份可以分开存储。 Client 仅能与 Broker 节点通信，不能与 Controller 节点通信。 Kafka 4.0 的新特性 彻底以 KRaft（Kafka Raft）取代 ZooKeeper（KRaft 成为默认且唯一的元数据管理） 说明：4.x 系列标志性变化是完全移除 ZooKeeper，元数据由 KRaft 管理（Controller 与 Broker 更紧密集成）。对运维而言：不再部署/维护 ZooKeeper 集群、元数据迁移/格式化步骤是升级时的关键。 影响/提示：必须按官方迁移流程把元数据从 ZK 导入 KRaft（若从旧版本升级）。测试迁移/备份元数据是必须项。 新的 consumer-group 协议（更高效的 rebalance/群组管理）与消费模型改进（包括“Queues/Shared Group”支持） 说明：引入/稳定了新的 Consumer Group 协议（相关 KIP），显著改善大群组下的重平衡延迟与稳定性；同时引入了类似“队列/共享组（Queues for Kafka）”的消费模式（用例：点对点消费），允许多消费者同时处理同一分区消息。 影响/提示：如果你有大规模消费者群组或依赖旧 rebalance 行为，需要测试新协议行为；某些客户端配置/行为可能需要调整。 指标类别 旧协议（Eager Rebalance） 新协议（Incremental / Cooperative Rebalance） 重平衡延迟（大规模群组） 约 60 秒（万级消费者规模） 小于 1 秒（测试显示在千级任务时可在一分钟内完成） (Confluent) 资源消耗（CPU） 较高（在重平衡期间系统停止或大规模迁移资源） 据称可降低约 70% 的 CPU／系统中断负荷（社区经验） 消费者群组扩展上限 适用于“千级消费者”规模 可扩展至“十万级消费者”规模（理论/社区宣称） 特性 传统消费者组（Consumer Group） 共享组（Shared Group / Queues for Kafka） 并行消费模型 分区数 = 消费者数（一个分区只能被一个消费者消费） 消费者数 &gt; 分区数（同一分区可由多个消费者并行处理） 消息确认机制 通过提交偏移量（Offset Commit）实现确认 每条消息单独确认（ACK/NACK 机制） 投递语义 At-Least-Once（至少一次投递） Exactly-Once（可选），支持精确一次处理 典型场景 流式日志、监控、顺序性要求高的场景 任务队列、并行计算、高吞吐任务处理 实现方式 基于 Topic-Partition 分配与偏移管理 基于共享队列模型，允许多消费者竞争消费同一分区 Kafka 版本支持 Kafka ≤ 3.x Kafka 4.x 引入（KIP-932 “Queues for Kafka”） 优势 顺序保证强、模型成熟稳定 并行能力强、吞吐提升、支持精确一次语义 劣势 分区限制吞吐，扩展受限 顺序性可能减弱，实现更复杂 删除长期弃用的旧 API / 协议（向后不兼容的清理） 说明：4.x 移除了那些已弃用 ≥12 个月的接口/协议，旨在简化代码库并鼓励采用新功能。 影响/提示：升级前务必检查你使用到的 Broker/Client/Streams/Connect API 是否依赖被移除的功能；测试客户端与第三方 Connector/插件兼容性。 Java 运行环境最低版本更新：Clients/Streams 与 Broker/Tools 的 JDK 要求提高 说明：Kafka 4.x 将客户端（Kafka Clients、Kafka Streams）与 Broker/Connect/工具分别提出了更高的 Java baseline（Clients/Streams 最低 Java 11，Broker/Connect/Tools 最低 Java 17 等）。 影响/提示：升级集群前先统一平台 JDK 版本，CI/CD/容器镜像也要对应更新。 许多新的 KIP（功能增强）与性能/可观测性改进 说明：包含改进的 Streams rebalance、更多 Admin/运维命令、节点注册/列举能力、插件/指标扩展点等（多项 KIP 在 4.0/4.1 陆续落地）。这些改进覆盖 Broker、Controller、Producer、Consumer、Admin 和 Streams 子系统。 影响/提示：运维与监控面板可能受益（新增可观测指标/API）；如果你有自定义插件或监控接入，需要检查新的插件/metrics 注册机制。","summary":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 KRaft 模式。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 本文的安装方法同样适用于 Kafka 4.x 版本，只不过 Kafka 4.x 中已经不再包含 ZooKeeper 相关的配置文件以及相关的命令，另外要求JDK17+。","date_published":"2025-10-16T13:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/","url":"https://blog.hanqunfeng.com/2025/10/15/kafka-04-command/","title":"Kafka 的 常用命令","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Kafka 的 常用命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/kafka-3-demo\">Java-Client 代码示例</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"topic\">topic</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 topic</span></span><br><span class=\"line\">kafka-topics.sh --create --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --partitions 3 --replication-factor 2</span><br><span class=\"line\"><span class=\"comment\"># --bootstrap-server 指定 kafka 集群地址</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 创建的 topic 名称</span></span><br><span class=\"line\"><span class=\"comment\"># --partitions 指定分区数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class=\"line\"><span class=\"comment\"># --replication-factor 指定副本数，不设置则默认使用 server.properties 中设置的默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出 topic</span></span><br><span class=\"line\">kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class=\"line\"><span class=\"comment\"># 查看 topic 详情</span></span><br><span class=\"line\">kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Topic: <span class=\"built_in\">test</span>\tTopicId: Ru0tWQJ4RMWcjjGsKAdWQg\tPartitionCount: 3\tReplicationFactor: 3\tConfigs:</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 0\tLeader: 3\tReplicas: 3,1,2\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 1\tLeader: 1\tReplicas: 1,2,3\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: <span class=\"built_in\">test</span>\tPartition: 2\tLeader: 2\tReplicas: 2,3,1\tIsr: 3,2,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\"><span class=\"comment\">## 输出说明</span></span><br><span class=\"line\"><span class=\"comment\"># 总体信息（Topic 概览）Topic: test\tTopicId: Ru0tWQJ4RMWcjjGsKAdWQg\tPartitionCount: 3\tReplicationFactor: 3\tConfigs:</span></span><br><span class=\"line\">| 字段                                  | 含义                                                            |</span><br><span class=\"line\">| ----------------------------------- | ------------------------------------------------------------- |</span><br><span class=\"line\">| **Topic: disTopic**                 | Topic 名称，即当前描述的主题。                                            |</span><br><span class=\"line\">| **TopicId: VUK7Mc9oQdS1mjGG7OhQzQ** | Kafka 内部自动生成的唯一标识符（UUID），Kafka 3.x 之后引入，用于区分同名但不同生命周期的 topic。 |</span><br><span class=\"line\">| **PartitionCount: 3**               | 该主题有 3 个分区（partition）。每个分区存储一部分消息。                            |</span><br><span class=\"line\">| **ReplicationFactor:**              | 副本因子。这里虽然输出中没显示具体值，但可从每行分区配置推断是 **3**（每个分区有 3 个副本）。           |</span><br><span class=\"line\">| **Configs:**                        | topic 的配置项（例如清理策略、压缩类型等），如果为空，说明使用默认配置。                       |</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分区详情（每个 Partition 一行）</span></span><br><span class=\"line\"></span><br><span class=\"line\">| 字段                                | 含义                                                          |</span><br><span class=\"line\">| --------------------------------- | ----------------------------------------------------------- |</span><br><span class=\"line\">| **Partition: 0**                  | 第 0 号分区。                                                    |</span><br><span class=\"line\">| **Leader: 2**                     | 该分区当前的 **Leader Broker 是 broker ID = 2**，只有 Leader 才处理读写请求。 |</span><br><span class=\"line\">| **Replicas: 2,3,1**               | 该分区的所有副本存放在哪些 Broker 上（即副本分布,AR），分别是 broker 2、3、1。             |</span><br><span class=\"line\">| **Isr (In-Sync Replicas): 2,3,1** | 当前与 Leader 保持同步的副本集合。这里所有副本都在同步中（健康状态 👍）。                  |</span><br><span class=\"line\">| **Elr / LastKnownElr**            | Kafka 新版本中引入的 <span class=\"string\">&quot;Enhanced Leader Replica&quot;</span> 状态，目前未启用（N/A）。      |</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 topic</span></span><br><span class=\"line\">kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"consumer\">consumer</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 consumer</span></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --group <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 指定 topic</span></span><br><span class=\"line\"><span class=\"comment\"># --group 指定 consumer 组</span></span><br><span class=\"line\"></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span>  --from-beginning</span><br><span class=\"line\"><span class=\"comment\"># --from-beginning 从 topic 的最开始消费</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"consumer-group\">consumer-group</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出 consumer 组</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class=\"line\"><span class=\"comment\"># --bootstrap-server 集群地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 consumer 组详情</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">GROUP  TOPIC  PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG  CONSUMER-ID                                             HOST         CLIENT-ID</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   0          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   1          2               2               0    console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1  /10.250.0.7   console-consumer</span><br><span class=\"line\"><span class=\"built_in\">test</span>   <span class=\"built_in\">test</span>   2          1               1               0    console-consumer-9ac45b29-d8f3-4649-ab09-7b567aa2ba53  /10.250.0.108 console-consumer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 输出说明</span></span><br><span class=\"line\"><span class=\"comment\"># GROUP       消费组名称</span></span><br><span class=\"line\"><span class=\"comment\"># TOPIC       topic 名称</span></span><br><span class=\"line\"><span class=\"comment\"># PARTITION   分区编号</span></span><br><span class=\"line\"><span class=\"comment\"># CURRENT-OFFSET  当前消费的 offset</span></span><br><span class=\"line\"><span class=\"comment\"># LOG-END-OFFSET   topic 中最大的 offset</span></span><br><span class=\"line\"><span class=\"comment\"># LAG         当前消费的 offset 与 topic 中最大的 offset 的差值，即剩余未消费的 消息数量</span></span><br><span class=\"line\"><span class=\"comment\"># CONSUMER-ID  当前消费的 consumer 的 id</span></span><br><span class=\"line\"><span class=\"comment\"># HOST        当前消费的 consumer 的主机名</span></span><br><span class=\"line\"><span class=\"comment\"># CLIENT-ID   当前消费的 consumer 的客户端名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 consumer 组</span></span><br><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"producer\">producer</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 producer</span></span><br><span class=\"line\">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># --topic 指定 topic</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"手动触发-Kafka-Partitoin-的-Leader-选举-自平衡\">手动触发 Kafka Partitoin 的 Leader 选举(自平衡)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>kafka的自平衡默认开启，每隔 300秒扫描一次，如果需要平衡的比例高于 10%，则会触发一次</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启自动平衡</span></span><br><span class=\"line\">auto.leader.rebalance.enable=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 间隔扫描时间 默认 300 秒</span></span><br><span class=\"line\">eader.imbalance.check.interval.seconds=300</span><br><span class=\"line\"><span class=\"comment\"># 触发比例，即扫描的 broker 上需要平衡的 partition 占当前 broker 全部 partition 的比例，默认 10%</span></span><br><span class=\"line\">leader.imbalance.per.broker.percentage=10</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>建议关闭，改为业务低峰时手动触发</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动平衡</span></span><br><span class=\"line\">kafka-leader-election.sh --bootstrap-server localhost:9092  --election-type preferred --topic <span class=\"built_in\">test</span> --partition 0</span><br><span class=\"line\"><span class=\"comment\"># --topic 指定要触发的 topic</span></span><br><span class=\"line\"><span class=\"comment\"># --partition 0 触发 partition 0 的 leader 选举</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>🧩 参数说明：–election-type</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数值</th>\n<th>含义</th>\n<th>触发条件</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>preferred</code></strong></td>\n<td><strong>首选 Leader 选举</strong>（Preferred Leader Election）<br>Kafka 会尝试将分区的 leader 重新切换为「首选副本」（通常是第一个副本）。</td>\n<td>只有当前 leader <strong>不是</strong> 首选副本时才执行。</td>\n<td>某些副本被自动选举成 leader 后，希望恢复原有「首选 leader」结构，以实现负载均衡。</td>\n</tr>\n<tr>\n<td><strong><code>unclean</code></strong></td>\n<td><strong>非干净 Leader 选举</strong>（Unclean Leader Election）<br>允许从不同步的副本中选举新的 leader。</td>\n<td>仅在分区 <strong>没有可用 leader</strong> 时执行。</td>\n<td>在紧急恢复场景下（比如所有 ISR 副本都下线），为了恢复服务可用性，即使会导致数据丢失。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Leader Partition⾃动平衡机制</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Leader Partitoin选举机制能够保证每⼀个Partition同⼀时刻有且仅有⼀个Leader Partition。但是，是不是只要分配好了Leader Partition就够了呢？</li>\n<li class=\"lvl-6\">在⼀组Partiton中，Leader Partition通常是⽐较繁忙的节点，因为他要负责与客户端的数据交互，以及向Follower同步数据。默认情况下，Kafka会尽量将Leader Partition分配到不同的Broker节点上，⽤以保证整个集群的性能压⼒能够⽐较平均。</li>\n<li class=\"lvl-6\">但是，经过Leader Partition选举后，这种平衡就有可能会被打破，让Leader Partition过多的集中到同⼀个Broker上。这样，这个Broker的压⼒就会明显⾼于其他Broker，从⽽影响到集群的整体性能。</li>\n<li class=\"lvl-6\">为此，Kafka设计了Leader Partition⾃动平衡机制，当发现Leader分配不均衡时，⾃动进⾏Leader Partition调整。</li>\n<li class=\"lvl-6\">Kafka在进⾏Leader Partition⾃平衡时的逻辑是这样的：他会认为AR(Replicas副本集)当中的第⼀个节点就应该是Leader节点。这种选举结果成为preferred election 理想选举结果。</li>\n<li class=\"lvl-6\">Controller会定期检测集群的Partition平衡情况，在开始检测时，Controller会依次检查所有的Broker。当发现这个Broker上的不平衡的Partition⽐例⾼于<code>leader.imbalance.per.broker.percentage</code>阈值时，就会触发⼀次Leader Partiton的⾃平衡。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Kafka 的 常用命令 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Java-Client 代码示例 topic 12345678910111213141516171819202122232425262728293031323334353637383940# 创建 topickafka-topics.sh --create --bootstrap-server localhost:9092 --topic test --partitions 3 --replication-factor 2# --bootstrap-server 指定 kafka 集群地址# --topic 创建的 topic 名称# --partitions 指定分区数，不设置则默认使用 server.properties 中设置的默认值# --replication-factor 指定副本数，不设置则默认使用 server.properties 中设置的默认值# 列出 topickafka-topics.sh --list --bootstrap-server localhost:9092# 查看 topic 详情kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test## 输出Topic: test TopicId: Ru0tWQJ4RMWcjjGsKAdWQg PartitionCount: 3 ReplicationFactor: 3 Configs: Topic: test Partition: 0 Leader: 3 Replicas: 3,1,2 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A Topic: test Partition: 1 Leader: 1 Replicas: 1,2,3 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A Topic: test Partition: 2 Leader: 2 Replicas: 2,3,1 Isr: 3,2,1 Elr: N/A LastKnownElr: N/A## 输出说明# 总体信息（Topic 概览）Topic: test TopicId: Ru0tWQJ4RMWcjjGsKAdWQg PartitionCount: 3 ReplicationFactor: 3 Configs:| 字段 | 含义 || ----------------------------------- | ------------------------------------------------------------- || **Topic: disTopic** | Topic 名称，即当前描述的主题。 || **TopicId: VUK7Mc9oQdS1mjGG7OhQzQ** | Kafka 内部自动生成的唯一标识符（UUID），Kafka 3.x 之后引入，用于区分同名但不同生命周期的 topic。 || **PartitionCount: 3** | 该主题有 3 个分区（partition）。每个分区存储一部分消息。 || **ReplicationFactor:** | 副本因子。这里虽然输出中没显示具体值，但可从每行分区配置推断是 **3**（每个分区有 3 个副本）。 || **Configs:** | topic 的配置项（例如清理策略、压缩类型等），如果为空，说明使用默认配置。 |# 分区详情（每个 Partition 一行）| 字段 | 含义 || --------------------------------- | ----------------------------------------------------------- || **Partition: 0** | 第 0 号分区。 || **Leader: 2** | 该分区当前的 **Leader Broker 是 broker ID = 2**，只有 Leader 才处理读写请求。 || **Replicas: 2,3,1** | 该分区的所有副本存放在哪些 Broker 上（即副本分布,AR），分别是 broker 2、3、1。 || **Isr (In-Sync Replicas): 2,3,1** | 当前与 Leader 保持同步的副本集合。这里所有副本都在同步中（健康状态 👍）。 || **Elr / LastKnownElr** | Kafka 新版本中引入的 &quot;Enhanced Leader Replica&quot; 状态，目前未启用（N/A）。 |# 删除 topickafka-topics.sh --delete --bootstrap-server localhost:9092 --topic test consumer 1234567# 创建 consumerkafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --group test# --topic 指定 topic# --group 指定 consumer 组kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning# --from-beginning 从 topic 的最开始消费 consumer-group 12345678910111213141516171819202122232425# 列出 consumer 组kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list# --bootstrap-server 集群地址# 查看 consumer 组详情kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group test## 输出GROUP TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST CLIENT-IDtest test 0 2 2 0 console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1 /10.250.0.7 console-consumertest test 1 2 2 0 console-consumer-2102b86e-895c-4ee3-8304-6df83523d1c1 /10.250.0.7 console-consumertest test 2 1 1 0 console-consumer-9ac45b29-d8f3-4649-ab09-7b567aa2ba53 /10.250.0.108 console-consumer## 输出说明# GROUP 消费组名称# TOPIC topic 名称# PARTITION 分区编号# CURRENT-OFFSET 当前消费的 offset# LOG-END-OFFSET topic 中最大的 offset# LAG 当前消费的 offset 与 topic 中最大的 offset 的差值，即剩余未消费的 消息数量# CONSUMER-ID 当前消费的 consumer 的 id# HOST 当前消费的 consumer 的主机名# CLIENT-ID 当前消费的 consumer 的客户端名称# 删除 consumer 组kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group test producer 123# 创建 producerkafka-console-producer.sh --bootstrap-server localhost:9092 --topic test# --topic 指定 topic 手动触发 Kafka Partitoin 的 Leader 选举(自平衡) kafka的自平衡默认开启，每隔 300秒扫描一次，如果需要平衡的比例高于 10%，则会触发一次 123456# 开启自动平衡auto.leader.rebalance.enable=true# 间隔扫描时间 默认 300 秒eader.imbalance.check.interval.seconds=300# 触发比例，即扫描的 broker 上需要平衡的 partition 占当前 broker 全部 partition 的比例，默认 10%leader.imbalance.per.broker.percentage=10 建议关闭，改为业务低峰时手动触发 1234# 自动平衡kafka-leader-election.sh --bootstrap-server localhost:9092 --election-type preferred --topic test --partition 0# --topic 指定要触发的 topic# --partition 0 触发 partition 0 的 leader 选举 🧩 参数说明：–election-type 参数值 含义 触发条件 典型使用场景 preferred 首选 Leader 选举（Preferred Leader Election）Kafka 会尝试将分区的 leader 重新切换为「首选副本」（通常是第一个副本）。 只有当前 leader 不是 首选副本时才执行。 某些副本被自动选举成 leader 后，希望恢复原有「首选 leader」结构，以实现负载均衡。 unclean 非干净 Leader 选举（Unclean Leader Election）允许从不同步的副本中选举新的 leader。 仅在分区 没有可用 leader 时执行。 在紧急恢复场景下（比如所有 ISR 副本都下线），为了恢复服务可用性，即使会导致数据丢失。 Leader Partition⾃动平衡机制 Leader Partitoin选举机制能够保证每⼀个Partition同⼀时刻有且仅有⼀个Leader Partition。但是，是不是只要分配好了Leader Partition就够了呢？ 在⼀组Partiton中，Leader Partition通常是⽐较繁忙的节点，因为他要负责与客户端的数据交互，以及向Follower同步数据。默认情况下，Kafka会尽量将Leader Partition分配到不同的Broker节点上，⽤以保证整个集群的性能压⼒能够⽐较平均。 但是，经过Leader Partition选举后，这种平衡就有可能会被打破，让Leader Partition过多的集中到同⼀个Broker上。这样，这个Broker的压⼒就会明显⾼于其他Broker，从⽽影响到集群的整体性能。 为此，Kafka设计了Leader Partition⾃动平衡机制，当发现Leader分配不均衡时，⾃动进⾏Leader Partition调整。 Kafka在进⾏Leader Partition⾃平衡时的逻辑是这样的：他会认为AR(Replicas副本集)当中的第⼀个节点就应该是Leader节点。这种选举结果成为preferred election 理想选举结果。 Controller会定期检测集群的Partition平衡情况，在开始检测时，Controller会依次检查所有的Broker。当发现这个Broker上的不平衡的Partition⽐例⾼于leader.imbalance.per.broker.percentage阈值时，就会触发⼀次Leader Partiton的⾃平衡。","summary":"摘要 本文介绍 Kafka 的 常用命令 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Java-Client 代码示例","date_published":"2025-10-15T12:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/14/kafka-01-server-config/","url":"https://blog.hanqunfeng.com/2025/10/14/kafka-01-server-config/","title":"Kafka 的 server.properties 配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 Kafka 的 server.properties 的配置项，基于 Zookeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Kafka-3-x-server-properties-主要配置项清单\">Kafka 3.x server.properties 主要配置项清单</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于 server.properties 的配置项，请参考 <a href=\"https://kafka.apache.org/39/documentation/#brokerconfigs\">Kafka 官方文档</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>参数名</th>\n<th>默认值</th>\n<th>说明</th>\n<th>推荐/备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🗂️ <strong>基本信息</strong></td>\n<td><code>broker.id</code></td>\n<td>0</td>\n<td>Broker 唯一标识</td>\n<td>集群中必须唯一</td>\n</tr>\n<tr>\n<td></td>\n<td><code>node.id</code></td>\n<td>-</td>\n<td>Raft 模式（KRaft）下使用</td>\n<td>ZK 模式忽略</td>\n</tr>\n<tr>\n<td></td>\n<td><code>process.roles</code></td>\n<td>-</td>\n<td>KRaft 模式角色（controller, broker）</td>\n<td>ZK 模式不配置</td>\n</tr>\n<tr>\n<td>🔌 <strong>网络与监听配置</strong></td>\n<td><code>listeners</code></td>\n<td>PLAINTEXT://:9092</td>\n<td>Broker 监听地址</td>\n<td>可用多个协议，如 SASL_PLAINTEXT, SSL</td>\n</tr>\n<tr>\n<td></td>\n<td><code>advertised.listeners</code></td>\n<td>-</td>\n<td>客户端连接时看到的地址</td>\n<td>外网访问需配置</td>\n</tr>\n<tr>\n<td></td>\n<td><code>listener.security.protocol.map</code></td>\n<td>PLAINTEXT:PLAINTEXT</td>\n<td>映射监听器协议</td>\n<td>多协议时配置</td>\n</tr>\n<tr>\n<td></td>\n<td><code>inter.broker.listener.name</code></td>\n<td>-（Kafka 2.4+ 默认第一个 listener）</td>\n<td>指定 broker 间通信使用哪个 listener（如 INTERNAL）</td>\n<td>集群内部通信必须一致；常配合多 listener 使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num.network.threads</code></td>\n<td>3</td>\n<td>网络线程数</td>\n<td>一般不需修改</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num.io.threads</code></td>\n<td>8</td>\n<td>处理请求的 IO 线程数</td>\n<td>根据 CPU 调整</td>\n</tr>\n<tr>\n<td></td>\n<td><code>socket.send.buffer.bytes</code></td>\n<td>102400</td>\n<td>发送缓冲区大小</td>\n<td>网络优化参数</td>\n</tr>\n<tr>\n<td></td>\n<td><code>socket.receive.buffer.bytes</code></td>\n<td>102400</td>\n<td>接收缓冲区大小</td>\n<td>网络优化参数</td>\n</tr>\n<tr>\n<td></td>\n<td><code>socket.request.max.bytes</code></td>\n<td>104857600</td>\n<td>单请求最大大小 (100MB)</td>\n<td>大消息需调大</td>\n</tr>\n<tr>\n<td>⚙️ <strong>集群与元数据</strong></td>\n<td><code>log.dirs</code></td>\n<td>/tmp/kafka-logs</td>\n<td>数据存储路径</td>\n<td>多目录可提升性能</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num.recovery.threads.per.data.dir</code></td>\n<td>1</td>\n<td>每个数据目录的恢复线程数</td>\n<td>多磁盘时可增加</td>\n</tr>\n<tr>\n<td></td>\n<td><code>auto.create.topics.enable</code></td>\n<td>true</td>\n<td>是否允许自动创建 Topic</td>\n<td>生产建议禁用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>controlled.shutdown.enable</code></td>\n<td>true</td>\n<td>优雅关闭 Broker</td>\n<td>建议开启</td>\n</tr>\n<tr>\n<td></td>\n<td><code>delete.topic.enable</code></td>\n<td>true</td>\n<td>是否允许删除 Topic</td>\n<td>生产慎用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>auto.leader.rebalance.enable</code></td>\n<td>true</td>\n<td>是否自动均衡 Leader</td>\n<td>建议开启</td>\n</tr>\n<tr>\n<td></td>\n<td><code>leader.imbalance.check.interval.seconds</code></td>\n<td>300</td>\n<td>检查 leader 失衡间隔</td>\n<td>与上配合使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>leader.imbalance.per.broker.percentage</code></td>\n<td>10</td>\n<td>触发 leader 重平衡的阈值</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td>🧱 <strong>副本与复制机制</strong></td>\n<td><code>default.replication.factor</code></td>\n<td>1</td>\n<td>新 Topic 默认副本数</td>\n<td>生产建议 3</td>\n</tr>\n<tr>\n<td></td>\n<td><code>offsets.topic.replication.factor</code></td>\n<td>1</td>\n<td>消费组偏移主题副本数</td>\n<td>建议 3</td>\n</tr>\n<tr>\n<td></td>\n<td><code>transaction.state.log.replication.factor</code></td>\n<td>1</td>\n<td>事务状态主题副本数</td>\n<td>建议 3</td>\n</tr>\n<tr>\n<td></td>\n<td><code>transaction.state.log.min.isr</code></td>\n<td>1</td>\n<td>事务状态日志最小 ISR 数</td>\n<td>建议 2</td>\n</tr>\n<tr>\n<td></td>\n<td><code>min.insync.replicas</code></td>\n<td>1</td>\n<td>Leader 写入时要求的最小 ISR 副本数</td>\n<td>建议 <code>replication.factor - 1</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unclean.leader.election.enable</code></td>\n<td>false</td>\n<td>是否允许非同步副本选为 leader</td>\n<td>生产建议 false</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num.replica.fetchers</code></td>\n<td>1</td>\n<td>follower 拉取线程数</td>\n<td>可提升复制性能</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetch.max.bytes</code></td>\n<td>1048576 (1MB)</td>\n<td>follower 拉取单分区最大数据量</td>\n<td>增大可提速</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetch.response.max.bytes</code></td>\n<td>10485760 (10MB)</td>\n<td>follower 一次拉取响应总量</td>\n<td>可调大</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetch.wait.max.ms</code></td>\n<td>500</td>\n<td>follower 等待新数据的最大时长</td>\n<td>延迟与吞吐折中</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetch.backoff.ms</code></td>\n<td>1000</td>\n<td>拉取失败后退避时间</td>\n<td>网络不稳时调整</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.socket.timeout.ms</code></td>\n<td>30000</td>\n<td>follower 与 leader 通信超时</td>\n<td>≥ <a href=\"http://fetch.wait.ms\">fetch.wait.ms</a></td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.socket.receive.buffer.bytes</code></td>\n<td>65536</td>\n<td>拉取 socket 缓冲区</td>\n<td>调大可提速</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.lag.time.max.ms</code></td>\n<td>10000</td>\n<td>follower 落后 leader 的最大时间</td>\n<td>影响 ISR</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.high.watermark.checkpoint.interval.ms</code></td>\n<td>5000</td>\n<td>高水位写入 checkpoint 周期</td>\n<td>影响恢复速度</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.selector.class</code></td>\n<td>-</td>\n<td>自定义副本选择类</td>\n<td>一般保持默认</td>\n</tr>\n<tr>\n<td>🧮 <strong>日志与段文件</strong></td>\n<td><code>log.segment.bytes</code></td>\n<td>1073741824 (1GB)</td>\n<td>单日志段文件大小</td>\n<td>调小便于删除</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.segment.ms</code></td>\n<td>604800000 (7天)</td>\n<td>强制滚动日志的时间</td>\n<td>适用于时间控制</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.retention.hours</code></td>\n<td>168</td>\n<td>日志保留时间（小时）</td>\n<td>与磁盘空间相关</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.retention.bytes</code></td>\n<td>-1</td>\n<td>日志总大小限制</td>\n<td>-1 表示不限制</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.retention.check.interval.ms</code></td>\n<td>300000</td>\n<td>检查日志保留策略间隔</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.cleaner.enable</code></td>\n<td>true</td>\n<td>是否启用日志压缩</td>\n<td>compact 主题需启用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.cleaner.threads</code></td>\n<td>1</td>\n<td>清理线程数</td>\n<td>大集群可增加</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.cleaner.io.max.bytes.per.second</code></td>\n<td>None</td>\n<td>限制清理 IO 带宽</td>\n<td>控制磁盘负载</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.flush.interval.messages</code></td>\n<td>Long.MAX_VALUE</td>\n<td>累计消息数达到后强制 flush</td>\n<td>通常保持默认</td>\n</tr>\n<tr>\n<td></td>\n<td><code>log.flush.interval.ms</code></td>\n<td>None</td>\n<td>每隔多久强制 flush</td>\n<td>SSD 可调大</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num.partitions</code></td>\n<td>1</td>\n<td>新 Topic 默认分区数</td>\n<td>通常 3~6 起步</td>\n</tr>\n<tr>\n<td>🧵 <strong>生产与消费相关</strong></td>\n<td><code>message.max.bytes</code></td>\n<td>1048576</td>\n<td>允许的最大消息大小</td>\n<td>与 Producer <code>max.request.size</code> 对齐</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetch.max.bytes</code></td>\n<td>1048576</td>\n<td>与 Producer/Consumer 对应的限制</td>\n<td>防止大消息卡死</td>\n</tr>\n<tr>\n<td></td>\n<td><code>compression.type</code></td>\n<td>producer</td>\n<td>压缩算法（none, gzip, snappy, lz4, zstd）</td>\n<td>建议 zstd</td>\n</tr>\n<tr>\n<td></td>\n<td><code>queued.max.requests</code></td>\n<td>500</td>\n<td>Broker 最大排队请求数</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td>🛠️ <strong>控制器与协调器</strong></td>\n<td><code>controller.socket.timeout.ms</code></td>\n<td>30000</td>\n<td>控制器通信超时</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td></td>\n<td><code>controller.quorum.voters</code></td>\n<td>-</td>\n<td>KRaft 模式选举成员</td>\n<td>ZK 模式不需</td>\n</tr>\n<tr>\n<td></td>\n<td><code>controller.listener.names</code></td>\n<td>-</td>\n<td>控制器监听名</td>\n<td>ZK 模式忽略</td>\n</tr>\n<tr>\n<td>📈 <strong>监控与指标</strong></td>\n<td><code>metric.reporters</code></td>\n<td>空</td>\n<td>指标上报类</td>\n<td>可接 Prometheus</td>\n</tr>\n<tr>\n<td></td>\n<td><code>metrics.num.samples</code></td>\n<td>2</td>\n<td>指标采样数</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td></td>\n<td><code>metrics.sample.window.ms</code></td>\n<td>30000</td>\n<td>指标采样窗口</td>\n<td>默认即可</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replica.fetchers.metrics.enabled</code></td>\n<td>true</td>\n<td>是否启用副本拉取指标</td>\n<td>Kafka 3.x 新增</td>\n</tr>\n<tr>\n<td>🔒 <strong>安全</strong></td>\n<td><code>authorizer.class.name</code></td>\n<td>空</td>\n<td>授权类实现</td>\n<td>开启 ACL 时配置</td>\n</tr>\n<tr>\n<td></td>\n<td><code>super.users</code></td>\n<td>空</td>\n<td>超级用户列表</td>\n<td>ACL 模式下配置</td>\n</tr>\n<tr>\n<td></td>\n<td><code>ssl.keystore.location</code></td>\n<td>-</td>\n<td>SSL 证书路径</td>\n<td>启用 SSL 时使用</td>\n</tr>\n<tr>\n<td></td>\n<td><code>ssl.truststore.location</code></td>\n<td>-</td>\n<td>信任证书路径</td>\n<td>启用 SSL 时使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参数使用建议总结\">参数使用建议总结</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>高可靠性集群</strong></td>\n<td><code>default.replication.factor=3</code>, <code>min.insync.replicas=2</code>, <code>unclean.leader.election.enable=false</code></td>\n</tr>\n<tr>\n<td><strong>吞吐优先</strong></td>\n<td>提高 <code>num.replica.fetchers</code>、<code>replica.fetch.max.bytes</code></td>\n</tr>\n<tr>\n<td><strong>快速恢复</strong></td>\n<td>减少 <code>replica.high.watermark.checkpoint.interval.ms</code></td>\n</tr>\n<tr>\n<td><strong>节省磁盘</strong></td>\n<td>启用 <code>log.cleaner.enable</code> 并设置 <code>log.retention.hours</code></td>\n</tr>\n<tr>\n<td><strong>事务或精确一次语义</strong></td>\n<td>设置 <code>transaction.state.log.replication.factor=3</code>、<code>transaction.state.log.min.isr=2</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 CentOS9 中 Kafka 的 server.properties 的配置项，基于 Zookeeper。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Kafka 3.x server.properties 主要配置项清单 关于 server.properties 的配置项，请参考 Kafka 官方文档 分类 参数名 默认值 说明 推荐/备注 🗂️ 基本信息 broker.id 0 Broker 唯一标识 集群中必须唯一 node.id - Raft 模式（KRaft）下使用 ZK 模式忽略 process.roles - KRaft 模式角色（controller, broker） ZK 模式不配置 🔌 网络与监听配置 listeners PLAINTEXT://:9092 Broker 监听地址 可用多个协议，如 SASL_PLAINTEXT, SSL advertised.listeners - 客户端连接时看到的地址 外网访问需配置 listener.security.protocol.map PLAINTEXT:PLAINTEXT 映射监听器协议 多协议时配置 inter.broker.listener.name -（Kafka 2.4+ 默认第一个 listener） 指定 broker 间通信使用哪个 listener（如 INTERNAL） 集群内部通信必须一致；常配合多 listener 使用 num.network.threads 3 网络线程数 一般不需修改 num.io.threads 8 处理请求的 IO 线程数 根据 CPU 调整 socket.send.buffer.bytes 102400 发送缓冲区大小 网络优化参数 socket.receive.buffer.bytes 102400 接收缓冲区大小 网络优化参数 socket.request.max.bytes 104857600 单请求最大大小 (100MB) 大消息需调大 ⚙️ 集群与元数据 log.dirs /tmp/kafka-logs 数据存储路径 多目录可提升性能 num.recovery.threads.per.data.dir 1 每个数据目录的恢复线程数 多磁盘时可增加 auto.create.topics.enable true 是否允许自动创建 Topic 生产建议禁用 controlled.shutdown.enable true 优雅关闭 Broker 建议开启 delete.topic.enable true 是否允许删除 Topic 生产慎用 auto.leader.rebalance.enable true 是否自动均衡 Leader 建议开启 leader.imbalance.check.interval.seconds 300 检查 leader 失衡间隔 与上配合使用 leader.imbalance.per.broker.percentage 10 触发 leader 重平衡的阈值 默认即可 🧱 副本与复制机制 default.replication.factor 1 新 Topic 默认副本数 生产建议 3 offsets.topic.replication.factor 1 消费组偏移主题副本数 建议 3 transaction.state.log.replication.factor 1 事务状态主题副本数 建议 3 transaction.state.log.min.isr 1 事务状态日志最小 ISR 数 建议 2 min.insync.replicas 1 Leader 写入时要求的最小 ISR 副本数 建议 replication.factor - 1 unclean.leader.election.enable false 是否允许非同步副本选为 leader 生产建议 false num.replica.fetchers 1 follower 拉取线程数 可提升复制性能 replica.fetch.max.bytes 1048576 (1MB) follower 拉取单分区最大数据量 增大可提速 replica.fetch.response.max.bytes 10485760 (10MB) follower 一次拉取响应总量 可调大 replica.fetch.wait.max.ms 500 follower 等待新数据的最大时长 延迟与吞吐折中 replica.fetch.backoff.ms 1000 拉取失败后退避时间 网络不稳时调整 replica.socket.timeout.ms 30000 follower 与 leader 通信超时 ≥ fetch.wait.ms replica.socket.receive.buffer.bytes 65536 拉取 socket 缓冲区 调大可提速 replica.lag.time.max.ms 10000 follower 落后 leader 的最大时间 影响 ISR replica.high.watermark.checkpoint.interval.ms 5000 高水位写入 checkpoint 周期 影响恢复速度 replica.selector.class - 自定义副本选择类 一般保持默认 🧮 日志与段文件 log.segment.bytes 1073741824 (1GB) 单日志段文件大小 调小便于删除 log.segment.ms 604800000 (7天) 强制滚动日志的时间 适用于时间控制 log.retention.hours 168 日志保留时间（小时） 与磁盘空间相关 log.retention.bytes -1 日志总大小限制 -1 表示不限制 log.retention.check.interval.ms 300000 检查日志保留策略间隔 默认即可 log.cleaner.enable true 是否启用日志压缩 compact 主题需启用 log.cleaner.threads 1 清理线程数 大集群可增加 log.cleaner.io.max.bytes.per.second None 限制清理 IO 带宽 控制磁盘负载 log.flush.interval.messages Long.MAX_VALUE 累计消息数达到后强制 flush 通常保持默认 log.flush.interval.ms None 每隔多久强制 flush SSD 可调大 num.partitions 1 新 Topic 默认分区数 通常 3~6 起步 🧵 生产与消费相关 message.max.bytes 1048576 允许的最大消息大小 与 Producer max.request.size 对齐 replica.fetch.max.bytes 1048576 与 Producer/Consumer 对应的限制 防止大消息卡死 compression.type producer 压缩算法（none, gzip, snappy, lz4, zstd） 建议 zstd queued.max.requests 500 Broker 最大排队请求数 默认即可 🛠️ 控制器与协调器 controller.socket.timeout.ms 30000 控制器通信超时 默认即可 controller.quorum.voters - KRaft 模式选举成员 ZK 模式不需 controller.listener.names - 控制器监听名 ZK 模式忽略 📈 监控与指标 metric.reporters 空 指标上报类 可接 Prometheus metrics.num.samples 2 指标采样数 默认即可 metrics.sample.window.ms 30000 指标采样窗口 默认即可 replica.fetchers.metrics.enabled true 是否启用副本拉取指标 Kafka 3.x 新增 🔒 安全 authorizer.class.name 空 授权类实现 开启 ACL 时配置 super.users 空 超级用户列表 ACL 模式下配置 ssl.keystore.location - SSL 证书路径 启用 SSL 时使用 ssl.truststore.location - 信任证书路径 启用 SSL 时使用 参数使用建议总结 场景 推荐配置 高可靠性集群 default.replication.factor=3, min.insync.replicas=2, unclean.leader.election.enable=false 吞吐优先 提高 num.replica.fetchers、replica.fetch.max.bytes 快速恢复 减少 replica.high.watermark.checkpoint.interval.ms 节省磁盘 启用 log.cleaner.enable 并设置 log.retention.hours 事务或精确一次语义 设置 transaction.state.log.replication.factor=3、transaction.state.log.min.isr=2","summary":"摘要 本文介绍 CentOS9 中 Kafka 的 server.properties 的配置项，基于 Zookeeper。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。","date_published":"2025-10-14T13:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/13/kafka-03-webui/","url":"https://blog.hanqunfeng.com/2025/10/13/kafka-03-webui/","title":"Kafka 的 Web UI 之 Kafbat UI","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Kafka 的 Web UI 之 Kafbat UI</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafbat.io\">Kafbat UI 官网</a>，<a href=\"https://github.com/kafbat/kafka-ui\">Kafbat UI Github</a>，<a href=\"https://ui.docs.kafbat.io\">Kafbat UI 文档</a>，Kafbat UI 支持 Docker 和 Jar 包两种方式运行，支持同时连接多个 Kafka 集群。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 Kafbat UI 类似的 Kafka Web UI 还有一个 <a href=\"https://github.com/obsidiandynamics/kafdrop\">kafdrop</a>，同样支持 Docker 和 Jar 包两种方式运行，只不过其仅支持单个 Kafka 集群，感兴趣的可以自己体验。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Kafbat-UI-简介\">Kafbat UI 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafbat UI 是一个免费的开源 Web 用户界面，用于监控和管理 Apache Kafka 集群。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafbat UI 是一个简单的工具，使您的数据流变得可观察，帮助更快地发现和排除问题，并提供最佳性能。其轻量级的仪表盘使您能够轻松跟踪 Kafka 集群的关键指标: 包括 Brokers、Topics、Partitions、生产和消费情况。</p>\n</li>\n</ul>\n<h2 id=\"运行-Kafbat-UI\">运行 Kafbat UI</h2>\n<h3 id=\"Docker-运行\">Docker 运行</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 8080:8080 \\</span><br><span class=\"line\">    --name kafka-ui \\</span><br><span class=\"line\">    -e KAFKA_CLUSTERS_0_NAME=kafka_c01 \\</span><br><span class=\"line\">    -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=localhost:9092 \\</span><br><span class=\"line\">    -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">    -d ghcr.io/kafbat/kafka-ui:latest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Jar-运行\">Jar 运行</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从<a href=\"https://github.com/kafbat/kafka-ui/releases\">Github</a>上下载最新版jar包，要求 <code>jdk 21+</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /Users/hanqf/myservice_dir/kafka_webui</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置kafka集群，可以同时配置多个，序号从0开始依次递增</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_NAME=kafka_c01</span><br><span class=\"line\"><span class=\"comment\"># =============================================================================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 外网PLAINTEXT访问</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093</span></span><br><span class=\"line\"><span class=\"comment\"># =============================================================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># =============================================================================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 外网SASL_PLAINTEXT访问</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9094,68.79.13.235:9094,43.192.84.195:9094</span></span><br><span class=\"line\"><span class=\"comment\"># # SASL_PLAINTEXT认证配置</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_PLAINTEXT</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAIN</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># =============================================================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># =============================================================================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 外网SASL_SSL访问</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9095,68.79.13.235:9095,43.192.84.195:9095</span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_SSL</span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAIN</span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=<span class=\"string\">&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># SSL配置</span></span><br><span class=\"line\"><span class=\"comment\"># JKS 格式证书</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_PASSWORD=123456</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># PEM 格式证书</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crt</span></span><br><span class=\"line\"><span class=\"comment\"># export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_TYPE=PEM</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用主机名验证</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_0_PROPERTIES_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># ============================================================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二个集群配置示例</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_1_NAME=kafka_c02</span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_CLUSTERS_1_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时区</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> TZ=Asia/Shanghai</span><br><span class=\"line\"><span class=\"comment\"># 语言</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LANG=zh_CN.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># webui访问路径</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> SERVER_SERVLET_CONTEXT_PATH=/</span><br><span class=\"line\"><span class=\"comment\"># 认证方式，支持NONE(无认证)，LOGIN_FORM(登录表单认证)</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> AUTH_TYPE=LOGIN_FORM</span><br><span class=\"line\"><span class=\"comment\"># webui认证用户名密码</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> SPRING_SECURITY_USER_NAME=admin</span><br><span class=\"line\"><span class=\"built_in\">export</span> SPRING_SECURITY_USER_PASSWORD=admin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">JAVA_OPTS=<span class=\"string\">&quot;-Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">/Users/hanqf/develop_soft/jdk21/bin/java --add-opens java.rmi/javax.rmi.ssl=ALL-UNNAMED  <span class=\"variable\">$JAVA_OPTS</span> -jar api-v1.3.0.jar</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问-Kafbat-UI\">访问 Kafbat UI</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问 <a href=\"http://localhost:8080\">http://localhost:8080</a><br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/ykd6F4.png\" alt=\"\"></p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Kafka 的 Web UI 之 Kafbat UI Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Kafbat UI 官网，Kafbat UI Github，Kafbat UI 文档，Kafbat UI 支持 Docker 和 Jar 包两种方式运行，支持同时连接多个 Kafka 集群。 与 Kafbat UI 类似的 Kafka Web UI 还有一个 kafdrop，同样支持 Docker 和 Jar 包两种方式运行，只不过其仅支持单个 Kafka 集群，感兴趣的可以自己体验。 Kafbat UI 简介 Kafbat UI 是一个免费的开源 Web 用户界面，用于监控和管理 Apache Kafka 集群。 Kafbat UI 是一个简单的工具，使您的数据流变得可观察，帮助更快地发现和排除问题，并提供最佳性能。其轻量级的仪表盘使您能够轻松跟踪 Kafka 集群的关键指标: 包括 Brokers、Topics、Partitions、生产和消费情况。 运行 Kafbat UI Docker 运行 1234567docker run -it -p 8080:8080 \\ --name kafka-ui \\ -e KAFKA_CLUSTERS_0_NAME=kafka_c01 \\ -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=localhost:9092 \\ -e TZ=Asia/Shanghai \\ -d ghcr.io/kafbat/kafka-ui:latest Jar 运行 从Github上下载最新版jar包，要求 jdk 21+ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859cd /Users/hanqf/myservice_dir/kafka_webui# 配置kafka集群，可以同时配置多个，序号从0开始依次递增export KAFKA_CLUSTERS_0_NAME=kafka_c01# =============================================================================================================# 外网PLAINTEXT访问# export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093# =============================================================================================================# =============================================================================================================# 外网SASL_PLAINTEXT访问# export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9094,68.79.13.235:9094,43.192.84.195:9094# # SASL_PLAINTEXT认证配置# export KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_PLAINTEXT# export KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAIN# export KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;# =============================================================================================================# =============================================================================================================# 外网SASL_SSL访问export KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=161.189.227.200:9095,68.79.13.235:9095,43.192.84.195:9095export KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL=SASL_SSLexport KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM=PLAINexport KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG=&#x27;org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;alice&quot; password=&quot;alice-secret&quot;;&#x27;# SSL配置# JKS 格式证书export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jksexport KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_PASSWORD=123456# PEM 格式证书# export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crt# export KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_TYPE=PEM# 禁用主机名验证export KAFKA_CLUSTERS_0_PROPERTIES_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM=&#x27;&#x27;# ============================================================================================================# 第二个集群配置示例export KAFKA_CLUSTERS_1_NAME=kafka_c02export KAFKA_CLUSTERS_1_BOOTSTRAPSERVERS=161.189.227.200:9093,68.79.13.235:9093,43.192.84.195:9093# 时区export TZ=Asia/Shanghai# 语言export LANG=zh_CN.UTF-8# webui访问路径export SERVER_SERVLET_CONTEXT_PATH=/# 认证方式，支持NONE(无认证)，LOGIN_FORM(登录表单认证)export AUTH_TYPE=LOGIN_FORM# webui认证用户名密码export SPRING_SECURITY_USER_NAME=adminexport SPRING_SECURITY_USER_PASSWORD=adminJAVA_OPTS=&quot;-Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m&quot;# 启动/Users/hanqf/develop_soft/jdk21/bin/java --add-opens java.rmi/javax.rmi.ssl=ALL-UNNAMED $JAVA_OPTS -jar api-v1.3.0.jar 访问 Kafbat UI 访问 http://localhost:8080","summary":"摘要 本文介绍 Kafka 的 Web UI 之 Kafbat UI Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Kafbat UI 官网，Kafbat UI Github，Kafbat UI 文档，Kafbat UI 支持 Docker 和 Jar 包两种方式运行，支持同时连接多个 Kafka 集群。 与 Kafbat UI 类似的 Kafka Web UI 还有一个 kafdrop，同样支持 Docker 和 Jar 包两种方式运行，只不过其仅支持单个 Kafka 集群，感兴趣的可以自己体验。","date_published":"2025-10-13T15:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/13/kafka-02-protocol/","url":"https://blog.hanqunfeng.com/2025/10/13/kafka-02-protocol/","title":"Kafka 通信协议、SSL加密和身份验证","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Kafka 的 通信协议，以及如何开启外网访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Kafka-的-通信协议\">Kafka 的 通信协议</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 主要支持四种安全协议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名称</th>\n<th>加密</th>\n<th>认证</th>\n<th>说明</th>\n<th>推荐场景</th>\n<th>理由</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PLAINTEXT</strong></td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>无加密、无认证（默认最简单）</td>\n<td>开发 / 测试环境、内网集群通信</td>\n<td>简单、易调试；网络可信，性能优先</td>\n</tr>\n<tr>\n<td><strong>SSL</strong></td>\n<td>✅ 是</td>\n<td>✅ 可选</td>\n<td>使用 TLS/SSL 加密通信，可配置客户端证书认证</td>\n<td>外网客户端访问</td>\n<td>支持数据加密，可选认证，保证安全</td>\n</tr>\n<tr>\n<td><strong>SASL_PLAINTEXT</strong></td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n<td>使用 SASL（用户名密码）认证，但不加密数据</td>\n<td>需要用户认证但局域网环境</td>\n<td>有认证，但不加密，性能开销低</td>\n</tr>\n<tr>\n<td><strong>SASL_SSL</strong></td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>同时支持 SASL 认证和 SSL 加密（最安全）</td>\n<td>外网客户端访问</td>\n<td>既有认证又加密，安全性最高</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>config/server.properties</code> 文件中 可以看到如下配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 套接字服务器监听的地址。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果未配置，则主机名默认等于 `java.net.InetAddress.getCanonicalHostName()` 的返回值，</span></span><br><span class=\"line\"><span class=\"comment\"># 使用监听器名称 `PLAINTEXT`，端口号为 9092。</span></span><br><span class=\"line\"><span class=\"comment\">#   格式：</span></span><br><span class=\"line\"><span class=\"comment\">#     listeners = listener_name://host_name:port</span></span><br><span class=\"line\"><span class=\"comment\">#   示例：</span></span><br><span class=\"line\"><span class=\"comment\">#     listeners = PLAINTEXT://your.host.name:9092</span></span><br><span class=\"line\"><span class=\"comment\">#listeners=PLAINTEXT://:9092</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Broker 向客户端“通告”的监听器名称、主机名和端口。</span></span><br><span class=\"line\"><span class=\"comment\"># 客户端实际会连接这个地址，而不是直接使用 listeners 的地址。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果未设置，则默认使用 `listeners` 的值。</span></span><br><span class=\"line\"><span class=\"comment\">#advertised.listeners=PLAINTEXT://your.host.name:9092</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将监听器名称映射到安全协议类型。</span></span><br><span class=\"line\"><span class=\"comment\"># 默认情况下，监听器名称与安全协议同名。</span></span><br><span class=\"line\"><span class=\"comment\"># 例如：PLAINTEXT→PLAINTEXT、SSL→SSL、SASL_PLAINTEXT→SASL_PLAINTEXT、SASL_SSL→SASL_SSL。</span></span><br><span class=\"line\"><span class=\"comment\"># 更多细节可参考 Kafka 官方配置文档。</span></span><br><span class=\"line\"><span class=\"comment\">#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n<th>说明值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>listeners</code></td>\n<td>Kafka 实际监听的地址（Broker 对外开放的端口）</td>\n<td><code>PLAINTEXT://:9092</code>这里 PLAINTEXT 是监听器名称，并不是协议名称，实际上可以配置为任何值，具体协议是通过 <code>listener.security.protocol.map</code> 配置的映射关系来确定。</td>\n</tr>\n<tr>\n<td><code>advertised.listeners</code></td>\n<td>Kafka 告诉客户端应该用哪个地址连接（客户端最终连的）</td>\n<td>默认使用 <code>listeners</code> 的值</td>\n</tr>\n<tr>\n<td><code>listener.security.protocol.map</code></td>\n<td>映射监听器名称到通信安全协议（如明文、SSL、SASL 等）</td>\n<td><code>PLAINTEXT:PLAINTEXT</code>，前面是监听器名称，后面是协议名称</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"仅需内网访问\">仅需内网访问</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listeners=PLAINTEXT://0.0.0.0:9092</span><br><span class=\"line\">advertised.listeners=PLAINTEXT://worker1:9092 <span class=\"comment\"># 这里是内网ip</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"允许外网访问\">允许外网访问</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listeners=PLAINTEXT://0.0.0.0:9092</span><br><span class=\"line\">advertised.listeners=PLAINTEXT://161.189.227.200:9092 <span class=\"comment\"># 这里是外网ip</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"内外网都要访问（推荐双通道方式）\">内外网都要访问（推荐双通道方式）</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里 INTERNAL 和 EXTERNAL 分别是自定义的监听器名称，此时内网端口为 9092，外网端口为 9093</span></span><br><span class=\"line\">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093</span><br><span class=\"line\"><span class=\"comment\"># 告诉客户端应该用哪个地址连接</span></span><br><span class=\"line\">advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9093</span><br><span class=\"line\"><span class=\"comment\"># 映射监听器名称到通信安全协议的映射关系</span></span><br><span class=\"line\">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 集群间通信仍使用内网</span></span><br><span class=\"line\">inter.broker.listener.name=INTERNAL</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启-SASL-PLAINTEXT\">开启 SASL_PLAINTEXT</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里设置外网访问时开启 SASL_PLAINTEXT</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class=\"line\">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9094</span><br><span class=\"line\"><span class=\"comment\"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class=\"line\">advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9094</span><br><span class=\"line\">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 集群间通信 still use INTERNAL</span></span><br><span class=\"line\">inter.broker.listener.name=INTERNAL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）</span></span><br><span class=\"line\"><span class=\"comment\"># client 连接时</span></span><br><span class=\"line\">sasl.enabled.mechanisms=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># broker 之间连接时，因为 inter.broker.listener.name=INTERNAL，所以 INTERNAL:SASL_PLAINTEXT 才有效</span></span><br><span class=\"line\"><span class=\"comment\">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 kafka_jaas.conf</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">############################</span></span><br><span class=\"line\"><span class=\"comment\"># Kafka Broker (服务端)</span></span><br><span class=\"line\"><span class=\"comment\">############################</span></span><br><span class=\"line\">KafkaServer &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class=\"line\">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class=\"line\">    <span class=\"comment\"># Broker 自己的身份（用于 broker 之间通信，本示例中没有使用）</span></span><br><span class=\"line\">    username=<span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">    password=<span class=\"string\">&quot;admin-secret&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 客户端可用账号，即 user_xxx，这里 xxx 为用户名，= 右边的为密码</span></span><br><span class=\"line\">    user_admin=<span class=\"string\">&quot;admin-secret&quot;</span></span><br><span class=\"line\">    user_alice=<span class=\"string\">&quot;alice-secret&quot;</span></span><br><span class=\"line\">    user_bob=<span class=\"string\">&quot;bob-secret&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 kafka</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在启动 Kafka Broker 前，设置环境变量指向 JAAS 文件</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_OPTS=<span class=\"string\">&quot;-Djava.security.auth.login.config=/usr/local/kafka/kafka3/config/kafka_jaas.conf&quot;</span></span><br><span class=\"line\">kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端访问\">客户端访问</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 client.conf</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">security.protocol=SASL_PLAINTEXT</span><br><span class=\"line\"><span class=\"comment\"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class=\"line\">sasl.mechanism=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class=\"line\">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class=\"string\">&quot;admin&quot;</span> password=<span class=\"string\">&quot;admin-secret&quot;</span>;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建topic</span></span><br><span class=\"line\">kafka-topics.sh --create --topic test-topic --bootstrap-server=161.189.227.200:9094 --command-config=client.conf</span><br><span class=\"line\"><span class=\"comment\"># 查看topic</span></span><br><span class=\"line\">kafka-topics.sh --list --bootstrap-server=161.189.227.200:9094 --command-config=client.conf</span><br><span class=\"line\"><span class=\"comment\"># 创建消费者，--group 指定消费者组名称</span></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --consumer.config=client.conf --group=test-group</span><br><span class=\"line\"><span class=\"comment\"># 创建生产者</span></span><br><span class=\"line\">kafka-console-producer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --producer.config=client.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启-SASL-SSL\">开启 SASL_SSL</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里设置外网访问时开启 SASL_SSL</p>\n</li>\n</ul>\n<h3 id=\"创建证书\">创建证书</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org/39/documentation.html#security_ssl\">官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>生成 Broker keystore，用于 存储 broker 的私钥和证书。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -keystore kafka.server.keystore.jks \\</span><br><span class=\"line\">  -<span class=\"built_in\">alias</span> broker -validity 3650 \\</span><br><span class=\"line\">  -genkey -keyalg RSA \\</span><br><span class=\"line\">  -dname <span class=\"string\">&quot;CN=broker, OU=Kafka, O=YourOrg, L=City, ST=State, C=CN&quot;</span> \\</span><br><span class=\"line\">  -storepass 123456 \\</span><br><span class=\"line\">  -keypass 123456</span><br><span class=\"line\"><span class=\"comment\">## 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># -keystore：生成的 keystore 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -alias broker：证书别名</span></span><br><span class=\"line\"><span class=\"comment\"># -validity 3650：有效期 3650 天</span></span><br><span class=\"line\"><span class=\"comment\"># -keyalg RSA：密钥算法</span></span><br><span class=\"line\"><span class=\"comment\"># -dname：证书信息</span></span><br><span class=\"line\"><span class=\"comment\"># -storepass：keystore 密码</span></span><br><span class=\"line\"><span class=\"comment\"># -keypass：密钥密码</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>导出 Broker 证书（用于客户端 truststore）,生成 kafka.server.crt，客户端会用它来验证 broker。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -keystore kafka.server.keystore.jks \\</span><br><span class=\"line\">  -<span class=\"built_in\">alias</span> broker -<span class=\"built_in\">export</span> -file kafka.server.crt \\</span><br><span class=\"line\">  -storepass 123456</span><br><span class=\"line\"><span class=\"comment\">## 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># -keystore：keystore 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -alias broker：证书别名</span></span><br><span class=\"line\"><span class=\"comment\"># -file kafka.server.crt：导出的证书文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -storepass：keystore 密码</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成 Broker truststore，truststore 用于 存储信任的证书（这里把自己生成的证书导入进去即可）,生成 kafka.truststore.jks</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意：这里 server 端 和 client 端 可以共用一个 truststore，也可以分别创建</span></span><br><span class=\"line\">keytool -keystore kafka.truststore.jks \\</span><br><span class=\"line\">  -<span class=\"built_in\">alias</span> broker -import -file kafka.server.crt \\</span><br><span class=\"line\">  -storepass 123456 -noprompt</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># -keystore：生成的 truststore 文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -alias broker：证书别名</span></span><br><span class=\"line\"><span class=\"comment\"># -file kafka.server.crt：导入的证书文件路径</span></span><br><span class=\"line\"><span class=\"comment\"># -storepass：truststore 密码</span></span><br><span class=\"line\"><span class=\"comment\"># -noprompt：不提示</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"server-properties-配置-SASL-SSL\">server.properties 配置 SASL_SSL</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class=\"line\">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095</span><br><span class=\"line\"><span class=\"comment\"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class=\"line\">advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095</span><br><span class=\"line\">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSL</span><br><span class=\"line\">inter.broker.listener.name=INTERNAL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SASL</span></span><br><span class=\"line\"><span class=\"comment\"># 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）</span></span><br><span class=\"line\"><span class=\"comment\"># client 连接时</span></span><br><span class=\"line\">sasl.enabled.mechanisms=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效</span></span><br><span class=\"line\"><span class=\"comment\">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSL</span></span><br><span class=\"line\">ssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/kafka.server.keystore.jks</span><br><span class=\"line\">ssl.keystore.password=123456</span><br><span class=\"line\">ssl.key.password=123456</span><br><span class=\"line\">ssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class=\"line\">ssl.truststore.password=123456</span><br><span class=\"line\"><span class=\"comment\"># 如果不要求客户端证书，可以设置 none ，要求则设置为 required</span></span><br><span class=\"line\">ssl.client.auth=none</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 kafka 前同样需要先创建好 kafka_jaas.conf，与 SASL_PLAINTEXT 一样。</p>\n</li>\n</ul>\n<h3 id=\"客户端访问-2\">客户端访问</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 <code>kafka.truststore.jks</code> 拷贝到客户端</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 SASL_PLAINTEXT 一样，创建 client.conf，并添加如下信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">security.protocol=SASL_SSL</span><br><span class=\"line\"><span class=\"comment\"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class=\"line\">sasl.mechanism=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class=\"line\">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class=\"string\">&quot;admin&quot;</span> password=<span class=\"string\">&quot;admin-secret&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSL 配置</span></span><br><span class=\"line\">ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jks</span><br><span class=\"line\">ssl.truststore.password=123456</span><br><span class=\"line\"><span class=\"comment\"># 禁用主机名验证，否则会校验证书的 SAN，证书域名校验开关，为空则表示关闭，这里需要保持关闭状态，必须设置为空</span></span><br><span class=\"line\">ssl.endpoint.identification.algorithm=</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行访问 与 SASL_PLAINTEXT 一样，这里不再赘述</p>\n</li>\n<li class=\"lvl-2\">\n<p>关于 Kafka JKS格式的SSL证书的创建及配置可以参考<a href=\"https://support.huaweicloud.com/usermanual-kafka/kafka-ug-0008.html\">制作和替换Kafka JKS格式的SSL证书</a></p>\n</li>\n</ul>\n<h4 id=\"PEM-证书\">PEM 证书</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kafka 的 证书 默认使用 JKS 格式，但从 2.7.0 开始支持 PEM 格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 监听地址和端口，这里内网和外网分开配置</span></span><br><span class=\"line\">listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095</span><br><span class=\"line\"><span class=\"comment\"># 客户端建立连接后实际返回给客户端的地址</span></span><br><span class=\"line\">advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095</span><br><span class=\"line\">listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSL</span><br><span class=\"line\">inter.broker.listener.name=INTERNAL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SASL</span></span><br><span class=\"line\"><span class=\"comment\"># 认证机制（常见为 PLAIN，也可以是 CRAM-SHA-256、SCRAM-SHA-512）</span></span><br><span class=\"line\"><span class=\"comment\"># client 连接时</span></span><br><span class=\"line\">sasl.enabled.mechanisms=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效</span></span><br><span class=\"line\"><span class=\"comment\">#sasl.mechanism.inter.broker.protocol=PLAIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSL-PEM</span></span><br><span class=\"line\">ssl.keystore.type=PEM <span class=\"comment\"># 指定证书类型是PEM，支持的类型 PEM、JKS</span></span><br><span class=\"line\">ssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/fullchain.pem <span class=\"comment\"># 包含私钥和公钥</span></span><br><span class=\"line\"><span class=\"comment\"># 指定客户端使用的证书类型是PEM</span></span><br><span class=\"line\">ssl.truststore.type=PEM</span><br><span class=\"line\">ssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/server.crt <span class=\"comment\"># 公钥</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不要求客户端证书，可以设置 none ，要求则设置为 required</span></span><br><span class=\"line\">ssl.client.auth=none</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>client.conf 配置如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">security.protocol=SASL_SSL</span><br><span class=\"line\"><span class=\"comment\"># 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致</span></span><br><span class=\"line\">sasl.mechanism=PLAIN</span><br><span class=\"line\"><span class=\"comment\"># 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required</span></span><br><span class=\"line\">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=<span class=\"string\">&quot;admin&quot;</span> password=<span class=\"string\">&quot;admin-secret&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSL 配置，将 server 端的 server.crt 拷贝到 client 端</span></span><br><span class=\"line\">ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crt</span><br><span class=\"line\">ssl.truststore.type=PEM</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用主机名验证</span></span><br><span class=\"line\">ssl.endpoint.identification.algorithm=</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>jks 证书转换为 pem 格式</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">从 JKS 导出为 PKCS#12 (.p12)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -importkeystore \\</span><br><span class=\"line\">  -srckeystore kafka.server.keystore.jks \\</span><br><span class=\"line\">  -srcstoretype JKS \\</span><br><span class=\"line\">  -destkeystore kafka.server.p12 \\</span><br><span class=\"line\">  -deststoretype PKCS12 \\</span><br><span class=\"line\">  -srcstorepass 123456 \\</span><br><span class=\"line\">  -deststorepass 123456 \\</span><br><span class=\"line\">  -J<span class=\"string\">&quot;-Djdk.tls.disabledAlgorithms=&quot;</span> \\</span><br><span class=\"line\">  -J<span class=\"string\">&quot;-Dkeystore.pkcs12.legacy=false&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\">  <span class=\"comment\"># -srcstoretype JKS：原始格式；</span></span><br><span class=\"line\">  <span class=\"comment\"># -deststoretype PKCS12：转换为通用格式；</span></span><br><span class=\"line\">  <span class=\"comment\"># .p12 是 PEM 的“中间格式”。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">导出证书[公钥] (.crt，这里是 PEM 格式)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -<span class=\"keyword\">in</span> kafka.server.p12 -clcerts -nokeys -out server.crt -password pass:123456 -provider legacy -provider default</span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># -clcerts：只导出证书；</span></span><br><span class=\"line\"><span class=\"comment\"># -nokeys：不导出密钥；</span></span><br><span class=\"line\"><span class=\"comment\"># -out server.crt：导出文件名；</span></span><br><span class=\"line\"><span class=\"comment\"># -password：kafka.server.p12的密钥密码，注意密码前面加上 pass:</span></span><br><span class=\"line\"><span class=\"comment\"># -provider legacy：启用旧算法支持模块，在 OpenSSL 3.0（及更高版本）中，引入了一个新机制 —— Provider（算法提供者）,默认情况下，OpenSSL 只加载 modern provider（default provider），而许多老旧算法（例如 RC2、MD5、DES、SHA1）被移到了一个单独的 legacy provider 模块中。</span></span><br><span class=\"line\"><span class=\"comment\"># -provider default：同时启用默认 provider，因为有些命令（比如涉及现代加密算法或证书签名）还依赖默认 provider，所以两者一起使用最安全、最兼容</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">导出私钥 (.key，这里是 PEM 格式)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -<span class=\"keyword\">in</span> kafka.server.p12 -nocerts -out server.key -nodes -password pass:123456 -provider legacy -provider default</span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># -nocerts：只导出密钥；</span></span><br><span class=\"line\"><span class=\"comment\"># -out server.key：导出文件名；</span></span><br><span class=\"line\"><span class=\"comment\"># -nodes：不加密导出的密钥文件</span></span><br><span class=\"line\"><span class=\"comment\"># -password：kafka.server.p12的密钥密码，注意密码前面加上 pass:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">fullchain.pem</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -<span class=\"keyword\">in</span> kafka.server.p12 -out fullchain.pem -nodes -password pass:123456 -provider legacy -provider default</span><br></pre></td></tr></table></figure>\n</div>\n","content_text":"摘要 本文介绍 Kafka 的 通信协议，以及如何开启外网访问。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Kafka 的 通信协议 Kafka 主要支持四种安全协议 协议名称 加密 认证 说明 推荐场景 理由 PLAINTEXT ❌ 否 ❌ 否 无加密、无认证（默认最简单） 开发 / 测试环境、内网集群通信 简单、易调试；网络可信，性能优先 SSL ✅ 是 ✅ 可选 使用 TLS/SSL 加密通信，可配置客户端证书认证 外网客户端访问 支持数据加密，可选认证，保证安全 SASL_PLAINTEXT ❌ 否 ✅ 是 使用 SASL（用户名密码）认证，但不加密数据 需要用户认证但局域网环境 有认证，但不加密，性能开销低 SASL_SSL ✅ 是 ✅ 是 同时支持 SASL 认证和 SSL 加密（最安全） 外网客户端访问 既有认证又加密，安全性最高 在 config/server.properties 文件中 可以看到如下配置 12345678910111213141516171819# 套接字服务器监听的地址。# 如果未配置，则主机名默认等于 `java.net.InetAddress.getCanonicalHostName()` 的返回值，# 使用监听器名称 `PLAINTEXT`，端口号为 9092。# 格式：# listeners = listener_name://host_name:port# 示例：# listeners = PLAINTEXT://your.host.name:9092#listeners=PLAINTEXT://:9092# Broker 向客户端“通告”的监听器名称、主机名和端口。# 客户端实际会连接这个地址，而不是直接使用 listeners 的地址。# 如果未设置，则默认使用 `listeners` 的值。#advertised.listeners=PLAINTEXT://your.host.name:9092# 将监听器名称映射到安全协议类型。# 默认情况下，监听器名称与安全协议同名。# 例如：PLAINTEXT→PLAINTEXT、SSL→SSL、SASL_PLAINTEXT→SASL_PLAINTEXT、SASL_SSL→SASL_SSL。# 更多细节可参考 Kafka 官方配置文档。#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL 配置项 作用 说明值 listeners Kafka 实际监听的地址（Broker 对外开放的端口） PLAINTEXT://:9092这里 PLAINTEXT 是监听器名称，并不是协议名称，实际上可以配置为任何值，具体协议是通过 listener.security.protocol.map 配置的映射关系来确定。 advertised.listeners Kafka 告诉客户端应该用哪个地址连接（客户端最终连的） 默认使用 listeners 的值 listener.security.protocol.map 映射监听器名称到通信安全协议（如明文、SSL、SASL 等） PLAINTEXT:PLAINTEXT，前面是监听器名称，后面是协议名称 仅需内网访问 12listeners=PLAINTEXT://0.0.0.0:9092advertised.listeners=PLAINTEXT://worker1:9092 # 这里是内网ip 允许外网访问 12listeners=PLAINTEXT://0.0.0.0:9092advertised.listeners=PLAINTEXT://161.189.227.200:9092 # 这里是外网ip 内外网都要访问（推荐双通道方式） 12345678# 这里 INTERNAL 和 EXTERNAL 分别是自定义的监听器名称，此时内网端口为 9092，外网端口为 9093listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093# 告诉客户端应该用哪个地址连接advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9093# 映射监听器名称到通信安全协议的映射关系listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT# 集群间通信仍使用内网inter.broker.listener.name=INTERNAL 开启 SASL_PLAINTEXT 这里设置外网访问时开启 SASL_PLAINTEXT 12345678910111213# 监听地址和端口，这里内网和外网分开配置listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9094# 客户端建立连接后实际返回给客户端的地址advertised.listeners=INTERNAL://worker1:9092,EXTERNAL://161.189.227.200:9094listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_PLAINTEXT# 集群间通信 still use INTERNALinter.broker.listener.name=INTERNAL# 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）# client 连接时sasl.enabled.mechanisms=PLAIN# broker 之间连接时，因为 inter.broker.listener.name=INTERNAL，所以 INTERNAL:SASL_PLAINTEXT 才有效#sasl.mechanism.inter.broker.protocol=PLAIN 创建 kafka_jaas.conf 123456789101112131415############################# Kafka Broker (服务端)############################KafkaServer &#123; # 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule required org.apache.kafka.common.security.plain.PlainLoginModule required # Broker 自己的身份（用于 broker 之间通信，本示例中没有使用） username=&quot;admin&quot; password=&quot;admin-secret&quot; # 客户端可用账号，即 user_xxx，这里 xxx 为用户名，= 右边的为密码 user_admin=&quot;admin-secret&quot; user_alice=&quot;alice-secret&quot; user_bob=&quot;bob-secret&quot;;&#125;; 启动 kafka 123# 在启动 Kafka Broker 前，设置环境变量指向 JAAS 文件export KAFKA_OPTS=&quot;-Djava.security.auth.login.config=/usr/local/kafka/kafka3/config/kafka_jaas.conf&quot;kafka-server-start.sh config/server.properties 客户端访问 创建 client.conf 12345security.protocol=SASL_PLAINTEXT# 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致sasl.mechanism=PLAIN# 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule requiredsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;admin&quot; password=&quot;admin-secret&quot;; 命令行访问 12345678# 创建topickafka-topics.sh --create --topic test-topic --bootstrap-server=161.189.227.200:9094 --command-config=client.conf# 查看topickafka-topics.sh --list --bootstrap-server=161.189.227.200:9094 --command-config=client.conf# 创建消费者，--group 指定消费者组名称kafka-console-consumer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --consumer.config=client.conf --group=test-group# 创建生产者kafka-console-producer.sh --bootstrap-server=161.189.227.200:9094 --topic test-topic --producer.config=client.conf 开启 SASL_SSL 这里设置外网访问时开启 SASL_SSL 创建证书 官方文档 生成 Broker keystore，用于 存储 broker 的私钥和证书。 1234567891011121314keytool -keystore kafka.server.keystore.jks \\ -alias broker -validity 3650 \\ -genkey -keyalg RSA \\ -dname &quot;CN=broker, OU=Kafka, O=YourOrg, L=City, ST=State, C=CN&quot; \\ -storepass 123456 \\ -keypass 123456## 参数说明：# -keystore：生成的 keystore 文件路径# -alias broker：证书别名# -validity 3650：有效期 3650 天# -keyalg RSA：密钥算法# -dname：证书信息# -storepass：keystore 密码# -keypass：密钥密码 导出 Broker 证书（用于客户端 truststore）,生成 kafka.server.crt，客户端会用它来验证 broker。 12345678keytool -keystore kafka.server.keystore.jks \\ -alias broker -export -file kafka.server.crt \\ -storepass 123456## 参数说明：# -keystore：keystore 文件路径# -alias broker：证书别名# -file kafka.server.crt：导出的证书文件路径# -storepass：keystore 密码 生成 Broker truststore，truststore 用于 存储信任的证书（这里把自己生成的证书导入进去即可）,生成 kafka.truststore.jks 12345678910# 注意：这里 server 端 和 client 端 可以共用一个 truststore，也可以分别创建keytool -keystore kafka.truststore.jks \\ -alias broker -import -file kafka.server.crt \\ -storepass 123456 -noprompt# 参数说明：# -keystore：生成的 truststore 文件路径# -alias broker：证书别名# -file kafka.server.crt：导入的证书文件路径# -storepass：truststore 密码# -noprompt：不提示 server.properties 配置 SASL_SSL 1234567891011121314151617181920212223# 监听地址和端口，这里内网和外网分开配置listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095# 客户端建立连接后实际返回给客户端的地址advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSLinter.broker.listener.name=INTERNAL# SASL# 认证机制（常见为 PLAIN，也可以是 SCRAM-SHA-256 或者 SCRAM-SHA-512）# client 连接时sasl.enabled.mechanisms=PLAIN# broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效#sasl.mechanism.inter.broker.protocol=PLAIN# SSLssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/kafka.server.keystore.jksssl.keystore.password=123456ssl.key.password=123456ssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/kafka.truststore.jksssl.truststore.password=123456# 如果不要求客户端证书，可以设置 none ，要求则设置为 requiredssl.client.auth=none 启动 kafka 前同样需要先创建好 kafka_jaas.conf，与 SASL_PLAINTEXT 一样。 客户端访问 将 kafka.truststore.jks 拷贝到客户端 与 SASL_PLAINTEXT 一样，创建 client.conf，并添加如下信息 1234567891011security.protocol=SASL_SSL# 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致sasl.mechanism=PLAIN# 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule requiredsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;admin&quot; password=&quot;admin-secret&quot;;# SSL 配置ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/kafka.truststore.jksssl.truststore.password=123456# 禁用主机名验证，否则会校验证书的 SAN，证书域名校验开关，为空则表示关闭，这里需要保持关闭状态，必须设置为空ssl.endpoint.identification.algorithm= 命令行访问 与 SASL_PLAINTEXT 一样，这里不再赘述 关于 Kafka JKS格式的SSL证书的创建及配置可以参考制作和替换Kafka JKS格式的SSL证书 PEM 证书 Kafka 的 证书 默认使用 JKS 格式，但从 2.7.0 开始支持 PEM 格式 123456789101112131415161718192021222324# 监听地址和端口，这里内网和外网分开配置listeners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9095# 客户端建立连接后实际返回给客户端的地址advertised.listeners=INTERNAL://worker2:9092,EXTERNAL://161.189.227.200:9095listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SASL_SSLinter.broker.listener.name=INTERNAL# SASL# 认证机制（常见为 PLAIN，也可以是 CRAM-SHA-256、SCRAM-SHA-512）# client 连接时sasl.enabled.mechanisms=PLAIN# broker 之间连接时，需要 inter.broker.listener.name=SASL_PLAINTEXT 才有效#sasl.mechanism.inter.broker.protocol=PLAIN# SSL-PEMssl.keystore.type=PEM # 指定证书类型是PEM，支持的类型 PEM、JKSssl.keystore.location=/usr/local/kafka/kafka3/config/ssl/fullchain.pem # 包含私钥和公钥# 指定客户端使用的证书类型是PEMssl.truststore.type=PEMssl.truststore.location=/usr/local/kafka/kafka3/config/ssl/server.crt # 公钥# 如果不要求客户端证书，可以设置 none ，要求则设置为 requiredssl.client.auth=none client.conf 配置如下： 123456789101112security.protocol=SASL_SSL# 认证机制，支持 PLAIN、SCRAM-SHA-256、SCRAM-SHA-512，要与 服务端一致sasl.mechanism=PLAIN# 如果使用 SCRAM-SHA-256 或者 SCRAM-SHA-512 认证，则需要配置 为 org.apache.kafka.common.security.scram.ScramLoginModule requiredsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;admin&quot; password=&quot;admin-secret&quot;;# SSL 配置，将 server 端的 server.crt 拷贝到 client 端ssl.truststore.location=/Users/hanqf/develop_soft/kafka/kafka3/config/ssl/server.crtssl.truststore.type=PEM# 禁用主机名验证ssl.endpoint.identification.algorithm= jks 证书转换为 pem 格式 从 JKS 导出为 PKCS#12 (.p12) 1234567891011121314keytool -importkeystore \\ -srckeystore kafka.server.keystore.jks \\ -srcstoretype JKS \\ -destkeystore kafka.server.p12 \\ -deststoretype PKCS12 \\ -srcstorepass 123456 \\ -deststorepass 123456 \\ -J&quot;-Djdk.tls.disabledAlgorithms=&quot; \\ -J&quot;-Dkeystore.pkcs12.legacy=false&quot;## 说明： # -srcstoretype JKS：原始格式； # -deststoretype PKCS12：转换为通用格式； # .p12 是 PEM 的“中间格式”。 导出证书[公钥] (.crt，这里是 PEM 格式) 12345678openssl pkcs12 -in kafka.server.p12 -clcerts -nokeys -out server.crt -password pass:123456 -provider legacy -provider default## 说明：# -clcerts：只导出证书；# -nokeys：不导出密钥；# -out server.crt：导出文件名；# -password：kafka.server.p12的密钥密码，注意密码前面加上 pass:# -provider legacy：启用旧算法支持模块，在 OpenSSL 3.0（及更高版本）中，引入了一个新机制 —— Provider（算法提供者）,默认情况下，OpenSSL 只加载 modern provider（default provider），而许多老旧算法（例如 RC2、MD5、DES、SHA1）被移到了一个单独的 legacy provider 模块中。# -provider default：同时启用默认 provider，因为有些命令（比如涉及现代加密算法或证书签名）还依赖默认 provider，所以两者一起使用最安全、最兼容 导出私钥 (.key，这里是 PEM 格式) 123456openssl pkcs12 -in kafka.server.p12 -nocerts -out server.key -nodes -password pass:123456 -provider legacy -provider default## 说明：# -nocerts：只导出密钥；# -out server.key：导出文件名；# -nodes：不加密导出的密钥文件# -password：kafka.server.p12的密钥密码，注意密码前面加上 pass: fullchain.pem 1openssl pkcs12 -in kafka.server.p12 -out fullchain.pem -nodes -password pass:123456 -provider legacy -provider default","summary":"摘要 本文介绍 Kafka 的 通信协议，以及如何开启外网访问。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。","date_published":"2025-10-13T14:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/10/13/kafka-01-install-zookeeper/","url":"https://blog.hanqunfeng.com/2025/10/13/kafka-01-install-zookeeper/","title":"Kafka 的安装：基于 Zookeeper","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 CentOS9 中 Kafka 的安装与使用，基于 Zookeeper。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kafka.apache.org\">Kafka官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Kafka-简介\">Kafka 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Apache Kafka 是一个 <code>分布式的流处理/事件流平台</code>，既可以作为<code>消息系统</code>，也可以作为持久化的 <code>日志/记录存储与流处理平台</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的设计目标是高吞吐、低延迟、可水平扩展、容错，以及可持久化数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 Kafka 中，消息被归类为 <code>主题（Topic）</code>，每个主题可以根据配置被拆分为多个 <code>分区（Partition）</code>，每个分区内部消息是<code>严格有序</code>的，并以<code>追加</code>方式写入。消费者可以按<code>偏移量（offset）</code>读取消息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 提供多个 API：Producer、Consumer、Streams（流处理）、Connect（与外部系统整合）等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 的核心架构要素与工作机制</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>组件 / 概念</th>\n<th>作用 / 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Broker（节点 / 服务器）</td>\n<td>Kafka 集群中的服务器实例，负责接收、存储、分发消息</td>\n</tr>\n<tr>\n<td>Topic</td>\n<td>消息的“分类”逻辑单元，Producer 写入、Consumer 读取</td>\n</tr>\n<tr>\n<td>Partition</td>\n<td>一个 Topic 被划分的子单元。分区使得主题可以横向扩展，并支持并行读写</td>\n</tr>\n<tr>\n<td>Offset</td>\n<td>每条消息在某个分区中的唯一位置标识，消费者根据 offset 来决定下一条读取</td>\n</tr>\n<tr>\n<td>Replication（副本）</td>\n<td>为了容错性，每个分区可以有多个副本（副本分布在不同 Broker 上）</td>\n</tr>\n<tr>\n<td>Leader / Follower</td>\n<td>在副本中，一个副本为 Leader，接受读写请求；其他为 Follower，从 Leader 同步数据</td>\n</tr>\n<tr>\n<td>Consumer Group</td>\n<td>一组消费者共同消费一个 Topic。每个分区在同一个消费者组中通常只被一个消费者 “拥有”</td>\n</tr>\n<tr>\n<td>ZooKeeper / KRaft</td>\n<td>用于元数据管理、集群协调（在较老版本中是 ZooKeeper；新版本推向 KRaft）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/Xe43JY.png\" alt=\"\" width=\"900\" height=\"600\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消息写入流程（简化）：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Producer 将消息发送给某个 Topic 的 Leader 分区节点</li>\n<li class=\"lvl-4\">Leader 接收到消息后，将其追加写入本地日志，并返回确认（ACK）</li>\n<li class=\"lvl-4\">Follower 副本从 Leader 拉取数据进行同步</li>\n<li class=\"lvl-4\">消费者根据自己的 offset 从对应 Partition 中读取消息</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>消费控制与容错：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">消费者维护自己的 offset（可以自动提交，也可手动控制），这样即使消费者重启，也可以从上次停止的位置继续。</li>\n<li class=\"lvl-4\">如果某个 Broker 宕机，副本可以切换（Leader 选举），保证服务继续。</li>\n<li class=\"lvl-4\">分区与副本机制使得 Kafka 能够扩展容量 &amp; 提高可靠性。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 的典型使用场景</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景类别</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>实时数据管道 / 数据集成</strong></td>\n<td>用于将各种数据源（如日志、数据库变更、传感器、用户事件等）实时采集、传输、分发到下游系统（如 OLAP、搜索引擎、监控平台等），构建高效的数据通道。</td>\n</tr>\n<tr>\n<td><strong>事件驱动 / 事件溯源</strong></td>\n<td>记录系统内部或跨系统的事件（状态变化），实现事件驱动架构（EDA）或事件溯源（Event Sourcing），可用于审计、回放、状态重建等。</td>\n</tr>\n<tr>\n<td><strong>日志聚合 / 分析</strong></td>\n<td>将分布式系统中的应用日志、监控指标、操作日志等统一收集到 Kafka 中，集中存储与分析，常与 ELK、ClickHouse 等结合。</td>\n</tr>\n<tr>\n<td><strong>流处理</strong></td>\n<td>与 Kafka Streams、Apache Flink、Spark Streaming 等流处理框架配合，对流经 Kafka 的数据进行实时计算、聚合、过滤、窗口统计等操作。</td>\n</tr>\n<tr>\n<td><strong>系统解耦 / 异步通信</strong></td>\n<td>作为系统间的消息中间件，实现发布-订阅模式，减少系统间耦合，支持异步通信、流量削峰、缓冲等，提升系统稳定性与扩展性。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Kafka-安装\">Kafka 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里先介绍基于 Zookeeper 的安装方式，下文会介绍基于 KRaft 的安装方式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kafka 3.9.1 的安装与运行需要 JDK 8+，所有我们需要提前安装 JDK 8+。可以选择OpenJDK，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/Adoptium/\">清华大学镜像站</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># root 用户</span></span><br><span class=\"line\"><span class=\"comment\"># 创建安装目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/jdk</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/jdk</span><br><span class=\"line\"><span class=\"comment\"># 下载JDK</span></span><br><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/Adoptium/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gz</span><br><span class=\"line\">tar -zxvf OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s jdk8u462-b08 jdk8</span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export JAVA_HOME=/usr/local/jdk/jdk8&#x27;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 注意这里是 单引号，双引号会解析变量，导致配置失败</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$JAVA_HOME/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 检查JDK安装</span></span><br><span class=\"line\">java -version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装过程参考官网文档<a href=\"https://kafka.apache.org/39/documentation.html#quickstart\">Kafka Quick Start</a>。</p>\n</li>\n</ul>\n<h3 id=\"单机安装\">单机安装</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>部署kafka都会使用集群模式，单机模式只作为学习试用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>下载Kafka，<a href=\"https://kafka.apache.org/downloads\">下载页面</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># root 用户</span></span><br><span class=\"line\"><span class=\"comment\"># 创建安装目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /usr/local/kafka</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/kafka</span><br><span class=\"line\"><span class=\"comment\"># 下载Kafka</span></span><br><span class=\"line\">wget https://dlcdn.apache.org/kafka/3.9.1/kafka_2.13-3.9.1.tgz</span><br><span class=\"line\">tar -zxvf kafka_2.13-3.9.1.tgz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s kafka_2.13-3.9.1 kafka3</span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export KAFKA_HOME=/usr/local/kafka/kafka3&#x27;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$KAFKA_HOME/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 查看Kafka版本</span></span><br><span class=\"line\">kafka-topics.sh --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 Zookeeper，kafka内置了zookeeper，所以不需要单独安装。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前台运行</span></span><br><span class=\"line\">zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties</span><br><span class=\"line\"><span class=\"comment\"># 后台运行</span></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties &gt; zookeeper.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭zookeeper，kill进程，过滤 java &amp; QuorumPeerMain</span></span><br><span class=\"line\">zookeeper-server-stop.sh</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动 kafka</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -daemon 后台运行</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查kafka是否启动成功</span></span><br><span class=\"line\">jps -l | grep kafka</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止 kafka，kill进程，过滤 java &amp; &#x27;kafka\\.Kafka&#x27;</span></span><br><span class=\"line\">kafka-server-stop.sh</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">注意：默认情况下 启动 kafka 需要的内存大小为 1G，这一点可以在 <a href=\"http://kafka-server-start.sh\">kafka-server-start.sh</a> 脚本中查看到</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;x<span class=\"variable\">$KAFKA_HEAP_OPTS</span>&quot;</span> = <span class=\"string\">&quot;x&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">export</span> KAFKA_HEAP_OPTS=<span class=\"string\">&quot;-Xmx1G -Xms1G&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">所以如果内存不够，可以设置环境变量后再启动kafka</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_HEAP_OPTS=<span class=\"string\">&quot;-Xmx512M -Xms512M&quot;</span></span><br><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 topic</span></span><br><span class=\"line\">kafka-topics.sh --create --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动消费者</span></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --from-beginning</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动生产者</span></span><br><span class=\"line\">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; hello world <span class=\"comment\"># 输入内容，消费者会收到</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"集群安装\">集群安装</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群安装需要准备多个节点，这里我准备三个节点，分别如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.7</span><br><span class=\"line\">10.250.0.174</span><br><span class=\"line\">10.250.0.108</span><br></pre></td></tr></table></figure>\n<h4 id=\"搭建-Zookeeper-集群\">搭建 Zookeeper 集群</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于如何搭建 Zookeeper 集群，可以参考我之前的文章 <a href=\"/2025/09/15/zookeeper-study/\" title=\"Zookeeper 的安装及使用\">Zookeeper 的安装及使用</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>如果图省事也可以直接使用 Kafka 自带的 zookeeper，编辑其配置文件 <code>config/zookeeper.properties</code>如下，注意要在 <code>dataDir</code> 目录下创建<code>myid</code>文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataDir=/usr/local/kafka/dataDir/zookeeper</span><br><span class=\"line\"><span class=\"comment\"># the port at which the clients will connect</span></span><br><span class=\"line\">clientPort=2181</span><br><span class=\"line\"><span class=\"comment\"># disable the per-ip limit on the number of connections since this is a non-production config</span></span><br><span class=\"line\">maxClientCnxns=0</span><br><span class=\"line\"><span class=\"comment\"># Disable the adminserver by default to avoid port conflicts.</span></span><br><span class=\"line\"><span class=\"comment\"># Set the port to something non-conflicting if choosing to enable this</span></span><br><span class=\"line\">admin.enableServer=<span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\"># admin.serverPort=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\">initLimit=10</span><br><span class=\"line\">syncLimit=5</span><br><span class=\"line\"></span><br><span class=\"line\">server.1=10.250.0.7:2888:3888</span><br><span class=\"line\">server.2=10.250.0.174:2888:3888</span><br><span class=\"line\">server.3=10.250.0.108:2888:3888</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置-Kafka-集群\">配置 Kafka 集群</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改主机的主机名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hostnamectl hostname worker1</span><br><span class=\"line\"><span class=\"comment\"># hostnamectl hostname worker2</span></span><br><span class=\"line\"><span class=\"comment\"># hostnamectl hostname worker3</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了后续方便维护，将ip地址映射到 hosts 文件中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.7 worker1</span><br><span class=\"line\">10.250.0.174 worker2</span><br><span class=\"line\">10.250.0.108 worker3</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编辑 <code>config/server.properties</code> 文件，需要修改如下配置项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#broker 的全局唯⼀编号，不能重复，只能是数字。</span></span><br><span class=\"line\">broker.id=1 <span class=\"comment\"># 这里分别设置为1、2、3</span></span><br><span class=\"line\"><span class=\"comment\">#服务监听地址</span></span><br><span class=\"line\">listeners=PLAINTEXT://worker1:9092</span><br><span class=\"line\"><span class=\"comment\">#数据⽂件地址。同样默认是给的/tmp⽬录。</span></span><br><span class=\"line\">log.dirs=/usr/local/kafka/dataDir/kafka-logs</span><br><span class=\"line\"><span class=\"comment\">#默认的每个Topic的分区数，创建Topic时，如果未指定分区数，则默认为1个分区。</span></span><br><span class=\"line\">num.partitions=1</span><br><span class=\"line\"><span class=\"comment\"># 每个⽇志⽂件删除之前保存的时间，默认是168小时，即7天。</span></span><br><span class=\"line\">log.retention.hours=168</span><br><span class=\"line\"><span class=\"comment\">#zookeeper的服务地址，如果是自建的 Zookeeper 集群，则这里需要填写集群的连接地址</span></span><br><span class=\"line\">zookeeper.connect=worker1:2181,worker2:2181,worker3:2181</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别在三个节点上启动 Kafka</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 topic</span></span><br><span class=\"line\">kafka-topics.sh --bootstrap-server worker1:9092 --create --replication-factor 3 --partitions 3 --topic disTopic</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --replication-factor 3 表示创建的副本数</span></span><br><span class=\"line\"><span class=\"comment\"># --partitions 3 表示创建的分区数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 topic 详情</span></span><br><span class=\"line\">kafka-topics.sh --bootstrap-server worker1:9092 --describe --topic disTopic</span><br><span class=\"line\">Topic: disTopic\tTopicId: VUK7Mc9oQdS1mjGG7OhQzQ\tPartitionCount: 3\tReplicationFactor: Configs:</span><br><span class=\"line\">\tTopic: disTopic\tPartition: 0\tLeader: 2\tReplicas: 2,3,1\tIsr: 2,3,1\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: disTopic\tPartition: 1\tLeader: 3\tReplicas: 3,1,2\tIsr: 3,1,2\tElr: N/A\tLastKnownElr: N/A</span><br><span class=\"line\">\tTopic: disTopic\tPartition: 2\tLeader: 1\tReplicas: 1,2,3\tIsr: 1,2,3\tElr: N/A\tLastKnownElr: N/A</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 Zookeeper。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。 Kafka 简介 Apache Kafka 是一个 分布式的流处理/事件流平台，既可以作为消息系统，也可以作为持久化的 日志/记录存储与流处理平台。 它的设计目标是高吞吐、低延迟、可水平扩展、容错，以及可持久化数据。 在 Kafka 中，消息被归类为 主题（Topic），每个主题可以根据配置被拆分为多个 分区（Partition），每个分区内部消息是严格有序的，并以追加方式写入。消费者可以按偏移量（offset）读取消息。 Kafka 提供多个 API：Producer、Consumer、Streams（流处理）、Connect（与外部系统整合）等。 Kafka 的核心架构要素与工作机制 组件 / 概念 作用 / 描述 Broker（节点 / 服务器） Kafka 集群中的服务器实例，负责接收、存储、分发消息 Topic 消息的“分类”逻辑单元，Producer 写入、Consumer 读取 Partition 一个 Topic 被划分的子单元。分区使得主题可以横向扩展，并支持并行读写 Offset 每条消息在某个分区中的唯一位置标识，消费者根据 offset 来决定下一条读取 Replication（副本） 为了容错性，每个分区可以有多个副本（副本分布在不同 Broker 上） Leader / Follower 在副本中，一个副本为 Leader，接受读写请求；其他为 Follower，从 Leader 同步数据 Consumer Group 一组消费者共同消费一个 Topic。每个分区在同一个消费者组中通常只被一个消费者 “拥有” ZooKeeper / KRaft 用于元数据管理、集群协调（在较老版本中是 ZooKeeper；新版本推向 KRaft） 消息写入流程（简化）： Producer 将消息发送给某个 Topic 的 Leader 分区节点 Leader 接收到消息后，将其追加写入本地日志，并返回确认（ACK） Follower 副本从 Leader 拉取数据进行同步 消费者根据自己的 offset 从对应 Partition 中读取消息 消费控制与容错： 消费者维护自己的 offset（可以自动提交，也可手动控制），这样即使消费者重启，也可以从上次停止的位置继续。 如果某个 Broker 宕机，副本可以切换（Leader 选举），保证服务继续。 分区与副本机制使得 Kafka 能够扩展容量 &amp; 提高可靠性。 Kafka 的典型使用场景 场景类别 说明 实时数据管道 / 数据集成 用于将各种数据源（如日志、数据库变更、传感器、用户事件等）实时采集、传输、分发到下游系统（如 OLAP、搜索引擎、监控平台等），构建高效的数据通道。 事件驱动 / 事件溯源 记录系统内部或跨系统的事件（状态变化），实现事件驱动架构（EDA）或事件溯源（Event Sourcing），可用于审计、回放、状态重建等。 日志聚合 / 分析 将分布式系统中的应用日志、监控指标、操作日志等统一收集到 Kafka 中，集中存储与分析，常与 ELK、ClickHouse 等结合。 流处理 与 Kafka Streams、Apache Flink、Spark Streaming 等流处理框架配合，对流经 Kafka 的数据进行实时计算、聚合、过滤、窗口统计等操作。 系统解耦 / 异步通信 作为系统间的消息中间件，实现发布-订阅模式，减少系统间耦合，支持异步通信、流量削峰、缓冲等，提升系统稳定性与扩展性。 Kafka 安装 这里先介绍基于 Zookeeper 的安装方式，下文会介绍基于 KRaft 的安装方式。 Kafka 3.9.1 的安装与运行需要 JDK 8+，所有我们需要提前安装 JDK 8+。可以选择OpenJDK，清华大学镜像站 123456789101112131415# root 用户# 创建安装目录mkdir /usr/local/jdkcd /usr/local/jdk# 下载JDKwget https://mirrors.tuna.tsinghua.edu.cn/Adoptium/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gztar -zxvf OpenJDK8U-jdk_x64_linux_hotspot_8u462b08.tar.gzln -s jdk8u462-b08 jdk8# 配置环境变量echo &#x27;export JAVA_HOME=/usr/local/jdk/jdk8&#x27; &gt;&gt; /etc/profile# 注意这里是 单引号，双引号会解析变量，导致配置失败echo &#x27;export PATH=$JAVA_HOME/bin:$PATH&#x27; &gt;&gt; /etc/profilesource /etc/profile# 检查JDK安装java -version 安装过程参考官网文档Kafka Quick Start。 单机安装 部署kafka都会使用集群模式，单机模式只作为学习试用。 下载Kafka，下载页面 1234567891011121314# root 用户# 创建安装目录mkdir /usr/local/kafkacd /usr/local/kafka# 下载Kafkawget https://dlcdn.apache.org/kafka/3.9.1/kafka_2.13-3.9.1.tgztar -zxvf kafka_2.13-3.9.1.tgzln -s kafka_2.13-3.9.1 kafka3# 配置环境变量echo &#x27;export KAFKA_HOME=/usr/local/kafka/kafka3&#x27; &gt;&gt; /etc/profileecho &#x27;export PATH=$KAFKA_HOME/bin:$PATH&#x27; &gt;&gt; /etc/profilesource /etc/profile# 查看Kafka版本kafka-topics.sh --version 启动 Zookeeper，kafka内置了zookeeper，所以不需要单独安装。 1234567# 前台运行zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties# 后台运行nohup zookeeper-server-start.sh /usr/local/kafka/kafka3/config/zookeeper.properties &gt; zookeeper.log 2&gt;&amp;1 &amp;# 关闭zookeeper，kill进程，过滤 java &amp; QuorumPeerMainzookeeper-server-stop.sh 启动 kafka 12345678# -daemon 后台运行kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties# 检查kafka是否启动成功jps -l | grep kafka# 停止 kafka，kill进程，过滤 java &amp; &#x27;kafka\\.Kafka&#x27;kafka-server-stop.sh 小贴士 注意：默认情况下 启动 kafka 需要的内存大小为 1G，这一点可以在 kafka-server-start.sh 脚本中查看到 123if [ &quot;x$KAFKA_HEAP_OPTS&quot; = &quot;x&quot; ]; then export KAFKA_HEAP_OPTS=&quot;-Xmx1G -Xms1G&quot;fi 所以如果内存不够，可以设置环境变量后再启动kafka 12export KAFKA_HEAP_OPTS=&quot;-Xmx512M -Xms512M&quot;kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties 测试 123456789# 创建 topickafka-topics.sh --create --bootstrap-server localhost:9092 --topic test# 启动消费者kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning# 启动生产者kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test&gt; hello world # 输入内容，消费者会收到 集群安装 集群安装需要准备多个节点，这里我准备三个节点，分别如下： 12310.250.0.710.250.0.17410.250.0.108 搭建 Zookeeper 集群 关于如何搭建 Zookeeper 集群，可以参考我之前的文章 Zookeeper 的安装及使用 如果图省事也可以直接使用 Kafka 自带的 zookeeper，编辑其配置文件 config/zookeeper.properties如下，注意要在 dataDir 目录下创建myid文件 12345678910111213141516dataDir=/usr/local/kafka/dataDir/zookeeper# the port at which the clients will connectclientPort=2181# disable the per-ip limit on the number of connections since this is a non-production configmaxClientCnxns=0# Disable the adminserver by default to avoid port conflicts.# Set the port to something non-conflicting if choosing to enable thisadmin.enableServer=false# admin.serverPort=8080initLimit=10syncLimit=5server.1=10.250.0.7:2888:3888server.2=10.250.0.174:2888:3888server.3=10.250.0.108:2888:3888 配置 Kafka 集群 修改主机的主机名 123hostnamectl hostname worker1# hostnamectl hostname worker2# hostnamectl hostname worker3 为了后续方便维护，将ip地址映射到 hosts 文件中 12310.250.0.7 worker110.250.0.174 worker210.250.0.108 worker3 编辑 config/server.properties 文件，需要修改如下配置项 123456789101112#broker 的全局唯⼀编号，不能重复，只能是数字。broker.id=1 # 这里分别设置为1、2、3#服务监听地址listeners=PLAINTEXT://worker1:9092#数据⽂件地址。同样默认是给的/tmp⽬录。log.dirs=/usr/local/kafka/dataDir/kafka-logs#默认的每个Topic的分区数，创建Topic时，如果未指定分区数，则默认为1个分区。num.partitions=1# 每个⽇志⽂件删除之前保存的时间，默认是168小时，即7天。log.retention.hours=168#zookeeper的服务地址，如果是自建的 Zookeeper 集群，则这里需要填写集群的连接地址zookeeper.connect=worker1:2181,worker2:2181,worker3:2181 分别在三个节点上启动 Kafka 1kafka-server-start.sh -daemon /usr/local/kafka/kafka3/config/server.properties 测试 123456789101112# 创建 topickafka-topics.sh --bootstrap-server worker1:9092 --create --replication-factor 3 --partitions 3 --topic disTopic## 参数说明# --replication-factor 3 表示创建的副本数# --partitions 3 表示创建的分区数# 查看 topic 详情kafka-topics.sh --bootstrap-server worker1:9092 --describe --topic disTopicTopic: disTopic TopicId: VUK7Mc9oQdS1mjGG7OhQzQ PartitionCount: 3 ReplicationFactor: Configs: Topic: disTopic Partition: 0 Leader: 2 Replicas: 2,3,1 Isr: 2,3,1 Elr: N/A LastKnownElr: N/A Topic: disTopic Partition: 1 Leader: 3 Replicas: 3,1,2 Isr: 3,1,2 Elr: N/A LastKnownElr: N/A Topic: disTopic Partition: 2 Leader: 1 Replicas: 1,2,3 Isr: 1,2,3 Elr: N/A LastKnownElr: N/A","summary":"摘要 本文介绍 CentOS9 中 Kafka 的安装与使用，基于 Zookeeper。 Kafka官网 本文使用的 Kafka 版本为 3.9.1。Kafka 团队宣布 3.9 会是 最后一个还带有被弃用的 ZooKeeper 模式 的主要版本。以后版本（如 4.0）将完全弃用 ZooKeeper。","date_published":"2025-10-13T13:30:05.000Z","tags":["技术","kafka","分布式","kafka"]},{"id":"https://blog.hanqunfeng.com/2025/09/25/rabbitmq-cluster/","url":"https://blog.hanqunfeng.com/2025/09/25/rabbitmq-cluster/","title":"RabbitMQ 之 Cluster","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RabbitMQ 的 Cluster 的基本概念和用法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.rabbitmq.com\">Zookeeper官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RabbitMQ 版本为 4.1.4。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo\">Java Client 示例</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RabbitMQ-Cluster-集群-简介\">RabbitMQ Cluster(集群) 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 RabbitMQ 中，<a href=\"https://www.rabbitmq.com/docs/clustering\">Cluster（集群）</a> 是多个节点组成的集合，用于实现高可用和负载均衡。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RabbitMQ 集群是一个或多个（三个、五个、七个或更多）节点的逻辑分组， 每个节点共享 用户、虚拟主机、队列、流、交换、绑定、运行时参数和其他分布式状态。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 RabbitMQ 中，Cluster（集群）的节点分为两种：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">磁盘节点(disk)：会把集群的所有元数据信息（比如交换机、绑定、队列、虚拟主机等信息）持久化到磁盘中。Master 节点必须是磁盘节点。</li>\n<li class=\"lvl-4\">内存节点(ram)：只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失。Slave 节点可以是内存节点。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>RabbitMQ 4.0 开始， 集群不再区分 <code>普通集群模式（Classic Cluster）</code> 与 <code>镜像集群模式（Mirrored Queue Cluster）</code> ，集群创建好后，会根据队列的<code>初始复制因子参数</code>决定为该队列创建多少个副本，比如 <code>Quroum Queue</code> 的参数是 <code>x-quorum-initial-group-size</code>，默认为3。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RabbitMQ 4.0 开始，<code>Quroum Queue</code> 和 <code>Stream Queue</code> 默认开启节点间<code>消息复制</code>，但是 <code>Classic Queue</code> 队列不支持节点间的<code>消息复制</code>;</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>RabbitMQ 4.0以前的 集群分为两种模式</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">普通集群模式（Classic Cluster）</li>\n</ol>\n<ul class=\"lvl-3\">\n<li class=\"lvl-4\">在 普通集群模式下，RabbitMQ 节点通过 Erlang 分布式系统实现互联，集群内的各个节点共享 消息队列、交换机、绑定等元素。</li>\n<li class=\"lvl-4\">普通集群的特点：\n<ul class=\"lvl-5\">\n<li class=\"lvl-6\">共享队列：队列数据仅存储在单一节点上，只有该节点可以处理队列中的消息。</li>\n<li class=\"lvl-6\">不自动复制数据：在普通集群中，消息并不会自动复制到其他节点。如果某个节点挂掉，队列上的消息就会丢失，无法恢复。</li>\n<li class=\"lvl-6\">负载均衡：交换机（Exchange）会把消息发送到不同的队列，但队列数据仍然只在一个节点上。因此，普通集群适合不要求极高可用性的场景。</li>\n<li class=\"lvl-6\">不具备高可用性：由于数据不会在集群的其他节点中复制，普通集群在某个节点宕机时，可能会导致消息丢失和系统不可用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">镜像集群模式（Mirrored Queue Cluster）</li>\n</ol>\n<ul class=\"lvl-3\">\n<li class=\"lvl-4\">镜像集群模式 是为了 高可用性 设计的，在该模式下，队列的数据会在集群中的多个节点上进行 复制（镜像），从而保证即使某个节点出现故障，数据也不会丢失。</li>\n<li class=\"lvl-4\">镜像集群的特点：\n<ul class=\"lvl-5\">\n<li class=\"lvl-6\">队列镜像：在镜像集群模式中，队列数据会在集群中的多个节点上复制。每个队列都有一个主节点和多个镜像节点。</li>\n<li class=\"lvl-6\">高可用性：消息会被复制到集群的其他节点上，从而保证如果一个节点宕机，数据不会丢失，系统能迅速恢复。</li>\n<li class=\"lvl-6\">节点故障恢复：当一个节点挂掉时，其他节点会继续处理该队列的消息，保证业务的高可用性。</li>\n<li class=\"lvl-6\">网络负担较重：由于需要在多个节点之间进行数据同步和复制，所以镜像队列模式会增加集群的网络负担和磁盘 I/O。</li>\n<li class=\"lvl-6\">性能影响：镜像队列模式会稍微影响性能，因为每次消息处理后，都需要将数据同步到其他镜像节点，增加了延迟。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"集群搭建\">集群搭建</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>准备三台服务器，分别安装 RabbitMQ ，安装方法参看 <a href=\"/2025/09/18/rabbitmq-install-01/\" title=\"RabbitMQ 的安装及使用\">RabbitMQ 的安装及使用</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>开放端口</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>端口范围</strong></th>\n<th><strong>用途</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>4369</strong></td>\n<td>epmd（Erlang Port Mapper Daemon）</td>\n<td>RabbitMQ 节点和 CLI 工具使用的帮助程序发现守护进程。</td>\n</tr>\n<tr>\n<td><strong>6000-6500</strong></td>\n<td>RabbitMQ Stream 复制使用</td>\n<td>用于 RabbitMQ Stream 的数据复制。</td>\n</tr>\n<tr>\n<td><strong>25672</strong></td>\n<td>Erlang 分发服务器端口</td>\n<td>用于节点间和 CLI 工具通信，默认情况下仅限于单个端口（AMQP端口 + 20000）。</td>\n</tr>\n<tr>\n<td><strong>35672-35682</strong></td>\n<td>Erlang 分发客户端端口</td>\n<td>用于 CLI 工具与节点通信，计算为服务器分发端口 + 10000 到 服务器分发端口 + 10010。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别修改三台服务器的 <code>hostname</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hostnamectl hostname rabbitmq01</span><br><span class=\"line\"><span class=\"comment\"># hostnamectl hostname rabbitmq02</span></span><br><span class=\"line\"><span class=\"comment\"># hostnamectl hostname rabbitmq03</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别修改三台服务器的 <code>/etc/hosts</code> 文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.56  rabbitmq01</span><br><span class=\"line\">10.250.0.232 rabbitmq02</span><br><span class=\"line\">10.250.0.97  rabbitmq03</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同步集群节点中的cookie</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">默认会在 <code>/var/lib/rabbitmq/</code>目录下生成一个<code>.erlang.cookie</code>，里面有一个字符串。</li>\n<li class=\"lvl-4\">我们使用 <code>rabbitmq01</code> 节点作为集群的主节点，其他节点作为集群的成员节点，我们要做的就是保证集群中三个节点的这个<code>cookie字符串一致</code>。</li>\n<li class=\"lvl-4\">将 <code>rabbitmq01</code> 的 <code>/var/lib/rabbitmq/.erlang.cookie</code> 文件中的<code>cookie字符串</code>复制到其他节点的 <code>/var/lib/rabbitmq/.erlang.cookie</code> 文件中。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>分别启动三台服务器的 RabbitMQ 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别登录 <code>rabbitmq02</code> 和 <code>rabbitmq03</code> 节点，执行如下命令，将节点加入集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停掉rabbitmq应用</span></span><br><span class=\"line\">rabbitmqctl stop_app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置rabbitmq、交换机、队列</span></span><br><span class=\"line\">rabbitmqctl reset</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加入集群，注意此时 rabbitmq01 是主节点，必须处于运行状态，</span></span><br><span class=\"line\"><span class=\"comment\"># --ram 表示以 ram 内存节点 加入集群。如果不带参数默认为 disk 磁盘节点</span></span><br><span class=\"line\"><span class=\"comment\"># RabbitMQ的集群节点分为 disk 和 ram，disk节点会将元数据保存到硬盘当中，而ram节点只是在内存中保存元数据。</span></span><br><span class=\"line\">rabbitmqctl join_cluster rabbit@rabbitmq01 --ram</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动rabbitmq应用</span></span><br><span class=\"line\">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录 任意 节点，执行如下命令，查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl cluster_status</span><br><span class=\"line\"><span class=\"comment\">## 输出类似</span></span><br><span class=\"line\">Cluster status of node rabbit@rabbitmq01 ...</span><br><span class=\"line\">Basics</span><br><span class=\"line\"></span><br><span class=\"line\">Cluster name: rabbit@rabbitmq01</span><br><span class=\"line\">Total CPU cores available cluster-wide: 6</span><br><span class=\"line\"></span><br><span class=\"line\">Cluster Tags</span><br><span class=\"line\"></span><br><span class=\"line\">(none)</span><br><span class=\"line\"></span><br><span class=\"line\">Disk Nodes</span><br><span class=\"line\"></span><br><span class=\"line\">rabbit@rabbitmq01</span><br><span class=\"line\"></span><br><span class=\"line\">RAM Nodes</span><br><span class=\"line\"></span><br><span class=\"line\">rabbit@rabbitmq02</span><br><span class=\"line\">rabbit@rabbitmq03</span><br><span class=\"line\"></span><br><span class=\"line\">Running Nodes</span><br><span class=\"line\"></span><br><span class=\"line\">rabbit@rabbitmq01</span><br><span class=\"line\">rabbit@rabbitmq02</span><br><span class=\"line\">rabbit@rabbitmq03</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS: 由于ram节点减少了很多与硬盘的交互，所以，ram节点的元数据使用性能会比较高。但是，同时，这也意味着元数据的安全性是不如disk节点的。在我们这个集群中， rabbitmq02 和 rabbitmq03 都以 ram节点 的身份加入到 rabbitmq01 集群里，因此，是存在单点故障的。如果 rabbitmq01 节点服务崩溃，那么元数据就有可能丢失。在企业进行部署时，性能与安全性需要自己进行平衡。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录任意节点的管理页面，查看集群状态<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/R195gJ.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>此时我们在任意节点中创建虚拟主机、队列、交换机和绑定关系 等元数据，都会自动同步到其他节点中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们也可以在 管理控制台 中查看队列时看到，此时多个一列，<code>Node</code>列，显示该队列在哪些节点中存在。只有 <code>Quorum 队列</code> 和 <code>Stream 队列</code> 才会显示多个节点，因为 <code>Classic 队列</code> 不支持多节点复制。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/GjHcLN.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>查看某个具体的 <code>Quorum 队列</code> 或 <code>Stream 队列</code>，可以看到更详细的说明<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/XtIkpp.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>此时新建队列，会要求我们指定主节点(Leader)，即负责存储消息的的节点，而 <code>Quorum 队列</code> 或 <code>Stream 队列</code>，会自动将消息复制到其它节点(Members)。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Leader: 队列的主节点，负责存储消息。</li>\n<li class=\"lvl-4\">Members: 队列的成员节点，负责存储消息的副本。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"演示队列复制\">演示队列复制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认情况下，<code>Quorum 队列</code> 和 <code>Stream 队列</code> 的 复制数 都为 3，这里为了演示，我在增加一个节点 <code>rabbitmq04</code>，请自行按上面的方法添加。</p>\n</li>\n</ul>\n<h3 id=\"Quorum-队列\">Quorum 队列</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在页面上创建一个 <code>Quorum 队列</code>，与单节点上创建队列的区别就是需要我们选择主节点。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/JYfKgg.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>通过 客户端 创建队列时，默认情况下，连接哪个节点，哪个节点就是Leader，但也可以通过参数<code>x-queue-leader-locator</code>指定主节点的选择策略。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqadmin queues <span class=\"built_in\">declare</span> --vhost <span class=\"string\">&quot;/vtest&quot;</span> --name <span class=\"string\">&quot;target.quorum.queue.name&quot;</span> --<span class=\"built_in\">type</span> <span class=\"string\">&quot;quorum&quot;</span> --durable <span class=\"literal\">true</span> --arguments <span class=\"string\">&#x27;&#123;&quot;x-queue-leader-locator&quot;:&quot;balanced&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># x-queue-leader-locator 有两种选择策略</span></span><br><span class=\"line\"><span class=\"comment\">## client-local：选择声明队列的客户端所连接的节点。这是默认值。</span></span><br><span class=\"line\"><span class=\"comment\">## balanced：如果队列总数少于 1000 个（经典队列、仲裁队列和流）， 选择托管最小数量的仲裁队列领导者的节点。 如果队列总体超过 1000 个，则随机选择一个节点。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建成功后，可以看到 <code>Quorum 队列</code> 的主节点和成员节点，可以看到这里成员节点有三个，除了主节点外，其余节点由集群自动选择。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/qBfNNh.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>也就是说，默认情况下，<code>Quorum 队列</code> 的复制数是 <code>3</code>，如果我们希望改变复制数，可以在创建队列时指定参数 <code>x-quorum-initial-group-size</code>，其值为 <code>大于 0 的整数</code>，若设置值大于实际成员节点数，则以实际成员节点数为准。<code>x-quorum-initial-group-size</code> 设置为 <code>1</code> 时便不进行复制了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果集群中增加了新的节点，希望队列也被复制到新的节点中，可以通过如下命令，将新的节点加入成员节点中:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-queues add_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;</span></span><br><span class=\"line\">rabbitmq-queues add_member -p /vtest q_4 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果希望将节点从成员节点中移除，可以通过如下命令:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-queues delete_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;</span></span><br><span class=\"line\">rabbitmq-queues delete_member -p /vtest q_4 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>另外，当通过 <code>forget_cluster_node</code> 命令从集群中永久删除节点时，会自动将队列关联的节点从成员节点中移除。</p>\n</li>\n<li class=\"lvl-2\">\n<p>删除节点时，请使用如下命令:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 因为要删除 rabbitmq04 节点，所以以下命令不能在 rabbitmq04 节点执行</span></span><br><span class=\"line\"><span class=\"comment\"># 删除前需要先关闭应用</span></span><br><span class=\"line\">rabbitmqctl -n rabbit@rabbitmq04 stop_app</span><br><span class=\"line\"><span class=\"comment\"># 删除节点</span></span><br><span class=\"line\"><span class=\"comment\"># rabbitmqctl forget_cluster_node &lt;node&gt;</span></span><br><span class=\"line\">rabbitmqctl forget_cluster_node rabbit@rabbitmq04</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新增节点后，一个个的对原有的队列进行复制扩展非常麻烦，可以通过如下命令快速对符合条件的队列进行复制扩展:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-queues grow &lt;node&gt; &lt;all | even&gt; [--vhost-pattern &lt;pattern&gt;] [--queue-pattern &lt;pattern&gt;]</span></span><br><span class=\"line\"><span class=\"comment\">## 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;node&gt;: 这个参数指定了 RabbitMQ 节点的名称，通常是 rabbit@&lt;hostname&gt;。它表示在哪个节点上执行增长操作。</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;all | even&gt;: 这个参数指定了要扩展的队列类型。all 表示扩展所有队列，even 表示扩展偶数编号的队列。</span></span><br><span class=\"line\"><span class=\"comment\"># --vhost-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的虚拟主机名称。</span></span><br><span class=\"line\"><span class=\"comment\"># --queue-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的队列名称。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 扩展所有虚拟主机下的所有队列的副本：</span></span><br><span class=\"line\">rabbitmq-queues grow rabbit@rabbitmq04 all</span><br><span class=\"line\"><span class=\"comment\"># 扩展所有虚拟主机下的偶数编号的队列的副本：</span></span><br><span class=\"line\">rabbitmq-queues grow rabbit@rabbitmq04 even</span><br><span class=\"line\"><span class=\"comment\"># 扩展特定虚拟主机和队列名称的队列</span></span><br><span class=\"line\">rabbitmq-queues grow rabbit@rabbitmq04 all --vhost-pattern /vtest --queue-pattern <span class=\"string\">&quot;^q_&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Stream-队列\">Stream 队列</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stream 队列 与 Quorum 队列 类似，通过哪个节点创建队列，哪个节点就是 Leader，但也是可以通过参数 <code>x-queue-leader-locator</code> 指定主节点的选择策略。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建 Stream 队列时，默认复制数就是当前集群的节点数（Quorum 队列 默认是 3），可以通过指定参数 <code>x-initial-cluster-size</code> 进行初始设置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>添加新的节点时，与 Quorum 队列 类似，Stream 队列 也不会自动进行复制，可以通过如下命令手动复制</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-streams add_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;</span></span><br><span class=\"line\">rabbitmq-streams add_replica -p /vtest sq_2 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除成员节点时，请使用如下命令:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-streams delete_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;</span></span><br><span class=\"line\">rabbitmq-streams delete_replica -p /vtest sq_2 rabbit@rabbitmq02</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看节点复制状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-streams stream_status [-p &lt;vhost&gt;] &lt;stream-name&gt;</span></span><br><span class=\"line\">rabbitmq-streams stream_status -p /vtest sq_2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当流出现异常状态（如副本分布异常、领导节点挂掉）时，为了恢复可用性，可以重启流</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq-streams restart_stream [-p &lt;vhost&gt;] &lt;stream-name&gt;</span></span><br><span class=\"line\">rabbitmq-streams restart_stream -p /vtest sq_2</span><br><span class=\"line\"><span class=\"comment\">## 重启操作</span></span><br><span class=\"line\"><span class=\"comment\"># 1.停止流的当前副本/分区。</span></span><br><span class=\"line\"><span class=\"comment\"># 2.重新初始化流的存储和元数据。</span></span><br><span class=\"line\"><span class=\"comment\"># 3.让流在集群中恢复为可用状态。</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 RabbitMQ 的 Cluster 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例 RabbitMQ Cluster(集群) 简介 在 RabbitMQ 中，Cluster（集群） 是多个节点组成的集合，用于实现高可用和负载均衡。 RabbitMQ 集群是一个或多个（三个、五个、七个或更多）节点的逻辑分组， 每个节点共享 用户、虚拟主机、队列、流、交换、绑定、运行时参数和其他分布式状态。 在 RabbitMQ 中，Cluster（集群）的节点分为两种： 磁盘节点(disk)：会把集群的所有元数据信息（比如交换机、绑定、队列、虚拟主机等信息）持久化到磁盘中。Master 节点必须是磁盘节点。 内存节点(ram)：只会将这些信息保存到内存中，如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失。Slave 节点可以是内存节点。 RabbitMQ 4.0 开始， 集群不再区分 普通集群模式（Classic Cluster） 与 镜像集群模式（Mirrored Queue Cluster） ，集群创建好后，会根据队列的初始复制因子参数决定为该队列创建多少个副本，比如 Quroum Queue 的参数是 x-quorum-initial-group-size，默认为3。 RabbitMQ 4.0 开始，Quroum Queue 和 Stream Queue 默认开启节点间消息复制，但是 Classic Queue 队列不支持节点间的消息复制; RabbitMQ 4.0以前的 集群分为两种模式 普通集群模式（Classic Cluster） 在 普通集群模式下，RabbitMQ 节点通过 Erlang 分布式系统实现互联，集群内的各个节点共享 消息队列、交换机、绑定等元素。 普通集群的特点： 共享队列：队列数据仅存储在单一节点上，只有该节点可以处理队列中的消息。 不自动复制数据：在普通集群中，消息并不会自动复制到其他节点。如果某个节点挂掉，队列上的消息就会丢失，无法恢复。 负载均衡：交换机（Exchange）会把消息发送到不同的队列，但队列数据仍然只在一个节点上。因此，普通集群适合不要求极高可用性的场景。 不具备高可用性：由于数据不会在集群的其他节点中复制，普通集群在某个节点宕机时，可能会导致消息丢失和系统不可用。 镜像集群模式（Mirrored Queue Cluster） 镜像集群模式 是为了 高可用性 设计的，在该模式下，队列的数据会在集群中的多个节点上进行 复制（镜像），从而保证即使某个节点出现故障，数据也不会丢失。 镜像集群的特点： 队列镜像：在镜像集群模式中，队列数据会在集群中的多个节点上复制。每个队列都有一个主节点和多个镜像节点。 高可用性：消息会被复制到集群的其他节点上，从而保证如果一个节点宕机，数据不会丢失，系统能迅速恢复。 节点故障恢复：当一个节点挂掉时，其他节点会继续处理该队列的消息，保证业务的高可用性。 网络负担较重：由于需要在多个节点之间进行数据同步和复制，所以镜像队列模式会增加集群的网络负担和磁盘 I/O。 性能影响：镜像队列模式会稍微影响性能，因为每次消息处理后，都需要将数据同步到其他镜像节点，增加了延迟。 集群搭建 准备三台服务器，分别安装 RabbitMQ ，安装方法参看 RabbitMQ 的安装及使用 开放端口 端口范围 用途 备注 4369 epmd（Erlang Port Mapper Daemon） RabbitMQ 节点和 CLI 工具使用的帮助程序发现守护进程。 6000-6500 RabbitMQ Stream 复制使用 用于 RabbitMQ Stream 的数据复制。 25672 Erlang 分发服务器端口 用于节点间和 CLI 工具通信，默认情况下仅限于单个端口（AMQP端口 + 20000）。 35672-35682 Erlang 分发客户端端口 用于 CLI 工具与节点通信，计算为服务器分发端口 + 10000 到 服务器分发端口 + 10010。 分别修改三台服务器的 hostname 123hostnamectl hostname rabbitmq01# hostnamectl hostname rabbitmq02# hostnamectl hostname rabbitmq03 分别修改三台服务器的 /etc/hosts 文件 12310.250.0.56 rabbitmq0110.250.0.232 rabbitmq0210.250.0.97 rabbitmq03 同步集群节点中的cookie 默认会在 /var/lib/rabbitmq/目录下生成一个.erlang.cookie，里面有一个字符串。 我们使用 rabbitmq01 节点作为集群的主节点，其他节点作为集群的成员节点，我们要做的就是保证集群中三个节点的这个cookie字符串一致。 将 rabbitmq01 的 /var/lib/rabbitmq/.erlang.cookie 文件中的cookie字符串复制到其他节点的 /var/lib/rabbitmq/.erlang.cookie 文件中。 分别启动三台服务器的 RabbitMQ 服务 1systemctl start rabbitmq-server 分别登录 rabbitmq02 和 rabbitmq03 节点，执行如下命令，将节点加入集群 12345678910111213# 停掉rabbitmq应用rabbitmqctl stop_app# 重置rabbitmq、交换机、队列rabbitmqctl reset# 加入集群，注意此时 rabbitmq01 是主节点，必须处于运行状态，# --ram 表示以 ram 内存节点 加入集群。如果不带参数默认为 disk 磁盘节点# RabbitMQ的集群节点分为 disk 和 ram，disk节点会将元数据保存到硬盘当中，而ram节点只是在内存中保存元数据。rabbitmqctl join_cluster rabbit@rabbitmq01 --ram# 启动rabbitmq应用rabbitmqctl start_app 登录 任意 节点，执行如下命令，查看集群状态 1234567891011121314151617181920212223242526rabbitmqctl cluster_status## 输出类似Cluster status of node rabbit@rabbitmq01 ...BasicsCluster name: rabbit@rabbitmq01Total CPU cores available cluster-wide: 6Cluster Tags(none)Disk Nodesrabbit@rabbitmq01RAM Nodesrabbit@rabbitmq02rabbit@rabbitmq03Running Nodesrabbit@rabbitmq01rabbit@rabbitmq02rabbit@rabbitmq03 PS: 由于ram节点减少了很多与硬盘的交互，所以，ram节点的元数据使用性能会比较高。但是，同时，这也意味着元数据的安全性是不如disk节点的。在我们这个集群中， rabbitmq02 和 rabbitmq03 都以 ram节点 的身份加入到 rabbitmq01 集群里，因此，是存在单点故障的。如果 rabbitmq01 节点服务崩溃，那么元数据就有可能丢失。在企业进行部署时，性能与安全性需要自己进行平衡。 登录任意节点的管理页面，查看集群状态 此时我们在任意节点中创建虚拟主机、队列、交换机和绑定关系 等元数据，都会自动同步到其他节点中。 我们也可以在 管理控制台 中查看队列时看到，此时多个一列，Node列，显示该队列在哪些节点中存在。只有 Quorum 队列 和 Stream 队列 才会显示多个节点，因为 Classic 队列 不支持多节点复制。 查看某个具体的 Quorum 队列 或 Stream 队列，可以看到更详细的说明 此时新建队列，会要求我们指定主节点(Leader)，即负责存储消息的的节点，而 Quorum 队列 或 Stream 队列，会自动将消息复制到其它节点(Members)。 Leader: 队列的主节点，负责存储消息。 Members: 队列的成员节点，负责存储消息的副本。 演示队列复制 默认情况下，Quorum 队列 和 Stream 队列 的 复制数 都为 3，这里为了演示，我在增加一个节点 rabbitmq04，请自行按上面的方法添加。 Quorum 队列 在页面上创建一个 Quorum 队列，与单节点上创建队列的区别就是需要我们选择主节点。 通过 客户端 创建队列时，默认情况下，连接哪个节点，哪个节点就是Leader，但也可以通过参数x-queue-leader-locator指定主节点的选择策略。 1234rabbitmqadmin queues declare --vhost &quot;/vtest&quot; --name &quot;target.quorum.queue.name&quot; --type &quot;quorum&quot; --durable true --arguments &#x27;&#123;&quot;x-queue-leader-locator&quot;:&quot;balanced&quot;&#125;&#x27;# x-queue-leader-locator 有两种选择策略## client-local：选择声明队列的客户端所连接的节点。这是默认值。## balanced：如果队列总数少于 1000 个（经典队列、仲裁队列和流）， 选择托管最小数量的仲裁队列领导者的节点。 如果队列总体超过 1000 个，则随机选择一个节点。 创建成功后，可以看到 Quorum 队列 的主节点和成员节点，可以看到这里成员节点有三个，除了主节点外，其余节点由集群自动选择。 也就是说，默认情况下，Quorum 队列 的复制数是 3，如果我们希望改变复制数，可以在创建队列时指定参数 x-quorum-initial-group-size，其值为 大于 0 的整数，若设置值大于实际成员节点数，则以实际成员节点数为准。x-quorum-initial-group-size 设置为 1 时便不进行复制了。 如果集群中增加了新的节点，希望队列也被复制到新的节点中，可以通过如下命令，将新的节点加入成员节点中: 12# rabbitmq-queues add_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;rabbitmq-queues add_member -p /vtest q_4 rabbit@rabbitmq02 如果希望将节点从成员节点中移除，可以通过如下命令: 12# rabbitmq-queues delete_member [-p &lt;vhost&gt;] &lt;queue-name&gt; &lt;node&gt;rabbitmq-queues delete_member -p /vtest q_4 rabbit@rabbitmq02 另外，当通过 forget_cluster_node 命令从集群中永久删除节点时，会自动将队列关联的节点从成员节点中移除。 删除节点时，请使用如下命令: 123456# 因为要删除 rabbitmq04 节点，所以以下命令不能在 rabbitmq04 节点执行# 删除前需要先关闭应用rabbitmqctl -n rabbit@rabbitmq04 stop_app# 删除节点# rabbitmqctl forget_cluster_node &lt;node&gt;rabbitmqctl forget_cluster_node rabbit@rabbitmq04 新增节点后，一个个的对原有的队列进行复制扩展非常麻烦，可以通过如下命令快速对符合条件的队列进行复制扩展: 1234567891011121314# rabbitmq-queues grow &lt;node&gt; &lt;all | even&gt; [--vhost-pattern &lt;pattern&gt;] [--queue-pattern &lt;pattern&gt;]## 参数说明：# &lt;node&gt;: 这个参数指定了 RabbitMQ 节点的名称，通常是 rabbit@&lt;hostname&gt;。它表示在哪个节点上执行增长操作。# &lt;all | even&gt;: 这个参数指定了要扩展的队列类型。all 表示扩展所有队列，even 表示扩展偶数编号的队列。# --vhost-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的虚拟主机名称。# --queue-pattern &lt;pattern&gt; （可选）: 这个参数指定了要匹配的队列名称。## 示例# 扩展所有虚拟主机下的所有队列的副本：rabbitmq-queues grow rabbit@rabbitmq04 all# 扩展所有虚拟主机下的偶数编号的队列的副本：rabbitmq-queues grow rabbit@rabbitmq04 even# 扩展特定虚拟主机和队列名称的队列rabbitmq-queues grow rabbit@rabbitmq04 all --vhost-pattern /vtest --queue-pattern &quot;^q_&quot; Stream 队列 Stream 队列 与 Quorum 队列 类似，通过哪个节点创建队列，哪个节点就是 Leader，但也是可以通过参数 x-queue-leader-locator 指定主节点的选择策略。 创建 Stream 队列时，默认复制数就是当前集群的节点数（Quorum 队列 默认是 3），可以通过指定参数 x-initial-cluster-size 进行初始设置。 添加新的节点时，与 Quorum 队列 类似，Stream 队列 也不会自动进行复制，可以通过如下命令手动复制 12# rabbitmq-streams add_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;rabbitmq-streams add_replica -p /vtest sq_2 rabbit@rabbitmq02 删除成员节点时，请使用如下命令: 12# rabbitmq-streams delete_replica [-p &lt;vhost&gt;] &lt;stream-name&gt; &lt;node&gt;rabbitmq-streams delete_replica -p /vtest sq_2 rabbit@rabbitmq02 查看节点复制状态 12# rabbitmq-streams stream_status [-p &lt;vhost&gt;] &lt;stream-name&gt;rabbitmq-streams stream_status -p /vtest sq_2 当流出现异常状态（如副本分布异常、领导节点挂掉）时，为了恢复可用性，可以重启流 123456# rabbitmq-streams restart_stream [-p &lt;vhost&gt;] &lt;stream-name&gt;rabbitmq-streams restart_stream -p /vtest sq_2## 重启操作# 1.停止流的当前副本/分区。# 2.重新初始化流的存储和元数据。# 3.让流在集群中恢复为可用状态。","summary":"摘要 本文介绍 RabbitMQ 的 Cluster 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例","date_published":"2025-09-25T14:30:05.000Z","tags":["技术","rabbitmq","分布式","rabbitmq"]},{"id":"https://blog.hanqunfeng.com/2025/09/21/rabbitmq-message/","url":"https://blog.hanqunfeng.com/2025/09/21/rabbitmq-message/","title":"RabbitMQ 之 Message","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RabbitMQ 的 Message 的基本概念和用法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.rabbitmq.com\">Zookeeper官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RabbitMQ 版本为 4.1.4。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo\">Java Client 示例</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Message-消息-是什么？\">Message(消息) 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 RabbitMQ 中，Message（消息）是消息队列中的数据单元。消息包含消息内容、消息属性等信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Message 组成：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">\n<ol>\n<li class=\"lvl-7\">消息内容：消息的内容，可以是任意数据。</li>\n</ol>\n</li>\n<li class=\"lvl-4\">\n<ol start=\"2\">\n<li class=\"lvl-7\">消息属性：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Web-控制台-中-Message-的使用\">Web 控制台 中 Message 的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Exchange 和 Queue 的管理界面中，都可以在其详情页面测试 Message 的使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>关于如何在代码中使用 Message，我会在下一节中详细介绍。</p>\n</li>\n</ul>\n<h3 id=\"Publish-message\">Publish message</h3>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/dHsDyt.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Payload：消息的内容，可以是任意数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Payload encoding：消息内容的编码方式，<code>String</code> 或者 <code>Base64</code>，默认为 <code>String</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Delivery mode：消息的持久化模式，1-Non-persistent 表示非持久化，2-Persistent 表示持久化。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Headers：消息的头信息，用于与 <code>Headers Exchange（头部交换机）</code>中的配置进行匹配。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Properties：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>中文含义</th>\n<th>数据类型</th>\n<th>默认值</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content_type</td>\n<td>内容类型</td>\n<td>String</td>\n<td>null</td>\n<td>指定消息的 MIME 类型，如 <code>&quot;text/plain&quot;</code>、<code>&quot;application/json&quot;</code></td>\n</tr>\n<tr>\n<td>content_encoding</td>\n<td>内容编码</td>\n<td>String</td>\n<td>null</td>\n<td>指定消息内容的编码方式，如 <code>&quot;gzip&quot;</code></td>\n</tr>\n<tr>\n<td>priority</td>\n<td>消息优先级</td>\n<td>Integer (0-255)</td>\n<td>0</td>\n<td>结合 <code>x-max-priority</code> 控制消息处理顺序，数值越大优先级越高</td>\n</tr>\n<tr>\n<td>correlation_id</td>\n<td>关联 ID</td>\n<td>String</td>\n<td>null</td>\n<td>RPC 模式中关联请求与响应</td>\n</tr>\n<tr>\n<td>reply_to</td>\n<td>回复队列名</td>\n<td>String</td>\n<td>null</td>\n<td>RPC 模式中指定响应消息的返回队列</td>\n</tr>\n<tr>\n<td>expiration</td>\n<td>消息过期时间</td>\n<td>String (ms)</td>\n<td>null</td>\n<td>消息的 TTL，毫秒为单位，过期后将被丢弃或进入死信队列</td>\n</tr>\n<tr>\n<td>message_id</td>\n<td>消息 ID</td>\n<td>String</td>\n<td>null</td>\n<td>唯一标识一条消息，通常由生产者指定</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>时间戳</td>\n<td>Date / Long</td>\n<td>null</td>\n<td>消息发送时间，通常是 Unix 时间戳</td>\n</tr>\n<tr>\n<td>type</td>\n<td>消息类型</td>\n<td>String</td>\n<td>null</td>\n<td>描述消息类型，如 <code>&quot;order&quot;</code> 或 <code>&quot;event&quot;</code></td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>用户 ID</td>\n<td>String</td>\n<td>null</td>\n<td>标识发送消息的用户，通常用于安全或审计</td>\n</tr>\n<tr>\n<td>app_id</td>\n<td>应用 ID</td>\n<td>String</td>\n<td>null</td>\n<td>标识发送消息的应用程序</td>\n</tr>\n<tr>\n<td>cluster_id</td>\n<td>集群 ID</td>\n<td>String</td>\n<td>null</td>\n<td>RabbitMQ 集群 ID，实际中很少使用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>与队列重叠的属性：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>队列参数（Queue Arguments）</th>\n<th>消息属性（Message Properties）</th>\n<th>谁的优先级更高 / 生效方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>priority / x-max-priority</strong></td>\n<td><code>x-max-priority</code>: 定义队列支持的<strong>最大优先级值</strong></td>\n<td><code>priority</code>: 为单个消息设置优先级</td>\n<td>队列先定义范围，消息只能在这个范围内取值 <br> 若 <code>priority &gt; x-max-priority</code>，则以<code>x-max-priority</code>为准</td>\n</tr>\n<tr>\n<td><strong>expiration / x-message-ttl</strong></td>\n<td><code>x-message-ttl</code>: 队列级别的消息<strong>统一 TTL</strong></td>\n<td><code>expiration</code>: 为单个消息设置 TTL（毫秒）</td>\n<td>如果同时设置，<strong>较短的 TTL</strong> 会生效</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Get-message\">Get message</h3>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/Ar9qob.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ack Mode：消息确认模式</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Nack message requeue true: 确认失败，消息重新入队，这是默认选择，主要是为了测试后消息依旧存在。</li>\n<li class=\"lvl-4\">Automatic ack: 自动确认</li>\n<li class=\"lvl-4\">Reject requeue true: 拒绝，消息重新入队</li>\n<li class=\"lvl-4\">Reject requeue false: 拒绝，消息不重新入队</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Encoding：消息内容编码方式</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>Auto String / Base64</code>，默认。如果消息载荷可以解释为UTF-8编码的字符串，就是 <code>String</code>，否则就是 <code>Base64</code>。</li>\n<li class=\"lvl-4\"><code>Base64</code>。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Messages: 一次获取消息数量，默认为 1。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RabbitMQ 的 Message 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例 Message(消息) 是什么？ 在 RabbitMQ 中，Message（消息）是消息队列中的数据单元。消息包含消息内容、消息属性等信息。 Message 组成： 消息内容：消息的内容，可以是任意数据。 消息属性：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。 Web 控制台 中 Message 的使用 在 Exchange 和 Queue 的管理界面中，都可以在其详情页面测试 Message 的使用。 关于如何在代码中使用 Message，我会在下一节中详细介绍。 Publish message Payload：消息的内容，可以是任意数据。 Payload encoding：消息内容的编码方式，String 或者 Base64，默认为 String。 Delivery mode：消息的持久化模式，1-Non-persistent 表示非持久化，2-Persistent 表示持久化。 Headers：消息的头信息，用于与 Headers Exchange（头部交换机）中的配置进行匹配。 Properties：消息的属性，如消息的过期时间、消息的优先级、消息的标签等。 属性名 中文含义 数据类型 默认值 典型用途 content_type 内容类型 String null 指定消息的 MIME 类型，如 &quot;text/plain&quot;、&quot;application/json&quot; content_encoding 内容编码 String null 指定消息内容的编码方式，如 &quot;gzip&quot; priority 消息优先级 Integer (0-255) 0 结合 x-max-priority 控制消息处理顺序，数值越大优先级越高 correlation_id 关联 ID String null RPC 模式中关联请求与响应 reply_to 回复队列名 String null RPC 模式中指定响应消息的返回队列 expiration 消息过期时间 String (ms) null 消息的 TTL，毫秒为单位，过期后将被丢弃或进入死信队列 message_id 消息 ID String null 唯一标识一条消息，通常由生产者指定 timestamp 时间戳 Date / Long null 消息发送时间，通常是 Unix 时间戳 type 消息类型 String null 描述消息类型，如 &quot;order&quot; 或 &quot;event&quot; user_id 用户 ID String null 标识发送消息的用户，通常用于安全或审计 app_id 应用 ID String null 标识发送消息的应用程序 cluster_id 集群 ID String null RabbitMQ 集群 ID，实际中很少使用 与队列重叠的属性： 参数名称 队列参数（Queue Arguments） 消息属性（Message Properties） 谁的优先级更高 / 生效方式 priority / x-max-priority x-max-priority: 定义队列支持的最大优先级值 priority: 为单个消息设置优先级 队列先定义范围，消息只能在这个范围内取值 若 priority &gt; x-max-priority，则以x-max-priority为准 expiration / x-message-ttl x-message-ttl: 队列级别的消息统一 TTL expiration: 为单个消息设置 TTL（毫秒） 如果同时设置，较短的 TTL 会生效 Get message Ack Mode：消息确认模式 Nack message requeue true: 确认失败，消息重新入队，这是默认选择，主要是为了测试后消息依旧存在。 Automatic ack: 自动确认 Reject requeue true: 拒绝，消息重新入队 Reject requeue false: 拒绝，消息不重新入队 Encoding：消息内容编码方式 Auto String / Base64，默认。如果消息载荷可以解释为UTF-8编码的字符串，就是 String，否则就是 Base64。 Base64。 Messages: 一次获取消息数量，默认为 1。","summary":"摘要 本文介绍 RabbitMQ 的 Message 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例","date_published":"2025-09-21T14:30:05.000Z","tags":["技术","rabbitmq","分布式","rabbitmq"]},{"id":"https://blog.hanqunfeng.com/2025/09/21/rabbitmq-exchange/","url":"https://blog.hanqunfeng.com/2025/09/21/rabbitmq-exchange/","title":"RabbitMQ 之 Exchange","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RabbitMQ 的 Exchange 的基本概念和用法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.rabbitmq.com\">Zookeeper官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RabbitMQ 版本为 4.1.4。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/rabbitmq-demo\">Java Client 示例</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Exchange-交换机-是什么？\">Exchange(交换机) 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 RabbitMQ 中，<a href=\"https://www.rabbitmq.com/docs/exchanges\">Exchange（交换机）</a> 是消息路由的核心组件。它负责接收生产者发送的消息，并根据预定义的路由规则将消息转发到一个或多个队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Exchange 类型决定了消息的路由方式。RabbitMQ 支持的 Exchange 类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Exchange 类型</th>\n<th>声明类型</th>\n<th>路由规则描述</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Direct</strong></td>\n<td><code>direct</code></td>\n<td>消息根据 <strong>路由键（routing key）</strong> 精确匹配绑定键（binding key）进行路由。</td>\n<td>精确消息传递，如日志分类、任务分发等。</td>\n</tr>\n<tr>\n<td><strong>Fanout</strong></td>\n<td><code>fanout</code></td>\n<td>消息广播到所有绑定的队列，<strong>忽略路由键</strong>。</td>\n<td>广播消息，如发布/订阅模式、实时通知等。</td>\n</tr>\n<tr>\n<td><strong>Topic</strong></td>\n<td><code>topic</code></td>\n<td>消息根据路由键与绑定键模式的匹配进行路由，支持通配符 <code>*</code>（匹配一个词）和 <code>#</code>（匹配零个或多个词）。</td>\n<td>模块化路由，如日志系统、事件驱动架构等。</td>\n</tr>\n<tr>\n<td><strong>Headers</strong></td>\n<td><code>headers</code></td>\n<td>消息根据 <strong>消息头部（headers）</strong> 与绑定时指定的头部匹配进行路由，支持 <code>x-match</code> 参数（<code>any</code> 或 <code>all</code>）。</td>\n<td>多条件路由，如复杂过滤、动态路由等。</td>\n</tr>\n<tr>\n<td><strong>Local Random Exchange</strong></td>\n<td><code>x-local-random</code></td>\n<td>消息始终被路由到本地队列，如果有多个本地队列绑定，则随机选择一个进行投递。</td>\n<td>请求-响应（RPC）模式，低延迟通信</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RabbitMQ 默认为我们提供了如下的交换机<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/SKlqQK.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>每新创建一个 Vhost，RabbitMQ 就会自动创建以下交换机，比如 <code>/vtest</code><br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/oGJ1oj.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>当然我们也可以根据需要创建新的交换机<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/QjnZin.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>配置说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Durability: 指定 Exchange 是否持久化。\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">Durable: 持久化的 Exchange 会被保存在磁盘上，重启 RabbitMQ 时会自动恢复。</li>\n<li class=\"lvl-6\">Transient: 非持久化的 Exchange 会被保存在内存中，重启 RabbitMQ 时会丢失。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">Auto-delete: 指定 Exchange 是否自动删除。\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">yes: 如果没有队列或交换机绑定该 Exchange，则该 Exchange 会自动删除。</li>\n<li class=\"lvl-6\">no: 该 Exchange 不会自动删除。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">Internal: 用于控制交换机是否可以被生产者直接发布消息\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">yes: 不能被生产者直接发送消息，该交换机只能用于 将消息从其他交换机转发到该交换机。</li>\n<li class=\"lvl-6\">no: 可以被生产者直接发送消息。</li>\n</ul>\n</li>\n<li class=\"lvl-4\">Arguments: 用于设置 Exchange 的其他参数，目前仅支持一个参数\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">Alternate exchange(alternate-exchange): 指定该 Exchange 的备用交换机，如果无法以其他方式将发往此交换机的消息路由出去，则将它们发送至此处指定的备用交换机。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Direct-Exchange（直接交换机）\">Direct Exchange（直接交换机）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>路由规则：消息的路由键与队列的绑定键完全匹配时，消息被路由到该队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：如果队列绑定键为 error，则只有路由键为 error 的消息会被路由到该队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：需要精确匹配的场景，如日志分类、任务分发等。</p>\n</li>\n</ul>\n<h2 id=\"Fanout-Exchange（扇出交换机）\">Fanout Exchange（扇出交换机）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>路由规则：消息广播到所有绑定的队列，忽略路由键。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：无论消息的路由键是什么，都会被路由到所有绑定的队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：广播消息，如发布/订阅模式、实时通知等。</p>\n</li>\n</ul>\n<h2 id=\"Topic-Exchange（主题交换机）\">Topic Exchange（主题交换机）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>路由规则：消息的路由键与队列的绑定键模式匹配时，消息被路由到该队列。支持通配符 *（匹配一个词）和 #（匹配零个或多个词）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：如果队列绑定键为 <em>.orange.</em>，则路由键为 quick.orange.rabbit 的消息会被路由到该队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：模块化路由，如日志系统、事件驱动架构等。</p>\n</li>\n</ul>\n<h2 id=\"Headers-Exchange（头部交换机）\">Headers Exchange（头部交换机）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>路由规则：消息的头部与队列的绑定头部匹配时，消息被路由到该队列。支持 x-match 参数（any 或 all）。即使配置了路由键也会忽略。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：如果队列绑定头部为 { “x-match”: “all”, “format”: “pdf”, “priority”: “high” }，则只有同时满足这两个条件的消息会被路由到该队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：多条件路由，如复杂过滤、动态路由等。</p>\n</li>\n</ul>\n<h2 id=\"Local-Random-Exchange（本地随机交换机）\">Local Random Exchange（本地随机交换机）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Local Random Exchange 是 RabbitMQ 4.0 引入的交换机类型，旨在优化<code>请求-响应</code>模式下的消息路由，特别适用于低延迟和高吞吐量的场景。通过结合独占队列使用，可以确保消息快速传递到本地消费者，减少网络延迟，提高系统性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>路由规则：消息始终被路由到本地队列（位于同一节点上），如果有多个本地队列绑定，则随机选择一个进行投递。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例：假设节点 A 上有两个绑定了 x-local-random 交换机的队列 Q1 和 Q2，发布的消息会随机路由到 Q1 或 Q2，但不会路由到其他节点的队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：请求-响应（RPC）模式下的低延迟通信，适合微服务架构中每个节点上都有消费者的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在使用 Local Random Exchange 时，必须满足以下条件：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">独占队列：消费者应声明独占队列，以确保队列仅绑定到当前节点。</li>\n<li class=\"lvl-4\">每个节点至少一个消费者：每个 RabbitMQ 节点上应至少有一个消费者，否则在该节点上发布的消息将被丢弃。</li>\n<li class=\"lvl-4\">交换机类型声明：使用 <code>x-local-random</code> 类型声明交换机。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Exchange-与-Queue-绑定-Binding\">Exchange 与 Queue 绑定(Binding)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建好 Exchange 之后，需要将 Exchange 与 Queue 绑定，才能将消息发送到指定的队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Exchange 与 Queue 的绑定关系，即 Exchange 发送的消息，会根据路由键与队列的绑定键进行匹配，如果匹配成功，则将消息发送到对应的队列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 Exchange 页面点击 Exchange 的名称，进入 Exchange 详情页面，此处可以进行 Exchange 与 Queue 绑定配置<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/taKUjm.png\" alt=\"\"></p>\n<blockquote>\n<p>这里的<code>Arguments</code>用于设置 绑定 的其他参数，比如 <code>Headers Exchange</code> 需要设置 <code>x-match</code> 参数等。</p>\n</blockquote>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RabbitMQ 的 Exchange 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例 Exchange(交换机) 是什么？ 在 RabbitMQ 中，Exchange（交换机） 是消息路由的核心组件。它负责接收生产者发送的消息，并根据预定义的路由规则将消息转发到一个或多个队列。 Exchange 类型决定了消息的路由方式。RabbitMQ 支持的 Exchange 类型 Exchange 类型 声明类型 路由规则描述 典型用途 Direct direct 消息根据 路由键（routing key） 精确匹配绑定键（binding key）进行路由。 精确消息传递，如日志分类、任务分发等。 Fanout fanout 消息广播到所有绑定的队列，忽略路由键。 广播消息，如发布/订阅模式、实时通知等。 Topic topic 消息根据路由键与绑定键模式的匹配进行路由，支持通配符 *（匹配一个词）和 #（匹配零个或多个词）。 模块化路由，如日志系统、事件驱动架构等。 Headers headers 消息根据 消息头部（headers） 与绑定时指定的头部匹配进行路由，支持 x-match 参数（any 或 all）。 多条件路由，如复杂过滤、动态路由等。 Local Random Exchange x-local-random 消息始终被路由到本地队列，如果有多个本地队列绑定，则随机选择一个进行投递。 请求-响应（RPC）模式，低延迟通信 RabbitMQ 默认为我们提供了如下的交换机 每新创建一个 Vhost，RabbitMQ 就会自动创建以下交换机，比如 /vtest 当然我们也可以根据需要创建新的交换机 配置说明 Durability: 指定 Exchange 是否持久化。 Durable: 持久化的 Exchange 会被保存在磁盘上，重启 RabbitMQ 时会自动恢复。 Transient: 非持久化的 Exchange 会被保存在内存中，重启 RabbitMQ 时会丢失。 Auto-delete: 指定 Exchange 是否自动删除。 yes: 如果没有队列或交换机绑定该 Exchange，则该 Exchange 会自动删除。 no: 该 Exchange 不会自动删除。 Internal: 用于控制交换机是否可以被生产者直接发布消息 yes: 不能被生产者直接发送消息，该交换机只能用于 将消息从其他交换机转发到该交换机。 no: 可以被生产者直接发送消息。 Arguments: 用于设置 Exchange 的其他参数，目前仅支持一个参数 Alternate exchange(alternate-exchange): 指定该 Exchange 的备用交换机，如果无法以其他方式将发往此交换机的消息路由出去，则将它们发送至此处指定的备用交换机。 Direct Exchange（直接交换机） 路由规则：消息的路由键与队列的绑定键完全匹配时，消息被路由到该队列。 示例：如果队列绑定键为 error，则只有路由键为 error 的消息会被路由到该队列。 适用场景：需要精确匹配的场景，如日志分类、任务分发等。 Fanout Exchange（扇出交换机） 路由规则：消息广播到所有绑定的队列，忽略路由键。 示例：无论消息的路由键是什么，都会被路由到所有绑定的队列。 适用场景：广播消息，如发布/订阅模式、实时通知等。 Topic Exchange（主题交换机） 路由规则：消息的路由键与队列的绑定键模式匹配时，消息被路由到该队列。支持通配符 *（匹配一个词）和 #（匹配零个或多个词）。 示例：如果队列绑定键为 .orange.，则路由键为 quick.orange.rabbit 的消息会被路由到该队列。 适用场景：模块化路由，如日志系统、事件驱动架构等。 Headers Exchange（头部交换机） 路由规则：消息的头部与队列的绑定头部匹配时，消息被路由到该队列。支持 x-match 参数（any 或 all）。即使配置了路由键也会忽略。 示例：如果队列绑定头部为 { “x-match”: “all”, “format”: “pdf”, “priority”: “high” }，则只有同时满足这两个条件的消息会被路由到该队列。 适用场景：多条件路由，如复杂过滤、动态路由等。 Local Random Exchange（本地随机交换机） Local Random Exchange 是 RabbitMQ 4.0 引入的交换机类型，旨在优化请求-响应模式下的消息路由，特别适用于低延迟和高吞吐量的场景。通过结合独占队列使用，可以确保消息快速传递到本地消费者，减少网络延迟，提高系统性能。 路由规则：消息始终被路由到本地队列（位于同一节点上），如果有多个本地队列绑定，则随机选择一个进行投递。 示例：假设节点 A 上有两个绑定了 x-local-random 交换机的队列 Q1 和 Q2，发布的消息会随机路由到 Q1 或 Q2，但不会路由到其他节点的队列。 适用场景：请求-响应（RPC）模式下的低延迟通信，适合微服务架构中每个节点上都有消费者的场景。 在使用 Local Random Exchange 时，必须满足以下条件： 独占队列：消费者应声明独占队列，以确保队列仅绑定到当前节点。 每个节点至少一个消费者：每个 RabbitMQ 节点上应至少有一个消费者，否则在该节点上发布的消息将被丢弃。 交换机类型声明：使用 x-local-random 类型声明交换机。 Exchange 与 Queue 绑定(Binding) 创建好 Exchange 之后，需要将 Exchange 与 Queue 绑定，才能将消息发送到指定的队列。 Exchange 与 Queue 的绑定关系，即 Exchange 发送的消息，会根据路由键与队列的绑定键进行匹配，如果匹配成功，则将消息发送到对应的队列。 在 Exchange 页面点击 Exchange 的名称，进入 Exchange 详情页面，此处可以进行 Exchange 与 Queue 绑定配置 这里的Arguments用于设置 绑定 的其他参数，比如 Headers Exchange 需要设置 x-match 参数等。","summary":"摘要 本文介绍 RabbitMQ 的 Exchange 的基本概念和用法。 Zookeeper官网 本文使用的 RabbitMQ 版本为 4.1.4。 Java Client 示例","date_published":"2025-09-21T13:30:05.000Z","tags":["技术","rabbitmq","分布式","rabbitmq"]}]}