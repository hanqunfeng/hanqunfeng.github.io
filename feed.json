{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/","url":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/","title":"Amazon Linux 2023(内核 6.1) 安装 Redis8","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Linux 安装 Redis8 的方法</li>\n<li class=\"lvl-2\">Linux 版本：<code>Amazon Linux 2023(内核 6.1)</code>。</li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\"><a href=\"https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/\">Redis官网安装手册</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Yum-安装\">Yum 安装</h2>\n<blockquote>\n<p>最省事，国内环境也可以顺利完成安装。<br>\n<code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Redis]</span></span><br><span class=\"line\"><span class=\"string\">name=Redis</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装 Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> rpm --import /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.查看redis安装信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看已安装的redis版本</span></span><br><span class=\"line\">$ rpm -qa | grep redis</span><br><span class=\"line\">redis-8.4.0-1.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装信息</span></span><br><span class=\"line\">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class=\"line\">Name        : redis</span><br><span class=\"line\">Version     : 8.4.0</span><br><span class=\"line\">Release     : 1</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class=\"line\">Group       : Applications/Databases</span><br><span class=\"line\">Size        : 83034075</span><br><span class=\"line\">License     :</span><br><span class=\"line\">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class=\"line\">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class=\"line\">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class=\"line\">Build Host  : 331d5099e900</span><br><span class=\"line\">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class=\"line\">URL         : https://redis.io/</span><br><span class=\"line\">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装的文件</span></span><br><span class=\"line\">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class=\"line\">/etc/redis</span><br><span class=\"line\">/etc/redis/redis.conf</span><br><span class=\"line\">/etc/redis/sentinel</span><br><span class=\"line\">/etc/redis/sentinel/sentinel.conf</span><br><span class=\"line\">/run/redis</span><br><span class=\"line\">/run/redis/redis-server.pid</span><br><span class=\"line\">/usr/bin/redis-benchmark</span><br><span class=\"line\">/usr/bin/redis-check-aof</span><br><span class=\"line\">/usr/bin/redis-check-rdb</span><br><span class=\"line\">/usr/bin/redis-cli</span><br><span class=\"line\">/usr/bin/redis-sentinel</span><br><span class=\"line\">/usr/bin/redis-server</span><br><span class=\"line\">/usr/lib/redis</span><br><span class=\"line\">/usr/lib/redis/modules</span><br><span class=\"line\">/usr/lib/redis/modules/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/modules/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/modules/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/modules/rejson.so</span><br><span class=\"line\">/usr/lib/redis/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/rejson.so</span><br><span class=\"line\">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class=\"line\">/usr/lib/systemd/system/redis.service</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.fc</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.te</span><br><span class=\"line\">/var/lib/redis</span><br><span class=\"line\">/var/log/redis</span><br><span class=\"line\">/var/log/redis/redis-sentinel.log</span><br><span class=\"line\">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启动redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<h2 id=\"源码安装\">源码安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.更新环境(非必须)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装依赖包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y --nobest --skip-broken \\</span><br><span class=\"line\">    pkg-config \\</span><br><span class=\"line\">    xz \\</span><br><span class=\"line\">    wget \\</span><br><span class=\"line\">    <span class=\"built_in\">which</span> \\</span><br><span class=\"line\">    git \\</span><br><span class=\"line\">    make \\</span><br><span class=\"line\">    openssl \\</span><br><span class=\"line\">    openssl-devel \\</span><br><span class=\"line\">    python3 \\</span><br><span class=\"line\">    python3-pip \\</span><br><span class=\"line\">    python3-devel \\</span><br><span class=\"line\">    unzip \\</span><br><span class=\"line\">    rsync \\</span><br><span class=\"line\">    clang \\</span><br><span class=\"line\">    llvm \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    libtool \\</span><br><span class=\"line\">    automake \\</span><br><span class=\"line\">    autoconf \\</span><br><span class=\"line\">    jq \\</span><br><span class=\"line\">    systemd-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.下载并提取Redis源代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.编译Redis</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意，不会自动安装模块，需要手动安装。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用GCC工具集</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src/redis-8.4.0</span><br><span class=\"line\"><span class=\"comment\"># 构建TLS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_TLS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 构建Redis模块，配不配都不会自动安装模块</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_WITH_MODULES=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 安装Rust工具链</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INSTALL_RUST_TOOLCHAIN=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭警告</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DISABLE_WERRORS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开始编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> make -j <span class=\"string\">&quot;<span class=\"subst\">$(nproc)</span>&quot;</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">./src/redis-server --version</span><br><span class=\"line\">./src/redis-cli --version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.启动Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> ./src/redis-server redis.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6.登录Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7.安装模块，可以参考如下文章中的介绍</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">\n<a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON\">Redis 扩展模块 -- RedisJSON</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Amazon Linux 2023(内核 6.1)。 Redis官网：https://redis.io/ Redis官网安装手册 Yum 安装 最省事，国内环境也可以顺利完成安装。 Amazon Linux 2023(内核 6.1) 和 Rocky Linux release 9.4 (Blue Onyx) 均成功安装。 1.添加仓库 1234567sudo tee /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;EOF[Redis]name=Redisbaseurl=http://packages.redis.io/rpm/rockylinux9enabled=1gpgcheck=1EOF 2.安装 Redis 123curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.keysudo rpm --import /tmp/redis.keysudo yum install redis -y 3.查看redis安装信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 查看已安装的redis版本$ rpm -qa | grep redisredis-8.4.0-1.x86_64# 查看redis安装信息$ rpm -qi redis-8.4.0-1.x86_64Name : redisVersion : 8.4.0Release : 1Architecture: x86_64Install Date: Wed 24 Dec 2025 06:05:22 AM UTCGroup : Applications/DatabasesSize : 83034075License :Signature : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0cSource RPM : redis-8.4.0-1.src.rpmBuild Date : Tue 18 Nov 2025 04:41:58 PM UTCBuild Host : 331d5099e900Packager : Redis Labs &lt;redis@redis.io&gt;URL : https://redis.io/Summary : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.Description :Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.# 查看redis安装的文件$ rpm -ql redis-8.4.0-1.x86_64/etc/redis/etc/redis/redis.conf/etc/redis/sentinel/etc/redis/sentinel/sentinel.conf/run/redis/run/redis/redis-server.pid/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli/usr/bin/redis-sentinel/usr/bin/redis-server/usr/lib/redis/usr/lib/redis/modules/usr/lib/redis/modules/redisbloom.so/usr/lib/redis/modules/redisearch.so/usr/lib/redis/modules/redistimeseries.so/usr/lib/redis/modules/rejson.so/usr/lib/redis/redisbloom.so/usr/lib/redis/redisearch.so/usr/lib/redis/redistimeseries.so/usr/lib/redis/rejson.so/usr/lib/systemd/system/redis-sentinel.service/usr/lib/systemd/system/redis.service/usr/share/selinux/packages/redis-ce.fc/usr/share/selinux/packages/redis-ce.te/var/lib/redis/var/log/redis/var/log/redis/redis-sentinel.log/var/log/redis/redis-server.log 4.启动redis 123sudo systemctl enable redissudo systemctl start redissudo systemctl status redis 5.登录redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array) 源码安装 1.更新环境(非必须) 1sudo dnf update -y 2.安装依赖包 12345678910111213141516171819202122sudo dnf install -y --nobest --skip-broken \\ pkg-config \\ xz \\ wget \\ which \\ git \\ make \\ openssl \\ openssl-devel \\ python3 \\ python3-pip \\ python3-devel \\ unzip \\ rsync \\ clang \\ llvm \\ curl \\ libtool \\ automake \\ autoconf \\ jq \\ systemd-devel 3.下载并提取Redis源代码 123cd /usr/srcsudo wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gzsudo tar -xzf redis-8.4.0.tar.gz 4.编译Redis 这里要注意，不会自动安装模块，需要手动安装。 1234567891011121314151617# 启用GCC工具集cd /usr/src/redis-8.4.0# 构建TLSexport BUILD_TLS=yes# 构建Redis模块，配不配都不会自动安装模块export BUILD_WITH_MODULES=yes# 安装Rust工具链export INSTALL_RUST_TOOLCHAIN=yes# 关闭警告export DISABLE_WERRORS=yes# 开始编译sudo make -j &quot;$(nproc)&quot; all# 验证./src/redis-server --version./src/redis-cli --version 5.启动Redis 1sudo ./src/redis-server redis.conf 6.登录Redis 12345678910$ ./src/redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array) 7.安装模块，可以参考如下文章中的介绍 Redis 扩展模块 -- RedisJSON Redis 扩展模块 -- RedisBloom","summary":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Amazon Linux 2023(内核 6.1)。 Redis官网：https://redis.io/ Redis官网安装手册","date_published":"2025-12-25T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/","url":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/","title":"Rcoky9 安装 Redis8","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Linux 安装 Redis8 的方法</li>\n<li class=\"lvl-2\">Linux 版本：<code>Rocky Linux release 9.4 (Blue Onyx)</code>。</li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\"><a href=\"https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/\">Redis官网安装手册</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Yum-安装\">Yum 安装</h2>\n<blockquote>\n<p>最省事，国内环境也可以顺利完成安装。<br>\n<code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Redis]</span></span><br><span class=\"line\"><span class=\"string\">name=Redis</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装 Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> rpm --import /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.查看redis安装信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看已安装的redis版本</span></span><br><span class=\"line\">$ rpm -qa | grep redis</span><br><span class=\"line\">redis-8.4.0-1.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装信息</span></span><br><span class=\"line\">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class=\"line\">Name        : redis</span><br><span class=\"line\">Version     : 8.4.0</span><br><span class=\"line\">Release     : 1</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class=\"line\">Group       : Applications/Databases</span><br><span class=\"line\">Size        : 83034075</span><br><span class=\"line\">License     :</span><br><span class=\"line\">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class=\"line\">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class=\"line\">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class=\"line\">Build Host  : 331d5099e900</span><br><span class=\"line\">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class=\"line\">URL         : https://redis.io/</span><br><span class=\"line\">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装的文件</span></span><br><span class=\"line\">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class=\"line\">/etc/redis</span><br><span class=\"line\">/etc/redis/redis.conf</span><br><span class=\"line\">/etc/redis/sentinel</span><br><span class=\"line\">/etc/redis/sentinel/sentinel.conf</span><br><span class=\"line\">/run/redis</span><br><span class=\"line\">/run/redis/redis-server.pid</span><br><span class=\"line\">/usr/bin/redis-benchmark</span><br><span class=\"line\">/usr/bin/redis-check-aof</span><br><span class=\"line\">/usr/bin/redis-check-rdb</span><br><span class=\"line\">/usr/bin/redis-cli</span><br><span class=\"line\">/usr/bin/redis-sentinel</span><br><span class=\"line\">/usr/bin/redis-server</span><br><span class=\"line\">/usr/lib/redis</span><br><span class=\"line\">/usr/lib/redis/modules</span><br><span class=\"line\">/usr/lib/redis/modules/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/modules/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/modules/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/modules/rejson.so</span><br><span class=\"line\">/usr/lib/redis/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/rejson.so</span><br><span class=\"line\">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class=\"line\">/usr/lib/systemd/system/redis.service</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.fc</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.te</span><br><span class=\"line\">/var/lib/redis</span><br><span class=\"line\">/var/log/redis</span><br><span class=\"line\">/var/log/redis/redis-sentinel.log</span><br><span class=\"line\">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启动redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<h2 id=\"源码安装\">源码安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/goreleaser.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[goreleaser]</span></span><br><span class=\"line\"><span class=\"string\">name=GoReleaser</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://repo.goreleaser.com/yum/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf clean all</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf makecache</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装依赖包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y --nobest --skip-broken \\</span><br><span class=\"line\">    pkg-config \\</span><br><span class=\"line\">    xz \\</span><br><span class=\"line\">    wget \\</span><br><span class=\"line\">    <span class=\"built_in\">which</span> \\</span><br><span class=\"line\">    gcc-toolset-13-gcc \\</span><br><span class=\"line\">    gcc-toolset-13-gcc-c++ \\</span><br><span class=\"line\">    git \\</span><br><span class=\"line\">    make \\</span><br><span class=\"line\">    openssl \\</span><br><span class=\"line\">    openssl-devel \\</span><br><span class=\"line\">    python3 \\</span><br><span class=\"line\">    python3-pip \\</span><br><span class=\"line\">    python3-devel \\</span><br><span class=\"line\">    unzip \\</span><br><span class=\"line\">    rsync \\</span><br><span class=\"line\">    clang \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    libtool \\</span><br><span class=\"line\">    automake \\</span><br><span class=\"line\">    autoconf \\</span><br><span class=\"line\">    jq \\</span><br><span class=\"line\">    systemd-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.创建一个Python虚拟环境</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> python3 -m venv /opt/venv</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启用GCC工具集</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> /opt/rh/gcc-toolset-13/enable /etc/profile.d/gcc-toolset-13.sh</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /etc/profile.d/gcc-toolset-13.sh&quot;</span> | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> -a /etc/bashrc</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.安装CMake</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMAKE_VERSION=3.25.1</span><br><span class=\"line\">ARCH=$(<span class=\"built_in\">uname</span> -m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$ARCH</span>&quot;</span> = <span class=\"string\">&quot;x86_64&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  CMAKE_FILE=cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>-linux-x86_64.sh</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  CMAKE_FILE=cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>-linux-aarch64.sh</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget https://github.com/Kitware/CMake/releases/download/v<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>/<span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> +x <span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> ./<span class=\"variable\">$&#123;CMAKE_FILE&#125;</span> --skip-license --prefix=/usr/local --exclude-subdir</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/local/bin</span><br><span class=\"line\">cmake --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6.下载并提取Redis源代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7.编译Redis</p>\n</li>\n</ul>\n<blockquote>\n<p>国内环境安装时因为需要从GitHub下载模块，速度很慢，而且经常失败，建议安装时先不要安装模块，安装好redis后再按需安装模块。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用GCC工具集</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/gcc-toolset-13.sh</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src/redis-8.4.0</span><br><span class=\"line\"><span class=\"comment\"># 构建TLS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_TLS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 构建Redis模块，如果不安装模块，则不需要此参数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_WITH_MODULES=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 安装Rust工具链</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INSTALL_RUST_TOOLCHAIN=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭警告</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DISABLE_WERRORS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开始编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> make -j <span class=\"string\">&quot;<span class=\"subst\">$(nproc)</span>&quot;</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">./src/redis-server --version</span><br><span class=\"line\">./src/redis-cli --version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>8.启动Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> ./src/redis-server redis-full.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>9.登录Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisearch/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisjson/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisbloom/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redistimeseries/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>10.安装模块，如果安装时没有安装模块，可以参考如下文章中的介绍</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">\n<a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON\">Redis 扩展模块 -- RedisJSON</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Rocky Linux release 9.4 (Blue Onyx)。 Redis官网：https://redis.io/ Redis官网安装手册 Yum 安装 最省事，国内环境也可以顺利完成安装。 Amazon Linux 2023(内核 6.1) 和 Rocky Linux release 9.4 (Blue Onyx) 均成功安装。 1.添加仓库 1234567sudo tee /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;EOF[Redis]name=Redisbaseurl=http://packages.redis.io/rpm/rockylinux9enabled=1gpgcheck=1EOF 2.安装 Redis 123curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.keysudo rpm --import /tmp/redis.keysudo yum install redis -y 3.查看redis安装信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 查看已安装的redis版本$ rpm -qa | grep redisredis-8.4.0-1.x86_64# 查看redis安装信息$ rpm -qi redis-8.4.0-1.x86_64Name : redisVersion : 8.4.0Release : 1Architecture: x86_64Install Date: Wed 24 Dec 2025 06:05:22 AM UTCGroup : Applications/DatabasesSize : 83034075License :Signature : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0cSource RPM : redis-8.4.0-1.src.rpmBuild Date : Tue 18 Nov 2025 04:41:58 PM UTCBuild Host : 331d5099e900Packager : Redis Labs &lt;redis@redis.io&gt;URL : https://redis.io/Summary : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.Description :Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.# 查看redis安装的文件$ rpm -ql redis-8.4.0-1.x86_64/etc/redis/etc/redis/redis.conf/etc/redis/sentinel/etc/redis/sentinel/sentinel.conf/run/redis/run/redis/redis-server.pid/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli/usr/bin/redis-sentinel/usr/bin/redis-server/usr/lib/redis/usr/lib/redis/modules/usr/lib/redis/modules/redisbloom.so/usr/lib/redis/modules/redisearch.so/usr/lib/redis/modules/redistimeseries.so/usr/lib/redis/modules/rejson.so/usr/lib/redis/redisbloom.so/usr/lib/redis/redisearch.so/usr/lib/redis/redistimeseries.so/usr/lib/redis/rejson.so/usr/lib/systemd/system/redis-sentinel.service/usr/lib/systemd/system/redis.service/usr/share/selinux/packages/redis-ce.fc/usr/share/selinux/packages/redis-ce.te/var/lib/redis/var/log/redis/var/log/redis/redis-sentinel.log/var/log/redis/redis-server.log 4.启动redis 123sudo systemctl enable redissudo systemctl start redissudo systemctl status redis 5.登录redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array) 源码安装 1.添加仓库 1234567891011sudo tee /etc/yum.repos.d/goreleaser.repo &gt; /dev/null &lt;&lt;EOF[goreleaser]name=GoReleaserbaseurl=https://repo.goreleaser.com/yum/enabled=1gpgcheck=0EOFsudo dnf clean allsudo dnf makecachesudo dnf update -y 2.安装依赖包 1234567891011121314151617181920212223sudo dnf install -y --nobest --skip-broken \\ pkg-config \\ xz \\ wget \\ which \\ gcc-toolset-13-gcc \\ gcc-toolset-13-gcc-c++ \\ git \\ make \\ openssl \\ openssl-devel \\ python3 \\ python3-pip \\ python3-devel \\ unzip \\ rsync \\ clang \\ curl \\ libtool \\ automake \\ autoconf \\ jq \\ systemd-devel 3.创建一个Python虚拟环境 1sudo python3 -m venv /opt/venv 4.启用GCC工具集 12sudo cp /opt/rh/gcc-toolset-13/enable /etc/profile.d/gcc-toolset-13.shecho &quot;source /etc/profile.d/gcc-toolset-13.sh&quot; | sudo tee -a /etc/bashrc 5.安装CMake 12345678910111213141516CMAKE_VERSION=3.25.1ARCH=$(uname -m)if [ &quot;$ARCH&quot; = &quot;x86_64&quot; ]; then CMAKE_FILE=cmake-$&#123;CMAKE_VERSION&#125;-linux-x86_64.shelse CMAKE_FILE=cmake-$&#123;CMAKE_VERSION&#125;-linux-aarch64.shfisudo wget https://github.com/Kitware/CMake/releases/download/v$&#123;CMAKE_VERSION&#125;/$&#123;CMAKE_FILE&#125;sudo chmod +x $&#123;CMAKE_FILE&#125;sudo ./$&#123;CMAKE_FILE&#125; --skip-license --prefix=/usr/local --exclude-subdirsudo rm $&#123;CMAKE_FILE&#125;export PATH=$PATH:/usr/local/bincmake --version 6.下载并提取Redis源代码 123cd /usr/srcsudo wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gzsudo tar -xzf redis-8.4.0.tar.gz 7.编译Redis 国内环境安装时因为需要从GitHub下载模块，速度很慢，而且经常失败，建议安装时先不要安装模块，安装好redis后再按需安装模块。 123456789101112131415161718# 启用GCC工具集source /etc/profile.d/gcc-toolset-13.shcd /usr/src/redis-8.4.0# 构建TLSexport BUILD_TLS=yes# 构建Redis模块，如果不安装模块，则不需要此参数export BUILD_WITH_MODULES=yes# 安装Rust工具链export INSTALL_RUST_TOOLCHAIN=yes# 关闭警告export DISABLE_WERRORS=yes# 开始编译sudo make -j &quot;$(nproc)&quot; all# 验证./src/redis-server --version./src/redis-cli --version 8.启动Redis 1sudo ./src/redis-server redis-full.conf 9.登录Redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ ./src/redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;./modules/redisearch/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redisjson/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redisbloom/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redistimeseries/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array) 10.安装模块，如果安装时没有安装模块，可以参考如下文章中的介绍 Redis 扩展模块 -- RedisJSON Redis 扩展模块 -- RedisBloom","summary":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Rocky Linux release 9.4 (Blue Onyx)。 Redis官网：https://redis.io/ Redis官网安装手册","date_published":"2025-12-25T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/","url":"https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/","title":"Redis 命令及数据类型 -- JSON","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisJSON 的安装参见 <a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON\">Redis 扩展模块 -- RedisJSON</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"JSON-vs-String\">JSON vs String</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis JSON存储数据的性能更高。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Redis JSON 底层其实是以一种高效的二进制的格式存储。</li>\n<li class=\"lvl-6\">相比简单的文本格式，二进制格式进行 JOSN 格式读写的性能更高，也更节省内存。</li>\n<li class=\"lvl-6\">根据官网的性能测试报告，使用 Redis JSON 读写 JSON数据，性能已经能够媲美 MongoDB 以及 ElasticSearch 等传统 NoSQL 数据库。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Redis JSON 使用树状结构来存储JSON。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">这种存储方式可以快速访问子元素。</li>\n<li class=\"lvl-6\">与传统的文本存储方案相比，树状存储结构能够更高效的执行查询操作。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>与Redis生态集成度高。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">作为Redis的扩展模块，Redis JSON 和Redis的其他功能和工具无缝集成。</li>\n<li class=\"lvl-6\">这意味着开发者可以继续使用TTL、Redis事务、发布/订阅、Lua脚本等功能。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSONPath\">JSONPath</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSONPath 是一种用于查询和修改 JSON 数据的语法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>JSONPath 语法</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语法元素</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>$</code></td>\n<td>根节点（最外层 JSON 元素），JSONPath 的起点</td>\n<td><code>$</code>、<code>$.user.name</code></td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>访问子字段（对象属性访问）</td>\n<td><code>$.user.age</code></td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td>子元素选择器（字段名或数组索引）</td>\n<td><code>$['user']['name']</code></td>\n</tr>\n<tr>\n<td><code>..</code></td>\n<td>递归下降，遍历所有层级的节点</td>\n<td><code>$..id</code></td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>通配符，匹配当前层级的所有元素</td>\n<td><code>$.users[*]</code></td>\n</tr>\n<tr>\n<td><code>[index]</code></td>\n<td>数组下标访问（支持负索引）</td>\n<td><code>$.scores[0]</code></td>\n</tr>\n<tr>\n<td><code>[a,b,c]</code></td>\n<td>联合选择，返回多个指定元素</td>\n<td><code>$.scores[0,2,4]</code></td>\n</tr>\n<tr>\n<td><code>[start:end:step]</code></td>\n<td>数组切片（起始索引 : 结束索引 : 步长）</td>\n<td><code>$.scores[1:5:2]</code></td>\n</tr>\n<tr>\n<td><code>[*]</code></td>\n<td>选择数组中的所有元素</td>\n<td><code>$.items[*]</code></td>\n</tr>\n<tr>\n<td><code>[:]</code></td>\n<td>选择数组中的所有元素（切片写法）</td>\n<td><code>$.items[:]</code></td>\n</tr>\n<tr>\n<td><code>?()</code></td>\n<td>过滤表达式，用于数组或对象的条件筛选</td>\n<td><code>$.users[?(@.age&gt;=18)]</code></td>\n</tr>\n<tr>\n<td><code>()</code></td>\n<td>脚本表达式，用于计算或复杂逻辑判断</td>\n<td><code>$.items[?((@.a+@.b)&gt;10)]</code></td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>当前元素引用，常用于过滤或脚本表达式中</td>\n<td><code>@.price&lt;100</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数组切片 <code>[start:end:step]</code> 详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[3:]</code></td>\n<td>从索引 3 到末尾</td>\n</tr>\n<tr>\n<td><code>[:8]</code></td>\n<td>从头到索引 7</td>\n</tr>\n<tr>\n<td><code>[:8:2]</code></td>\n<td>从头到 7，每隔 2 个取一个</td>\n</tr>\n<tr>\n<td><code>[::]</code></td>\n<td>等价于 <code>[:]</code>，取全部</td>\n</tr>\n<tr>\n<td><code>[*]</code></td>\n<td>推荐写法，取全部</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>默认值规则：<br>\nstart 默认 0<br>\nend 默认数组末尾<br>\nstep 默认 1</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>过滤表达式 <code>?()</code> 支持的运算符</p>\n</li>\n</ul>\n<blockquote>\n<p>比较运算符，实测中仅支持数字比较，且注意两边不能有空格</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>==</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>!=</code></td>\n<td>不等于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>=~</code></td>\n<td>正则匹配</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>逻辑运算符</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>与</td>\n</tr>\n<tr>\n<td><code>||</code></td>\n<td>或</td>\n</tr>\n<tr>\n<td><code>()</code></td>\n<td>分组优先级</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 的 RedisJSON 模块（提供 JSON 操作功能）支持的 JSONPath 语法是受限的子集，尤其是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">❌ 不支持复杂表达式</li>\n<li class=\"lvl-6\">❌ 不支持嵌套数组条件（@.items[*].xxx）</li>\n<li class=\"lvl-6\">⚠️ 对 ?() 的支持非常有限</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>如果需要复杂的查询推荐使用 <code>RediSearch</code> 模块，这个我们后面的章节会介绍。</p>\n</li>\n</ul>\n<h2 id=\"JSON-命令\">JSON 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON 命令 汇总</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基础读写</td>\n<td>SET / MSET / GET / MGET</td>\n</tr>\n<tr>\n<td>数组操作</td>\n<td>ARRAPPEND / ARRINSERT / ARRPOP / ARRLEN / ARRINDEX / ARRTRIM</td>\n</tr>\n<tr>\n<td>对象操作</td>\n<td>OBJKEYS / OBJLEN / TYPE</td>\n</tr>\n<tr>\n<td>数值运算</td>\n<td>NUMINCRBY / NUMMULTBY / TOGGLE</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>STRAPPEND / STRLEN</td>\n</tr>\n<tr>\n<td>删除清空</td>\n<td>DEL / FORGET / CLEAR</td>\n</tr>\n<tr>\n<td>合并输出</td>\n<td>MERGE / RESP</td>\n</tr>\n<tr>\n<td>调试诊断</td>\n<td>DEBUG / DEBUG MEMORY</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一、基础读写类（CRUD）\">一、基础读写类（CRUD）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>关键参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.SET</td>\n<td>设置或更新某个 path 的值</td>\n<td><code>key</code>：键名<br><code>path</code>：JSONPath（如 <code>$</code>、<code>$.a.b</code>）<br><code>value</code>：JSON 值</td>\n<td><code>JSON.SET user:1 $ '&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;'</code></td>\n</tr>\n<tr>\n<td>JSON.MSET</td>\n<td>批量设置多个 key</td>\n<td><code>(key path value)...</code></td>\n<td><code>JSON.MSET k1 $ '&#123;&quot;a&quot;:1&#125;' k2 $.b 2</code></td>\n</tr>\n<tr>\n<td>JSON.GET</td>\n<td>获取一个 key 的 JSON 值</td>\n<td><code>key</code><br><code>path...</code>：可多个</td>\n<td><code>JSON.GET user:1 $.name $.age</code></td>\n</tr>\n<tr>\n<td>JSON.MGET</td>\n<td>从多个 key 获取同一路径</td>\n<td><code>key... path</code></td>\n<td><code>JSON.MGET k1 k2 $.a</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">JSON.GET 返回 字符串化 JSON</li>\n<li class=\"lvl-6\">JSON.MGET 返回数组，对应多个 key</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、数组操作类（Array）\">二、数组操作类（Array）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.ARRAPPEND</td>\n<td>向数组末尾追加元素</td>\n<td><code>key path value...</code></td>\n<td><code>JSON.ARRAPPEND k $.tags &quot;redis&quot; &quot;json&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRINSERT</td>\n<td>在指定索引插入元素</td>\n<td><code>key path index value...</code></td>\n<td><code>JSON.ARRINSERT k $.tags 1 &quot;nosql&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRPOP</td>\n<td>删除并返回指定索引元素</td>\n<td><code>key path [index]</code></td>\n<td><code>JSON.ARRPOP k $.tags -1</code></td>\n</tr>\n<tr>\n<td>JSON.ARRLEN</td>\n<td>获取数组长度</td>\n<td><code>key path</code></td>\n<td><code>JSON.ARRLEN k $.tags</code></td>\n</tr>\n<tr>\n<td>JSON.ARRINDEX</td>\n<td>查找元素索引</td>\n<td><code>key path value</code></td>\n<td><code>JSON.ARRINDEX k $.tags &quot;redis&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRTRIM</td>\n<td>截取数组区间</td>\n<td><code>key path start stop</code></td>\n<td><code>JSON.ARRTRIM k $.scores 0 9</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">索引支持负数（-1 表示最后一个）</li>\n<li class=\"lvl-6\">ARRTRIM 类似 LTRIM</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、对象操作类（Object）\">三、对象操作类（Object）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.OBJKEYS</td>\n<td>获取对象的所有 key</td>\n<td><code>key path</code></td>\n<td><code>JSON.OBJKEYS k $.user</code></td>\n</tr>\n<tr>\n<td>JSON.OBJLEN</td>\n<td>获取对象字段数量</td>\n<td><code>key path</code></td>\n<td><code>JSON.OBJLEN k $.user</code></td>\n</tr>\n<tr>\n<td>JSON.TYPE</td>\n<td>返回 path 对应值类型</td>\n<td><code>key path</code></td>\n<td><code>JSON.TYPE k $.user.name</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON.TYPE 返回类型包括：object / array / string / number / boolean / null</p>\n</li>\n</ul>\n<h3 id=\"四、数值运算类（Numeric）\">四、数值运算类（Numeric）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.NUMINCRBY</td>\n<td>数值自增</td>\n<td><code>key path number</code></td>\n<td><code>JSON.NUMINCRBY k $.count 1</code></td>\n</tr>\n<tr>\n<td>JSON.NUMMULTBY</td>\n<td>数值乘法</td>\n<td><code>key path number</code></td>\n<td><code>JSON.NUMMULTBY k $.price 0.8</code></td>\n</tr>\n<tr>\n<td>JSON.TOGGLE</td>\n<td>布尔值取反</td>\n<td><code>key path</code></td>\n<td><code>JSON.TOGGLE k $.enabled</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">保证 原子性</li>\n<li class=\"lvl-6\">常用于计数、开关状态</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、字符串操作类（String）\">五、字符串操作类（String）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.STRAPPEND</td>\n<td>追加字符串</td>\n<td><code>key path value</code></td>\n<td><code>JSON.STRAPPEND k $.msg &quot; world&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.STRLEN</td>\n<td>字符串长度</td>\n<td><code>key path</code></td>\n<td><code>JSON.STRLEN k $.msg</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"六、删除-清空类\">六、删除 / 清空类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.DEL</td>\n<td>删除指定 path</td>\n<td><code>key path</code></td>\n<td><code>JSON.DEL k $.user.age</code></td>\n</tr>\n<tr>\n<td>JSON.FORGET</td>\n<td>等价 JSON.DEL</td>\n<td>同上</td>\n<td><code>JSON.FORGET k $.tmp</code></td>\n</tr>\n<tr>\n<td>JSON.CLEAR</td>\n<td>清空值</td>\n<td><code>key path</code></td>\n<td><code>JSON.CLEAR k $.list</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON.CLEAR 行为说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">数组 → []</li>\n<li class=\"lvl-6\">对象 → {}</li>\n<li class=\"lvl-6\">数值 → 0</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、合并与高级操作\">七、合并与高级操作</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.MERGE</td>\n<td>合并 JSON（RFC7396）</td>\n<td><code>key path value</code></td>\n<td><code>JSON.MERGE k $ '&#123;&quot;a&quot;:2,&quot;b&quot;:3&#125;'</code></td>\n</tr>\n<tr>\n<td>JSON.RESP</td>\n<td>RESP 格式返回</td>\n<td><code>key path</code></td>\n<td><code>JSON.RESP k $.user</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">MERGE 支持字段覆盖、删除、扩展</li>\n<li class=\"lvl-6\">RESP 适合客户端直接解析</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"八、调试与诊断类（Debug）\">八、调试与诊断类（Debug）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.DEBUG</td>\n<td>调试命令容器</td>\n<td>子命令</td>\n<td><code>JSON.DEBUG MEMORY k</code></td>\n</tr>\n<tr>\n<td>JSON.DEBUG MEMORY</td>\n<td>查看 JSON 占用内存</td>\n<td><code>key</code></td>\n<td><code>JSON.DEBUG MEMORY user:1</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"应用示例\">应用示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景选用：电商用户画像 + 订单系统（结构复杂、字段多、非常适合 JSONPath）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们要存储一个用户的完整画像：</span><br><span class=\"line\">    基本信息</span><br><span class=\"line\">    地址列表</span><br><span class=\"line\">    订单列表（包含商品、价格、数量）</span><br><span class=\"line\">    标签(偏好)</span><br><span class=\"line\">    账户状态</span><br><span class=\"line\">    统计信息</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot暂时没有支持RedisJSON，你可以编写Lua脚本来实现相应的功能，另外 <a href=\"https://redisson.pro/docs/data-and-services/objects/#json-object-holder\">Redissson</a>已经提供了对JSON的支持，但是实际使用中发现还有一些Bug，下面结合命令给出代码示例。</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.52.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建完整 JSON 文档（JSON.SET）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 JSON 文档，实际执行中不支持多行，这里只是为了看着清楚些，实际运行时要将其改成一行</span></span><br><span class=\"line\">JSON.SET user:10001 $ <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;profile&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;age&quot;: 28,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;vip&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;addresses&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;orders&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;orderId&quot;: &quot;O1001&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;amount&quot;: 199.99,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;status&quot;: &quot;PAID&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;orderId&quot;: &quot;O1002&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;amount&quot;: 59.90,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;status&quot;: &quot;CREATED&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;stats&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;loginCount&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;balance&quot;: 300.5</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用单行模式一点点组装</span></span><br><span class=\"line\">JSON.SET user:10001 $ <span class=\"string\">&#x27;&#123;&#125;&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.profile <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:28,&quot;vip&quot;:true&#125;&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.tags <span class=\"string\">&#x27;[&quot;vip&quot;,&quot;electronics&quot;,&quot;promotion&quot;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.addresses <span class=\"string\">&#x27;[&#123;&quot;city&quot;:&quot;Beijing&quot;,&quot;zip&quot;:&quot;100000&quot;&#125;,&#123;&quot;city&quot;:&quot;Shanghai&quot;,&quot;zip&quot;:&quot;200000&quot;&#125;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.orders <span class=\"string\">&#x27;[&#123;&quot;orderId&quot;:&quot;O1001&quot;,&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-1&quot;,&quot;price&quot;:99.99,&quot;qty&quot;:1&#125;,&#123;&quot;sku&quot;:&quot;SKU-2&quot;,&quot;price&quot;:100,&quot;qty&quot;:1&#125;]&#125;,&#123;&quot;orderId&quot;:&quot;O1002&quot;,&quot;amount&quot;:59.90,&quot;status&quot;:&quot;CREATED&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-3&quot;,&quot;price&quot;:59.90,&quot;qty&quot;:1&#125;]&#125;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.stats <span class=\"string\">&#x27;&#123;&quot;loginCount&quot;:10,&quot;balance&quot;:300.5&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> user:10001</span><br><span class=\"line\">ReJSON-RL</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">userStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            &#123;</span></span><br><span class=\"line\"><span class=\"string\">              &quot;profile&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">                &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;age&quot;: 28,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;vip&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">              &#125;,</span></span><br><span class=\"line\"><span class=\"string\">              &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;addresses&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">              ],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;orders&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                &#123;</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;orderId&quot;: &quot;O1001&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;amount&quot;: 199.99,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;status&quot;: &quot;PAID&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">                  ]</span></span><br><span class=\"line\"><span class=\"string\">                &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                &#123;</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;orderId&quot;: &quot;O1002&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;amount&quot;: 59.90,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;status&quot;: &quot;CREATED&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">                  ]</span></span><br><span class=\"line\"><span class=\"string\">                &#125;</span></span><br><span class=\"line\"><span class=\"string\">              ],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;stats&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">                &quot;loginCount&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;balance&quot;: 300.5</span></span><br><span class=\"line\"><span class=\"string\">              &#125;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">RJsonBucket&lt;User&gt; bucket = redissonClient.getJsonBucket(<span class=\"string\">&quot;user:10001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(User.class));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> objectMapper.readValue(userStr, User.class);</span><br><span class=\"line\">bucket.set(user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSONPath-查询示例\">JSONPath 查询示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基础路径访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取全部数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取用户信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.profile</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Alice\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:true&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取用户名</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.profile.name</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;Alice\\&quot;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;User&gt;() &#123;&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">User.<span class=\"type\">ProfileBean</span> <span class=\"variable\">profile</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;User.ProfileBean&gt;() &#123;&#125;),<span class=\"string\">&quot;profile&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;String&gt;() &#123;&#125;),<span class=\"string\">&quot;profile.name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加上 $. 前缀，返回值必须是 List&lt;T&gt;</span></span><br><span class=\"line\">List&lt;String&gt; names = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.profile.name&quot;</span>);</span><br><span class=\"line\">System.out.println(names.get(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 数组访问 &amp; 通配符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有订单ID</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[*].orderId</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;O1001\\&quot;,\\&quot;O1002\\&quot;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取所有地址的城市</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.addresses[*].city</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;Beijing\\&quot;,\\&quot;Shanghai\\&quot;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; orderIds = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[*].orderId&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; citys = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.addresses[*].city&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ 数组下标与切片</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取第一个订单</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取第一个和第二个订单，切片逻辑是 [start:end]， start &lt;= x &lt; end ，end不写默认为数组末尾</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0:2]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取所有订单，这里等同于 $.orders[*]</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[:]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;OrdersBean&gt; orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[0]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[0:2]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[:]&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4️⃣ 递归查询（…）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 找出所有商品价格（不管在哪一层）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $..price</span><br><span class=\"line\"><span class=\"string\">&quot;[99.99,100,59.9]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Double&gt; prices = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;Double&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$..price&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5️⃣ 条件过滤（JSONPath 核心能力）</p>\n</li>\n</ul>\n<blockquote>\n<p>✅ 支持的查询</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单金额大于100的订单，✅ 数字比较</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单中第一个商品价格大于50的订单，✅ 数组条件</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[0].price&gt;50)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单金额大于100并且订单中第一个商品价格大于50的订单，✅ 逻辑运算符</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;OrdersBean&gt; orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.amount&gt;100)]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.items[0].price&gt;50)]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>❌ 不支持的查询</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 👉 找出所有已支付订单，❌ 不支持字符串的比较</span><br><span class=\"line\">JSON.GET user:10001 $.orders[?(@.status==&quot;PAID&quot;)]</span><br><span class=\"line\"># 👉 找出所有已支付订单，❌ 不支持正则匹配</span><br><span class=\"line\">JSON.GET user:10001 $.orders[?(@.status=~&quot;PAID&quot;)]</span><br><span class=\"line\"></span><br><span class=\"line\"># 👉 找出所有订单中商品价格大于50的订单，这个就不准，❌ 不支持嵌套数组条件（@.items[*].xxx）</span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[*].price&gt;50)]</span><br><span class=\"line\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6️⃣ 修改数据（JSON.SET / JSON.NUMINCRBY）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 修改用户名</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.SET user:10001 $.profile.name <span class=\"string\">&#x27;&quot;Alice Zhang&quot;&#x27;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 👉 用户登录次数 +1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.NUMINCRBY user:10001 $.stats.loginCount 1</span><br><span class=\"line\"><span class=\"string\">&quot;[11]&quot;</span> <span class=\"comment\"># 返回修改后的值</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bucket.set(<span class=\"string\">&quot;$.profile.name&quot;</span>, <span class=\"string\">&quot;Alice Zhang&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意如下方法会增加成功，但是会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\"><span class=\"comment\">// Caused by: java.lang.NumberFormatException: For input string: &quot;[11]&quot;</span></span><br><span class=\"line\">bucket.incrementAndGet(<span class=\"string\">&quot;$.stats.loginCount&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7️⃣ 数组操作（ARRAPPEND / ARRINSERT）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 添加一个订单</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.orders <span class=\"string\">&#x27;&#123;&quot;orderId&quot;: &quot;O1003&quot;,&quot;amount&quot;: 399,&quot;status&quot;: &quot;PAID&quot;,&quot;items&quot;: [&#123; &quot;sku&quot;: &quot;SKU-9&quot;, &quot;price&quot;: 399, &quot;qty&quot;: 1 &#125;]&#125;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3 <span class=\"comment\"># 返回添加后的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 在 tags 的最后添加一个标签</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.tags <span class=\"string\">&#x27;&quot;newTag&quot;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 4 <span class=\"comment\"># 添加后的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 在 tags 中的指定位置插入一个标签</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRINSERT user:10001 $.tags 1 <span class=\"string\">&#x27;&quot;newTag2&quot;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 5 <span class=\"comment\"># 插入后的长度</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OrdersBean</span> <span class=\"variable\">ordersBean</span> <span class=\"operator\">=</span> OrdersBean.builder()</span><br><span class=\"line\">                .orderId(<span class=\"string\">&quot;O1003&quot;</span>)</span><br><span class=\"line\">                .amount(<span class=\"number\">399</span>)</span><br><span class=\"line\">                .status(<span class=\"string\">&quot;CREATED&quot;</span>)</span><br><span class=\"line\">                .items(List.of(</span><br><span class=\"line\">                        OrdersBean.ItemsBean.builder()</span><br><span class=\"line\">                                .sku(<span class=\"string\">&quot;SKU-9&quot;</span>)</span><br><span class=\"line\">                                .qty(<span class=\"number\">1</span>)</span><br><span class=\"line\">                                .price(<span class=\"number\">399</span>).build()</span><br><span class=\"line\">                )).build();</span><br><span class=\"line\"><span class=\"comment\">// 添加一个订单，返回添加后的长度</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> bucket.arrayAppend(<span class=\"string\">&quot;$.orders&quot;</span>, ordersBean);</span><br><span class=\"line\"></span><br><span class=\"line\">num = bucket.arrayAppend(<span class=\"string\">&quot;$.tags&quot;</span>, <span class=\"string\">&quot;newTag&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入成功，但是会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\">num = bucket.arrayInsert(<span class=\"string\">&quot;$.tags&quot;</span>, <span class=\"number\">1</span>, <span class=\"string\">&quot;newTag2&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>8️⃣ 删除 &amp; 清理操作（JSON.DEL &amp; JSON.CLEAR）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 删除用户年龄，$.profile.age 不存在了</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.DEL user:10001 $.profile.age</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 删除成功，返回0，表示路径不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 清空用户所有标签，$.tags 保留，只是变成了 [] 空数组</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.CLEAR user:10001 $.tags</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 清空成功，返回0，表示路径不存在或已经清空</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">delete</span> <span class=\"operator\">=</span> bucket.delete(<span class=\"string\">&quot;$.profile.age&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">clear</span> <span class=\"operator\">=</span> bucket.clear(<span class=\"string\">&quot;$.tags&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>9️⃣ 统计数组长度</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 统计用户订单的长度</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRLEN user:10001 $.orders</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> bucket.arraySize(<span class=\"string\">&quot;$.orders&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>🔟 查看 JSON 占用内存</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; JSON.DEBUG MEMORY user:10001</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1896 <span class=\"comment\"># 占用内存大小，单位字节</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">sizeInMemory</span> <span class=\"operator\">=</span> bucket.sizeInMemory();</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 的安装参见 Redis 扩展模块 -- RedisJSON JSON vs String Redis JSON存储数据的性能更高。 Redis JSON 底层其实是以一种高效的二进制的格式存储。 相比简单的文本格式，二进制格式进行 JOSN 格式读写的性能更高，也更节省内存。 根据官网的性能测试报告，使用 Redis JSON 读写 JSON数据，性能已经能够媲美 MongoDB 以及 ElasticSearch 等传统 NoSQL 数据库。 Redis JSON 使用树状结构来存储JSON。 这种存储方式可以快速访问子元素。 与传统的文本存储方案相比，树状存储结构能够更高效的执行查询操作。 与Redis生态集成度高。 作为Redis的扩展模块，Redis JSON 和Redis的其他功能和工具无缝集成。 这意味着开发者可以继续使用TTL、Redis事务、发布/订阅、Lua脚本等功能。 JSONPath JSONPath 是一种用于查询和修改 JSON 数据的语法。 JSONPath 语法 语法元素 中文说明 示例 $ 根节点（最外层 JSON 元素），JSONPath 的起点 $、$.user.name . 访问子字段（对象属性访问） $.user.age [] 子元素选择器（字段名或数组索引） $['user']['name'] .. 递归下降，遍历所有层级的节点 $..id * 通配符，匹配当前层级的所有元素 $.users[*] [index] 数组下标访问（支持负索引） $.scores[0] [a,b,c] 联合选择，返回多个指定元素 $.scores[0,2,4] [start:end:step] 数组切片（起始索引 : 结束索引 : 步长） $.scores[1:5:2] [*] 选择数组中的所有元素 $.items[*] [:] 选择数组中的所有元素（切片写法） $.items[:] ?() 过滤表达式，用于数组或对象的条件筛选 $.users[?(@.age&gt;=18)] () 脚本表达式，用于计算或复杂逻辑判断 $.items[?((@.a+@.b)&gt;10)] @ 当前元素引用，常用于过滤或脚本表达式中 @.price&lt;100 数组切片 [start:end:step] 详解 写法 含义 [3:] 从索引 3 到末尾 [:8] 从头到索引 7 [:8:2] 从头到 7，每隔 2 个取一个 [::] 等价于 [:]，取全部 [*] 推荐写法，取全部 默认值规则： start 默认 0 end 默认数组末尾 step 默认 1 过滤表达式 ?() 支持的运算符 比较运算符，实测中仅支持数字比较，且注意两边不能有空格 运算符 含义 == 等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 =~ 正则匹配 逻辑运算符 运算符 含义 &amp;&amp; 与 || 或 () 分组优先级 Redis 的 RedisJSON 模块（提供 JSON 操作功能）支持的 JSONPath 语法是受限的子集，尤其是： ❌ 不支持复杂表达式 ❌ 不支持嵌套数组条件（@.items[*].xxx） ⚠️ 对 ?() 的支持非常有限 如果需要复杂的查询推荐使用 RediSearch 模块，这个我们后面的章节会介绍。 JSON 命令 JSON 命令 汇总 分类 命令 基础读写 SET / MSET / GET / MGET 数组操作 ARRAPPEND / ARRINSERT / ARRPOP / ARRLEN / ARRINDEX / ARRTRIM 对象操作 OBJKEYS / OBJLEN / TYPE 数值运算 NUMINCRBY / NUMMULTBY / TOGGLE 字符串 STRAPPEND / STRLEN 删除清空 DEL / FORGET / CLEAR 合并输出 MERGE / RESP 调试诊断 DEBUG / DEBUG MEMORY 一、基础读写类（CRUD） 命令 作用 关键参数说明 示例 JSON.SET 设置或更新某个 path 的值 key：键名path：JSONPath（如 $、$.a.b）value：JSON 值 JSON.SET user:1 $ '&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;' JSON.MSET 批量设置多个 key (key path value)... JSON.MSET k1 $ '&#123;&quot;a&quot;:1&#125;' k2 $.b 2 JSON.GET 获取一个 key 的 JSON 值 keypath...：可多个 JSON.GET user:1 $.name $.age JSON.MGET 从多个 key 获取同一路径 key... path JSON.MGET k1 k2 $.a 说明： JSON.GET 返回 字符串化 JSON JSON.MGET 返回数组，对应多个 key 二、数组操作类（Array） 命令 作用 参数含义 示例 JSON.ARRAPPEND 向数组末尾追加元素 key path value... JSON.ARRAPPEND k $.tags &quot;redis&quot; &quot;json&quot; JSON.ARRINSERT 在指定索引插入元素 key path index value... JSON.ARRINSERT k $.tags 1 &quot;nosql&quot; JSON.ARRPOP 删除并返回指定索引元素 key path [index] JSON.ARRPOP k $.tags -1 JSON.ARRLEN 获取数组长度 key path JSON.ARRLEN k $.tags JSON.ARRINDEX 查找元素索引 key path value JSON.ARRINDEX k $.tags &quot;redis&quot; JSON.ARRTRIM 截取数组区间 key path start stop JSON.ARRTRIM k $.scores 0 9 说明： 索引支持负数（-1 表示最后一个） ARRTRIM 类似 LTRIM 三、对象操作类（Object） 命令 作用 参数说明 示例 JSON.OBJKEYS 获取对象的所有 key key path JSON.OBJKEYS k $.user JSON.OBJLEN 获取对象字段数量 key path JSON.OBJLEN k $.user JSON.TYPE 返回 path 对应值类型 key path JSON.TYPE k $.user.name JSON.TYPE 返回类型包括：object / array / string / number / boolean / null 四、数值运算类（Numeric） 命令 作用 参数说明 示例 JSON.NUMINCRBY 数值自增 key path number JSON.NUMINCRBY k $.count 1 JSON.NUMMULTBY 数值乘法 key path number JSON.NUMMULTBY k $.price 0.8 JSON.TOGGLE 布尔值取反 key path JSON.TOGGLE k $.enabled 说明： 保证 原子性 常用于计数、开关状态 五、字符串操作类（String） 命令 作用 参数说明 示例 JSON.STRAPPEND 追加字符串 key path value JSON.STRAPPEND k $.msg &quot; world&quot; JSON.STRLEN 字符串长度 key path JSON.STRLEN k $.msg 六、删除 / 清空类 命令 作用 参数说明 示例 JSON.DEL 删除指定 path key path JSON.DEL k $.user.age JSON.FORGET 等价 JSON.DEL 同上 JSON.FORGET k $.tmp JSON.CLEAR 清空值 key path JSON.CLEAR k $.list JSON.CLEAR 行为说明： 数组 → [] 对象 → {} 数值 → 0 七、合并与高级操作 命令 作用 参数说明 示例 JSON.MERGE 合并 JSON（RFC7396） key path value JSON.MERGE k $ '&#123;&quot;a&quot;:2,&quot;b&quot;:3&#125;' JSON.RESP RESP 格式返回 key path JSON.RESP k $.user 说明： MERGE 支持字段覆盖、删除、扩展 RESP 适合客户端直接解析 八、调试与诊断类（Debug） 命令 作用 参数说明 示例 JSON.DEBUG 调试命令容器 子命令 JSON.DEBUG MEMORY k JSON.DEBUG MEMORY 查看 JSON 占用内存 key JSON.DEBUG MEMORY user:1 应用示例 场景选用：电商用户画像 + 订单系统（结构复杂、字段多、非常适合 JSONPath） 1234567我们要存储一个用户的完整画像： 基本信息 地址列表 订单列表（包含商品、价格、数量） 标签(偏好) 账户状态 统计信息 SpringBoot暂时没有支持RedisJSON，你可以编写Lua脚本来实现相应的功能，另外 Redissson已经提供了对JSON的支持，但是实际使用中发现还有一些Bug，下面结合命令给出代码示例。 123456&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.52.0&lt;/version&gt;&lt;/dependency&gt; 创建完整 JSON 文档（JSON.SET） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 创建 JSON 文档，实际执行中不支持多行，这里只是为了看着清楚些，实际运行时要将其改成一行JSON.SET user:10001 $ &#x27;&#123; &quot;profile&quot;: &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28, &quot;vip&quot;: true &#125;, &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;], &quot;addresses&quot;: [ &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;, &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125; ], &quot;orders&quot;: [ &#123; &quot;orderId&quot;: &quot;O1001&quot;, &quot;amount&quot;: 199.99, &quot;status&quot;: &quot;PAID&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;, &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125; ] &#125;, &#123; &quot;orderId&quot;: &quot;O1002&quot;, &quot;amount&quot;: 59.90, &quot;status&quot;: &quot;CREATED&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125; ] &#125; ], &quot;stats&quot;: &#123; &quot;loginCount&quot;: 10, &quot;balance&quot;: 300.5 &#125;&#125;&#x27;# 也可以使用单行模式一点点组装JSON.SET user:10001 $ &#x27;&#123;&#125;&#x27;JSON.SET user:10001 $.profile &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:28,&quot;vip&quot;:true&#125;&#x27;JSON.SET user:10001 $.tags &#x27;[&quot;vip&quot;,&quot;electronics&quot;,&quot;promotion&quot;]&#x27;JSON.SET user:10001 $.addresses &#x27;[&#123;&quot;city&quot;:&quot;Beijing&quot;,&quot;zip&quot;:&quot;100000&quot;&#125;,&#123;&quot;city&quot;:&quot;Shanghai&quot;,&quot;zip&quot;:&quot;200000&quot;&#125;]&#x27;JSON.SET user:10001 $.orders &#x27;[&#123;&quot;orderId&quot;:&quot;O1001&quot;,&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-1&quot;,&quot;price&quot;:99.99,&quot;qty&quot;:1&#125;,&#123;&quot;sku&quot;:&quot;SKU-2&quot;,&quot;price&quot;:100,&quot;qty&quot;:1&#125;]&#125;,&#123;&quot;orderId&quot;:&quot;O1002&quot;,&quot;amount&quot;:59.90,&quot;status&quot;:&quot;CREATED&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-3&quot;,&quot;price&quot;:59.90,&quot;qty&quot;:1&#125;]&#125;]&#x27;JSON.SET user:10001 $.stats &#x27;&#123;&quot;loginCount&quot;:10,&quot;balance&quot;:300.5&#125;&#x27;# 查看类型127.0.0.1:6379&gt; type user:10001ReJSON-RL 通用代码 123456789101112131415161718192021222324252627282930313233343536373839404142@Autowiredprivate RedissonClient redissonClient;String userStr = &quot;&quot;&quot; &#123; &quot;profile&quot;: &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28, &quot;vip&quot;: true &#125;, &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;], &quot;addresses&quot;: [ &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;, &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125; ], &quot;orders&quot;: [ &#123; &quot;orderId&quot;: &quot;O1001&quot;, &quot;amount&quot;: 199.99, &quot;status&quot;: &quot;PAID&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;, &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125; ] &#125;, &#123; &quot;orderId&quot;: &quot;O1002&quot;, &quot;amount&quot;: 59.90, &quot;status&quot;: &quot;CREATED&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125; ] &#125; ], &quot;stats&quot;: &#123; &quot;loginCount&quot;: 10, &quot;balance&quot;: 300.5 &#125; &#125; &quot;&quot;&quot;;ObjectMapper objectMapper = new ObjectMapper();RJsonBucket&lt;User&gt; bucket = redissonClient.getJsonBucket(&quot;user:10001&quot;, new JacksonCodec&lt;&gt;(User.class)); 12User user = objectMapper.readValue(userStr, User.class);bucket.set(user); JSONPath 查询示例 1️⃣ 基础路径访问 12345678910# 获取全部数据127.0.0.1:6379&gt; JSON.GET user:10001# 获取用户信息127.0.0.1:6379&gt; JSON.GET user:10001 $.profile&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Alice\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:true&#125;]&quot;# 获取用户名127.0.0.1:6379&gt; JSON.GET user:10001 $.profile.name&quot;[\\&quot;Alice\\&quot;]&quot; 123456789User user = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;User&gt;() &#123;&#125;));User.ProfileBean profile = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;User.ProfileBean&gt;() &#123;&#125;),&quot;profile&quot;);String name = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;String&gt;() &#123;&#125;),&quot;profile.name&quot;);// 加上 $. 前缀，返回值必须是 List&lt;T&gt;List&lt;String&gt; names = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.profile.name&quot;);System.out.println(names.get(0)); 2️⃣ 数组访问 &amp; 通配符 1234567# 获取所有订单ID127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[*].orderId&quot;[\\&quot;O1001\\&quot;,\\&quot;O1002\\&quot;]&quot;# 获取所有地址的城市127.0.0.1:6379&gt; JSON.GET user:10001 $.addresses[*].city&quot;[\\&quot;Beijing\\&quot;,\\&quot;Shanghai\\&quot;]&quot; 123List&lt;String&gt; orderIds = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.orders[*].orderId&quot;);List&lt;String&gt; citys = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.addresses[*].city&quot;); 3️⃣ 数组下标与切片 1234567891011# 获取第一个订单127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 获取第一个和第二个订单，切片逻辑是 [start:end]， start &lt;= x &lt; end ，end不写默认为数组末尾127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0:2]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 获取所有订单，这里等同于 $.orders[*]127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[:]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 12345List&lt;OrdersBean&gt; orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[0]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[0:2]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[:]&quot;); 4️⃣ 递归查询（…） 123# 👉 找出所有商品价格（不管在哪一层）127.0.0.1:6379&gt; JSON.GET user:10001 $..price&quot;[99.99,100,59.9]&quot; 1List&lt;Double&gt; prices = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;Double&gt;&gt;() &#123;&#125;),&quot;$..price&quot;); 5️⃣ 条件过滤（JSONPath 核心能力） ✅ 支持的查询 1234567891011# 👉 找出所有订单金额大于100的订单，✅ 数字比较127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 👉 找出所有订单中第一个商品价格大于50的订单，✅ 数组条件127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[0].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 👉 找出所有订单金额大于100并且订单中第一个商品价格大于50的订单，✅ 逻辑运算符127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 12345List&lt;OrdersBean&gt; orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.amount&gt;100)]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.items[0].price&gt;50)]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;); ❌ 不支持的查询 12345678# 👉 找出所有已支付订单，❌ 不支持字符串的比较JSON.GET user:10001 $.orders[?(@.status==&quot;PAID&quot;)]# 👉 找出所有已支付订单，❌ 不支持正则匹配JSON.GET user:10001 $.orders[?(@.status=~&quot;PAID&quot;)]# 👉 找出所有订单中商品价格大于50的订单，这个就不准，❌ 不支持嵌套数组条件（@.items[*].xxx）127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[*].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 6️⃣ 修改数据（JSON.SET / JSON.NUMINCRBY） 123456# 👉 修改用户名127.0.0.1:6379&gt; JSON.SET user:10001 $.profile.name &#x27;&quot;Alice Zhang&quot;&#x27;OK# 👉 用户登录次数 +1127.0.0.1:6379&gt; JSON.NUMINCRBY user:10001 $.stats.loginCount 1&quot;[11]&quot; # 返回修改后的值 1234bucket.set(&quot;$.profile.name&quot;, &quot;Alice Zhang&quot;);// 注意如下方法会增加成功，但是会抛异常，应该是Redisson的bug// Caused by: java.lang.NumberFormatException: For input string: &quot;[11]&quot;bucket.incrementAndGet(&quot;$.stats.loginCount&quot;, 1); 7️⃣ 数组操作（ARRAPPEND / ARRINSERT） 1234567891011# 👉 添加一个订单127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.orders &#x27;&#123;&quot;orderId&quot;: &quot;O1003&quot;,&quot;amount&quot;: 399,&quot;status&quot;: &quot;PAID&quot;,&quot;items&quot;: [&#123; &quot;sku&quot;: &quot;SKU-9&quot;, &quot;price&quot;: 399, &quot;qty&quot;: 1 &#125;]&#125;&#x27;1) (integer) 3 # 返回添加后的长度# 👉 在 tags 的最后添加一个标签127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.tags &#x27;&quot;newTag&quot;&#x27;1) (integer) 4 # 添加后的长度# 👉 在 tags 中的指定位置插入一个标签127.0.0.1:6379&gt; JSON.ARRINSERT user:10001 $.tags 1 &#x27;&quot;newTag2&quot;&#x27;1) (integer) 5 # 插入后的长度 1234567891011121314151617OrdersBean ordersBean = OrdersBean.builder() .orderId(&quot;O1003&quot;) .amount(399) .status(&quot;CREATED&quot;) .items(List.of( OrdersBean.ItemsBean.builder() .sku(&quot;SKU-9&quot;) .qty(1) .price(399).build() )).build();// 添加一个订单，返回添加后的长度long num = bucket.arrayAppend(&quot;$.orders&quot;, ordersBean);num = bucket.arrayAppend(&quot;$.tags&quot;, &quot;newTag&quot;);// 插入成功，但是会抛异常，应该是Redisson的bugnum = bucket.arrayInsert(&quot;$.tags&quot;, 1, &quot;newTag2&quot;); 8️⃣ 删除 &amp; 清理操作（JSON.DEL &amp; JSON.CLEAR） 1234567# 👉 删除用户年龄，$.profile.age 不存在了127.0.0.1:6379&gt; JSON.DEL user:10001 $.profile.age(integer) 1 # 删除成功，返回0，表示路径不存在# 👉 清空用户所有标签，$.tags 保留，只是变成了 [] 空数组127.0.0.1:6379&gt; JSON.CLEAR user:10001 $.tags(integer) 1 # 清空成功，返回0，表示路径不存在或已经清空 123long delete = bucket.delete(&quot;$.profile.age&quot;);long clear = bucket.clear(&quot;$.tags&quot;); 9️⃣ 统计数组长度 123# 👉 统计用户订单的长度127.0.0.1:6379&gt; JSON.ARRLEN user:10001 $.orders1) (integer) 3 12// 会抛异常，应该是Redisson的buglong length = bucket.arraySize(&quot;$.orders&quot;); 🔟 查看 JSON 占用内存 12127.0.0.1:6379&gt; JSON.DEBUG MEMORY user:10001(integer) 1896 # 占用内存大小，单位字节 1long sizeInMemory = bucket.sizeInMemory();","summary":"摘要 本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 的安装参见 Redis 扩展模块 -- RedisJSON","date_published":"2025-12-24T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/","url":"https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/","title":"Redis 扩展模块 -- RedisJSON","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisJSON 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisJSON-简介\">RedisJSON 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisJSON/RedisJSON\">RedisJSON</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于对JSON数据进行操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisJSON 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n</ul>\n<h2 id=\"安装-RedisJSON\">安装 RedisJSON</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是从<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中进行下载，其提供了所有Redis模块编译后的<code>.so</code>文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/rguEIA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>源码编译</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>rejson.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisJSON/RedisJSON.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisJSON</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.8.16</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: 7fc8e62</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y git unzip rsync</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getrust</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getgcc --modern</span><br><span class=\"line\"><span class=\"built_in\">dir</span>=$(<span class=\"built_in\">mktemp</span> -d /tmp/tar.XXXXXX); (<span class=\"built_in\">cd</span> <span class=\"variable\">$dir</span>; wget --no-verbose -O tar.tgz http://redismodules.s3.amazonaws.com/readies/gnu/gnu-tar-1.32-x64-centos7.tgz; tar -xzf tar.tgz -C /; ); <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$dir</span></span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r /usr/local/soft/modules/RedisJSON/tests/pytest/requirements.txt</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getaws</span><br><span class=\"line\">NO_PY2=1 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getpudb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RedisJSON 的编译依赖 Rust 工具链，所以编译前需要安装rust，若已经安装则忽略</span></span><br><span class=\"line\"><span class=\"comment\"># 安装 rustup</span></span><br><span class=\"line\">curl --proto <span class=\"string\">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按提示选择默认安装（通常选择 1）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 让 Rust 生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.cargo/env</span><br><span class=\"line\"><span class=\"comment\"># 检查 rust 版本</span></span><br><span class=\"line\">rustc --version <span class=\"comment\"># rustc 1.92.0 (ded5c06cf 2025-12-08)</span></span><br><span class=\"line\">cargo --version <span class=\"comment\"># cargo 1.92.0 (344c4567c 2025-10-21)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RedisJSON</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/rejson.so`</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<blockquote>\n<p><code>install_raven</code> 的报错参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a> 进行修改。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">……</span><br><span class=\"line\">dnf install -q -y llvm-toolset-7.0</span><br><span class=\"line\">Error: Unable to find a match: llvm-toolset-7.0</span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: dnf install -q -y llvm-toolset-7.0</span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisJSON/sbin/setup:</span><br><span class=\"line\">18       \tpython3 -m pip list</span><br><span class=\"line\">19       <span class=\"keyword\">fi</span></span><br><span class=\"line\">20</span><br><span class=\"line\">21   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py</span><br><span class=\"line\">22       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">23       \tpython3 -m pip list</span><br><span class=\"line\">24       <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 错误分析与解决方法：</span></span><br><span class=\"line\">问题原因：</span><br><span class=\"line\">    操作系统的事，在 `deps/readies/bin/getclang`中有一个方法，其实一看就明白了</span><br><span class=\"line\">    def redhat_compat(self):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> not self.modern:</span><br><span class=\"line\">            <span class=\"built_in\">return</span></span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;%s/bin/getepel&quot;</span> % READIES, <span class=\"built_in\">sudo</span>=True)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.dist <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;centos&#x27;</span>, <span class=\"string\">&#x27;ol&#x27;</span>] and self.os_version[0] &gt;= 8:</span><br><span class=\"line\">            self.install(<span class=\"string\">&quot;clang&quot;</span>)</span><br><span class=\"line\">            self.install(<span class=\"string\">&quot;llvm-toolset&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.install(<span class=\"string\">&quot;llvm-toolset-7.0&quot;</span>)</span><br><span class=\"line\">            self.cp_to_profile_d(<span class=\"string\">&quot;/opt/rh/llvm-toolset-7.0/enable&quot;</span>, <span class=\"string\">&quot;llvm-toolset-7.0.sh&quot;</span>)</span><br><span class=\"line\">    我使用的机器不是 centos，所以就走<span class=\"keyword\">else</span>的逻辑了，另外这里即便走了 centos 逻辑，也有问题，就是el9中已经没有 llvm-toolset 了，取而代之的是 llvm，所以需要修改该方法</span><br><span class=\"line\"></span><br><span class=\"line\">修改方法如下：</span><br><span class=\"line\">    def redhat_compat(self):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> not self.modern:</span><br><span class=\"line\">            <span class=\"built_in\">return</span></span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;%s/bin/getepel&quot;</span> % READIES, <span class=\"built_in\">sudo</span>=True)</span><br><span class=\"line\">        <span class=\"comment\"># 去掉判断，直接安装，前提是 el9</span></span><br><span class=\"line\">        self.install(<span class=\"string\">&quot;clang&quot;</span>)</span><br><span class=\"line\">        self.install(<span class=\"string\">&quot;llvm&quot;</span>)</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <a href=\"http://rejson.so\">rejson.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要包含可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> bin/linux-x64-release/rejson.so /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 rejson.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; info Modules</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\">module:name=ReJSON,ver=20816,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20816</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisJSON 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 简介 RedisJSON 是 Redis 官方维护的一个扩展模块，隶属于 Redis Stack，专门用于对JSON数据进行操作。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisJSON 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 安装 RedisJSON 最简单的方式就是从Redis Cloud的Download Center中进行下载，其提供了所有Redis模块编译后的.so文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 源码编译 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的rejson.so上传到国内服务器即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisJSON/RedisJSON.gitcd RedisJSON# 推荐切换到稳定的release版本git checkout v2.8.16# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: 7fc8e62dnf install -q -y ca-certificatesdnf install -q -y wget unzip/usr/local/soft/modules/RedisJSON/deps/readies/bin/enable-utf8dnf install -q -y git unzip rsync/usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern/usr/local/soft/modules/RedisJSON/deps/readies/bin/getrust/usr/local/soft/modules/RedisJSON/deps/readies/bin/getcmake --usrdnf install -q -y which/usr/local/soft/modules/RedisJSON/deps/readies/bin/getgcc --moderndir=$(mktemp -d /tmp/tar.XXXXXX); (cd $dir; wget --no-verbose -O tar.tgz http://redismodules.s3.amazonaws.com/readies/gnu/gnu-tar-1.32-x64-centos7.tgz; tar -xzf tar.tgz -C /; ); rm -rf $dirdnf install -q -y lcov/usr/bin/python3 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 -m pip install --disable-pip-version-check --user -r /usr/local/soft/modules/RedisJSON/tests/pytest/requirements.txt/usr/local/soft/modules/RedisJSON/deps/readies/bin/getawsNO_PY2=1 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getpudb# RedisJSON 的编译依赖 Rust 工具链，所以编译前需要安装rust，若已经安装则忽略# 安装 rustupcurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh# 按提示选择默认安装（通常选择 1）# 让 Rust 生效source $HOME/.cargo/env# 检查 rust 版本rustc --version # rustc 1.92.0 (ded5c06cf 2025-12-08)cargo --version # cargo 1.92.0 (344c4567c 2025-10-21)# 编译 RedisJSONmake# 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/rejson.so` ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下： install_raven 的报错参见 Redis 扩展模块 -- RedisBloom 进行修改。 12345678910111213141516171819202122232425262728293031323334353637383940./sbin/setup## 错误信息……dnf install -q -y llvm-toolset-7.0Error: Unable to find a match: llvm-toolset-7.0command failed: dnf install -q -y llvm-toolset-7.0command failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modernIn /usr/local/soft/modules/RedisJSON/sbin/setup:18 python3 -m pip list19 fi2021 &gt;&gt;&gt; $ROOT/sbin/system-setup.py22 if [[ $VERBOSE == 1 ]]; then23 python3 -m pip list24 fi# 错误分析与解决方法：问题原因： 操作系统的事，在 `deps/readies/bin/getclang`中有一个方法，其实一看就明白了 def redhat_compat(self): if not self.modern: return self.run(&quot;%s/bin/getepel&quot; % READIES, sudo=True) if self.dist in [&#x27;centos&#x27;, &#x27;ol&#x27;] and self.os_version[0] &gt;= 8: self.install(&quot;clang&quot;) self.install(&quot;llvm-toolset&quot;) else: self.install(&quot;llvm-toolset-7.0&quot;) self.cp_to_profile_d(&quot;/opt/rh/llvm-toolset-7.0/enable&quot;, &quot;llvm-toolset-7.0.sh&quot;) 我使用的机器不是 centos，所以就走else的逻辑了，另外这里即便走了 centos 逻辑，也有问题，就是el9中已经没有 llvm-toolset 了，取而代之的是 llvm，所以需要修改该方法修改方法如下： def redhat_compat(self): if not self.modern: return self.run(&quot;%s/bin/getepel&quot; % READIES, sudo=True) # 去掉判断，直接安装，前提是 el9 self.install(&quot;clang&quot;) self.install(&quot;llvm&quot;) Redis 启用模块 将生成的 rejson.so 拷贝到 redis 的 modules 目录下（非必须） 12# 注意 .so 文件需要包含可执行权限cp bin/linux-x64-release/rejson.so /usr/local/soft/redis-7.4.7/modules/rejson.so 本文采用 loadmodule 加载模块 1234567891011121314151617181920212223242526272829303132333435# 将 rejson.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/rejson.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; info Modules## 输出# Modules# Modulesmodule:name=ReJSON,ver=20816,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 20816 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisJSON 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-24T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/","title":"Redis 命令及数据类型 -- TDigest","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"T-Digest-分位数估计算法\">T-Digest(分位数估计算法)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>T-Digest（TDigest）解决的问题与 CMS、TopK 完全不同，核心目标是 分位数（quantile）统计。</p>\n</li>\n<li class=\"lvl-2\">\n<p>T-Digest 由 Ted Dunning 提出，专门为 <code>高精度尾部分位数</code> 设计。</p>\n</li>\n<li class=\"lvl-2\">\n<p>TDigest 可以在极低内存占用下，近似计算分位数（P50 / P90 / P99 / Median 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>分位数（Percentile）指标对照表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>英文全称</th>\n<th>数学含义</th>\n<th>通俗解释</th>\n<th>典型业务解读</th>\n<th>常见使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Median</td>\n<td>Median</td>\n<td>排序后位于中间位置的值</td>\n<td>一半数据在它左右</td>\n<td>“一般用户的体验”</td>\n<td>基础体验评估</td>\n</tr>\n<tr>\n<td>P50</td>\n<td>50th Percentile</td>\n<td>50% 的数据 ≤ 该值</td>\n<td>和 Median 完全相同</td>\n<td>“典型请求耗时”</td>\n<td>常规性能监控</td>\n</tr>\n<tr>\n<td>P90</td>\n<td>90th Percentile</td>\n<td>90% 的数据 ≤ 该值</td>\n<td>10% 的请求更慢</td>\n<td>“大多数用户的体验”</td>\n<td>业务体验监控</td>\n</tr>\n<tr>\n<td>P95</td>\n<td>95th Percentile</td>\n<td>95% 的数据 ≤ 该值</td>\n<td>5% 的请求更慢</td>\n<td>“尾部开始恶化”</td>\n<td>SLA 边界监控</td>\n</tr>\n<tr>\n<td>P99</td>\n<td>99th Percentile</td>\n<td>99% 的数据 ≤ 该值</td>\n<td>1% 的请求最慢</td>\n<td>“极端但真实的用户体验”</td>\n<td>核心 SLA / SLO</td>\n</tr>\n<tr>\n<td>P99.9</td>\n<td>99.9th Percentile</td>\n<td>99.9% 的数据 ≤ 该值</td>\n<td>千分之一最慢请求</td>\n<td>“极端尾延迟”</td>\n<td>金融 / 核心链路</td>\n</tr>\n<tr>\n<td>Max</td>\n<td>Maximum</td>\n<td>数据中的最大值</td>\n<td>最慢的那一次</td>\n<td>噪音极大</td>\n<td>几乎不用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>一个快速理解示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设 100 次请求：</span><br><span class=\"line\">    99 次耗时：10 ms</span><br><span class=\"line\">    1 次耗时：3000 ms</span><br><span class=\"line\"></span><br><span class=\"line\">所以：</span><br><span class=\"line\">    P99 = 3000 ms</span><br><span class=\"line\">    P90 = 10 ms</span><br><span class=\"line\">    P50/Median = 10 ms</span><br><span class=\"line\">    平均值 = （99*10 + 1*3000）/ 100 = 39.9 ms</span><br><span class=\"line\"></span><br><span class=\"line\">👉 只有 P99 真实暴露了问题。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>工程实践中的“标准搭配”</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>应用场景</th>\n<th>常看指标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web / API 服务</td>\n<td>P90 / P99</td>\n</tr>\n<tr>\n<td>微服务链路</td>\n<td>P99 / P99.9</td>\n</tr>\n<tr>\n<td>数据库 / 存储</td>\n<td>P95 / P99</td>\n</tr>\n<tr>\n<td>前端体验</td>\n<td>P50 / P90</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一句话：TDigest 用于统计数字的分布，P50 看中间，P90 看大多数，P99 看最差那 1%</p>\n</li>\n</ul>\n<h2 id=\"RedisBloom-中-TDigest-的核心命令\">RedisBloom 中 TDigest 的核心命令</h2>\n<h3 id=\"创建-TDigest\">创建 TDigest</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.CREATE key [COMPRESSION compression]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.CREATE latency:td COMPRESSION 200</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取 TDigest 的类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">TDIS-TYPE</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加样本\">添加样本</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.ADD key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.ADD latency:td 12.3 15.7 100.4</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看最大-最小值\">查看最大/最小值</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取最大值</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.MAX key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MAX latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\"><span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取最小值</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.MIN key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MIN latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\"><span class=\"string\">&quot;12.3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询分位数\">查询分位数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.QUANTILE key quantile [quantile ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># quantile： 查询的分位数，0.5=&gt;P50 / 0.9=&gt;P90 / 0.99=&gt;P99</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.QUANTILE latency:td 0.5 0.9 0.99</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;15.7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;100.4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"反向查询（值-→-百分位）\">反向查询（值 → 百分位）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.CDF key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.CDF latency:td 12.3 15.7 100.4 20</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;0.16666666666666666&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;0.5&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;0.8333333333333334&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;0.6666666666666666&quot;</span>  <span class=\"comment\"># 这里注意 value 不必须在 TDIGEST 中，这里的含义是 P66=20，即 66% 的值都 ≤ 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"合并-TDigest\">合并 TDigest</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.MERGE destination-key numkeys source-key [source-key ...] [COMPRESSION compression] [OVERRIDE]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># destination-key： 目标 TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># numkeys： 源 TDigest 的数量</span></span><br><span class=\"line\"><span class=\"comment\"># source-key： 源 TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class=\"line\"><span class=\"comment\"># OVERRIDE： 是否覆盖目标 TDigest，默认为 false</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MERGE latency:td 2 latency:td:1 latency:td:2 COMPRESSION 200 OVERRIDE</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取近似排名\">获取近似排名</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.RANK key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.ADD latency:td 12.3 15.7 100.4 # 假设这些数据已经写入了 TDigest</span></span><br><span class=\"line\"><span class=\"comment\"># 如果把 value 放入当前分布中，它的 rank（小于该值的样本数量）是多少</span></span><br><span class=\"line\">TDIGEST.RANK latency:td 0 12.3 15.7 20 100.4 200</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) -1   <span class=\"comment\"># 0: 小于最小值 12.3 → 返回 -1</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0    <span class=\"comment\"># 12.3: 第 0 位 → 返回 0，真实存在的位数</span></span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1    <span class=\"comment\"># 15.7: 排在 12.3 后 → 返回 1，真实存在的位数</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 2    <span class=\"comment\"># 20: 介于 15.7 与 100.4 之间 → 返回 2</span></span><br><span class=\"line\">5) (<span class=\"built_in\">integer</span>) 2    <span class=\"comment\"># 100.4: 第 2 位 → 20，真实存在的位数</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 3    <span class=\"comment\"># 200: 大于 100.4 → 返回 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 反向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.REVRANK key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.REVRANK latency:td 0 12.3 15.7 20 100.4 200</span><br></pre></td></tr></table></figure>\n<h2 id=\"根据排名获取元素\">根据排名获取元素</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.BYRANK key rank [rank ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.BYRANK latency:td 0 1 2 3</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;12.3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;15.7&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;inf&quot;</span>  <span class=\"comment\"># 不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 反向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.BYREVRANK key rank [rank ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.BYREVRANK latency:td 0 1 2 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"计算-TDigest-内部样本-去掉尾部极值后的平均近似值（Trimmed-Mean，截断均值）\">计算 TDigest 内部样本 去掉尾部极值后的平均近似值（Trimmed Mean，截断均值）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉数据分布的极端尾部，只算主要集中区域的平均值，这样更能代表“绝大多数用户的体验”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.TRIMMED_MEAN key low_cut_quantile high_cut_quantile</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># low_cut_quantile： 去掉的左侧百分比</span></span><br><span class=\"line\"><span class=\"comment\"># high_cut_quantile： 去掉的右侧百分比</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.TRIMMED_MEAN latency:td 0.05 0.95</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;42.800000000000004&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-TDigest-的信息\">获取 TDigest 的信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.INFO key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.INFO latency:td</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"> 1) Compression     <span class=\"comment\"># 压缩级别，控制质心的数量与精度。值越大 → 精度越高，内存稍大。</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 200</span><br><span class=\"line\"> 3) Capacity       <span class=\"comment\"># 质心最大容量。表示内部能容纳的最大节点数，实际使用中 TDigest 会动态合并质心以控制内存。</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 1210</span><br><span class=\"line\"> 5) Merged nodes   <span class=\"comment\"># 已合并的质心数量。这些是 TDigest 当前压缩后的节点，用于计算 rank / quantile。</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"> 7) Unmerged nodes <span class=\"comment\"># 未合并的节点数量。表示新加入但尚未压缩到质心的样本。</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"> 9) Merged weight  <span class=\"comment\"># 已合并质心的总权重。每个样本权重默认为 1，3 表示目前总共有 3 个样本被合并进质心。</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">11) Unmerged weight <span class=\"comment\"># 未合并节点的权重总和。0 表示没有未压缩的样本</span></span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">13) Observations    <span class=\"comment\"># 观测到的样本总数。你 TDIGEST.ADD 的 3 个样本正好对应这个值。</span></span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">15) Total compressions <span class=\"comment\"># 已经执行的压缩次数。每次 TDigest 内部质心合并称为一次压缩。</span></span><br><span class=\"line\">16) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">17) Memory usage     <span class=\"comment\"># Redis 为这个 TDigest 分配的内存（字节）。包含质心、索引、结构开销。TDigest 内存使用是固定的、与样本数量无关（主要由 Compression 决定）</span></span><br><span class=\"line\">18) (<span class=\"built_in\">integer</span>) 19368</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空元素\">清空元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.RESET key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.RESET latency:td</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h2 id=\"TDigest-的内存与精度\">TDigest 的内存与精度</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存占用</td>\n<td>与 COMPRESSION 成正比（通常 KB 级）</td>\n</tr>\n<tr>\n<td>精度</td>\n<td>尾部分位数（P95/P99）极高</td>\n</tr>\n<tr>\n<td>写入复杂度</td>\n<td>近似 O(log n)</td>\n</tr>\n<tr>\n<td>查询复杂度</td>\n<td>O(log n)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>与样本数量无关。</p>\n</blockquote>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom T-Digest(分位数估计算法) T-Digest（TDigest）解决的问题与 CMS、TopK 完全不同，核心目标是 分位数（quantile）统计。 T-Digest 由 Ted Dunning 提出，专门为 高精度尾部分位数 设计。 TDigest 可以在极低内存占用下，近似计算分位数（P50 / P90 / P99 / Median 等）。 分位数（Percentile）指标对照表 指标 英文全称 数学含义 通俗解释 典型业务解读 常见使用场景 Median Median 排序后位于中间位置的值 一半数据在它左右 “一般用户的体验” 基础体验评估 P50 50th Percentile 50% 的数据 ≤ 该值 和 Median 完全相同 “典型请求耗时” 常规性能监控 P90 90th Percentile 90% 的数据 ≤ 该值 10% 的请求更慢 “大多数用户的体验” 业务体验监控 P95 95th Percentile 95% 的数据 ≤ 该值 5% 的请求更慢 “尾部开始恶化” SLA 边界监控 P99 99th Percentile 99% 的数据 ≤ 该值 1% 的请求最慢 “极端但真实的用户体验” 核心 SLA / SLO P99.9 99.9th Percentile 99.9% 的数据 ≤ 该值 千分之一最慢请求 “极端尾延迟” 金融 / 核心链路 Max Maximum 数据中的最大值 最慢的那一次 噪音极大 几乎不用 一个快速理解示例 1234567891011假设 100 次请求： 99 次耗时：10 ms 1 次耗时：3000 ms所以： P99 = 3000 ms P90 = 10 ms P50/Median = 10 ms 平均值 = （99*10 + 1*3000）/ 100 = 39.9 ms👉 只有 P99 真实暴露了问题。 工程实践中的“标准搭配” 应用场景 常看指标 Web / API 服务 P90 / P99 微服务链路 P99 / P99.9 数据库 / 存储 P95 / P99 前端体验 P50 / P90 一句话：TDigest 用于统计数字的分布，P50 看中间，P90 看大多数，P99 看最差那 1% RedisBloom 中 TDigest 的核心命令 创建 TDigest 12345678910111213# TDIGEST.CREATE key [COMPRESSION compression]# 参数说明# key： TDigest 的名称# compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大# 示例TDIGEST.CREATE latency:td COMPRESSION 200# 返回值OK# 获取 TDigest 的类型type latency:td# 返回值TDIS-TYPE 添加样本 12345# TDIGEST.ADD key value [value ...]# 示例TDIGEST.ADD latency:td 12.3 15.7 100.4# 返回值OK 查看最大/最小值 12345678910111213# 获取最大值# TDIGEST.MAX key# 示例TDIGEST.MAX latency:td# 返回值&quot;100.4&quot;# 取最小值# TDIGEST.MIN key# 示例TDIGEST.MIN latency:td# 返回值&quot;12.3&quot; 查询分位数 12345678910# TDIGEST.QUANTILE key quantile [quantile ...]# 参数说明# key： TDigest 的名称# quantile： 查询的分位数，0.5=&gt;P50 / 0.9=&gt;P90 / 0.99=&gt;P99# 示例TDIGEST.QUANTILE latency:td 0.5 0.9 0.99# 返回值1) &quot;15.7&quot;2) &quot;100.4&quot;3) &quot;100.4&quot; 反向查询（值 → 百分位） 12345678# TDIGEST.CDF key value [value ...]# 示例TDIGEST.CDF latency:td 12.3 15.7 100.4 20# 返回值1) &quot;0.16666666666666666&quot;2) &quot;0.5&quot;3) &quot;0.8333333333333334&quot;4) &quot;0.6666666666666666&quot; # 这里注意 value 不必须在 TDIGEST 中，这里的含义是 P66=20，即 66% 的值都 ≤ 20 合并 TDigest 1234567891011# TDIGEST.MERGE destination-key numkeys source-key [source-key ...] [COMPRESSION compression] [OVERRIDE]# 参数说明# destination-key： 目标 TDigest 的名称# numkeys： 源 TDigest 的数量# source-key： 源 TDigest 的名称# compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大# OVERRIDE： 是否覆盖目标 TDigest，默认为 false# 示例TDIGEST.MERGE latency:td 2 latency:td:1 latency:td:2 COMPRESSION 200 OVERRIDE# 返回值OK 获取近似排名 123456789101112131415161718# 正向排名# TDIGEST.RANK key value [value ...]# 示例# TDIGEST.ADD latency:td 12.3 15.7 100.4 # 假设这些数据已经写入了 TDigest# 如果把 value 放入当前分布中，它的 rank（小于该值的样本数量）是多少TDIGEST.RANK latency:td 0 12.3 15.7 20 100.4 200# 返回值1) (integer) -1 # 0: 小于最小值 12.3 → 返回 -12) (integer) 0 # 12.3: 第 0 位 → 返回 0，真实存在的位数3) (integer) 1 # 15.7: 排在 12.3 后 → 返回 1，真实存在的位数4) (integer) 2 # 20: 介于 15.7 与 100.4 之间 → 返回 25) (integer) 2 # 100.4: 第 2 位 → 20，真实存在的位数6) (integer) 3 # 200: 大于 100.4 → 返回 3# 反向排名# TDIGEST.REVRANK key value [value ...]# 示例TDIGEST.REVRANK latency:td 0 12.3 15.7 20 100.4 200 根据排名获取元素 1234567891011121314# 正向排名# TDIGEST.BYRANK key rank [rank ...]# 示例TDIGEST.BYRANK latency:td 0 1 2 3# 输出结果1) &quot;12.3&quot;2) &quot;15.7&quot;3) &quot;100.4&quot;4) &quot;inf&quot; # 不存在# 反向排名# TDIGEST.BYREVRANK key rank [rank ...]# 示例TDIGEST.BYREVRANK latency:td 0 1 2 3 计算 TDigest 内部样本 去掉尾部极值后的平均近似值（Trimmed Mean，截断均值） 去掉数据分布的极端尾部，只算主要集中区域的平均值，这样更能代表“绝大多数用户的体验” 123456789# TDIGEST.TRIMMED_MEAN key low_cut_quantile high_cut_quantile# 参数说明# key： TDigest 的名称# low_cut_quantile： 去掉的左侧百分比# high_cut_quantile： 去掉的右侧百分比# 示例TDIGEST.TRIMMED_MEAN latency:td 0.05 0.95# 输出结果&quot;42.800000000000004&quot; 获取 TDigest 的信息 12345678910111213141516171819202122# TDIGEST.INFO key# 示例TDIGEST.INFO latency:td# 输出结果 1) Compression # 压缩级别，控制质心的数量与精度。值越大 → 精度越高，内存稍大。 2) (integer) 200 3) Capacity # 质心最大容量。表示内部能容纳的最大节点数，实际使用中 TDigest 会动态合并质心以控制内存。 4) (integer) 1210 5) Merged nodes # 已合并的质心数量。这些是 TDigest 当前压缩后的节点，用于计算 rank / quantile。 6) (integer) 3 7) Unmerged nodes # 未合并的节点数量。表示新加入但尚未压缩到质心的样本。 8) (integer) 0 9) Merged weight # 已合并质心的总权重。每个样本权重默认为 1，3 表示目前总共有 3 个样本被合并进质心。10) (integer) 311) Unmerged weight # 未合并节点的权重总和。0 表示没有未压缩的样本12) (integer) 013) Observations # 观测到的样本总数。你 TDIGEST.ADD 的 3 个样本正好对应这个值。14) (integer) 315) Total compressions # 已经执行的压缩次数。每次 TDigest 内部质心合并称为一次压缩。16) (integer) 117) Memory usage # Redis 为这个 TDigest 分配的内存（字节）。包含质心、索引、结构开销。TDigest 内存使用是固定的、与样本数量无关（主要由 Compression 决定）18) (integer) 19368 清空元素 12345# TDIGEST.RESET key# 示例TDIGEST.RESET latency:td# 输出结果OK TDigest 的内存与精度 维度 特性 内存占用 与 COMPRESSION 成正比（通常 KB 级） 精度 尾部分位数（P95/P99）极高 写入复杂度 近似 O(log n) 查询复杂度 O(log n) 与样本数量无关。","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-23T07:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/","title":"Redis 命令及数据类型 -- TopK","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"TopK\">TopK</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>TopK，专门用于解决 “在海量数据流中，实时找出最热门的 N 个元素” 这一类问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>Top-K 属于流式重频（Heavy Hitters）算法家族，其目标不是记录所有元素，而是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">在受限内存下，持续维护出现频率最高的 K 个元素</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>TopK 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">固定容量：只维护 K 个元素</span><br><span class=\"line\">近似统计：计数可能略有误差</span><br><span class=\"line\">自动淘汰：低频元素会被踢出</span><br><span class=\"line\">写入极快：适合高 QPS</span><br><span class=\"line\">内存稳定：与数据规模无关</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RedisBloom 的 TopK 内部使用 CMS 作为频次估算基础，并结合<code>堆+淘汰策略</code>来维护热点集合。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">CMS: 参考 <a href=\"/2025/12/23/redis7-datatype-13-CMS/\" title=\"Redis 命令及数据类型 -- CMS(Count-Min Sketch)\">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li>\n<li class=\"lvl-6\">堆+淘汰策略: TopK 在内部如何决定谁能进入 TopK、谁必须被踢出 TopK 的一整套机制。\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">堆：TopK 使用一个最小堆来维护 TopK 元素，TopK 维护 K 个候选元素，堆顶永远是 当前 TopK 中频次最低的那个</li>\n<li class=\"lvl-10\">淘汰策略：TopK 使用一个 LRU 缓存来记录最近访问的元素，当 TopK 元素数量达到上限时，将 LRU 缓存中的元素逐个加入 TopK，并更新 TopK 元素的频率。</li>\n<li class=\"lvl-10\">一句话：当新元素的估算频次超过当前最弱的那个时，就把弱者淘汰掉，让新元素进榜。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"当一个新元素到来时，我该不该让它进入-TopK？\">当一个新元素到来时，我该不该让它进入 TopK？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下面是 TopK 在 TOPK.ADD 时的真实逻辑抽象</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Step 1：更新 CMS（不存 item，只更新计数器）</span></span><br><span class=\"line\">CMS.increment(item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 2：item 是否在 TopK 显式集合中？</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> item <span class=\"keyword\">in</span> TopK:</span><br><span class=\"line\">    <span class=\"comment\"># 重新平衡堆位置</span></span><br><span class=\"line\">    update_heap(item)</span><br><span class=\"line\">    <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 3：TopK 是否未满？</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> TopK.size &lt; K:</span><br><span class=\"line\">    TopK.insert(item)</span><br><span class=\"line\">    <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 4：比较 CMS 估算值</span></span><br><span class=\"line\">freq_new = CMS.query(item)</span><br><span class=\"line\">freq_min = CMS.query(TopK.min_item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> freq_new &gt; freq_min:</span><br><span class=\"line\">    TopK.evict_min()</span><br><span class=\"line\">    TopK.insert(item)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 什么都不做</span></span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-的应用场景\">TopK 的应用场景</h2>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>TopK 是否适合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>当前访问量最高的 URL</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>搜索热词 Top 10</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>商品点击榜</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>所有商品的点击次数</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>精确计数</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RedisBloom-TopK-的核心命令\">RedisBloom TopK 的核心命令</h2>\n<h3 id=\"创建-TopK\">创建 TopK</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用 TopK 前必须先创建 TopK</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.RESERVE key topk [width depth decay]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key: 键名</span></span><br><span class=\"line\"><span class=\"comment\"># topk: 存储的元素数量，即统计的前 K 个元素</span></span><br><span class=\"line\"><span class=\"comment\"># width: 内部CMS 的宽度，默认 8</span></span><br><span class=\"line\"><span class=\"comment\"># depth: 内部CMS 的深度，默认 7</span></span><br><span class=\"line\"><span class=\"comment\"># decay: 衰减因子（0 ~ 1），默认 0.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：维护访问量最高的 100 个 URL，允许历史热度逐渐衰减。</span></span><br><span class=\"line\">TOPK.RESERVE topk:urls 100 2000 7 0.9</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> topk:urls</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">TopK-TYPE</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\">添加元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.ADD key items [items ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：添加元素 &quot;a&quot; 和 &quot;b&quot; 到 TopK 中</span></span><br><span class=\"line\">TOPK.ADD topk:urls a b</span><br><span class=\"line\"><span class=\"comment\"># 返回值，被挤出 TopK 的元素（如果有）</span></span><br><span class=\"line\">1) (nil)</span><br><span class=\"line\">2) (nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加元素的频率\">增加元素的频率</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.INCRBY key item increment [item increment ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：将元素 &quot;a&quot; 的频率增加 1</span></span><br><span class=\"line\">TOPK.INCRBY topk:urls a 1</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) (nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询元素是否在-TopK-中\">查询元素是否在 TopK 中</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.QUERY key item [item ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：查询元素 &quot;a&quot; 是否在 TopK 中</span></span><br><span class=\"line\">TOPK.QUERY topk:urls a</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 1 表示元素 &quot;a&quot; 在 TopK 中，0 表示元素 &quot;a&quot; 不在 TopK 中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-TopK-中的元素\">获取 TopK 中的元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.LIST key [WITHCOUNT]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCOUNT: 是否返回每个元素出现的次数，默认不返回</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：获取 TopK 中的元素，并返回每个元素出现的次数</span></span><br><span class=\"line\">TOPK.LIST topk:urls WITHCOUNT</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">3) <span class=\"string\">&quot;b&quot;</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取近似计数\">获取近似计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.COUNT key item [item ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：获取元素 &quot;a&quot; 的近似计数</span></span><br><span class=\"line\">TOPK.COUNT topk:urls a</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看TopK-的状态\">查看TopK 的状态</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.INFO key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：查看 TopK 的状态</span></span><br><span class=\"line\">TOPK.INFO topk:urls</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) k                    <span class=\"comment\"># topk 的大小</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 100</span><br><span class=\"line\">3) width                <span class=\"comment\"># 内部 CMS 的宽度</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 2000</span><br><span class=\"line\">5) depth                <span class=\"comment\"># 内部 CMS 的深度</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 7</span><br><span class=\"line\">7) decay                <span class=\"comment\"># 衰减因子</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;0.9&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-的衰减（decay）参数怎么理解\">TopK 的衰减（decay）参数怎么理解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>decay 用于解决一个问题：“老热点永远霸榜，新热点上不来”</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>decay</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.0</td>\n<td>永不衰减（全历史统计）</td>\n</tr>\n<tr>\n<td>0.9</td>\n<td>越老的数据权重越低</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>热点更新非常快</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>经验值：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">实时热点：0.8 ~ 0.9</li>\n<li class=\"lvl-6\">长周期榜单：0.95 ~ 1.0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CMS-和-TopK-组合使用场景\">CMS 和 TopK 组合使用场景</h2>\n<h3 id=\"📌场景1：-实时热搜榜（最经典组合）\">📌场景1： 实时热搜榜（最经典组合）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计所有搜索词频次（CMS），同时实时出TOP10热搜（TOPK），既知热度又能排序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 初始化CMS（统计全量搜索词计数，误差0.001）</span></span><br><span class=\"line\">cms.initbyprob search_count 0.001 0.01</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 初始化TOPK（取TOP10热搜）</span></span><br><span class=\"line\">topk.reserve search_top10 10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 用户搜索核心操作（2命令必一起执行）</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索&quot;周杰伦&quot;，CMS计数+1，同时录入TOPK（自动累加热度）</span></span><br><span class=\"line\">cms.incrby search_count 周杰伦 1</span><br><span class=\"line\">topk.incrby search_top10 周杰伦 1</span><br><span class=\"line\"></span><br><span class=\"line\">cms.incrby search_count 原神 1</span><br><span class=\"line\">topk.incrby search_top10 原神 1</span><br><span class=\"line\">cms.incrby search_count 周杰伦 1  <span class=\"comment\"># 重复搜索，双端同步+1</span></span><br><span class=\"line\">topk.incrby search_top10 周杰伦 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 核心查询：先取TOP10，再查精准计数（组合核心）</span></span><br><span class=\"line\"><span class=\"comment\"># 第一步：取TOP10热搜列表</span></span><br><span class=\"line\">topk.list search_top10  <span class=\"comment\"># 返回：周杰伦、原神...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二步：查热搜词精准近似计数（CMS比TOPK.count更准）</span></span><br><span class=\"line\">cms.query search_count 周杰伦  <span class=\"comment\"># 返回2（精准）</span></span><br><span class=\"line\">topk.count search_top10 周杰伦  <span class=\"comment\"># 参考值，优先用CMS结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 辅助查询：判断词是否在热搜榜</span></span><br><span class=\"line\">topk.query search_top10 周杰伦  <span class=\"comment\"># 1=在，0=不在</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-vs-ZSET\">TopK vs ZSET</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能力边界对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>TopK</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否近似</td>\n<td>✔️ 是</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td>是否保存全部元素</td>\n<td>❌ 只保存 Top K</td>\n<td>✔️ 保存全部</td>\n</tr>\n<tr>\n<td>频次是否精确</td>\n<td>❌ 估计</td>\n<td>✔️ 精确</td>\n</tr>\n<tr>\n<td>是否支持排序</td>\n<td>⚠️ 仅 Top K</td>\n<td>✔️ 全量排序</td>\n</tr>\n<tr>\n<td>是否可遍历</td>\n<td>❌ 仅 K 个</td>\n<td>✔️ 全量</td>\n</tr>\n<tr>\n<td>是否支持删除</td>\n<td>❌ 不支持</td>\n<td>✔️ 支持</td>\n</tr>\n<tr>\n<td>是否支持范围查询</td>\n<td>❌</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>Top N 查询</td>\n<td>✔️ 原生</td>\n<td>✔️</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>性能与吞吐量对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>TopK</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入复杂度</td>\n<td>O(d)</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>高并发写入</td>\n<td>极优</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>查询 TopK</td>\n<td>O(K)</td>\n<td>O(K)</td>\n</tr>\n<tr>\n<td>查询单元素频次</td>\n<td>O(d)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>批量写入</td>\n<td>极快</td>\n<td>较慢</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom TopK TopK，专门用于解决 “在海量数据流中，实时找出最热门的 N 个元素” 这一类问题 Top-K 属于流式重频（Heavy Hitters）算法家族，其目标不是记录所有元素，而是： 在受限内存下，持续维护出现频率最高的 K 个元素 TopK 的核心特性 12345固定容量：只维护 K 个元素近似统计：计数可能略有误差自动淘汰：低频元素会被踢出写入极快：适合高 QPS内存稳定：与数据规模无关 RedisBloom 的 TopK 内部使用 CMS 作为频次估算基础，并结合堆+淘汰策略来维护热点集合。 CMS: 参考 Redis 命令及数据类型 -- CMS(Count-Min Sketch) 堆+淘汰策略: TopK 在内部如何决定谁能进入 TopK、谁必须被踢出 TopK 的一整套机制。 堆：TopK 使用一个最小堆来维护 TopK 元素，TopK 维护 K 个候选元素，堆顶永远是 当前 TopK 中频次最低的那个 淘汰策略：TopK 使用一个 LRU 缓存来记录最近访问的元素，当 TopK 元素数量达到上限时，将 LRU 缓存中的元素逐个加入 TopK，并更新 TopK 元素的频率。 一句话：当新元素的估算频次超过当前最弱的那个时，就把弱者淘汰掉，让新元素进榜。 当一个新元素到来时，我该不该让它进入 TopK？ 下面是 TopK 在 TOPK.ADD 时的真实逻辑抽象 123456789101112131415161718192021222324# Step 1：更新 CMS（不存 item，只更新计数器）CMS.increment(item)# Step 2：item 是否在 TopK 显式集合中？if item in TopK: # 重新平衡堆位置 update_heap(item) return# Step 3：TopK 是否未满？if TopK.size &lt; K: TopK.insert(item) return# Step 4：比较 CMS 估算值freq_new = CMS.query(item)freq_min = CMS.query(TopK.min_item)if freq_new &gt; freq_min: TopK.evict_min() TopK.insert(item)else: # 什么都不做 pass TopK 的应用场景 问题 TopK 是否适合 当前访问量最高的 URL ✅ 搜索热词 Top 10 ✅ 商品点击榜 ✅ 所有商品的点击次数 ❌ 精确计数 ❌ RedisBloom TopK 的核心命令 创建 TopK 使用 TopK 前必须先创建 TopK 123456789101112131415161718# TOPK.RESERVE key topk [width depth decay]# 参数说明# key: 键名# topk: 存储的元素数量，即统计的前 K 个元素# width: 内部CMS 的宽度，默认 8# depth: 内部CMS 的深度，默认 7# decay: 衰减因子（0 ~ 1），默认 0.9# 示例# 含义：维护访问量最高的 100 个 URL，允许历史热度逐渐衰减。TOPK.RESERVE topk:urls 100 2000 7 0.9# 返回值OK# 验证类型type topk:urls# 返回值TopK-TYPE 添加元素 1234567# TOPK.ADD key items [items ...]# 示例# 含义：添加元素 &quot;a&quot; 和 &quot;b&quot; 到 TopK 中TOPK.ADD topk:urls a b# 返回值，被挤出 TopK 的元素（如果有）1) (nil)2) (nil) 增加元素的频率 123456# TOPK.INCRBY key item increment [item increment ...]# 示例# 含义：将元素 &quot;a&quot; 的频率增加 1TOPK.INCRBY topk:urls a 1# 输出结果1) (nil) 查询元素是否在 TopK 中 123456# TOPK.QUERY key item [item ...]# 示例# 含义：查询元素 &quot;a&quot; 是否在 TopK 中TOPK.QUERY topk:urls a# 返回值1) (integer) 1 # 1 表示元素 &quot;a&quot; 在 TopK 中，0 表示元素 &quot;a&quot; 不在 TopK 中 获取 TopK 中的元素 1234567891011# TOPK.LIST key [WITHCOUNT]# 参数说明# WITHCOUNT: 是否返回每个元素出现的次数，默认不返回# 示例# 含义：获取 TopK 中的元素，并返回每个元素出现的次数TOPK.LIST topk:urls WITHCOUNT# 输出结果1) &quot;a&quot;2) (integer) 23) &quot;b&quot;4) (integer) 1 获取近似计数 123456# TOPK.COUNT key item [item ...]# 示例# 含义：获取元素 &quot;a&quot; 的近似计数TOPK.COUNT topk:urls a# 输出结果1) (integer) 2 查看TopK 的状态 12345678910111213# TOPK.INFO key# 示例# 含义：查看 TopK 的状态TOPK.INFO topk:urls# 输出结果1) k # topk 的大小2) (integer) 1003) width # 内部 CMS 的宽度4) (integer) 20005) depth # 内部 CMS 的深度6) (integer) 77) decay # 衰减因子8) &quot;0.9&quot; TopK 的衰减（decay）参数怎么理解 decay 用于解决一个问题：“老热点永远霸榜，新热点上不来” decay 行为 1.0 永不衰减（全历史统计） 0.9 越老的数据权重越低 0.5 热点更新非常快 经验值： 实时热点：0.8 ~ 0.9 长周期榜单：0.95 ~ 1.0 CMS 和 TopK 组合使用场景 📌场景1： 实时热搜榜（最经典组合） 需求：统计所有搜索词频次（CMS），同时实时出TOP10热搜（TOPK），既知热度又能排序 1234567891011121314151617181920212223242526# 1. 初始化CMS（统计全量搜索词计数，误差0.001）cms.initbyprob search_count 0.001 0.01# 2. 初始化TOPK（取TOP10热搜）topk.reserve search_top10 10# 3. 用户搜索核心操作（2命令必一起执行）# 搜索&quot;周杰伦&quot;，CMS计数+1，同时录入TOPK（自动累加热度）cms.incrby search_count 周杰伦 1topk.incrby search_top10 周杰伦 1cms.incrby search_count 原神 1topk.incrby search_top10 原神 1cms.incrby search_count 周杰伦 1 # 重复搜索，双端同步+1topk.incrby search_top10 周杰伦 1# 4. 核心查询：先取TOP10，再查精准计数（组合核心）# 第一步：取TOP10热搜列表topk.list search_top10 # 返回：周杰伦、原神...# 第二步：查热搜词精准近似计数（CMS比TOPK.count更准）cms.query search_count 周杰伦 # 返回2（精准）topk.count search_top10 周杰伦 # 参考值，优先用CMS结果# 5. 辅助查询：判断词是否在热搜榜topk.query search_top10 周杰伦 # 1=在，0=不在 TopK vs ZSET 能力边界对比 能力 TopK ZSet 是否近似 ✔️ 是 ❌ 否 是否保存全部元素 ❌ 只保存 Top K ✔️ 保存全部 频次是否精确 ❌ 估计 ✔️ 精确 是否支持排序 ⚠️ 仅 Top K ✔️ 全量排序 是否可遍历 ❌ 仅 K 个 ✔️ 全量 是否支持删除 ❌ 不支持 ✔️ 支持 是否支持范围查询 ❌ ✔️ Top N 查询 ✔️ 原生 ✔️ 性能与吞吐量对比 维度 TopK ZSet 写入复杂度 O(d) O(log N) 高并发写入 极优 一般 查询 TopK O(K) O(K) 查询单元素频次 O(d) O(1) 批量写入 极快 较慢","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-23T06:50:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/","title":"Redis 命令及数据类型 -- CMS(Count-Min Sketch)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Count-Min-Sketch\">Count-Min Sketch</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Count-Min Sketch（CMS） 用于在极低内存占用下，对高频写入的计数型数据进行近似统计，非常适合流量、事件、关键词等“只关心频次规模、不要求精确值”的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Count-Min Sketch 是一种基于哈希的概率型计数结构，用于估算元素出现次数，具有以下核心特征：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">只会高估，不会低估（over-estimation）</li>\n<li class=\"lvl-6\">固定内存，与元素种类数无关</li>\n<li class=\"lvl-6\">O(1) 的更新与查询复杂度</li>\n<li class=\"lvl-6\">不支持删除（或只能近似删除）</li>\n<li class=\"lvl-6\">只能返回给定元素近似统计其频次，而无法返回全部元素的统计频次</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>基本工作原理（简化版）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.初始化一个二维数组 counter[d][w]</span><br><span class=\"line\">2.对每个元素 x：</span><br><span class=\"line\">    a. 通过 d 个哈希函数映射到 d 行中的 w 个位置</span><br><span class=\"line\">    b. 对对应的 d 个计数器全部 +1</span><br><span class=\"line\">3.查询元素 x 的频次：</span><br><span class=\"line\">    a.取这 d 个计数器的 最小值(取最小值是为了尽量抵消哈希冲突带来的“多加”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意下图中的数组不是二进制的，每次映射都会+1<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Ybl5tj.png\" alt=\"\"></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>误差与空间复杂度</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>误差上界</td>\n<td>≤ ε × 总插入次数</td>\n</tr>\n<tr>\n<td>错误概率</td>\n<td>≤ δ</td>\n</tr>\n<tr>\n<td>空间复杂度</td>\n<td>O(1 / ε × log(1 / δ))</td>\n</tr>\n<tr>\n<td>查询复杂度</td>\n<td>O(d)</td>\n</tr>\n<tr>\n<td>更新复杂度</td>\n<td>O(d)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>结论：数据量再大，内存不增长，代价是“精度换空间”</p>\n</blockquote>\n<h2 id=\"RedisBloom-中-CMS-的核心命令\">RedisBloom 中 CMS 的核心命令</h2>\n<h3 id=\"创建-CMS\">创建 CMS</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按底层维度初始化</span></span><br><span class=\"line\"><span class=\"comment\"># CMS.INITBYDIM key width depth</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># width (w)：每一行的桶数（影响误差）</span></span><br><span class=\"line\"><span class=\"comment\"># depth (d)：哈希函数数量（影响冲突概率）</span></span><br><span class=\"line\"><span class=\"comment\"># 比如：</span></span><br><span class=\"line\">CMS.INITBYDIM page:view 1000 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> page:view</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">CMSk-TYPE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按误差+容量初始化</span></span><br><span class=\"line\"><span class=\"comment\"># CMS.INITBYPROB page:view error probability</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># error (ε)：误差上界</span></span><br><span class=\"line\"><span class=\"comment\"># probability (δ)：超过误差上界的概率，这个数字越接近零，每个项目的内存消耗就越大，每次操作的CPU使用就越多。</span></span><br><span class=\"line\"><span class=\"comment\"># RedisBloom 会自动换算 w 和 d</span></span><br><span class=\"line\"><span class=\"comment\"># 比如：</span></span><br><span class=\"line\">CMS.INITBYPROB key 0.001 0.01</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>数值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>error</code></td>\n<td><code>0.001</code></td>\n<td>最大相对误差 ε = 0.1%</td>\n</tr>\n<tr>\n<td><code>probability</code></td>\n<td><code>0.01</code></td>\n<td>只有 1% 的概率超过该误差</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"增加计数\">增加计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.INCRBY key item1 count1 item2 count2 ...</span></span><br><span class=\"line\">CMS.INCRBY page:view home 1 about 1 home 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询计数\">查询计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.QUERY key item1 item2 ...</span></span><br><span class=\"line\">CMS.QUERY page:view home about</span><br><span class=\"line\"><span class=\"comment\"># 返回的是 估算值（可能偏大）</span></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并-CMS\">合并 CMS</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.MERGE dest numkeys src1 src2 ... WEIGHTS w1 w2 ...</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># dest：目标 CMS，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># numkeys：源 CMS 数量</span></span><br><span class=\"line\"><span class=\"comment\"># src1 src2 ...：源 CMS，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># WEIGHTS w1 w2 ...：源 CMS 权重</span></span><br><span class=\"line\">CMS.MERGE page:view 2 page:view:1 page:view:2 WEIGHTS 1 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-CMS-的信息\">获取 CMS 的信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.INFO key</span></span><br><span class=\"line\">CMS.INFO page:view</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) width            <span class=\"comment\"># 每一行桶数 w</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\">3) depth            <span class=\"comment\"># 哈希函数数量 d</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">5) count            <span class=\"comment\"># 当前已插入的元素数量</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h2 id=\"CMS-的使用场景\">CMS 的使用场景</h2>\n<h3 id=\"场景1：网站PV统计\">场景1：网站PV统计</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计网站 PV，即页面被访问的次数，允许0.1%的误差</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化 CMS</span></span><br><span class=\"line\">CMS.INITBYPROB page:pv 0.001 0.01</span><br><span class=\"line\"><span class=\"comment\"># 添加计数</span></span><br><span class=\"line\">CMS.INCRBY page:pv /home 1 /about 1</span><br><span class=\"line\">CMS.INCRBY page:pv /home 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询计数</span></span><br><span class=\"line\">CMS.QUERY page:pv /home</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景2：接口调用频次限流前置统计\">场景2：接口调用频次限流前置统计</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计接口调用次数，为限流提供已经，不需要精准计数，允许0.1%的误差</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 CMS</span></span><br><span class=\"line\">CMS.INITBYPROB api:<span class=\"built_in\">limit</span> 0.001 0.01</span><br><span class=\"line\"><span class=\"comment\"># 添加计数</span></span><br><span class=\"line\">CMS.INCRBY api:<span class=\"built_in\">limit</span> /api/user/list 1</span><br><span class=\"line\"><span class=\"comment\"># 获取计数</span></span><br><span class=\"line\">CMS.QUERY api:<span class=\"built_in\">limit</span> /api/user/list</span><br></pre></td></tr></table></figure>\n<h2 id=\"CMS-vs-ZSET\">CMS vs ZSET</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能力边界对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>CMS</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>频次统计</td>\n<td>✔️ 近似</td>\n<td>✔️ 精确</td>\n</tr>\n<tr>\n<td>是否存元素</td>\n<td>❌ 不存</td>\n<td>✔️ 存</td>\n</tr>\n<tr>\n<td>是否可遍历元素</td>\n<td>❌ 不可</td>\n<td>✔️ 可</td>\n</tr>\n<tr>\n<td>TopK / 排行</td>\n<td>❌（需配合 TopK）</td>\n<td>✔️ 天然支持</td>\n</tr>\n<tr>\n<td>删除元素</td>\n<td>❌ 不支持</td>\n<td>✔️ 支持</td>\n</tr>\n<tr>\n<td>误判 / 误差</td>\n<td>✔️ 存在</td>\n<td>❌ 无</td>\n</tr>\n<tr>\n<td>是否可逆（查成员）</td>\n<td>❌ 不可逆</td>\n<td>✔️ 可逆</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>性能特征对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>CMS</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入 / 计数</td>\n<td>O(d)（常数级）</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>查询频次</td>\n<td>O(d)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>排名查询</td>\n<td>❌</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>批量写入</td>\n<td>极快</td>\n<td>中等</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom Count-Min Sketch Count-Min Sketch（CMS） 用于在极低内存占用下，对高频写入的计数型数据进行近似统计，非常适合流量、事件、关键词等“只关心频次规模、不要求精确值”的场景。 Count-Min Sketch 是一种基于哈希的概率型计数结构，用于估算元素出现次数，具有以下核心特征： 只会高估，不会低估（over-estimation） 固定内存，与元素种类数无关 O(1) 的更新与查询复杂度 不支持删除（或只能近似删除） 只能返回给定元素近似统计其频次，而无法返回全部元素的统计频次 基本工作原理（简化版） 1234561.初始化一个二维数组 counter[d][w]2.对每个元素 x： a. 通过 d 个哈希函数映射到 d 行中的 w 个位置 b. 对对应的 d 个计数器全部 +13.查询元素 x 的频次： a.取这 d 个计数器的 最小值(取最小值是为了尽量抵消哈希冲突带来的“多加”) 注意下图中的数组不是二进制的，每次映射都会+1 误差与空间复杂度 维度 说明 误差上界 ≤ ε × 总插入次数 错误概率 ≤ δ 空间复杂度 O(1 / ε × log(1 / δ)) 查询复杂度 O(d) 更新复杂度 O(d) 结论：数据量再大，内存不增长，代价是“精度换空间” RedisBloom 中 CMS 的核心命令 创建 CMS 1234567891011121314151617181920212223# 按底层维度初始化# CMS.INITBYDIM key width depth# 参数说明# width (w)：每一行的桶数（影响误差）# depth (d)：哈希函数数量（影响冲突概率）# 比如：CMS.INITBYDIM page:view 1000 10# 输出OK# 验证类型type page:view# 返回值CMSk-TYPE# 按误差+容量初始化# CMS.INITBYPROB page:view error probability# 参数说明# error (ε)：误差上界# probability (δ)：超过误差上界的概率，这个数字越接近零，每个项目的内存消耗就越大，每次操作的CPU使用就越多。# RedisBloom 会自动换算 w 和 d# 比如：CMS.INITBYPROB key 0.001 0.01 参数 数值 说明 error 0.001 最大相对误差 ε = 0.1% probability 0.01 只有 1% 的概率超过该误差 增加计数 123456# CMS.INCRBY key item1 count1 item2 count2 ...CMS.INCRBY page:view home 1 about 1 home 1# 输出1) (integer) 12) (integer) 13) (integer) 2 查询计数 123456# CMS.QUERY key item1 item2 ...CMS.QUERY page:view home about# 返回的是 估算值（可能偏大）# 输出1) (integer) 22) (integer) 1 合并 CMS 123456789# CMS.MERGE dest numkeys src1 src2 ... WEIGHTS w1 w2 ...# 参数说明# dest：目标 CMS，必须存在# numkeys：源 CMS 数量# src1 src2 ...：源 CMS，必须存在# WEIGHTS w1 w2 ...：源 CMS 权重CMS.MERGE page:view 2 page:view:1 page:view:2 WEIGHTS 1 1# 输出OK 获取 CMS 的信息 123456789# CMS.INFO keyCMS.INFO page:view# 输出1) width # 每一行桶数 w2) (integer) 10003) depth # 哈希函数数量 d4) (integer) 105) count # 当前已插入的元素数量6) (integer) 3 CMS 的使用场景 场景1：网站PV统计 需求：统计网站 PV，即页面被访问的次数，允许0.1%的误差 12345678# 初始化 CMSCMS.INITBYPROB page:pv 0.001 0.01# 添加计数CMS.INCRBY page:pv /home 1 /about 1CMS.INCRBY page:pv /home 1# 查询计数CMS.QUERY page:pv /home 场景2：接口调用频次限流前置统计 需求：统计接口调用次数，为限流提供已经，不需要精准计数，允许0.1%的误差 123456# 创建 CMSCMS.INITBYPROB api:limit 0.001 0.01# 添加计数CMS.INCRBY api:limit /api/user/list 1# 获取计数CMS.QUERY api:limit /api/user/list CMS vs ZSET 能力边界对比 能力 CMS ZSet 频次统计 ✔️ 近似 ✔️ 精确 是否存元素 ❌ 不存 ✔️ 存 是否可遍历元素 ❌ 不可 ✔️ 可 TopK / 排行 ❌（需配合 TopK） ✔️ 天然支持 删除元素 ❌ 不支持 ✔️ 支持 误判 / 误差 ✔️ 存在 ❌ 无 是否可逆（查成员） ❌ 不可逆 ✔️ 可逆 性能特征对比 操作 CMS ZSet 插入 / 计数 O(d)（常数级） O(log N) 查询频次 O(d) O(1) 排名查询 ❌ O(log N) 批量写入 极快 中等","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-23T06:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","title":"Redis 命令及数据类型 -- CF(Cuckoo Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Cuckoo-Filter（布谷鸟过滤器）\">Cuckoo Filter（布谷鸟过滤器）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Cuckoo Filter 是 Bloom Filter 的改进版，支持 动态添加和删除元素，仍能提供比布隆过滤器更高的查询性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</p>\n</li>\n<li class=\"lvl-2\">\n<p>优点：低误判率 + 高负载率，基于相同的集合和误报率，Cuckoo Filter通常占用空间更少。相对的，算法实现也就更复杂。</p>\n</li>\n<li class=\"lvl-2\">\n<p>缺点：与Bloom Filter一样，有可能将一个不在集合中的元素错误的判断成在集合中</p>\n</li>\n<li class=\"lvl-2\">\n<p>Bloom Filter 的误报率通过调整<code>位数组的大小</code>和<code>哈希函数数量</code>来控制，而 Cuckoo Filter 的误报率受<code>指纹大小</code>和<code>桶大小</code>控制。</p>\n</li>\n</ul>\n<h3 id=\"布谷哈希算法\">布谷哈希算法</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://baike.baidu.com/item/Cockoo%20hash/3022855\">百度百科对布谷哈希算法的描述</a>]</p>\n</li>\n<li class=\"lvl-2\">\n<p>算法使用两个不同哈希函数计算对应 key 的位置。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<ol>\n<li class=\"lvl-9\">当两个哈希任意位置为空，则随机选择一个位置插入</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"2\">\n<li class=\"lvl-9\">当两个哈希有位置为空时，则插入到空位置</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"3\">\n<li class=\"lvl-9\">当两个哈希位置均不为空时，随机选择一个位置插入并踢出原key，原key会再次经过计算获得新的位置，转至1执行，反复直到成功或者达到最大迭代次数。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Cuckoo-Filter-的实现原理\">Cuckoo Filter 的实现原理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>布谷过滤器 是在<code>布谷哈希算法</code>的算法基础上扩充来的，但是它所提供的概念不是表，而是提供了多个数据桶(Bucket)</p>\n</li>\n<li class=\"lvl-2\">\n<p>每一个数据桶都是个<code>一维数组</code>，每个数组的保存内容为<code>条目(Entry)</code>，每一个条目里面可以保存一个<code>指纹数据</code>(指纹数据就是原始数据经过哈希计算得到的一个n位的数据标记)，除了指纹数据之外，还会同时得出一个<code>保存位置P1标记</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当两个数据计算得到的指纹数据相同时，就会发生冲突，冲突操作的解决思路是使用<code>布谷哈希算法</code>，简单说就是新的数据会将原有数据<code>踢出</code>，而被踢出的数据会被重新计算得到新的指纹数据和保存位置标记。</p>\n</li>\n<li class=\"lvl-2\">\n<p>布谷过滤器里面需要进行各种数据的<code>踢出</code>操作，这个踢出的方式就是使用<code>P1标志位</code>和<code>指纹数据</code>进行<code>异或计算</code>得出来的<code>P2标志位</code>，按照同样的思路(前提:一直都有冲突操作)一直计算新的P2位，直到冲突解决或者达到最大迭代次数，就会失败。</p>\n</li>\n<li class=\"lvl-2\">\n<p>指纹数据里面包含有<code>唯一性</code>，所以可以实现数据的删除，当然，不同的数据计算是有可能得到相同指纹的，那么一旦删除数据之后，有可能造成数据的&quot;假删除&quot;，所以布谷过滤器本身也是存在有误差的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Cuckoo Filter 中的 <code>BUSKETSIZE</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">BUSKETSIZE，表示每个桶(Busket)中存放的元素个数，即桶大小。</li>\n<li class=\"lvl-6\">Cuckoo Filter的数组里存的不是位，而是桶(busket)，每个桶里可以存放多个数据。</li>\n<li class=\"lvl-6\">同一个桶中存放的数据越多，空间利用率更高，相应的误判率也就越高，性能也更慢。</li>\n<li class=\"lvl-6\">Redis的CuckooFilter实现中，BUSKETSIZE应该是一个在1到255之间的整数，默认的 BUSKETSIZE 是 <code>2</code>。</li>\n<li class=\"lvl-6\">桶(Busket)中并不实际保存数据本身，而是保存数据的指纹(fingerprint)。指纹越小，HASH冲突造成误判的几率就越小。这个参数的调整比较复杂，Redis的CuckooFilter中不支持调整这个参数。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CF-命令说明\">CF 命令说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>CF.xxx</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CF.RESERVE</strong></td>\n<td>显式创建 Cuckoo Filter</td>\n<td>是</td>\n<td><code>capacity</code>：容量(必填)<br><code>BUCKETSIZE</code>：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)<br><code>MAXITERATIONS</code>：重排次数，越大成功率越高<br><code>EXPANSION</code>：扩容倍数，默认 1（不扩容）</td>\n<td>OK</td>\n<td><code>CF.RESERVE user:cf 100000</code></td>\n<td>✅ <strong>生产推荐</strong><br>支持删除与计数</td>\n</tr>\n<tr>\n<td><strong>CF.ADD</strong></td>\n<td>添加一个元素，不去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code>：元素</td>\n<td>OK</td>\n<td><code>CF.ADD user:cf user_1</code></td>\n<td>若满可能失败</td>\n</tr>\n<tr>\n<td><strong>CF.ADDNX</strong></td>\n<td>元素不存在时才添加，去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code></td>\n<td><code>1</code> 新增<br><code>0</code> 已存在</td>\n<td><code>CF.ADDNX user:cf user_1</code></td>\n<td>幂等写入首选</td>\n</tr>\n<tr>\n<td><strong>CF.INSERT</strong></td>\n<td>批量插入</td>\n<td>是（不存在则创建）</td>\n<td><code>ITEMS</code>：元素列表</td>\n<td>OK</td>\n<td><code>CF.INSERT user:cf ITEMS u1 u2</code></td>\n<td>默认配置</td>\n</tr>\n<tr>\n<td><strong>CF.INSERTNX</strong></td>\n<td>批量插入（不存在才加）</td>\n<td>是</td>\n<td><code>ITEMS</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.INSERTNX user:cf ITEMS u1 u2</code></td>\n<td>幂等 + 批量</td>\n</tr>\n<tr>\n<td><strong>CF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 可能存在<br><code>0</code> 不存在</td>\n<td><code>CF.EXISTS user:cf user_1</code></td>\n<td>仍有误判</td>\n</tr>\n<tr>\n<td><strong>CF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.MEXISTS user:cf u1 u9</code></td>\n<td>高并发推荐</td>\n</tr>\n<tr>\n<td><strong>CF.COUNT</strong></td>\n<td>返回元素出现次数</td>\n<td>否</td>\n<td><code>item</code></td>\n<td>整数</td>\n<td><code>CF.COUNT user:cf user_1</code></td>\n<td>⭐ Bloom 没有的能力</td>\n</tr>\n<tr>\n<td><strong>CF.DEL</strong></td>\n<td>删除一个元素</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 删除成功<br><code>0</code> 不存在</td>\n<td><code>CF.DEL user:cf user_1</code></td>\n<td>⭐ Bloom 不支持</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://CF.INFO\">CF.INFO</a></strong></td>\n<td>查看 Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>CF.INFO user:cf</code></td>\n<td>运维分析</td>\n</tr>\n<tr>\n<td><strong>CF.SCANDUMP</strong></td>\n<td>分块导出 Filter</td>\n<td>否</td>\n<td><code>iterator</code></td>\n<td><code>iterator + data</code></td>\n<td><code>CF.SCANDUMP user:cf 0</code></td>\n<td>迁移 / 备份</td>\n</tr>\n<tr>\n<td><strong>CF.LOADCHUNK</strong></td>\n<td>从 dump 恢复 Filter</td>\n<td>是</td>\n<td><code>iterator + data</code></td>\n<td>OK</td>\n<td><code>CF.LOADCHUNK user:cf 1 &quot;xxx&quot;</code></td>\n<td>与 SCANDUMP 配合</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Bloom-vs-Cuckoo\">Bloom vs Cuckoo</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Bloom Filter</th>\n<th>Cuckoo Filter</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查询复杂度</td>\n<td>O(k)（k 个哈希函数）</td>\n<td>O(1)（2–4 次 bucket 访问）</td>\n</tr>\n<tr>\n<td>插入复杂度</td>\n<td>O(k)</td>\n<td>平均 O(1)，最坏可能触发重排</td>\n</tr>\n<tr>\n<td>删除支持</td>\n<td>❌ 原生不支持</td>\n<td>✅ 原生支持</td>\n</tr>\n<tr>\n<td>误判率（False Positive）</td>\n<td>可配置，稳定</td>\n<td>可配置，通常更低</td>\n</tr>\n<tr>\n<td>漏判（False Negative）</td>\n<td>❌ 理论上不会</td>\n<td>❌ 理论上不会</td>\n</tr>\n<tr>\n<td>空间利用率</td>\n<td>高（但受 k 影响）</td>\n<td>通常更高（特别是低误判率）</td>\n</tr>\n<tr>\n<td>扩容成本</td>\n<td>高（需重建）</td>\n<td>中等（支持扩展策略）</td>\n</tr>\n<tr>\n<td>实现复杂度</td>\n<td>低</td>\n<td>较高</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>RedisBloom Cuckoo Filter 不支持设置 <code>误判率</code>，通常 容量 越大，误判率越低。</p>\n</blockquote>\n<h2 id=\"CF-命令示例\">CF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Cuckoo Filter</span></span><br><span class=\"line\"><span class=\"comment\">## 容量1000，这个是必填参数。后面几个都是可选参数。</span></span><br><span class=\"line\"><span class=\"comment\">## BUSKETSIZE越大，空间利用率更高，但是误判率也更高，性能更差，默认2</span></span><br><span class=\"line\"><span class=\"comment\">## MAXITARATIONS越小，性能越好。如果设置越大，空间利用率就越好。默认20</span></span><br><span class=\"line\"><span class=\"comment\">## EXPANSION 是指空间扩容的比例。默认1，不扩容</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 可以重复添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回元素出现次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.EXISTS user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 删除元素，一次只删除一个</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 因为user_1有两个，所以才是还是能查询出 user_1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 再次删除</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 同名元素已全部删除，查询不到</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元素不存在时才添加，幂等</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Filter 元信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INFO user:cf</span><br><span class=\"line\"> 1) Size                      <span class=\"comment\"># 当前 Cuckoo Filter 实际占用的内存大小（字节）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1080</span><br><span class=\"line\"> 3) Number of buckets         <span class=\"comment\"># 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2)</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\"> 5) Number of filters         <span class=\"comment\"># 内部 子 Cuckoo Filter 的数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 成功插入的元素总数（近似）</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"> 9) Number of items deleted   <span class=\"comment\"># 已删除元素的累计次数</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">11) Bucket size               <span class=\"comment\"># 每个 bucket 可容纳的 fingerprint 数，默认为 2</span></span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">13) Expansion rate            <span class=\"comment\"># 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）</span></span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">15) Max iterations            <span class=\"comment\"># Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升</span></span><br><span class=\"line\">16) (<span class=\"built_in\">integer</span>) 500</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量添加，key不存在则创建</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order2</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 幂等，元素不存在时才添加</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> order:cf</span><br><span class=\"line\">MBbloomCF</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisCuckooFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 CuckooFilter 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCuckooFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCuckooFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key      Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity 预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter（高级参数）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key           Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity      预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bucketSize    每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxIterations 重排次数，越大成功率越高</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expansion     扩容倍数，默认 1（不扩容）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">int</span> bucketSize, <span class=\"type\">int</span> maxIterations, <span class=\"type\">int</span> expansion)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> String.format(</span><br><span class=\"line\">                <span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;</span>,</span><br><span class=\"line\">                capacity, bucketSize, maxIterations, expansion</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（不去重）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（仅当不存在时）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 表示成功插入，false 表示已存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addNx</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应的结果，1 表示存在，0 表示不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回元素出现次数（近似）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">count</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除元素</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 删除成功，false 表示不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">delete</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，不去重</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，去重</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">insertNx</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Cuckoo Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Long&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Long&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> (Long) result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字节数组转字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * info 返回的 List</span></span><br><span class=\"line\"><span class=\"comment\">     * [</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Size&quot;),                  Long(1080),</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Number of buckets&quot;),     Long(512),</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Number of filters&quot;),     Long(1),</span></span><br><span class=\"line\"><span class=\"comment\">     * ...</span></span><br><span class=\"line\"><span class=\"comment\">     * ]</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom Cuckoo Filter（布谷鸟过滤器） Cuckoo Filter 是 Bloom Filter 的改进版，支持 动态添加和删除元素，仍能提供比布隆过滤器更高的查询性能。 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 优点：低误判率 + 高负载率，基于相同的集合和误报率，Cuckoo Filter通常占用空间更少。相对的，算法实现也就更复杂。 缺点：与Bloom Filter一样，有可能将一个不在集合中的元素错误的判断成在集合中 Bloom Filter 的误报率通过调整位数组的大小和哈希函数数量来控制，而 Cuckoo Filter 的误报率受指纹大小和桶大小控制。 布谷哈希算法 百度百科对布谷哈希算法的描述] 算法使用两个不同哈希函数计算对应 key 的位置。 当两个哈希任意位置为空，则随机选择一个位置插入 当两个哈希有位置为空时，则插入到空位置 当两个哈希位置均不为空时，随机选择一个位置插入并踢出原key，原key会再次经过计算获得新的位置，转至1执行，反复直到成功或者达到最大迭代次数。 Cuckoo Filter 的实现原理 布谷过滤器 是在布谷哈希算法的算法基础上扩充来的，但是它所提供的概念不是表，而是提供了多个数据桶(Bucket) 每一个数据桶都是个一维数组，每个数组的保存内容为条目(Entry)，每一个条目里面可以保存一个指纹数据(指纹数据就是原始数据经过哈希计算得到的一个n位的数据标记)，除了指纹数据之外，还会同时得出一个保存位置P1标记。 当两个数据计算得到的指纹数据相同时，就会发生冲突，冲突操作的解决思路是使用布谷哈希算法，简单说就是新的数据会将原有数据踢出，而被踢出的数据会被重新计算得到新的指纹数据和保存位置标记。 布谷过滤器里面需要进行各种数据的踢出操作，这个踢出的方式就是使用P1标志位和指纹数据进行异或计算得出来的P2标志位，按照同样的思路(前提:一直都有冲突操作)一直计算新的P2位，直到冲突解决或者达到最大迭代次数，就会失败。 指纹数据里面包含有唯一性，所以可以实现数据的删除，当然，不同的数据计算是有可能得到相同指纹的，那么一旦删除数据之后，有可能造成数据的&quot;假删除&quot;，所以布谷过滤器本身也是存在有误差的。 Cuckoo Filter 中的 BUSKETSIZE BUSKETSIZE，表示每个桶(Busket)中存放的元素个数，即桶大小。 Cuckoo Filter的数组里存的不是位，而是桶(busket)，每个桶里可以存放多个数据。 同一个桶中存放的数据越多，空间利用率更高，相应的误判率也就越高，性能也更慢。 Redis的CuckooFilter实现中，BUSKETSIZE应该是一个在1到255之间的整数，默认的 BUSKETSIZE 是 2。 桶(Busket)中并不实际保存数据本身，而是保存数据的指纹(fingerprint)。指纹越小，HASH冲突造成误判的几率就越小。这个参数的调整比较复杂，Redis的CuckooFilter中不支持调整这个参数。 CF 命令说明 对应Redis命令： CF.xxx 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 CF.RESERVE 显式创建 Cuckoo Filter 是 capacity：容量(必填)BUCKETSIZE：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)MAXITERATIONS：重排次数，越大成功率越高EXPANSION：扩容倍数，默认 1（不扩容） OK CF.RESERVE user:cf 100000 ✅ 生产推荐支持删除与计数 CF.ADD 添加一个元素，不去重 是 （不存在则创建） item：元素 OK CF.ADD user:cf user_1 若满可能失败 CF.ADDNX 元素不存在时才添加，去重 是 （不存在则创建） item 1 新增0 已存在 CF.ADDNX user:cf user_1 幂等写入首选 CF.INSERT 批量插入 是（不存在则创建） ITEMS：元素列表 OK CF.INSERT user:cf ITEMS u1 u2 默认配置 CF.INSERTNX 批量插入（不存在才加） 是 ITEMS 0/1 列表 CF.INSERTNX user:cf ITEMS u1 u2 幂等 + 批量 CF.EXISTS 判断单个元素是否存在 否 item 1 可能存在0 不存在 CF.EXISTS user:cf user_1 仍有误判 CF.MEXISTS 批量判断是否存在 否 item... 0/1 列表 CF.MEXISTS user:cf u1 u9 高并发推荐 CF.COUNT 返回元素出现次数 否 item 整数 CF.COUNT user:cf user_1 ⭐ Bloom 没有的能力 CF.DEL 删除一个元素 否 item 1 删除成功0 不存在 CF.DEL user:cf user_1 ⭐ Bloom 不支持 CF.INFO 查看 Filter 元信息 否 无 KV 列表 CF.INFO user:cf 运维分析 CF.SCANDUMP 分块导出 Filter 否 iterator iterator + data CF.SCANDUMP user:cf 0 迁移 / 备份 CF.LOADCHUNK 从 dump 恢复 Filter 是 iterator + data OK CF.LOADCHUNK user:cf 1 &quot;xxx&quot; 与 SCANDUMP 配合 Bloom vs Cuckoo 维度 Bloom Filter Cuckoo Filter 查询复杂度 O(k)（k 个哈希函数） O(1)（2–4 次 bucket 访问） 插入复杂度 O(k) 平均 O(1)，最坏可能触发重排 删除支持 ❌ 原生不支持 ✅ 原生支持 误判率（False Positive） 可配置，稳定 可配置，通常更低 漏判（False Negative） ❌ 理论上不会 ❌ 理论上不会 空间利用率 高（但受 k 影响） 通常更高（特别是低误判率） 扩容成本 高（需重建） 中等（支持扩展策略） 实现复杂度 低 较高 RedisBloom Cuckoo Filter 不支持设置 误判率，通常 容量 越大，误判率越低。 CF 命令示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 创建 Cuckoo Filter## 容量1000，这个是必填参数。后面几个都是可选参数。## BUSKETSIZE越大，空间利用率更高，但是误判率也更高，性能更差，默认2## MAXITARATIONS越小，性能越好。如果设置越大，空间利用率就越好。默认20## EXPANSION 是指空间扩容的比例。默认1，不扩容127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2OK# 添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1127.0.0.1:6379&gt; CF.ADD user:cf user_2(integer) 1# 可以重复添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1# 返回元素出现次数127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 2# 判断元素是否存在127.0.0.1:6379&gt; CF.EXISTS user:cf user_1(integer) 1# 批量判断元素是否存在127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_1001) (integer) 12) (integer) 13) (integer) 0# 删除元素，一次只删除一个127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 因为user_1有两个，所以才是还是能查询出 user_1127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 1# 再次删除127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 同名元素已全部删除，查询不到127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 0# 元素不存在时才添加，幂等127.0.0.1:6379&gt; CF.ADDNX user:cf user_2(integer) 0127.0.0.1:6379&gt; CF.ADDNX user:cf user_3(integer) 1# 查看 Filter 元信息127.0.0.1:6379&gt; CF.INFO user:cf 1) Size # 当前 Cuckoo Filter 实际占用的内存大小（字节） 2) (integer) 1080 3) Number of buckets # 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2) 4) (integer) 512 5) Number of filters # 内部 子 Cuckoo Filter 的数量 6) (integer) 1 7) Number of items inserted # 成功插入的元素总数（近似） 8) (integer) 2 9) Number of items deleted # 已删除元素的累计次数10) (integer) 211) Bucket size # 每个 bucket 可容纳的 fingerprint 数，默认为 212) (integer) 213) Expansion rate # 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）14) (integer) 215) Max iterations # Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升16) (integer) 500# 批量添加，key不存在则创建127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order21) (integer) 12) (integer) 1# 幂等，元素不存在时才添加127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order1001) (integer) 02) (integer) 03) (integer) 1# 查看类型127.0.0.1:6379&gt; type order:cfMBbloomCF SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisCuckooFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240package com.example.redisbloom;/** * 基于 RedisBloom 插件的 CuckooFilter 实现 * https://github.com/RedisBloom/RedisBloom/releases */import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;@Component@Slf4jpublic class RedisCuckooFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisCuckooFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 Cuckoo Filter * &lt;p&gt; * 不能重复创建 * * @param key Filter 名称 * @param capacity 预计容量 */ public boolean reserve(String key, long capacity) &#123; String script = &quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot; + capacity + &quot;)&quot;; try&#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisCuckooFilterTool reserve error:&quot;,e); return false; &#125; &#125; /** * 初始化 Cuckoo Filter（高级参数） * * 不能重复创建 * * @param key Filter 名称 * @param capacity 预计容量 * @param bucketSize 每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解) * @param maxIterations 重排次数，越大成功率越高 * @param expansion 扩容倍数，默认 1（不扩容） */ public boolean reserve(String key, long capacity, int bucketSize, int maxIterations, int expansion) &#123; String script = String.format( &quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot; + &quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;, capacity, bucketSize, maxIterations, expansion ); try&#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisCuckooFilterTool reserve error:&quot;,e); return false; &#125; &#125; /** * 添加元素（不去重） */ public boolean add(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 添加元素（仅当不存在时） * * @return true 表示成功插入，false 表示已存在 */ public boolean addNx(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量判断是否存在 * @return 每个元素对应的结果，1 表示存在，0 表示不存在 */ public List&lt;Long&gt; mexists(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 返回元素出现次数（近似） */ public Long count(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key), value ); &#125; /** * 删除元素 * * @return true 删除成功，false 表示不存在 */ public boolean delete(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;; final Long execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量插入，不去重 * @return 每个元素对应插入结果，1 插入成功，0 插入失败 */ public List&lt;Long&gt; insert(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 批量插入，去重 * @return 每个元素对应插入结果，1 插入成功，0 插入失败 */ public List&lt;Boolean&gt; insertNx(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 获取 Cuckoo Filter 元信息 */ public Map&lt;String, Long&gt; info(String key) &#123; String script = &quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;; List&lt;Object&gt; result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Long&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Long value = (Long) result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; /** * 字节数组转字符串 * info 返回的 List * [ * byte[](&quot;Size&quot;), Long(1080), * byte[](&quot;Number of buckets&quot;), Long(512), * byte[](&quot;Number of filters&quot;), Long(1), * ... * ] */ private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125;","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-22T06:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","title":"Redis 命令及数据类型 -- BF(Bloom Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bloom-Filter-布隆过滤器\">Bloom Filter(布隆过滤器)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>布隆过滤器是一种用于快速判断元素是否存在的 probabilistic data structure（概率数据结构），非常适合海量数据且不要求绝对精确的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>布隆过滤器使用一个很长的二进制位数组和一系列哈希函数来保存元素。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">优点: 非常节省空间、查询快</li>\n<li class=\"lvl-6\">缺点: 有一定的误判概率、无法删除元素、无法给元素计数</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>布隆过滤器判断一个元素不在集合中，那么这个元素肯定不在集合中。但是，布隆过滤器判断一个元素在集合中，那么这个元素有可能不在集合中。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/l7rGDM.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>位数组（Bit Array）：布隆过滤器使用一个长度固定的位数组来存储数据。每个位置只占用一个比特（0或1），初始时所有位都设置为0。位数组的长度和哈希函数的数量决定了过滤器的误报率和容量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>哈希函数集合：布隆过滤器使用多个哈希函数，每个函数都会将输入数据映射到位数组的一个不同位置。哈希函数的选择对过滤器的性能有很大影响，理想的哈希函数应该具有良好的散列性，使得不同的输入尽可能均匀地映射到位数组的不同位置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如何降低误判率？</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">更大的位数组</li>\n<li class=\"lvl-6\">更多的哈希函数</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>很多人都是用过Google开源的Guava的布隆过滤器，但其是JVM层的布隆过滤器，若需要分布式布隆过滤器，就可以使用RedisBloom提供的BF(Bloom Filter)。</p>\n</li>\n</ul>\n<h2 id=\"BF-命令说明\">BF 命令说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>BF.xxx</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>BF.RESERVE</strong></td>\n<td>显式创建 Bloom Filter</td>\n<td>是（已存在则报错）</td>\n<td><code>error_rate</code>：误判率<br><code>capacity</code>：预计元素数<br><code>EXPANSION</code>：扩容倍率</td>\n<td>OK</td>\n<td><code>BF.RESERVE user:bf 0.001 1000000</code></td>\n<td>✅ <strong>生产推荐</strong><br>显式规划容量与误判率，避免隐式创建</td>\n</tr>\n<tr>\n<td><strong>BF.ADD</strong></td>\n<td>添加单个元素</td>\n<td>是（不存在则创建）</td>\n<td>无</td>\n<td><code>1</code> 新增<br><code>0</code> 可能已存在</td>\n<td><code>BF.ADD user:bf user_1</code></td>\n<td>Key 必须已存在，否则报错</td>\n</tr>\n<tr>\n<td><strong>BF.MADD</strong></td>\n<td>批量添加元素</td>\n<td>是（不存在则创建）</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MADD user:bf u1 u2 u3</code></td>\n<td>⚠ 使用默认配置，不建议生产</td>\n</tr>\n<tr>\n<td><strong>BF.INSERT</strong></td>\n<td>批量插入（可控参数）</td>\n<td>是</td>\n<td><code>CAPACITY</code>：容量<br><code>ERROR</code>：误判率<br><code>NOCREATE</code>:不自动创建过滤器<br><code>NONSCALING</code>: 不扩容，达到capacity时，过滤器返回错误<br><code>EXPANSION expansion</code>:扩容时，新建子过滤器的容量增长倍率，默认2 <br><code>ITEMS</code>：元素列表</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2</code></td>\n<td>✅ <strong>最推荐的写入方式</strong><br>支持初始化 + 插入</td>\n</tr>\n<tr>\n<td><strong>BF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code>：待判断元素</td>\n<td><code>1</code> 可能存在<br><code>0</code> 一定不存在</td>\n<td><code>BF.EXISTS user:bf user_1</code></td>\n<td>不存在结果 <strong>绝对可靠</strong></td>\n</tr>\n<tr>\n<td><strong>BF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MEXISTS user:bf u1 u9</code></td>\n<td>高并发批量查询首选</td>\n</tr>\n<tr>\n<td><strong>BF.CARD</strong></td>\n<td>返回插入元素数量（近似）</td>\n<td>否</td>\n<td>无</td>\n<td>整数</td>\n<td><code>BF.CARD user:bf</code></td>\n<td>用于容量监控，非精确</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://BF.INFO\">BF.INFO</a></strong></td>\n<td>返回 Bloom Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>BF.INFO user:bf</code></td>\n<td>运维、容量与内存分析必备</td>\n</tr>\n<tr>\n<td><strong>BF.SCANDUMP</strong></td>\n<td>分块导出 Bloom Filter</td>\n<td>否</td>\n<td><code>iterator</code>：游标</td>\n<td><code>iterator + data</code></td>\n<td><code>BF.SCANDUMP user:bf 0</code></td>\n<td>用于迁移、备份</td>\n</tr>\n<tr>\n<td><strong>BF.LOADCHUNK</strong></td>\n<td>从 dump 数据恢复 Filter</td>\n<td>是</td>\n<td><code>iterator</code><br><code>data</code></td>\n<td>OK</td>\n<td><code>BF.LOADCHUNK user:bf 1 &quot;xxx&quot;</code></td>\n<td>必须与 SCANDUMP 配合使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"BF-命令示例\">BF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化一个BloomFilter，错误率0.01，元素数量1000</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.RESERVE <span class=\"built_in\">test</span> 0.01 1000</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">MBbloom--</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MADD <span class=\"built_in\">test</span> user3 user4 user5</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回Bloom过滤器的基数，即添加的元素数量(存在误差)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.CARD <span class=\"built_in\">test</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 批量查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MEXISTS <span class=\"built_in\">test</span> user1 user2 user6</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.INFO <span class=\"built_in\">test</span></span><br><span class=\"line\"> 1) Capacity       <span class=\"comment\"># 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\"> 3) Size           <span class=\"comment\"># 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 1480</span><br><span class=\"line\"> 5) Number of filters <span class=\"comment\"># 当前 key 内部包含的 Bloom Filter 数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 已调用 BF.ADD / BF.MADD 插入的元素总数</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"> 9) Expansion rate     <span class=\"comment\"># Bloom Filter 扩容时，新建子过滤器的容量增长倍率</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisBloomFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 BloomFilter 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 不想安装插件也可以使用 Redission 的 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisBloomFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisBloomFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率，比如为0.01，即 1%</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量，比如为1000</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">double</span> errorRate, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot;</span> + errorRate + <span class=\"string\">&quot;, &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisBloomFilterTool reserve error:&quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 RedisModule 提供的 BF.ADD 命令</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">addBatch</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> items     要添加的元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">double</span> errorRate, String... items)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], &#x27;CAPACITY&#x27;, ARGV[1], &#x27;ERROR&#x27;, ARGV[2], &#x27;ITEMS&#x27;, unpack(ARGV, 3))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Object&gt; args = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        args.add(String.valueOf(capacity));</span><br><span class=\"line\">        args.add(String.valueOf(errorRate));</span><br><span class=\"line\">        Collections.addAll(args, items);   <span class=\"comment\">// ✅ 关键点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.INSERT 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                args.toArray()</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 存在 1，不存在 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取元素数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">card</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 RedisModule 提供的 BF.CARD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Bloom Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Long&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Long&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> (Long) result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redisson-的-BloomFilter-的使用方法\">Redisson 的 BloomFilter 的使用方法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(<span class=\"string\">&quot;bloomFilter&quot;</span>);</span><br><span class=\"line\">bloomFilter.tryInit(<span class=\"number\">1000000</span>, <span class=\"number\">0.01</span>);</span><br><span class=\"line\">bloomFilter.add(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">System.out.println(bloomFilter.contains(<span class=\"string\">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom Bloom Filter(布隆过滤器) 布隆过滤器是一种用于快速判断元素是否存在的 probabilistic data structure（概率数据结构），非常适合海量数据且不要求绝对精确的场景。 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 布隆过滤器使用一个很长的二进制位数组和一系列哈希函数来保存元素。 优点: 非常节省空间、查询快 缺点: 有一定的误判概率、无法删除元素、无法给元素计数 布隆过滤器判断一个元素不在集合中，那么这个元素肯定不在集合中。但是，布隆过滤器判断一个元素在集合中，那么这个元素有可能不在集合中。 位数组（Bit Array）：布隆过滤器使用一个长度固定的位数组来存储数据。每个位置只占用一个比特（0或1），初始时所有位都设置为0。位数组的长度和哈希函数的数量决定了过滤器的误报率和容量。 哈希函数集合：布隆过滤器使用多个哈希函数，每个函数都会将输入数据映射到位数组的一个不同位置。哈希函数的选择对过滤器的性能有很大影响，理想的哈希函数应该具有良好的散列性，使得不同的输入尽可能均匀地映射到位数组的不同位置。 如何降低误判率？ 更大的位数组 更多的哈希函数 很多人都是用过Google开源的Guava的布隆过滤器，但其是JVM层的布隆过滤器，若需要分布式布隆过滤器，就可以使用RedisBloom提供的BF(Bloom Filter)。 BF 命令说明 对应Redis命令： BF.xxx 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 BF.RESERVE 显式创建 Bloom Filter 是（已存在则报错） error_rate：误判率capacity：预计元素数EXPANSION：扩容倍率 OK BF.RESERVE user:bf 0.001 1000000 ✅ 生产推荐显式规划容量与误判率，避免隐式创建 BF.ADD 添加单个元素 是（不存在则创建） 无 1 新增0 可能已存在 BF.ADD user:bf user_1 Key 必须已存在，否则报错 BF.MADD 批量添加元素 是（不存在则创建） item...：多个元素 0/1 列表 BF.MADD user:bf u1 u2 u3 ⚠ 使用默认配置，不建议生产 BF.INSERT 批量插入（可控参数） 是 CAPACITY：容量ERROR：误判率NOCREATE:不自动创建过滤器NONSCALING: 不扩容，达到capacity时，过滤器返回错误EXPANSION expansion:扩容时，新建子过滤器的容量增长倍率，默认2 ITEMS：元素列表 0/1 列表 BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2 ✅ 最推荐的写入方式支持初始化 + 插入 BF.EXISTS 判断单个元素是否存在 否 item：待判断元素 1 可能存在0 一定不存在 BF.EXISTS user:bf user_1 不存在结果 绝对可靠 BF.MEXISTS 批量判断是否存在 否 item...：多个元素 0/1 列表 BF.MEXISTS user:bf u1 u9 高并发批量查询首选 BF.CARD 返回插入元素数量（近似） 否 无 整数 BF.CARD user:bf 用于容量监控，非精确 BF.INFO 返回 Bloom Filter 元信息 否 无 KV 列表 BF.INFO user:bf 运维、容量与内存分析必备 BF.SCANDUMP 分块导出 Bloom Filter 否 iterator：游标 iterator + data BF.SCANDUMP user:bf 0 用于迁移、备份 BF.LOADCHUNK 从 dump 数据恢复 Filter 是 iteratordata OK BF.LOADCHUNK user:bf 1 &quot;xxx&quot; 必须与 SCANDUMP 配合使用 BF 命令示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 初始化一个BloomFilter，错误率0.01，元素数量1000127.0.0.1:6379&gt; BF.RESERVE test 0.01 1000OK# 查看类型127.0.0.1:6379&gt; type testMBbloom--# 添加元素127.0.0.1:6379&gt; BF.ADD test user1(integer) 1127.0.0.1:6379&gt; BF.ADD test user2(integer) 1# 批量添加元素127.0.0.1:6379&gt; BF.MADD test user3 user4 user51) (integer) 12) (integer) 13) (integer) 1# 返回Bloom过滤器的基数，即添加的元素数量(存在误差)127.0.0.1:6379&gt; BF.CARD test(integer) 5# 查询元素是否存在127.0.0.1:6379&gt; BF.EXISTS test user2(integer) 1127.0.0.1:6379&gt; BF.EXISTS test user6(integer) 0# 批量查询元素是否存在127.0.0.1:6379&gt; BF.MEXISTS test user1 user2 user61) (integer) 12) (integer) 13) (integer) 0# 获取信息127.0.0.1:6379&gt; BF.INFO test 1) Capacity # 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter） 2) (integer) 1000 3) Size # 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少 4) (integer) 1480 5) Number of filters # 当前 key 内部包含的 Bloom Filter 数量 6) (integer) 1 7) Number of items inserted # 已调用 BF.ADD / BF.MADD 插入的元素总数 8) (integer) 5 9) Expansion rate # Bloom Filter 扩容时，新建子过滤器的容量增长倍率10) (integer) 2 SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisBloomFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.example.redisbloom;/** * 基于 RedisBloom 插件的 BloomFilter 实现 * https://github.com/RedisBloom/RedisBloom/releases * &lt;p&gt; * 不想安装插件也可以使用 Redission 的 BloomFilter */import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.*;@Component@Slf4jpublic class RedisBloomFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisBloomFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 BloomFilter * &lt;p&gt; * 不能重复创建 * * @param key BloomFilter 名称 * @param errorRate 错误率，比如为0.01，即 1% * @param capacity 容量，比如为1000 */ public boolean reserve(String key, double errorRate, long capacity) &#123; String script = &quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot; + errorRate + &quot;, &quot; + capacity + &quot;)&quot;; try &#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisBloomFilterTool reserve error:&quot;, e); return false; &#125; &#125; /** * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建 */ public boolean add(String key, String value) &#123; // 使用 RedisModule 提供的 BF.ADD 命令 String script = &quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; String script = &quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量添加 * @return 添加结果列表，成功 1，失败 0 */ public List&lt;Long&gt; addBatch(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 调用 BF.MADD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate * * @param key BloomFilter 名称 * @param capacity 容量 * @param errorRate 错误率 * @param items 要添加的元素 * @return 添加结果列表，成功 1，失败 0 */ public List&lt;Long&gt; insert(String key, long capacity, double errorRate, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], &#x27;CAPACITY&#x27;, ARGV[1], &#x27;ERROR&#x27;, ARGV[2], &#x27;ITEMS&#x27;, unpack(ARGV, 3))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; List&lt;Object&gt; args = new ArrayList&lt;&gt;(); args.add(String.valueOf(capacity)); args.add(String.valueOf(errorRate)); Collections.addAll(args, items); // ✅ 关键点 // 调用 BF.INSERT 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), args.toArray() ); &#125; /** * 批量判断元素是否存在 * @return 存在 1，不存在 0 */ public List&lt;Long&gt; mexists(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 调用 BF.MADD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 获取元素数量 */ public Long card(String key) &#123; String script = &quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;; // 使用 RedisModule 提供的 BF.CARD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key) ); &#125; /** * 获取 Bloom Filter 元信息 */ public Map&lt;String, Long&gt; info(String key) &#123; String script = &quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;; List&lt;Object&gt; result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Long&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Long value = (Long) result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125; Redisson 的 BloomFilter 的使用方法 1234RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(&quot;bloomFilter&quot;);bloomFilter.tryInit(1000000, 0.01);bloomFilter.add(&quot;test&quot;);System.out.println(bloomFilter.contains(&quot;test&quot;));","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-22T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","url":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","title":"Redis 扩展模块 -- RedisBloom","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisBloom 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisBloom-简介\">RedisBloom 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisBloom/RedisBloom\">RedisBloom</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisBloom 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n</ul>\n<h2 id=\"RedisBloom-提供的核心数据结构\">RedisBloom 提供的核心数据结构</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装好RedisBloom后，我们可以通过如下方式查看RedisBloom 支持的命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上所有 Stack Module Commands都是通过如下命令查看，因为我们这里只安装了 RedisBloom，所以此时仅可以看到 RedisBloom 模块的命令</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">help</span> @module</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过输出我们可以看到-RedisBloom-模块支持的命令大致分为-5-类\">通过输出我们可以看到 RedisBloom 模块支持的命令大致分为 5 类</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Bloom Filter（布隆过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></li>\n<li class=\"lvl-6\">生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></li>\n<li class=\"lvl-6\">对应Redis命令： <code>BF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-11-BF/\" title=\"Redis 命令及数据类型 -- BF(Bloom Filter)\">Redis 命令及数据类型 -- BF(Bloom Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>2️⃣ Cuckoo Filter（布谷鸟过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Bloom Filter 的增强版，支持 删除元素</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></li>\n<li class=\"lvl-6\">在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</li>\n<li class=\"lvl-6\">低误判率 + 高负载率场景，Cuckoo Filter 更省内存。</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-12-CF/\" title=\"Redis 命令及数据类型 -- CF(Cuckoo Filter)\">Redis 命令及数据类型 -- CF(Cuckoo Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3️⃣ Count-Min Sketch（CMS）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">近似统计元素出现频率</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CMS.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-13-CMS/\" title=\"Redis 命令及数据类型 -- CMS(Count-Min Sketch)\">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>4️⃣ Top-K</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">统计访问频率最高的 K 个元素</li>\n<li class=\"lvl-6\">对应Redis命令： <code>TOPK.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-14-TopK/\" title=\"Redis 命令及数据类型 -- TopK\">Redis 命令及数据类型 -- TopK</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>5️⃣ TDigest</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">统计数字的分布</li>\n<li class=\"lvl-6\">对应Redis命令： <code>TDIGEST.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-15-TDigest/\" title=\"Redis 命令及数据类型 -- TDigest\">Redis 命令及数据类型 -- TDigest</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装-RedisBloom\">安装 RedisBloom</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是从<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中进行下载，其提供了所有Redis模块编译后的<code>.so</code>文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/rguEIA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>源码编译</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisbloom.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisBloom</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.8.17</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: 7fc8e62</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y git jq</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --modern</span><br><span class=\"line\">dnf install -q -y valgrind</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/sbin/get-fbinfer</span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r tests/flow/requirements.txt</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  pudb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...</span><br><span class=\"line\"></span><br><span class=\"line\">Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...</span><br><span class=\"line\">-- The C compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- The CXX compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- Detecting C compiler ABI info</span><br><span class=\"line\">-- Detecting C compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working C compiler: /usr/bin/gcc - skipped</span><br><span class=\"line\">-- Detecting C compile features</span><br><span class=\"line\">-- Detecting C compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Detecting CXX compiler ABI info</span><br><span class=\"line\">-- Detecting CXX compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working CXX compiler: /usr/bin/g++ - skipped</span><br><span class=\"line\">-- Detecting CXX compile features</span><br><span class=\"line\">-- Detecting CXX compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Setting build <span class=\"built_in\">type</span> to <span class=\"string\">&#x27;Release&#x27;</span> as none was specified.</span><br><span class=\"line\">-- Configuring <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Generating <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c</span><br><span class=\"line\"></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...</span><br><span class=\"line\">[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o</span><br><span class=\"line\">[100%] Linking C static library libtdigest_static.a</span><br><span class=\"line\">[100%] Built target tdigest_static</span><br><span class=\"line\">Compiling deps/bloom/bloom.c...</span><br><span class=\"line\">Compiling deps/murmur2/MurmurHash2.c...</span><br><span class=\"line\">Compiling deps/rmutil/util.c...</span><br><span class=\"line\">Compiling src/rebloom.c...</span><br><span class=\"line\">Compiling src/sb.c...</span><br><span class=\"line\">Compiling src/cf.c...</span><br><span class=\"line\">Compiling src/rm_topk.c...</span><br><span class=\"line\">Compiling src/rm_tdigest.c...</span><br><span class=\"line\">Compiling src/topk.c...</span><br><span class=\"line\">Compiling src/rm_cms.c...</span><br><span class=\"line\">Compiling src/cms.c...</span><br><span class=\"line\">Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so...</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">……</span><br><span class=\"line\">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\">Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:</span><br><span class=\"line\">346      \t\t<span class=\"comment\"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class=\"line\">347      \t<span class=\"keyword\">fi</span></span><br><span class=\"line\">348</span><br><span class=\"line\">349  &gt;&gt;&gt; \tinstall_raven</span><br><span class=\"line\">350      \tinstall_remi</span><br><span class=\"line\">351      \t<span class=\"comment\"># install_centos_stream_repos</span></span><br><span class=\"line\">352</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/sbin/setup:</span><br><span class=\"line\">16       \tpython3 -m pip list</span><br><span class=\"line\">17       <span class=\"keyword\">fi</span></span><br><span class=\"line\">18</span><br><span class=\"line\">19   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py</span><br><span class=\"line\">20       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">21       \tpython3 -m pip list</span><br><span class=\"line\">22       <span class=\"keyword\">fi</span> 编译安装时报错</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 错误分析与解决方法</span></span><br><span class=\"line\">问题原因：</span><br><span class=\"line\">    你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。</span><br><span class=\"line\">readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。</span><br><span class=\"line\">    这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。</span><br><span class=\"line\">    RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel</span><br><span class=\"line\">    这个脚本用于：</span><br><span class=\"line\">        安装 EPEL</span><br><span class=\"line\">        安装 Raven Repo（EL9 特有）</span><br><span class=\"line\">        安装 Remi Repo</span><br><span class=\"line\">    但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。</span><br><span class=\"line\">    你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm</span><br><span class=\"line\">    说明你使用的可能是如下系统中的一个：</span><br><span class=\"line\">        RHEL 9</span><br><span class=\"line\">        Rocky Linux 9</span><br><span class=\"line\">        AlmaLinux 9</span><br><span class=\"line\">        CentOS Stream 9</span><br><span class=\"line\"></span><br><span class=\"line\">推荐解决方案:</span><br><span class=\"line\">   Raven Repo 并非是 ReidsBloom 的必要依赖，所以直接修改 getepel 脚本，禁用 install_raven</span><br><span class=\"line\">   vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <a href=\"http://redisbloom.so\">redisbloom.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要具有可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 启用模块有三种方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 2.也可以通过如下方式加载模块</span></span><br><span class=\"line\">redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 3.不需要重启redis</span></span><br><span class=\"line\">redis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>加载方式</th>\n<th>是否持久</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MODULE LOAD</code>（redis-cli）</td>\n<td>❌ 仅当前进程</td>\n</tr>\n<tr>\n<td>命令行 <code>redis-server --loadmodule</code></td>\n<td>❌ 仅本次启动</td>\n</tr>\n<tr>\n<td><code>redis.conf</code> 中 <code>loadmodule</code></td>\n<td>✅ <strong>永久生效</strong> （推荐/生产）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; info Modules</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 简介 RedisBloom 是 Redis 官方维护的一个扩展模块，隶属于 Redis Stack，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。 它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisBloom 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 RedisBloom 提供的核心数据结构 安装好RedisBloom后，我们可以通过如下方式查看RedisBloom 支持的命令 12# 实际上所有 Stack Module Commands都是通过如下命令查看，因为我们这里只安装了 RedisBloom，所以此时仅可以看到 RedisBloom 模块的命令&gt; help @module 通过输出我们可以看到 RedisBloom 模块支持的命令大致分为 5 类 1️⃣ Bloom Filter（布隆过滤器） 判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 对应Redis命令： BF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- BF(Bloom Filter) 2️⃣ Cuckoo Filter（布谷鸟过滤器） Bloom Filter 的增强版，支持 删除元素 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 低误判率 + 高负载率场景，Cuckoo Filter 更省内存。 对应Redis命令： CF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- CF(Cuckoo Filter) 3️⃣ Count-Min Sketch（CMS） 近似统计元素出现频率 对应Redis命令： CMS.xxx，详细的使用方法参见 Redis 命令及数据类型 -- CMS(Count-Min Sketch) 4️⃣ Top-K 统计访问频率最高的 K 个元素 对应Redis命令： TOPK.xxx，详细的使用方法参见 Redis 命令及数据类型 -- TopK 5️⃣ TDigest 统计数字的分布 对应Redis命令： TDIGEST.xxx，详细的使用方法参见 Redis 命令及数据类型 -- TDigest 安装 RedisBloom 最简单的方式就是从Redis Cloud的Download Center中进行下载，其提供了所有Redis模块编译后的.so文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 源码编译 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redisbloom.so上传到国内服务器即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom# 推荐切换到稳定的release版本git checkout v2.8.17# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: 7fc8e62dnf install -q -y ca-certificatesdnf install -q -y wget unzip/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8dnf install -q -y git jqdnf install -q -y which/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --moderndnf install -q -y valgrind/usr/local/soft/modules/RedisBloom/sbin/get-fbinferdnf install -q -y lcov/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr/usr/bin/python3 -m pip install --disable-pip-version-check --user -r tests/flow/requirements.txt/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws/usr/bin/python3 -m pip install --disable-pip-version-check --user pudb# 编译make# 输出Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...-- The C compiler identification is GNU 11.5.0-- The CXX compiler identification is GNU 11.5.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/gcc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/g++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Setting build type to &#x27;Release&#x27; as none was specified.-- Configuring done-- Generating done-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-cBuilding /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o[100%] Linking C static library libtdigest_static.a[100%] Built target tdigest_staticCompiling deps/bloom/bloom.c...Compiling deps/murmur2/MurmurHash2.c...Compiling deps/rmutil/util.c...Compiling src/rebloom.c...Compiling src/sb.c...Compiling src/cf.c...Compiling src/rm_topk.c...Compiling src/rm_tdigest.c...Compiling src/topk.c...Compiling src/rm_cms.c...Compiling src/cms.c...Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so... ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，类似于CentOS 9，所以第一次运行会报错，大致报错信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647./sbin/setup## 错误信息……[FAILED] raven-release.el9.noarch.rpm: Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:346 # xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm347 fi348349 &gt;&gt;&gt; install_raven350 install_remi351 # install_centos_stream_repos352command failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepelIn /usr/local/soft/modules/RedisBloom/sbin/setup:16 python3 -m pip list17 fi1819 &gt;&gt;&gt; $ROOT/sbin/system-setup.py20 if [[ $VERBOSE == 1 ]]; then21 python3 -m pip list22 fi 编译安装时报错## 错误分析与解决方法问题原因： 你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。 这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。 RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel 这个脚本用于： 安装 EPEL 安装 Raven Repo（EL9 特有） 安装 Remi Repo 但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。 你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm 说明你使用的可能是如下系统中的一个： RHEL 9 Rocky Linux 9 AlmaLinux 9 CentOS Stream 9推荐解决方案: Raven Repo 并非是 ReidsBloom 的必要依赖，所以直接修改 getepel 脚本，禁用 install_raven vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可 Redis 启用模块 将生成的 redisbloom.so 拷贝到 redis 的 modules 目录下（非必须） 12# 注意 .so 文件需要具有可执行权限cp bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so Redis 启用模块有三种方法 123456# 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 2.也可以通过如下方式加载模块redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 3.不需要重启redisredis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so 加载方式 是否持久 MODULE LOAD（redis-cli） ❌ 仅当前进程 命令行 redis-server --loadmodule ❌ 仅本次启动 redis.conf 中 loadmodule ✅ 永久生效 （推荐/生产） 本文采用 loadmodule 加载模块 123456789101112131415161718192021222324# 将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; info Modules## 输出# Modulesmodule:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-21T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","url":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","title":"Redis 命令及数据类型 -- Stream","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Stream 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Stream-核心详解\">Stream 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的<code>消息队列</code>，底层用<code>基数树+链表</code>实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。</p>\n</li>\n<li class=\"lvl-2\">\n<p>建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Stream 与传统的MQ 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Redis Stream</th>\n<th>RabbitMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据模型</strong></td>\n<td>类似日志的有序 KV 消息流（ID → field/value）</td>\n<td>队列（FIFO）</td>\n<td>日志分区（Partitioned Append-Only Log）</td>\n</tr>\n<tr>\n<td><strong>消息持久化</strong></td>\n<td>可选持久化（AOF / RDB），默认内存优先</td>\n<td>可持久化到磁盘</td>\n<td>持久化到磁盘，顺序写入，效率高</td>\n</tr>\n<tr>\n<td><strong>消息确认</strong></td>\n<td>XACK 对单条消息确认，支持 Pending 消息管理</td>\n<td>ACK / NACK</td>\n<td>Offset 控制，Consumer 自行提交</td>\n</tr>\n<tr>\n<td><strong>消费模式</strong></td>\n<td>支持 Consumer Group，多消费者共享 Pending 消息</td>\n<td>Queue 绑定 Consumer，多消费者抢占</td>\n<td>Consumer Group，多消费者平行消费</td>\n</tr>\n<tr>\n<td><strong>重复消费</strong></td>\n<td>默认可能重复，需要应用端幂等</td>\n<td>可通过 ACK/NACK 控制</td>\n<td>默认可能重复，Consumer 需幂等处理</td>\n</tr>\n<tr>\n<td><strong>消息顺序</strong></td>\n<td>按 Stream ID 顺序，可保证分组内顺序</td>\n<td>队列顺序保证</td>\n<td>Partition 内顺序保证</td>\n</tr>\n<tr>\n<td><strong>消息保留策略</strong></td>\n<td>可配置 maxlen / minid，按时间或长度裁剪</td>\n<td>队列长度 / TTL 控制</td>\n<td>基于时间或大小保留（Retention Policy）</td>\n</tr>\n<tr>\n<td><strong>延时/定时消费</strong></td>\n<td>原生不支持延时队列，需要应用端处理</td>\n<td>支持插件或 TTL</td>\n<td>原生不支持，需要应用端处理或 Kafka Streams</td>\n</tr>\n<tr>\n<td><strong>事务与原子操作</strong></td>\n<td>事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项</td>\n<td>原生事务支持（事务 / confirm 模式）</td>\n<td>不支持事务，依赖幂等生产者</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>内存级高吞吐，持久化会有开销</td>\n<td>中等，受磁盘和网络限制</td>\n<td>高吞吐，顺序写入磁盘效率极高</td>\n</tr>\n<tr>\n<td><strong>典型使用场景</strong></td>\n<td>事件日志、轻量 MQ、内部异步流水线</td>\n<td>企业级消息、任务调度、RPC</td>\n<td>大数据管道、日志收集、流处理</td>\n</tr>\n<tr>\n<td><strong>多语言支持</strong></td>\n<td>客户端支持多种语言（Java、Python、Go 等）</td>\n<td>客户端丰富</td>\n<td>客户端丰富</td>\n</tr>\n<tr>\n<td><strong>易运维性</strong></td>\n<td>单节点即可使用，但持久化需关注内存</td>\n<td>集群较复杂，需要 RabbitMQ 集群</td>\n<td>集群复杂度高，需要 ZooKeeper 或 KRaft</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"底层核心实现\">底层核心实现</h3>\n<ol>\n<li class=\"lvl-3\">\n<p>存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。</p>\n</li>\n<li class=\"lvl-3\">\n<p>持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。</p>\n</li>\n<li class=\"lvl-3\">\n<p>核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。</p>\n</li>\n</ol>\n<h2 id=\"Stream-核心基础操作（必用）\">Stream 核心基础操作（必用）</h2>\n<h3 id=\"1-生产消息（XADD）：写入队列\">1. 生产消息（XADD）：写入队列</h3>\n<p>• 核心命令：<code>XADD key ID 字段1 值1 字段2 值2 ...</code>，ID 写*表示自动生成（生产首选）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XADD key</span><br><span class=\"line\">     [NOMKSTREAM]</span><br><span class=\"line\">     [MAXLEN | MINID [= | ~] threshold [LIMIT count]]</span><br><span class=\"line\">     * | <span class=\"built_in\">id</span></span><br><span class=\"line\">     field value [field value ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称</span></span><br><span class=\"line\"><span class=\"comment\"># NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败</span></span><br><span class=\"line\"><span class=\"comment\"># MAXLEN threshold —— 按长度裁剪</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高</span></span><br><span class=\"line\"><span class=\"comment\"># LIMIT count —— 每次最多裁剪多少条</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程</span></span><br><span class=\"line\"><span class=\"comment\"># MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）</span></span><br><span class=\"line\"><span class=\"comment\">#   MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略</span></span><br><span class=\"line\"><span class=\"comment\"># * | id —— 消息 ID</span></span><br><span class=\"line\"><span class=\"comment\">#   *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理</span></span><br><span class=\"line\"><span class=\"comment\">#   id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败</span></span><br><span class=\"line\"><span class=\"comment\"># field value —— 消息体（Payload）</span></span><br><span class=\"line\"><span class=\"comment\">#   至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改</span></span><br></pre></td></tr></table></figure>\n<p>• 示例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向订单队列写入1条消息，自动生成消息ID</span></span><br><span class=\"line\">XADD order_stream * uid 1001 order_no ORD20251220 price 299</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保留某个时间点之后的日志</span></span><br><span class=\"line\">XADD <span class=\"built_in\">log</span> MINID ~ 1689900000000-0 * level INFO msg <span class=\"string\">&quot;startup&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-消费消息（2种核心模式）\">2. 消费消息（2种核心模式）</h3>\n<h4 id=\"（1）-独立消费（无消费组）：一对一消费，适合简单场景\">（1） 独立消费（无消费组）：一对一消费，适合简单场景</h4>\n<p>• XREAD：主动拉取消息，支持阻塞/非阻塞</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREAD</span><br><span class=\"line\">  [COUNT count]</span><br><span class=\"line\">  [BLOCK milliseconds]</span><br><span class=\"line\">  STREAMS key [key ...]</span><br><span class=\"line\">          <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count —— 单次最多读取多少条，是“上限”，不是保证值</span></span><br><span class=\"line\"><span class=\"comment\"># BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil</span></span><br><span class=\"line\"><span class=\"comment\">#   BLOCK 0: 无限阻塞，直到有新消息</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身</span></span><br><span class=\"line\"><span class=\"comment\">#   普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0</span></span><br><span class=\"line\"><span class=\"comment\">#   $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $</span></span><br></pre></td></tr></table></figure>\n<p>• 示例1（非阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从开头拉5条消息</span></span><br><span class=\"line\">XREAD COUNT 5 STREAMS order_stream 0-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span>          <span class=\"comment\"># Stream名称</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span>          <span class=\"comment\"># 消息体 键值对</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br></pre></td></tr></table></figure>\n<p>• 示例2（阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。</span></span><br><span class=\"line\">XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $</span><br></pre></td></tr></table></figure>\n<h4 id=\"（2）-消费组消费（XGROUP）：一对多消费，核心生产模式\">（2） 消费组消费（XGROUP）：一对多消费，核心生产模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。</p>\n</li>\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">先创建消费组<code>XGROUP CREATE</code></li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE key group <span class=\"built_in\">id</span>|$</span><br><span class=\"line\">       [MKSTREAM]</span><br><span class=\"line\">       [ENTRIESREAD entries-read]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key：Stream 名称，为指定的Stream创建消费组</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group</span></span><br><span class=\"line\"><span class=\"comment\"># id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。</span></span><br><span class=\"line\"><span class=\"comment\"># [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用</span></span><br><span class=\"line\"><span class=\"comment\"># [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：创建group1消费组，从最新订单消息开始消费</span></span><br><span class=\"line\">XGROUP CREATE order_stream group1 $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>消费者拉取消息<code>XREADGROUP</code></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREADGROUP GROUP group consumer</span><br><span class=\"line\">           [COUNT count]</span><br><span class=\"line\">           [BLOCK milliseconds]</span><br><span class=\"line\">           [NOACK]</span><br><span class=\"line\">           STREAMS key [key ...]</span><br><span class=\"line\">                   <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># GROUP group consumer: 指定消费者组名：group，消费者名：consumer</span></span><br><span class=\"line\"><span class=\"comment\">#    同一个 group 下，不同 consumer 不会收到重复消息</span></span><br><span class=\"line\"><span class=\"comment\"># [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证</span></span><br><span class=\"line\"><span class=\"comment\"># [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒</span></span><br><span class=\"line\"><span class=\"comment\">#    BLOCK 0 → 永久阻塞</span></span><br><span class=\"line\"><span class=\"comment\"># [NOACK] —— 不进入 Pending（⚠️ 谨慎）</span></span><br><span class=\"line\"><span class=\"comment\">#    消息 不会进入 Pending，不需要 XACK，消费后即认为完成</span></span><br><span class=\"line\"><span class=\"comment\">#    风险：消费者崩溃 → 消息直接丢失，不可重投递</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 决定“读什么”的关键</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息</span></span><br><span class=\"line\"><span class=\"comment\">#    多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。</span></span><br><span class=\"line\">XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;</span><br><span class=\"line\"><span class=\"comment\">## 此时在5秒内创建新的消息，就会有类似如下输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\">(1.50s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-消息确认（XACK）\">3. 消息确认（XACK）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费完成后必须确认，否则会被标记为「未确认消息」</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XACK key 消费组名 消息ID1 消息ID2 ...。</span></span><br><span class=\"line\">XACK key group <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记</span></span><br><span class=\"line\">XACK order_stream group1 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-消息重试\">4. 消息重试</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>未确认的消息，会被存入消费组的<code>「PEL（Pending Entries List）」</code>，可通过<code>XPENDING key 消费组名</code>查看，支持<code>XCLAIM</code>将<code>PEL</code>中的消息转移给其他消费者处理，避免单点故障导致消息堆积。</p>\n</li>\n<li class=\"lvl-2\">\n<p>XPENDING：查看未被确认的消息情况</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XPENDING key group</span><br><span class=\"line\">        [[IDLE min-idle-time]</span><br><span class=\"line\">         start end count</span><br><span class=\"line\">         [consumer]]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息</span></span><br><span class=\"line\"><span class=\"comment\">#    min-idle-time(空闲时间) = 从上次投递 / claim到现在</span></span><br><span class=\"line\"><span class=\"comment\"># start end —— ID 范围</span></span><br><span class=\"line\"><span class=\"comment\">#    -: 最小ID</span></span><br><span class=\"line\"><span class=\"comment\">#    +: 最大ID</span></span><br><span class=\"line\"><span class=\"comment\"># count —— 返回条数上限</span></span><br><span class=\"line\"><span class=\"comment\"># [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部</span></span><br><span class=\"line\"><span class=\"comment\"># 只返回 元数据，不返回消息内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例1: 查看是否有消息积压</span></span><br><span class=\"line\">XPENDING order_stream group1</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1      <span class=\"comment\"># 积压消息数，未确认消息数量</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最小 ID</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最大 ID</span></span><br><span class=\"line\">4) 1) 1) <span class=\"string\">&quot;consumerA&quot;</span> <span class=\"comment\"># 按 consumer 统计的 Pending 数量</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条</span></span><br><span class=\"line\">XPENDING order_stream group1 IDLE 60000 - + 10</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># 消息 ID</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;consumerA&quot;</span>       <span class=\"comment\"># 当前持有该消息的 consumer</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 255581  <span class=\"comment\"># idle 时间（毫秒）</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 2       <span class=\"comment\"># delivery count（投递次数）,该消息至少被投递过 2 次</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例3: 只查看 consumerA 的 Pending，最多返回20条</span></span><br><span class=\"line\">XPENDING order_stream group1 - + 20 consumerA</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>XCLAIM: 转移投递</p>\n</li>\n</ul>\n<blockquote>\n<p>将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。<br>\n一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XCLAIM key group consumer min-idle-time <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\">       [IDLE ms]</span><br><span class=\"line\">       [TIME unix-time-milliseconds]</span><br><span class=\"line\">       [RETRYCOUNT count]</span><br><span class=\"line\">       [FORCE]</span><br><span class=\"line\">       [JUSTID]</span><br><span class=\"line\">       [LASTID lastid]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream Key，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer</span></span><br><span class=\"line\"><span class=\"comment\"># min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...]: 指定要 claim 的消息 ID，ID必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态</span></span><br><span class=\"line\"><span class=\"comment\"># [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码</span></span><br><span class=\"line\"><span class=\"comment\"># [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”</span></span><br><span class=\"line\"><span class=\"comment\"># [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险</span></span><br><span class=\"line\"><span class=\"comment\"># [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销</span></span><br><span class=\"line\"><span class=\"comment\"># [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为</span></span><br><span class=\"line\"><span class=\"comment\">#    ⚠️ 高级特性，一般不建议业务代码使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：</span></span><br><span class=\"line\"><span class=\"comment\"># 1️⃣ 抢占 idle 超过 60s 的消息</span></span><br><span class=\"line\">XCLAIM order_stream group1 consumerB 60000 1766215642763-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">   2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">      5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2️⃣ 抢占并标记为第 3 次重试</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3</span><br><span class=\"line\"><span class=\"comment\"># 3️⃣ 只返回 ID（配合批处理）</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级特性（生产必备）\">高级特性（生产必备）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息回溯与遍历</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）</span></span><br><span class=\"line\">XRANGE key start end [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）</span></span><br><span class=\"line\">XREVRANGE key end start [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。</span></span><br><span class=\"line\">XRANGE order_stream 0-0 + COUNT 10</span><br><span class=\"line\">XRANGE order_stream - + COUNT 10</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>队列信息查询</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查消息总数</span></span><br><span class=\"line\">XLEN key</span><br><span class=\"line\"><span class=\"comment\"># 查Stream完整元数据（最新ID、消费组数量、消息总数等）</span></span><br><span class=\"line\"></span><br><span class=\"line\">XINFO STREAM key [FULL [COUNT count]]</span><br><span class=\"line\"><span class=\"comment\">## FULL: 完整模式</span></span><br><span class=\"line\">    <span class=\"comment\"># 👉 返回：</span></span><br><span class=\"line\">    <span class=\"comment\">#     Stream 元信息</span></span><br><span class=\"line\">    <span class=\"comment\">#     所有 Consumer Group</span></span><br><span class=\"line\">    <span class=\"comment\">#     每个 Group 的 Consumer</span></span><br><span class=\"line\">    <span class=\"comment\">#     Pending Entries List（PEL）</span></span><br><span class=\"line\">    <span class=\"comment\">#     部分历史 entries</span></span><br><span class=\"line\">    <span class=\"comment\"># ⚠️ 开销很大，慎用于生产环境。</span></span><br><span class=\"line\"><span class=\"comment\">## COUNT count（FULL 模式的限制参数）</span></span><br><span class=\"line\">    <span class=\"comment\">#   XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查所有消费组信息</span></span><br><span class=\"line\">XINFO GROUPS key</span><br><span class=\"line\"><span class=\"comment\"># 查该组下所有消费者</span></span><br><span class=\"line\">XINFO CONSUMERS key 消费组名</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费组管理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除消费组</span></span><br><span class=\"line\">XGROUP DESTROY key 消费组名</span><br><span class=\"line\"><span class=\"comment\"># 删除消费者</span></span><br><span class=\"line\">XGROUP DELCONSUMER key 消费组名 消费者名</span><br><span class=\"line\"><span class=\"comment\"># 重置消费组起始ID</span></span><br><span class=\"line\">XGROUP SETID key 消费组名 新ID</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。</p>\n</li>\n</ol>\n<h2 id=\"生产环境核心痛点与解决方案\">生产环境核心痛点与解决方案</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息丢失：3重保障</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性）</li>\n<li class=\"lvl-6\">生产者写入后确认返回值（确保写入成功）</li>\n<li class=\"lvl-6\">消费者消费后必须<code>XACK</code>确认。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>消息堆积：2种处理</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">① 写入时用<code>MAXLEN</code>设置上限，淘汰旧消息；</li>\n<li class=\"lvl-6\">② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>重复消费</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL）</li>\n<li class=\"lvl-6\">解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。</p>\n</li>\n</ol>\n<h2 id=\"典型应用场景\">典型应用场景</h2>\n<h3 id=\"分布式业务解耦（订单-库存-支付-物流解耦）\">分布式业务解耦（订单-库存-支付-物流解耦）</h3>\n<blockquote>\n<p>核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（订单服务）：写入订单完成消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）</span></span><br><span class=\"line\">XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建3个独立消费组（库存/支付/物流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存消费组：从最新消息开始消费，队列不存在则自动创建</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_stock $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 支付消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_pay $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 物流消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_logistics $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>各消费组消费者拉取+确认消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒</span></span><br><span class=\"line\">XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 库存处理完成后确认消息（替换为实际拉取到的消息ID）</span></span><br><span class=\"line\">XACK order_core_stream group_stock 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支付服务消费者（consumer_pay1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_pay 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 物流服务消费者（consumer_log1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步任务处理（用户注册-邮件-短信-积分异步执行）\">异步任务处理（用户注册-邮件/短信/积分异步执行）</h3>\n<blockquote>\n<p>核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（注册服务）：用户注册成功后写入消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息</span></span><br><span class=\"line\">XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建单个消费组（统一处理注册后续任务）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 短信发送消费者（consumer_sms）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 邮件发送消费者（consumer_email）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 积分发放消费者（consumer_score）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志收集（系统实时日志-分析-告警）\">日志收集（系统实时日志-分析/告警）</h3>\n<blockquote>\n<p>核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）</span></span><br><span class=\"line\">XADD sys_log_stream * module order_service level ERROR content <span class=\"string\">&quot;库存扣减失败，订单号ORD20251220001&quot;</span> log_time 1734567910</span><br><span class=\"line\">XADD sys_log_stream * module pay_service level INFO content <span class=\"string\">&quot;支付成功，uid1001，金额299&quot;</span> log_time 1734567912</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建2个消费组（日志分析+实时告警）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>对应消费者拉取处理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费者（批量拉取，非阻塞，适合离线处理）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;</span><br><span class=\"line\">XACK sys_log_stream group_log_analysis 批量消息ID...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt;  <span class=\"comment\"># BLOCK 0 永久阻塞，有消息立即返回</span></span><br><span class=\"line\">XACK sys_log_stream group_log_alert 告警消息ID</span><br></pre></td></tr></table></figure>\n<h3 id=\"限流削峰（秒杀场景-请求削峰填谷）\">限流削峰（秒杀场景-请求削峰填谷）</h3>\n<blockquote>\n<p>核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中”</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）</span></span><br><span class=\"line\">XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建消费组（单消费组+多消费者，控制总处理速率）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE seckill_stream group_seckill $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）</span></span><br><span class=\"line\">XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）</span></span><br><span class=\"line\">XACK seckill_stream group_seckill 秒杀请求消息ID...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。</p>\n</blockquote>\n<h2 id=\"与其他-Redis-队列方案对比（核心优势）\">与其他 Redis 队列方案对比（核心优势）</h2>\n<p>• 对比 List<br>\n- List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列；<br>\n- Stream 支持多播+消费组+确认机制，适合复杂分布式场景。</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Stream</th>\n<th>List</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消费者组</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>ACK</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>重试</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>阻塞</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>顺序性</td>\n<td>强</td>\n<td>强</td>\n</tr>\n</tbody>\n</table>\n<p>• 对比 Pub/Sub<br>\n- Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息；<br>\n- Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。</p>\n<h2 id=\"Stream-命令\">Stream 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForStream()</code> 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里不一定要用 <code>StringRedisTemplate</code> 来操作 Stream，但是用 <code>StringRedisTemplate</code> 可以保证可读性。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心能力划分：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">消息写入（XADD）</span><br><span class=\"line\">消息确认（XACK）</span><br><span class=\"line\">消息读取（XRANGE / XREAD / XREADGROUP）</span><br><span class=\"line\">Pending 消息管理（XPENDING / XCLAIM）</span><br><span class=\"line\">消费者组管理（XGROUP）</span><br><span class=\"line\">Stream 元信息（XINFO）</span><br><span class=\"line\">Stream 裁剪与删除（XTRIM / XDEL）</span><br><span class=\"line\">对象映射（MapRecord / ObjectRecord）</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息写入（XADD）\">消息写入（XADD）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基础写入</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>opsForStream().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 Map</td>\n<td><code>add(K key, Map&lt;HK,HV&gt;)</code></td>\n<td><code>XADD key * field value</code></td>\n<td>自动生成 ID</td>\n</tr>\n<tr>\n<td>写入 Record</td>\n<td><code>add(Record&lt;K, ?&gt; record)</code></td>\n<td><code>XADD</code></td>\n<td>支持 ObjectRecord</td>\n</tr>\n<tr>\n<td>写入 MapRecord</td>\n<td><code>add(MapRecord&lt;K,HK,HV&gt;)</code></td>\n<td><code>XADD</code></td>\n<td>Map 形式</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 带参数写入（推荐）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 + 选项</td>\n<td><code>add(record, XAddOptions)</code></td>\n<td><code>XADD ...</code></td>\n<td>支持 MAXLEN / NOMKSTREAM</td>\n</tr>\n<tr>\n<td>Map + 选项</td>\n<td><code>add(key, map, XAddOptions)</code></td>\n<td><code>XADD</code></td>\n<td>Redis ≥ 6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消息确认（XACK）\">消息确认（XACK）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>确认消息</td>\n<td><code>acknowledge(key, group, recordIds…)</code></td>\n<td><code>XACK</code></td>\n<td>标记已消费</td>\n</tr>\n<tr>\n<td>Record 确认</td>\n<td><code>acknowledge(group, record)</code></td>\n<td><code>XACK</code></td>\n<td>常用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 只对 Consumer Group 生效</p>\n</blockquote>\n<h3 id=\"消息读取（无消费者组）\">消息读取（无消费者组）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按 Range 读取（历史数据）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正序读取</td>\n<td><code>range(key, range)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>限制条数</td>\n<td><code>range(key, range, limit)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>反序读取</td>\n<td><code>reverseRange(key, range)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n<tr>\n<td>反序 + limit</td>\n<td><code>reverseRange(key, range, limit)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 实时读取（XREAD）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td><code>read(StreamOffset…)</code></td>\n<td><code>XREAD</code></td>\n<td>不支持 ACK</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(options, offsets…)</code></td>\n<td><code>XREAD</code></td>\n<td>BLOCK / COUNT</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, …)</code></td>\n<td><code>XREAD</code></td>\n<td>自动反序列化</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组读取（XREADGROUP）\">消费者组读取（XREADGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组内读取</td>\n<td><code>read(Consumer, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>MQ 核心</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(Consumer, options, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>BLOCK</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, Consumer, …)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Pending-消息管理（XPENDING-XCLAIM）\">Pending 消息管理（XPENDING / XCLAIM）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Pending 查询</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pending 汇总</td>\n<td><code>pending(key, group)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>指定消费者</td>\n<td><code>pending(key, consumer)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>范围查询</td>\n<td><code>pending(key, group, range, count)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 消息重新分配（XCLAIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重新分配</td>\n<td><code>claim(key, group, newOwner, minIdle, ids…)</code></td>\n<td><code>XCLAIM</code></td>\n<td>超时接管</td>\n</tr>\n<tr>\n<td>高级配置</td>\n<td><code>claim(key, group, newOwner, XClaimOptions)</code></td>\n<td><code>XCLAIM</code></td>\n<td>force / retry</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组管理（XGROUP）\">消费者组管理（XGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建组</td>\n<td><code>createGroup(key, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>从 <code>$</code> 开始</td>\n</tr>\n<tr>\n<td>指定 offset</td>\n<td><code>createGroup(key, offset, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>常用 <code>0-0</code></td>\n</tr>\n<tr>\n<td>删除消费者</td>\n<td><code>deleteConsumer(key, consumer)</code></td>\n<td><code>XGROUP DELCONSUMER</code></td>\n<td></td>\n</tr>\n<tr>\n<td>销毁组</td>\n<td><code>destroyGroup(key, group)</code></td>\n<td><code>XGROUP DESTROY</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-元信息（XINFO）\">Stream 元信息（XINFO）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Stream 信息</td>\n<td><code>info(key)</code></td>\n<td><code>XINFO STREAM</code></td>\n</tr>\n<tr>\n<td>组信息</td>\n<td><code>groups(key)</code></td>\n<td><code>XINFO GROUPS</code></td>\n</tr>\n<tr>\n<td>消费者信息</td>\n<td><code>consumers(key, group)</code></td>\n<td><code>XINFO CONSUMERS</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-删除-裁剪\">Stream 删除 / 裁剪</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 删除消息</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除消息</td>\n<td><code>delete(key, recordIds…)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n<tr>\n<td>删除 Record</td>\n<td><code>delete(record)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 裁剪 Stream（XTRIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>精确裁剪</td>\n<td><code>trim(key, count)</code></td>\n<td><code>XTRIM</code></td>\n<td></td>\n</tr>\n<tr>\n<td>近似裁剪</td>\n<td><code>trim(key, count, true)</code></td>\n<td><code>XTRIM ~</code></td>\n<td>性能更好</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对象映射能力（非常重要）\">对象映射能力（非常重要）</h3>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map → Object</td>\n<td><code>map(MapRecord, Class&lt;T&gt;)</code></td>\n<td>自动反序列化</td>\n</tr>\n<tr>\n<td>List 映射</td>\n<td><code>map(List&lt;MapRecord&gt;, Class&lt;T&gt;)</code></td>\n<td></td>\n</tr>\n<tr>\n<td>HashMapper</td>\n<td><code>getHashMapper(Class&lt;T&gt;)</code></td>\n<td>自定义映射</td>\n</tr>\n<tr>\n<td>反序列化</td>\n<td><code>deserializeRecord(ByteRecord)</code></td>\n<td>底层能力</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Stream 核心详解 Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的消息队列，底层用基数树+链表实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。 建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。 Stream 与传统的MQ 的对比 对比维度 Redis Stream RabbitMQ Kafka 数据模型 类似日志的有序 KV 消息流（ID → field/value） 队列（FIFO） 日志分区（Partitioned Append-Only Log） 消息持久化 可选持久化（AOF / RDB），默认内存优先 可持久化到磁盘 持久化到磁盘，顺序写入，效率高 消息确认 XACK 对单条消息确认，支持 Pending 消息管理 ACK / NACK Offset 控制，Consumer 自行提交 消费模式 支持 Consumer Group，多消费者共享 Pending 消息 Queue 绑定 Consumer，多消费者抢占 Consumer Group，多消费者平行消费 重复消费 默认可能重复，需要应用端幂等 可通过 ACK/NACK 控制 默认可能重复，Consumer 需幂等处理 消息顺序 按 Stream ID 顺序，可保证分组内顺序 队列顺序保证 Partition 内顺序保证 消息保留策略 可配置 maxlen / minid，按时间或长度裁剪 队列长度 / TTL 控制 基于时间或大小保留（Retention Policy） 延时/定时消费 原生不支持延时队列，需要应用端处理 支持插件或 TTL 原生不支持，需要应用端处理或 Kafka Streams 事务与原子操作 事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项 原生事务支持（事务 / confirm 模式） 不支持事务，依赖幂等生产者 性能 内存级高吞吐，持久化会有开销 中等，受磁盘和网络限制 高吞吐，顺序写入磁盘效率极高 典型使用场景 事件日志、轻量 MQ、内部异步流水线 企业级消息、任务调度、RPC 大数据管道、日志收集、流处理 多语言支持 客户端支持多种语言（Java、Python、Go 等） 客户端丰富 客户端丰富 易运维性 单节点即可使用，但持久化需关注内存 集群较复杂，需要 RabbitMQ 集群 集群复杂度高，需要 ZooKeeper 或 KRaft 底层核心实现 存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。 消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。 持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。 核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。 Stream 核心基础操作（必用） 1. 生产消息（XADD）：写入队列 • 核心命令：XADD key ID 字段1 值1 字段2 值2 ...，ID 写*表示自动生成（生产首选） 12345678910111213141516171819202122XADD key [NOMKSTREAM] [MAXLEN | MINID [= | ~] threshold [LIMIT count]] * | id field value [field value ...]# 参数解释# key: Stream 名称# NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败# MAXLEN threshold —— 按长度裁剪# MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）# MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大# MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高# LIMIT count —— 每次最多裁剪多少条# MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程# MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）# MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略# * | id —— 消息 ID# *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理# id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败# field value —— 消息体（Payload）# 至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改 • 示例 1234567# 向订单队列写入1条消息，自动生成消息IDXADD order_stream * uid 1001 order_no ORD20251220 price 299## 输出&quot;1766215406540-0&quot; # 消息ID# 保留某个时间点之后的日志XADD log MINID ~ 1689900000000-0 * level INFO msg &quot;startup&quot; 2. 消费消息（2种核心模式） （1） 独立消费（无消费组）：一对一消费，适合简单场景 • XREAD：主动拉取消息，支持阻塞/非阻塞 12345678910111213XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]# 参数解释# COUNT count —— 单次最多读取多少条，是“上限”，不是保证值# BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil# BLOCK 0: 无限阻塞，直到有新消息# STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应# id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身# 普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0# $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $ • 示例1（非阻塞） 1234567891011# 从开头拉5条消息XREAD COUNT 5 STREAMS order_stream 0-0# 输出1) 1) &quot;order_stream&quot; # Stream名称 2) 1) 1) &quot;1766215406540-0&quot; # 消息ID 2) 1) &quot;uid&quot; # 消息体 键值对 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot; • 示例2（阻塞） 12# $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $ （2） 消费组消费（XGROUP）：一对多消费，核心生产模式 Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。 先创建消费组XGROUP CREATE 1234567891011121314XGROUP CREATE key group id|$ [MKSTREAM] [ENTRIESREAD entries-read]# 参数解释# key：Stream 名称，为指定的Stream创建消费组# group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group# id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。# [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用# [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景# 示例：创建group1消费组，从最新订单消息开始消费XGROUP CREATE order_stream group1 $ MKSTREAM# 输出OK 消费者拉取消息XREADGROUP 123456789101112131415161718192021222324252627282930313233XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]# 参数解释# GROUP group consumer: 指定消费者组名：group，消费者名：consumer# 同一个 group 下，不同 consumer 不会收到重复消息# [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证# [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒# BLOCK 0 → 永久阻塞# [NOACK] —— 不进入 Pending（⚠️ 谨慎）# 消息 不会进入 Pending，不需要 XACK，消费后即认为完成# 风险：消费者崩溃 → 消息直接丢失，不可重投递# STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致# id [id ...] —— 决定“读什么”的关键# 使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息# 使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息# 多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id# 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;## 此时在5秒内创建新的消息，就会有类似如下输出1) 1) &quot;order_stream&quot; 2) 1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;(1.50s) 3. 消息确认（XACK） 消费完成后必须确认，否则会被标记为「未确认消息」 12345# XACK key 消费组名 消息ID1 消息ID2 ...。XACK key group id [id ...]# 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记XACK order_stream group1 1734567890000-0 1734567890001-0 4. 消息重试 未确认的消息，会被存入消费组的「PEL（Pending Entries List）」，可通过XPENDING key 消费组名查看，支持XCLAIM将PEL中的消息转移给其他消费者处理，避免单点故障导致消息堆积。 XPENDING：查看未被确认的消息情况 123456789101112131415161718192021222324252627282930313233343536XPENDING key group [[IDLE min-idle-time] start end count [consumer]]# 参数解释# key: Stream 名称，必须存在# group: 消费者组名称，必须存在# [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息# min-idle-time(空闲时间) = 从上次投递 / claim到现在# start end —— ID 范围# -: 最小ID# +: 最大ID# count —— 返回条数上限# [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部# 只返回 元数据，不返回消息内容# 示例1: 查看是否有消息积压XPENDING order_stream group1## 输出1) (integer) 1 # 积压消息数，未确认消息数量2) &quot;1766215642763-0&quot; # Pending 中最小 ID3) &quot;1766215642763-0&quot; # Pending 中最大 ID4) 1) 1) &quot;consumerA&quot; # 按 consumer 统计的 Pending 数量 2) &quot;1&quot;# 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条XPENDING order_stream group1 IDLE 60000 - + 10## 输出1) 1) &quot;1766215642763-0&quot; # 消息 ID 2) &quot;consumerA&quot; # 当前持有该消息的 consumer 3) (integer) 255581 # idle 时间（毫秒） 4) (integer) 2 # delivery count（投递次数）,该消息至少被投递过 2 次# 示例3: 只查看 consumerA 的 Pending，最多返回20条XPENDING order_stream group1 - + 20 consumerA XCLAIM: 转移投递 将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。 一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录 12345678910111213141516171819202122232425262728293031323334353637XCLAIM key group consumer min-idle-time id [id ...] [IDLE ms] [TIME unix-time-milliseconds] [RETRYCOUNT count] [FORCE] [JUSTID] [LASTID lastid]# 参数解释# key: Stream Key，必须存在# group: 消费者组名称，必须存在# consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer# min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim# id [id ...]: 指定要 claim 的消息 ID，ID必须存在# [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态# [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码# [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”# [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险# [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销# [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为# ⚠️ 高级特性，一般不建议业务代码使用# 示例：# 1️⃣ 抢占 idle 超过 60s 的消息XCLAIM order_stream group1 consumerB 60000 1766215642763-0# 输出1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;# 2️⃣ 抢占并标记为第 3 次重试XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3# 3️⃣ 只返回 ID（配合批处理）XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID 高级特性（生产必备） 消息回溯与遍历 1234567# XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）XRANGE key start end [COUNT count]# XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）XREVRANGE key end start [COUNT count]# 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。XRANGE order_stream 0-0 + COUNT 10XRANGE order_stream - + COUNT 10 队列信息查询 1234567891011121314151617181920# 查消息总数XLEN key# 查Stream完整元数据（最新ID、消费组数量、消息总数等）XINFO STREAM key [FULL [COUNT count]]## FULL: 完整模式 # 👉 返回： # Stream 元信息 # 所有 Consumer Group # 每个 Group 的 Consumer # Pending Entries List（PEL） # 部分历史 entries # ⚠️ 开销很大，慎用于生产环境。## COUNT count（FULL 模式的限制参数） # XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量# 查所有消费组信息XINFO GROUPS key# 查该组下所有消费者XINFO CONSUMERS key 消费组名 消费组管理 123456# 删除消费组XGROUP DESTROY key 消费组名# 删除消费者XGROUP DELCONSUMER key 消费组名 消费者名# 重置消费组起始IDXGROUP SETID key 消费组名 新ID 惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。 生产环境核心痛点与解决方案 消息丢失：3重保障 开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性） 生产者写入后确认返回值（确保写入成功） 消费者消费后必须XACK确认。 消息堆积：2种处理 ① 写入时用MAXLEN设置上限，淘汰旧消息； ② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。 重复消费 根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL） 解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。 阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。 典型应用场景 分布式业务解耦（订单-库存-支付-物流解耦） 核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。 生产者（订单服务）：写入订单完成消息 12# 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890 创建3个独立消费组（库存/支付/物流） 123456# 库存消费组：从最新消息开始消费，队列不存在则自动创建XGROUP CREATE order_core_stream group_stock $ MKSTREAM# 支付消费组XGROUP CREATE order_core_stream group_pay $ MKSTREAM# 物流消费组XGROUP CREATE order_core_stream group_logistics $ MKSTREAM 各消费组消费者拉取+确认消息 123456789101112# 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;# 库存处理完成后确认消息（替换为实际拉取到的消息ID）XACK order_core_stream group_stock 1734567890000-0 1734567890001-0# 支付服务消费者（consumer_pay1）同理XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_pay 1734567890000-0 1734567890001-0# 物流服务消费者（consumer_log1）同理XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0 异步任务处理（用户注册-邮件/短信/积分异步执行） 核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。 生产者（注册服务）：用户注册成功后写入消息 12# 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900 创建单个消费组（统一处理注册后续任务） 1XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM 多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容） 1234567891011# 短信发送消费者（consumer_sms）XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 邮件发送消费者（consumer_email）XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 积分发放消费者（consumer_score）XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2 日志收集（系统实时日志-分析/告警） 核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。 生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流） 123# 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）XADD sys_log_stream * module order_service level ERROR content &quot;库存扣减失败，订单号ORD20251220001&quot; log_time 1734567910XADD sys_log_stream * module pay_service level INFO content &quot;支付成功，uid1001，金额299&quot; log_time 1734567912 创建2个消费组（日志分析+实时告警） 1234# 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM# 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM 对应消费者拉取处理 1234567# 日志分析消费者（批量拉取，非阻塞，适合离线处理）XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;XACK sys_log_stream group_log_analysis 批量消息ID...# 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt; # BLOCK 0 永久阻塞，有消息立即返回XACK sys_log_stream group_log_alert 告警消息ID 限流削峰（秒杀场景-请求削峰填谷） 核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。 生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中” 12# 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000 创建消费组（单消费组+多消费者，控制总处理速率） 1XGROUP CREATE seckill_stream group_seckill $ MKSTREAM 消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条） 1234# 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;# 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）XACK seckill_stream group_seckill 秒杀请求消息ID... 关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。 与其他 Redis 队列方案对比（核心优势） • 对比 List - List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列； - Stream 支持多播+消费组+确认机制，适合复杂分布式场景。 对比项 Stream List 消费者组 ✅ ❌ ACK ✅ ❌ 重试 ✅ ❌ 阻塞 ✅ ✅ 顺序性 强 强 • 对比 Pub/Sub - Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息； - Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。 Stream 命令 SpringBoot 的 StringRedisTemplate.opsForStream() 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里不一定要用 StringRedisTemplate 来操作 Stream，但是用 StringRedisTemplate 可以保证可读性。 核心能力划分： 12345678消息写入（XADD）消息确认（XACK）消息读取（XRANGE / XREAD / XREADGROUP）Pending 消息管理（XPENDING / XCLAIM）消费者组管理（XGROUP）Stream 元信息（XINFO）Stream 裁剪与删除（XTRIM / XDEL）对象映射（MapRecord / ObjectRecord） 消息写入（XADD） 1️⃣ 基础写入 方法功能 方法 opsForStream().xxx() Redis 原始命令 说明 写入 Map add(K key, Map&lt;HK,HV&gt;) XADD key * field value 自动生成 ID 写入 Record add(Record&lt;K, ?&gt; record) XADD 支持 ObjectRecord 写入 MapRecord add(MapRecord&lt;K,HK,HV&gt;) XADD Map 形式 2️⃣ 带参数写入（推荐） 方法功能 方法 Redis 原始命令 备注 写入 + 选项 add(record, XAddOptions) XADD ... 支持 MAXLEN / NOMKSTREAM Map + 选项 add(key, map, XAddOptions) XADD Redis ≥ 6 消息确认（XACK） 方法功能 方法 Redis 原始命令 说明 确认消息 acknowledge(key, group, recordIds…) XACK 标记已消费 Record 确认 acknowledge(group, record) XACK 常用 ⚠️ 只对 Consumer Group 生效 消息读取（无消费者组） 1️⃣ 按 Range 读取（历史数据） 方法功能 方法 Redis 原始命令 正序读取 range(key, range) XRANGE 限制条数 range(key, range, limit) XRANGE 反序读取 reverseRange(key, range) XREVRANGE 反序 + limit reverseRange(key, range, limit) XREVRANGE 2️⃣ 实时读取（XREAD） 方法功能 方法 Redis 原始命令 说明 读取 read(StreamOffset…) XREAD 不支持 ACK 带参数 read(options, offsets…) XREAD BLOCK / COUNT 映射对象 read(Class&lt;T&gt;, …) XREAD 自动反序列化 消费者组读取（XREADGROUP） 方法功能 方法 Redis 原始命令 说明 组内读取 read(Consumer, offsets…) XREADGROUP MQ 核心 带参数 read(Consumer, options, offsets…) XREADGROUP BLOCK 映射对象 read(Class&lt;T&gt;, Consumer, …) XREADGROUP — Pending 消息管理（XPENDING / XCLAIM） 1️⃣ Pending 查询 方法功能 方法 Redis 原始命令 Pending 汇总 pending(key, group) XPENDING 指定消费者 pending(key, consumer) XPENDING 范围查询 pending(key, group, range, count) XPENDING 2️⃣ 消息重新分配（XCLAIM） 方法功能 方法 Redis 原始命令 说明 重新分配 claim(key, group, newOwner, minIdle, ids…) XCLAIM 超时接管 高级配置 claim(key, group, newOwner, XClaimOptions) XCLAIM force / retry 消费者组管理（XGROUP） 方法功能 方法 Redis 原始命令 说明 创建组 createGroup(key, group) XGROUP CREATE 从 $ 开始 指定 offset createGroup(key, offset, group) XGROUP CREATE 常用 0-0 删除消费者 deleteConsumer(key, consumer) XGROUP DELCONSUMER 销毁组 destroyGroup(key, group) XGROUP DESTROY Stream 元信息（XINFO） 方法功能 方法 Redis 原始命令 Stream 信息 info(key) XINFO STREAM 组信息 groups(key) XINFO GROUPS 消费者信息 consumers(key, group) XINFO CONSUMERS Stream 删除 / 裁剪 1️⃣ 删除消息 方法功能 方法 Redis 原始命令 删除消息 delete(key, recordIds…) XDEL 删除 Record delete(record) XDEL 2️⃣ 裁剪 Stream（XTRIM） 方法功能 方法 Redis 原始命令 说明 精确裁剪 trim(key, count) XTRIM 近似裁剪 trim(key, count, true) XTRIM ~ 性能更好 对象映射能力（非常重要） 能力 方法 说明 Map → Object map(MapRecord, Class&lt;T&gt;) 自动反序列化 List 映射 map(List&lt;MapRecord&gt;, Class&lt;T&gt;) HashMapper getHashMapper(Class&lt;T&gt;) 自定义映射 反序列化 deserializeRecord(ByteRecord) 底层能力","summary":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-20T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","title":"Redis 命令及数据类型 -- Geo","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Geo 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Geo-核心详解\">Geo 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Geo 是基于有序集合（<code>zset</code>） 实现的地理空间操作功能，底层用<code>geohash编码</code>存储<code>经纬度</code>，核心支持 6 个基础操作 + 2 个扩展操作，兼顾<code>精准存储</code>、<code>距离计算</code>、<code>范围筛选</code>等核心需求，直接对接实际场景（如附近门店、同城好友）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>有效经度(longitude)为 <code>-180 ~ 180</code>，有效纬度(latitude)为 <code>-85.05112878 ~ 85.05112878</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 内部实现中：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEO 数据 ≈ ZSET</span><br><span class=\"line\">score = GeoHash（52 位bit ≈ 11 个字符）</span><br><span class=\"line\">member = 实际成员名</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geohash-是什么\">Geohash 是什么?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将「位置」映射为「可排序的值」</span><br><span class=\"line\">相近的地理位置 → 前缀相同或接近</span><br><span class=\"line\">便于 范围查询、邻近查询、索引存储</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心思想</p>\n</li>\n</ul>\n<blockquote>\n<p>不断对经纬度区间进行二分，并交叉编码<br>\n编码顺序：经度 → 纬度 → 经度 → 纬度 → …</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每一步：</span><br><span class=\"line\">    1.取当前区间的中点</span><br><span class=\"line\">    2.大于中点记为 1</span><br><span class=\"line\">    3.小于中点记为 0</span><br><span class=\"line\">    4.缩小区间，继续下一位</span><br><span class=\"line\">最终得到一个 bit 序列。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 内部的 Geohash 字符 = <code>52bit</code>，即 经度 <code>26 bit</code>，纬度 <code>26 bit</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个字符 = 5 bit</span><br><span class=\"line\">内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bit</span><br><span class=\"line\"></span><br><span class=\"line\">Redis 默认在输出字符串时：</span><br><span class=\"line\">    会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0</span><br><span class=\"line\">    因此最终得到 11 个 Base32 字符</span><br></pre></td></tr></table></figure>\n<h3 id=\"Geohash-计算过程示例\">Geohash 计算过程示例</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longitude = 116.397128</span><br><span class=\"line\">latitude  = 39.916527</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了简化计算过程，我们这里固定一个常用精度：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>逐位计算（关键过程）<br>\n1️⃣ 经度 bit（13 位）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-180,180]</td>\n<td>0</td>\n<td>116 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,180]</td>\n<td>90</td>\n<td>116 ≥ 90</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[90,180]</td>\n<td>135</td>\n<td>116 &lt; 135</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[90,135]</td>\n<td>112.5</td>\n<td>116 ≥ 112.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[112.5,135]</td>\n<td>123.75</td>\n<td>116 &lt; 123.75</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[112.5,123.75]</td>\n<td>118.125</td>\n<td>116 &lt; 118.125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[112.5,118.125]</td>\n<td>115.3125</td>\n<td>116 ≥ 115.3125</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[115.3125,118.125]</td>\n<td>116.71875</td>\n<td>116 &lt; 116.71875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[115.3125,116.71875]</td>\n<td>116.015625</td>\n<td>116 ≥ 116.015625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[116.015625,116.71875]</td>\n<td>116.3671875</td>\n<td>116 ≥ 116.3671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[116.3671875,116.71875]</td>\n<td>116.54296875</td>\n<td>116 &lt; 116.54296875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[116.3671875,116.54296875]</td>\n<td>116.455078125</td>\n<td>116 &lt; 116.455078125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>13</td>\n<td>[116.3671875,116.455078125]</td>\n<td>116.4111328125</td>\n<td>116 &lt; 116.4111328125</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>经度 bit（13 位）：<code>1101001011000</code></p>\n</blockquote>\n<p>2️⃣ 纬度 bit（12 位）</p>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-90,90]</td>\n<td>0</td>\n<td>39 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,90]</td>\n<td>45</td>\n<td>39 &lt; 45</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[0,45]</td>\n<td>22.5</td>\n<td>39 ≥ 22.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[22.5,45]</td>\n<td>33.75</td>\n<td>39 ≥ 33.75</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[33.75,45]</td>\n<td>39.375</td>\n<td>39 &lt; 39.375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[33.75,39.375]</td>\n<td>36.5625</td>\n<td>39 ≥ 36.5625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[36.5625,39.375]</td>\n<td>37.96875</td>\n<td>39 ≥ 37.96875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[37.96875,39.375]</td>\n<td>38.671875</td>\n<td>39 ≥ 38.671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[38.671875,39.375]</td>\n<td>39.0234375</td>\n<td>39 &lt; 39.0234375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[38.671875,39.0234375]</td>\n<td>38.84765625</td>\n<td>39 ≥ 38.84765625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[38.84765625,39.0234375]</td>\n<td>38.935546875</td>\n<td>39 ≥ 38.935546875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[38.935546875,39.0234375]</td>\n<td>38.9794921875</td>\n<td>39 ≥ 38.9794921875</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>纬度 bit（12 位）：<code>101101110111</code></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>交叉合并（最终 bit 序列）</p>\n</li>\n</ul>\n<blockquote>\n<p>按规则：经度 → 纬度 → 经度 → 纬度 …</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经度: 1 1 0 1 0 0 1 0 1 1 0 0 0</span><br><span class=\"line\">纬度: 1 0 1 1 0 1 1 1 0 1 1 1</span><br><span class=\"line\"></span><br><span class=\"line\">交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01</span><br><span class=\"line\">合并为一行：1110011100011101101010101</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每 5 bit → 1 个 Base32 字符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从左到右，每 5 位一组：</span></span><br><span class=\"line\">11100 | 11100 | 01110 | 11010 | 10101</span><br><span class=\"line\"><span class=\"comment\"># 转10进制</span></span><br><span class=\"line\">28    | 28    | 14    | 26    | 21</span><br><span class=\"line\"><span class=\"comment\"># 转 Base32</span></span><br><span class=\"line\">w     | w    | f    | u    | p</span><br><span class=\"line\"><span class=\"comment\"># 最终结果：</span></span><br><span class=\"line\">wwfup</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）：</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Index:  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">Char :  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 10 11 12 13 14 15 16 17 18 19</span><br><span class=\"line\">Char :  b  c  d  e  f  g  h  j  k  m</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 20 21 22 23 24 25 26 27 28 29</span><br><span class=\"line\">Char :  n  p  q  r  s  t  u  v  w  x</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 30 31</span><br><span class=\"line\">Char :  y  z</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">Geohash Base32 字符集 为什么缺少 <code>a, i, l, o</code>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">为了避免在视觉上引起数字混淆</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 容易和 4 混淆</span><br><span class=\"line\">i 容易和 1 混淆</span><br><span class=\"line\">l 容易和 1 混淆</span><br><span class=\"line\">o 容易和 0 混淆</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">去掉 <code>a, i, l, o</code> 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"Geo-核心基础操作（必用）\">Geo 核心基础操作（必用）</h2>\n<h3 id=\"1-GEOADD：添加地理位置坐标（核心写入操作）\">1. GEOADD：添加地理位置坐标（核心写入操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># NX：如果已存在，则不执行写入操作</span></span><br><span class=\"line\"><span class=\"comment\"># XX: 如果不存在，则执行写入操作，与 NX 互斥</span></span><br><span class=\"line\"><span class=\"comment\"># CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度 (-180 ~ 180)</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度 (-85.05112878 ~ 85.05112878)</span></span><br><span class=\"line\"><span class=\"comment\"># member: 成员名称，位置唯一标识（字符串）</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给shop集合加王府井、西单2个门店的经纬度</span></span><br><span class=\"line\">GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<p>◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。</p>\n<h3 id=\"2-GEOPOS：获取指定成员的经纬度（精准查询坐标）\">2. GEOPOS：获取指定成员的经纬度（精准查询坐标）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOPOS key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的经纬度数组 [经度, 纬度]</span></span><br><span class=\"line\">GEOPOS shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。</p>\n<h3 id=\"3-GEODIST：计算两个成员之间的距离（核心计算操作）\">3. GEODIST：计算两个成员之间的距离（核心计算操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEODIST key member1 member2 [M|KM|FT|MI]</span><br><span class=\"line\"><span class=\"comment\"># [M|KM|FT|MI] : 距离单位</span></span><br><span class=\"line\"><span class=\"comment\"># M : 米，默认</span></span><br><span class=\"line\"><span class=\"comment\"># KM : 千米</span></span><br><span class=\"line\"><span class=\"comment\"># FT : 英尺</span></span><br><span class=\"line\"><span class=\"comment\"># MI : 英里</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井和西单之间的距离，单位为米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1468.0611&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算王府井到西单的距离，单位千米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan km</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。</p>\n<h3 id=\"4-GEOHASH：获取指定成员的geohash编码（底层编码查询）\">4. GEOHASH：获取指定成员的geohash编码（底层编码查询）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOHASH key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的geohash字符串，共11位</span></span><br><span class=\"line\">GEOHASH shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;wx4g0f6f2u0&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。</p>\n<h3 id=\"5-GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）\">5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCOORD: 返回经纬度</span></span><br><span class=\"line\"><span class=\"comment\"># WITHDIST: 带距离</span></span><br><span class=\"line\"><span class=\"comment\"># WITHHASH: 带geohash</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count: 限制返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ANY: 随机返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ASC/DESC: 按距离正/倒序</span></span><br><span class=\"line\"><span class=\"comment\"># STORE key: 存储结果到指定key</span></span><br><span class=\"line\"><span class=\"comment\"># STOREDIST key: 存储结果到指定key，结果为距离</span></span><br></pre></td></tr></table></figure>\n<p>◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序）</p>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离</span></span><br><span class=\"line\">GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）\">6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 语法说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># member: 已有成员名称</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数说明同 GEORADIUS</span></span><br></pre></td></tr></table></figure>\n<p>◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令）<br>\n◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-扩展操作（实战常用）\">Geo 扩展操作（实战常用）</h2>\n<h3 id=\"1-GEOSEARCH（Redis-6-2-新增，替代-GEORADIUS-GEORADIUSBYMEMBER）\">1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER）</h3>\n<p>◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>\n<p>◦ 语法1（按坐标中心）：<code>GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查天安门3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 语法2（按成员中心）：<code>GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 新增特性：支持 <code>BYBOX（按矩形范围查询）</code>，适配更多场景（如查询某片区内的门店）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店</span></span><br><span class=\"line\"><span class=\"comment\"># 西单距离王府井 1.4681 km，所以不在结果中</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-GEOSEARCHSTORE（Redis-6-2-新增）\">2. GEOSEARCHSTORE（Redis 6.2+ 新增）</h3>\n<p>◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序）<br>\n◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCHSTORE destination <span class=\"built_in\">source</span></span><br><span class=\"line\">  &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 把王府井3km内的门店，存到near_shop集合</span></span><br><span class=\"line\">GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km</span><br></pre></td></tr></table></figure>\n<h2 id=\"底层核心与实战注意事项\">底层核心与实战注意事项</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。</p>\n</li>\n<li class=\"lvl-3\">\n<p>性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。</p>\n</li>\n<li class=\"lvl-3\">\n<p>适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。</p>\n</li>\n</ol>\n<h2 id=\"典型实战场景示例\">典型实战场景示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 批量添加餐饮坐标</span></span><br><span class=\"line\">GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）</span></span><br><span class=\"line\">GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 删除某餐饮</span></span><br><span class=\"line\">ZREM restaurant aaa</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-命令\">Geo 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForGeo()</code> 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Geo</p>\n</blockquote>\n<h3 id=\"写入-删除类操作\">写入 / 删除类操作</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加单个坐标</td>\n<td><code>add(K key, Point point, M member)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td>返回 <strong>新增成员数量</strong>（已存在则返回 0）</td>\n</tr>\n<tr>\n<td>添加单个位置</td>\n<td><code>add(K key, GeoLocation&lt;M&gt; location)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td><code>GeoLocation</code> 内部封装了 <code>Point + member</code></td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Map&lt;M, Point&gt; map)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td><strong>推荐</strong>，一次网络 IO</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td>与 Map 方式等价</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>remove(K key, M... members)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>GEO 本质是 <strong>Sorted Set</strong></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, point, member);</span><br><span class=\"line\"></span><br><span class=\"line\">RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= <span class=\"keyword\">new</span> <span class=\"title class_\">RedisGeoCommands</span>.GeoLocation&lt;&gt;(member, point);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, geoLocation);</span><br></pre></td></tr></table></figure>\n<h3 id=\"距离-坐标-哈希查询\">距离 / 坐标 / 哈希查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>两点距离</td>\n<td><code>distance(K key, m1, m2)</code></td>\n<td><code>GEODIST key m1 m2</code></td>\n<td>默认单位米</td>\n</tr>\n<tr>\n<td>指定单位距离</td>\n<td><code>distance(K key, m1, m2, metric)</code></td>\n<td><code>GEODIST key m1 m2 unit</code></td>\n<td>m / km / mi / ft</td>\n</tr>\n<tr>\n<td>获取 GeoHash</td>\n<td><code>hash(K key, M... members)</code></td>\n<td><code>GEOHASH key member</code></td>\n<td>用于调试</td>\n</tr>\n<tr>\n<td>获取坐标</td>\n<td><code>position(K key, M... members)</code></td>\n<td><code>GEOPOS key member</code></td>\n<td>lon / lat</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"半径查询（旧接口，已不推荐）\">半径查询（旧接口，已不推荐）</h3>\n<blockquote>\n<p>Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基于坐标点</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, Circle within)</code></td>\n<td><code>GEORADIUS key lon lat radius</code></td>\n</tr>\n<tr>\n<td>半径 + 参数</td>\n<td><code>radius(K key, Circle within, args)</code></td>\n<td><code>GEORADIUS</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 基于成员</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, member, radius)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>指定单位</td>\n<td><code>radius(K key, member, Distance)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>radius(K key, member, Distance, args)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"搜索查询（推荐使用-GEOSEARCH）\">搜索查询（推荐使用 GEOSEARCH）</h3>\n<blockquote>\n<p>替代 GEORADIUS / GEORADIUSBYMEMBER</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按圆形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>圆形搜索</td>\n<td><code>search(K key, Circle within)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>新推荐接口</td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>search(K key, GeoReference, Distance)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>FROMMEMBER / FROMLONLAT</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, radius, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>支持排序、limit</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 按矩形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形搜索</td>\n<td><code>search(K key, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用搜索（底层能力）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>任意 GeoShape</td>\n<td><code>search(K key, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于给定的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, <span class=\"type\">double</span> longitude, <span class=\"type\">double</span> latitude, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 中心点</span></span><br><span class=\"line\">    <span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建圆形</span></span><br><span class=\"line\">    <span class=\"type\">Circle</span> <span class=\"variable\">circle</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(point, distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于成员的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, String member, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"搜索并存储（GEOSEARCHSTORE）\">搜索并存储（GEOSEARCHSTORE）</h3>\n<blockquote>\n<p>这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 圆形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索并存储</td>\n<td><code>searchAndStore(K key, destKey, Circle)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>searchAndStore(K key, destKey, reference, radius)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, radius, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 矩形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形存储</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ 通用 GeoShape 存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通用存储</td>\n<td><code>searchAndStore(K key, destKey, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Geo 核心详解 Redis Geo 是基于有序集合（zset） 实现的地理空间操作功能，底层用geohash编码存储经纬度，核心支持 6 个基础操作 + 2 个扩展操作，兼顾精准存储、距离计算、范围筛选等核心需求，直接对接实际场景（如附近门店、同城好友）。 有效经度(longitude)为 -180 ~ 180，有效纬度(latitude)为 -85.05112878 ~ 85.05112878。 Redis 内部实现中： 123GEO 数据 ≈ ZSETscore = GeoHash（52 位bit ≈ 11 个字符）member = 实际成员名 Geohash 是什么? Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是： 123将「位置」映射为「可排序的值」相近的地理位置 → 前缀相同或接近便于 范围查询、邻近查询、索引存储 核心思想 不断对经纬度区间进行二分，并交叉编码 编码顺序：经度 → 纬度 → 经度 → 纬度 → … 123456每一步： 1.取当前区间的中点 2.大于中点记为 1 3.小于中点记为 0 4.缩小区间，继续下一位最终得到一个 bit 序列。 Redis 内部的 Geohash 字符 = 52bit，即 经度 26 bit，纬度 26 bit 123456每个字符 = 5 bit内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bitRedis 默认在输出字符串时： 会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0 因此最终得到 11 个 Base32 字符 Geohash 计算过程示例 12longitude = 116.397128latitude = 39.916527 为了简化计算过程，我们这里固定一个常用精度： 精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度） 逐位计算（关键过程） 1️⃣ 经度 bit（13 位） 位次 区间 mid 判断 bit 1 [-180,180] 0 116 ≥ 0 1 2 [0,180] 90 116 ≥ 90 1 3 [90,180] 135 116 &lt; 135 0 4 [90,135] 112.5 116 ≥ 112.5 1 5 [112.5,135] 123.75 116 &lt; 123.75 0 6 [112.5,123.75] 118.125 116 &lt; 118.125 0 7 [112.5,118.125] 115.3125 116 ≥ 115.3125 1 8 [115.3125,118.125] 116.71875 116 &lt; 116.71875 0 9 [115.3125,116.71875] 116.015625 116 ≥ 116.015625 1 10 [116.015625,116.71875] 116.3671875 116 ≥ 116.3671875 1 11 [116.3671875,116.71875] 116.54296875 116 &lt; 116.54296875 0 12 [116.3671875,116.54296875] 116.455078125 116 &lt; 116.455078125 0 13 [116.3671875,116.455078125] 116.4111328125 116 &lt; 116.4111328125 0 经度 bit（13 位）：1101001011000 2️⃣ 纬度 bit（12 位） 位次 区间 mid 判断 bit 1 [-90,90] 0 39 ≥ 0 1 2 [0,90] 45 39 &lt; 45 0 3 [0,45] 22.5 39 ≥ 22.5 1 4 [22.5,45] 33.75 39 ≥ 33.75 1 5 [33.75,45] 39.375 39 &lt; 39.375 0 6 [33.75,39.375] 36.5625 39 ≥ 36.5625 1 7 [36.5625,39.375] 37.96875 39 ≥ 37.96875 1 8 [37.96875,39.375] 38.671875 39 ≥ 38.671875 1 9 [38.671875,39.375] 39.0234375 39 &lt; 39.0234375 0 10 [38.671875,39.0234375] 38.84765625 39 ≥ 38.84765625 1 11 [38.84765625,39.0234375] 38.935546875 39 ≥ 38.935546875 1 12 [38.935546875,39.0234375] 38.9794921875 39 ≥ 38.9794921875 1 纬度 bit（12 位）：101101110111 交叉合并（最终 bit 序列） 按规则：经度 → 纬度 → 经度 → 纬度 … 12345经度: 1 1 0 1 0 0 1 0 1 1 0 0 0纬度: 1 0 1 1 0 1 1 1 0 1 1 1交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01合并为一行：1110011100011101101010101 每 5 bit → 1 个 Base32 字符 12345678# 从左到右，每 5 位一组：11100 | 11100 | 01110 | 11010 | 10101# 转10进制28 | 28 | 14 | 26 | 21# 转 Base32w | w | f | u | p# 最终结果：wwfup Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）： 1234567891011Index: 0 1 2 3 4 5 6 7 8 9Char : 0 1 2 3 4 5 6 7 8 9Index: 10 11 12 13 14 15 16 17 18 19Char : b c d e f g h j k mIndex: 20 21 22 23 24 25 26 27 28 29Char : n p q r s t u v w xIndex: 30 31Char : y z Geohash Base32 字符集 为什么缺少 a, i, l, o 为了避免在视觉上引起数字混淆 1234a 容易和 4 混淆i 容易和 1 混淆l 容易和 1 混淆o 容易和 0 混淆 去掉 a, i, l, o 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度 Geo 核心基础操作（必用） 1. GEOADD：添加地理位置坐标（核心写入操作） ◦ 语法： 12345678910GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]# 参数说明：# key: key名称# NX：如果已存在，则不执行写入操作# XX: 如果不存在，则执行写入操作，与 NX 互斥# CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量# longitude: 经度 (-180 ~ 180)# latitude: 纬度 (-85.05112878 ~ 85.05112878)# member: 成员名称，位置唯一标识（字符串）# 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量 ◦ 示例： 1234# 给shop集合加王府井、西单2个门店的经纬度GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan# 输出(integer) 2 ◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。 2. GEOPOS：获取指定成员的经纬度（精准查询坐标） ◦ 语法： 1GEOPOS key [member [member ...]] ◦ 示例： 12345# 返回王府井的经纬度数组 [经度, 纬度]GEOPOS shop wangfujing# 输出1) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。 3. GEODIST：计算两个成员之间的距离（核心计算操作） ◦ 语法： 123456GEODIST key member1 member2 [M|KM|FT|MI]# [M|KM|FT|MI] : 距离单位# M : 米，默认# KM : 千米# FT : 英尺# MI : 英里 ◦ 示例： 123456789# 返回王府井和西单之间的距离，单位为米GEODIST shop wangfujing xidan# 输出&quot;1468.0611&quot;# 计算王府井到西单的距离，单位千米GEODIST shop wangfujing xidan km# 输出&quot;1.4681&quot; ◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。 4. GEOHASH：获取指定成员的geohash编码（底层编码查询） ◦ 语法： 1GEOHASH key [member [member ...]] ◦ 示例： 1234# 返回王府井的geohash字符串，共11位GEOHASH shop wangfujing# 输出1) &quot;wx4g0f6f2u0&quot; ◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。 5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 12345678910111213141516GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 参数说明# key: key名称# longitude: 经度# latitude: 纬度# radius: 半径# M|KM|FT|MI: 单位## 可选参数# WITHCOORD: 返回经纬度# WITHDIST: 带距离# WITHHASH: 带geohash# COUNT count: 限制返回数量# ANY: 随机返回数量# ASC/DESC: 按距离正/倒序# STORE key: 存储结果到指定key# STOREDIST key: 存储结果到指定key，结果为距离 ◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序） ◦ 示例： 1234567# 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 1234567GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 语法说明：# key: key名称# member: 已有成员名称# radius: 半径# M|KM|FT|MI: 单位## 可选参数说明同 GEORADIUS ◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令） ◦ 示例： 1234567# 查王府井3km内的门店，按距离排序GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; Geo 扩展操作（实战常用） 1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER） ◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法 123GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH] ◦ 语法1（按坐标中心）：GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查天安门3km内的门店，按距离排序GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 语法2（按成员中心）：GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查王府井3km内的门店，按距离排序GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot; ◦ 新增特性：支持 BYBOX（按矩形范围查询），适配更多场景（如查询某片区内的门店）。 123456789# 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店# 西单距离王府井 1.4681 km，所以不在结果中GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; 2. GEOSEARCHSTORE（Redis 6.2+ 新增） ◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序） ◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH） 1234GEOSEARCHSTORE destination source &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [STOREDIST] ◦ 示例： 12# 把王府井3km内的门店，存到near_shop集合GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km 底层核心与实战注意事项 底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。 精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。 性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。 适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。 典型实战场景示例 需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。 12345678# 1. 批量添加餐饮坐标GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc# 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC# 3. 删除某餐饮ZREM restaurant aaa Geo 命令 SpringBoot 的 StringRedisTemplate.opsForGeo() 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Geo 写入 / 删除类操作 方法功能 方法 Redis 原始命令 备注 添加单个坐标 add(K key, Point point, M member) GEOADD key longitude latitude member 返回 新增成员数量（已存在则返回 0） 添加单个位置 add(K key, GeoLocation&lt;M&gt; location) GEOADD key longitude latitude member GeoLocation 内部封装了 Point + member 批量添加 add(K key, Map&lt;M, Point&gt; map) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 推荐，一次网络 IO 批量添加 add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 与 Map 方式等价 删除成员 remove(K key, M... members) ZREM key member [member ...] GEO 本质是 Sorted Set 12345Point point = new Point(longitude, latitude);redisTemplate.opsForGeo().add(key, point, member);RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= new RedisGeoCommands.GeoLocation&lt;&gt;(member, point);redisTemplate.opsForGeo().add(key, geoLocation); 距离 / 坐标 / 哈希查询 方法功能 方法 Redis 原始命令 说明 两点距离 distance(K key, m1, m2) GEODIST key m1 m2 默认单位米 指定单位距离 distance(K key, m1, m2, metric) GEODIST key m1 m2 unit m / km / mi / ft 获取 GeoHash hash(K key, M... members) GEOHASH key member 用于调试 获取坐标 position(K key, M... members) GEOPOS key member lon / lat 半径查询（旧接口，已不推荐） Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。 1️⃣ 基于坐标点 方法功能 方法 Redis 原始命令 半径查询 radius(K key, Circle within) GEORADIUS key lon lat radius 半径 + 参数 radius(K key, Circle within, args) GEORADIUS 2️⃣ 基于成员 方法功能 方法 Redis 原始命令 半径查询 radius(K key, member, radius) GEORADIUSBYMEMBER 指定单位 radius(K key, member, Distance) GEORADIUSBYMEMBER 带参数 radius(K key, member, Distance, args) GEORADIUSBYMEMBER 搜索查询（推荐使用 GEOSEARCH） 替代 GEORADIUS / GEORADIUSBYMEMBER 1️⃣ 按圆形范围搜索 方法功能 方法 Redis 原始命令 说明 圆形搜索 search(K key, Circle within) GEOSEARCH 新推荐接口 指定参考点 search(K key, GeoReference, Distance) GEOSEARCH FROMMEMBER / FROMLONLAT 带参数 search(K key, reference, radius, args) GEOSEARCH 支持排序、limit 2️⃣ 按矩形范围搜索 方法功能 方法 Redis 原始命令 矩形搜索 search(K key, reference, BoundingBox) GEOSEARCH 带参数 search(K key, reference, BoundingBox, args) GEOSEARCH 通用搜索（底层能力） 方法功能 方法 Redis 原始命令 任意 GeoShape search(K key, reference, GeoShape, args) GEOSEARCH 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 基于给定的坐标搜索public void search(String key, double longitude, double latitude, double radius) &#123; // 中心点 Point point = new Point(longitude, latitude); // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建圆形 Circle circle = new Circle(point, distance); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125;// 基于成员的坐标搜索public void search(String key, String member, double radius) &#123; // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125; 搜索并存储（GEOSEARCHSTORE） 这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet 1️⃣ 圆形范围存储 方法功能 方法 Redis 原始命令 搜索并存储 searchAndStore(K key, destKey, Circle) GEOSEARCHSTORE 指定参考点 searchAndStore(K key, destKey, reference, radius) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, radius, args) GEOSEARCHSTORE 2️⃣ 矩形范围存储 方法功能 方法 Redis 原始命令 矩形存储 searchAndStore(K key, destKey, reference, BoundingBox) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, BoundingBox, args) GEOSEARCHSTORE 3️⃣ 通用 GeoShape 存储 方法功能 方法 Redis 原始命令 通用存储 searchAndStore(K key, destKey, reference, GeoShape, args) GEOSEARCHSTORE","summary":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","title":"Redis 命令及数据类型 -- Hyperloglog","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hyperloglog 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hyperloglog-核心详解\">Hyperloglog 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 <code>12KB</code>）就能统计海量数据的基数，误差率仅 <code>0.81%</code>，无需存储全部数据本身。</p>\n</li>\n</ul>\n<blockquote>\n<p>基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n</ul>\n<h2 id=\"核心使用方式（3个核心命令）\">核心使用方式（3个核心命令）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 命令极简，只有 3 个核心操作</p>\n</li>\n</ul>\n<h3 id=\"PFADD\">PFADD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFADD key [element [element ...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFCOUNT\">PFCOUNT</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFMERGE\">PFMERGE</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFMERGE destkey [sourcekey [sourcekey ...]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"实操示例\">实操示例</h2>\n<h3 id=\"示例1：单-key-基础统计（统计网站-UV）\">示例1：单 key 基础统计（统计网站 UV）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 模拟3个访客访问，其中用户A重复访问</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 统计当日UV（去重后是3，忽略重复的userA）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251218</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例2：-多-key-合并与汇总统计\">示例2： 多 key 合并与汇总统计</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 分别统计12.17和12.18的UV</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251217 userA userD</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 合并两日UV到 uv:20251217_18</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251217_18</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心应用场景（精准落地场景）\">核心应用场景（精准落地场景）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 只关注 <strong>“去重数量”</strong>，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案：</p>\n</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">\n<p>网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。</p>\n</li>\n<li class=\"lvl-3\">\n<p>业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。</p>\n</li>\n</ol>\n<h2 id=\"关键注意事项（避坑重点）\">关键注意事项（避坑重点）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。</p>\n</li>\n<li class=\"lvl-3\">\n<p>误差不可避免，可控不影响大部分场景：固定误差率 <code>0.81%</code>，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。</p>\n</li>\n<li class=\"lvl-3\">\n<p>内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 <code>12KB</code>，这是其核心优势，也是区别于 Set 的关键。</p>\n</li>\n<li class=\"lvl-3\">\n<p>元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 <code>EXPIRE key seconds</code> 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。</p>\n</li>\n</ol>\n<h2 id=\"与-Set-统计基数的对比（选型参考）\">与 Set 统计基数的对比（选型参考）</h2>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>HyperLogLog</th>\n<th>Set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据结构类型</td>\n<td>基数统计结构</td>\n<td>无序集合</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>固定约 <strong>12KB</strong>，与数据量无关</td>\n<td>随元素数量线性增长，海量数据内存占用极高</td>\n</tr>\n<tr>\n<td>统计结果精度</td>\n<td><strong>非精准</strong>，标准误差约 <strong>0.81%</strong></td>\n<td><strong>100% 精准</strong></td>\n</tr>\n<tr>\n<td>是否支持获取具体元素</td>\n<td>不支持</td>\n<td>支持（如 <code>SMEMBERS</code>）</td>\n</tr>\n<tr>\n<td>是否支持去重</td>\n<td>支持（基数去重）</td>\n<td>支持（元素级去重）</td>\n</tr>\n<tr>\n<td>统计性能</td>\n<td>极快（固定计算逻辑，O(1)）</td>\n<td>数据量越大，统计与遍历成本越高</td>\n</tr>\n<tr>\n<td>适合数据规模</td>\n<td>超大规模（百万 / 千万 / 亿级）</td>\n<td>中小规模集合</td>\n</tr>\n<tr>\n<td>常见使用场景</td>\n<td>UV / DAU 统计、独立 IP 数、访问用户数</td>\n<td>好友列表、标签集合、关注列表</td>\n</tr>\n<tr>\n<td>是否可做集合运算</td>\n<td>不支持</td>\n<td>支持（<code>SUNION</code> / <code>SINTER</code> / <code>SDIFF</code>）</td>\n</tr>\n<tr>\n<td>是否可序列化/持久化</td>\n<td>可（Redis 内部结构）</td>\n<td>可</td>\n</tr>\n<tr>\n<td>选型结论</td>\n<td><strong>低成本 + 海量数据 + 可接受误差的基数统计</strong></td>\n<td><strong>精准统计 + 需要元素明细的场景</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"HyperLogLog-命令\">HyperLogLog 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForHyperLogLog()</code> 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 HyperLogLog</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注 / 使用建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素</td>\n<td><code>Long add(K key, V... values)</code></td>\n<td><code>PFADD key element [element ...]</code></td>\n<td>返回 1 表示 HLL 结构发生变化</td>\n</tr>\n<tr>\n<td>获取基数（去重数）</td>\n<td><code>Long size(K... keys)</code></td>\n<td><code>PFCOUNT key [key ...]</code></td>\n<td>支持多 key 合并统计</td>\n</tr>\n<tr>\n<td>合并 HLL</td>\n<td><code>Long union(K destination, K... sourceKeys)</code></td>\n<td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td>\n<td>合并后写入 destkey</td>\n</tr>\n<tr>\n<td>删除 HLL</td>\n<td><code>void delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>直接删除整个 HLL</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hyperloglog 核心详解 Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 12KB）就能统计海量数据的基数，误差率仅 0.81%，无需存储全部数据本身。 基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。 Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展 核心使用方式（3个核心命令） HyperLogLog 命令极简，只有 3 个核心操作 PFADD 向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。 1PFADD key [element [element ...]] PFCOUNT 统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。 1PFCOUNT key [key ...] PFMERGE 将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。 1PFMERGE destkey [sourcekey [sourcekey ...]] 实操示例 示例1：单 key 基础统计（统计网站 UV） 123456789# 1. 模拟3个访客访问，其中用户A重复访问127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA(integer) 0# 2. 统计当日UV（去重后是3，忽略重复的userA）127.0.0.1:6379&gt; PFCOUNT uv:20251218(integer) 3 示例2： 多 key 合并与汇总统计 12345678910111213# 1. 分别统计12.17和12.18的UV127.0.0.1:6379&gt; PFADD uv:20251217 userA userD(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1# 2. 合并两日UV到 uv:20251217_18127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218OK# 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）127.0.0.1:6379&gt; PFCOUNT uv:20251217_18(integer) 4 核心应用场景（精准落地场景） HyperLogLog 只关注 “去重数量”，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案： 网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。 业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。 海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。 跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。 关键注意事项（避坑重点） 不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。 误差不可避免，可控不影响大部分场景：固定误差率 0.81%，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。 内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 12KB，这是其核心优势，也是区别于 Set 的关键。 元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。 过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 EXPIRE key seconds 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。 PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。 与 Set 统计基数的对比（选型参考） 对比维度 HyperLogLog Set 数据结构类型 基数统计结构 无序集合 内存占用 固定约 12KB，与数据量无关 随元素数量线性增长，海量数据内存占用极高 统计结果精度 非精准，标准误差约 0.81% 100% 精准 是否支持获取具体元素 不支持 支持（如 SMEMBERS） 是否支持去重 支持（基数去重） 支持（元素级去重） 统计性能 极快（固定计算逻辑，O(1)） 数据量越大，统计与遍历成本越高 适合数据规模 超大规模（百万 / 千万 / 亿级） 中小规模集合 常见使用场景 UV / DAU 统计、独立 IP 数、访问用户数 好友列表、标签集合、关注列表 是否可做集合运算 不支持 支持（SUNION / SINTER / SDIFF） 是否可序列化/持久化 可（Redis 内部结构） 可 选型结论 低成本 + 海量数据 + 可接受误差的基数统计 精准统计 + 需要元素明细的场景 HyperLogLog 命令 SpringBoot 的 StringRedisTemplate.opsForHyperLogLog() 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 HyperLogLog 方法功能 方法 Redis 原始命令 备注 / 使用建议 添加元素 Long add(K key, V... values) PFADD key element [element ...] 返回 1 表示 HLL 结构发生变化 获取基数（去重数） Long size(K... keys) PFCOUNT key [key ...] 支持多 key 合并统计 合并 HLL Long union(K destination, K... sourceKeys) PFMERGE destkey sourcekey [sourcekey ...] 合并后写入 destkey 删除 HLL void delete(K key) DEL key 直接删除整个 HLL","summary":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/","url":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/","title":"Redis 命令及数据类型 -- Bitfield","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Bitfield 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bitfield-核心详解\">Bitfield 核心详解</h2>\n<p>• BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。<br>\n• 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。</p>\n<h2 id=\"Bitfield-命令\">Bitfield 命令</h2>\n<h3 id=\"1-BITFIELD-批量操作\">1. <code>BITFIELD</code> 批量操作</h3>\n<p>• BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  ...]]</span><br></pre></td></tr></table></figure>\n<p>• 参数说明（核心部分）</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>操作的 Redis 字符串键</td>\n</tr>\n<tr>\n<td><strong>GET encoding offset</strong></td>\n<td>从指定位偏移量读取一个整数</td>\n</tr>\n<tr>\n<td><strong>SET encoding offset value</strong></td>\n<td>在指定位置写入整数</td>\n</tr>\n<tr>\n<td><strong>INCRBY encoding offset increment</strong></td>\n<td>在指定位置对整数做增量操作</td>\n</tr>\n<tr>\n<td><strong>OVERFLOW WRAP/SAT/FAIL</strong></td>\n<td>配置随后的算数操作溢出行为</td>\n</tr>\n</tbody>\n</table>\n<p>• 数据类型（encoding）:用于指定整数的位宽和符号类型</p>\n<table>\n<thead>\n<tr>\n<th>前缀</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>u&lt;number&gt;</code></td>\n<td>无符号整数（unsigned），占位 bits = number</td>\n<td>u5 — 5 位无符号整数</td>\n</tr>\n<tr>\n<td><code>i&lt;number&gt;</code></td>\n<td>有符号整数（signed），占位 bits = number</td>\n<td>i10 — 10 位有符号整数</td>\n</tr>\n</tbody>\n</table>\n<p>• 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。</p>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>WRAP</strong></td>\n<td>环绕（默认）溢出按环形计数处理</td>\n</tr>\n<tr>\n<td><strong>SAT</strong></td>\n<td>饱和，在边界值保持最大/最小</td>\n</tr>\n<tr>\n<td><strong>FAIL</strong></td>\n<td>溢出时操作失败并返回错误</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。</span></span><br><span class=\"line\">BITFIELD key OVERFLOW SAT INCRBY u4 0 1</span><br></pre></td></tr></table></figure>\n<p>• 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-BITFIELD-RO-批量只读\">2. <code>BITFIELD_RO</code> 批量只读</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 6.0 新增的只读版本，用于批量只读</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD_RO key [GET encoding offset [GET encoding offset ...]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"综合示例\">综合示例</h2>\n<h3 id=\"示例-1-设置并读取简单整数\">示例 1. 设置并读取简单整数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET mykey <span class=\"string\">&quot;&quot;</span> <span class=\"comment\"># 此时mykey 的值是空字符串，长度为 0</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET u4 0 7 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># set命令的返回值，这里返回set前的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># get命令的返回值</span></span><br><span class=\"line\"><span class=\"comment\"># 设置有符号整数</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET i4 0 -2 GET i4 0</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># 返回set前的值，之前是7，即 0111，set后变为 -2，即 1110</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) -2 <span class=\"comment\"># get命令的返回值</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>负数的二进制表示</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">以 -2 为例，先写出 +2 的二进制，以8位为例，就是 <code>00000010</code>，4位就是 <code>0010</code></li>\n<li class=\"lvl-2\">按位取反（得到反码），例如 <code>00000010</code>，按位取反就是 <code>11111101</code></li>\n<li class=\"lvl-2\">加 1（得到补码），<code>11111101</code> + 1，得到 <code>11111110</code>，这就是 -2 的二进制表示</li>\n<li class=\"lvl-2\">如果是4位，则 -2 就是 <code>1110</code></li>\n</ul>\n</div>\n<h3 id=\"示例-2-自增计数器\">示例 2. 自增计数器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果 counter 之前为空，则视为 0</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5</span></span><br><span class=\"line\"><span class=\"comment\"># GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值</span></span><br><span class=\"line\">BITFIELD counter INCRBY u8 8 5 GET u8 8</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 5 <span class=\"comment\"># INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例-3-带溢出控制的操作\">示例 3. 带溢出控制的操作</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># OVERFLOW SAT: 设置溢出策略为 SAT（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 4 位无符号整数，即15</span></span><br><span class=\"line\">BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 15</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 15</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例-4-批量多个操作\">示例 4. 批量多个操作</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理</span></span><br><span class=\"line\"><span class=\"comment\"># 返回结果数组对应每个子命令顺序返回结果</span></span><br><span class=\"line\">BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 0000000000110000</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-操作-BitField\">SpringBoot 操作 BitField</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 BitField 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 BitField</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>位字段读/写/自增</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>位字段操作（读/写/自增）</td>\n<td><code>bitField(K key, BitFieldSubCommands subCommands)</code></td>\n<td><code>BITFIELD key ...</code></td>\n<td>原子执行多个子命令</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD limits</span><br><span class=\"line\">    OVERFLOW SAT</span><br><span class=\"line\">    SET u4 0 3</span><br><span class=\"line\">    INCRBY u4 0 20</span><br><span class=\"line\">    GET u4 0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SET u4 0 3</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldSet</span> <span class=\"variable\">bitFieldSet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// OVERFLOW SAT INCRBY u4 0 20</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldIncrBy</span> <span class=\"variable\">bitFieldIncrBy</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">20</span>, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);</span><br><span class=\"line\"><span class=\"comment\">// GET u4 0</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldGet</span> <span class=\"variable\">bitFieldGet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取结果，每个子操作返回一个结果</span></span><br><span class=\"line\">List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(<span class=\"string\">&quot;limits&quot;</span>, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis Bitfield 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Bitfield 核心详解 • BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。 • 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。 Bitfield 命令 1. BITFIELD 批量操作 • BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。 12345BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; ...]] • 参数说明（核心部分） 参数 含义 key 操作的 Redis 字符串键 GET encoding offset 从指定位偏移量读取一个整数 SET encoding offset value 在指定位置写入整数 INCRBY encoding offset increment 在指定位置对整数做增量操作 OVERFLOW WRAP/SAT/FAIL 配置随后的算数操作溢出行为 • 数据类型（encoding）:用于指定整数的位宽和符号类型 前缀 含义 示例 u&lt;number&gt; 无符号整数（unsigned），占位 bits = number u5 — 5 位无符号整数 i&lt;number&gt; 有符号整数（signed），占位 bits = number i10 — 10 位有符号整数 • 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。 策略 行为 WRAP 环绕（默认）溢出按环形计数处理 SAT 饱和，在边界值保持最大/最小 FAIL 溢出时操作失败并返回错误 12# 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。BITFIELD key OVERFLOW SAT INCRBY u4 0 1 • 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果 1234BITFIELD mykey INCRBY i5 100 1 GET u4 0# 输出1) (integer) 12) (integer) 0 2. BITFIELD_RO 批量只读 Redis 6.0 新增的只读版本，用于批量只读 1BITFIELD_RO key [GET encoding offset [GET encoding offset ...]] 综合示例 示例 1. 设置并读取简单整数 1234567891011&gt; SET mykey &quot;&quot; # 此时mykey 的值是空字符串，长度为 0# SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000# GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7&gt; BITFIELD mykey SET u4 0 7 GET u4 0# 输出1) (integer) 0 # set命令的返回值，这里返回set前的值2) (integer) 7 # get命令的返回值# 设置有符号整数&gt; BITFIELD mykey SET i4 0 -2 GET i4 01) (integer) 7 # 返回set前的值，之前是7，即 0111，set后变为 -2，即 11102) (integer) -2 # get命令的返回值 负数的二进制表示 以 -2 为例，先写出 +2 的二进制，以8位为例，就是 00000010，4位就是 0010 按位取反（得到反码），例如 00000010，按位取反就是 11111101 加 1（得到补码），11111101 + 1，得到 11111110，这就是 -2 的二进制表示 如果是4位，则 -2 就是 1110 示例 2. 自增计数器 1234567# 如果 counter 之前为空，则视为 0# INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5# GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值BITFIELD counter INCRBY u8 8 5 GET u8 8# 输出1) (integer) 5 # INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值2) (integer) 5 示例 3. 带溢出控制的操作 1234567# OVERFLOW SAT: 设置溢出策略为 SAT（饱和）# INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）# GET u4 0：读取 4 位无符号整数，即15BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0# 输出1) (integer) 152) (integer) 15 示例 4. 批量多个操作 123456789# GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数# SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理# 返回结果数组对应每个子命令顺序返回结果BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1# 输出1) (integer) 0 # events原先为空，所以这里返回02) (integer) 0 # events原先为空，所以这里返回03) (integer) 0 # events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 00000000001100004) (integer) 1 # 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节 SpringBoot 操作 BitField SpringBoot 的 StringRedisTemplate.opsForValue() 中 BitField 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 BitField 位字段读/写/自增 方法功能 方法 Redis 原始命令 备注 位字段操作（读/写/自增） bitField(K key, BitFieldSubCommands subCommands) BITFIELD key ... 原子执行多个子命令 示例 12345BITFIELD limits OVERFLOW SAT SET u4 0 3 INCRBY u4 0 20 GET u4 0 123456789// SET u4 0 3BitFieldSubCommands.BitFieldSet bitFieldSet = BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 3);// OVERFLOW SAT INCRBY u4 0 20BitFieldSubCommands.BitFieldIncrBy bitFieldIncrBy = BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 20, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);// GET u4 0BitFieldSubCommands.BitFieldGet bitFieldGet = BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0));// 获取结果，每个子操作返回一个结果List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(&quot;limits&quot;, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));","summary":"摘要 本文介绍 Redis Bitfield 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-18T13:30:06.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","url":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","title":"Redis 命令及数据类型 -- Bitmap","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Bitmap 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bitmap-核心详解\">Bitmap 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n<li class=\"lvl-2\">\n<p>String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值）</p>\n</li>\n</ul>\n<h2 id=\"Bitmap-命令使用方式\">Bitmap 命令使用方式</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础</p>\n</li>\n</ul>\n<h3 id=\"1-位设置：SETBIT-key-offset-value\">1. 位设置：<code>SETBIT key offset value</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容）</p>\n</li>\n<li class=\"lvl-2\">\n<p>offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT bitkey 1 1 <span class=\"comment\"># 实际的bit为 01000000</span></span><br><span class=\"line\">SETBIT bitkey 10 1 <span class=\"comment\"># 实际的bit为 0100000000100000</span></span><br><span class=\"line\"><span class=\"comment\"># 操作 String</span></span><br><span class=\"line\">SET k1 v1 <span class=\"comment\"># 实际的bit为 0111011000110001</span></span><br><span class=\"line\">SETBIT k1 1 0 <span class=\"comment\"># 实际bit为 0011011000110001</span></span><br><span class=\"line\">GET k1 <span class=\"comment\"># 输出 61</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bitmap 实际上是 string</span></span><br><span class=\"line\">TYPE bitkey <span class=\"comment\"># 输出 string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-位查询：GETBIT-key-offset\">2. 位查询：<code>GETBIT key offset</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查询指定偏移量的位值，不存在的 offset 默认返回 0</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GETBIT bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-位统计：BITCOUNT-key-start-end\">3. 位统计：<code>BITCOUNT key [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITCOUNT bitkey</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITCOUNT bitkey 0 -1</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-位运算：BITOP-op-destkey-key1-key2\">4. 位运算：<code>BITOP op destkey key1 key2...</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将key1 与 key2 做按位与运算，结果存入 destkey</span></span><br><span class=\"line\">BITOP AND destkey key1 key2</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-位查找：BITPOS-key-value-start-end\">5. 位查找：<code>BITPOS key value [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查找第一个值为 0/1 的 bit 偏移量，快速定位目标位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITPOS bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITPOS bitkey 1 0 -1</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心使用场景-实操举例（贴合开发实战）\">核心使用场景 + 实操举例（贴合开发实战）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景</p>\n</li>\n</ul>\n<h3 id=\"场景1：-用户签到-打卡（最经典场景）\">场景1： 用户签到/打卡（最经典场景）</h3>\n<p>• 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数<br>\n• 设计：key 格式 <code>user:sign:uid:202512</code>（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>12月1号签到：<code>SETBIT user:sign:uid:202512 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询12月1号是否签到：<code>GETBIT user:sign:uid:202512 0</code>（返回1=签到）</p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月总签到次数：<code>BITCOUNT user:sign:uid:202512</code></p>\n</li>\n</ol>\n<p>• 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景2：-日活-周活-月活（DAU-WAU-MAU）统计（高并发场景首选）\">场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选）</h3>\n<p>• 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计<br>\n• 设计：按日期建 Bitmap，key 格式 <code>active:user:20251217</code>（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>用户ID 10086 12月17日访问：<code>SETBIT active:user:20251217 10086 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月17日日活：<code>BITCOUNT active:user:20251217</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日3天内活跃的用户数：<code>BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日每天都登录的用户数：<code>BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n</ol>\n<p>• 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景3：-功能开关-状态标记（多维度轻量标记）\">场景3： 功能开关/状态标记（多维度轻量标记）</h3>\n<p>• 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key<br>\n• 设计：1个key对应1个用户，key 格式 <code>user:status:10086</code>，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>给用户10086绑定手机：<code>SETBIT user:status:10086 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>开通会员：<code>SETBIT user:status:10086 1 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询是否是会员：<code>GETBIT user:status:10086 1</code></p>\n</li>\n</ol>\n<p>• 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景4：-布隆过滤器底层实现（核心依赖Bitmap）\">场景4： 布隆过滤器底层实现（核心依赖Bitmap）</h3>\n<p>• 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判<br>\n• 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在<br>\n• 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。<br>\n• 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：布隆过滤器虽然有极小误判率，但不允许删除。</p>\n</li>\n</ul>\n<h2 id=\"注意事项（避坑关键）\">注意事项（避坑关键）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩）</p>\n</li>\n<li class=\"lvl-3\">\n<p>避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长</p>\n</li>\n<li class=\"lvl-3\">\n<p>注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置</p>\n</li>\n</ol>\n<h2 id=\"Bitmap-命令\">Bitmap 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Bitmap</p>\n</blockquote>\n<h3 id=\"写操作（位修改）\">写操作（位修改）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置指定偏移量的位</td>\n<td><code>setBit(K key, long offset, boolean value)</code></td>\n<td><code>SETBIT key offset value</code></td>\n<td>返回旧值（0 / 1），offset 从 0 开始</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>offset 表示 第几位（bit），不是字节</p>\n</blockquote>\n<h3 id=\"读操作（位查询）\">读操作（位查询）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定偏移量的位</td>\n<td><code>getBit(K key, long offset)</code></td>\n<td><code>GETBIT key offset</code></td>\n<td>返回 0 / 1，不会修改数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Bitmap-常用但-Spring-未直接封装的命令\">Bitmap 常用但 Spring 未直接封装的命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Redis 命令</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>BITCOUNT key [start end]</code></td>\n<td>统计 bit=1 的数量</td>\n<td>常用于活跃用户统计</td>\n</tr>\n<tr>\n<td><code>BITPOS key bit [start end]</code></td>\n<td>查找第一个 0/1 的位置</td>\n<td>常用于分配位</td>\n</tr>\n<tr>\n<td><code>BITOP AND/OR/XOR/NOT</code></td>\n<td>位运算</td>\n<td>多 bitmap 计算</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo.bitmap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.demo.CommonUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.domain.Range;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BitmapUtil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITCOUNT key [start end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 统计 bit=1 的数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(), start, end)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITPOS key bit [start] [end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = false → 查找第一个 0</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = true → 查找第一个 1</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回值是 bit 索引（不是 byte）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITOP operation destKey key [key ...]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * operation: AND\\OR\\XOR\\NOT</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 运算结果保存在 destKey 中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitOp</span><span class=\"params\">(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[][] keys = Arrays.stream(sourceKeys)</span><br><span class=\"line\">                    .map(String::getBytes)</span><br><span class=\"line\">                    .toArray(<span class=\"type\">byte</span>[][]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.stringCommands().bitOp(</span><br><span class=\"line\">                    operation,</span><br><span class=\"line\">                    destKey.getBytes(),</span><br><span class=\"line\">                    keys</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Bitmap 核心详解 Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展 String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值） Bitmap 命令使用方式 核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础 1. 位设置：SETBIT key offset value 给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容） offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte 123456789SETBIT bitkey 1 1 # 实际的bit为 01000000SETBIT bitkey 10 1 # 实际的bit为 0100000000100000# 操作 StringSET k1 v1 # 实际的bit为 0111011000110001SETBIT k1 1 0 # 实际bit为 0011011000110001GET k1 # 输出 61# bitmap 实际上是 stringTYPE bitkey # 输出 string 2. 位查询：GETBIT key offset 查询指定偏移量的位值，不存在的 offset 默认返回 0 123GETBIT bitkey 1# 输出(integer) 1 3. 位统计：BITCOUNT key [start end] 统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选 123BITCOUNT bitkey# 等价于BITCOUNT bitkey 0 -1 4. 位运算：BITOP op destkey key1 key2... 对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey 12# 将key1 与 key2 做按位与运算，结果存入 destkeyBITOP AND destkey key1 key2 5. 位查找：BITPOS key value [start end] 查找第一个值为 0/1 的 bit 偏移量，快速定位目标位 123BITPOS bitkey 1# 等价于BITPOS bitkey 1 0 -1 核心使用场景 + 实操举例（贴合开发实战） Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景 场景1： 用户签到/打卡（最经典场景） • 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数 • 设计：key 格式 user:sign:uid:202512（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0 • 实操命令： 12月1号签到：SETBIT user:sign:uid:202512 0 1 查询12月1号是否签到：GETBIT user:sign:uid:202512 0（返回1=签到） 统计12月总签到次数：BITCOUNT user:sign:uid:202512 • 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。 劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选） • 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计 • 设计：按日期建 Bitmap，key 格式 active:user:20251217（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1 • 实操命令： 用户ID 10086 12月17日访问：SETBIT active:user:20251217 10086 1 统计12月17日日活：BITCOUNT active:user:20251217 统计12月15-17日3天内活跃的用户数：BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 统计12月15-17日每天都登录的用户数：BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 • 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。 劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景3： 功能开关/状态标记（多维度轻量标记） • 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key • 设计：1个key对应1个用户，key 格式 user:status:10086，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否 • 实操命令： 给用户10086绑定手机：SETBIT user:status:10086 0 1 开通会员：SETBIT user:status:10086 1 1 查询是否是会员：GETBIT user:status:10086 1 • 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。 劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景4： 布隆过滤器底层实现（核心依赖Bitmap） • 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判 • 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在 • 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。 • 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。 劣势：布隆过滤器虽然有极小误判率，但不允许删除。 注意事项（避坑关键） offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩） 避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长 注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置 Bitmap 命令 SpringBoot 的 StringRedisTemplate.opsForValue() 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Bitmap 写操作（位修改） 方法功能 方法 Redis 原始命令 备注 设置指定偏移量的位 setBit(K key, long offset, boolean value) SETBIT key offset value 返回旧值（0 / 1），offset 从 0 开始 offset 表示 第几位（bit），不是字节 读操作（位查询） 方法功能 方法 Redis 原始命令 备注 获取指定偏移量的位 getBit(K key, long offset) GETBIT key offset 返回 0 / 1，不会修改数据 Bitmap 常用但 Spring 未直接封装的命令 Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。 Redis 命令 功能 说明 BITCOUNT key [start end] 统计 bit=1 的数量 常用于活跃用户统计 BITPOS key bit [start end] 查找第一个 0/1 的位置 常用于分配位 BITOP AND/OR/XOR/NOT 位运算 多 bitmap 计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.demo.bitmap;import com.example.demo.CommonUtil;import org.springframework.data.domain.Range;import org.springframework.data.redis.connection.RedisStringCommands;import org.springframework.data.redis.core.RedisCallback;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;import java.util.Arrays;@Componentpublic class BitmapUtil &#123; @Autowired protected StringRedisTemplate redisTemplate; /** * BITCOUNT key [start end] * &lt;p&gt; * 统计 bit=1 的数量 */ public Long bitCount(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8)) ); &#125; public Long bitCount(String key, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(), start, end) ); &#125; /** * BITPOS key bit [start] [end] * &lt;p&gt; * bit = false → 查找第一个 0 * bit = true → 查找第一个 1 * &lt;p&gt; * 返回值是 bit 索引（不是 byte） */ public Long bitPos(String key, boolean bit) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit) ); &#125; public Long bitPos(String key, boolean bit, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end)) ); &#125; /** * BITOP operation destKey key [key ...] * &lt;p&gt; * operation: AND\\OR\\XOR\\NOT * &lt;p&gt; * 运算结果保存在 destKey 中 */ public Long bitOp(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123; byte[][] keys = Arrays.stream(sourceKeys) .map(String::getBytes) .toArray(byte[][]::new); return connection.stringCommands().bitOp( operation, destKey.getBytes(), keys ); &#125;); &#125;&#125;","summary":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-18T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","url":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","title":"一个基于 Redis 的可重入分布式锁的实现","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 一个基于 Redis 的可重入分布式锁的实现方案</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">本文仅为学习原理，生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/locks-and-synchronizers/\">Redisson 分布式锁</a> 吧。</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"设计目标与关键约束\">设计目标与关键约束</h2>\n<h3 id=\"设计目标\">设计目标</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>互斥性：同一时间只有一个持有者</p>\n</li>\n<li class=\"lvl-2\">\n<p>可重入：同一线程 / 请求可多次加锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>安全释放：只能释放自己持有的锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>自动过期：防止死锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>续期能力（Watch Dog）：业务时间不确定时依然安全</p>\n</li>\n<li class=\"lvl-2\">\n<p>高性能：单 Redis Key，Lua 保证原子性</p>\n</li>\n</ul>\n<h3 id=\"技术选型\">技术选型</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Boot</p>\n</li>\n<li class=\"lvl-2\">\n<p>Spring Data Redis（Lettuce）</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis Lua Script</p>\n</li>\n</ul>\n<blockquote>\n<p>Redis 是唯一依赖组件：Redis<br>\nSpring Boot 作为运行框架：Spring Boot</p>\n</blockquote>\n<h3 id=\"锁的核心数据结构设计（关键）\">锁的核心数据结构设计（关键）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Key 结构(String)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># lock:前缀</span></span><br><span class=\"line\">lock:order:123</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Value 结构（Hash）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;uuid:threadId&quot;</span> : 重入次数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同一线程重入 → count +1，不同线程 → 拒绝</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用<code>StringRedisTemplate</code>，因其序列化器是<code>StringRedisSerializer</code>，可以保证 Lua 脚本能够正常执行。</p>\n</li>\n</ul>\n<blockquote>\n<p>基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer</p>\n</blockquote>\n<h3 id=\"Lua-脚本（原子性保障）\">Lua 脚本（原子性保障）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加锁脚本（支持可重入）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[2] expireMillis</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;exists&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hset&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解锁脚本（防误删）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> count = redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hdel&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hlen&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">        redis.call(<span class=\"string\">&#x27;del&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java-实现（核心代码）\">Java 实现（核心代码）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>WatchDog，实现锁自动续期</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisLockWatchDog</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * WatchDog的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 拥有者是当前线程就续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">WATCHDOG_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单线程足够（Redisson 也是）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">scheduler</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                t.setName(<span class=\"string\">&quot;redis-lock-watch-dog&quot;</span>);</span><br><span class=\"line\">                t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每个 lockKey 对应一个续期任务</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisLockWatchDog</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动续期</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey     Redis 锁 key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ownerId     uuid:threadId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseMillis 锁过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startRenew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 防止重复启动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (renewTasks.containsKey(lockKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 间隔多久续期一次</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">period</span> <span class=\"operator\">=</span> leaseMillis / <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                renew(lockKey, ownerId, leaseMillis);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生产环境建议接日志</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        renewTasks.put(lockKey, future);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取消续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stopRenew</span><span class=\"params\">(String lockKey)</span> &#123;</span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (future != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            future.cancel(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实际续期逻辑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">renew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId,</span><br><span class=\"line\">                String.valueOf(leaseMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 锁已不属于当前线程，停止 Watch Dog</span></span><br><span class=\"line\">            stopRenew(lockKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 应用关闭时释放资源（可选）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shutdown</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        scheduler.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> waitTime  尝试获取锁的最大等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 不等待立即返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 只要获取到锁就返回，否则一直自旋获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit 时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁实现类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的key前缀</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.key 不存在时创建锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.key 存在时判断锁的拥有者是否为当前线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">UNLOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 0</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)</span></span><br><span class=\"line\"><span class=\"string\">            if (count &gt; 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            else</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1])</span></span><br><span class=\"line\"><span class=\"string\">                if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                    redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">                end</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedisLockWatchDog watchDog;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisReentrantLock</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">        watchDog = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisLockWatchDog</span>(redisTemplate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前线程的 ownerId</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">ownerId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uuid + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expireMillis</span> <span class=\"operator\">=</span> unit.toMillis(leaseTime);</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(LOCK_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId(),</span><br><span class=\"line\">                String.valueOf(expireMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Boolean.TRUE.equals(success)) &#123;<span class=\"comment\">//防止NullPointerException</span></span><br><span class=\"line\">            <span class=\"comment\">// 启动 Watch Dog（只有在 leaseTime 不确定时）</span></span><br><span class=\"line\">            watchDog.startRenew(</span><br><span class=\"line\">                    lockKey,</span><br><span class=\"line\">                    ownerId(),</span><br><span class=\"line\">                    expireMillis</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">deadline</span> <span class=\"operator\">=</span> System.currentTimeMillis() + unit.toMillis(waitTime);</span><br><span class=\"line\">        <span class=\"comment\">// 使用带条件的循环，避免重复赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; deadline) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用无限循环，语义更清晰</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"comment\">// 先停续期</span></span><br><span class=\"line\">        watchDog.stopRenew(lockKey);</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(UNLOCK_SCRIPT, Long.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId()</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.lock.RedisReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockTests</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisReentrantLock redisReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;order:123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">5</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">                doBusiness();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 测试可重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBusiness</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (redisReentrantLock.lock(lockKey, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能</span></span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;结束执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试多线程同时获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demoMultiThread</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">threadCount</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(threadCount);</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">successCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 每个线程都尝试获取同一个锁</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">10</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            successCount.incrementAndGet();</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁成功，开始执行业务&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 模拟业务执行时间</span></span><br><span class=\"line\">                            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 业务执行完成&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 释放锁&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁失败&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    latch.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待所有线程执行完成</span></span><br><span class=\"line\">        latch.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;成功获取锁的线程数: &quot;</span> + successCount.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redisson-的锁的使用方法\">Redisson 的锁的使用方法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;myLock&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传统锁定方式，阻塞等待获取锁</span></span><br><span class=\"line\"><span class=\"comment\">// lock.lock();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者，获取锁并在10秒后自动解锁</span></span><br><span class=\"line\"><span class=\"comment\">// lock.lock(10, TimeUnit.SECONDS);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或等，尝试在 100 秒内获取锁，获得后在 10 秒后自动解锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">100</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取锁成功&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。 设计目标与关键约束 设计目标 互斥性：同一时间只有一个持有者 可重入：同一线程 / 请求可多次加锁 安全释放：只能释放自己持有的锁 自动过期：防止死锁 续期能力（Watch Dog）：业务时间不确定时依然安全 高性能：单 Redis Key，Lua 保证原子性 技术选型 Spring Boot Spring Data Redis（Lettuce） Redis Lua Script Redis 是唯一依赖组件：Redis Spring Boot 作为运行框架：Spring Boot 锁的核心数据结构设计（关键） Redis Key 结构(String) 12# lock:前缀lock:order:123 Value 结构（Hash） 123&#123; &quot;uuid:threadId&quot; : 重入次数&#125; 同一线程重入 → count +1，不同线程 → 拒绝 使用StringRedisTemplate，因其序列化器是StringRedisSerializer，可以保证 Lua 脚本能够正常执行。 基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer Lua 脚本（原子性保障） 加锁脚本（支持可重入） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerId (uuid:threadId)-- ARGV[2] expireMillisif (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endreturn 0 解锁脚本（防误删） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerIdif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0endlocal count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)if (count &gt; 0) then return 1else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1end Java 实现（核心代码） WatchDog，实现锁自动续期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import java.util.Collections;import java.util.Map;import java.util.concurrent.*;public class RedisLockWatchDog &#123; /** * WatchDog的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 拥有者是当前线程就续期 */ private static final String WATCHDOG_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; /** * 单线程足够（Redisson 也是） */ private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;redis-lock-watch-dog&quot;); t.setDaemon(true); return t; &#125;); /** * 每个 lockKey 对应一个续期任务 */ private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = new ConcurrentHashMap&lt;&gt;(); public RedisLockWatchDog(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 启动续期 * * @param lockKey Redis 锁 key * @param ownerId uuid:threadId * @param leaseMillis 锁过期时间 */ public void startRenew(String lockKey, String ownerId, long leaseMillis) &#123; // 防止重复启动 if (renewTasks.containsKey(lockKey)) &#123; return; &#125; // 间隔多久续期一次 long period = leaseMillis / 3; ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123; try &#123; renew(lockKey, ownerId, leaseMillis); &#125; catch (Exception e) &#123; // 生产环境建议接日志 &#125; &#125;, period, period, TimeUnit.MILLISECONDS); renewTasks.put(lockKey, future); &#125; /** * 取消续期 */ public void stopRenew(String lockKey) &#123; ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey); if (future != null) &#123; future.cancel(false); &#125; &#125; /** * 实际续期逻辑 */ private void renew(String lockKey, String ownerId, long leaseMillis) &#123; Boolean result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId, String.valueOf(leaseMillis) ); if (!result) &#123; // 锁已不属于当前线程，停止 Watch Dog stopRenew(lockKey); &#125; &#125; /** * 应用关闭时释放资源（可选） */ public void shutdown() &#123; scheduler.shutdown(); &#125;&#125; 锁接口 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.lock;import java.util.concurrent.TimeUnit;public interface DistributedLock &#123; /** * 尝试获取锁 * * @param key 锁的key * @param waitTime 尝试获取锁的最大等待时间 * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit); /** * 尝试获取锁 * 不等待立即返回 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long leaseTime, TimeUnit unit); /** * 获取锁 * 只要获取到锁就返回，否则一直自旋获取锁 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean lock(String key, long leaseTime, TimeUnit unit); /** * 释放锁 * * @param key 锁的key */ void unlock(String key);&#125; 锁实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.UUID;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.LockSupport;@Componentpublic class RedisReentrantLock implements DistributedLock &#123; /** * 锁的key前缀 */ private static final String LOCK_PREFIX = &quot;lock:&quot;; /** * 锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 1.key 不存在时创建锁 * 2.key 存在时判断锁的拥有者是否为当前线程 */ private static final String LOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; /** * 释放锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) */ private static final String UNLOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0 end local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) if (count &gt; 0) then return 1 else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1 end &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; private final RedisLockWatchDog watchDog; private final String uuid = UUID.randomUUID().toString(); public RedisReentrantLock(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; watchDog = new RedisLockWatchDog(redisTemplate); &#125; /** * 获取当前线程的 ownerId * * @return */ private String ownerId() &#123; return uuid + &quot;:&quot; + Thread.currentThread().getId(); &#125; @Override public boolean tryLock(String key, long leaseTime, TimeUnit unit) &#123; String lockKey = LOCK_PREFIX + key; long expireMillis = unit.toMillis(leaseTime); Boolean success = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(LOCK_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId(), String.valueOf(expireMillis) ); if (Boolean.TRUE.equals(success)) &#123;//防止NullPointerException // 启动 Watch Dog（只有在 leaseTime 不确定时） watchDog.startRenew( lockKey, ownerId(), expireMillis ); return true; &#125; return false; &#125; @Override public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) &#123; long deadline = System.currentTimeMillis() + unit.toMillis(waitTime); // 使用带条件的循环，避免重复赋值 while (System.currentTimeMillis() &lt; deadline) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; return false; &#125; @Override public boolean lock(String key, long leaseTime, TimeUnit unit) &#123; // 使用无限循环，语义更清晰 while (true) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; &#125; @Override public void unlock(String key) &#123; String lockKey = LOCK_PREFIX + key; // 先停续期 watchDog.stopRenew(lockKey); // 释放锁 redisTemplate.execute( new DefaultRedisScript&lt;&gt;(UNLOCK_SCRIPT, Long.class), Collections.singletonList(lockKey), ownerId() ); &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example;import com.example.lock.RedisReentrantLock;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;@SpringBootTestpublic class LockTests &#123; @Autowired RedisReentrantLock redisReentrantLock; String lockKey = &quot;order:123&quot;; // 测试获取锁 @Test void demo() &#123; if (redisReentrantLock.tryLock(lockKey, 5, 30, TimeUnit.SECONDS)) &#123; try &#123; // 业务逻辑 doBusiness(); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; // 测试可重入锁 private void doBusiness() &#123; try &#123; if (redisReentrantLock.lock(lockKey, 30, TimeUnit.SECONDS)) &#123; try &#123; System.out.println(&quot;开始执行业务逻辑&quot;); // 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能 TimeUnit.SECONDS.sleep(200); System.out.println(&quot;结束执行业务逻辑&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; // 测试多线程同时获取锁 @Test void demoMultiThread() throws InterruptedException &#123; int threadCount = 5; CountDownLatch latch = new CountDownLatch(threadCount); AtomicInteger successCount = new AtomicInteger(0); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadId = i; new Thread(() -&gt; &#123; try &#123; // 每个线程都尝试获取同一个锁 if (redisReentrantLock.tryLock(lockKey, 10, 30, TimeUnit.SECONDS)) &#123; try &#123; successCount.incrementAndGet(); System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁成功，开始执行业务&quot;); // 模拟业务执行时间 TimeUnit.SECONDS.sleep(3); System.out.println(&quot;线程 &quot; + threadId + &quot; 业务执行完成&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); System.out.println(&quot;线程 &quot; + threadId + &quot; 释放锁&quot;); &#125; &#125; else &#123; System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁失败&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); &#125; &#125;).start(); &#125; // 等待所有线程执行完成 latch.await(); System.out.println(&quot;成功获取锁的线程数: &quot; + successCount.get()); &#125;&#125; Redisson 的锁的使用方法 12345678910111213141516171819RLock lock = redissonClient.getLock(&quot;myLock&quot;);// 传统锁定方式，阻塞等待获取锁// lock.lock();// 或者，获取锁并在10秒后自动解锁// lock.lock(10, TimeUnit.SECONDS);// 或等，尝试在 100 秒内获取锁，获得后在 10 秒后自动解锁boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);if (res) &#123; try &#123; System.out.println(&quot;获取锁成功&quot;); System.out.println(&quot;开始执行业务逻辑&quot;); TimeUnit.SECONDS.sleep(5); &#125; finally &#123; lock.unlock(); &#125;&#125;","summary":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。","date_published":"2025-12-17T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","title":"Redis 命令及数据类型 -- ZSet","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis ZSet 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ZSet-核心详解\">ZSet 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; &#123; member -&gt; score &#125;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">member：唯一，不可重复（String，二进制安全）</span><br><span class=\"line\">score：double 类型，用于排序</span><br><span class=\"line\">集合按 score 从小到大 排序</span><br><span class=\"line\">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSet = Set（去重） + 排序能力</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素唯一</span><br><span class=\"line\">天然有序</span><br><span class=\"line\">支持范围查询</span><br><span class=\"line\">支持排名（rank）</span><br><span class=\"line\">支持按 score 增量更新</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Zset集合操作实现新闻点击排行榜</span></span><br><span class=\"line\">1）点击新闻</span><br><span class=\"line\">ZINCRBY hotNews:20251201 1 news1 <span class=\"comment\"># 点击一次分数 +1</span></span><br><span class=\"line\">2）展示当日点击排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201 0 9 WITHSCORES <span class=\"comment\"># 倒序</span></span><br><span class=\"line\">3）七日搜索榜单计算</span><br><span class=\"line\">ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 <span class=\"comment\"># 合并</span></span><br><span class=\"line\">4）展示七日排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSet 适合 排序 + 查询</span><br><span class=\"line\">score 设计要稳定、可扩展</span><br><span class=\"line\">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class=\"line\">大 ZSet 避免全量遍历</span><br><span class=\"line\">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSet-命令\">ZSet 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForZSet()</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"基础写入-删除-计数\">基础写入 / 删除 / 计数</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素（含 score）</td>\n<td><code>Boolean add(K key, V value, double score)</code></td>\n<td><code>ZADD key score member</code></td>\n<td>新增返回 <code>true</code></td>\n</tr>\n<tr>\n<td>添加元素（仅不存在时）</td>\n<td><code>Boolean addIfAbsent(K key, V value, double score)</code></td>\n<td><code>ZADD key NX score member</code></td>\n<td>Redis ≥ 3.0</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key score member [score member ...]</code></td>\n<td>返回新增数量</td>\n</tr>\n<tr>\n<td>批量添加（仅不存在）</td>\n<td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key NX ...</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>Long remove(K key, Object... values)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>递增 score</td>\n<td><code>Double incrementScore(K key, V value, double delta)</code></td>\n<td><code>ZINCRBY key delta member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小</td>\n<td><code>Long size(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小（同义）</td>\n<td><code>Long zCard(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>API 别名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问\">随机访问</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机获取成员</td>\n<td><code>V randomMember(K key)</code></td>\n<td><code>ZRANDMEMBER key</code></td>\n<td>不返回 score</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n<tr>\n<td>随机获取成员及 score</td>\n<td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td>\n<td><code>ZRANDMEMBER key WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机获取不重复成员及 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>随机获取可重复成员及 score</td>\n<td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"排名-score-查询\">排名 / score 查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取正序排名</td>\n<td><code>Long rank(K key, Object o)</code></td>\n<td><code>ZRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取倒序排名</td>\n<td><code>Long reverseRank(K key, Object o)</code></td>\n<td><code>ZREVRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取 score</td>\n<td><code>Double score(K key, Object o)</code></td>\n<td><code>ZSCORE key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量获取 score</td>\n<td><code>List&lt;Double&gt; score(K key, Object... o)</code></td>\n<td><code>ZMScore key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>score 区间计数</td>\n<td><code>Long count(K key, double min, double max)</code></td>\n<td><code>ZCOUNT key min max</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间查询（rank-score）\">区间查询（rank / score）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 查询</td>\n<td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end</code></td>\n<td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td>\n</tr>\n<tr>\n<td>按 rank 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td>\n<td>按 score 升序分页，返回 member + score</td>\n</tr>\n<tr>\n<td>倒序 rank 查询</td>\n<td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end</code></td>\n<td>按 rank 倒序（高 → 低）</td>\n</tr>\n<tr>\n<td>倒序 rank（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end WITHSCORES</code></td>\n<td>倒序 rank，返回 score</td>\n</tr>\n<tr>\n<td>倒序 score 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min</code></td>\n<td>注意：<strong>max 在前，min 在后</strong></td>\n</tr>\n<tr>\n<td>倒序 score（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td>\n<td>倒序 score，返回 score</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"弹出元素（队列-TopN-场景）\">弹出元素（队列 / TopN 场景）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td>\n<td><code>ZPOPMIN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最小 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td>\n<td><code>ZPOPMIN key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td>\n<td><code>BZPOPMIN key timeout</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td>\n<td><code>ZPOPMAX key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最大 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td>\n<td><code>ZPOPMAX key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td>\n<td><code>BZPOPMAX key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间删除\">区间删除</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 删除</td>\n<td><code>Long removeRange(K key, long start, long end)</code></td>\n<td><code>ZREMRANGEBYRANK key start end</code></td>\n</tr>\n<tr>\n<td>按 score 删除</td>\n<td><code>Long removeRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREMRANGEBYSCORE key min max</code></td>\n</tr>\n<tr>\n<td>按 lex 删除</td>\n<td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td>\n<td><code>ZREMRANGEBYLEX key min max</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合运算（ZSet-特有）\">集合运算（ZSet 特有）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差集</td>\n<td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集</td>\n<td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZINTERSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Lex（字典序，仅-score-相同）\">Lex（字典序，仅 score 相同）</h3>\n<blockquote>\n<p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>\n只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>\n如果 score 不同，Redis 文档明确说明：结果不可预测</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 lex 查询</td>\n<td><code>Set&lt;V&gt; rangeByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td>\n<td>score 必须相同</td>\n</tr>\n<tr>\n<td>倒序 lex 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td>\n<td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>lex 范围存储</td>\n<td><code>Long rangeAndStoreByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>score 范围存储</td>\n<td><code>Long rangeAndStoreByScore(...)</code></td>\n<td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Lex 范围写法规则</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[a</code></td>\n<td>≥ a（包含）</td>\n</tr>\n<tr>\n<td><code>(a</code></td>\n<td>&gt; a（不包含）</td>\n</tr>\n<tr>\n<td><code>[z</code></td>\n<td>≤ z</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>正无穷</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>负无穷</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a ≤ member &lt; d</span></span><br><span class=\"line\">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历\">遍历</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描</td>\n<td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td>\n<td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td>\n<td>推荐替代全量查询</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ ZSet 核心详解 Redis ZSet 是一种 带权重的有序集合，本质结构为： 123456key -&gt; &#123; member -&gt; score &#125;# 说明member：唯一，不可重复（String，二进制安全）score：double 类型，用于排序集合按 score 从小到大 排序score 相同则按 member 的字典序(Lex)排序 ZSet = Set（去重） + 排序能力 ZSet 的核心特性 12345元素唯一天然有序支持范围查询支持排名（rank）支持按 score 增量更新 Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。 ZSet 的应用场景 123456789# Zset集合操作实现新闻点击排行榜1）点击新闻ZINCRBY hotNews:20251201 1 news1 # 点击一次分数 +12）展示当日点击排行前十ZREVRANGE hotNews:20251201 0 9 WITHSCORES # 倒序3）七日搜索榜单计算ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 # 合并4）展示七日排行前十ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES 生产环境建议 12345ZSet 适合 排序 + 查询score 设计要稳定、可扩展定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）大 ZSet 避免全量遍历删除大 ZSet 使用 UNLINK ZSet 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForZSet() 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 基础写入 / 删除 / 计数 方法功能 方法 Redis 原始命令 命令备注 / 推荐替代 添加元素（含 score） Boolean add(K key, V value, double score) ZADD key score member 新增返回 true 添加元素（仅不存在时） Boolean addIfAbsent(K key, V value, double score) ZADD key NX score member Redis ≥ 3.0 批量添加 Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key score member [score member ...] 返回新增数量 批量添加（仅不存在） Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key NX ... — 删除成员 Long remove(K key, Object... values) ZREM key member [member ...] 返回删除数量 递增 score Double incrementScore(K key, V value, double delta) ZINCRBY key delta member — 获取集合大小 Long size(K key) ZCARD key — 获取集合大小（同义） Long zCard(K key) ZCARD key API 别名 随机访问 方法功能 方法 Redis 原始命令 命令备注 随机获取成员 V randomMember(K key) ZRANDMEMBER key 不返回 score 随机获取不重复成员 Set&lt;V&gt; distinctRandomMembers(K key, long count) ZRANDMEMBER key count count &gt; 0 随机获取可重复成员 List&lt;V&gt; randomMembers(K key, long count) ZRANDMEMBER key -count count &lt; 0 随机获取成员及 score TypedTuple&lt;V&gt; randomMemberWithScore(K key) ZRANDMEMBER key WITHSCORES Redis ≥ 6.2 随机获取不重复成员及 score Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count) ZRANDMEMBER key count WITHSCORES — 随机获取可重复成员及 score List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count) ZRANDMEMBER key -count WITHSCORES — 排名 / score 查询 方法功能 方法 Redis 原始命令 备注 获取正序排名 Long rank(K key, Object o) ZRANK key member 从 0 开始 获取倒序排名 Long reverseRank(K key, Object o) ZREVRANK key member 从 0 开始 获取 score Double score(K key, Object o) ZSCORE key member — 批量获取 score List&lt;Double&gt; score(K key, Object... o) ZMScore key member [member ...] Redis ≥ 6.2 score 区间计数 Long count(K key, double min, double max) ZCOUNT key min max — 区间查询（rank / score） 方法功能 方法 Redis 原始命令 备注 按 rank 查询 Set&lt;V&gt; range(K key, long start, long end) ZRANGE key start end 正序rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始） 按 rank 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end) ZRANGE key start end WITHSCORES — 按 score 查询 Set&lt;V&gt; rangeByScore(K key, double min, double max) ZRANGEBYSCORE key min max — 按 score 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max) ZRANGEBYSCORE key min max WITHSCORES — score 分页 Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max LIMIT offset count — score 分页（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count 按 score 升序分页，返回 member + score 倒序 rank 查询 Set&lt;V&gt; reverseRange(K key, long start, long end) ZREVRANGE key start end 按 rank 倒序（高 → 低） 倒序 rank（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end) ZREVRANGE key start end WITHSCORES 倒序 rank，返回 score 倒序 score 查询 Set&lt;V&gt; reverseRangeByScore(K key, double min, double max) ZREVRANGEBYSCORE key max min 注意：max 在前，min 在后 倒序 score（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max) ZREVRANGEBYSCORE key max min WITHSCORES 倒序 score，返回 score 弹出元素（队列 / TopN 场景） 方法功能 方法 Redis 原始命令 备注 弹出最小 score TypedTuple&lt;V&gt; popMin(K key) ZPOPMIN key — 批量弹出最小 score Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count) ZPOPMIN key count — 阻塞弹出最小 score TypedTuple&lt;V&gt; popMin(K key, timeout) BZPOPMIN key timeout — 弹出最大 score TypedTuple&lt;V&gt; popMax(K key) ZPOPMAX key — 批量弹出最大 score Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count) ZPOPMAX key count — 阻塞弹出最大 score TypedTuple&lt;V&gt; popMax(K key, timeout) BZPOPMAX key timeout — 区间删除 方法功能 方法 Redis 原始命令（完整） 按 rank 删除 Long removeRange(K key, long start, long end) ZREMRANGEBYRANK key start end 按 score 删除 Long removeRangeByScore(K key, double min, double max) ZREMRANGEBYSCORE key min max 按 lex 删除 Long removeRangeByLex(K key, Range&lt;String&gt; range) ZREMRANGEBYLEX key min max 集合运算（ZSet 特有） 方法功能 方法 Redis 原始命令（完整） 备注 差集 Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] Redis ≥ 6.2 差集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 差集并存储 Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZDIFFSTORE destination numkeys key [otherKey ...] Redis ≥ 6.2 交集 Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] Redis ≥ 6.2 交集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 并集 Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] Redis ≥ 6.2 并集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 交集并存储 Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZINTERSTORE destination numkeys key [key ...] 并集并存储 Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZUNIONSTORE destination numkeys key [key ...] Lex（字典序，仅 score 相同） Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。 只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义 如果 score 不同，Redis 文档明确说明：结果不可预测 方法功能 方法 Redis 原始命令（完整） 备注 按 lex 查询 Set&lt;V&gt; rangeByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] score 必须相同 倒序 lex 查询 Set&lt;V&gt; reverseRangeByLex(...) ZREVRANGEBYLEX key max min [LIMIT offset count] — lex 范围存储 Long rangeAndStoreByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey Spring 封装 score 范围存储 Long rangeAndStoreByScore(...) ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey Spring 封装 Lex 范围写法规则 写法 含义 [a ≥ a（包含） (a &gt; a（不包含） [z ≤ z + 正无穷 - 负无穷 示例 12# a ≤ member &lt; dZRANGEBYLEX my:zset [a (d 遍历 方法功能 方法 Redis 原始命令（完整） 备注 游标扫描 Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options) ZSCAN key cursor [MATCH pattern] [COUNT count] 推荐替代全量查询","summary":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","title":"Redis 命令及数据类型 -- Set","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Set 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Set-核心详解\">Set 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 是一个无序、不重复元素集合，本质上是：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Set&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素唯一（自动去重）</span><br><span class=\"line\">无顺序（不保证插入顺序）</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Set 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动去重</span><br><span class=\"line\">高效成员判断</span><br><span class=\"line\">支持集合运算</span><br><span class=\"line\">操作原子性强</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Set 应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 微信抽奖小程序</span></span><br><span class=\"line\">1）点击参与抽奖加入集合</span><br><span class=\"line\">SADD key &#123;userlD&#125;</span><br><span class=\"line\">2）查看参与抽奖所有用户</span><br><span class=\"line\">SMEMBERS key</span><br><span class=\"line\">3）抽取count名中奖者</span><br><span class=\"line\">SRANDMEMBER key [count] / SPOP key [count]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信微博点赞，收藏，标签</span></span><br><span class=\"line\">1) 点赞</span><br><span class=\"line\">SADD like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">2) 取消点赞</span><br><span class=\"line\">SREM like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">3) 检查用户是否点过赞</span><br><span class=\"line\">SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">4) 获取点赞的用户列表</span><br><span class=\"line\">SMEMBERS like:&#123;消息ID&#125;</span><br><span class=\"line\">5) 获取点赞用户数</span><br><span class=\"line\">SCARD like:&#123;消息ID&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集合操作</span></span><br><span class=\"line\"><span class=\"comment\"># 交集：多个集合中同时存在的元素</span></span><br><span class=\"line\">SINTER set1 set2 set3 -&gt; &#123; c &#125; <span class=\"comment\"># 交集，共同关注 / 共同好友 / 共同兴趣</span></span><br><span class=\"line\"><span class=\"comment\"># 并集：存在于任意一个集合中的元素</span></span><br><span class=\"line\">SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; <span class=\"comment\"># 多来源合并后的用户全集</span></span><br><span class=\"line\"><span class=\"comment\"># 差集：只存在于第一个集合中的元素</span></span><br><span class=\"line\">SDIFF set1 set2 set3 -&gt; &#123;a&#125; <span class=\"comment\"># 差集，推荐好友</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 适合 成员资格判断</span><br><span class=\"line\">始终控制成员规模</span><br><span class=\"line\">大 Set 遍历使用 SSCAN</span><br><span class=\"line\">集合运算放在离线或低频场景</span><br><span class=\"line\">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"Set-命令\">Set 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForSet()</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"写操作（增-删-移动）\">写操作（增 / 删 / 移动）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>向集合添加元素</td>\n<td><code>add(K key, V... values)</code></td>\n<td><code>SADD key member [member ...]</code></td>\n<td>返回新增成员数量</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"移除-弹出成员\">移除 / 弹出成员</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从集合移除元素</td>\n<td><code>remove(K key, Object... values)</code></td>\n<td><code>SREM key member [member ...]</code></td>\n<td>返回移除成员数量</td>\n</tr>\n<tr>\n<td>随机弹出一个元素</td>\n<td><code>pop(K key)</code></td>\n<td><code>SPOP key</code></td>\n<td>随机且删除</td>\n</tr>\n<tr>\n<td>随机弹出多个元素</td>\n<td><code>pop(K key, long count)</code></td>\n<td><code>SPOP key count</code></td>\n<td>Redis ≥ 3.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员移动（原子）\">成员移动（原子）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>将成员移动到其他集合</td>\n<td><code>move(K key, V value, K destKey)</code></td>\n<td><code>SMOVE source dest member</code></td>\n<td>原子操作</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合大小\">集合大小</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取集合大小</td>\n<td><code>size(K key)</code></td>\n<td><code>SCARD key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员存在性判断\">成员存在性判断</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>判断是否是成员</td>\n<td><code>isMember(K key, Object o)</code></td>\n<td><code>SISMEMBER key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量判断成员是否存在</td>\n<td><code>isMember(K key, Object... objects)</code></td>\n<td><code>SMISMEMBER key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"交集（Intersection）\">交集（Intersection）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, K otherKey)</code></td>\n<td><code>SINTER key key</code></td>\n<td>O(N × M)</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(Collection&lt;K&gt; keys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SINTERSTORE dest key key</code></td>\n<td>返回结果数量</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"并集（Union）\">并集（Union）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, K otherKey)</code></td>\n<td><code>SUNION key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(Collection&lt;K&gt; keys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"差集（Difference）\">差集（Difference）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, K otherKey)</code></td>\n<td><code>SDIFF key key</code></td>\n<td>key 顺序影响结果</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(Collection&lt;K&gt; keys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全量-随机读取\">全量 / 随机读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取所有成员</td>\n<td><code>members(K key)</code></td>\n<td><code>SMEMBERS key</code></td>\n<td>大集合慎用</td>\n</tr>\n<tr>\n<td>随机获取一个成员</td>\n<td><code>randomMember(K key)</code></td>\n<td><code>SRANDMEMBER key</code></td>\n<td>不删除</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>distinctRandomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>randomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"游标扫描（大集合推荐）\">游标扫描（大集合推荐）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描成员</td>\n<td><code>scan(K key, ScanOptions options)</code></td>\n<td><code>SSCAN key cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>SMEMBERS</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Set 核心详解 Redis Set 是一个无序、不重复元素集合，本质上是： 12345key -&gt; Set&lt;String&gt;# 说明元素唯一（自动去重）无顺序（不保证插入顺序）元素类型为 String（二进制安全） Set 的核心特性 1234自动去重高效成员判断支持集合运算操作原子性强 Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Set 应用场景 12345678910111213141516171819202122232425262728# 微信抽奖小程序1）点击参与抽奖加入集合SADD key &#123;userlD&#125;2）查看参与抽奖所有用户SMEMBERS key3）抽取count名中奖者SRANDMEMBER key [count] / SPOP key [count]# 微信微博点赞，收藏，标签1) 点赞SADD like:&#123;消息ID&#125; &#123;用户ID&#125;2) 取消点赞SREM like:&#123;消息ID&#125; &#123;用户ID&#125;3) 检查用户是否点过赞SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;4) 获取点赞的用户列表SMEMBERS like:&#123;消息ID&#125;5) 获取点赞用户数SCARD like:&#123;消息ID&#125;# 集合操作# 交集：多个集合中同时存在的元素SINTER set1 set2 set3 -&gt; &#123; c &#125; # 交集，共同关注 / 共同好友 / 共同兴趣# 并集：存在于任意一个集合中的元素SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; # 多来源合并后的用户全集# 差集：只存在于第一个集合中的元素SDIFF set1 set2 set3 -&gt; &#123;a&#125; # 差集，推荐好友 生产环境建议 12345Set 适合 成员资格判断始终控制成员规模大 Set 遍历使用 SSCAN集合运算放在离线或低频场景删除大 Set 使用 UNLINK Set 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForSet() 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 写操作（增 / 删 / 移动） 方法功能 方法 Redis 原始命令 备注 向集合添加元素 add(K key, V... values) SADD key member [member ...] 返回新增成员数量 移除 / 弹出成员 方法功能 方法 Redis 原始命令 备注 从集合移除元素 remove(K key, Object... values) SREM key member [member ...] 返回移除成员数量 随机弹出一个元素 pop(K key) SPOP key 随机且删除 随机弹出多个元素 pop(K key, long count) SPOP key count Redis ≥ 3.2 成员移动（原子） 方法功能 方法 Redis 原始命令 备注 将成员移动到其他集合 move(K key, V value, K destKey) SMOVE source dest member 原子操作 集合大小 方法功能 方法 Redis 原始命令 备注 获取集合大小 size(K key) SCARD key — 成员存在性判断 方法功能 方法 Redis 原始命令 备注 判断是否是成员 isMember(K key, Object o) SISMEMBER key member — 批量判断成员是否存在 isMember(K key, Object... objects) SMISMEMBER key member [member ...] Redis ≥ 6.2 交集（Intersection） 方法功能 方法 Redis 原始命令 备注 计算交集 intersect(K key, K otherKey) SINTER key key O(N × M) 计算交集 intersect(K key, Collection&lt;K&gt; otherKeys) SINTER key [key ...] — 计算交集 intersect(Collection&lt;K&gt; keys) SINTER key [key ...] — 交集并存储 intersectAndStore(K key, K otherKey, K destKey) SINTERSTORE dest key key 返回结果数量 交集并存储 intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SINTERSTORE dest key [key ...] — 交集并存储 intersectAndStore(Collection&lt;K&gt; keys, K destKey) SINTERSTORE dest key [key ...] — 并集（Union） 方法功能 方法 Redis 原始命令 备注 计算并集 union(K key, K otherKey) SUNION key key — 计算并集 union(K key, Collection&lt;K&gt; otherKeys) SUNION key [key ...] — 计算并集 union(Collection&lt;K&gt; keys) SUNION key [key ...] — 并集并存储 unionAndStore(K key, K otherKey, K destKey) SUNIONSTORE dest key key — 并集并存储 unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SUNIONSTORE dest key [key ...] — 并集并存储 unionAndStore(Collection&lt;K&gt; keys, K destKey) SUNIONSTORE dest key [key ...] — 差集（Difference） 方法功能 方法 Redis 原始命令 备注 计算差集 difference(K key, K otherKey) SDIFF key key key 顺序影响结果 计算差集 difference(K key, Collection&lt;K&gt; otherKeys) SDIFF key [key ...] — 计算差集 difference(Collection&lt;K&gt; keys) SDIFF key [key ...] — 差集并存储 differenceAndStore(K key, K otherKey, K destKey) SDIFFSTORE dest key key — 差集并存储 differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SDIFFSTORE dest key [key ...] — 差集并存储 differenceAndStore(Collection&lt;K&gt; keys, K destKey) SDIFFSTORE dest key [key ...] — 全量 / 随机读取 方法功能 方法 Redis 原始命令 备注 获取所有成员 members(K key) SMEMBERS key 大集合慎用 随机获取一个成员 randomMember(K key) SRANDMEMBER key 不删除 随机获取不重复成员 distinctRandomMembers(K key, long count) SRANDMEMBER key count count &gt; 0 随机获取可重复成员 randomMembers(K key, long count) SRANDMEMBER key -count count &lt; 0 游标扫描（大集合推荐） 方法功能 方法 Redis 原始命令 备注 游标扫描成员 scan(K key, ScanOptions options) SSCAN key cursor [MATCH] [COUNT] 推荐替代 SMEMBERS","summary":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:38:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","title":"Redis 命令及数据类型 -- List","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis List 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"List-核心详解\">List 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 是一个有序字符串列表，本质上是:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; List&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素按插入顺序排列</span><br><span class=\"line\">允许重复元素</span><br><span class=\"line\">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>List 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有序</span><br><span class=\"line\">可重复</span><br><span class=\"line\">双端操作（Deque）</span><br><span class=\"line\">支持阻塞读</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差</p>\n</li>\n<li class=\"lvl-2\">\n<p>常用数据结构</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(栈) = LPUSH + LPOP</span><br><span class=\"line\">Queue(队列）= LPUSH + RPOP</span><br><span class=\"line\">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>List 的使用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">视频列表、签到列表</span><br><span class=\"line\">排队机</span><br><span class=\"line\">简化版的MQ</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List 只用于 顺序消费</span><br><span class=\"line\">始终限制 List 长度（LTRIM）</span><br><span class=\"line\">避免中间插入、删除</span><br><span class=\"line\">大 List 删除使用 UNLINK</span><br><span class=\"line\">高可靠消息不要用 List</span><br></pre></td></tr></table></figure>\n<h2 id=\"List-命令\">List 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForList()</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"区间访问与整体控制\">区间访问与整体控制</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定区间元素</td>\n<td><code>range(K key, long start, long end)</code></td>\n<td><code>LRANGE key start end</code></td>\n<td><code>end = -1</code> 表示到末尾</td>\n</tr>\n<tr>\n<td>裁剪 list，仅保留指定区间</td>\n<td><code>trim(K key, long start, long end)</code></td>\n<td><code>LTRIM key start end</code></td>\n<td><strong>原地修改</strong></td>\n</tr>\n<tr>\n<td>获取 list 长度</td>\n<td><code>size(K key)</code></td>\n<td><code>LLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📌 使用建议</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>LRANGE 0 -1</code> 等价全量读取，小 list 可用</li>\n<li class=\"lvl-6\">大 list 建议分页 + LRANGE</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"左侧入队（Head）\">左侧入队（Head）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧插入一个元素</td>\n<td><code>leftPush(K key, V value)</code></td>\n<td><code>LPUSH key value</code></td>\n<td>返回插入后长度</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>leftPushAll(K key, V... values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>依次从左插入</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>leftPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时左侧插入</td>\n<td><code>leftPushIfPresent(K key, V value)</code></td>\n<td><code>LPUSHX key value</code></td>\n<td>key 不存在不执行</td>\n</tr>\n<tr>\n<td>在 pivot 左侧插入</td>\n<td><code>leftPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key BEFORE pivot value</code></td>\n<td>pivot 不存在返回 <code>-1</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"右侧入队（Tail）\">右侧入队（Tail）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>右侧插入一个元素</td>\n<td><code>rightPush(K key, V value)</code></td>\n<td><code>RPUSH key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>rightPushAll(K key, V... values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>rightPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时右侧插入</td>\n<td><code>rightPushIfPresent(K key, V value)</code></td>\n<td><code>RPUSHX key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>在 pivot 右侧插入</td>\n<td><code>rightPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key AFTER pivot value</code></td>\n<td>pivot 不存在返回 <code>-1</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"非阻塞弹出\">非阻塞弹出</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧弹出</td>\n<td><code>leftPop(K key)</code></td>\n<td><code>LPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>左侧批量弹出</td>\n<td><code>leftPop(K key, long count)</code></td>\n<td><code>LPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>右侧弹出</td>\n<td><code>rightPop(K key)</code></td>\n<td><code>RPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量弹出</td>\n<td><code>rightPop(K key, long count)</code></td>\n<td><code>RPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"阻塞弹出（Blocking-Queue）\">阻塞弹出（Blocking Queue）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧阻塞弹出</td>\n<td><code>leftPop(K key, timeout)</code></td>\n<td><code>BLPOP key timeout</code></td>\n<td>队列为空时阻塞</td>\n</tr>\n<tr>\n<td>右侧阻塞弹出</td>\n<td><code>rightPop(K key, timeout)</code></td>\n<td><code>BRPOP key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📌 典型场景：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">消息队列 / 任务队列</li>\n<li class=\"lvl-6\">简单生产者-消费者模型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原子移动\">原子移动</h3>\n<blockquote>\n<p>Redis 6.2+ 新模型（统一、可读性更强）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>原子移动（非阻塞）</td>\n<td><code>move(sourceKey, from, destinationKey, to)</code></td>\n<td><code>LMOVE source dest LEFT|RIGHT LEFT|RIGHT</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>原子移动（阻塞）</td>\n<td><code>move(sourceKey, from, destinationKey, to, timeout)</code></td>\n<td><code>BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语义说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">从 sourceKey 的一端 POP</li>\n<li class=\"lvl-6\">向 destinationKey 的一端 PUSH</li>\n<li class=\"lvl-6\">整个过程 原子性保证</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>命令参数说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">source:源 List（从这里取一个元素）</li>\n<li class=\"lvl-6\">dest:目标 List（往这里放一个元素）</li>\n<li class=\"lvl-6\">第一个 LEFT/RIGHT:从 source 的哪一端弹出元素</li>\n<li class=\"lvl-6\">第二个 LEFT/RIGHT:从 dest 的哪一端插入元素</li>\n<li class=\"lvl-6\">timeout: 阻塞时间\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。</li>\n<li class=\"lvl-10\">timeout = 0：无限期阻塞，直到有数据可用或连接断开</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>旧命令（即将废弃）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>右弹左插</td>\n<td><code>rightPopAndLeftPush(...)</code></td>\n<td><code>RPOPLPUSH</code></td>\n<td><code>LMOVE</code></td>\n</tr>\n<tr>\n<td>阻塞右弹左插</td>\n<td><code>rightPopAndLeftPush(..., timeout)</code></td>\n<td><code>BRPOPLPUSH</code></td>\n<td><code>BLMOVE</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问与定位（O-N-）\">随机访问与定位（O(N)）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取第一个元素</td>\n<td><code>getFirst(K key)</code></td>\n<td><code>LINDEX key 0</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取最后一个元素</td>\n<td><code>getLast(K key)</code></td>\n<td><code>LINDEX key -1</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取指定索引元素</td>\n<td><code>index(K key, long index)</code></td>\n<td><code>LINDEX key index</code></td>\n<td>O(N)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取</p>\n</blockquote>\n<h3 id=\"搜索与删除\">搜索与删除</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除指定值</td>\n<td><code>remove(K key, long count, Object value)</code></td>\n<td><code>LREM key count value</code></td>\n<td>count &gt;0 从左，&lt;0 从右</td>\n</tr>\n<tr>\n<td>获取首次出现位置</td>\n<td><code>indexOf(K key, V value)</code></td>\n<td><code>LPOS key value</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n<tr>\n<td>获取最后出现位置</td>\n<td><code>lastIndexOf(K key, V value)</code></td>\n<td><code>LPOS key value RANK -1</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"List-的典型使用模式总结\">List 的典型使用模式总结</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>队列（FIFO）</td>\n<td><code>RPUSH + LPOP</code></td>\n</tr>\n<tr>\n<td>栈（LIFO）</td>\n<td><code>LPUSH + LPOP</code></td>\n</tr>\n<tr>\n<td>阻塞队列</td>\n<td><code>BLPOP / BRPOP</code></td>\n</tr>\n<tr>\n<td>可靠队列</td>\n<td><code>LMOVE / BLMOVE</code></td>\n</tr>\n<tr>\n<td>消息转移</td>\n<td><code>LMOVE source dest</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ List 核心详解 Redis List 是一个有序字符串列表，本质上是: 12345key -&gt; List&lt;String&gt;# 说明元素按插入顺序排列允许重复元素支持从 左（头） 和 右（尾） 两端操作 List 的核心特性 12345有序可重复双端操作（Deque）支持阻塞读元素类型为 String（二进制安全） Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差 常用数据结构 123Stack(栈) = LPUSH + LPOPQueue(队列）= LPUSH + RPOPBlocking MQ(阻塞队列）= LPUSH + BRPOP List 的使用场景 123视频列表、签到列表排队机简化版的MQ 生产环境建议 12345List 只用于 顺序消费始终限制 List 长度（LTRIM）避免中间插入、删除大 List 删除使用 UNLINK高可靠消息不要用 List List 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForList() 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 区间访问与整体控制 方法功能 方法 Redis 原始命令 备注 获取指定区间元素 range(K key, long start, long end) LRANGE key start end end = -1 表示到末尾 裁剪 list，仅保留指定区间 trim(K key, long start, long end) LTRIM key start end 原地修改 获取 list 长度 size(K key) LLEN key — 📌 使用建议 LRANGE 0 -1 等价全量读取，小 list 可用 大 list 建议分页 + LRANGE 左侧入队（Head） 方法功能 方法 Redis 原始命令 备注 左侧插入一个元素 leftPush(K key, V value) LPUSH key value 返回插入后长度 左侧批量插入 leftPushAll(K key, V... values) LPUSH key value [value ...] 依次从左插入 左侧批量插入 leftPushAll(K key, Collection&lt;V&gt; values) LPUSH key value [value ...] — key 存在时左侧插入 leftPushIfPresent(K key, V value) LPUSHX key value key 不存在不执行 在 pivot 左侧插入 leftPush(K key, V pivot, V value) LINSERT key BEFORE pivot value pivot 不存在返回 -1 右侧入队（Tail） 方法功能 方法 Redis 原始命令 备注 右侧插入一个元素 rightPush(K key, V value) RPUSH key value — 右侧批量插入 rightPushAll(K key, V... values) RPUSH key value [value ...] — 右侧批量插入 rightPushAll(K key, Collection&lt;V&gt; values) RPUSH key value [value ...] — key 存在时右侧插入 rightPushIfPresent(K key, V value) RPUSHX key value — 在 pivot 右侧插入 rightPush(K key, V pivot, V value) LINSERT key AFTER pivot value pivot 不存在返回 -1 非阻塞弹出 方法功能 方法 Redis 原始命令 备注 左侧弹出 leftPop(K key) LPOP key — 左侧批量弹出 leftPop(K key, long count) LPOP key count Redis ≥ 6.2 右侧弹出 rightPop(K key) RPOP key — 右侧批量弹出 rightPop(K key, long count) RPOP key count Redis ≥ 6.2 阻塞弹出（Blocking Queue） 方法功能 方法 Redis 原始命令 备注 左侧阻塞弹出 leftPop(K key, timeout) BLPOP key timeout 队列为空时阻塞 右侧阻塞弹出 rightPop(K key, timeout) BRPOP key timeout — 📌 典型场景： 消息队列 / 任务队列 简单生产者-消费者模型 原子移动 Redis 6.2+ 新模型（统一、可读性更强） 方法功能 方法 Redis 原始命令 备注 原子移动（非阻塞） move(sourceKey, from, destinationKey, to) LMOVE source dest LEFT|RIGHT LEFT|RIGHT Redis ≥ 6.2 原子移动（阻塞） move(sourceKey, from, destinationKey, to, timeout) BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout Redis ≥ 6.2 语义说明 从 sourceKey 的一端 POP 向 destinationKey 的一端 PUSH 整个过程 原子性保证 命令参数说明： source:源 List（从这里取一个元素） dest:目标 List（往这里放一个元素） 第一个 LEFT/RIGHT:从 source 的哪一端弹出元素 第二个 LEFT/RIGHT:从 dest 的哪一端插入元素 timeout: 阻塞时间 当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。 timeout = 0：无限期阻塞，直到有数据可用或连接断开 旧命令（即将废弃） 方法功能 方法 Redis 原始命令 推荐替代 右弹左插 rightPopAndLeftPush(...) RPOPLPUSH LMOVE 阻塞右弹左插 rightPopAndLeftPush(..., timeout) BRPOPLPUSH BLMOVE 随机访问与定位（O(N)） 方法功能 方法 Redis 原始命令 备注 获取第一个元素 getFirst(K key) LINDEX key 0 O(N) 获取最后一个元素 getLast(K key) LINDEX key -1 O(N) 获取指定索引元素 index(K key, long index) LINDEX key index O(N) ⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取 搜索与删除 方法功能 方法 Redis 原始命令 备注 删除指定值 remove(K key, long count, Object value) LREM key count value count &gt;0 从左，&lt;0 从右 获取首次出现位置 indexOf(K key, V value) LPOS key value Redis ≥ 6.0 获取最后出现位置 lastIndexOf(K key, V value) LPOS key value RANK -1 Redis ≥ 6.0 List 的典型使用模式总结 场景 推荐方式 队列（FIFO） RPUSH + LPOP 栈（LIFO） LPUSH + LPOP 阻塞队列 BLPOP / BRPOP 可靠队列 LMOVE / BLMOVE 消息转移 LMOVE source dest","summary":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:35:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","title":"Redis 命令及数据类型 -- Hash","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hash 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hash-核心详解\">Hash 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Map&lt;String, String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">key：Redis 的键（只能是 String）</span><br><span class=\"line\">field：Hash 内的字段名（String）</span><br><span class=\"line\">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">适合存储对象型数据</span><br><span class=\"line\">支持 字段级别读写</span><br><span class=\"line\">所有操作均为 原子性</span><br><span class=\"line\">内存效率优于「String + JSON」</span><br><span class=\"line\">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 的使用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对象缓存</span></span><br><span class=\"line\">HSET user:1 name zhangsan age 20</span><br><span class=\"line\"><span class=\"comment\"># 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为value</span></span><br><span class=\"line\">HSET cart:userId commodity:1001 1 commodity:1002 5</span><br><span class=\"line\"><span class=\"comment\"># 分布式锁，一个命令搞不定，需要结合Lua脚本</span></span><br><span class=\"line\">HINCRBY lock uuid:threadId 1 <span class=\"comment\"># 创建锁 或 重入+1</span></span><br><span class=\"line\">EXPIRE lock 30 <span class=\"comment\"># 30 秒后自动释放锁</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash结构优缺点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">• 优点</span><br><span class=\"line\">1）同类数据聚合存储，适合表达对象模型，便于管理与维护</span><br><span class=\"line\">2）相比 string 操作消耗内存与 CPU 更小</span><br><span class=\"line\">    a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销</span><br><span class=\"line\">    b.Hash 过大时（BigHash）优势消失</span><br><span class=\"line\">3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销</span><br><span class=\"line\">• 缺点</span><br><span class=\"line\">1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持</span><br><span class=\"line\">```bash</span><br><span class=\"line\"><span class=\"comment\"># user:1 这个 Hash 不会过期</span></span><br><span class=\"line\">HSET user:1 name <span class=\"string\">&quot;Tom&quot;</span> age 18</span><br><span class=\"line\"><span class=\"comment\"># HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 只有 name field 60 秒后自动删除</span></span><br><span class=\"line\">HEXPIRE user:1 60 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 同时给多个 field 设置过期时间</span></span><br><span class=\"line\">HEXPIRE user:1 60 FIELDS 2 name age</span><br><span class=\"line\"><span class=\"comment\"># 使用毫秒级过期（HPEXPIRE）</span></span><br><span class=\"line\"><span class=\"comment\"># HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPEXPIRE user:1 60 FIELDS 2 name age</span><br><span class=\"line\"><span class=\"comment\"># 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class=\"line\"><span class=\"comment\"># HTTL key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HTTL user:1 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class=\"line\"><span class=\"comment\"># HPTTL key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPTTL user:1 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 移出过期时间</span></span><br><span class=\"line\"><span class=\"comment\"># HPERSIST key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPERSIST user:1 FIELDS 1 name</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个 Hash = 一个对象</span><br><span class=\"line\">field 数量建议 &lt; 100</span><br><span class=\"line\">单 field value 建议 &lt; 1 KB</span><br><span class=\"line\">大对象拆分为多个 Hash</span><br><span class=\"line\">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hash-命令\">Hash 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForHash()</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"写入-更新\">写入 / 更新</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置单个 field-value</td>\n<td><code>put(H key, HK hashKey, HV value)</code></td>\n<td><code>HSET key field value</code></td>\n<td>新增或覆盖</td>\n</tr>\n<tr>\n<td>批量设置 field-value</td>\n<td><code>putAll(H key, Map&lt;HK,HV&gt; m)</code></td>\n<td><code>HSET key field value [field value ...]</code></td>\n<td><code>HMSET</code> 已废弃</td>\n</tr>\n<tr>\n<td>field 不存在时设置</td>\n<td><code>putIfAbsent(H key, HK hashKey, HV value)</code></td>\n<td><code>HSETNX key field value</code></td>\n<td>原子操作</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"读取\">读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定 field 的值</td>\n<td><code>get(H key, Object hashKey)</code></td>\n<td><code>HGET key field</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n<tr>\n<td>批量获取多个 field</td>\n<td><code>multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HMGET key field [field ...]</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n<tr>\n<td>获取所有 value</td>\n<td><code>values(H key)</code></td>\n<td><code>HVALS key</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取所有 field-value</td>\n<td><code>entries(H key)</code></td>\n<td><code>HGETALL key</code></td>\n<td><strong>生产环境慎用</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"删除-存在性判断\">删除 / 存在性判断</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除一个或多个 field</td>\n<td><code>delete(H key, Object... hashKeys)</code></td>\n<td><code>HDEL key field [field ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>判断 field 是否存在</td>\n<td><code>hasKey(H key, Object hashKey)</code></td>\n<td><code>HEXISTS key field</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"计数与数值运算\">计数与数值运算</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>field 整数自增</td>\n<td><code>increment(H key, HK hashKey, long delta)</code></td>\n<td><code>HINCRBY key field increment</code></td>\n<td>value 必须是整数</td>\n</tr>\n<tr>\n<td>field 浮点数自增</td>\n<td><code>increment(H key, HK hashKey, double delta)</code></td>\n<td><code>HINCRBYFLOAT key field increment</code></td>\n<td>Redis ≥ 2.6</td>\n</tr>\n<tr>\n<td>获取 field 对应 value 长度</td>\n<td><code>lengthOfValue(H key, HK hashKey)</code></td>\n<td><code>HSTRLEN key field</code></td>\n<td>不存在返回 0</td>\n</tr>\n<tr>\n<td>获取 hash 中 field 数量</td>\n<td><code>size(H key)</code></td>\n<td><code>HLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问（Random-Access）\">随机访问（Random Access）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机返回一个 field</td>\n<td><code>randomKey(H key)</code></td>\n<td><code>HRANDFIELD key</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回一个 field-value</td>\n<td><code>randomEntry(H key)</code></td>\n<td><code>HRANDFIELD key WITHVALUES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回多个 field</td>\n<td><code>randomKeys(H key, long count)</code></td>\n<td><code>HRANDFIELD key count</code></td>\n<td>count &lt; 0 可重复</td>\n</tr>\n<tr>\n<td>随机返回多个 field-value</td>\n<td><code>randomEntries(H key, long count)</code></td>\n<td><code>HRANDFIELD key count WITHVALUES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"遍历与扫描（推荐方式）\">遍历与扫描（推荐方式）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取所有 field</td>\n<td><code>keys(H key)</code></td>\n<td><code>HKEYS key</code></td>\n<td>O(N)，大 hash 慎用</td>\n</tr>\n<tr>\n<td>游标扫描 hash</td>\n<td><code>scan(H key, ScanOptions options)</code></td>\n<td><code>HSCAN key cursor [MATCH] [COUNT]</code></td>\n<td><strong>推荐替代 <code>HGETALL</code></strong></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>📌 最佳实践</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">小 hash：HGETALL</li>\n<li class=\"lvl-6\">大 hash / 线上系统：HSCAN</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hash-Field-级别过期（Redis-7-4-）\">Hash Field 级别过期（Redis 7.4+）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强</p>\n</li>\n<li class=\"lvl-2\">\n<p>设置过期</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>为指定 field 设置过期时间</td>\n<td><code>expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE key seconds FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n<tr>\n<td>为指定 field 设置过期时间点</td>\n<td><code>expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n<tr>\n<td>高级过期策略</td>\n<td><code>expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE / HEXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>移除过期时间</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移除指定 field 的过期时间</td>\n<td><code>persist(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HPERSIST key FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hash 核心详解 Redis Hash 是一种 key → field → value 的数据结构，本质上是 12345key -&gt; Map&lt;String, String&gt;# 说明key：Redis 的键（只能是 String）field：Hash 内的字段名（String）value：字段值（String，二进制安全） Hash 的核心特性 12345适合存储对象型数据支持 字段级别读写所有操作均为 原子性内存效率优于「String + JSON」单个 Hash 理论最大 512 MB Hash 的使用场景 1234567# 对象缓存HSET user:1 name zhangsan age 20# 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为valueHSET cart:userId commodity:1001 1 commodity:1002 5# 分布式锁，一个命令搞不定，需要结合Lua脚本HINCRBY lock uuid:threadId 1 # 创建锁 或 重入+1EXPIRE lock 30 # 30 秒后自动释放锁 Hash结构优缺点 12345678910111213141516171819202122232425262728• 优点1）同类数据聚合存储，适合表达对象模型，便于管理与维护2）相比 string 操作消耗内存与 CPU 更小 a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销 b.Hash 过大时（BigHash）优势消失3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销• 缺点1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持```bash# user:1 这个 Hash 不会过期HSET user:1 name &quot;Tom&quot; age 18# HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]# 只有 name field 60 秒后自动删除HEXPIRE user:1 60 FIELDS 1 name# 同时给多个 field 设置过期时间HEXPIRE user:1 60 FIELDS 2 name age# 使用毫秒级过期（HPEXPIRE）# HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]HPEXPIRE user:1 60 FIELDS 2 name age# 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期# HTTL key FIELDS numfields field [field ...]HTTL user:1 FIELDS 1 name# 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期# HPTTL key FIELDS numfields field [field ...]HPTTL user:1 FIELDS 1 name# 移出过期时间# HPERSIST key FIELDS numfields field [field ...]HPERSIST user:1 FIELDS 1 name 在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。 生产环境建议 12345一个 Hash = 一个对象field 数量建议 &lt; 100单 field value 建议 &lt; 1 KB大对象拆分为多个 Hash避免在大 Hash 上使用 HGETALL Hash 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForHash() 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 写入 / 更新 方法功能 方法 Redis 原始命令 备注 设置单个 field-value put(H key, HK hashKey, HV value) HSET key field value 新增或覆盖 批量设置 field-value putAll(H key, Map&lt;HK,HV&gt; m) HSET key field value [field value ...] HMSET 已废弃 field 不存在时设置 putIfAbsent(H key, HK hashKey, HV value) HSETNX key field value 原子操作 读取 方法功能 方法 Redis 原始命令 备注 获取指定 field 的值 get(H key, Object hashKey) HGET key field 不存在返回 null 批量获取多个 field multiGet(H key, Collection&lt;HK&gt; hashKeys) HMGET key field [field ...] 不存在返回 null 获取所有 value values(H key) HVALS key O(N) 获取所有 field-value entries(H key) HGETALL key 生产环境慎用 删除 / 存在性判断 方法功能 方法 Redis 原始命令 备注 删除一个或多个 field delete(H key, Object... hashKeys) HDEL key field [field ...] 返回删除数量 判断 field 是否存在 hasKey(H key, Object hashKey) HEXISTS key field — 计数与数值运算 方法功能 方法 Redis 原始命令 备注 field 整数自增 increment(H key, HK hashKey, long delta) HINCRBY key field increment value 必须是整数 field 浮点数自增 increment(H key, HK hashKey, double delta) HINCRBYFLOAT key field increment Redis ≥ 2.6 获取 field 对应 value 长度 lengthOfValue(H key, HK hashKey) HSTRLEN key field 不存在返回 0 获取 hash 中 field 数量 size(H key) HLEN key — 随机访问（Random Access） ⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务 方法功能 方法 Redis 原始命令 备注 随机返回一个 field randomKey(H key) HRANDFIELD key Redis ≥ 6.2 随机返回一个 field-value randomEntry(H key) HRANDFIELD key WITHVALUES Redis ≥ 6.2 随机返回多个 field randomKeys(H key, long count) HRANDFIELD key count count &lt; 0 可重复 随机返回多个 field-value randomEntries(H key, long count) HRANDFIELD key count WITHVALUES — 遍历与扫描（推荐方式） 方法功能 方法 Redis 原始命令 备注 获取所有 field keys(H key) HKEYS key O(N)，大 hash 慎用 游标扫描 hash scan(H key, ScanOptions options) HSCAN key cursor [MATCH] [COUNT] 推荐替代 HGETALL 📌 最佳实践 小 hash：HGETALL 大 hash / 线上系统：HSCAN Hash Field 级别过期（Redis 7.4+） Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强 设置过期 方法功能 方法 Redis 原始命令 备注 为指定 field 设置过期时间 expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys) HEXPIRE key seconds FIELDS n field [...] Redis ≥ 7.4 为指定 field 设置过期时间点 expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys) HEXPIREAT key timestamp FIELDS n field [...] Redis ≥ 7.4 高级过期策略 expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys) HEXPIRE / HEXPIREAT Spring 抽象封装 移除过期时间 方法功能 方法 Redis 原始命令 备注 移除指定 field 的过期时间 persist(H key, Collection&lt;HK&gt; hashKeys) HPERSIST key FIELDS n field [...] Redis ≥ 7.4","summary":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:33:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","title":"Redis 命令及数据类型 -- String","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis String 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"String-核心详解\">String 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据形式</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通字符串</td>\n<td><code>&quot;hello redis&quot;</code></td>\n</tr>\n<tr>\n<td>数字（整型/浮点）</td>\n<td><code>&quot;100&quot;</code>, <code>&quot;3.14&quot;</code></td>\n</tr>\n<tr>\n<td>JSON</td>\n<td><code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125;</code></td>\n</tr>\n<tr>\n<td>序列化对象</td>\n<td>Java / JSON / ProtoBuf</td>\n</tr>\n<tr>\n<td>Base64 / 二进制</td>\n<td>图片、Token 等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>最大存储大小（MB）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Key</td>\n<td>&lt; 1k</td>\n</tr>\n<tr>\n<td>Value</td>\n<td>&lt; 1MB</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>String 数据类型的主要应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 单值缓存</span></span><br><span class=\"line\">SET k1 v1</span><br><span class=\"line\"><span class=\"comment\"># 对象缓存</span></span><br><span class=\"line\">SET user:1 <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 分布式锁，为了保证可重入，现在更推荐使用 hash 类型</span></span><br><span class=\"line\">SET lock uuid:threadId NX EX 10</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redis-String-的编码类型\">Redis String 的编码类型</h2>\n<blockquote>\n<p>编码类型是针对 value 的编码方式</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>编码类型</th>\n<th>OBJECT ENCODING</th>\n<th>触发条件</th>\n<th>内部存储</th>\n<th>是否可变</th>\n<th>典型命令/场景</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整数编码</td>\n<td><code>int</code></td>\n<td>value 是<strong>纯数字字符串</strong>且在 <code>[-2^63, 2^63-1]</code> 范围</td>\n<td><code>long</code></td>\n<td>❌</td>\n<td><code>SET k 1</code>、<code>INCR k</code></td>\n<td>最省内存、数值运算最快</td>\n</tr>\n<tr>\n<td>嵌入式字符串</td>\n<td><code>embstr</code></td>\n<td><strong>字符串长度 ≤ 44 字节</strong>（Redis 7.x）且<strong>直接 SET</strong></td>\n<td><code>redisObject + SDS</code> 一次性分配</td>\n<td>⚠️（会升级）</td>\n<td><code>SET k &quot;ok&quot;</code></td>\n<td>不支持扩容</td>\n</tr>\n<tr>\n<td>原始字符串</td>\n<td><code>raw</code></td>\n<td>字符串长度 &gt; 44 字节，或发生<strong>增量修改</strong></td>\n<td><code>redisObject → SDS</code></td>\n<td>✅</td>\n<td><code>APPEND</code>、<code>SETRANGE</code></td>\n<td>最通用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以用命令查看指定key的 value 的编码类型</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJECT ENCODING key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> k1 123</span><br><span class=\"line\">OBJECT ENCODING k1 <span class=\"comment\"># int</span></span><br><span class=\"line\">APPEND k1 <span class=\"string\">&quot;4&quot;</span> <span class=\"comment\"># 自动升级为 raw，这是因为 APPEND 会强制使用 raw，即使最终字符串长度 ≤ 44 字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">SET k <span class=\"string\">&quot;short&quot;</span></span><br><span class=\"line\">OBJECT ENCODING k <span class=\"comment\"># embstr</span></span><br><span class=\"line\">APPEND k <span class=\"string\">&quot;this-is-a-long-string&quot;</span> <span class=\"comment\"># 自动升级为 raw</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis String 根据“值的形态 + 操作语义”在 int / embstr / raw 之间自动选择；</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种编码自适应机制，是 Redis 高性能与低内存占用的重要基础。</p>\n</li>\n</ul>\n<h2 id=\"String-命令\">String 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForValue()</code> 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"普通设置\">普通设置</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置 key 的值</td>\n<td><code>set(K key, V value)</code></td>\n<td><code>SET key value</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件写入（NX-XX）\">条件写入（NX / XX）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key 不存在时设置</td>\n<td><code>setIfAbsent(K key, V value)</code></td>\n<td><code>SET key value NX</code></td>\n<td>NX：key 不存在才设置</td>\n</tr>\n<tr>\n<td>key 存在时设置</td>\n<td><code>setIfPresent(K key, V value)</code></td>\n<td><code>SET key value XX</code></td>\n<td>XX：key 存在才设置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件写入-过期时间\">条件写入 + 过期时间</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key 不存在时设置并指定过期时间</td>\n<td><code>setIfAbsent(K key, V value, timeout, unit)</code></td>\n<td><code>SET key value NX EX seconds</code></td>\n<td>EX 秒 / PX 毫秒</td>\n</tr>\n<tr>\n<td>key 存在时设置并指定过期时间</td>\n<td><code>setIfPresent(K key, V value, timeout, unit)</code></td>\n<td><code>SET key value XX EX seconds</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"直接设置并指定过期时间\">直接设置并指定过期时间</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置值并指定过期时间</td>\n<td><code>set(K key, V value, timeout, unit)</code></td>\n<td><code>SETEX key seconds value</code> <strong>即将废弃</strong></td>\n<td><strong>推荐</strong> → <code>SET key value EX seconds</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"保留-TTL-写入（KEEP-TTL）\">保留 TTL 写入（KEEP_TTL）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置新值并保留原 TTL</td>\n<td>无直接方法</td>\n<td><code>SET key value KEEPTTL</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setKeepTtl</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">    redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">            connection.stringCommands().set(</span><br><span class=\"line\">                    Objects.requireNonNull(redisTemplate.getStringSerializer().serialize(key)),</span><br><span class=\"line\">                    Objects.requireNonNull(((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer()).serialize(value)),</span><br><span class=\"line\">                    Expiration.keepTtl(),</span><br><span class=\"line\">                    RedisStringCommands.SetOption.UPSERT</span><br><span class=\"line\">            )</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"普通读取\">普通读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取 key 的值</td>\n<td><code>get(K key)</code></td>\n<td><code>GET key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"读改写原子操作（GETEX-GETDEL）\">读改写原子操作（GETEX / GETDEL）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取值并重置过期时间</td>\n<td><code>getAndExpire(K key, timeout, unit)</code></td>\n<td><code>GETEX key EX seconds</code></td>\n<td>Redis ≥ 6.2<br>GET + EXPIRE（非原子）</td>\n</tr>\n<tr>\n<td>获取 key 的当前值并移除过期时间</td>\n<td><code>getAndPersist(K key)</code></td>\n<td><code>GETEX key PERSIST</code></td>\n<td>Redis ≥ 6.2<br>GET + PERSIST（非原子）</td>\n</tr>\n<tr>\n<td>获取值并删除 key</td>\n<td><code>getAndDelete(K key)</code></td>\n<td><code>GETDEL key</code></td>\n<td>Redis ≥ 6.2<br>GET + DEL（非原子）</td>\n</tr>\n<tr>\n<td>获取旧值并设置新值</td>\n<td><code>getAndSet(K key, V value)</code></td>\n<td><code>GETSET key value</code> <strong>即将废弃</strong></td>\n<td><strong>推荐</strong> → <code>SET key value GET</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符串区间读取\">字符串区间读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取字符串指定区间</td>\n<td><code>get(K key, start, end)</code></td>\n<td><code>GETRANGE key start end</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取字符串长度</td>\n<td><code>size(K key)</code></td>\n<td><code>STRLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数值运算（计数器场景）\">数值运算（计数器场景）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数值自增 1</td>\n<td><code>increment(K key)</code></td>\n<td><code>INCR key</code></td>\n<td>value 必须是整数</td>\n</tr>\n<tr>\n<td>数值增加指定值</td>\n<td><code>increment(K key, delta)</code></td>\n<td><code>INCRBY key increment</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值自减 1</td>\n<td><code>decrement(K key)</code></td>\n<td><code>DECR key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值减少指定值</td>\n<td><code>decrement(K key, delta)</code></td>\n<td><code>DECRBY key decrement</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量写入-读取\">批量写入 / 读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量设置 key-value</td>\n<td><code>multiSet(map)</code></td>\n<td><code>MSET key value ...</code></td>\n<td>非原子</td>\n</tr>\n<tr>\n<td>批量获取 key 的值</td>\n<td><code>multiGet(keys)</code></td>\n<td><code>MGET key ...</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量条件写入（原子）\">批量条件写入（原子）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量设置（仅当全部不存在）</td>\n<td><code>multiSetIfAbsent(map)</code></td>\n<td><code>MSETNX key value ...</code></td>\n<td><strong>全成功 / 全失败</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符串追加操作\">字符串追加操作</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>追加字符串并返回新长度</td>\n<td><code>append(K key, String value)</code></td>\n<td><code>APPEND key value</code></td>\n<td>key 不存在等价于 SET</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ String 核心详解 在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。 Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。 Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等 数据形式 示例 普通字符串 &quot;hello redis&quot; 数字（整型/浮点） &quot;100&quot;, &quot;3.14&quot; JSON &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125; 序列化对象 Java / JSON / ProtoBuf Base64 / 二进制 图片、Token 等 单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下 分类 最大存储大小（MB） Key &lt; 1k Value &lt; 1MB String 数据类型的主要应用场景 123456# 单值缓存SET k1 v1# 对象缓存SET user:1 &#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;# 分布式锁，为了保证可重入，现在更推荐使用 hash 类型SET lock uuid:threadId NX EX 10 Redis String 的编码类型 编码类型是针对 value 的编码方式 编码类型 OBJECT ENCODING 触发条件 内部存储 是否可变 典型命令/场景 备注 整数编码 int value 是纯数字字符串且在 [-2^63, 2^63-1] 范围 long ❌ SET k 1、INCR k 最省内存、数值运算最快 嵌入式字符串 embstr 字符串长度 ≤ 44 字节（Redis 7.x）且直接 SET redisObject + SDS 一次性分配 ⚠️（会升级） SET k &quot;ok&quot; 不支持扩容 原始字符串 raw 字符串长度 &gt; 44 字节，或发生增量修改 redisObject → SDS ✅ APPEND、SETRANGE 最通用 可以用命令查看指定key的 value 的编码类型 1OBJECT ENCODING key 示例 1234567set k1 123OBJECT ENCODING k1 # intAPPEND k1 &quot;4&quot; # 自动升级为 raw，这是因为 APPEND 会强制使用 raw，即使最终字符串长度 ≤ 44 字节SET k &quot;short&quot;OBJECT ENCODING k # embstrAPPEND k &quot;this-is-a-long-string&quot; # 自动升级为 raw Redis String 根据“值的形态 + 操作语义”在 int / embstr / raw 之间自动选择； 这种编码自适应机制，是 Redis 高性能与低内存占用的重要基础。 String 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForValue() 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 普通设置 方法功能 方法 Redis 原始命令 备注 设置 key 的值 set(K key, V value) SET key value — 条件写入（NX / XX） 方法功能 方法 Redis 原始命令 命令备注 key 不存在时设置 setIfAbsent(K key, V value) SET key value NX NX：key 不存在才设置 key 存在时设置 setIfPresent(K key, V value) SET key value XX XX：key 存在才设置 条件写入 + 过期时间 方法功能 方法 Redis 原始命令 命令备注 key 不存在时设置并指定过期时间 setIfAbsent(K key, V value, timeout, unit) SET key value NX EX seconds EX 秒 / PX 毫秒 key 存在时设置并指定过期时间 setIfPresent(K key, V value, timeout, unit) SET key value XX EX seconds — 直接设置并指定过期时间 方法功能 方法 Redis 原始命令 命令备注 / 推荐替代 设置值并指定过期时间 set(K key, V value, timeout, unit) SETEX key seconds value 即将废弃 推荐 → SET key value EX seconds 保留 TTL 写入（KEEP_TTL） 方法功能 方法 Redis 原始命令 备注 设置新值并保留原 TTL 无直接方法 SET key value KEEPTTL Redis ≥ 6.0 12345678910public void setKeepTtl(String key, Object value) &#123; redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.stringCommands().set( Objects.requireNonNull(redisTemplate.getStringSerializer().serialize(key)), Objects.requireNonNull(((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer()).serialize(value)), Expiration.keepTtl(), RedisStringCommands.SetOption.UPSERT ) );&#125; 普通读取 方法功能 方法 Redis 原始命令 备注 获取 key 的值 get(K key) GET key — 读改写原子操作（GETEX / GETDEL） 方法功能 方法 Redis 原始命令 备注 获取值并重置过期时间 getAndExpire(K key, timeout, unit) GETEX key EX seconds Redis ≥ 6.2GET + EXPIRE（非原子） 获取 key 的当前值并移除过期时间 getAndPersist(K key) GETEX key PERSIST Redis ≥ 6.2GET + PERSIST（非原子） 获取值并删除 key getAndDelete(K key) GETDEL key Redis ≥ 6.2GET + DEL（非原子） 获取旧值并设置新值 getAndSet(K key, V value) GETSET key value 即将废弃 推荐 → SET key value GET 字符串区间读取 方法功能 方法 Redis 原始命令 备注 获取字符串指定区间 get(K key, start, end) GETRANGE key start end — 获取字符串长度 size(K key) STRLEN key — 数值运算（计数器场景） 方法功能 方法 Redis 原始命令 备注 数值自增 1 increment(K key) INCR key value 必须是整数 数值增加指定值 increment(K key, delta) INCRBY key increment — 数值自减 1 decrement(K key) DECR key — 数值减少指定值 decrement(K key, delta) DECRBY key decrement — 批量写入 / 读取 方法功能 方法 Redis 原始命令 备注 批量设置 key-value multiSet(map) MSET key value ... 非原子 批量获取 key 的值 multiGet(keys) MGET key ... 不存在返回 null 批量条件写入（原子） 方法功能 方法 Redis 原始命令 备注 批量设置（仅当全部不存在） multiSetIfAbsent(map) MSETNX key value ... 全成功 / 全失败 字符串追加操作 方法功能 方法 Redis 原始命令 备注 追加字符串并返回新长度 append(K key, String value) APPEND key value key 不存在等价于 SET","summary":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:31:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","title":"Redis 命令及数据类型 -- 通用命令","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"通用命令\">通用命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以在 Redis官网 中查看所有命令的使用方法，也可以在命令行中通过 <code>help command</code> 或 <code>help @group</code> 查看命令的帮助</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 set 命令的使用方法</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 查看事务相关命令的使用方法</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @transactions</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis核心分组</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分组</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@string</code></td>\n<td>String</td>\n</tr>\n<tr>\n<td><code>@hash</code></td>\n<td>Hash</td>\n</tr>\n<tr>\n<td><code>@list</code></td>\n<td>List</td>\n</tr>\n<tr>\n<td><code>@set</code></td>\n<td>Set</td>\n</tr>\n<tr>\n<td><code>@sortedset</code></td>\n<td>ZSet</td>\n</tr>\n<tr>\n<td><code>@bitmap</code></td>\n<td>Bitmap</td>\n</tr>\n<tr>\n<td><code>@hyperloglog</code></td>\n<td>HLL</td>\n</tr>\n<tr>\n<td><code>@geo</code></td>\n<td>GEO</td>\n</tr>\n<tr>\n<td><code>@stream</code></td>\n<td>Stream</td>\n</tr>\n<tr>\n<td><code>@transactions</code></td>\n<td>MULTI / EXEC</td>\n</tr>\n<tr>\n<td><code>@pubsub</code></td>\n<td>发布订阅</td>\n</tr>\n<tr>\n<td><code>@scripting</code></td>\n<td>Lua</td>\n</tr>\n<tr>\n<td><code>@server</code></td>\n<td>服务器管理</td>\n</tr>\n<tr>\n<td><code>@connection</code></td>\n<td>连接管理</td>\n</tr>\n<tr>\n<td><code>@cluster</code></td>\n<td>集群</td>\n</tr>\n<tr>\n<td><code>@module</code></td>\n<td>Stack扩展</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以下是针对所有数据类型均可使用给的方法和命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>redisTemplate.xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制 key 到新 key</td>\n<td><code>Boolean copy(K source, K target, boolean replace)</code></td>\n<td><code>COPY source target [REPLACE]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>判断 key 是否存在（单个）</td>\n<td><code>Boolean hasKey(K key)</code></td>\n<td><code>EXISTS key</code></td>\n<td>CLI 返回存在数量</td>\n</tr>\n<tr>\n<td>统计存在的 key 数量</td>\n<td><code>Long countExistingKeys(Collection&lt;K&gt; keys)</code></td>\n<td><code>EXISTS key [key ...]</code></td>\n<td>返回存在 key 的数量</td>\n</tr>\n<tr>\n<td>删除指定 key（同步）</td>\n<td><code>Boolean delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>返回是否删除成功</td>\n</tr>\n<tr>\n<td>批量删除 key（同步）</td>\n<td><code>Long delete(Collection&lt;K&gt; keys)</code></td>\n<td><code>DEL key [key ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>删除 key（异步）</td>\n<td><code>Boolean unlink(K key)</code></td>\n<td><code>UNLINK key</code></td>\n<td>非阻塞删除</td>\n</tr>\n<tr>\n<td>批量删除 key（异步）</td>\n<td><code>Long unlink(Collection&lt;K&gt; keys)</code></td>\n<td><code>UNLINK key [key ...]</code></td>\n<td>推荐大 key 使用</td>\n</tr>\n<tr>\n<td>获取 key 的数据类型</td>\n<td><code>DataType type(K key)</code></td>\n<td><code>TYPE key</code></td>\n<td>返回 string/hash/list/set/zset/none</td>\n</tr>\n<tr>\n<td>按模式匹配 key（阻塞）</td>\n<td><code>Set&lt;K&gt; keys(K pattern)</code></td>\n<td><code>KEYS pattern</code></td>\n<td><strong>生产环境不推荐</strong></td>\n</tr>\n<tr>\n<td>游标方式扫描 key</td>\n<td><code>Cursor&lt;K&gt; scan(ScanOptions options)</code></td>\n<td><code>SCAN cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>KEYS</code></td>\n</tr>\n<tr>\n<td>随机返回一个 key</td>\n<td><code>K randomKey()</code></td>\n<td><code>RANDOMKEY</code></td>\n<td>可能返回 <code>null</code></td>\n</tr>\n<tr>\n<td>重命名 key</td>\n<td><code>void rename(K oldKey, K newKey)</code></td>\n<td><code>RENAME oldKey newKey</code></td>\n<td>覆盖目标 key</td>\n</tr>\n<tr>\n<td>key 不存在时重命名</td>\n<td><code>Boolean renameIfAbsent(K oldKey, K newKey)</code></td>\n<td><code>RENAMENX oldKey newKey</code></td>\n<td>原子操作</td>\n</tr>\n<tr>\n<td>设置 key 过期时间</td>\n<td><code>Boolean expire(K key, long timeout, TimeUnit unit)</code></td>\n<td><code>PEXPIRE / EXPIRE</code></td>\n<td>优先毫秒精度</td>\n</tr>\n<tr>\n<td>设置 key 在指定时间过期</td>\n<td><code>Boolean expireAt(K key, Date date)</code></td>\n<td><code>PEXPIREAT / EXPIREAT</code></td>\n<td>精度自动降级</td>\n</tr>\n<tr>\n<td>设置过期策略（高级 API）</td>\n<td><code>ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options)</code></td>\n<td><code>EXPIRE / PEXPIRE / EXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n<tr>\n<td>清除 key 的过期时间</td>\n<td><code>Boolean persist(K key)</code></td>\n<td><code>PERSIST key</code></td>\n<td>变为永久 key</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（秒）</td>\n<td><code>Long getExpire(K key)</code></td>\n<td><code>TTL key</code></td>\n<td><code>-1</code> 无 TTL，<code>-2</code> 不存在</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（指定单位）</td>\n<td><code>Long getExpire(K key, TimeUnit unit)</code></td>\n<td><code>PTTL / TTL</code></td>\n<td>优先毫秒</td>\n</tr>\n<tr>\n<td>将 key 移动到其他 DB</td>\n<td><code>Boolean move(K key, int dbIndex)</code></td>\n<td><code>MOVE key db</code></td>\n<td>集群模式不可用</td>\n</tr>\n<tr>\n<td>导出 key 的序列化值</td>\n<td><code>byte[] dump(K key)</code></td>\n<td><code>DUMP key</code></td>\n<td>用于迁移</td>\n</tr>\n<tr>\n<td>恢复 key</td>\n<td><code>void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace)</code></td>\n<td><code>RESTORE key ttl value [REPLACE]</code></td>\n<td>与 <code>DUMP</code> 配合</td>\n</tr>\n<tr>\n<td>排序并返回结果</td>\n<td><code>List&lt;V&gt; sort(SortQuery&lt;K&gt; query)</code></td>\n<td><code>SORT key</code></td>\n<td>阻塞操作</td>\n</tr>\n<tr>\n<td>排序并指定返回类型</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer)</code></td>\n<td><code>SORT key</code></td>\n<td>结果反序列化</td>\n</tr>\n<tr>\n<td>排序并映射结果</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>排序并映射（高级）</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>批量映射</td>\n</tr>\n<tr>\n<td>排序并存储结果</td>\n<td><code>Long sort(SortQuery&lt;K&gt; query, K storeKey)</code></td>\n<td><code>SORT key STORE destination</code></td>\n<td>返回结果条数</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境慎用的命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>原因</th>\n<th>推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>KEYS</code></td>\n<td>阻塞、O(N)</td>\n<td><code>SCAN</code></td>\n</tr>\n<tr>\n<td><code>SORT</code></td>\n<td>阻塞、消耗 CPU</td>\n<td>业务侧排序</td>\n</tr>\n<tr>\n<td><code>DEL</code></td>\n<td>阻塞、消耗 CPU</td>\n<td><code>UNLINK</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"避免BigKey\">避免BigKey</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BigKey 的危害并不在“占内存”，而在操作成本是 O(N)。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 是单线程执行命令，比如 <code>HGETALL</code>、<code>DEL</code>等，运行期间会占用CPU，阻塞 Redis 主线程，直接表现为 RT 飙升 / QPS 下降。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外BigKey还会导致如下问题：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大 Key 返回值过大 → 网络 IO 抖动</span><br><span class=\"line\">主从复制同步 BigKey → 从库延迟</span><br><span class=\"line\">RDB / AOF 重写 → Fork 时间变长</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BigKey 的阈值</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>元素数量阈值（经验值）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>≥ 10,000 byte</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>≥ 10,000 field</td>\n</tr>\n<tr>\n<td>List</td>\n<td>≥ 10,000 item</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>≥ 10,000 member</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>≥ 10,000 member</td>\n</tr>\n<tr>\n<td>Stream</td>\n<td>≥ 10,000 entry</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在生产环境中，5,000 就已经需要警惕。<br>\n建议在数据量达到一定阈值时，考虑拆分。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Reids官方给出了判断BigKey的命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --bigkeys</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 注意：它不是按<code>内存占用最大</code>，而是按<code>元素数/长度</code> 来找<code>最大的 key</code>。</p>\n</li>\n</ul>\n<h3 id=\"BigKey-的处理方式\">BigKey 的处理方式</h3>\n<h4 id=\"避免执行占用CPU的操作\">避免执行占用CPU的操作</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>比如 <code>HGETALL</code>、<code>DEL</code>、<code>Keys *</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只读取一部分字段</span></span><br><span class=\"line\">HGETALL user:1001 --&gt; HMGET user:1001 name age email</span><br><span class=\"line\"><span class=\"comment\"># 异步清除</span></span><br><span class=\"line\">DEL key --&gt; UNLINK key</span><br><span class=\"line\"><span class=\"comment\"># 避免 KEYS 改用 SCAN</span></span><br><span class=\"line\">keys pattern --&gt; scan cursor match pattern count 1000</span><br><span class=\"line\"><span class=\"comment\"># 避免读取全部数据，而是应该指定读取范围</span></span><br><span class=\"line\">LRANGE key 0 -1 --&gt; LRANGE key 0 999</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>业务侧排序，避免使用<code>SORT</code></p>\n</li>\n</ul>\n<h4 id=\"设计上避免BigKey\">设计上避免BigKey</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>拆分数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 错误设计：</span></span><br><span class=\"line\">user:all_profiles -&gt; 超大 JSON</span><br><span class=\"line\"><span class=\"comment\"># 正确设计：</span></span><br><span class=\"line\">user:1001:profile</span><br><span class=\"line\">user:1002:profile</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 分桶（Shard）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 hash(id) % N 分散</span></span><br><span class=\"line\">order:2025:0</span><br><span class=\"line\">order:2025:1</span><br><span class=\"line\">order:2025:2</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 通用命令 我们可以在 Redis官网 中查看所有命令的使用方法，也可以在命令行中通过 help command 或 help @group 查看命令的帮助 1234# 查看 set 命令的使用方法help set# 查看事务相关命令的使用方法help @transactions Redis核心分组 分组 说明 @string String @hash Hash @list List @set Set @sortedset ZSet @bitmap Bitmap @hyperloglog HLL @geo GEO @stream Stream @transactions MULTI / EXEC @pubsub 发布订阅 @scripting Lua @server 服务器管理 @connection 连接管理 @cluster 集群 @module Stack扩展 以下是针对所有数据类型均可使用给的方法和命令 方法功能 方法 redisTemplate.xxx() Redis 原始命令 命令备注 / 推荐替代 复制 key 到新 key Boolean copy(K source, K target, boolean replace) COPY source target [REPLACE] Redis ≥ 6.2 判断 key 是否存在（单个） Boolean hasKey(K key) EXISTS key CLI 返回存在数量 统计存在的 key 数量 Long countExistingKeys(Collection&lt;K&gt; keys) EXISTS key [key ...] 返回存在 key 的数量 删除指定 key（同步） Boolean delete(K key) DEL key 返回是否删除成功 批量删除 key（同步） Long delete(Collection&lt;K&gt; keys) DEL key [key ...] 返回删除数量 删除 key（异步） Boolean unlink(K key) UNLINK key 非阻塞删除 批量删除 key（异步） Long unlink(Collection&lt;K&gt; keys) UNLINK key [key ...] 推荐大 key 使用 获取 key 的数据类型 DataType type(K key) TYPE key 返回 string/hash/list/set/zset/none 按模式匹配 key（阻塞） Set&lt;K&gt; keys(K pattern) KEYS pattern 生产环境不推荐 游标方式扫描 key Cursor&lt;K&gt; scan(ScanOptions options) SCAN cursor [MATCH] [COUNT] 推荐替代 KEYS 随机返回一个 key K randomKey() RANDOMKEY 可能返回 null 重命名 key void rename(K oldKey, K newKey) RENAME oldKey newKey 覆盖目标 key key 不存在时重命名 Boolean renameIfAbsent(K oldKey, K newKey) RENAMENX oldKey newKey 原子操作 设置 key 过期时间 Boolean expire(K key, long timeout, TimeUnit unit) PEXPIRE / EXPIRE 优先毫秒精度 设置 key 在指定时间过期 Boolean expireAt(K key, Date date) PEXPIREAT / EXPIREAT 精度自动降级 设置过期策略（高级 API） ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options) EXPIRE / PEXPIRE / EXPIREAT Spring 抽象封装 清除 key 的过期时间 Boolean persist(K key) PERSIST key 变为永久 key 获取剩余 TTL（秒） Long getExpire(K key) TTL key -1 无 TTL，-2 不存在 获取剩余 TTL（指定单位） Long getExpire(K key, TimeUnit unit) PTTL / TTL 优先毫秒 将 key 移动到其他 DB Boolean move(K key, int dbIndex) MOVE key db 集群模式不可用 导出 key 的序列化值 byte[] dump(K key) DUMP key 用于迁移 恢复 key void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace) RESTORE key ttl value [REPLACE] 与 DUMP 配合 排序并返回结果 List&lt;V&gt; sort(SortQuery&lt;K&gt; query) SORT key 阻塞操作 排序并指定返回类型 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer) SORT key 结果反序列化 排序并映射结果 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper) SORT key Spring 封装 排序并映射（高级） List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper) SORT key 批量映射 排序并存储结果 Long sort(SortQuery&lt;K&gt; query, K storeKey) SORT key STORE destination 返回结果条数 生产环境慎用的命令 命令 原因 推荐 KEYS 阻塞、O(N) SCAN SORT 阻塞、消耗 CPU 业务侧排序 DEL 阻塞、消耗 CPU UNLINK 避免BigKey BigKey 的危害并不在“占内存”，而在操作成本是 O(N)。 Redis 是单线程执行命令，比如 HGETALL、DEL等，运行期间会占用CPU，阻塞 Redis 主线程，直接表现为 RT 飙升 / QPS 下降。 另外BigKey还会导致如下问题： 123大 Key 返回值过大 → 网络 IO 抖动主从复制同步 BigKey → 从库延迟RDB / AOF 重写 → Fork 时间变长 BigKey 的阈值 数据类型 元素数量阈值（经验值） String ≥ 10,000 byte Hash ≥ 10,000 field List ≥ 10,000 item Set ≥ 10,000 member ZSet ≥ 10,000 member Stream ≥ 10,000 entry 在生产环境中，5,000 就已经需要警惕。 建议在数据量达到一定阈值时，考虑拆分。 Reids官方给出了判断BigKey的命令 1redis-cli --bigkeys ⚠️ 注意：它不是按内存占用最大，而是按元素数/长度 来找最大的 key。 BigKey 的处理方式 避免执行占用CPU的操作 比如 HGETALL、DEL、Keys * 12345678# 只读取一部分字段HGETALL user:1001 --&gt; HMGET user:1001 name age email# 异步清除DEL key --&gt; UNLINK key# 避免 KEYS 改用 SCANkeys pattern --&gt; scan cursor match pattern count 1000# 避免读取全部数据，而是应该指定读取范围LRANGE key 0 -1 --&gt; LRANGE key 0 999 业务侧排序，避免使用SORT 设计上避免BigKey 拆分数据 12345# 错误设计：user:all_profiles -&gt; 超大 JSON# 正确设计：user:1001:profileuser:1002:profile Hash 分桶（Shard） 1234# 通过 hash(id) % N 分散order:2025:0order:2025:1order:2025:2","summary":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","url":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","title":"Redis SCAN 命令详解：作用、用法与最佳实践","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。</li>\n<li class=\"lvl-2\">Redis 提供了两种思路：使用 <code>KEYS pattern</code> 或使用游标式遍历命令 <code>SCAN</code>。</li>\n<li class=\"lvl-2\"><code>KEYS pattern</code> 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用<code>KEYS pattern</code>等危险命令。</li>\n<li class=\"lvl-2\">所以Redis官方强烈推荐 <code>SCAN</code> 方式，其是最安全、最可控的遍历方法。</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"SCAN-的核心作用\">SCAN 的核心作用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的主要功能是<strong>基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key</strong>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 的设计目标包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">避免阻塞 Redis 主线程</li>\n<li class=\"lvl-5\">分批、渐进扫描大规模 key 集合</li>\n<li class=\"lvl-5\">灵活配合模式匹配（MATCH）</li>\n<li class=\"lvl-5\">控制每次返回 key 的数量（COUNT）</li>\n<li class=\"lvl-5\">在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 命令是完整游标遍历族的一部分，还包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\"><code>HSCAN</code>：遍历哈希表 field/value</li>\n<li class=\"lvl-5\"><code>SSCAN</code>：遍历 set 元素</li>\n<li class=\"lvl-5\"><code>ZSCAN</code>：遍历有序集合</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>为了完成后面的示例演示，这里准备一个测试数据批量生产脚本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 脚本名称：import_unified_data.sh</span></span><br><span class=\"line\"><span class=\"comment\"># 运行方法：sh $0 &lt;type&gt; [count]</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;type&gt;: string, hash, list, set, 或 zset</span></span><br><span class=\"line\"><span class=\"comment\"># [count]: 导入的数据量 (可选，默认为 100)</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 1. 参数校验与配置 ---</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUPPORTED_TYPES=<span class=\"string\">&quot;string hash list set zset&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 定义每个集合/列表/有序集合要添加的成员数量</span></span><br><span class=\"line\">MEMBERS_PER_KEY=5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查是否提供了类型参数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -lt 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：请指定导入类型。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: sh <span class=\"variable\">$0</span> &lt;type&gt; [count]&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取类型参数 (第一个参数)</span></span><br><span class=\"line\">DATA_TYPE=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;[:upper:]&#x27;</span> <span class=\"string\">&#x27;[:lower:]&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据量参数 (第二个参数)，不存在则默认为 1000</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -ge 2 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    DATA_COUNT=<span class=\"variable\">$2</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    DATA_COUNT=100</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查类型是否有效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ ! <span class=\"string\">&quot; <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span> &quot;</span> =~ <span class=\"string\">&quot; <span class=\"variable\">$&#123;DATA_TYPE&#125;</span> &quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：不支持的类型 &#x27;<span class=\"variable\">$DATA_TYPE</span>&#x27;。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 连接配置</span></span><br><span class=\"line\">REDIS_HOST=<span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">REDIS_PORT=<span class=\"string\">&quot;6379&quot;</span></span><br><span class=\"line\">REDIS_PASSWORD=<span class=\"string\">&quot;password&quot;</span> <span class=\"comment\"># 替换为你的实际密码或留空</span></span><br><span class=\"line\">KEY_PREFIX=<span class=\"string\">&quot;test_data&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># --- 2. 命令生成主逻辑 ---</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;⏳ 正在生成 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 Redis [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 命令...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建 RESP 命令流</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le <span class=\"variable\">$DATA_COUNT</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$DATA_TYPE</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\"># --- String 类型导入 (SET key value) ---</span></span><br><span class=\"line\">        string)</span><br><span class=\"line\">            KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:string:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            VALUE=<span class=\"string\">&quot;value_of_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"subst\">$(date +%s%N)</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># SET 命令 RESP 协议: *3 (SET, key, value)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$<span class=\"variable\">$&#123;#KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Hash 类型导入 (HSET key field1 value1 field2 value2) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">hash</span>)</span><br><span class=\"line\">            HASH_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:hash:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD1=<span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">            VALUE1=<span class=\"string\">&quot;User_Name_<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD2=<span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">            VALUE2=$(( (i % <span class=\"number\">50</span>) + <span class=\"number\">20</span> ))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$<span class=\"variable\">$&#123;#HASH_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;HASH_KEY&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD1&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD1&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE1&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE1&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD2&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD2&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE2&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE2&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- List 类型导入 (LPUSH key value) ---</span></span><br><span class=\"line\">        list)</span><br><span class=\"line\">            LIST_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:list:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                VALUE=<span class=\"string\">&quot;list_element_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># LPUSH 命令 RESP 协议: *3 (LPUSH, key, value)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$<span class=\"variable\">$&#123;#LIST_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;LIST_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Set 类型导入 (SADD key member) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">set</span>)</span><br><span class=\"line\">            SET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:set:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;set_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># SADD 命令 RESP 协议: *3 (SADD, key, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$<span class=\"variable\">$&#123;#SET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;SET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Sorted Set 类型导入 (ZADD key score member) ---</span></span><br><span class=\"line\">        zset)</span><br><span class=\"line\">            ZSET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:zset:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                SCORE=<span class=\"string\">&quot;<span class=\"variable\">$&#123;i&#125;</span><span class=\"variable\">$&#123;j&#125;</span>&quot;</span> <span class=\"comment\"># 生成唯一分数：例如 key 1 的分数是 11, 12...</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;zset_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># ZADD 命令 RESP 协议: *4 (ZADD, key, score, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$<span class=\"variable\">$&#123;#ZSET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;ZSET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#SCORE&#125;</span>\\r\\n<span class=\"variable\">$&#123;SCORE&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\"></span><br><span class=\"line\">    i=$((i+<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">done</span> | (</span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"comment\"># --- 3. 管道导入到 Redis ---</span></span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;📤 正在通过 redis-cli --pipe 导入数据...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构建 redis-cli 命令</span></span><br><span class=\"line\">    REDIS_CLI_CMD=<span class=\"string\">&quot;redis-cli -h <span class=\"variable\">$&#123;REDIS_HOST&#125;</span> -p <span class=\"variable\">$&#123;REDIS_PORT&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果设置了密码，则添加 -a 参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        REDIS_CLI_CMD=<span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> -a <span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 执行导入</span></span><br><span class=\"line\">    <span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> --pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 检查命令是否执行成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ $? -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;✅ 数据导入成功！共导入 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 记录。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"SCAN-的基本用法\">SCAN 的基本用法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class=\"built_in\">type</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>TYPE type</td>\n<td>匹配的 key 类型（可选）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例：\">示例：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh string 100</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 key：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 游标初始值为0</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span>  <span class=\"comment\"># 游标</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\"><span class=\"comment\"># 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key</span></span><br><span class=\"line\"><span class=\"comment\">## 扫描结果中：</span></span><br><span class=\"line\"><span class=\"comment\"># 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束</span></span><br><span class=\"line\"><span class=\"comment\"># 第二个元素是匹配的 key列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着上面给出的游标，继续扫描：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 88</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span>  <span class=\"comment\"># 不为0就表示还有更多的 key 可以继续扫描</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">……………………………………</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 87</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span> <span class=\"comment\"># 扫描结束 游标为0</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:68&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:79&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:41&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">控制每次获取的 key 数量</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 count 20</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。</span></span><br><span class=\"line\"><span class=\"comment\"># 本示例就返回了21条，比 count 还多了 1 条</span></span><br><span class=\"line\"><span class=\"comment\"># 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string*</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">   22) <span class=\"string\">&quot;test_data:string:48&quot;</span></span><br><span class=\"line\">   23) <span class=\"string\">&quot;test_data:string:74&quot;</span></span><br><span class=\"line\">   24) <span class=\"string\">&quot;test_data:string:67&quot;</span></span><br><span class=\"line\">   25) <span class=\"string\">&quot;test_data:string:26&quot;</span></span><br><span class=\"line\">   26) <span class=\"string\">&quot;test_data:string:60&quot;</span></span><br><span class=\"line\">   27) <span class=\"string\">&quot;test_data:string:36&quot;</span></span><br><span class=\"line\">   28) <span class=\"string\">&quot;test_data:string:49&quot;</span></span><br><span class=\"line\">   29) <span class=\"string\">&quot;test_data:string:3&quot;</span></span><br><span class=\"line\">   30) <span class=\"string\">&quot;test_data:string:44&quot;</span></span><br><span class=\"line\">   31) <span class=\"string\">&quot;test_data:string:68&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个</span></span><br><span class=\"line\"><span class=\"comment\"># 也有可能比 count 少，甚至为 0 个</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"5\">\n<li class=\"lvl-5\">扫描以 h_key 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先插入一条记录</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> h_key:1 1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个</span></span><br><span class=\"line\"><span class=\"comment\"># 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回</span></span><br><span class=\"line\"><span class=\"comment\"># 并且此时返回的游标也不为0，说明我们还需要继续扫描</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整的扫描过程如下：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)  <span class=\"comment\"># empty array 也不能说明一定没有</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 9 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;43&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 43 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span>      <span class=\"comment\"># 只有游标为0时才算扫描结束</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;75&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 75 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"6\">\n<li class=\"lvl-5\">扫描指定类型的key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> string</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支持的类型有：</span></span><br><span class=\"line\"><span class=\"comment\"># string list set zset hash stream</span></span><br><span class=\"line\"><span class=\"comment\"># 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。</span></span><br><span class=\"line\"><span class=\"comment\"># 例如，ZSET 和 GEOHASH 都是 zset 类型。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; GEOADD geokey 0 0 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> geokey</span><br><span class=\"line\">zset</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD zkey 1000 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SCAN 0 TYPE zset count 1000</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zkey&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;geokey&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"HSCAN-的基本使用方法\">HSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key</td>\n<td>键名</td>\n</tr>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>NOVALUES</td>\n<td>redis8+增加的属性，只返回key，不返回 value（可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 HSCAN，我们先插入一些数据：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh <span class=\"built_in\">hash</span> 100</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 field 和 value：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">hash</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;48&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:hash:42&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:hash:71&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:hash:54&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:hash:87&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:hash:96&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:hash:49&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 获取 test_data:hash:42 的所有 field 和 value</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配 field：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match age*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">模糊匹配 field，并返回 10 条数据：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match *e* count 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">不显示value(需要redis8+)</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 novalues</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SSCAN-的基本使用方法\">SSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-2\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">set</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:set:43&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:set:33&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:set:98&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:set:61&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:set:2&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:set:70&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">返回 1 个元素: 实际上控制不住，大概率会返回所有元素</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSCAN-的基本使用方法\">ZSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-3\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> zset</span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:zset:89&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:zset:81&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:zset:73&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:zset:79&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:zset:15&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;893&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">获取指定key的所有元素，并返回 1 个元素，同样控制不住</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;  zscan test_data:zset:89 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/ SCAN 的核心作用 SCAN 的主要功能是基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key。 它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。 SCAN 的设计目标包括： 避免阻塞 Redis 主线程 分批、渐进扫描大规模 key 集合 灵活配合模式匹配（MATCH） 控制每次返回 key 的数量（COUNT） 在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描 SCAN 命令是完整游标遍历族的一部分，还包括： HSCAN：遍历哈希表 field/value SSCAN：遍历 set 元素 ZSCAN：遍历有序集合 为了完成后面的示例演示，这里准备一个测试数据批量生产脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/bin/bash# 脚本名称：import_unified_data.sh# 运行方法：sh $0 &lt;type&gt; [count]# &lt;type&gt;: string, hash, list, set, 或 zset# [count]: 导入的数据量 (可选，默认为 100)# ----------------------------------------# --- 1. 参数校验与配置 ---SUPPORTED_TYPES=&quot;string hash list set zset&quot;# 定义每个集合/列表/有序集合要添加的成员数量MEMBERS_PER_KEY=5# 检查是否提供了类型参数if [ $# -lt 1 ]; then echo &quot;❌ 错误：请指定导入类型。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; echo &quot;用法: sh $0 &lt;type&gt; [count]&quot; exit 1fi# 获取类型参数 (第一个参数)DATA_TYPE=$(echo &quot;$1&quot; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)# 获取数据量参数 (第二个参数)，不存在则默认为 1000if [ $# -ge 2 ]; then DATA_COUNT=$2else DATA_COUNT=100fi# 检查类型是否有效if [[ ! &quot; $&#123;SUPPORTED_TYPES&#125; &quot; =~ &quot; $&#123;DATA_TYPE&#125; &quot; ]]; then echo &quot;❌ 错误：不支持的类型 &#x27;$DATA_TYPE&#x27;。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; exit 1fi# Redis 连接配置REDIS_HOST=&quot;127.0.0.1&quot;REDIS_PORT=&quot;6379&quot;REDIS_PASSWORD=&quot;password&quot; # 替换为你的实际密码或留空KEY_PREFIX=&quot;test_data&quot;# ----------------------------------------# --- 2. 命令生成主逻辑 ---# ----------------------------------------echo &quot;⏳ 正在生成 $&#123;DATA_COUNT&#125; 条 Redis [$&#123;DATA_TYPE&#125;] 命令...&quot;# 构建 RESP 命令流i=1while [ $i -le $DATA_COUNT ]do case &quot;$DATA_TYPE&quot; in # --- String 类型导入 (SET key value) --- string) KEY=&quot;$&#123;KEY_PREFIX&#125;:string:$&#123;i&#125;&quot; VALUE=&quot;value_of_$&#123;i&#125;_$(date +%s%N)&quot; # SET 命令 RESP 协议: *3 (SET, key, value) printf &quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$$&#123;#KEY&#125;\\r\\n$&#123;KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; ;; # --- Hash 类型导入 (HSET key field1 value1 field2 value2) --- hash) HASH_KEY=&quot;$&#123;KEY_PREFIX&#125;:hash:$&#123;i&#125;&quot; FIELD1=&quot;name&quot; VALUE1=&quot;User_Name_$&#123;i&#125;&quot; FIELD2=&quot;age&quot; VALUE2=$(( (i % 50) + 20 )) # HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2) printf &quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$$&#123;#HASH_KEY&#125;\\r\\n$&#123;HASH_KEY&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD1&#125;\\r\\n$&#123;FIELD1&#125;\\r\\n\\$$&#123;#VALUE1&#125;\\r\\n$&#123;VALUE1&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD2&#125;\\r\\n$&#123;FIELD2&#125;\\r\\n\\$$&#123;#VALUE2&#125;\\r\\n$&#123;VALUE2&#125;\\r\\n&quot; ;; # --- List 类型导入 (LPUSH key value) --- list) LIST_KEY=&quot;$&#123;KEY_PREFIX&#125;:list:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do VALUE=&quot;list_element_$&#123;i&#125;_$&#123;j&#125;&quot; # LPUSH 命令 RESP 协议: *3 (LPUSH, key, value) printf &quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$$&#123;#LIST_KEY&#125;\\r\\n$&#123;LIST_KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; done ;; # --- Set 类型导入 (SADD key member) --- set) SET_KEY=&quot;$&#123;KEY_PREFIX&#125;:set:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do MEMBER=&quot;set_member_$&#123;i&#125;_$&#123;j&#125;&quot; # SADD 命令 RESP 协议: *3 (SADD, key, member) printf &quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$$&#123;#SET_KEY&#125;\\r\\n$&#123;SET_KEY&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; # --- Sorted Set 类型导入 (ZADD key score member) --- zset) ZSET_KEY=&quot;$&#123;KEY_PREFIX&#125;:zset:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do SCORE=&quot;$&#123;i&#125;$&#123;j&#125;&quot; # 生成唯一分数：例如 key 1 的分数是 11, 12... MEMBER=&quot;zset_member_$&#123;i&#125;_$&#123;j&#125;&quot; # ZADD 命令 RESP 协议: *4 (ZADD, key, score, member) printf &quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$$&#123;#ZSET_KEY&#125;\\r\\n$&#123;ZSET_KEY&#125;\\r\\n\\$$&#123;#SCORE&#125;\\r\\n$&#123;SCORE&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; esac i=$((i+1))done | ( # ---------------------------------------- # --- 3. 管道导入到 Redis --- # ---------------------------------------- echo &quot;📤 正在通过 redis-cli --pipe 导入数据...&quot; # 构建 redis-cli 命令 REDIS_CLI_CMD=&quot;redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;REDIS_PORT&#125;&quot; # 如果设置了密码，则添加 -a 参数 if [ -n &quot;$&#123;REDIS_PASSWORD&#125;&quot; ]; then REDIS_CLI_CMD=&quot;$&#123;REDIS_CLI_CMD&#125; -a $&#123;REDIS_PASSWORD&#125;&quot; fi # 执行导入 $&#123;REDIS_CLI_CMD&#125; --pipe # 检查命令是否执行成功 if [ $? -eq 0 ]; then echo &quot;✅ 数据导入成功！共导入 $&#123;DATA_COUNT&#125; 条 [$&#123;DATA_TYPE&#125;] 记录。&quot; else echo &quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot; fi) SCAN 的基本用法 SCAN 的基本语法如下： 1SCAN cursor [MATCH pattern] [COUNT count] [TYPE type] 参数解释： 参数 说明 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 TYPE type 匹配的 key 类型（可选） 示例： 为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据 1sh import_unified_data.sh string 100 获取所有 key： 1234567891011121314151617181920212223242526272829303132333435363738394041# 游标初始值为0127.0.0.1:6379&gt; scan 01) &quot;88&quot; # 游标2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;## 说明# 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key## 扫描结果中：# 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束# 第二个元素是匹配的 key列表# 接着上面给出的游标，继续扫描：127.0.0.1:6379&gt; scan 881) &quot;92&quot; # 不为0就表示还有更多的 key 可以继续扫描2) 1) &quot;test_data:string:63&quot; 2) &quot;test_data:string:2&quot; 3) &quot;test_data:string:4&quot; 4) &quot;test_data:string:20&quot; 5) &quot;test_data:string:57&quot; 6) &quot;test_data:string:78&quot; 7) &quot;test_data:string:71&quot; 8) &quot;test_data:string:35&quot; 9) &quot;test_data:string:86&quot; 10) &quot;test_data:string:6&quot; 11) &quot;test_data:string:47&quot;……………………………………127.0.0.1:6379&gt; scan 871) &quot;0&quot; # 扫描结束 游标为02) 1) &quot;test_data:68&quot; 2) &quot;test_data:79&quot; 3) &quot;test_data:41&quot; 控制每次获取的 key 数量 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; scan 0 count 201) &quot;92&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot;# 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。# 本示例就返回了21条，比 count 还多了 1 条# 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。 扫描以 test_data:string 开头的 key 123456789101112127.0.0.1:6379&gt; scan 0 match test_data:string*1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 扫描以 test_data:string 开头的 key，并返回 30 条 123456789101112131415161718192021222324252627282930313233343536127.0.0.1:6379&gt; scan 0 match test_data:string* count 301) &quot;10&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot; 22) &quot;test_data:string:48&quot; 23) &quot;test_data:string:74&quot; 24) &quot;test_data:string:67&quot; 25) &quot;test_data:string:26&quot; 26) &quot;test_data:string:60&quot; 27) &quot;test_data:string:36&quot; 28) &quot;test_data:string:49&quot; 29) &quot;test_data:string:3&quot; 30) &quot;test_data:string:44&quot; 31) &quot;test_data:string:68&quot;# 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个# 也有可能比 count 少，甚至为 0 个 扫描以 h_key 开头的 key，并返回 30 条 1234567891011121314151617181920212223242526272829303132333435# 先插入一条记录127.0.0.1:6379&gt; set h_key:1 1OK127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)# 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个# 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回# 并且此时返回的游标也不为0，说明我们还需要继续扫描# 完整的扫描过程如下：127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array) # empty array 也不能说明一定没有127.0.0.1:6379&gt; scan 124 match h_key* count 301) &quot;9&quot;2) (empty array)127.0.0.1:6379&gt; scan 9 match h_key* count 301) &quot;43&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 43 match h_key* count 301) &quot;0&quot; # 只有游标为0时才算扫描结束2) (empty array)# 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)127.0.0.1:6379&gt; scan 124 match h_key* count 601) &quot;75&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 75 match h_key* count 601) &quot;0&quot;2) (empty array) 扫描指定类型的key 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; scan 0 type string1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;# 支持的类型有：# string list set zset hash stream# 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。# 例如，ZSET 和 GEOHASH 都是 zset 类型。127.0.0.1:6379&gt; GEOADD geokey 0 0 value(integer) 1127.0.0.1:6379&gt; type geokeyzset127.0.0.1:6379&gt; ZADD zkey 1000 value(integer) 1127.0.0.1:6379&gt; SCAN 0 TYPE zset count 10001) &quot;0&quot;2) 1) &quot;zkey&quot; 2) &quot;geokey&quot; HSCAN 的基本使用方法 HSCAN 的基本语法如下： 1HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES] 参数解释： 参数 说明 key 键名 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 NOVALUES redis8+增加的属性，只返回key，不返回 value（可选） 为了测试 HSCAN，我们先插入一些数据： 1sh import_unified_data.sh hash 100 使用示例 获取所有 field 和 value： 123456789101112131415127.0.0.1:6379&gt; scan 0 type hash1) &quot;48&quot;2) 1) &quot;test_data:hash:42&quot; 2) &quot;test_data:hash:71&quot; 3) &quot;test_data:hash:54&quot; 4) &quot;test_data:hash:87&quot; 5) &quot;test_data:hash:96&quot; 6) &quot;test_data:hash:49&quot;# 获取 test_data:hash:42 的所有 field 和 value127.0.0.1:6379&gt; hscan test_data:hash:42 01) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 模糊匹配 field： 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 match age*1) &quot;0&quot;2) 1) &quot;age&quot; 2) &quot;62&quot; 模糊匹配 field，并返回 10 条数据： 123456127.0.0.1:6379&gt; hscan test_data:hash:42 0 match *e* count 101) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 不显示value(需要redis8+) 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 novalues1) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;age&quot; SSCAN 的基本使用方法 SSCAN 的基本语法如下： 1SSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 123456789101112131415127.0.0.1:6379&gt; scan 0 type set1) &quot;112&quot;2) 1) &quot;test_data:set:43&quot; 2) &quot;test_data:set:33&quot; 3) &quot;test_data:set:98&quot; 4) &quot;test_data:set:61&quot; 5) &quot;test_data:set:2&quot; 6) &quot;test_data:set:70&quot;127.0.0.1:6379&gt; sscan test_data:set:43 01) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; 模糊匹配元素： 123127.0.0.1:6379&gt; sscan test_data:set:43 0 match *_3*1) &quot;0&quot;2) 1) &quot;set_member_43_3&quot; 返回 1 个元素: 实际上控制不住，大概率会返回所有元素 1234567127.0.0.1:6379&gt; sscan test_data:set:43 0 count 11) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; ZSCAN 的基本使用方法 ZSCAN 的基本语法如下： 1ZSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 1234567891011121314151617181920127.0.0.1:6379&gt; scan 0 type zset1) &quot;112&quot;2) 1) &quot;test_data:zset:89&quot; 2) &quot;test_data:zset:81&quot; 3) &quot;test_data:zset:73&quot; 4) &quot;test_data:zset:79&quot; 5) &quot;test_data:zset:15&quot;127.0.0.1:6379&gt; zscan test_data:zset:89 01) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot; 模糊匹配元素： 1234127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*1) &quot;0&quot;2) 1) &quot;zset_member_89_3&quot; 2) &quot;893&quot; 获取指定key的所有元素，并返回 1 个元素，同样控制不住 123456789101112127.0.0.1:6379&gt; zscan test_data:zset:89 0 count 11) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot;","summary":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-10T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","url":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","title":"Maven 新一代构建工具 mvnd","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Maven 新一代构建工具 mvnd</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/maven-mvnd\">mvnd GitHub</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文安装的是 mvnd 1.0.3。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"mvnd-简介\">mvnd 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p>\n</li>\n</ul>\n<h3 id=\"架构概述\">架构概述</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际构建发生在一个长驻后台进程中，又名守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种架构带来了以下优点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">不需要每次构建重新启动 JVM，大大节省时间。</li>\n<li class=\"lvl-6\">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li>\n<li class=\"lvl-6\">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p>\n</li>\n</ul>\n<h2 id=\"mvnd-安装\">mvnd 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 安装包下载地址：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><a href=\"https://github.com/apache/maven-mvnd/releases\">mvnd Github Release</a></li>\n<li class=\"lvl-6\"><a href=\"https://maven.apache.org/download.cgi\">maven 官网下载页</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>本文以 macOS 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 mvnd 对应的安装包</span></span><br><span class=\"line\">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class=\"line\"><span class=\"comment\"># 添加 mvnd 到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br><span class=\"line\"><span class=\"comment\"># 检查 mvnd 是否安装成功</span></span><br><span class=\"line\">mvnd --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"variable\">$MVND_HOME</span>/conf/mvnd.properties <span class=\"variable\">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>默认值</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>mvnd.noBuffering</strong> <code>[*]</code></td>\n<td>false</td>\n<td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td>\n</tr>\n<tr>\n<td><strong>mvnd.rollingWindowSize</strong></td>\n<td>0</td>\n<td>构建并行模块时，每个模块显示的日志行数</td>\n</tr>\n<tr>\n<td><strong>mvnd.logPurgePeriod</strong></td>\n<td>7d</td>\n<td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.noDaemon</strong></td>\n<td>false</td>\n<td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td>\n</tr>\n<tr>\n<td><strong>mvnd.debug</strong></td>\n<td>false</td>\n<td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.idleTimeout</strong></td>\n<td>3 hours</td>\n<td>守护进程在空闲多久后自动关闭</td>\n</tr>\n<tr>\n<td><strong>mvnd.keepAlive</strong></td>\n<td>100 ms</td>\n<td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxLostKeepAlive</strong></td>\n<td>30</td>\n<td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td>\n</tr>\n<tr>\n<td><strong>mvnd.minThreads</strong></td>\n<td>1</td>\n<td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td>\n</tr>\n<tr>\n<td><strong>mvnd.threads</strong> <code>[*]</code></td>\n<td>未设置</td>\n<td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td>\n</tr>\n<tr>\n<td><strong>mvnd.builder</strong></td>\n<td>smart</td>\n<td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td>\n</tr>\n<tr>\n<td><strong>mvnd.minHeapSize</strong></td>\n<td>128M</td>\n<td>守护进程 JVM 的最小堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td>\n<td>2G</td>\n<td>守护进程 JVM 的最大堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.threadStackSize</strong></td>\n<td>1M</td>\n<td>守护进程线程栈大小</td>\n</tr>\n<tr>\n<td><strong>mvnd.jvmArgs</strong></td>\n<td>未设置</td>\n<td>传递给 daemon 的额外 JVM 参数</td>\n</tr>\n<tr>\n<td><strong>mvnd.enableAssertions</strong></td>\n<td>false</td>\n<td>是否为 daemon 启用 JVM 断言（-ea）</td>\n</tr>\n<tr>\n<td><strong>mvnd.expirationCheckDelay</strong></td>\n<td>10 seconds</td>\n<td>守护进程检测自身是否需要过期的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.duplicateDaemonGracePeriod</strong></td>\n<td>10 seconds</td>\n<td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td>\n</tr>\n<tr>\n<td><strong>mvnd.home</strong></td>\n<td>自动设置</td>\n<td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td>\n</tr>\n<tr>\n<td><strong>java.home</strong></td>\n<td>使用环境变量</td>\n<td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td>\n</tr>\n<tr>\n<td><strong>maven.settings</strong> <code>[*]</code></td>\n<td>~/.m2/settings.xml</td>\n<td>maven 的 settings.xml 路径</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"mvnd-使用\">mvnd 使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行使用方式与 mvn 一样，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvnd clean install</span><br><span class=\"line\">mvnd clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 还有些特殊用法，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class=\"line\">mvnd --status</span><br><span class=\"line\"><span class=\"comment\"># 手动停止所有运行的守护进程</span></span><br><span class=\"line\">mvnd --stop</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"mvnd-与-mvnw-的区别\">mvnd 与 mvnw 的区别</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class=\"line\">mvnw： linux 脚本文件</span><br><span class=\"line\">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>mvnw</code>使用方式如下:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>mvnd</th>\n<th>mvnw（Maven Wrapper）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是什么</td>\n<td>一个「常驻的 Maven 守护进程」</td>\n<td>一个「Maven 启动脚本」</td>\n</tr>\n<tr>\n<td>是否常驻</td>\n<td>✅ 是（daemon）</td>\n<td>❌ 否（一次性）</td>\n</tr>\n<tr>\n<td>是否下载 Maven</td>\n<td>❌ 不下载，自己就是程序</td>\n<td>✅ 会自动下载指定版本</td>\n</tr>\n<tr>\n<td>主要目的</td>\n<td>加速构建</td>\n<td>保证版本一致</td>\n</tr>\n<tr>\n<td>是否推荐在 CI</td>\n<td>一般不建议</td>\n<td>✅ 非常推荐</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td><code>mvnd clean install</code></td>\n<td><code>./mvnw clean install</code></td>\n</tr>\n<tr>\n<td>是否与项目绑定</td>\n<td>❌ 全局使用</td>\n<td>✅ 和项目绑定</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。 mvnd 简介 mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。 mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。 架构概述 mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。 实际构建发生在一个长驻后台进程中，又名守护程序。 一个守护程序实例可以服务来自mvnd客户端的多个连续请求。 mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。 如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。 这种架构带来了以下优点： 不需要每次构建重新启动 JVM，大大节省时间。 持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。 JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。 默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: availableProcessors - 1 mvnd 安装 mvnd 安装包下载地址： mvnd Github Release maven 官网下载页 本文以 macOS 为例 123456789# 下载 mvnd 对应的安装包curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xzln -s mvnd-1.0.3-darwin-amd64 mvnd# 添加 mvnd 到环境变量echo &#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27; &gt;&gt; ~/.zshrcecho &#x27;export PATH=$MVND_HOME/bin:$PATH&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc# 检查 mvnd 是否安装成功mvnd --version mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 ~/.m2/settings.xml ，由于本机之前安装过 Maven，所以这一步就省略了。 [推荐]将 mvnd 的配置文件拷贝到 ~/.m2 目录下 12# 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`cp $MVND_HOME/conf/mvnd.properties $HOME/.m2/mvnd.properties mvnd 配置项说明，一般不需要修改，可能会修改的我用 [*] 做了标注 配置项 默认值 中文解释 mvnd.noBuffering [*] false 是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 -B 或 --batch-mode 也会启用此行为 mvnd.rollingWindowSize 0 构建并行模块时，每个模块显示的日志行数 mvnd.logPurgePeriod 7d 自动清理日志的周期（如：7天），日志保存路径： $HOME/.m2/mvnd/registry/1.0.3/ mvnd.noDaemon false 禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效 mvnd.debug false 使用调试模式启动 daemon，JVM 参数为：-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000 mvnd.idleTimeout 3 hours 守护进程在空闲多久后自动关闭 mvnd.keepAlive 100 ms 如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔 mvnd.maxLostKeepAlive 30 允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败 mvnd.minThreads 1 构建时要使用的最少线程数量。如果显式指定了 -T、--threads 或 mvnd.threads，该值将被忽略 mvnd.threads [*] 未设置 传递给 daemon 的线程数，与 Maven 的 -T / --threads 语法一致 mvnd.builder smart 指定使用的 Maven 构建器名称（等同于 -b 或 --builder） mvnd.minHeapSize 128M 守护进程 JVM 的最小堆内存 mvnd.maxHeapSize [*] 2G 守护进程 JVM 的最大堆内存 mvnd.threadStackSize 1M 守护进程线程栈大小 mvnd.jvmArgs 未设置 传递给 daemon 的额外 JVM 参数 mvnd.enableAssertions false 是否为 daemon 启用 JVM 断言（-ea） mvnd.expirationCheckDelay 10 seconds 守护进程检测自身是否需要过期的时间间隔 mvnd.duplicateDaemonGracePeriod 10 seconds 多个 daemon 存在时，多余 daemon 的宽限退出时间 mvnd.home 自动设置 mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置 java.home 使用环境变量 启动 daemon 的 Java 目录（等同 JAVA_HOME） maven.settings [*] ~/.m2/settings.xml maven 的 settings.xml 路径 mvnd 使用 命令行使用方式与 mvn 一样，比如： 12mvnd clean installmvnd clean package -Dmaven.test.skip=true mvnd 的 daemon 缓存了一切，所以运行 mvnd clean install 后，之后再次运行 mvnd clean install 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。 mvnd 还有些特殊用法，比如： 1234# 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭mvnd --status# 手动停止所有运行的守护进程mvnd --stop 在IDEA中使用mvnd，在Maven设置中将mvnd的安装目录添加到 Maven Home Path 中 mvnd 与 mvnw 的区别 我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件 123.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明 mvn 的 urlmvnw： linux 脚本文件mvnw.cmd： windows 脚本文件 实际上 mvnw 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。 第一次使用mvnw时会通过wrapper/maven-wrapper.properties 文件中的声明自动下载maven，并保存在 ~/.m2/wrapper/dists/ 目录下 mvnw使用方式如下: 1./mvnw clean install 运行速度： mvnd &gt;&gt; mvnw ≈ mvn 对比项 mvnd mvnw（Maven Wrapper） 是什么 一个「常驻的 Maven 守护进程」 一个「Maven 启动脚本」 是否常驻 ✅ 是（daemon） ❌ 否（一次性） 是否下载 Maven ❌ 不下载，自己就是程序 ✅ 会自动下载指定版本 主要目的 加速构建 保证版本一致 是否推荐在 CI 一般不建议 ✅ 非常推荐 使用方式 mvnd clean install ./mvnw clean install 是否与项目绑定 ❌ 全局使用 ✅ 和项目绑定","summary":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。","date_published":"2025-12-07T14:30:05.000Z","tags":["技术","maven","mvnd","mavne","mvnd"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","url":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","title":"Redis 7 + ACL 简介","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 简介</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Redis-ACL-简介\">Redis ACL 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ACL 可以控制的维度包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">谁能登录（用户、密码）</li>\n<li class=\"lvl-5\">可以执行哪些命令</li>\n<li class=\"lvl-5\">可以访问哪些 key（按前缀 / 正则）</li>\n<li class=\"lvl-5\">可否通过网络访问</li>\n<li class=\"lvl-5\">是否启用 / 禁用某个用户</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p>\n</li>\n</ul>\n<h2 id=\"Redis-ACL-的使用\">Redis ACL 的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>redis.conf</code> 中添加如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 ACL 文件</span></span><br><span class=\"line\">aclfile /etc/redis/users.acl</span><br><span class=\"line\"><span class=\"comment\"># 关闭 密码</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p>\n</li>\n</ul>\n<h3 id=\"ACL-的配置方式\">ACL 的配置方式</h3>\n<h4 id=\"直接编辑-aclfile\">直接编辑 aclfile</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置一个管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个应用用户</span></span><br><span class=\"line\">user appuser on  ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span> &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个只读用户</span></span><br><span class=\"line\">user <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p>\n</li>\n<li class=\"lvl-2\">\n<p>格式说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用 off: 禁用</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+<span class=\"built_in\">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class=\"built_in\">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class=\"built_in\">cat</span> 命令查看，以@开头，比如 @<span class=\"built_in\">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class=\"line\">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上就是一个超级管理员权限</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class=\"line\"><span class=\"comment\"># 如果设置了 requirepass 密码</span></span><br><span class=\"line\">user default on sanitize-payload <span class=\"comment\">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 连接时直接登录, --pass == -a</span></span><br><span class=\"line\">redis-cli --user username --pass password -h host -p port</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"><span class=\"comment\"># 本机登录</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@</span><br><span class=\"line\"><span class=\"comment\"># 本机登录时端口不是默认的6379时</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@:6380</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先连接后登录</span></span><br><span class=\"line\">redis-cli -h host -p port</span><br><span class=\"line\">&gt; auth username password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ACL 规则中文说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>规则 / 语法</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>on</code></td>\n<td>启用用户：可以使用该用户进行认证登录</td>\n</tr>\n<tr>\n<td><code>off</code></td>\n<td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td>\n</tr>\n<tr>\n<td><code>skip-sanitize-payload</code></td>\n<td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td>\n</tr>\n<tr>\n<td><code>sanitize-payload</code></td>\n<td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;</code></td>\n<td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td>\n</tr>\n<tr>\n<td><code>-&lt;command&gt;</code></td>\n<td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td>\n</tr>\n<tr>\n<td><code>+@&lt;category&gt;</code></td>\n<td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td>\n</tr>\n<tr>\n<td><code>@all</code></td>\n<td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;|first-arg</code></td>\n<td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td>\n</tr>\n<tr>\n<td><code>allcommands</code></td>\n<td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td>\n</tr>\n<tr>\n<td><code>nocommands</code></td>\n<td><code>-@all</code> 的别名，禁止所有命令</td>\n</tr>\n<tr>\n<td><code>~&lt;pattern&gt;</code></td>\n<td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td>\n</tr>\n<tr>\n<td><code>%R~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许读取</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>%W~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许写入</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>allkeys</code></td>\n<td><code>~*</code> 的别名，允许所有 key</td>\n</tr>\n<tr>\n<td><code>resetkeys</code></td>\n<td>清空允许访问的 key 模式</td>\n</tr>\n<tr>\n<td><code>&amp;&lt;pattern&gt;</code></td>\n<td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td>\n</tr>\n<tr>\n<td><code>allchannels</code></td>\n<td><code>&amp;*</code> 的别名，允许所有 channel</td>\n</tr>\n<tr>\n<td><code>resetchannels</code></td>\n<td>清空 Pub/Sub channel 模式列表</td>\n</tr>\n<tr>\n<td><code>&gt;&lt;password&gt;</code></td>\n<td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;password&gt;</code></td>\n<td>移除指定密码</td>\n</tr>\n<tr>\n<td><code>nopass</code></td>\n<td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td>\n</tr>\n<tr>\n<td><code>resetpass</code></td>\n<td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td>\n</tr>\n<tr>\n<td><code>(&lt;options&gt;)</code></td>\n<td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td>\n</tr>\n<tr>\n<td><code>clearselectors</code></td>\n<td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通过-ACL-命令\">通过 ACL 命令</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png\" alt=\"\"></p>\n<h5 id=\"ACL-SETUSER\">ACL SETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建/修改用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 default 用户</span></span><br><span class=\"line\">ACL SETUSER default off</span><br><span class=\"line\"><span class=\"comment\"># 创建一个管理员</span></span><br><span class=\"line\">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 创建一个普通用户</span></span><br><span class=\"line\">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个只读用户</span></span><br><span class=\"line\">ACL SETUSER <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一次执行</span></span><br><span class=\"line\">ACL SETUSER testuser on ~* -@all +@<span class=\"built_in\">read</span> +ping  &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 第二次执行，只添加新的权限</span></span><br><span class=\"line\">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行后的结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"修改用户权限\">修改用户权限</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重置权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重置所有权限</span></span><br><span class=\"line\">ACL SETUSER testuser reset</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>取消密码，但保留权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser nopass</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：取消密码</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有频道</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LIST\">ACL LIST</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以通过如下命令查看当前 Redis 中所有的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LIST</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用</span><br><span class=\"line\">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class=\"line\">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-SAVE\">ACL SAVE</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SAVE</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p>\n</li>\n</ul>\n<h5 id=\"ACL-LOAD\">ACL LOAD</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOAD</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-USERS\">ACL USERS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>列出所有已创建的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL USERS</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;appuser&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;default&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-GETUSER\">ACL GETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取指定用户的权限信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL GETUSER appuser</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;flags&quot;</span></span><br><span class=\"line\"> 2) 1) <span class=\"string\">&quot;on&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;sanitize-payload&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;passwords&quot;</span></span><br><span class=\"line\"> 4) 1) <span class=\"string\">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;commands&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;-@all +get +set&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;keys&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;~cache:*&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;channels&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;&amp;app:*&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;selectors&quot;</span></span><br><span class=\"line\">12) (empty array)</span><br></pre></td></tr></table></figure>\n<h6 id=\"selectors-选择器规则\">selectors(选择器规则)</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以前 = 一个用户一条规则</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根权限（全局规则）</span></span><br><span class=\"line\">ACL SETUSER selectoruser on ~cache:* +get +<span class=\"built_in\">set</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>现在 = 一个用户可以有多个“权限分身”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 选择器规则</span></span><br><span class=\"line\"><span class=\"comment\"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class=\"line\">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class=\"built_in\">set</span>) &gt;123456</span><br><span class=\"line\"><span class=\"comment\">## 翻译后的结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DELUSER\">ACL DELUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除一个用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-WHOAMI\">ACL WHOAMI</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取当前登录的用户名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL WHOAMI</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-CAT\">ACL CAT</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取所有权限类别</p>\n</li>\n<li class=\"lvl-2\">\n<p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有权限类别</span></span><br><span class=\"line\">ACL CAT</span><br><span class=\"line\"><span class=\"comment\"># 获取指定类别中的命令列表</span></span><br><span class=\"line\">ACL CAT 分类名称</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DRYRUN\">ACL DRYRUN</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 7.0.0 新增。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class=\"line\"><span class=\"string\">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOG\">ACL LOG</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOG          <span class=\"comment\"># 查看默认最新的 ACL 日志条目</span></span><br><span class=\"line\">ACL LOG RESET    <span class=\"comment\"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>日志格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) <span class=\"string\">&quot;count&quot;</span> =&gt; 1</span><br><span class=\"line\">   2) <span class=\"string\">&quot;reason&quot;</span> =&gt; <span class=\"string\">&quot;command&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;context&quot;</span> =&gt; <span class=\"string\">&quot;toplevel&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;object&quot;</span> =&gt; <span class=\"string\">&quot;acl|log&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;username&quot;</span> =&gt; <span class=\"string\">&quot;selectoruser&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class=\"line\">   7) <span class=\"string\">&quot;client-info&quot;</span> =&gt; <span class=\"string\">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class=\"line\">   8) <span class=\"string\">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class=\"line\">   9) <span class=\"string\">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class=\"line\">   10) <span class=\"string\">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>count</code></td>\n<td>触发该日志的次数。比如同一事件触发 1 次就是 1</td>\n</tr>\n<tr>\n<td><code>reason</code></td>\n<td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td>\n</tr>\n<tr>\n<td><code>object</code></td>\n<td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td>触发事件的用户</td>\n</tr>\n<tr>\n<td><code>age-seconds</code></td>\n<td>事件距离当前的时间（秒），越大表示越久远</td>\n</tr>\n<tr>\n<td><code>client-info</code></td>\n<td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td>\n</tr>\n<tr>\n<td><code>entry-id</code></td>\n<td>日志条目 ID</td>\n</tr>\n<tr>\n<td><code>timestamp-created</code></td>\n<td>日志创建时间（毫秒）</td>\n</tr>\n<tr>\n<td><code>timestamp-last-updated</code></td>\n<td>日志最后更新时间（毫秒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"ACL-GENPASS\">ACL GENPASS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成一个随机的 ACL 密码</p>\n</li>\n<li class=\"lvl-2\">\n<p>生成复杂密码的工具有很多，没必要用这玩意。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class=\"line\">&gt; ACL GENPASS</span><br><span class=\"line\"><span class=\"string\">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，32/4 = 8</span></span><br><span class=\"line\">&gt; ACL GENPASS 32</span><br><span class=\"line\"><span class=\"string\">&quot;355ef3dd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class=\"line\">&gt; ACL GENPASS 5</span><br><span class=\"line\"><span class=\"string\">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis ACL 简介 从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。 ACL 可以控制的维度包括： 谁能登录（用户、密码） 可以执行哪些命令 可以访问哪些 key（按前缀 / 正则） 可否通过网络访问 是否启用 / 禁用某个用户 一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离 Redis ACL 的使用 在 redis.conf 中添加如下内容： 1234# 指定 ACL 文件aclfile /etc/redis/users.acl# 关闭 密码# requirepass foobared 也可以不配置 aclfile，而是将用户信息直接编写在 redis.conf 中，但不建议这样做。 ACL 的配置方式 直接编辑 aclfile 创建一个 users.acl 文件，并写入如下内容： 123456# 配置一个管理员user admin on ~* &amp;* +@all &gt;password# 配置一个应用用户user appuser on ~cache:* &amp;app:* +get +set &gt;password# 配置一个只读用户user readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。 格式说明 1234567user: 固定前缀username: 用户名on: 启用 off: 禁用~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格 为了兼容以前的版本，Redis 提供了一个默认的用户：default，不指定用户名的时候，默认使用的就是 default 用户，其对应的acl权限为 1234# 实际上就是一个超级管理员权限user default on nopass sanitize-payload ~* &amp;* +@all# 如果设置了 requirepass 密码user default on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all 开启ACL后，推荐关闭 default 用户。 12# 关闭默认用户，禁止匿名访问user default off 登录redis 12345678910111213# 连接时直接登录, --pass == -aredis-cli --user username --pass password -h host -p port# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 本机登录redis-cli -u redis://admin:123456@# 本机登录时端口不是默认的6379时redis-cli -u redis://admin:123456@:6380# 先连接后登录redis-cli -h host -p port&gt; auth username password Redis ACL 规则中文说明 规则 / 语法 中文说明 on 启用用户：可以使用该用户进行认证登录 off 禁用用户：无法再使用该用户认证，但已认证的连接仍然有效 skip-sanitize-payload 跳过对 RESTORE 命令的 dump 数据载荷过滤（跳过安全检查） sanitize-payload 对 RESTORE 命令的 dump 数据载荷进行过滤（默认） +&lt;command&gt; 允许执行指定命令；可以指定子命令，例如：+config | get -&lt;command&gt; 禁止执行指定命令；可以指定子命令，例如：-config | set +@&lt;category&gt; 允许一个命令分类的所有命令，如：@admin, @set, @sortedset 等。完整分类在 server.c 的命令表中 @all 特殊分类，表示所有当前已有命令 + 未来模块加载的命令 +&lt;command&gt;|first-arg 只允许使用某命令的第一个参数（已废弃，将可能移除）；只支持新增，不支持禁止（如 -SELECT|1 不允许） allcommands +@all 的别名，允许所有命令（包括将来可能加载的模块命令） nocommands -@all 的别名，禁止所有命令 ~&lt;pattern&gt; 添加允许访问的 key 模式（glob 风格），如：~user:*；可以有多个 %R~&lt;pattern&gt; 添加允许读取的 key 模式 %W~&lt;pattern&gt; 添加允许写入的 key 模式 allkeys ~* 的别名，允许所有 key resetkeys 清空允许访问的 key 模式 &amp;&lt;pattern&gt; 添加可访问的 Pub/Sub channel 模式（glob 风格），可多个 allchannels &amp;* 的别名，允许所有 channel resetchannels 清空 Pub/Sub channel 模式列表 &gt;&lt;password&gt; 添加密码，例如：&gt;mypass；此指令会清除 nopass 标志 &lt;&lt;password&gt; 移除指定密码 nopass 移除所有密码，且任何密码都可登录。如果用于 default 用户，则新连接无需 AUTH 即自动登录为 default resetpass 清空所有密码，并移除 nopass 状态。此后没有密码将无法认证 reset 重置所有设置：包括 resetpass、resetkeys、resetchannels、allchannels（如果开启 acl-pubsub-default）、off、clearseletors、-@all (&lt;options&gt;) 创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则 clearselectors 删除所有 selector，但不会影响根权限（直接赋给用户的权限） 通过 ACL 命令 ACL SETUSER 创建/修改用户 12345678# 关闭 default 用户ACL SETUSER default off# 创建一个管理员ACL SETUSER admin on ~* &amp;* +@all &gt;password# 创建一个普通用户ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +set# 创建一个只读用户ACL SETUSER readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 可以看的出来，ACL SETUSER 后面的命令格式与直接编辑 users.acl 文件是一样的 这里要注意 ACL SETUSER 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如： 1234# 第一次执行ACL SETUSER testuser on ~* -@all +@read +ping &gt;password# 第二次执行，只添加新的权限ACL SETUSER testuser +info +client +config|get 运行后的结果 1&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 修改用户权限 重置权限 1234# 重置所有权限ACL SETUSER testuser reset## 运行结果：去除所有频道和命令权限，禁止登录&quot;user testuser off sanitize-payload resetchannels -@all&quot; 取消密码，但保留权限 123ACL SETUSER testuser nopass## 运行结果：取消密码&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot; 去除所有频道 1ACL SETUSER testuser resetchannels 去除所有selectors，关于selectors后面会详细介绍 1ACL SETUSER testuser clearselectors ACL LIST 可以通过如下命令查看当前 Redis 中所有的用户 123456ACL LIST## 输出1) &quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;2) &quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;3) &quot;user default off sanitize-payload resetchannels -@all&quot;4) &quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式 123456789user: 固定前缀username: 用户名on: 启用sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 keyresetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令 ACL SAVE 当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 users.acl 文件中 1ACL SAVE 此时保存的文件内容就是 ACL LIST 命令的输出 ACL LOAD 当修改了 users.acl 文件后，可以通过如下命令将其重新加载到 Redis 中 1ACL LOAD ACL USERS 列出所有已创建的用户 123456ACL USERS## 输出1) &quot;admin&quot;2) &quot;appuser&quot;3) &quot;default&quot;4) &quot;readonly&quot; ACL GETUSER 获取指定用户的权限信息 123456789101112131415ACL GETUSER appuser## 输出1) &quot;flags&quot; 2) 1) &quot;on&quot; 2) &quot;sanitize-payload&quot; 3) &quot;passwords&quot; 4) 1) &quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot; 5) &quot;commands&quot; 6) &quot;-@all +get +set&quot; 7) &quot;keys&quot; 8) &quot;~cache:*&quot; 9) &quot;channels&quot;10) &quot;&amp;app:*&quot;11) &quot;selectors&quot;12) (empty array) selectors(选择器规则) 这里看到最后有一个selectors，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。 以前 = 一个用户一条规则 12# 根权限（全局规则）ACL SETUSER selectoruser on ~cache:* +get +set 现在 = 一个用户可以有多个“权限分身” 12345# 选择器规则# 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +set) &gt;123456## 翻译后的结果&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot; &gt;123456 如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。 ACL DELUSER 删除一个用户 1ACL DELUSER 用户名 ACL WHOAMI 获取当前登录的用户名 1ACL WHOAMI ACL CAT 获取所有权限类别 前面我们在为用户授权时介绍过，@ 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。 ACL CAT 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。 1234# 获取所有权限类别ACL CAT# 获取指定类别中的命令列表ACL CAT 分类名称 这里有一个特殊的权限类别 @all 并不在列出的权限类别中，其表示所有命令。 ACL DRYRUN ACL DRYRUN 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。 Redis 7.0.0 新增。 123456&gt; ACL SETUSER VIRGINIA +SET ~*&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA SET foo bar&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA GET foo&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot; ACL LOG ACL LOG 命令可以查看 ACL 命令执行日志。 它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。 12ACL LOG # 查看默认最新的 ACL 日志条目ACL LOG RESET # 清空 ACL 日志 日志格式 123456789101) &quot;count&quot; =&gt; 1 2) &quot;reason&quot; =&gt; &quot;command&quot; 3) &quot;context&quot; =&gt; &quot;toplevel&quot; 4) &quot;object&quot; =&gt; &quot;acl|log&quot; 5) &quot;username&quot; =&gt; &quot;selectoruser&quot; 6) &quot;age-seconds&quot; =&gt; 1589.819 7) &quot;client-info&quot; =&gt; &quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot; 8) &quot;entry-id&quot; =&gt; 3 9) &quot;timestamp-created&quot; =&gt; 1765089007352 10) &quot;timestamp-last-updated&quot; =&gt; 1765089007352 字段 含义 count 触发该日志的次数。比如同一事件触发 1 次就是 1 reason 日志触发的原因，通常是 command 表示某个命令被执行或被 ACL 检查 context 执行命令的上下文，toplevel 表示直接在客户端执行 object 触发事件的对象，例如 acl|log表示执行了ACL LOG 命令，acl|list表示执行了ACL LIST username 触发事件的用户 age-seconds 事件距离当前的时间（秒），越大表示越久远 client-info 客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等 entry-id 日志条目 ID timestamp-created 日志创建时间（毫秒） timestamp-last-updated 日志最后更新时间（毫秒） ACL GENPASS 生成一个随机的 ACL 密码 生成复杂密码的工具有很多，没必要用这玩意。 该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。 123456789# 默认64个十六进制字符，相当于 ACL GENPASS 256&gt; ACL GENPASS&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;# 指定长度，32/4 = 8&gt; ACL GENPASS 32&quot;355ef3dd&quot;# 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2&gt; ACL GENPASS 5&quot;90&quot;","summary":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-07T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]}]}