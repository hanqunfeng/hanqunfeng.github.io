{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/09/01/springboot3-shardingsphere/","url":"https://blog.hanqunfeng.com/2025/09/01/springboot3-shardingsphere/","title":"SpringBoot3 + ShardingSphere-JDBC5.5.2 分库分表","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 SpringBoot3.5.5 + ShardingSphere-JDBC5.5.2 分库分表的使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://shardingsphere.apache.org/index_zh.html\">ShardingSphere官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/shardingsphere-demo\">本文项目代码Github地址</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"maven依赖\">maven依赖</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 本项目 基于 mysql --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- mybatis plus，本项目用到，非必须 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.baomidou<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ShardingSphere JDBC 主依赖（5.5.2 建议） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shardingsphere-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"application-yml\">application.yml</h2>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">org.apache.shardingsphere.driver.ShardingSphereDriver</span></span><br><span class=\"line\">    <span class=\"comment\"># 指向类路径下的 sharding.yaml（也可 absolute path / file: / http: 等，见官方说明）</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:shardingsphere:classpath:sharding.yaml</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sharding-yaml\">sharding.yaml</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整配置，下文会介绍部分配置</p>\n</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数据源配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/</span></span><br><span class=\"line\"><span class=\"attr\">dataSources:</span></span><br><span class=\"line\">  <span class=\"attr\">ds_0:</span> <span class=\"comment\"># 逻辑数据源名称</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">jdbcUrl:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">ds_1:</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">jdbcUrl:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分片规则配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/</span></span><br><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SHARDING</span> <span class=\"comment\"># 分片规则配置</span></span><br><span class=\"line\">    <span class=\"comment\"># 绑定表：同分片键 join 时走同路由，减少广播,多个逗号分隔，要求分片规则一致</span></span><br><span class=\"line\">    <span class=\"attr\">bindingTables:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">t_order,t_order_item</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">tables:</span> <span class=\"comment\"># 手工分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">course:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.course_$&#123;1..2&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">course_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">cid</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">course_inline</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">cid</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_complex:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_order_complex_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">complex:</span> <span class=\"comment\"># 用于多分片键的复杂分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumns:</span> <span class=\"string\">user_id,order_id</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order-complex-algorithm</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">order_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item_complex:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_order_item_complex_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">complex:</span> <span class=\"comment\"># 用于多分片键的复杂分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumns:</span> <span class=\"string\">user_id,order_id</span>  <span class=\"comment\"># 分片列名称,多个逗号分隔</span></span><br><span class=\"line\"><span class=\"comment\">#             shardingAlgorithmName: t_order_item-class-based-algorithm   # 基于自定义类的分片算法</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_item-class-based-algorithm_spi</span> <span class=\"comment\"># 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">item_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_user_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_user_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">id</span>  <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_user_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">id</span> <span class=\"comment\"># 自增列名称，字符串类型</span></span><br><span class=\"line\"><span class=\"comment\">#           keyGeneratorName: uuid # 分布式序列算法名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">custom_snowflake_string</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#       t_address:      # 普通表（不分库分表，绑定到 ds_0）,没有默认的数据源配置，所以每个都要显示声明</span></span><br><span class=\"line\"><span class=\"comment\">#         actualDataNodes: ds_0.t_address # 实际数据节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">autoTables:</span> <span class=\"comment\"># 自动分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">t_order:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataSources:</span> <span class=\"string\">ds_$&#123;0..1&#125;</span> <span class=\"comment\"># 数据源名称</span></span><br><span class=\"line\">        <span class=\"attr\">shardingStrategy:</span> <span class=\"comment\"># 切分策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">mod_2</span> <span class=\"comment\"># 自动分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">order_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataSources:</span> <span class=\"string\">ds_$&#123;0..1&#125;</span> <span class=\"comment\"># 数据源名称</span></span><br><span class=\"line\">        <span class=\"attr\">shardingStrategy:</span> <span class=\"comment\"># 切分策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">mod_2</span> <span class=\"comment\"># 自动分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">item_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">shardingAlgorithms:</span> <span class=\"comment\"># 分片算法 https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/</span></span><br><span class=\"line\">      <span class=\"attr\">course_inline:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span> <span class=\"comment\"># 基于行表达式的分片算法，这里使用 MOD 会报错</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span> <span class=\"comment\"># 属性</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">course_$&#123;cid</span> <span class=\"string\">%</span> <span class=\"number\">2</span> <span class=\"string\">+</span> <span class=\"number\">1</span><span class=\"string\">&#125;</span> <span class=\"comment\"># 表达式，这是因为表名称为 course_1, course_2</span></span><br><span class=\"line\">          <span class=\"attr\">allow-range-query-with-inline-sharding:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 允许范围查询</span></span><br><span class=\"line\">      <span class=\"attr\">course_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span> <span class=\"comment\"># 表示 ds_0, ds_1</span></span><br><span class=\"line\">      <span class=\"attr\">mod_2:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MOD</span> <span class=\"comment\"># 基于 MOD 的分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">sharding-count:</span> <span class=\"number\">2</span> <span class=\"comment\"># 分片数量，即 对 2 进行取余</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">      <span class=\"attr\">t_order-complex-algorithm:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">COMPLEX_INLINE</span> <span class=\"comment\"># 基于行表达式的复合分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">t_order_complex_$&#123;(user_id</span> <span class=\"string\">+</span> <span class=\"string\">order_id</span> <span class=\"string\">+</span> <span class=\"number\">1</span><span class=\"string\">)</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item-class-based-algorithm:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">CLASS_BASED</span> <span class=\"comment\"># 基于自定义类的分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">strategy:</span> <span class=\"string\">COMPLEX</span> <span class=\"comment\"># 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略</span></span><br><span class=\"line\">          <span class=\"attr\">algorithmClassName:</span> <span class=\"string\">com.hanqf.demo.support.algorithm.OrderItemComplexAlgorithm</span> <span class=\"comment\"># 指定算法类</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item-class-based-algorithm_spi:</span> <span class=\"comment\"># SPI</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">T_ORDER_ITEM_COMPLEX</span> <span class=\"comment\"># 基于自定义类的分片算法</span></span><br><span class=\"line\">      <span class=\"attr\">t_user_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;Math.abs(id.hashCode()%2)&#125;</span></span><br><span class=\"line\">      <span class=\"attr\">t_user_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">t_user_$&#123;Math.abs(id.hashCode()%4).intdiv(2)&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">keyGenerators:</span> <span class=\"comment\"># 分布式主键生成器: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/keygen/</span></span><br><span class=\"line\">      <span class=\"attr\">snowflake:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span> <span class=\"comment\"># 使用雪花算法，Long</span></span><br><span class=\"line\">      <span class=\"attr\">uuid:</span>    <span class=\"comment\"># 定义名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">UUID</span> <span class=\"comment\"># 字符串主键，String</span></span><br><span class=\"line\">      <span class=\"attr\">custom_snowflake_string:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">CUSTOM_SNOWFLAKE_STRING</span>  <span class=\"comment\"># 自定义雪花算法，String</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">workerId:</span> <span class=\"number\">2</span></span><br><span class=\"line\">          <span class=\"attr\">datacenterId:</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!BROADCAST</span>  <span class=\"comment\"># 广播表配置，即所有的库中都包含指定的表，写入数据时同时写入多个库，查询时随机读一个</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dict</span>    <span class=\"comment\"># 广播表名称，⼴播表不能配置分表逻辑，只往多个库的同⼀个表中插⼊数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!ENCRYPT</span>    <span class=\"comment\"># 数据加密配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span>  <span class=\"comment\"># 加密表名称</span></span><br><span class=\"line\">        <span class=\"attr\">columns:</span></span><br><span class=\"line\">          <span class=\"attr\">password:</span> <span class=\"comment\"># 加密列名称</span></span><br><span class=\"line\">            <span class=\"attr\">cipher:</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">password</span> <span class=\"comment\"># 密文列名称</span></span><br><span class=\"line\">              <span class=\"attr\">encryptorName:</span> <span class=\"string\">aes_encryptor</span> <span class=\"comment\"># 密文列加密算法名称</span></span><br><span class=\"line\">    <span class=\"comment\"># 加密算法配置: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/encrypt/</span></span><br><span class=\"line\">    <span class=\"attr\">encryptors:</span></span><br><span class=\"line\">      <span class=\"attr\">aes_encryptor:</span> <span class=\"comment\"># 加解密算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">AES</span> <span class=\"comment\"># 加解密算法类型</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span> <span class=\"comment\"># 加解密算法属性配置</span></span><br><span class=\"line\">          <span class=\"attr\">aes-key-value:</span> <span class=\"string\">123456abc</span>     <span class=\"comment\"># AES 使用的 KEY</span></span><br><span class=\"line\">          <span class=\"attr\">digest-algorithm-name:</span> <span class=\"string\">SHA-1</span> <span class=\"comment\"># AES KEY 的摘要算法</span></span><br><span class=\"line\">      <span class=\"attr\">md5_encryptor:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MD5</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">salt:</span> <span class=\"number\">123456</span>  <span class=\"comment\"># 盐值（可选）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!MASK</span>  <span class=\"comment\"># 数据脱敏配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span>  <span class=\"comment\"># 脱敏表名称</span></span><br><span class=\"line\">        <span class=\"attr\">columns:</span>  <span class=\"comment\"># 脱敏列配置</span></span><br><span class=\"line\">          <span class=\"attr\">password:</span> <span class=\"comment\"># 脱敏列名称</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">md5_mask</span> <span class=\"comment\"># 脱敏算法名称</span></span><br><span class=\"line\">          <span class=\"attr\">email:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">mask_before_special_chars_mask</span></span><br><span class=\"line\">          <span class=\"attr\">telephone:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">keep_first_n_last_m_mask</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">my_mask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">maskAlgorithms:</span> <span class=\"comment\"># 脱敏算法配置</span></span><br><span class=\"line\">      <span class=\"attr\">md5_mask:</span> <span class=\"comment\"># 自定义脱敏算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MD5</span>  <span class=\"comment\"># 脱敏算法类型，md5加密后展示</span></span><br><span class=\"line\">      <span class=\"attr\">mask_before_special_chars_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MASK_BEFORE_SPECIAL_CHARS</span> <span class=\"comment\"># 在特殊字符（比如邮箱里的 @）前面做脱敏，示例：myemail@example.com → *******@example.com</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">special-chars:</span> <span class=\"string\">&#x27;@&#x27;</span>  <span class=\"comment\"># 遇到 @ 之前的部分做脱敏</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&#x27;*&#x27;</span>   <span class=\"comment\"># 脱敏字符用 * 代替</span></span><br><span class=\"line\">      <span class=\"attr\">keep_first_n_last_m_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">KEEP_FIRST_N_LAST_M</span> <span class=\"comment\"># 保留前 n 位和后 m 位，其余用替换字符填充，示例：13812345678 → 138****5678</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">first-n:</span> <span class=\"number\">3</span>     <span class=\"comment\"># 保留前 3 位</span></span><br><span class=\"line\">          <span class=\"attr\">last-m:</span> <span class=\"number\">4</span>      <span class=\"comment\"># 保留后 4 位</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&#x27;*&#x27;</span> <span class=\"comment\"># 脱敏字符用 * 代替</span></span><br><span class=\"line\">      <span class=\"attr\">my_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MY_CUSTOM_MASK</span>  <span class=\"comment\"># 自定义脱敏算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&quot;#&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SINGLE</span> <span class=\"comment\"># 单表规则配置，单表规则优先级高于分库分表规则</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"comment\"># MySQL 风格</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ds_0.t_address</span> <span class=\"comment\"># 加载指定单表</span></span><br><span class=\"line\"><span class=\"comment\">#       - ds_1.* # 加载指定数据源中的全部单表</span></span><br><span class=\"line\"><span class=\"comment\">#       - &quot;*.*&quot; # 加载全部单表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 属性配置：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/props/</span></span><br><span class=\"line\"><span class=\"attr\">props:</span></span><br><span class=\"line\">  <span class=\"attr\">sql-show:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 控制台打印改写后的 SQL，便于排错，默认为 false</span></span><br><span class=\"line\">  <span class=\"attr\">check-table-metadata-enabled:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 在程序启动和更新时，是否检查分片元数据的结构一致性，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数据源配置\">数据源配置</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>hikari + mysql</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dataSources:</span></span><br><span class=\"line\">  <span class=\"attr\">ds_0:</span> <span class=\"comment\"># 逻辑数据源名称</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">jdbcUrl:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">ds_1:</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">jdbcUrl:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>druid + mysql</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dataSources:</span></span><br><span class=\"line\">  <span class=\"attr\">ds_1:</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br><span class=\"line\">    <span class=\"comment\"># Druid 特有配置</span></span><br><span class=\"line\">    <span class=\"attr\">initialSize:</span> <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"attr\">minIdle:</span> <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"attr\">maxActive:</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"attr\">maxWait:</span> <span class=\"number\">60000</span></span><br><span class=\"line\">    <span class=\"attr\">testWhileIdle:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">validationQuery:</span> <span class=\"string\">SELECT</span> <span class=\"number\">1</span> <span class=\"string\">FROM</span> <span class=\"string\">DUAL</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>druid + mysql + p6spy</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dataSources:</span></span><br><span class=\"line\">  <span class=\"attr\">ds_0:</span> <span class=\"comment\"># 逻辑数据源名称</span></span><br><span class=\"line\">    <span class=\"attr\">dataSourceClassName:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">driverClassName:</span> <span class=\"string\">com.p6spy.engine.spy.P6SpyDriver</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:p6spy:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">newpwd</span></span><br><span class=\"line\">    <span class=\"comment\"># Druid 特有配置</span></span><br><span class=\"line\">    <span class=\"attr\">initialSize:</span> <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"attr\">minIdle:</span> <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"attr\">maxActive:</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"attr\">maxWait:</span> <span class=\"number\">60000</span></span><br><span class=\"line\">    <span class=\"attr\">testWhileIdle:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">validationQuery:</span> <span class=\"string\">SELECT</span> <span class=\"number\">1</span> <span class=\"string\">FROM</span> <span class=\"string\">DUAL</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"分库分表配置\">分库分表配置</h3>\n<h4 id=\"单分片键，Long-类型\">单分片键，Long 类型</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SHARDING</span> <span class=\"comment\"># 分片规则配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span> <span class=\"comment\"># 手工分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">course:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.course_$&#123;1..2&#125;</span> <span class=\"comment\"># 实际数据节点，建表时写成了 1和2，懒得改了，所以下面分表规则中对2取余后要+1</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">course_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">cid</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">course_inline</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">cid</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">shardingAlgorithms:</span> <span class=\"comment\"># 分片算法</span></span><br><span class=\"line\">      <span class=\"attr\">course_inline:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span> <span class=\"comment\"># 基于行表达式的分片算法，这里使用 MOD 会报错</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span> <span class=\"comment\"># 属性</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">course_$&#123;cid</span> <span class=\"string\">%</span> <span class=\"number\">2</span> <span class=\"string\">+</span> <span class=\"number\">1</span><span class=\"string\">&#125;</span> <span class=\"comment\"># 表达式，这是因为表名称为 course_1, course_2</span></span><br><span class=\"line\">          <span class=\"attr\">allow-range-query-with-inline-sharding:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 允许范围查询</span></span><br><span class=\"line\">      <span class=\"attr\">course_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span> <span class=\"comment\"># 表示 ds_0, ds_1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">keyGenerators:</span> <span class=\"comment\"># 分布式主键生成器</span></span><br><span class=\"line\">      <span class=\"attr\">snowflake:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span> <span class=\"comment\"># 使用雪花算法，Long</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里分库与分表采用了不同的字段，分库使用 user_id，分表使用 cid</p>\n</li>\n<li class=\"lvl-2\">\n<p>allow-range-query-with-inline-sharding: true ，这里设置为允许范围查询，默认值是 false，不允许 between 查询</p>\n</li>\n</ul>\n<h4 id=\"单分片键，String-类型\">单分片键，String 类型</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SHARDING</span> <span class=\"comment\"># 分片规则配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span> <span class=\"comment\"># 手工分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_user_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_user_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">id</span>  <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_user_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">id</span> <span class=\"comment\"># 自增列名称，字符串类型</span></span><br><span class=\"line\"><span class=\"comment\">#           keyGeneratorName: uuid # 分布式序列算法名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">custom_snowflake_string</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">shardingAlgorithms:</span> <span class=\"comment\"># 分片算法</span></span><br><span class=\"line\">      <span class=\"attr\">t_user_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;Math.abs(id.hashCode()%2)&#125;</span> <span class=\"comment\"># 分库，ds_0, ds_1，id 为字符串，所以要转换为数字再进行运算</span></span><br><span class=\"line\">      <span class=\"attr\">t_user_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">t_user_$&#123;Math.abs(id.hashCode()%4).intdiv(2)&#125;</span> <span class=\"comment\"># 分表，t_user_0, t_user_1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">keyGenerators:</span> <span class=\"comment\"># 分布式序列算法</span></span><br><span class=\"line\">      <span class=\"attr\">uuid:</span>    <span class=\"comment\"># 定义名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">UUID</span> <span class=\"comment\"># 字符串主键，String</span></span><br><span class=\"line\">      <span class=\"attr\">custom_snowflake_string:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">CUSTOM_SNOWFLAKE_STRING</span> <span class=\"comment\"># 自定义雪花算法，String，spi</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">workerId:</span> <span class=\"number\">2</span></span><br><span class=\"line\">          <span class=\"attr\">datacenterId:</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里分库与分表采用了相同的字段，即主键id，因其为字符串类型，所以需要使用 hashCode() 获取数字，再进行运算</p>\n</li>\n<li class=\"lvl-2\">\n<p>主键获取规则使用的自定义的雪花算法，spi，详见<code>src/main/resources/META-INF/services/org.apache.shardingsphere.infra.algorithm.keygen.core.KeyGenerateAlgorithm</code></p>\n</li>\n</ul>\n<h4 id=\"多分片键，Long-类型\">多分片键，Long 类型</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SHARDING</span> <span class=\"comment\"># 分片规则配置</span></span><br><span class=\"line\">    <span class=\"comment\"># 绑定表：同分片键 join 时走同路由，多个逗号分隔，要求分片规则一致</span></span><br><span class=\"line\">    <span class=\"attr\">bindingTables:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">t_order,t_order_item</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">tables:</span> <span class=\"comment\"># 手工分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_complex:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_order_complex_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">complex:</span> <span class=\"comment\"># 用于多分片键的复杂分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumns:</span> <span class=\"string\">user_id,order_id</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order-complex-algorithm</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">order_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item_complex:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataNodes:</span> <span class=\"string\">ds_$&#123;0..1&#125;.t_order_item_complex_$&#123;0..1&#125;</span> <span class=\"comment\"># 实际数据节点</span></span><br><span class=\"line\">        <span class=\"attr\">databaseStrategy:</span> <span class=\"comment\"># 分库策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_db_inline</span> <span class=\"comment\"># 分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">tableStrategy:</span> <span class=\"comment\"># 分表策略</span></span><br><span class=\"line\">          <span class=\"attr\">complex:</span> <span class=\"comment\"># 用于多分片键的复杂分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumns:</span> <span class=\"string\">user_id,order_id</span>  <span class=\"comment\"># 分片列名称,多个逗号分隔</span></span><br><span class=\"line\"><span class=\"comment\">#             shardingAlgorithmName: t_order_item-class-based-algorithm   # 基于自定义类的分片算法</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">t_order_item-class-based-algorithm_spi</span> <span class=\"comment\"># 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">item_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">shardingAlgorithms:</span> <span class=\"comment\"># 分片算法</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_db_inline:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds_$&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">      <span class=\"attr\">t_order-complex-algorithm:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">COMPLEX_INLINE</span> <span class=\"comment\"># 基于行表达式的复合分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">t_order_complex_$&#123;(user_id</span> <span class=\"string\">+</span> <span class=\"string\">order_id</span> <span class=\"string\">+</span> <span class=\"number\">1</span><span class=\"string\">)</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item-class-based-algorithm:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">CLASS_BASED</span> <span class=\"comment\"># 基于自定义类的分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">strategy:</span> <span class=\"string\">COMPLEX</span> <span class=\"comment\"># 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略</span></span><br><span class=\"line\">          <span class=\"attr\">algorithmClassName:</span> <span class=\"string\">com.hanqf.demo.support.algorithm.OrderItemComplexAlgorithm</span> <span class=\"comment\"># 指定算法类</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item-class-based-algorithm_spi:</span> <span class=\"comment\"># SPI</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">T_ORDER_ITEM_COMPLEX</span> <span class=\"comment\"># 基于自定义类的分片算法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">keyGenerators:</span> <span class=\"comment\"># 分布式主键生成器</span></span><br><span class=\"line\">      <span class=\"attr\">snowflake:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span> <span class=\"comment\"># 使用雪花算法，Long</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多个分片键，<code>t_order</code>表使用了内置的<code>COMPLEX_INLINE</code>算法，而<code>t_order_item</code>表使用了自定义的的分片算法，spi，详见<code>src/main/resources/META-INF/services/org.apache.shardingsphere.sharding.spi.ShardingAlgorithm</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>同时这里还配置了<code>bindingTables</code>，用来指定其分片路由一致。</p>\n</li>\n</ul>\n<h4 id=\"自动分片规则\">自动分片规则</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面介绍的都是手工配置分片规则，用于配置较为复杂的分片规则，如果分片规则比价简单，可以使用自动分片规则</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SHARDING</span> <span class=\"comment\"># 分片规则配置</span></span><br><span class=\"line\">    <span class=\"attr\">autoTables:</span> <span class=\"comment\"># 自动分片规则配置</span></span><br><span class=\"line\">      <span class=\"attr\">t_order:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataSources:</span> <span class=\"string\">ds_$&#123;0..1&#125;</span> <span class=\"comment\"># 数据源名称</span></span><br><span class=\"line\">        <span class=\"attr\">shardingStrategy:</span> <span class=\"comment\"># 切分策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">mod_2</span> <span class=\"comment\"># 自动分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">order_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\">      <span class=\"attr\">t_order_item:</span> <span class=\"comment\"># 逻辑表名称</span></span><br><span class=\"line\">        <span class=\"attr\">actualDataSources:</span> <span class=\"string\">ds_$&#123;0..1&#125;</span> <span class=\"comment\"># 数据源名称</span></span><br><span class=\"line\">        <span class=\"attr\">shardingStrategy:</span> <span class=\"comment\"># 切分策略</span></span><br><span class=\"line\">          <span class=\"attr\">standard:</span> <span class=\"comment\"># 用于单分片键的标准分片场景</span></span><br><span class=\"line\">            <span class=\"attr\">shardingColumn:</span> <span class=\"string\">user_id</span> <span class=\"comment\"># 分片列名称</span></span><br><span class=\"line\">            <span class=\"attr\">shardingAlgorithmName:</span> <span class=\"string\">mod_2</span> <span class=\"comment\"># 自动分片算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">keyGenerateStrategy:</span> <span class=\"comment\"># 分布式序列策略</span></span><br><span class=\"line\">          <span class=\"attr\">column:</span> <span class=\"string\">item_id</span> <span class=\"comment\"># 自增列名称</span></span><br><span class=\"line\">          <span class=\"attr\">keyGeneratorName:</span> <span class=\"string\">snowflake</span> <span class=\"comment\"># 分布式序列算法名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">shardingAlgorithms:</span> <span class=\"comment\"># 分片算法</span></span><br><span class=\"line\">      <span class=\"attr\">mod_2:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MOD</span> <span class=\"comment\"># 基于 MOD 的分片算法</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">sharding-count:</span> <span class=\"number\">2</span> <span class=\"comment\"># 分片数量，即 对 2 进行取余</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">keyGenerators:</span> <span class=\"comment\"># 分布式主键生成器</span></span><br><span class=\"line\">      <span class=\"attr\">snowflake:</span> <span class=\"comment\"># 定义名称，在上面引用</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span> <span class=\"comment\"># 使用雪花算法，Long</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>自动分片规则需要声明数据库，但不需要声明表分配规则，其根据分片算法自动确定具体的数据表。</p>\n</li>\n</ul>\n<h3 id=\"广播表配置\">广播表配置</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>广播表，即所有数据源都包含的表，比如字典表</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!BROADCAST</span>  <span class=\"comment\"># 广播表配置，即所有的库中都包含指定的表，写入数据时同时写入多个库，查询时随机读一个</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dict</span>    <span class=\"comment\"># 广播表名称，⼴播表不能配置分表逻辑，只往多个库的同⼀个表中插⼊数据。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数据加密规则\">数据加密规则</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!ENCRYPT</span>    <span class=\"comment\"># 数据加密配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span>  <span class=\"comment\"># 加密表名称</span></span><br><span class=\"line\">        <span class=\"attr\">columns:</span></span><br><span class=\"line\">          <span class=\"attr\">password:</span> <span class=\"comment\"># 加密列名称</span></span><br><span class=\"line\">            <span class=\"attr\">cipher:</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">password</span> <span class=\"comment\"># 密文列名称</span></span><br><span class=\"line\">              <span class=\"attr\">encryptorName:</span> <span class=\"string\">aes_encryptor</span> <span class=\"comment\"># 密文列加密算法名称</span></span><br><span class=\"line\">    <span class=\"comment\"># 加密算法配置: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/encrypt/</span></span><br><span class=\"line\">    <span class=\"attr\">encryptors:</span></span><br><span class=\"line\">      <span class=\"attr\">aes_encryptor:</span> <span class=\"comment\"># 加解密算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">AES</span> <span class=\"comment\"># 加解密算法类型</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span> <span class=\"comment\"># 加解密算法属性配置</span></span><br><span class=\"line\">          <span class=\"attr\">aes-key-value:</span> <span class=\"string\">123456abc</span>     <span class=\"comment\"># AES 使用的 KEY</span></span><br><span class=\"line\">          <span class=\"attr\">digest-algorithm-name:</span> <span class=\"string\">SHA-1</span> <span class=\"comment\"># AES KEY 的摘要算法</span></span><br><span class=\"line\">      <span class=\"attr\">md5_encryptor:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MD5</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">salt:</span> <span class=\"number\">123456</span>  <span class=\"comment\"># 盐值（可选）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置加密字段规则后，新增数据时，会自动对加密字段加密后存储，查询时也会加密后进行比较查询。</p>\n</li>\n</ul>\n<h3 id=\"数据脱敏规则\">数据脱敏规则</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!MASK</span>  <span class=\"comment\"># 数据脱敏配置</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"attr\">t_user:</span>  <span class=\"comment\"># 脱敏表名称</span></span><br><span class=\"line\">        <span class=\"attr\">columns:</span>  <span class=\"comment\"># 脱敏列配置</span></span><br><span class=\"line\">          <span class=\"attr\">password:</span> <span class=\"comment\"># 脱敏列名称</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">md5_mask</span> <span class=\"comment\"># 脱敏算法名称</span></span><br><span class=\"line\">          <span class=\"attr\">email:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">mask_before_special_chars_mask</span></span><br><span class=\"line\">          <span class=\"attr\">telephone:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">keep_first_n_last_m_mask</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span></span><br><span class=\"line\">            <span class=\"attr\">maskAlgorithm:</span> <span class=\"string\">my_mask</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">maskAlgorithms:</span> <span class=\"comment\"># 脱敏算法配置</span></span><br><span class=\"line\">      <span class=\"attr\">md5_mask:</span> <span class=\"comment\"># 自定义脱敏算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MD5</span>  <span class=\"comment\"># 脱敏算法类型，md5加密后展示</span></span><br><span class=\"line\">      <span class=\"attr\">mask_before_special_chars_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MASK_BEFORE_SPECIAL_CHARS</span> <span class=\"comment\"># 在特殊字符（比如邮箱里的 @）前面做脱敏，示例：myemail@example.com → *******@example.com</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">special-chars:</span> <span class=\"string\">&#x27;@&#x27;</span>  <span class=\"comment\"># 遇到 @ 之前的部分做脱敏</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&#x27;*&#x27;</span>   <span class=\"comment\"># 脱敏字符用 * 代替</span></span><br><span class=\"line\">      <span class=\"attr\">keep_first_n_last_m_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">KEEP_FIRST_N_LAST_M</span> <span class=\"comment\"># 保留前 n 位和后 m 位，其余用替换字符填充，示例：13812345678 → 138****5678</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">first-n:</span> <span class=\"number\">3</span>     <span class=\"comment\"># 保留前 3 位</span></span><br><span class=\"line\">          <span class=\"attr\">last-m:</span> <span class=\"number\">4</span>      <span class=\"comment\"># 保留后 4 位</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&#x27;*&#x27;</span> <span class=\"comment\"># 脱敏字符用 * 代替</span></span><br><span class=\"line\">      <span class=\"attr\">my_mask:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">MY_CUSTOM_MASK</span>  <span class=\"comment\"># 自定义脱敏算法名称</span></span><br><span class=\"line\">        <span class=\"attr\">props:</span></span><br><span class=\"line\">          <span class=\"attr\">replace-char:</span> <span class=\"string\">&quot;#&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>被脱敏的字段在查询时会进行脱敏展示。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里还自定义了脱敏算法，spi，详见<code>src/main/resources/META-INF/services/org.apache.shardingsphere.mask.spi.MaskAlgorithm</code></p>\n</li>\n</ul>\n<h3 id=\"单表规则\">单表规则</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即不需要进行分库分表的表</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"type\">!SINGLE</span> <span class=\"comment\"># 单表规则配置，单表规则优先级高于分库分表规则</span></span><br><span class=\"line\">    <span class=\"attr\">tables:</span></span><br><span class=\"line\">      <span class=\"comment\"># MySQL 风格</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ds_0.t_address</span> <span class=\"comment\"># 加载指定单表</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"其它属性配置\">其它属性配置</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 属性配置：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/props/</span></span><br><span class=\"line\"><span class=\"attr\">props:</span></span><br><span class=\"line\">  <span class=\"attr\">sql-show:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 控制台打印改写后的 SQL，便于排错，默认为 false</span></span><br><span class=\"line\">  <span class=\"attr\">check-table-metadata-enabled:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 在程序启动和更新时，是否检查分片元数据的结构一致性，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>springboot3 集成 shardingsphere5.5.2 与 springboot2 不同，不再提供 <code>springboot-starter-shardingsphere</code>，相关配置也采用了独立的配置文件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>代码中包含两个库中使用到的数据库脚本，<code>shardingsphere-demo/shardingsphere-demo-01/sql</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>具体使用效果可以通过项目中提供的单元测试类进行验证。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 SpringBoot3.5.5 + ShardingSphere-JDBC5.5.2 分库分表的使用。 ShardingSphere官网 本文项目代码Github地址 maven依赖 123456789101112131415161718&lt;!-- 本项目 基于 mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- mybatis plus，本项目用到，非必须 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ShardingSphere JDBC 主依赖（5.5.2 建议） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt;&lt;/dependency&gt; application.yml 12345spring: datasource: driver-class-name: org.apache.shardingsphere.driver.ShardingSphereDriver # 指向类路径下的 sharding.yaml（也可 absolute path / file: / http: 等，见官方说明） url: jdbc:shardingsphere:classpath:sharding.yaml sharding.yaml 完整配置，下文会介绍部分配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221# 数据源配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/dataSources: ds_0: # 逻辑数据源名称 dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: newpwd ds_1: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: newpwd# 分片规则配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/rules: - !SHARDING # 分片规则配置 # 绑定表：同分片键 join 时走同路由，减少广播,多个逗号分隔，要求分片规则一致 bindingTables: - t_order,t_order_item tables: # 手工分片规则配置 course: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.course_$&#123;1..2&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: course_db_inline # 分片算法名称 tableStrategy: # 分表策略 standard: shardingColumn: cid shardingAlgorithmName: course_inline keyGenerateStrategy: # 分布式序列策略 column: cid # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_order_complex: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.t_order_complex_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: t_order_db_inline # 分片算法名称 tableStrategy: # 分表策略 complex: # 用于多分片键的复杂分片场景 shardingColumns: user_id,order_id shardingAlgorithmName: t_order-complex-algorithm keyGenerateStrategy: # 分布式序列策略 column: order_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_order_item_complex: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.t_order_item_complex_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: t_order_db_inline # 分片算法名称 tableStrategy: # 分表策略 complex: # 用于多分片键的复杂分片场景 shardingColumns: user_id,order_id # 分片列名称,多个逗号分隔# shardingAlgorithmName: t_order_item-class-based-algorithm # 基于自定义类的分片算法 shardingAlgorithmName: t_order_item-class-based-algorithm_spi # 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI keyGenerateStrategy: # 分布式序列策略 column: item_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_user: actualDataNodes: ds_$&#123;0..1&#125;.t_user_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: id # 分片列名称 shardingAlgorithmName: t_user_db_inline # 分片算法名称 tableStrategy: # 分表策略 standard: shardingColumn: id # 分片列名称 shardingAlgorithmName: t_user_inline # 分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: id # 自增列名称，字符串类型# keyGeneratorName: uuid # 分布式序列算法名称 keyGeneratorName: custom_snowflake_string # 分布式序列算法名称# t_address: # 普通表（不分库分表，绑定到 ds_0）,没有默认的数据源配置，所以每个都要显示声明# actualDataNodes: ds_0.t_address # 实际数据节点 autoTables: # 自动分片规则配置 t_order: # 逻辑表名称 actualDataSources: ds_$&#123;0..1&#125; # 数据源名称 shardingStrategy: # 切分策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: mod_2 # 自动分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: order_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_order_item: # 逻辑表名称 actualDataSources: ds_$&#123;0..1&#125; # 数据源名称 shardingStrategy: # 切分策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: mod_2 # 自动分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: item_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 shardingAlgorithms: # 分片算法 https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/ course_inline: # 定义名称，在上面引用 type: INLINE # 基于行表达式的分片算法，这里使用 MOD 会报错 props: # 属性 algorithm-expression: course_$&#123;cid % 2 + 1&#125; # 表达式，这是因为表名称为 course_1, course_2 allow-range-query-with-inline-sharding: true # 允许范围查询 course_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;user_id % 2&#125; # 表示 ds_0, ds_1 mod_2: type: MOD # 基于 MOD 的分片算法 props: sharding-count: 2 # 分片数量，即 对 2 进行取余 t_order_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;user_id % 2&#125; t_order-complex-algorithm: type: COMPLEX_INLINE # 基于行表达式的复合分片算法 props: algorithm-expression: t_order_complex_$&#123;(user_id + order_id + 1) % 2&#125; t_order_item-class-based-algorithm: type: CLASS_BASED # 基于自定义类的分片算法 props: strategy: COMPLEX # 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略 algorithmClassName: com.hanqf.demo.support.algorithm.OrderItemComplexAlgorithm # 指定算法类 t_order_item-class-based-algorithm_spi: # SPI type: T_ORDER_ITEM_COMPLEX # 基于自定义类的分片算法 t_user_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;Math.abs(id.hashCode()%2)&#125; t_user_inline: type: INLINE props: algorithm-expression: t_user_$&#123;Math.abs(id.hashCode()%4).intdiv(2)&#125; keyGenerators: # 分布式主键生成器: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/keygen/ snowflake: # 定义名称，在上面引用 type: SNOWFLAKE # 使用雪花算法，Long uuid: # 定义名称 type: UUID # 字符串主键，String custom_snowflake_string: type: CUSTOM_SNOWFLAKE_STRING # 自定义雪花算法，String props: workerId: 2 datacenterId: 2 - !BROADCAST # 广播表配置，即所有的库中都包含指定的表，写入数据时同时写入多个库，查询时随机读一个 tables: - dict # 广播表名称，⼴播表不能配置分表逻辑，只往多个库的同⼀个表中插⼊数据。 - !ENCRYPT # 数据加密配置 tables: t_user: # 加密表名称 columns: password: # 加密列名称 cipher: name: password # 密文列名称 encryptorName: aes_encryptor # 密文列加密算法名称 # 加密算法配置: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/encrypt/ encryptors: aes_encryptor: # 加解密算法名称 type: AES # 加解密算法类型 props: # 加解密算法属性配置 aes-key-value: 123456abc # AES 使用的 KEY digest-algorithm-name: SHA-1 # AES KEY 的摘要算法 md5_encryptor: type: MD5 props: salt: 123456 # 盐值（可选） - !MASK # 数据脱敏配置 tables: t_user: # 脱敏表名称 columns: # 脱敏列配置 password: # 脱敏列名称 maskAlgorithm: md5_mask # 脱敏算法名称 email: maskAlgorithm: mask_before_special_chars_mask telephone: maskAlgorithm: keep_first_n_last_m_mask name: maskAlgorithm: my_mask maskAlgorithms: # 脱敏算法配置 md5_mask: # 自定义脱敏算法名称 type: MD5 # 脱敏算法类型，md5加密后展示 mask_before_special_chars_mask: type: MASK_BEFORE_SPECIAL_CHARS # 在特殊字符（比如邮箱里的 @）前面做脱敏，示例：myemail@example.com → *******@example.com props: special-chars: &#x27;@&#x27; # 遇到 @ 之前的部分做脱敏 replace-char: &#x27;*&#x27; # 脱敏字符用 * 代替 keep_first_n_last_m_mask: type: KEEP_FIRST_N_LAST_M # 保留前 n 位和后 m 位，其余用替换字符填充，示例：13812345678 → 138****5678 props: first-n: 3 # 保留前 3 位 last-m: 4 # 保留后 4 位 replace-char: &#x27;*&#x27; # 脱敏字符用 * 代替 my_mask: type: MY_CUSTOM_MASK # 自定义脱敏算法名称 props: replace-char: &quot;#&quot; - !SINGLE # 单表规则配置，单表规则优先级高于分库分表规则 tables: # MySQL 风格 - ds_0.t_address # 加载指定单表# - ds_1.* # 加载指定数据源中的全部单表# - &quot;*.*&quot; # 加载全部单表# 属性配置：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/props/props: sql-show: true # 控制台打印改写后的 SQL，便于排错，默认为 false check-table-metadata-enabled: false # 在程序启动和更新时，是否检查分片元数据的结构一致性，默认为 false 数据源配置 hikari + mysql 1234567891011121314dataSources: ds_0: # 逻辑数据源名称 dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: newpwd ds_1: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: newpwd druid + mysql 1234567891011121314dataSources: ds_1: dataSourceClassName: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&amp;serverTimezone=UTC username: root password: newpwd # Druid 特有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 testWhileIdle: true validationQuery: SELECT 1 FROM DUAL druid + mysql + p6spy 1234567891011121314dataSources: ds_0: # 逻辑数据源名称 dataSourceClassName: com.alibaba.druid.pool.DruidDataSource driverClassName: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&amp;serverTimezone=UTC username: root password: newpwd # Druid 特有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 testWhileIdle: true validationQuery: SELECT 1 FROM DUAL 分库分表配置 单分片键，Long 类型 12345678910111213141516171819202122232425262728293031rules: - !SHARDING # 分片规则配置 tables: # 手工分片规则配置 course: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.course_$&#123;1..2&#125; # 实际数据节点，建表时写成了 1和2，懒得改了，所以下面分表规则中对2取余后要+1 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: course_db_inline # 分片算法名称 tableStrategy: # 分表策略 standard: shardingColumn: cid shardingAlgorithmName: course_inline keyGenerateStrategy: # 分布式序列策略 column: cid # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 shardingAlgorithms: # 分片算法 course_inline: # 定义名称，在上面引用 type: INLINE # 基于行表达式的分片算法，这里使用 MOD 会报错 props: # 属性 algorithm-expression: course_$&#123;cid % 2 + 1&#125; # 表达式，这是因为表名称为 course_1, course_2 allow-range-query-with-inline-sharding: true # 允许范围查询 course_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;user_id % 2&#125; # 表示 ds_0, ds_1 keyGenerators: # 分布式主键生成器 snowflake: # 定义名称，在上面引用 type: SNOWFLAKE # 使用雪花算法，Long 这里分库与分表采用了不同的字段，分库使用 user_id，分表使用 cid allow-range-query-with-inline-sharding: true ，这里设置为允许范围查询，默认值是 false，不允许 between 查询 单分片键，String 类型 123456789101112131415161718192021222324252627282930313233343536rules: - !SHARDING # 分片规则配置 tables: # 手工分片规则配置 t_user: actualDataNodes: ds_$&#123;0..1&#125;.t_user_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: id # 分片列名称 shardingAlgorithmName: t_user_db_inline # 分片算法名称 tableStrategy: # 分表策略 standard: shardingColumn: id # 分片列名称 shardingAlgorithmName: t_user_inline # 分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: id # 自增列名称，字符串类型# keyGeneratorName: uuid # 分布式序列算法名称 keyGeneratorName: custom_snowflake_string # 分布式序列算法名称 shardingAlgorithms: # 分片算法 t_user_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;Math.abs(id.hashCode()%2)&#125; # 分库，ds_0, ds_1，id 为字符串，所以要转换为数字再进行运算 t_user_inline: type: INLINE props: algorithm-expression: t_user_$&#123;Math.abs(id.hashCode()%4).intdiv(2)&#125; # 分表，t_user_0, t_user_1 keyGenerators: # 分布式序列算法 uuid: # 定义名称 type: UUID # 字符串主键，String custom_snowflake_string: type: CUSTOM_SNOWFLAKE_STRING # 自定义雪花算法，String，spi props: workerId: 2 datacenterId: 2 这里分库与分表采用了相同的字段，即主键id，因其为字符串类型，所以需要使用 hashCode() 获取数字，再进行运算 主键获取规则使用的自定义的雪花算法，spi，详见src/main/resources/META-INF/services/org.apache.shardingsphere.infra.algorithm.keygen.core.KeyGenerateAlgorithm 多分片键，Long 类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455rules: - !SHARDING # 分片规则配置 # 绑定表：同分片键 join 时走同路由，多个逗号分隔，要求分片规则一致 bindingTables: - t_order,t_order_item tables: # 手工分片规则配置 t_order_complex: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.t_order_complex_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: t_order_db_inline # 分片算法名称 tableStrategy: # 分表策略 complex: # 用于多分片键的复杂分片场景 shardingColumns: user_id,order_id shardingAlgorithmName: t_order-complex-algorithm keyGenerateStrategy: # 分布式序列策略 column: order_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_order_item_complex: # 逻辑表名称 actualDataNodes: ds_$&#123;0..1&#125;.t_order_item_complex_$&#123;0..1&#125; # 实际数据节点 databaseStrategy: # 分库策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: t_order_db_inline # 分片算法名称 tableStrategy: # 分表策略 complex: # 用于多分片键的复杂分片场景 shardingColumns: user_id,order_id # 分片列名称,多个逗号分隔# shardingAlgorithmName: t_order_item-class-based-algorithm # 基于自定义类的分片算法 shardingAlgorithmName: t_order_item-class-based-algorithm_spi # 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI keyGenerateStrategy: # 分布式序列策略 column: item_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 shardingAlgorithms: # 分片算法 t_order_db_inline: type: INLINE props: algorithm-expression: ds_$&#123;user_id % 2&#125; t_order-complex-algorithm: type: COMPLEX_INLINE # 基于行表达式的复合分片算法 props: algorithm-expression: t_order_complex_$&#123;(user_id + order_id + 1) % 2&#125; t_order_item-class-based-algorithm: type: CLASS_BASED # 基于自定义类的分片算法 props: strategy: COMPLEX # 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略 algorithmClassName: com.hanqf.demo.support.algorithm.OrderItemComplexAlgorithm # 指定算法类 t_order_item-class-based-algorithm_spi: # SPI type: T_ORDER_ITEM_COMPLEX # 基于自定义类的分片算法 keyGenerators: # 分布式主键生成器 snowflake: # 定义名称，在上面引用 type: SNOWFLAKE # 使用雪花算法，Long 多个分片键，t_order表使用了内置的COMPLEX_INLINE算法，而t_order_item表使用了自定义的的分片算法，spi，详见src/main/resources/META-INF/services/org.apache.shardingsphere.sharding.spi.ShardingAlgorithm 同时这里还配置了bindingTables，用来指定其分片路由一致。 自动分片规则 上面介绍的都是手工配置分片规则，用于配置较为复杂的分片规则，如果分片规则比价简单，可以使用自动分片规则 12345678910111213141516171819202122232425262728293031rules: - !SHARDING # 分片规则配置 autoTables: # 自动分片规则配置 t_order: # 逻辑表名称 actualDataSources: ds_$&#123;0..1&#125; # 数据源名称 shardingStrategy: # 切分策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: mod_2 # 自动分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: order_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 t_order_item: # 逻辑表名称 actualDataSources: ds_$&#123;0..1&#125; # 数据源名称 shardingStrategy: # 切分策略 standard: # 用于单分片键的标准分片场景 shardingColumn: user_id # 分片列名称 shardingAlgorithmName: mod_2 # 自动分片算法名称 keyGenerateStrategy: # 分布式序列策略 column: item_id # 自增列名称 keyGeneratorName: snowflake # 分布式序列算法名称 shardingAlgorithms: # 分片算法 mod_2: type: MOD # 基于 MOD 的分片算法 props: sharding-count: 2 # 分片数量，即 对 2 进行取余 keyGenerators: # 分布式主键生成器 snowflake: # 定义名称，在上面引用 type: SNOWFLAKE # 使用雪花算法，Long 自动分片规则需要声明数据库，但不需要声明表分配规则，其根据分片算法自动确定具体的数据表。 广播表配置 广播表，即所有数据源都包含的表，比如字典表 1234rules: - !BROADCAST # 广播表配置，即所有的库中都包含指定的表，写入数据时同时写入多个库，查询时随机读一个 tables: - dict # 广播表名称，⼴播表不能配置分表逻辑，只往多个库的同⼀个表中插⼊数据。 数据加密规则 1234567891011121314151617181920rules: - !ENCRYPT # 数据加密配置 tables: t_user: # 加密表名称 columns: password: # 加密列名称 cipher: name: password # 密文列名称 encryptorName: aes_encryptor # 密文列加密算法名称 # 加密算法配置: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/encrypt/ encryptors: aes_encryptor: # 加解密算法名称 type: AES # 加解密算法类型 props: # 加解密算法属性配置 aes-key-value: 123456abc # AES 使用的 KEY digest-algorithm-name: SHA-1 # AES KEY 的摘要算法 md5_encryptor: type: MD5 props: salt: 123456 # 盐值（可选） 配置加密字段规则后，新增数据时，会自动对加密字段加密后存储，查询时也会加密后进行比较查询。 数据脱敏规则 1234567891011121314151617181920212223242526272829303132rules: - !MASK # 数据脱敏配置 tables: t_user: # 脱敏表名称 columns: # 脱敏列配置 password: # 脱敏列名称 maskAlgorithm: md5_mask # 脱敏算法名称 email: maskAlgorithm: mask_before_special_chars_mask telephone: maskAlgorithm: keep_first_n_last_m_mask name: maskAlgorithm: my_mask maskAlgorithms: # 脱敏算法配置 md5_mask: # 自定义脱敏算法名称 type: MD5 # 脱敏算法类型，md5加密后展示 mask_before_special_chars_mask: type: MASK_BEFORE_SPECIAL_CHARS # 在特殊字符（比如邮箱里的 @）前面做脱敏，示例：myemail@example.com → *******@example.com props: special-chars: &#x27;@&#x27; # 遇到 @ 之前的部分做脱敏 replace-char: &#x27;*&#x27; # 脱敏字符用 * 代替 keep_first_n_last_m_mask: type: KEEP_FIRST_N_LAST_M # 保留前 n 位和后 m 位，其余用替换字符填充，示例：13812345678 → 138****5678 props: first-n: 3 # 保留前 3 位 last-m: 4 # 保留后 4 位 replace-char: &#x27;*&#x27; # 脱敏字符用 * 代替 my_mask: type: MY_CUSTOM_MASK # 自定义脱敏算法名称 props: replace-char: &quot;#&quot; 被脱敏的字段在查询时会进行脱敏展示。 这里还自定义了脱敏算法，spi，详见src/main/resources/META-INF/services/org.apache.shardingsphere.mask.spi.MaskAlgorithm 单表规则 即不需要进行分库分表的表 12345rules: - !SINGLE # 单表规则配置，单表规则优先级高于分库分表规则 tables: # MySQL 风格 - ds_0.t_address # 加载指定单表 其它属性配置 1234# 属性配置：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/props/props: sql-show: true # 控制台打印改写后的 SQL，便于排错，默认为 false check-table-metadata-enabled: false # 在程序启动和更新时，是否检查分片元数据的结构一致性，默认为 false 后记 springboot3 集成 shardingsphere5.5.2 与 springboot2 不同，不再提供 springboot-starter-shardingsphere，相关配置也采用了独立的配置文件。 代码中包含两个库中使用到的数据库脚本，shardingsphere-demo/shardingsphere-demo-01/sql 具体使用效果可以通过项目中提供的单元测试类进行验证。","summary":"摘要 本文介绍 SpringBoot3.5.5 + ShardingSphere-JDBC5.5.2 分库分表的使用。 ShardingSphere官网 本文项目代码Github地址","date_published":"2025-09-01T13:30:05.000Z","tags":["技术","springboot","sharding-sphere","springboot","sharding-sphere"]},{"id":"https://blog.hanqunfeng.com/2025/07/25/k8s-ui-rancher/","url":"https://blog.hanqunfeng.com/2025/07/25/k8s-ui-rancher/","title":"K8S UI 之 Rancher","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 UI 管理工具 Rancher ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://ranchermanager.docs.rancher.com/zh/\">Rancher 官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/rancher/rancher\">Rancher Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Rancher-简介\">Rancher 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Rancher 是一个 开源的 Kubernetes 管理平台，用于帮助用户部署、管理和运维多个 Kubernetes 集群，具有易用的 Web UI、权限控制、集群监控、应用管理等功能，广泛应用于企业的云原生平台建设中。</p>\n</li>\n</ul>\n<h2 id=\"部署-Rancher\">部署 Rancher</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://ranchermanager.docs.rancher.com/zh/getting-started/quick-start-guides/deploy-rancher-manager/helm-cli#%E4%BD%BF%E7%94%A8-helm-%E6%9D%A5%E5%AE%89%E8%A3%85-rancher\">使用 Helm 安装 Rancher</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加 rancher 的 Helm 仓库</span></span><br><span class=\"line\">helm repo add rancher-latest https://releases.rancher.com/server-charts/latest</span><br><span class=\"line\"><span class=\"comment\"># 更新 rancher 的 Helm 仓库</span></span><br><span class=\"line\">helm repo update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 rancher 的版本</span></span><br><span class=\"line\">$ helm search repo rancher -l | <span class=\"built_in\">head</span></span><br><span class=\"line\">NAME                  \tCHART VERSION\tAPP VERSION\tDESCRIPTION</span><br><span class=\"line\">rancher-latest/rancher\t2.11.3       \tv2.11.3    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.11.2       \tv2.11.2    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.11.1       \tv2.11.1    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.11.0       \tv2.11.0    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.10.3       \tv2.10.3    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.10.2       \tv2.10.2    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.10.1       \tv2.10.1    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.10.0       \tv2.10.0    \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\">rancher-latest/rancher\t2.9.3        \tv2.9.3     \tInstall Rancher Server to manage Kubernetes clu...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建命名空间</span></span><br><span class=\"line\">kubectl create namespace cattle-system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建证书，证书是机构颁发的</span></span><br><span class=\"line\">kubectl create secret tls tls-rancher-ingress \\</span><br><span class=\"line\">  --key=nginx_ssl/nginx.hanqunfeng.com.key \\</span><br><span class=\"line\">  --cert=nginx_ssl/nginx.hanqunfeng.com.pem \\</span><br><span class=\"line\">  -n cattle-system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 Rancher  --version v2.11.3 可以指定版本，默认最新版</span></span><br><span class=\"line\">helm install rancher rancher-latest/rancher \\</span><br><span class=\"line\">  --namespace cattle-system \\</span><br><span class=\"line\">  --create-namespace \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> hostname=rancher.hanqunfeng.com \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> ingress.tls.source=secret \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> replicas=3 \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> bootstrapPassword=rancher#2025</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --set hostname=rancher.hanqunfeng.com 设置 rancher 的域名</span></span><br><span class=\"line\"><span class=\"comment\"># --set ingress.tls.source=secret 配置 rancher 的证书，名称为 tls-rancher-ingress</span></span><br><span class=\"line\"><span class=\"comment\"># --set replicas=3 设置 rancher 的副本数</span></span><br><span class=\"line\"><span class=\"comment\"># --set bootstrapPassword=rancher#2025 设置 rancher 的初始密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 不过执行上面的安装命令会报错，应该是当前的 rancher 版本不支持 Kubernetes v1.33.2</span></span><br><span class=\"line\">Error: INSTALLATION FAILED: chart requires kubeVersion: &lt; 1.33.0-0 <span class=\"built_in\">which</span> is incompatible with Kubernetes v1.33.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 解决办法</span></span><br><span class=\"line\"><span class=\"comment\"># 下载并解压 rancher 安装包</span></span><br><span class=\"line\">helm pull rancher-latest/rancher --untar --untardir ./</span><br><span class=\"line\"><span class=\"comment\"># 修改其中的 Chart.yaml 文件</span></span><br><span class=\"line\">kubeVersion: &lt; 1.33.0-0 ==&gt; kubeVersion: &lt; 1.34.0-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 rancher</span></span><br><span class=\"line\">helm install rancher rancher \\</span><br><span class=\"line\">  --namespace cattle-system \\</span><br><span class=\"line\">  --create-namespace \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> hostname=rancher.hanqunfeng.com \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> ingress.tls.source=secret \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> replicas=3 \\</span><br><span class=\"line\">  --<span class=\"built_in\">set</span> bootstrapPassword=rancher#2025</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME: rancher</span><br><span class=\"line\">LAST DEPLOYED: Thu Jul 24 23:55:24 2025</span><br><span class=\"line\">NAMESPACE: cattle-system</span><br><span class=\"line\">STATUS: deployed</span><br><span class=\"line\">REVISION: 1</span><br><span class=\"line\">TEST SUITE: None</span><br><span class=\"line\">NOTES:</span><br><span class=\"line\">Rancher Server has been installed.</span><br><span class=\"line\"></span><br><span class=\"line\">NOTE: Rancher may take several minutes to fully initialize. Please standby <span class=\"keyword\">while</span> Certificates are being issued, Containers are started and the Ingress rule comes up.</span><br><span class=\"line\"></span><br><span class=\"line\">Check out our docs at https://rancher.com/docs/</span><br><span class=\"line\"></span><br><span class=\"line\">If you provided your own bootstrap password during installation, browse to https://rancher.hanqunfeng.com to get started.</span><br><span class=\"line\"></span><br><span class=\"line\">If this is the first time you installed Rancher, get started by running this <span class=\"built_in\">command</span> and clicking the URL it generates:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> https://rancher.hanqunfeng.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=<span class=\"string\">&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To get just the bootstrap password on its own, run:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=<span class=\"string\">&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123; &quot;\\n&quot; &#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Happy Containering!</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看创建的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get all,ing -n cattle-system</span><br><span class=\"line\">NAME                                   READY   STATUS      RESTARTS   AGE</span><br><span class=\"line\">pod/helm-operation-8257k               0/2     Completed   0          11m</span><br><span class=\"line\">pod/helm-operation-g8blp               0/2     Completed   0          12m</span><br><span class=\"line\">pod/helm-operation-hwpbp               0/2     Completed   0          10m</span><br><span class=\"line\">pod/helm-operation-qbs5n               0/2     Completed   0          10m</span><br><span class=\"line\">pod/helm-operation-wlptb               0/2     Completed   0          13m</span><br><span class=\"line\">pod/rancher-56689b7d8c-v7hpd           1/1     Running     0          21m</span><br><span class=\"line\">pod/rancher-56689b7d8c-xnrbf           1/1     Running     0          21m</span><br><span class=\"line\">pod/rancher-56689b7d8c-xvqgs           1/1     Running     0          21m</span><br><span class=\"line\">pod/rancher-webhook-5fd5fc44f9-8xwjk   1/1     Running     0          11m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class=\"line\">service/imperative-api-extension   ClusterIP   10.96.188.28   &lt;none&gt;        6666/TCP         15m</span><br><span class=\"line\">service/rancher                    ClusterIP   10.96.21.41    &lt;none&gt;        80/TCP,443/TCP   21m</span><br><span class=\"line\">service/rancher-webhook            ClusterIP   10.96.85.153   &lt;none&gt;        443/TCP          11m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                              READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/rancher           3/3     3            3           21m</span><br><span class=\"line\">deployment.apps/rancher-webhook   1/1     1            1           11m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                         DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/rancher-56689b7d8c           3         3         3       21m</span><br><span class=\"line\">replicaset.apps/rancher-webhook-5fd5fc44f9   1         1         1       11m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                CLASS   HOSTS                    ADDRESS         PORTS     AGE</span><br><span class=\"line\">ingress.networking.k8s.io/rancher   nginx   rancher.hanqunfeng.com   10.211.55.201   80, 443   21m</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>浏览器访问：<a href=\"https://rancher.hanqunfeng.com\">https://rancher.hanqunfeng.com</a>，输入上面设置的密码即可。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果忘记初始密码可以通过如下命令查看密码</span></span><br><span class=\"line\">kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=<span class=\"string\">&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/rHDDMN.png\" alt=\"\"></p>\n<h2 id=\"卸载-Rancher\">卸载 Rancher</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载 Rancher</span></span><br><span class=\"line\">helm uninstall rancher -n cattle-system</span><br><span class=\"line\"><span class=\"comment\"># 删除 cattle-system 命名空间</span></span><br><span class=\"line\">kubectl delete namespace cattle-system</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 UI 管理工具 Rancher ，本文以 CentOS 8 为例。 K8S官网 k8s Github Rancher 官网 Rancher Github Rancher 简介 Rancher 是一个 开源的 Kubernetes 管理平台，用于帮助用户部署、管理和运维多个 Kubernetes 集群，具有易用的 Web UI、权限控制、集群监控、应用管理等功能，广泛应用于企业的云原生平台建设中。 部署 Rancher 使用 Helm 安装 Rancher 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# 添加 rancher 的 Helm 仓库helm repo add rancher-latest https://releases.rancher.com/server-charts/latest# 更新 rancher 的 Helm 仓库helm repo update# 查看 rancher 的版本$ helm search repo rancher -l | headNAME CHART VERSION APP VERSION DESCRIPTIONrancher-latest/rancher 2.11.3 v2.11.3 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.11.2 v2.11.2 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.11.1 v2.11.1 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.11.0 v2.11.0 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.10.3 v2.10.3 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.10.2 v2.10.2 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.10.1 v2.10.1 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.10.0 v2.10.0 Install Rancher Server to manage Kubernetes clu...rancher-latest/rancher 2.9.3 v2.9.3 Install Rancher Server to manage Kubernetes clu...# 创建命名空间kubectl create namespace cattle-system# 创建证书，证书是机构颁发的kubectl create secret tls tls-rancher-ingress \\ --key=nginx_ssl/nginx.hanqunfeng.com.key \\ --cert=nginx_ssl/nginx.hanqunfeng.com.pem \\ -n cattle-system# 安装 Rancher --version v2.11.3 可以指定版本，默认最新版helm install rancher rancher-latest/rancher \\ --namespace cattle-system \\ --create-namespace \\ --set hostname=rancher.hanqunfeng.com \\ --set ingress.tls.source=secret \\ --set replicas=3 \\ --set bootstrapPassword=rancher#2025## 参数说明# --set hostname=rancher.hanqunfeng.com 设置 rancher 的域名# --set ingress.tls.source=secret 配置 rancher 的证书，名称为 tls-rancher-ingress# --set replicas=3 设置 rancher 的副本数# --set bootstrapPassword=rancher#2025 设置 rancher 的初始密码## 不过执行上面的安装命令会报错，应该是当前的 rancher 版本不支持 Kubernetes v1.33.2Error: INSTALLATION FAILED: chart requires kubeVersion: &lt; 1.33.0-0 which is incompatible with Kubernetes v1.33.2## 解决办法# 下载并解压 rancher 安装包helm pull rancher-latest/rancher --untar --untardir ./# 修改其中的 Chart.yaml 文件kubeVersion: &lt; 1.33.0-0 ==&gt; kubeVersion: &lt; 1.34.0-0# 安装 rancherhelm install rancher rancher \\ --namespace cattle-system \\ --create-namespace \\ --set hostname=rancher.hanqunfeng.com \\ --set ingress.tls.source=secret \\ --set replicas=3 \\ --set bootstrapPassword=rancher#2025## 输出NAME: rancherLAST DEPLOYED: Thu Jul 24 23:55:24 2025NAMESPACE: cattle-systemSTATUS: deployedREVISION: 1TEST SUITE: NoneNOTES:Rancher Server has been installed.NOTE: Rancher may take several minutes to fully initialize. Please standby while Certificates are being issued, Containers are started and the Ingress rule comes up.Check out our docs at https://rancher.com/docs/If you provided your own bootstrap password during installation, browse to https://rancher.hanqunfeng.com to get started.If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates:echo https://rancher.hanqunfeng.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#x27;)To get just the bootstrap password on its own, run:kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123; &quot;\\n&quot; &#125;&#125;&#x27;Happy Containering! 查看创建的资源 123456789101112131415161718192021222324252627$ k get all,ing -n cattle-systemNAME READY STATUS RESTARTS AGEpod/helm-operation-8257k 0/2 Completed 0 11mpod/helm-operation-g8blp 0/2 Completed 0 12mpod/helm-operation-hwpbp 0/2 Completed 0 10mpod/helm-operation-qbs5n 0/2 Completed 0 10mpod/helm-operation-wlptb 0/2 Completed 0 13mpod/rancher-56689b7d8c-v7hpd 1/1 Running 0 21mpod/rancher-56689b7d8c-xnrbf 1/1 Running 0 21mpod/rancher-56689b7d8c-xvqgs 1/1 Running 0 21mpod/rancher-webhook-5fd5fc44f9-8xwjk 1/1 Running 0 11mNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/imperative-api-extension ClusterIP 10.96.188.28 &lt;none&gt; 6666/TCP 15mservice/rancher ClusterIP 10.96.21.41 &lt;none&gt; 80/TCP,443/TCP 21mservice/rancher-webhook ClusterIP 10.96.85.153 &lt;none&gt; 443/TCP 11mNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/rancher 3/3 3 3 21mdeployment.apps/rancher-webhook 1/1 1 1 11mNAME DESIRED CURRENT READY AGEreplicaset.apps/rancher-56689b7d8c 3 3 3 21mreplicaset.apps/rancher-webhook-5fd5fc44f9 1 1 1 11mNAME CLASS HOSTS ADDRESS PORTS AGEingress.networking.k8s.io/rancher nginx rancher.hanqunfeng.com 10.211.55.201 80, 443 21m 浏览器访问：https://rancher.hanqunfeng.com，输入上面设置的密码即可。 12# 如果忘记初始密码可以通过如下命令查看密码kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#x27; 卸载 Rancher 1234# 卸载 Rancherhelm uninstall rancher -n cattle-system# 删除 cattle-system 命名空间kubectl delete namespace cattle-system","summary":"摘要 本文介绍 K8S 的 UI 管理工具 Rancher ，本文以 CentOS 8 为例。 K8S官网 k8s Github Rancher 官网 Rancher Github","date_published":"2025-07-25T14:33:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/24/k8s-ui-kubesphere/","url":"https://blog.hanqunfeng.com/2025/07/24/k8s-ui-kubesphere/","title":"K8S UI 之 Kubesphere","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 UI 管理工具 Kubesphere，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubesphere.io/zh/\">Kubesphere 官网</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Kubesphere-简介\">Kubesphere 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>KubeSphere 是一个基于 Kubernetes 构建的 企业级多租户容器管理平台，提供了一套完整的容器平台解决方案，让用户以图形化方式轻松使用 Kubernetes 和 DevOps 能力，不需要深入理解复杂的底层架构。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 K8S 的 Dashboard 相比具有如下优势：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能 / 特性</th>\n<th>Kubernetes Dashboard</th>\n<th><strong>KubeSphere</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 基础资源管理</td>\n<td>✅ 支持</td>\n<td>✅ 更丰富，支持更多细粒度控制</td>\n</tr>\n<tr>\n<td>👥 多租户支持</td>\n<td>❌ 无</td>\n<td>✅ 内建企业级多租户、空间（Workspace）隔离</td>\n</tr>\n<tr>\n<td>🔐 身份认证与权限控制</td>\n<td>⚠️ 需手动整合 RBAC</td>\n<td>✅ 内建用户管理、角色、团队、企业组织架构</td>\n</tr>\n<tr>\n<td>🌐 多集群支持</td>\n<td>❌ 不支持</td>\n<td>✅ 支持跨区域多集群统一管理</td>\n</tr>\n<tr>\n<td>🚀 DevOps（CI/CD 流水线）</td>\n<td>❌ 无</td>\n<td>✅ 内置图形化流水线（Jenkins 驱动）</td>\n</tr>\n<tr>\n<td>📊 监控与指标（Prometheus）</td>\n<td>❌ 手动安装</td>\n<td>✅ 内置，图形化展示 Pod/Node/服务等监控数据</td>\n</tr>\n<tr>\n<td>📁 日志查询与分析（EFK）</td>\n<td>❌ 无</td>\n<td>✅ 内建 Fluent Bit + Elasticsearch + Kibana</td>\n</tr>\n<tr>\n<td>💡 微服务治理（Istio）</td>\n<td>❌ 无</td>\n<td>✅ 可选启用，支持服务拓扑、灰度发布、流量治理等</td>\n</tr>\n<tr>\n<td>🧰 应用商店（Helm 可视化部署）</td>\n<td>❌ 无</td>\n<td>✅ 支持 Helm 应用市场，点击即可安装常见中间件</td>\n</tr>\n<tr>\n<td>🔌 插件架构</td>\n<td>❌ 无</td>\n<td>✅ 支持模块按需启用/关闭</td>\n</tr>\n<tr>\n<td>🧪 容器镜像仓库（Harbor）</td>\n<td>❌ 无</td>\n<td>✅ 可集成或内建 Harbor 容器仓库</td>\n</tr>\n<tr>\n<td>📦 安装复杂度</td>\n<td>✅ 简单</td>\n<td>⚠️ 略复杂，但可按需启用模块</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"部署-Kubesphere\">部署 Kubesphere</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubesphere 对系统资源有最低要求，具体参考<a href=\"https://kubesphere.io/zh/docs/v4.1/03-installation-and-upgrade/01-preparations/01-supported-k8s/\">官网:环境要求</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>部署</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果无法访问 charts.kubesphere.io, 可将 charts.kubesphere.io 替换为 charts.kubesphere.com.cn</span></span><br><span class=\"line\">helm upgrade --install -n kubesphere-system --create-namespace ks-core https://charts.kubesphere.io/main/ks-core-1.1.4.tgz --debug --<span class=\"built_in\">wait</span></span><br><span class=\"line\"><span class=\"comment\">## 安装成功后会输出如下信息：</span></span><br><span class=\"line\">NOTES:</span><br><span class=\"line\">Thank you <span class=\"keyword\">for</span> choosing KubeSphere Helm Chart.</span><br><span class=\"line\"></span><br><span class=\"line\">Please be patient and <span class=\"built_in\">wait</span> <span class=\"keyword\">for</span> several seconds <span class=\"keyword\">for</span> the KubeSphere deployment to complete.</span><br><span class=\"line\"></span><br><span class=\"line\">1. Wait <span class=\"keyword\">for</span> Deployment Completion</span><br><span class=\"line\"></span><br><span class=\"line\">    Confirm that all KubeSphere components are running by executing the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    kubectl get pods -n kubesphere-system</span><br><span class=\"line\">2. Access the KubeSphere Console</span><br><span class=\"line\"></span><br><span class=\"line\">    Once the deployment is complete, you can access the KubeSphere console using the following URL:</span><br><span class=\"line\"></span><br><span class=\"line\">    http://10.211.55.11:30880</span><br><span class=\"line\"></span><br><span class=\"line\">3. Login to KubeSphere Console</span><br><span class=\"line\"></span><br><span class=\"line\">    Use the following credentials to <span class=\"built_in\">log</span> <span class=\"keyword\">in</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    Account: admin</span><br><span class=\"line\">    Password: P@88w0rd</span><br><span class=\"line\"></span><br><span class=\"line\">NOTE: It is highly recommended to change the default password immediately after the first login.</span><br><span class=\"line\">For additional information and details, please visit https://kubesphere.io.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有组件</span></span><br><span class=\"line\">$ kubectl get pod,deploy,svc -n kubesphere-system</span><br><span class=\"line\">NAME                                         READY   STATUS    RESTARTS       AGE</span><br><span class=\"line\">pod/extensions-museum-ffd8bd9d8-fvcw4        1/1     Running   1 (28m ago)    5h5m</span><br><span class=\"line\">pod/ks-apiserver-7b4479d5f5-2k4c9            1/1     Running   2 (27m ago)    5h5m</span><br><span class=\"line\">pod/ks-console-6bd9b9f5d9-xqlzs              1/1     Running   0              26m</span><br><span class=\"line\">pod/ks-controller-manager-547f9fc8c9-5b88z   1/1     Running   10 (27m ago)   5h5m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/extensions-museum       1/1     1            1           5h14m</span><br><span class=\"line\">deployment.apps/ks-apiserver            1/1     1            1           5h14m</span><br><span class=\"line\">deployment.apps/ks-console              1/1     1            1           5h14m</span><br><span class=\"line\">deployment.apps/ks-controller-manager   1/1     1            1           5h14m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class=\"line\">service/extensions-museum       ClusterIP   10.96.95.71    &lt;none&gt;        443/TCP        5h14m</span><br><span class=\"line\">service/ks-apiserver            ClusterIP   10.96.12.106   &lt;none&gt;        80/TCP         5h14m</span><br><span class=\"line\">service/ks-console              NodePort    10.96.55.165   &lt;none&gt;        80:30880/TCP   5h14m</span><br><span class=\"line\">service/ks-controller-manager   ClusterIP   10.96.13.243   &lt;none&gt;        443/TCP        5h14m</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>浏览器访问：<a href=\"http://10.211.55.11:30880\">http://10.211.55.11:30880</a>，输入账号密码：admin/P@88w0rd，首次登录需要修改密码。</p>\n</li>\n</ul>\n<h2 id=\"配置-ingress\">配置 ingress</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create secret tls nginx-tls \\</span><br><span class=\"line\">    --key=nginx_ssl/nginx.hanqunfeng.com.key \\</span><br><span class=\"line\">    --cert=nginx_ssl/nginx.hanqunfeng.com.pem \\</span><br><span class=\"line\">    -n kubesphere-system</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 ingress</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubesphere-ingress.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">kubesphere-nginx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubesphere-system</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">tls:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">hosts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">kubesphere.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">secretName:</span> <span class=\"string\">nginx-tls</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">kubesphere.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">ks-console</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"卸载-Kubesphere\">卸载 Kubesphere</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm uninstall ks-core -n kubesphere-system</span><br><span class=\"line\">kubectl delete namespace kubesphere-system</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 的 UI 管理工具 Kubesphere，本文以 CentOS 8 为例。 K8S官网 k8s Github Kubesphere 官网 Kubesphere 简介 KubeSphere 是一个基于 Kubernetes 构建的 企业级多租户容器管理平台，提供了一套完整的容器平台解决方案，让用户以图形化方式轻松使用 Kubernetes 和 DevOps 能力，不需要深入理解复杂的底层架构。 与 K8S 的 Dashboard 相比具有如下优势： 功能 / 特性 Kubernetes Dashboard KubeSphere ✅ 基础资源管理 ✅ 支持 ✅ 更丰富，支持更多细粒度控制 👥 多租户支持 ❌ 无 ✅ 内建企业级多租户、空间（Workspace）隔离 🔐 身份认证与权限控制 ⚠️ 需手动整合 RBAC ✅ 内建用户管理、角色、团队、企业组织架构 🌐 多集群支持 ❌ 不支持 ✅ 支持跨区域多集群统一管理 🚀 DevOps（CI/CD 流水线） ❌ 无 ✅ 内置图形化流水线（Jenkins 驱动） 📊 监控与指标（Prometheus） ❌ 手动安装 ✅ 内置，图形化展示 Pod/Node/服务等监控数据 📁 日志查询与分析（EFK） ❌ 无 ✅ 内建 Fluent Bit + Elasticsearch + Kibana 💡 微服务治理（Istio） ❌ 无 ✅ 可选启用，支持服务拓扑、灰度发布、流量治理等 🧰 应用商店（Helm 可视化部署） ❌ 无 ✅ 支持 Helm 应用市场，点击即可安装常见中间件 🔌 插件架构 ❌ 无 ✅ 支持模块按需启用/关闭 🧪 容器镜像仓库（Harbor） ❌ 无 ✅ 可集成或内建 Harbor 容器仓库 📦 安装复杂度 ✅ 简单 ⚠️ 略复杂，但可按需启用模块 部署 Kubesphere Kubesphere 对系统资源有最低要求，具体参考官网:环境要求 部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 如果无法访问 charts.kubesphere.io, 可将 charts.kubesphere.io 替换为 charts.kubesphere.com.cnhelm upgrade --install -n kubesphere-system --create-namespace ks-core https://charts.kubesphere.io/main/ks-core-1.1.4.tgz --debug --wait## 安装成功后会输出如下信息：NOTES:Thank you for choosing KubeSphere Helm Chart.Please be patient and wait for several seconds for the KubeSphere deployment to complete.1. Wait for Deployment Completion Confirm that all KubeSphere components are running by executing the following command: kubectl get pods -n kubesphere-system2. Access the KubeSphere Console Once the deployment is complete, you can access the KubeSphere console using the following URL: http://10.211.55.11:308803. Login to KubeSphere Console Use the following credentials to log in: Account: admin Password: P@88w0rdNOTE: It is highly recommended to change the default password immediately after the first login.For additional information and details, please visit https://kubesphere.io.# 查看所有组件$ kubectl get pod,deploy,svc -n kubesphere-systemNAME READY STATUS RESTARTS AGEpod/extensions-museum-ffd8bd9d8-fvcw4 1/1 Running 1 (28m ago) 5h5mpod/ks-apiserver-7b4479d5f5-2k4c9 1/1 Running 2 (27m ago) 5h5mpod/ks-console-6bd9b9f5d9-xqlzs 1/1 Running 0 26mpod/ks-controller-manager-547f9fc8c9-5b88z 1/1 Running 10 (27m ago) 5h5mNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/extensions-museum 1/1 1 1 5h14mdeployment.apps/ks-apiserver 1/1 1 1 5h14mdeployment.apps/ks-console 1/1 1 1 5h14mdeployment.apps/ks-controller-manager 1/1 1 1 5h14mNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/extensions-museum ClusterIP 10.96.95.71 &lt;none&gt; 443/TCP 5h14mservice/ks-apiserver ClusterIP 10.96.12.106 &lt;none&gt; 80/TCP 5h14mservice/ks-console NodePort 10.96.55.165 &lt;none&gt; 80:30880/TCP 5h14mservice/ks-controller-manager ClusterIP 10.96.13.243 &lt;none&gt; 443/TCP 5h14m 浏览器访问：http://10.211.55.11:30880，输入账号密码：admin/P@88w0rd，首次登录需要修改密码。 配置 ingress 创建证书 1234kubectl create secret tls nginx-tls \\ --key=nginx_ssl/nginx.hanqunfeng.com.key \\ --cert=nginx_ssl/nginx.hanqunfeng.com.pem \\ -n kubesphere-system 创建 ingress 12345678910111213141516171819202122232425# kubesphere-ingress.yamlapiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: kubesphere-nginx namespace: kubesphere-system annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;spec: ingressClassName: nginx tls: - hosts: - kubesphere.hanqunfeng.com secretName: nginx-tls rules: - host: kubesphere.hanqunfeng.com http: paths: - pathType: Prefix path: / backend: service: name: ks-console port: number: 80 卸载 Kubesphere 12helm uninstall ks-core -n kubesphere-systemkubectl delete namespace kubesphere-system","summary":"摘要 本文介绍 K8S 的 UI 管理工具 Kubesphere，本文以 CentOS 8 为例。 K8S官网 k8s Github Kubesphere 官网","date_published":"2025-07-24T14:33:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/24/k8s-ui-dashboard/","url":"https://blog.hanqunfeng.com/2025/07/24/k8s-ui-dashboard/","title":"K8S UI 之 Dashboard","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 UI 管理工具 Dashboard，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/\">Dashboard k8s介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Dashboard-简介\">Dashboard 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Dashboard 是基于网页的 Kubernetes 用户界面。</p>\n</li>\n<li class=\"lvl-2\">\n<p>你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。</p>\n</li>\n<li class=\"lvl-2\">\n<p>你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment、Job、DaemonSet 等等）。 例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。</p>\n</li>\n</ul>\n<h2 id=\"部署-Dashboard\">部署 Dashboard</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes Dashboard 目前仅支持基于 Helm 的安装，因为它速度更快， 并且可以让我们更好地控制 Dashboard 运行所需的所有依赖项。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加 kubernetes-dashboard 仓库</span></span><br><span class=\"line\">helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/</span><br><span class=\"line\"><span class=\"comment\"># 使用 kubernetes-dashboard Chart 部署名为 `kubernetes-dashboard` 的 Helm Release</span></span><br><span class=\"line\">$ helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard \\</span><br><span class=\"line\">    --create-namespace \\</span><br><span class=\"line\">    --namespace kubernetes-dashboard</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Release <span class=\"string\">&quot;kubernetes-dashboard&quot;</span> does not exist. Installing it now.</span><br><span class=\"line\">NAME: kubernetes-dashboard</span><br><span class=\"line\">LAST DEPLOYED: Sun Jul  6 00:40:02 2025</span><br><span class=\"line\">NAMESPACE: kubernetes-dashboard</span><br><span class=\"line\">STATUS: deployed</span><br><span class=\"line\">REVISION: 1</span><br><span class=\"line\">TEST SUITE: None</span><br><span class=\"line\">NOTES:</span><br><span class=\"line\">*************************************************************************************************</span><br><span class=\"line\">*** PLEASE BE PATIENT: Kubernetes Dashboard may need a few minutes to get up and become ready ***</span><br><span class=\"line\">*************************************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">Congratulations! You have just installed Kubernetes Dashboard <span class=\"keyword\">in</span> your cluster.</span><br><span class=\"line\"></span><br><span class=\"line\">To access Dashboard run:</span><br><span class=\"line\">  kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443</span><br><span class=\"line\"></span><br><span class=\"line\">NOTE: In <span class=\"keyword\">case</span> port-forward <span class=\"built_in\">command</span> does not work, make sure that kong service name is correct.</span><br><span class=\"line\">      Check the services <span class=\"keyword\">in</span> Kubernetes Dashboard namespace using:</span><br><span class=\"line\">        kubectl -n kubernetes-dashboard get svc</span><br><span class=\"line\"></span><br><span class=\"line\">Dashboard will be available at:</span><br><span class=\"line\">  https://localhost:8443</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 helm 安装的包，注意指定 命名空间</span></span><br><span class=\"line\">$ helm list -n kubernetes-dashboard</span><br><span class=\"line\">NAME                \tNAMESPACE           \tREVISION\tUPDATED                                \tSTATUS  \tCHART                      \tAPP VERSION</span><br><span class=\"line\">kubernetes-dashboard\tkubernetes-dashboard\t1       \t2025-07-24 14:01:06.678570212 +0800 CST\tdeployed\tkubernetes-dashboard-7.13.0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看启动的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl -n kubernetes-dashboard get all</span><br><span class=\"line\">NAME                                                       READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/kubernetes-dashboard-api-568f47ddd7-tx6f8              1/1     Running   0          20m</span><br><span class=\"line\">pod/kubernetes-dashboard-auth-645b944589-t6v2m             1/1     Running   0          20m</span><br><span class=\"line\">pod/kubernetes-dashboard-kong-648658d45f-7qsm9             1/1     Running   0          20m</span><br><span class=\"line\">pod/kubernetes-dashboard-metrics-scraper-547874fcf-87mrv   1/1     Running   0          20m</span><br><span class=\"line\">pod/kubernetes-dashboard-web-7796b9fbbb-xsdlw              1/1     Running   0          20m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class=\"line\">service/kubernetes-dashboard-api               ClusterIP   10.96.149.59    &lt;none&gt;        8000/TCP   20m</span><br><span class=\"line\">service/kubernetes-dashboard-auth              ClusterIP   10.96.145.120   &lt;none&gt;        8000/TCP   20m</span><br><span class=\"line\">service/kubernetes-dashboard-kong-proxy        ClusterIP   10.96.171.40    &lt;none&gt;        443/TCP    20m</span><br><span class=\"line\">service/kubernetes-dashboard-metrics-scraper   ClusterIP   10.96.79.48     &lt;none&gt;        8000/TCP   20m</span><br><span class=\"line\">service/kubernetes-dashboard-web               ClusterIP   10.96.247.143   &lt;none&gt;        8000/TCP   20m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/kubernetes-dashboard-api               1/1     1            1           20m</span><br><span class=\"line\">deployment.apps/kubernetes-dashboard-auth              1/1     1            1           20m</span><br><span class=\"line\">deployment.apps/kubernetes-dashboard-kong              1/1     1            1           20m</span><br><span class=\"line\">deployment.apps/kubernetes-dashboard-metrics-scraper   1/1     1            1           20m</span><br><span class=\"line\">deployment.apps/kubernetes-dashboard-web               1/1     1            1           20m</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                                             DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/kubernetes-dashboard-api-568f47ddd7              1         1         1       20m</span><br><span class=\"line\">replicaset.apps/kubernetes-dashboard-auth-645b944589             1         1         1       20m</span><br><span class=\"line\">replicaset.apps/kubernetes-dashboard-kong-648658d45f             1         1         1       20m</span><br><span class=\"line\">replicaset.apps/kubernetes-dashboard-metrics-scraper-547874fcf   1         1         1       20m</span><br><span class=\"line\">replicaset.apps/kubernetes-dashboard-web-7796b9fbbb              1         1         1       20m</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">第一次创建kubernetes-dashboard时，有几个 pod 一直处于 ContainerCreating 状态，通过 describe 命令，查看 pod 的状态发现报如下错误：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning  FailedCreatePodSandBox  4m52s                kubelet            Failed to create pod sandbox: rpc error: code = Unknown desc = failed to setup network <span class=\"keyword\">for</span> sandbox <span class=\"string\">&quot;cfa0b6062fabd77353e6d832ab0e62f96787b4d59346d9e57c28dbc0e19a3127&quot;</span>: plugin <span class=\"built_in\">type</span>=<span class=\"string\">&quot;calico&quot;</span> failed (add): error getting ClusterInformation: connection is unauthorized: Unauthorized</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>这条错误说明：</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">容器网络插件（CNI）使用的是 Calico</li>\n<li class=\"lvl-6\">Calico 在尝试获取 Kubernetes 集群的 ClusterInformation 时 认证失败</li>\n<li class=\"lvl-6\">错误关键词：connection is unauthorized: Unauthorized</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>不确定导致这一问题的原因，我的解决方法是重新安装 Calico</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete -f calico.yaml</span><br><span class=\"line\">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开放代理端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在哪个机器上运行的命令，开放的就是哪个机器的端口</span></span><br><span class=\"line\">kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问：在开放代理端口的机器上使用浏览器访问：<a href=\"https://localhost:8443\">https://localhost:8443</a></p>\n</li>\n</ul>\n<h2 id=\"登录帐号\">登录帐号</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建管理员用户</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># dashboard-adminuser.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span>                    <span class=\"comment\"># 创建 ServiceAccount</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span>                      <span class=\"comment\"># SA 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span>       <span class=\"comment\"># SA 所在命名空间</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRoleBinding</span>                <span class=\"comment\"># 集群角色绑定</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\"><span class=\"attr\">roleRef:</span></span><br><span class=\"line\">  <span class=\"attr\">apiGroup:</span> <span class=\"string\">rbac.authorization.k8s.io</span>   <span class=\"comment\"># 集群角色组，这个是 k8s 内置的</span></span><br><span class=\"line\">  <span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span>                     <span class=\"comment\"># 集群角色</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">cluster-admin</span>                   <span class=\"comment\"># 集群管理员角色</span></span><br><span class=\"line\"><span class=\"attr\">subjects:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span>                  <span class=\"comment\"># 服务账号</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span>                      <span class=\"comment\"># 服务账号名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span>       <span class=\"comment\"># 服务账号命名空间</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建并获取token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f dashboard-adminuser.yaml</span><br><span class=\"line\"><span class=\"comment\"># 获取token，该 token 有效期为 1 小时，token格式为 jwt，可以通过 jwt.io 解析</span></span><br><span class=\"line\">kubectl -n kubernetes-dashboard create token admin-user</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取长效token</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># dashboard-secret.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/service-account.name:</span> <span class=\"string\">&quot;admin-user&quot;</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">kubernetes.io/service-account-token</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f dashboard-secret.yaml</span><br><span class=\"line\"><span class=\"comment\"># 该命令获取token，永不过期，将其保存下来</span></span><br><span class=\"line\">kubectl get secret admin-user -n kubernetes-dashboard -o jsonpath=<span class=\"string\">&quot;&#123;.data.token&#125;&quot;</span> | <span class=\"built_in\">base64</span> -d</span><br></pre></td></tr></table></figure>\n<h2 id=\"卸载-kubernetes-dashboard\">卸载 kubernetes-dashboard</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>卸载 kubernetes-dashboard</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm uninstall kubernetes-dashboard --namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>清理用户信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl -n kubernetes-dashboard delete serviceaccount admin-user</span><br><span class=\"line\">kubectl -n kubernetes-dashboard delete clusterrolebinding admin-user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以直接删除 命名空间，删除命名空间会同时删除所有资源</span></span><br><span class=\"line\">kubectl delete namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 UI 管理工具 Dashboard，本文以 CentOS 8 为例。 K8S官网 k8s Github Dashboard k8s介绍 Dashboard 简介 Dashboard 是基于网页的 Kubernetes 用户界面。 你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。 你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment、Job、DaemonSet 等等）。 例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。 Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。 部署 Dashboard Kubernetes Dashboard 目前仅支持基于 Helm 的安装，因为它速度更快， 并且可以让我们更好地控制 Dashboard 运行所需的所有依赖项。 1234567891011121314151617181920212223242526272829303132333435# 添加 kubernetes-dashboard 仓库helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/# 使用 kubernetes-dashboard Chart 部署名为 `kubernetes-dashboard` 的 Helm Release$ helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard \\ --create-namespace \\ --namespace kubernetes-dashboard## 输出Release &quot;kubernetes-dashboard&quot; does not exist. Installing it now.NAME: kubernetes-dashboardLAST DEPLOYED: Sun Jul 6 00:40:02 2025NAMESPACE: kubernetes-dashboardSTATUS: deployedREVISION: 1TEST SUITE: NoneNOTES:**************************************************************************************************** PLEASE BE PATIENT: Kubernetes Dashboard may need a few minutes to get up and become ready ****************************************************************************************************Congratulations! You have just installed Kubernetes Dashboard in your cluster.To access Dashboard run: kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443NOTE: In case port-forward command does not work, make sure that kong service name is correct. Check the services in Kubernetes Dashboard namespace using: kubectl -n kubernetes-dashboard get svcDashboard will be available at: https://localhost:8443# 查看 helm 安装的包，注意指定 命名空间$ helm list -n kubernetes-dashboardNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSIONkubernetes-dashboard kubernetes-dashboard 1 2025-07-24 14:01:06.678570212 +0800 CST deployed kubernetes-dashboard-7.13.0 查看启动的资源 12345678910111213141516171819202122232425262728$ kubectl -n kubernetes-dashboard get allNAME READY STATUS RESTARTS AGEpod/kubernetes-dashboard-api-568f47ddd7-tx6f8 1/1 Running 0 20mpod/kubernetes-dashboard-auth-645b944589-t6v2m 1/1 Running 0 20mpod/kubernetes-dashboard-kong-648658d45f-7qsm9 1/1 Running 0 20mpod/kubernetes-dashboard-metrics-scraper-547874fcf-87mrv 1/1 Running 0 20mpod/kubernetes-dashboard-web-7796b9fbbb-xsdlw 1/1 Running 0 20mNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes-dashboard-api ClusterIP 10.96.149.59 &lt;none&gt; 8000/TCP 20mservice/kubernetes-dashboard-auth ClusterIP 10.96.145.120 &lt;none&gt; 8000/TCP 20mservice/kubernetes-dashboard-kong-proxy ClusterIP 10.96.171.40 &lt;none&gt; 443/TCP 20mservice/kubernetes-dashboard-metrics-scraper ClusterIP 10.96.79.48 &lt;none&gt; 8000/TCP 20mservice/kubernetes-dashboard-web ClusterIP 10.96.247.143 &lt;none&gt; 8000/TCP 20mNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/kubernetes-dashboard-api 1/1 1 1 20mdeployment.apps/kubernetes-dashboard-auth 1/1 1 1 20mdeployment.apps/kubernetes-dashboard-kong 1/1 1 1 20mdeployment.apps/kubernetes-dashboard-metrics-scraper 1/1 1 1 20mdeployment.apps/kubernetes-dashboard-web 1/1 1 1 20mNAME DESIRED CURRENT READY AGEreplicaset.apps/kubernetes-dashboard-api-568f47ddd7 1 1 1 20mreplicaset.apps/kubernetes-dashboard-auth-645b944589 1 1 1 20mreplicaset.apps/kubernetes-dashboard-kong-648658d45f 1 1 1 20mreplicaset.apps/kubernetes-dashboard-metrics-scraper-547874fcf 1 1 1 20mreplicaset.apps/kubernetes-dashboard-web-7796b9fbbb 1 1 1 20m 小贴士 第一次创建kubernetes-dashboard时，有几个 pod 一直处于 ContainerCreating 状态，通过 describe 命令，查看 pod 的状态发现报如下错误： 1Warning FailedCreatePodSandBox 4m52s kubelet Failed to create pod sandbox: rpc error: code = Unknown desc = failed to setup network for sandbox &quot;cfa0b6062fabd77353e6d832ab0e62f96787b4d59346d9e57c28dbc0e19a3127&quot;: plugin type=&quot;calico&quot; failed (add): error getting ClusterInformation: connection is unauthorized: Unauthorized 这条错误说明： 容器网络插件（CNI）使用的是 Calico Calico 在尝试获取 Kubernetes 集群的 ClusterInformation 时 认证失败 错误关键词：connection is unauthorized: Unauthorized 不确定导致这一问题的原因，我的解决方法是重新安装 Calico 12kubectl delete -f calico.yamlkubectl apply -f calico.yaml 开放代理端口 12# 在哪个机器上运行的命令，开放的就是哪个机器的端口kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443 访问：在开放代理端口的机器上使用浏览器访问：https://localhost:8443 登录帐号 创建管理员用户 12345678910111213141516171819# dashboard-adminuser.yamlapiVersion: v1kind: ServiceAccount # 创建 ServiceAccountmetadata: name: admin-user # SA 名称 namespace: kubernetes-dashboard # SA 所在命名空间---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBinding # 集群角色绑定metadata: name: admin-userroleRef: apiGroup: rbac.authorization.k8s.io # 集群角色组，这个是 k8s 内置的 kind: ClusterRole # 集群角色 name: cluster-admin # 集群管理员角色subjects:- kind: ServiceAccount # 服务账号 name: admin-user # 服务账号名称 namespace: kubernetes-dashboard # 服务账号命名空间 创建并获取token 123kubectl apply -f dashboard-adminuser.yaml# 获取token，该 token 有效期为 1 小时，token格式为 jwt，可以通过 jwt.io 解析kubectl -n kubernetes-dashboard create token admin-user 获取长效token 123456789# dashboard-secret.yamlapiVersion: v1kind: Secretmetadata: name: admin-user namespace: kubernetes-dashboard annotations: kubernetes.io/service-account.name: &quot;admin-user&quot;type: kubernetes.io/service-account-token 123kubectl apply -f dashboard-secret.yaml# 该命令获取token，永不过期，将其保存下来kubectl get secret admin-user -n kubernetes-dashboard -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 -d 卸载 kubernetes-dashboard 卸载 kubernetes-dashboard 1helm uninstall kubernetes-dashboard --namespace kubernetes-dashboard 清理用户信息 12345kubectl -n kubernetes-dashboard delete serviceaccount admin-userkubectl -n kubernetes-dashboard delete clusterrolebinding admin-user# 也可以直接删除 命名空间，删除命名空间会同时删除所有资源kubectl delete namespace kubernetes-dashboard","summary":"摘要 本文介绍 K8S 的 UI 管理工具 Dashboard，本文以 CentOS 8 为例。 K8S官网 k8s Github Dashboard k8s介绍","date_published":"2025-07-24T13:33:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/24/k8s-tools/","url":"https://blog.hanqunfeng.com/2025/07/24/k8s-tools/","title":"K8S 之 Tools","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>K8S 的 Tools: crictl、nerdctl、helm ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"crictl-命令\">crictl 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>crictl</code> 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>crictl</code> 命令默认需要 sudo 权限，如果不想每次都加 sudo，可以将用户加入 containerd 的 socket 权限组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># containerd 的默认 socket 是 /var/run/containerd/containerd.sock</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -l /var/run/containerd/containerd.sock</span><br><span class=\"line\">srw-rw---- 1 root root 0 7月   1 10:57 /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 如果 group 是 root：你可以改为其它组，比如 docker</span></span><br><span class=\"line\"><span class=\"comment\"># 如果 docker 组不存在则创建</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> groupadd docker</span><br><span class=\"line\"><span class=\"comment\"># 修改文件所属组为 docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chgrp</span> docker /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 为组添加读写权限</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> g+rw /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 添加用户到 docker 组</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\"><span class=\"comment\"># 刷新权限</span></span><br><span class=\"line\">newgrp docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时虽然已经可以不用 sudo 了，但是一旦重启 containerd 就会重新回到 root 权限，因此需要添加如下配置</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/containerd.service.d/</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/systemd/system/containerd.service.d/override.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">ExecStartPost=/bin/bash -c &#x27;chmod 660 /run/containerd/containerd.sock &amp;&amp; chgrp docker /run/containerd/containerd.sock&#x27;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>crictl</code> 命令的使用方式比较类似<code>docker</code>命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><code>docker</code> 命令</th>\n<th><code>crictl</code> 命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查看正在运行的容器</td>\n<td><code>docker ps</code></td>\n<td><code>crictl ps</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看所有容器（包括已停止）</td>\n<td><code>docker ps -a</code></td>\n<td><code>crictl ps -a</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看镜像</td>\n<td><code>docker images</code></td>\n<td><code>crictl images</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器日志</td>\n<td><code>docker logs &lt;container_id&gt;</code></td>\n<td><code>crictl logs &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>进入容器交互</td>\n<td><code>docker exec -it &lt;id&gt; sh</code></td>\n<td><code>crictl exec -it &lt;id&gt; sh</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器详细信息</td>\n<td><code>docker inspect &lt;container_id&gt;</code></td>\n<td><code>crictl inspect &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看 Pod 详细信息</td>\n<td>❌（不支持）</td>\n<td><code>crictl inspectp &lt;pod_id&gt;</code></td>\n<td>K8s 专属</td>\n</tr>\n<tr>\n<td>删除容器</td>\n<td><code>docker rm &lt;container_id&gt;</code></td>\n<td><code>crictl rm &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>删除镜像</td>\n<td><code>docker rmi &lt;image_id&gt;</code></td>\n<td><code>crictl rmi &lt;image_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>拉取镜像</td>\n<td><code>docker pull nginx</code></td>\n<td><code>crictl pull nginx</code></td>\n<td></td>\n</tr>\n<tr>\n<td>运行容器（非 K8s 场景）</td>\n<td><code>docker run -it nginx</code></td>\n<td>❌（不支持）</td>\n<td><code>crictl</code> 不运行容器，仅调试现有容器</td>\n</tr>\n<tr>\n<td>列出容器运行时信息</td>\n<td><code>docker info</code></td>\n<td><code>crictl info</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器运行状态</td>\n<td><code>docker stats</code></td>\n<td><code>crictl stats</code></td>\n<td>简要版</td>\n</tr>\n<tr>\n<td>设置配置文件</td>\n<td><code>~/.docker/config.json</code></td>\n<td><code>/etc/crictl.yaml</code></td>\n<td>如设置 endpoint</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"nerdctl\">nerdctl</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/containerd/nerdctl\">nerdctl</a> 是一个 兼容 Docker CLI 的容器命令行工具，用于管理 containerd 容器运行时。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它是 containerd 官方子项目，由 CNCF 维护，其命令语法与 Docker CLI 兼容，目标是让习惯 Docker 的用户也能轻松使用 containerd。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装 nerdctl</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 下载最新版本</span></span><br><span class=\"line\">VERSION=2.1.3</span><br><span class=\"line\">wget https://github.com/containerd/nerdctl/releases/download/v<span class=\"variable\">$&#123;VERSION&#125;</span>/nerdctl-<span class=\"variable\">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 解压</span></span><br><span class=\"line\">tar -xvf nerdctl-<span class=\"variable\">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 移动到系统 PATH</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mv</span> nerdctl /usr/local/bin/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># nerdctl 需要 sudo 权限</span></span><br><span class=\"line\"><span class=\"comment\">## 为 sudo 添加 PATH</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> visudo</span><br><span class=\"line\"><span class=\"comment\">## 找到这一行</span></span><br><span class=\"line\">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br><span class=\"line\"><span class=\"comment\">## 修改为，即将 nerdctl 所在的目录加入 PATH</span></span><br><span class=\"line\">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.测试</span></span><br><span class=\"line\"><span class=\"comment\">## 查看版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> nerdctl version</span><br><span class=\"line\"><span class=\"comment\">## 列出容器，--namespace k8s.io 表示查看 k8s 中的容器</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> nerdctl ps --namespace k8s.io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 如果不想每次都加上 --namespace k8s.io，可以设置别名</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;alias kps=&#x27;sudo nerdctl --namespace=k8s.io ps&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\">## 测试</span></span><br><span class=\"line\">kps</span><br></pre></td></tr></table></figure>\n<h2 id=\"Helm\">Helm</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://helm.sh/zh/docs/\">官网文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Helm 是 Kubernetes 的包管理器，类似于 Linux 下的包管理工具如 yum、apt 等。可以方便的将之前打包好的 yaml 文件部署到 Kunernetes 上。</p>\n</li>\n</ul>\n<h3 id=\"Helm的安装\">Helm的安装</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>官网<a href=\"https://helm.sh/zh/docs/intro/install/\">安装方法</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://get.helm.sh/helm-v3.17.4-linux-amd64.tar.gz</span><br><span class=\"line\">tar -zxvf helm-v3.17.4-linux-amd64.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mv</span> linux-amd64/helm /usr/local/bin/helm</span><br><span class=\"line\">$ helm version</span><br><span class=\"line\">version.BuildInfo&#123;Version:<span class=\"string\">&quot;v3.17.4&quot;</span>, GitCommit:<span class=\"string\">&quot;595a05da6166037d0abebaa27ac8a498fa4d7ed2&quot;</span>, GitTreeState:<span class=\"string\">&quot;clean&quot;</span>, GoVersion:<span class=\"string\">&quot;go1.23.10&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Helm<a href=\"https://helm.sh/zh/docs/helm/helm_completion_bash/\">自动补全</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 helm 的自动补全功能</span></span><br><span class=\"line\"><span class=\"comment\"># 1 当前用户</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source &lt;(helm completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 所有用户</span></span><br><span class=\"line\">helm completion bash | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/bash_completion.d/helm &gt; /dev/null</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> a+r /etc/bash_completion.d/helm</span><br></pre></td></tr></table></figure>\n<h3 id=\"Helm的使用\">Helm的使用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以参考 <a href=\"/2023/07/10/aws-eks14-helm/\" title=\"AWS-EKS-14--Helm\">AWS-EKS-14--Helm</a></p>\n</li>\n</ul>\n<h4 id=\"仓库管理\">仓库管理</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>add：添加图表存储库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>list：列出图表存储库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo list</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>remove：删除图表存储库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo remove bitnami</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>update：从图表存储库更新本地可用图表的信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更新所有仓库</span></span><br><span class=\"line\">helm repo update</span><br><span class=\"line\"><span class=\"comment\"># 更新指定的仓库</span></span><br><span class=\"line\">helm repo update bitnami</span><br></pre></td></tr></table></figure>\n<h4 id=\"在仓库中搜索\">在仓库中搜索</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在所有仓库中搜索，默认只展示最新的版本</span></span><br><span class=\"line\">helm search repo nginx</span><br><span class=\"line\"><span class=\"comment\"># 在指定的仓库中搜索</span></span><br><span class=\"line\">helm search repo bitnami/wordpress</span><br><span class=\"line\"><span class=\"comment\"># 显示所有版本</span></span><br><span class=\"line\">helm search repo nginx -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在全部版本中搜索大于等于指定版本</span></span><br><span class=\"line\">$ helm search repo nginx --version ^21.0.0 -l</span><br><span class=\"line\">NAME         \tCHART VERSION\tAPP VERSION\tDESCRIPTION</span><br><span class=\"line\">bitnami/nginx\t21.0.8       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.7       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.6       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.4       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.3       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.2       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.1       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br><span class=\"line\">bitnami/nginx\t21.0.0       \t1.29.0     \tNGINX Open Source is a web server that can be a...</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装包\">安装包</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装最新版</span></span><br><span class=\"line\">helm install nginx bitnami/nginx</span><br><span class=\"line\"><span class=\"comment\"># 安装指定版本</span></span><br><span class=\"line\">helm install nginx bitnami/nginx --version 21.0.3</span><br><span class=\"line\"><span class=\"comment\"># 安装包到指定命名空间</span></span><br><span class=\"line\">helm install nginx bitnami/nginx -n &lt;namespace&gt;</span><br><span class=\"line\"><span class=\"comment\"># 安装包并创建命名空间</span></span><br><span class=\"line\">helm install nginx bitnami/nginx -n &lt;namespace&gt; --create-namespace</span><br><span class=\"line\"><span class=\"comment\"># oci： 从 docker 仓库中安装</span></span><br><span class=\"line\">helm pull oci://registry-1.docker.io/bitnamicharts/nginx --version 21.0.8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装本地 chart 目录</span></span><br><span class=\"line\">helm install my-release ./nginx</span><br><span class=\"line\"><span class=\"comment\"># 安装 .tgz 格式的打包 chart</span></span><br><span class=\"line\">helm install my-release ./nginx-1.2.3.tgz</span><br><span class=\"line\"><span class=\"comment\"># 从远程tgz安装</span></span><br><span class=\"line\">helm install my-release https://example.com/charts/nginx-1.2.3.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 Git 仓库中的 chart（结合 plugin）</span></span><br><span class=\"line\">helm plugin install https://github.com/aslafy-z/helm-git</span><br><span class=\"line\">helm repo add mychart <span class=\"string\">&#x27;git+https://github.com/myorg/mychart.git&#x27;</span></span><br><span class=\"line\">helm install my-release mychart/nginx</span><br><span class=\"line\"><span class=\"comment\"># 卸载helm-git插件</span></span><br><span class=\"line\">helm plugin remove helm-git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 --set 传递单个或多个值</span></span><br><span class=\"line\">helm install my-release bitnami/nginx --<span class=\"built_in\">set</span> service.type=NodePort</span><br><span class=\"line\"><span class=\"comment\"># 使用 --values 或 -f 加载 YAML 配置文件</span></span><br><span class=\"line\">helm install my-release bitnami/nginx -f custom-values.yaml</span><br><span class=\"line\"><span class=\"comment\"># 同时使用多种 values 文件 + --set</span></span><br><span class=\"line\">helm install my-release bitnami/nginx -f base.yaml -f prod.yaml --<span class=\"built_in\">set</span> replicaCount=3</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"查看已经安装的包\">查看已经安装的包</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定命名空间已安装的包</span></span><br><span class=\"line\">helm list -n &lt;namespace&gt;</span><br><span class=\"line\"><span class=\"comment\"># 查看所有已安装的包</span></span><br><span class=\"line\">helm list -A</span><br><span class=\"line\"><span class=\"comment\"># 查看已安装的包状态</span></span><br><span class=\"line\">helm status ngxin -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"卸载包\">卸载包</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm uninstall nginx -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>","content_text":"摘要 K8S 的 Tools: crictl、nerdctl、helm ，本文以 CentOS 8 为例。 K8S官网 k8s Github crictl 命令 crictl 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。 crictl 命令默认需要 sudo 权限，如果不想每次都加 sudo，可以将用户加入 containerd 的 socket 权限组 123456789101112131415161718192021222324# containerd 的默认 socket 是 /var/run/containerd/containerd.sock$ ls -l /var/run/containerd/containerd.socksrw-rw---- 1 root root 0 7月 1 10:57 /var/run/containerd/containerd.sock# 如果 group 是 root：你可以改为其它组，比如 docker# 如果 docker 组不存在则创建sudo groupadd docker# 修改文件所属组为 dockersudo chgrp docker /var/run/containerd/containerd.sock# 为组添加读写权限sudo chmod g+rw /var/run/containerd/containerd.sock# 添加用户到 docker 组sudo usermod -aG docker $USER# 刷新权限newgrp docker# 此时虽然已经可以不用 sudo 了，但是一旦重启 containerd 就会重新回到 root 权限，因此需要添加如下配置sudo mkdir -p /etc/systemd/system/containerd.service.d/sudo tee /etc/systemd/system/containerd.service.d/override.conf &lt;&lt;EOF[Service]ExecStartPost=/bin/bash -c &#x27;chmod 660 /run/containerd/containerd.sock &amp;&amp; chgrp docker /run/containerd/containerd.sock&#x27;EOFsudo systemctl daemon-reloadsudo systemctl restart containerd crictl 命令的使用方式比较类似docker命令 操作 docker 命令 crictl 命令 说明 查看正在运行的容器 docker ps crictl ps 查看所有容器（包括已停止） docker ps -a crictl ps -a 查看镜像 docker images crictl images 查看容器日志 docker logs &lt;container_id&gt; crictl logs &lt;container_id&gt; 进入容器交互 docker exec -it &lt;id&gt; sh crictl exec -it &lt;id&gt; sh 查看容器详细信息 docker inspect &lt;container_id&gt; crictl inspect &lt;container_id&gt; 查看 Pod 详细信息 ❌（不支持） crictl inspectp &lt;pod_id&gt; K8s 专属 删除容器 docker rm &lt;container_id&gt; crictl rm &lt;container_id&gt; 删除镜像 docker rmi &lt;image_id&gt; crictl rmi &lt;image_id&gt; 拉取镜像 docker pull nginx crictl pull nginx 运行容器（非 K8s 场景） docker run -it nginx ❌（不支持） crictl 不运行容器，仅调试现有容器 列出容器运行时信息 docker info crictl info 查看容器运行状态 docker stats crictl stats 简要版 设置配置文件 ~/.docker/config.json /etc/crictl.yaml 如设置 endpoint nerdctl nerdctl 是一个 兼容 Docker CLI 的容器命令行工具，用于管理 containerd 容器运行时。 它是 containerd 官方子项目，由 CNCF 维护，其命令语法与 Docker CLI 兼容，目标是让习惯 Docker 的用户也能轻松使用 containerd。 安装 nerdctl 1234567891011121314151617181920212223242526272829# 1. 下载最新版本VERSION=2.1.3wget https://github.com/containerd/nerdctl/releases/download/v$&#123;VERSION&#125;/nerdctl-$&#123;VERSION&#125;-linux-amd64.tar.gz# 2. 解压tar -xvf nerdctl-$&#123;VERSION&#125;-linux-amd64.tar.gz# 3. 移动到系统 PATHsudo mv nerdctl /usr/local/bin/# nerdctl 需要 sudo 权限## 为 sudo 添加 PATHsudo visudo## 找到这一行Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin## 修改为，即将 nerdctl 所在的目录加入 PATHDefaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin# 4.测试## 查看版本sudo nerdctl version## 列出容器，--namespace k8s.io 表示查看 k8s 中的容器sudo nerdctl ps --namespace k8s.io## 如果不想每次都加上 --namespace k8s.io，可以设置别名echo &quot;alias kps=&#x27;sudo nerdctl --namespace=k8s.io ps&#x27;&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc## 测试kps Helm 官网文档 Helm 是 Kubernetes 的包管理器，类似于 Linux 下的包管理工具如 yum、apt 等。可以方便的将之前打包好的 yaml 文件部署到 Kunernetes 上。 Helm的安装 官网安装方法 12345wget https://get.helm.sh/helm-v3.17.4-linux-amd64.tar.gztar -zxvf helm-v3.17.4-linux-amd64.tar.gzsudo mv linux-amd64/helm /usr/local/bin/helm$ helm versionversion.BuildInfo&#123;Version:&quot;v3.17.4&quot;, GitCommit:&quot;595a05da6166037d0abebaa27ac8a498fa4d7ed2&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.23.10&quot;&#125; Helm自动补全 12345678# 安装 helm 的自动补全功能# 1 当前用户echo &#x27;source &lt;(helm completion bash)&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 2 所有用户helm completion bash | sudo tee /etc/bash_completion.d/helm &gt; /dev/nullsudo chmod a+r /etc/bash_completion.d/helm Helm的使用 可以参考 AWS-EKS-14--Helm 仓库管理 add：添加图表存储库 1helm repo add bitnami https://charts.bitnami.com/bitnami list：列出图表存储库 1helm repo list remove：删除图表存储库 1helm repo remove bitnami update：从图表存储库更新本地可用图表的信息 1234# 更新所有仓库helm repo update# 更新指定的仓库helm repo update bitnami 在仓库中搜索 123456789101112131415161718# 在所有仓库中搜索，默认只展示最新的版本helm search repo nginx# 在指定的仓库中搜索helm search repo bitnami/wordpress# 显示所有版本helm search repo nginx -l# 在全部版本中搜索大于等于指定版本$ helm search repo nginx --version ^21.0.0 -lNAME CHART VERSION APP VERSION DESCRIPTIONbitnami/nginx 21.0.8 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.7 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.6 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.4 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.3 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.2 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.1 1.29.0 NGINX Open Source is a web server that can be a...bitnami/nginx 21.0.0 1.29.0 NGINX Open Source is a web server that can be a... 安装包 123456789101112131415161718192021222324252627282930313233# 安装最新版helm install nginx bitnami/nginx# 安装指定版本helm install nginx bitnami/nginx --version 21.0.3# 安装包到指定命名空间helm install nginx bitnami/nginx -n &lt;namespace&gt;# 安装包并创建命名空间helm install nginx bitnami/nginx -n &lt;namespace&gt; --create-namespace# oci： 从 docker 仓库中安装helm pull oci://registry-1.docker.io/bitnamicharts/nginx --version 21.0.8# 安装本地 chart 目录helm install my-release ./nginx# 安装 .tgz 格式的打包 charthelm install my-release ./nginx-1.2.3.tgz# 从远程tgz安装helm install my-release https://example.com/charts/nginx-1.2.3.tgz# 安装 Git 仓库中的 chart（结合 plugin）helm plugin install https://github.com/aslafy-z/helm-githelm repo add mychart &#x27;git+https://github.com/myorg/mychart.git&#x27;helm install my-release mychart/nginx# 卸载helm-git插件helm plugin remove helm-git# 使用 --set 传递单个或多个值helm install my-release bitnami/nginx --set service.type=NodePort# 使用 --values 或 -f 加载 YAML 配置文件helm install my-release bitnami/nginx -f custom-values.yaml# 同时使用多种 values 文件 + --sethelm install my-release bitnami/nginx -f base.yaml -f prod.yaml --set replicaCount=3 查看已经安装的包 123456# 查看指定命名空间已安装的包helm list -n &lt;namespace&gt;# 查看所有已安装的包helm list -A# 查看已安装的包状态helm status ngxin -n &lt;namespace&gt; 卸载包 1helm uninstall nginx -n &lt;namespace&gt;","summary":"摘要 K8S 的 Tools: crictl、nerdctl、helm ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-24T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/24/k8s-connection/","url":"https://blog.hanqunfeng.com/2025/07/24/k8s-connection/","title":"K8S 之 远程连接","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍  K8S 的 远程连接 方法，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"远程连接-k8s-集群\">远程连接 k8s 集群</h2>\n<h3 id=\"本地不存在-kubeconfig-文件\">本地不存在 kubeconfig 文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 kubeconfig 文件，位于 Master 节点：/etc/kubernetes/admin.conf，将其拷贝到本地</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/config</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地已存在-kubeconfig-文件\">本地已存在 kubeconfig 文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>已经配置了一个集群的连接，还想再添加一个集群，可以通过通过合并的方式添加</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将新集群的 kubeconfig 文件拷贝到本地</span></span><br><span class=\"line\">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/new-cluster.conf</span><br><span class=\"line\"><span class=\"comment\"># 合并</span></span><br><span class=\"line\">KUBECONFIG=~/.kube/config:new-cluster.conf kubectl config view --flatten &gt; merged-config.yaml</span><br><span class=\"line\"><span class=\"comment\"># 替换</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> merged-config.yaml ~/.kube/config</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群配置相关命令\">集群配置相关命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取集群配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有集群配置</span></span><br><span class=\"line\">kubectl config get-contexts</span><br><span class=\"line\"><span class=\"comment\"># 查看当前默认的 context</span></span><br><span class=\"line\">kubectl config current-context</span><br><span class=\"line\"><span class=\"comment\"># 切换 context</span></span><br><span class=\"line\">kubectl config use-context &lt;context_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取集群名称</span></span><br><span class=\"line\">kubectl config get-clusters</span><br><span class=\"line\"><span class=\"comment\"># 获取用户名称</span></span><br><span class=\"line\">kubectl config get-users</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get node</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除集群配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 context</span></span><br><span class=\"line\">kubectl config delete-context &lt;context_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除 cluster</span></span><br><span class=\"line\">kubectl config delete-cluster &lt;cluster_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除 user</span></span><br><span class=\"line\">kubectl config delete-user &lt;user_name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以直接编辑 kubeconfig（~/.kube/config） 文件，添加或删除不需要的集群、用户、上下文等信息</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 的 远程连接 方法，本文以 CentOS 8 为例。 K8S官网 k8s Github 远程连接 k8s 集群 本地不存在 kubeconfig 文件 获取 kubeconfig 文件，位于 Master 节点：/etc/kubernetes/admin.conf，将其拷贝到本地 1scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/config 本地已存在 kubeconfig 文件 已经配置了一个集群的连接，还想再添加一个集群，可以通过通过合并的方式添加 123456# 将新集群的 kubeconfig 文件拷贝到本地scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/new-cluster.conf# 合并KUBECONFIG=~/.kube/config:new-cluster.conf kubectl config view --flatten &gt; merged-config.yaml# 替换mv merged-config.yaml ~/.kube/config 集群配置相关命令 获取集群配置 1234567891011# 获取所有集群配置kubectl config get-contexts# 查看当前默认的 contextkubectl config current-context# 切换 contextkubectl config use-context &lt;context_name&gt;# 获取集群名称kubectl config get-clusters# 获取用户名称kubectl config get-users 测试 1kubectl get node 删除集群配置 123456# 删除 contextkubectl config delete-context &lt;context_name&gt;# 删除 clusterkubectl config delete-cluster &lt;cluster_name&gt;# 删除 userkubectl config delete-user &lt;user_name&gt; 后记 也可以直接编辑 kubeconfig（~/.kube/config） 文件，添加或删除不需要的集群、用户、上下文等信息","summary":"摘要 本文介绍 K8S 的 远程连接 方法，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-24T12:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/23/k8s-secret/","url":"https://blog.hanqunfeng.com/2025/07/23/k8s-secret/","title":"K8S 之 Secret","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Secret ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/\">k8s Secret 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Secret-介绍\">Secret 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 使用 Secret 意味着你不需要在应用程序代码中包含机密数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>由于创建 Secret 可以独立于使用它们的 Pod， 因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。 Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施， 例如避免将敏感数据写入非易失性存储。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Secret 类似于 ConfigMap 但专门用于保存机密数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个 Secret 的尺寸最多为 1MiB</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 K8S 中，Secret 有多种类型：本文只讲解 <code>Opaque</code> 类型，其余类型参考[官网]((<a href=\"https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/\">https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/</a>)。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内置类型</th>\n<th>用法描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Opaque</code></td>\n<td>用户自定义的任意数据（默认类型）</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/service-account-token</code></td>\n<td>自动挂载的服务账号令牌，供 Pod 访问 API 使用</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/dockercfg</code></td>\n<td>序列化的 <code>~/.dockercfg</code> 文件，用于私有仓库认证（旧格式）</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/dockerconfigjson</code></td>\n<td>序列化的 <code>~/.docker/config.json</code> 文件（推荐）</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/basic-auth</code></td>\n<td>存储用户名和密码，用于 HTTP 基本认证</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/ssh-auth</code></td>\n<td>存储 SSH 私钥，用于 SSH 身份认证</td>\n</tr>\n<tr>\n<td><code>kubernetes.io/tls</code></td>\n<td>存储 TLS 密钥和证书，用于 HTTPS 或服务加密通信</td>\n</tr>\n<tr>\n<td><code>bootstrap.kubernetes.io/token</code></td>\n<td>用于 kubelet 加入集群的引导令牌</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Secret-创建及使用\">Secret 创建及使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Secret 与 ConfigMap 创建及使用类似，都是存储键值对，但存储内容不同，Secret 存储的是 Base64 编码后的内容。</p>\n</li>\n</ul>\n<h3 id=\"环境变量引用\">环境变量引用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysevret.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">my-secret</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">Opaque</span>                  <span class=\"comment\"># 默认类型 ，可以省略</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> <span class=\"string\">YWRtaW4=</span>          <span class=\"comment\"># &quot;admin&quot; 的 base64 编码</span></span><br><span class=\"line\">  <span class=\"attr\">password:</span> <span class=\"string\">MWYyZDFlMmU2N2Rm</span>  <span class=\"comment\"># &quot;1f2d1e2e67df&quot; 的 base64 编码</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># key：value 方式创建，这里 value 值是 明文，k8s 会进行 base64 编码</span></span><br><span class=\"line\">kubectl create secret generic my-secret \\</span><br><span class=\"line\">  --from-literal=username=admin \\</span><br><span class=\"line\">  --from-literal=password=1f2d1e2e67df</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件方式创建</span></span><br><span class=\"line\"><span class=\"comment\"># --from-env-file=app.env 作用：将 app.env 中的每一行解析为 key=value，每一行变成 Secret 中的一个键值对。</span></span><br><span class=\"line\">kubectl create secret generic my-secret \\</span><br><span class=\"line\">  --from-env-file=username.env \\</span><br><span class=\"line\">  --from-env-file=password.env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># username.env 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># username=admin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># password.env 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># password=1f2d1e2e67df</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建完成后，查看 Secret 的内容</span></span><br><span class=\"line\">$ k get secrets my-secret -o yaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  password: MWYyZDFlMmU2N2Rm</span><br><span class=\"line\">  username: YWRtaW4=</span><br><span class=\"line\">kind: Secret</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-07-05T13:21:22Z&quot;</span></span><br><span class=\"line\">  name: my-secret</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;747355&quot;</span></span><br><span class=\"line\">  uid: 4f77269d-d4c3-4ae8-aafc-7cfa56b84a5d</span><br><span class=\"line\"><span class=\"built_in\">type</span>: Opaque</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 Secret 中的全部数据作为环境变量使用</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">env-secret</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">      <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;printenv&quot;</span>] <span class=\"comment\"># 打印环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">busybox:latest</span></span><br><span class=\"line\">      <span class=\"attr\">envFrom:</span>                  <span class=\"comment\"># 环境变量引用文件、 Secret ，等等</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">secretRef:</span>            <span class=\"comment\"># 这里引用 Secret ，此处将 Secret 中的全部数据作为环境变量使用</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">my-secret</span>     <span class=\"comment\"># Secret 名称</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 Secret 中的部分数据作为环境变量使用</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod2.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">env-secret2</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span>                       <span class=\"comment\"># 容器启动命令</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">        echo &quot;username: $&#123;SECRET_USERNAME&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        echo &quot;password: $&#123;SECRET_PASSWORD&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"attr\">image:</span> <span class=\"string\">busybox:latest</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>                        <span class=\"comment\"># 环境变量配置，key: value 形式</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">SECRET_USERNAME</span>     <span class=\"comment\"># 要在pod中配置的环境变量的 key</span></span><br><span class=\"line\">      <span class=\"attr\">valueFrom:</span>                <span class=\"comment\"># value 来源</span></span><br><span class=\"line\">        <span class=\"attr\">secretKeyRef:</span>           <span class=\"comment\"># 引用 Secret 中的 key</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">my-secret</span>       <span class=\"comment\"># Secret 名称</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">username</span>         <span class=\"comment\"># Secret 中 key 的名称</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">SECRET_PASSWORD</span></span><br><span class=\"line\">      <span class=\"attr\">valueFrom:</span></span><br><span class=\"line\">        <span class=\"attr\">secretKeyRef:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">my-secret</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">password</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看pod日志</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k logs pods/env-secret</span><br><span class=\"line\">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class=\"line\">KUBERNETES_SERVICE_PORT=443</span><br><span class=\"line\">HOSTNAME=env-secret</span><br><span class=\"line\">SHLVL=1</span><br><span class=\"line\">username=admin</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class=\"line\">password=1f2d1e2e67df</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class=\"line\">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class=\"line\">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class=\"line\">PWD=/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ k logs pods/env-secret2</span><br><span class=\"line\">username: admin</span><br><span class=\"line\">password: 1f2d1e2e67df</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储卷引用\">存储卷引用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># secret-configfile.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">my-secret</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">Opaque</span></span><br><span class=\"line\"><span class=\"attr\">stringData:</span>                          <span class=\"comment\"># 使用 stringData，K8s 会自动将其转换为 base64 编码</span></span><br><span class=\"line\">  <span class=\"attr\">app.properties:</span> <span class=\"string\">|</span>                  <span class=\"comment\"># 文件名</span></span><br><span class=\"line\">    <span class=\"string\">server.port=8080</span></span><br><span class=\"line\">    <span class=\"string\">log.level=INFO</span></span><br><span class=\"line\">  <span class=\"attr\">db.properties:</span> <span class=\"string\">|</span>                   <span class=\"comment\"># 文件名</span></span><br><span class=\"line\">    <span class=\"string\">db.host=localhost</span></span><br><span class=\"line\">    <span class=\"string\">db.port=5432</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意这里是 --from-file，作为文件配置，而非环境变量</span></span><br><span class=\"line\"><span class=\"comment\"># 文件内容是明文，k8s 会自动将其转换为 base64 编码</span></span><br><span class=\"line\">kubectl create secret generic my-secret \\</span><br><span class=\"line\">  --from-file=app.properties \\</span><br><span class=\"line\">  --from-file=db.properties</span><br><span class=\"line\"><span class=\"comment\"># app.properties 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># server.port=8080</span></span><br><span class=\"line\"><span class=\"comment\"># log.level=INFO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># db.properties 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># db.host=localhost</span></span><br><span class=\"line\"><span class=\"comment\"># db.port=5432</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ k get secrets my-secret -oyaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  app.properties: c2VydmVyLnBvcnQ9ODA4MApsb2cubGV2ZWw9SU5GTwo=</span><br><span class=\"line\">  db.properties: ZGIuaG9zdD1sb2NhbGhvc3QKZGIucG9ydD0xMjU0MzIK</span><br><span class=\"line\">kind: Secret</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-07-05T13:45:14Z&quot;</span></span><br><span class=\"line\">  name: my-secret</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;750742&quot;</span></span><br><span class=\"line\">  uid: 35ffcdd6-d70a-4f3a-9246-5c56da630bc1</span><br><span class=\"line\"><span class=\"built_in\">type</span>: Opaque</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 挂载 Secret 为文件</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># secret-pod.yaml 文件内容如下：</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">secret-demo</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/config</span>              <span class=\"comment\"># 挂载路径</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span>                   <span class=\"comment\"># 存储卷 名称</span></span><br><span class=\"line\">    <span class=\"attr\">secret:</span>                               <span class=\"comment\"># 存储卷类型为 Secret</span></span><br><span class=\"line\">      <span class=\"attr\">secretName:</span> <span class=\"string\">my-secret</span>               <span class=\"comment\"># 挂载的 Secret 名称，本利中将 Secret 中的全部文件都挂载到pod目录下</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器内的 <code>/etc/config/</code> 目录下会有两个文件：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/config/app.properties</span><br><span class=\"line\">/etc/config/db.properties</span><br><span class=\"line\"></span><br><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it secret-demo -- <span class=\"built_in\">ls</span> /etc/config/</span><br><span class=\"line\">app.properties  db.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果只想挂载 Secret 中的某些文件，可以通过 <code>items</code> 字段指定：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># secret-pod2.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">secret-demo2</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/config</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">    <span class=\"attr\">secret:</span></span><br><span class=\"line\">      <span class=\"attr\">secretName:</span> <span class=\"string\">my-secret</span></span><br><span class=\"line\">      <span class=\"attr\">items:</span>                   <span class=\"comment\"># 明确指定挂载的key</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app.properties</span>    <span class=\"comment\"># secret 中的key</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">app.properties</span>   <span class=\"comment\"># 映射到容器内的路径，最终挂载路径为 /etc/config/app.properties</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Secret 的特点与使用方法与 ConfigMap 非常类似。</p>\n</li>\n<li class=\"lvl-2\">\n<p>🔍 ConfigMap vs Secret 对比表：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ConfigMap</th>\n<th>Secret</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>存储非敏感配置信息（如环境变量、配置文件）</td>\n<td>存储敏感信息（如密码、证书、token）</td>\n</tr>\n<tr>\n<td><strong>数据是否加密</strong></td>\n<td>否，明文存储（Base64 编码可读）</td>\n<td>否（默认 Base64 编码），可配置加密存储（如使用 KMS）</td>\n</tr>\n<tr>\n<td><strong>字段名</strong></td>\n<td><code>data</code> / <code>binaryData</code></td>\n<td><code>data</code>（需 base64） / <code>stringData</code>（明文）</td>\n</tr>\n<tr>\n<td><strong>可存储的最大大小</strong></td>\n<td>每个对象最多约 1MB</td>\n<td>每个对象最多约 1MB</td>\n</tr>\n<tr>\n<td><strong>支持的挂载方式</strong></td>\n<td>- 环境变量<br>- 卷（文件）</td>\n<td>- 环境变量<br>- 卷（文件）</td>\n</tr>\n<tr>\n<td><strong>默认类型（type）</strong></td>\n<td>无类型字段</td>\n<td>默认为 <code>Opaque</code></td>\n</tr>\n<tr>\n<td><strong>可定义为多个文件挂载</strong></td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>默认 RBAC 访问控制强度</strong></td>\n<td>弱（多数用户/Pod 可读取）</td>\n<td>强（默认受限访问）</td>\n</tr>\n<tr>\n<td><strong>支持的内置类型</strong></td>\n<td>无</td>\n<td>✅ 如：<code>kubernetes.io/tls</code>、<code>kubernetes.io/basic-auth</code> 等</td>\n</tr>\n<tr>\n<td><strong>是否适合存储密钥/密码</strong></td>\n<td>❌ 不推荐</td>\n<td>✅ 推荐</td>\n</tr>\n<tr>\n<td><strong>可视化明文读取</strong></td>\n<td>✅ 直接读取</td>\n<td>✅ 但 Base64 编码后需要解码</td>\n</tr>\n<tr>\n<td><strong>常见用途示例</strong></td>\n<td>App 配置、日志级别、连接参数等</td>\n<td>数据库密码、TLS 证书、API Token 等</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 Secret ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Secret 官方文档 Secret 介绍 Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 使用 Secret 意味着你不需要在应用程序代码中包含机密数据。 由于创建 Secret 可以独立于使用它们的 Pod， 因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。 Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施， 例如避免将敏感数据写入非易失性存储。 Secret 类似于 ConfigMap 但专门用于保存机密数据。 每个 Secret 的尺寸最多为 1MiB 在 K8S 中，Secret 有多种类型：本文只讲解 Opaque 类型，其余类型参考[官网]((https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/)。 内置类型 用法描述 Opaque 用户自定义的任意数据（默认类型） kubernetes.io/service-account-token 自动挂载的服务账号令牌，供 Pod 访问 API 使用 kubernetes.io/dockercfg 序列化的 ~/.dockercfg 文件，用于私有仓库认证（旧格式） kubernetes.io/dockerconfigjson 序列化的 ~/.docker/config.json 文件（推荐） kubernetes.io/basic-auth 存储用户名和密码，用于 HTTP 基本认证 kubernetes.io/ssh-auth 存储 SSH 私钥，用于 SSH 身份认证 kubernetes.io/tls 存储 TLS 密钥和证书，用于 HTTPS 或服务加密通信 bootstrap.kubernetes.io/token 用于 kubelet 加入集群的引导令牌 Secret 创建及使用 Secret 与 ConfigMap 创建及使用类似，都是存储键值对，但存储内容不同，Secret 存储的是 Base64 编码后的内容。 环境变量引用 yaml创建 12345678910# mysevret.yamlapiVersion: v1kind: Secretmetadata: name: my-secrettype: Opaque # 默认类型 ，可以省略data: username: YWRtaW4= # &quot;admin&quot; 的 base64 编码 password: MWYyZDFlMmU2N2Rm # &quot;1f2d1e2e67df&quot; 的 base64 编码 命令行创建 12345678910111213141516171819202122232425262728293031# key：value 方式创建，这里 value 值是 明文，k8s 会进行 base64 编码kubectl create secret generic my-secret \\ --from-literal=username=admin \\ --from-literal=password=1f2d1e2e67df# 文件方式创建# --from-env-file=app.env 作用：将 app.env 中的每一行解析为 key=value，每一行变成 Secret 中的一个键值对。kubectl create secret generic my-secret \\ --from-env-file=username.env \\ --from-env-file=password.env# username.env 文件内容如下：# username=admin# password.env 文件内容如下：# password=1f2d1e2e67df# 创建完成后，查看 Secret 的内容$ k get secrets my-secret -o yamlapiVersion: v1data: password: MWYyZDFlMmU2N2Rm username: YWRtaW4=kind: Secretmetadata: creationTimestamp: &quot;2025-07-05T13:21:22Z&quot; name: my-secret namespace: default resourceVersion: &quot;747355&quot; uid: 4f77269d-d4c3-4ae8-aafc-7cfa56b84a5dtype: Opaque 将 Secret 中的全部数据作为环境变量使用 12345678910111213# pod.yamlapiVersion: v1kind: Podmetadata: name: env-secretspec: containers: - name: app command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;printenv&quot;] # 打印环境变量 image: busybox:latest envFrom: # 环境变量引用文件、 Secret ，等等 - secretRef: # 这里引用 Secret ，此处将 Secret 中的全部数据作为环境变量使用 name: my-secret # Secret 名称 将 Secret 中的部分数据作为环境变量使用 12345678910111213141516171819202122232425# pod2.yamlapiVersion: v1kind: Podmetadata: name: env-secret2spec: containers: - name: app command: [&quot;/bin/sh&quot;, &quot;-c&quot;] args: # 容器启动命令 - | echo &quot;username: $&#123;SECRET_USERNAME&#125;&quot; echo &quot;password: $&#123;SECRET_PASSWORD&#125;&quot; image: busybox:latest env: # 环境变量配置，key: value 形式 - name: SECRET_USERNAME # 要在pod中配置的环境变量的 key valueFrom: # value 来源 secretKeyRef: # 引用 Secret 中的 key name: my-secret # Secret 名称 key: username # Secret 中 key 的名称 - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: my-secret key: password 查看pod日志 123456789101112131415161718192021$ k logs pods/env-secretKUBERNETES_PORT=tcp://10.96.0.1:443KUBERNETES_SERVICE_PORT=443HOSTNAME=env-secretSHLVL=1username=adminHOME=/rootKUBERNETES_PORT_443_TCP_ADDR=10.96.0.1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binKUBERNETES_PORT_443_TCP_PORT=443password=1f2d1e2e67dfKUBERNETES_PORT_443_TCP_PROTO=tcpKUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443KUBERNETES_SERVICE_PORT_HTTPS=443KUBERNETES_SERVICE_HOST=10.96.0.1PWD=/$ k logs pods/env-secret2username: adminpassword: 1f2d1e2e67df 存储卷引用 yaml创建 1234567891011121314# secret-configfile.yamlapiVersion: v1kind: Secretmetadata: name: my-secrettype: OpaquestringData: # 使用 stringData，K8s 会自动将其转换为 base64 编码 app.properties: | # 文件名 server.port=8080 log.level=INFO db.properties: | # 文件名 db.host=localhost db.port=5432 命令行创建 1234567891011121314151617181920212223242526# 注意这里是 --from-file，作为文件配置，而非环境变量# 文件内容是明文，k8s 会自动将其转换为 base64 编码kubectl create secret generic my-secret \\ --from-file=app.properties \\ --from-file=db.properties# app.properties 文件内容如下：# server.port=8080# log.level=INFO# db.properties 文件内容如下：# db.host=localhost# db.port=5432$ k get secrets my-secret -oyamlapiVersion: v1data: app.properties: c2VydmVyLnBvcnQ9ODA4MApsb2cubGV2ZWw9SU5GTwo= db.properties: ZGIuaG9zdD1sb2NhbGhvc3QKZGIucG9ydD0xMjU0MzIKkind: Secretmetadata: creationTimestamp: &quot;2025-07-05T13:45:14Z&quot; name: my-secret namespace: default resourceVersion: &quot;750742&quot; uid: 35ffcdd6-d70a-4f3a-9246-5c56da630bc1type: Opaque Pod 挂载 Secret 为文件 123456789101112131415161718# secret-pod.yaml 文件内容如下：apiVersion: v1kind: Podmetadata: name: secret-demospec: containers: - name: myapp image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] volumeMounts: - name: config-volume mountPath: /etc/config # 挂载路径 readOnly: true volumes: - name: config-volume # 存储卷 名称 secret: # 存储卷类型为 Secret secretName: my-secret # 挂载的 Secret 名称，本利中将 Secret 中的全部文件都挂载到pod目录下 容器内的 /etc/config/ 目录下会有两个文件： 12345/etc/config/app.properties/etc/config/db.properties$ k exec -it secret-demo -- ls /etc/config/app.properties db.properties 如果只想挂载 Secret 中的某些文件，可以通过 items 字段指定： 123456789101112131415161718192021# secret-pod2.yamlapiVersion: v1kind: Podmetadata: name: secret-demo2spec: containers: - name: myapp image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] volumeMounts: - name: config-volume mountPath: /etc/config readOnly: true volumes: - name: config-volume secret: secretName: my-secret items: # 明确指定挂载的key - key: app.properties # secret 中的key path: app.properties # 映射到容器内的路径，最终挂载路径为 /etc/config/app.properties 后记 Secret 的特点与使用方法与 ConfigMap 非常类似。 🔍 ConfigMap vs Secret 对比表： 特性 ConfigMap Secret 用途 存储非敏感配置信息（如环境变量、配置文件） 存储敏感信息（如密码、证书、token） 数据是否加密 否，明文存储（Base64 编码可读） 否（默认 Base64 编码），可配置加密存储（如使用 KMS） 字段名 data / binaryData data（需 base64） / stringData（明文） 可存储的最大大小 每个对象最多约 1MB 每个对象最多约 1MB 支持的挂载方式 - 环境变量- 卷（文件） - 环境变量- 卷（文件） 默认类型（type） 无类型字段 默认为 Opaque 可定义为多个文件挂载 ✅ ✅ 默认 RBAC 访问控制强度 弱（多数用户/Pod 可读取） 强（默认受限访问） 支持的内置类型 无 ✅ 如：kubernetes.io/tls、kubernetes.io/basic-auth 等 是否适合存储密钥/密码 ❌ 不推荐 ✅ 推荐 可视化明文读取 ✅ 直接读取 ✅ 但 Base64 编码后需要解码 常见用途示例 App 配置、日志级别、连接参数等 数据库密码、TLS 证书、API Token 等","summary":"摘要 本文介绍 K8S 的 Secret ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Secret 官方文档","date_published":"2025-07-23T13:35:15.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/23/k8s-configmap/","url":"https://blog.hanqunfeng.com/2025/07/23/k8s-configmap/","title":"K8S 之 ConfigMap","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 ConfigMap ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/\">k8s ConfigMap 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ConfigMap-别名cm-介绍\">ConfigMap(别名cm) 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用时， Pod 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ConfigMap 将你的环境配置信息和容器镜像解耦，便于应用配置的修改。</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个 Pod 可以关联同一个 ConfigMap</p>\n</li>\n</ul>\n<h2 id=\"ConfigMap-创建及使用\">ConfigMap 创建及使用</h2>\n<h3 id=\"环境变量引用\">环境变量引用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># configmap.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span>       <span class=\"comment\"># ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myconfigmap</span>   <span class=\"comment\"># configmap 名称</span></span><br><span class=\"line\"><span class=\"attr\">data:</span>                 <span class=\"comment\"># data 字段设计用来保存 UTF-8 字符串，最大值为 1M</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> <span class=\"string\">k8s-admin</span> <span class=\"comment\"># key: value</span></span><br><span class=\"line\">  <span class=\"attr\">access_level:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">password:</span> <span class=\"string\">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># key：value 方式创建</span></span><br><span class=\"line\">kubectl create configmap myconfigmap --from-literal=username=k8s-admin --from-literal=access_level=1 --from-literal=password=123456</span><br><span class=\"line\"><span class=\"comment\"># 文件方式创建</span></span><br><span class=\"line\"><span class=\"comment\"># --from-env-file=app.env 作用：将 app.env 中的每一行解析为 key=value，每一行变成 ConfigMap 中的一个键值对。</span></span><br><span class=\"line\">kubectl create configmap myconfigmap --from-env-file=app.env --from-env-file=other.env</span><br><span class=\"line\"><span class=\"comment\"># app.env 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># username=k8s-admin</span></span><br><span class=\"line\"><span class=\"comment\"># access_level=1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># other.env 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># password=123456</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建完成后，查看 ConfigMap 的内容</span></span><br><span class=\"line\">$ k get cm myconfigmap -oyaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  access_level: <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">  password: <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\">  username: k8s-admin</span><br><span class=\"line\">kind: ConfigMap</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-07-05T10:29:15Z&quot;</span></span><br><span class=\"line\">  name: myconfigmap</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;723770&quot;</span></span><br><span class=\"line\">  uid: ee850cf9-9014-4be2-97d8-5d1840e78d54</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 ConfigMap 中的全部数据作为环境变量使用</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">env-configmap</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">      <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;printenv&quot;</span>] <span class=\"comment\"># 打印环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">busybox:latest</span></span><br><span class=\"line\">      <span class=\"attr\">envFrom:</span>                  <span class=\"comment\"># 环境变量引用文件、configMap，等等</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">configMapRef:</span>         <span class=\"comment\"># 这里引用 ConfigMap，此处将 ConfigMap 中的全部数据作为环境变量使用</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">myconfigmap</span>   <span class=\"comment\"># configMap 名称</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 ConfigMap 中的部分数据作为环境变量使用</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod2.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">env-configmap2</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span>                       <span class=\"comment\"># 容器启动命令</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">        echo &quot;username: $&#123;CONFIGMAP_USERNAME&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        echo &quot;password: $&#123;CONFIGMAP_PASSWORD&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"attr\">image:</span> <span class=\"string\">busybox:latest</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>                        <span class=\"comment\"># 环境变量配置，key: value 形式</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">CONFIGMAP_USERNAME</span>  <span class=\"comment\"># 要在pod中配置的环境变量的 key</span></span><br><span class=\"line\">      <span class=\"attr\">valueFrom:</span>                <span class=\"comment\"># value 来源</span></span><br><span class=\"line\">        <span class=\"attr\">configMapKeyRef:</span>        <span class=\"comment\"># 引用 ConfigMap 中的 key</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">myconfigmap</span>     <span class=\"comment\"># configMap 名称</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">username</span>         <span class=\"comment\"># configMap 中 key 的名称</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">CONFIGMAP_PASSWORD</span></span><br><span class=\"line\">      <span class=\"attr\">valueFrom:</span></span><br><span class=\"line\">        <span class=\"attr\">configMapKeyRef:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">myconfigmap</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">password</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看pod日志</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl logs pods/env-configmap</span><br><span class=\"line\">access_level=1</span><br><span class=\"line\">KUBERNETES_SERVICE_PORT=443</span><br><span class=\"line\">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class=\"line\">HOSTNAME=env-configmap</span><br><span class=\"line\">SHLVL=1</span><br><span class=\"line\">username=k8s-admin</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class=\"line\">password=123456</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class=\"line\">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class=\"line\">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class=\"line\">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class=\"line\">PWD=/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl logs pods/env-configmap2</span><br><span class=\"line\">username: k8s-admin</span><br><span class=\"line\">password: 123456</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储卷引用\">存储卷引用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># configmap-configfile.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">app-config</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">app.properties:</span> <span class=\"string\">|</span>  <span class=\"comment\"># 文件名称 ，使用 | 创建多行</span></span><br><span class=\"line\">    <span class=\"string\">server.port=8080</span></span><br><span class=\"line\">    <span class=\"string\">log.level=INFO</span></span><br><span class=\"line\">  <span class=\"attr\">db.properties:</span> <span class=\"string\">|</span>   <span class=\"comment\"># 文件名称</span></span><br><span class=\"line\">    <span class=\"string\">db.host=localhost</span></span><br><span class=\"line\">    <span class=\"string\">db.port=5432</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># 注意这里是 --from-file，作为文件配置，而非环境变量</span></span><br><span class=\"line\">kubectl create configmap app-config \\</span><br><span class=\"line\">  --from-file=app.properties \\</span><br><span class=\"line\">  --from-file=db.properties</span><br><span class=\"line\"><span class=\"comment\"># app.properties 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># server.port=8080</span></span><br><span class=\"line\"><span class=\"comment\"># log.level=INFO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># db.properties 文件内容如下：</span></span><br><span class=\"line\"><span class=\"comment\"># db.host=localhost</span></span><br><span class=\"line\"><span class=\"comment\"># db.port=5432</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ k get cm app-config -oyaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  app.properties: |</span><br><span class=\"line\">    server.port=8080</span><br><span class=\"line\">    log.level=INFO</span><br><span class=\"line\">  db.properties: |</span><br><span class=\"line\">    db.host=localhost</span><br><span class=\"line\">    db.port=5432</span><br><span class=\"line\">kind: ConfigMap</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-07-05T10:49:00Z&quot;</span></span><br><span class=\"line\">  name: app-config</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;726507&quot;</span></span><br><span class=\"line\">  uid: 05c9a228-ec69-4e88-b8d8-63f97eff2651</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 挂载 ConfigMap 为文件</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># configmap-pod.yaml 文件内容如下：</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">configmap-demo</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/config</span>              <span class=\"comment\"># 挂载路径</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span>                   <span class=\"comment\"># 存储卷 名称</span></span><br><span class=\"line\">    <span class=\"attr\">configMap:</span>                            <span class=\"comment\"># 存储卷类型为 ConfigMap</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">app-config</span>                    <span class=\"comment\"># 挂载的 ConfigMap 名称，本利中将 configMap 中的全部文件都挂载到pod目录下</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器内的 <code>/etc/config/</code> 目录下会有两个文件：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/config/app.properties</span><br><span class=\"line\">/etc/config/db.properties</span><br><span class=\"line\"></span><br><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it configmap-demo -- <span class=\"built_in\">ls</span> /etc/config/</span><br><span class=\"line\">app.properties  db.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果只想挂载 ConfigMap 中的某些文件，可以通过 <code>items</code> 字段指定：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">configmap-demo</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/config</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">    <span class=\"attr\">configMap:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">app-config</span></span><br><span class=\"line\">      <span class=\"attr\">items:</span>                   <span class=\"comment\"># 明确指定挂载的key</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app.properties</span>    <span class=\"comment\"># configMap中的key</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">app.properties</span>   <span class=\"comment\"># 映射到容器内的路径，最终挂载路径为 /etc/config/app.properties</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--from-env-file=app.env</code> 与 <code>--from-file=app.env</code> 的区别</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>--from-env-file=app.env</code></th>\n<th><code>--from-file=app.env</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>解析为环境变量形式键值对</td>\n<td>按文件整体读入为内容</td>\n</tr>\n<tr>\n<td>适合场景</td>\n<td>想把每个变量都单独用掉</td>\n<td>挂载为配置文件使用</td>\n</tr>\n<tr>\n<td>data 结构</td>\n<td>每一行变一个键值对</td>\n<td>文件名为 key，内容为值</td>\n</tr>\n<tr>\n<td>读取方式</td>\n<td>用 <code>envFrom</code> 注入环境变量</td>\n<td>用 <code>volumeMount</code> 挂载整个文件</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ConfigMap 也支持 <code>二进制</code> 数据，但需要用 <code>base64</code> 编码</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">my-config</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">config.txt:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    Hello, world!</span></span><br><span class=\"line\"><span class=\"string\"></span><span class=\"attr\">binaryData:</span></span><br><span class=\"line\">  <span class=\"attr\">config.bin:</span> <span class=\"string\">aGVsbG8gd29ybGQK</span>   <span class=\"comment\"># 这是 &quot;hello world&quot; 的 base64 编码</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>binaryData 和 data 的区别</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>内容类型</th>\n<th>编码方式</th>\n<th>适合存储</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>data</code></td>\n<td>文本（UTF-8）</td>\n<td>明文</td>\n<td>配置文件、参数、脚本等</td>\n</tr>\n<tr>\n<td><code>binaryData</code></td>\n<td>任意二进制数据</td>\n<td>base64 编码</td>\n<td>图片、证书、非UTF-8文件等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>❗注意事项</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>base64 编码格式</td>\n<td><code>binaryData</code> 中的值必须是标准 base64，不支持换行</td>\n</tr>\n<tr>\n<td>解码后大小限制</td>\n<td>ConfigMap 单个对象最大 1MB（无论 data 还是 binaryData）</td>\n</tr>\n<tr>\n<td>二者可共存</td>\n<td><code>data</code> 与 <code>binaryData</code> 可以同时出现在同一个 ConfigMap 中（字段名不能重复）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>修改 ConfigMap 后 ：<code>k edit configmap &lt;configmap-name&gt;</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">如果 Pod 是作为 环境变量 关联的，Pod 不会更新，只能重新创建</li>\n<li class=\"lvl-4\">如果 Pod 是作为 volume 挂载的，Pod 会自动更新(大约几秒后)</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>删除 ConfigMap 后：<code>k delete configmap &lt;configmap-name&gt;</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Pod 状态</th>\n<th>ConfigMap 删除后影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正在运行</td>\n<td>不受影响</td>\n</tr>\n<tr>\n<td>重启 / 扩容</td>\n<td><strong>失败</strong>：找不到 ConfigMap，无法创建容器</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 ConfigMap ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s ConfigMap 官方文档 ConfigMap(别名cm) 介绍 ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。 使用时， Pod 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。 ConfigMap 将你的环境配置信息和容器镜像解耦，便于应用配置的修改。 多个 Pod 可以关联同一个 ConfigMap ConfigMap 创建及使用 环境变量引用 yaml创建 123456789# configmap.yamlapiVersion: v1kind: ConfigMap # ConfigMapmetadata: name: myconfigmap # configmap 名称data: # data 字段设计用来保存 UTF-8 字符串，最大值为 1M username: k8s-admin # key: value access_level: &quot;1&quot; password: &quot;123456&quot; 命令行创建 1234567891011121314151617181920212223242526# key：value 方式创建kubectl create configmap myconfigmap --from-literal=username=k8s-admin --from-literal=access_level=1 --from-literal=password=123456# 文件方式创建# --from-env-file=app.env 作用：将 app.env 中的每一行解析为 key=value，每一行变成 ConfigMap 中的一个键值对。kubectl create configmap myconfigmap --from-env-file=app.env --from-env-file=other.env# app.env 文件内容如下：# username=k8s-admin# access_level=1# other.env 文件内容如下：# password=123456# 创建完成后，查看 ConfigMap 的内容$ k get cm myconfigmap -oyamlapiVersion: v1data: access_level: &quot;1&quot; password: &quot;123456&quot; username: k8s-adminkind: ConfigMapmetadata: creationTimestamp: &quot;2025-07-05T10:29:15Z&quot; name: myconfigmap namespace: default resourceVersion: &quot;723770&quot; uid: ee850cf9-9014-4be2-97d8-5d1840e78d54 将 ConfigMap 中的全部数据作为环境变量使用 12345678910111213# pod.yamlapiVersion: v1kind: Podmetadata: name: env-configmapspec: containers: - name: app command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;printenv&quot;] # 打印环境变量 image: busybox:latest envFrom: # 环境变量引用文件、configMap，等等 - configMapRef: # 这里引用 ConfigMap，此处将 ConfigMap 中的全部数据作为环境变量使用 name: myconfigmap # configMap 名称 将 ConfigMap 中的部分数据作为环境变量使用 12345678910111213141516171819202122232425# pod2.yamlapiVersion: v1kind: Podmetadata: name: env-configmap2spec: containers: - name: app command: [&quot;/bin/sh&quot;, &quot;-c&quot;] args: # 容器启动命令 - | echo &quot;username: $&#123;CONFIGMAP_USERNAME&#125;&quot; echo &quot;password: $&#123;CONFIGMAP_PASSWORD&#125;&quot; image: busybox:latest env: # 环境变量配置，key: value 形式 - name: CONFIGMAP_USERNAME # 要在pod中配置的环境变量的 key valueFrom: # value 来源 configMapKeyRef: # 引用 ConfigMap 中的 key name: myconfigmap # configMap 名称 key: username # configMap 中 key 的名称 - name: CONFIGMAP_PASSWORD valueFrom: configMapKeyRef: name: myconfigmap key: password 查看pod日志 12345678910111213141516171819202122$ kubectl logs pods/env-configmapaccess_level=1KUBERNETES_SERVICE_PORT=443KUBERNETES_PORT=tcp://10.96.0.1:443HOSTNAME=env-configmapSHLVL=1username=k8s-adminHOME=/rootKUBERNETES_PORT_443_TCP_ADDR=10.96.0.1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binKUBERNETES_PORT_443_TCP_PORT=443password=123456KUBERNETES_PORT_443_TCP_PROTO=tcpKUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443KUBERNETES_SERVICE_PORT_HTTPS=443KUBERNETES_SERVICE_HOST=10.96.0.1PWD=/$ kubectl logs pods/env-configmap2username: k8s-adminpassword: 123456 存储卷引用 yaml创建 123456789101112# configmap-configfile.yamlapiVersion: v1kind: ConfigMapmetadata: name: app-configdata: app.properties: | # 文件名称 ，使用 | 创建多行 server.port=8080 log.level=INFO db.properties: | # 文件名称 db.host=localhost db.port=5432 命令行创建 12345678910111213141516171819202122232425262728 # 注意这里是 --from-file，作为文件配置，而非环境变量kubectl create configmap app-config \\ --from-file=app.properties \\ --from-file=db.properties# app.properties 文件内容如下：# server.port=8080# log.level=INFO# db.properties 文件内容如下：# db.host=localhost# db.port=5432$ k get cm app-config -oyamlapiVersion: v1data: app.properties: | server.port=8080 log.level=INFO db.properties: | db.host=localhost db.port=5432kind: ConfigMapmetadata: creationTimestamp: &quot;2025-07-05T10:49:00Z&quot; name: app-config namespace: default resourceVersion: &quot;726507&quot; uid: 05c9a228-ec69-4e88-b8d8-63f97eff2651 Pod 挂载 ConfigMap 为文件 123456789101112131415161718# configmap-pod.yaml 文件内容如下：apiVersion: v1kind: Podmetadata: name: configmap-demospec: containers: - name: myapp image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] volumeMounts: - name: config-volume mountPath: /etc/config # 挂载路径 readOnly: true volumes: - name: config-volume # 存储卷 名称 configMap: # 存储卷类型为 ConfigMap name: app-config # 挂载的 ConfigMap 名称，本利中将 configMap 中的全部文件都挂载到pod目录下 容器内的 /etc/config/ 目录下会有两个文件： 12345/etc/config/app.properties/etc/config/db.properties$ k exec -it configmap-demo -- ls /etc/config/app.properties db.properties 如果只想挂载 ConfigMap 中的某些文件，可以通过 items 字段指定： 1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: configmap-demospec: containers: - name: myapp image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] volumeMounts: - name: config-volume mountPath: /etc/config readOnly: true volumes: - name: config-volume configMap: name: app-config items: # 明确指定挂载的key - key: app.properties # configMap中的key path: app.properties # 映射到容器内的路径，最终挂载路径为 /etc/config/app.properties 后记 --from-env-file=app.env 与 --from-file=app.env 的区别 项目 --from-env-file=app.env --from-file=app.env 用途 解析为环境变量形式键值对 按文件整体读入为内容 适合场景 想把每个变量都单独用掉 挂载为配置文件使用 data 结构 每一行变一个键值对 文件名为 key，内容为值 读取方式 用 envFrom 注入环境变量 用 volumeMount 挂载整个文件 ConfigMap 也支持 二进制 数据，但需要用 base64 编码 123456789apiVersion: v1kind: ConfigMapmetadata: name: my-configdata: config.txt: | Hello, world!binaryData: config.bin: aGVsbG8gd29ybGQK # 这是 &quot;hello world&quot; 的 base64 编码 binaryData 和 data 的区别 字段 内容类型 编码方式 适合存储 data 文本（UTF-8） 明文 配置文件、参数、脚本等 binaryData 任意二进制数据 base64 编码 图片、证书、非UTF-8文件等 ❗注意事项 项目 说明 base64 编码格式 binaryData 中的值必须是标准 base64，不支持换行 解码后大小限制 ConfigMap 单个对象最大 1MB（无论 data 还是 binaryData） 二者可共存 data 与 binaryData 可以同时出现在同一个 ConfigMap 中（字段名不能重复） 修改 ConfigMap 后 ：k edit configmap &lt;configmap-name&gt; 如果 Pod 是作为 环境变量 关联的，Pod 不会更新，只能重新创建 如果 Pod 是作为 volume 挂载的，Pod 会自动更新(大约几秒后) 删除 ConfigMap 后：k delete configmap &lt;configmap-name&gt; Pod 状态 ConfigMap 删除后影响 正在运行 不受影响 重启 / 扩容 失败：找不到 ConfigMap，无法创建容器","summary":"摘要 本文介绍 K8S 的 ConfigMap ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s ConfigMap 官方文档","date_published":"2025-07-23T12:35:15.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/22/k8s-storageclass/","url":"https://blog.hanqunfeng.com/2025/07/22/k8s-storageclass/","title":"K8S 之 StorageClass","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 StorageClass，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/\">k8s StorageClass 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文底层存储卷是 NFS</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"StorageClass-别名sc-介绍\">StorageClass(别名sc) 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>K8s 的存储资源分为两种供应模式：静态供应模式 和 动态供应模式。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">静态模式下，管理员需要预先创建许多PV，等待 PVC  来绑定。</li>\n<li class=\"lvl-4\">动态模式下，Kubernetes 会通过 StorageClass 自动创建 PV，并完成与 PVC 的绑定。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>StorageClass 是 Kubernetes 中用来定义 <code>存储后端类型和配置参数</code> 的资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>作用： 自动创建 PV（PersistentVolume）的“模板”或“规则”</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用场景： 配合 PVC 使用时，Kubernetes 可以根据 StorageClass 自动 动态创建 对应的持久卷。</p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ 核心优势：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">无需手动创建 PV</li>\n<li class=\"lvl-4\">支持多种存储后端（NFS、云盘、Ceph、GlusterFS、iSCSI…）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/OGGWYb.png\" alt=\"\"></p>\n<h2 id=\"创建-StorageClass\">创建 StorageClass</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 NFS 的 StorageClass 的 yaml 示例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nfs-storage.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">storage.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StorageClass</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nfs-csi</span>                                           <span class=\"comment\"># 存储类名称</span></span><br><span class=\"line\"><span class=\"attr\">provisioner:</span> <span class=\"string\">nfs.csi.k8s.io</span>                               <span class=\"comment\"># 指定存储插件的 CSI 驱动名称，需要安装 nfs-csi-driver</span></span><br><span class=\"line\"><span class=\"attr\">reclaimPolicy:</span> <span class=\"string\">Delete</span>                                     <span class=\"comment\"># Retain：PVC 删除后，PV 不会被自动删除（数据保留），默认是 Delete,生产环境慎用。</span></span><br><span class=\"line\"><span class=\"attr\">allowVolumeExpansion:</span> <span class=\"literal\">true</span>                                <span class=\"comment\"># 是否允许 PVC 自动扩容，nfs 支持扩容</span></span><br><span class=\"line\"><span class=\"attr\">mountOptions:</span>                                             <span class=\"comment\"># 挂载选项，csi插件不同，选项不同。这里是 nfs的</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hard</span>                                                  <span class=\"comment\"># 服务器异常时客户端会一直发请求直到挂载成功</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">nfsvers=4.1</span>                                           <span class=\"comment\"># nfs版本    nfs4.1</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">nolock</span>                                                <span class=\"comment\"># 允许多个客户端同时访问</span></span><br><span class=\"line\"><span class=\"attr\">volumeBindingMode:</span> <span class=\"string\">Immediate</span>                              <span class=\"comment\"># 默认值：Immediate: 创建PVC时立即绑定 ,WaitForFirstConsumer：等到 Pod 调度到节点后再分配卷，适合多可用区场景</span></span><br><span class=\"line\"><span class=\"attr\">parameters:</span>                                               <span class=\"comment\"># 参数配置</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.88</span>                                    <span class=\"comment\"># nfs服务器地址</span></span><br><span class=\"line\">  <span class=\"attr\">share:</span> <span class=\"string\">/nfs-server/data</span>                                 <span class=\"comment\"># nfs-server上的存储目录</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>csi-driver-nfs 从 v4.x 起，已经支持 Delete reclaimPolicy 和 allowVolumeExpansion 自动扩容。<br>\n生产环境慎用 Delete reclaimPolicy，因为此时删除 PVC 后，nfs-server 上的存储目录也会被删除。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每个 StorageClass 配置中有三个必填的参数：<code>provisioner</code>、<code>parameters</code> 和 <code>reclaimPolicy</code> 字段， 这些字段会在 StorageClass 需要动态制备 PersistentVolume (PV) 以满足 PersistentVolumeClaim (PVC) 时使用到。</p>\n</li>\n</ul>\n<h3 id=\"provisioner-存储制备器\">provisioner: 存储制备器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。</p>\n</li>\n<li class=\"lvl-2\">\n<p>比如 NFS 存储制备器：<code>provisioner: nfs.csi.k8s.io</code>，是 K8S 官方维护的 NFS CSI 插件。<a href=\"https://github.com/kubernetes-csi/csi-driver-nfs\">Github</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装 NFS CSI 插件：<a href=\"https://github.com/kubernetes-csi/csi-driver-nfs/blob/master/docs/install-csi-driver-master.md\">Install NFS CSI Driver</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在线安装</span></span><br><span class=\"line\">curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/install-driver.sh | bash -s master --</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">kubectl -n kube-system get pod -o wide -l app=csi-nfs-controller</span><br><span class=\"line\">kubectl -n kube-system get pod -o wide -l app=csi-nfs-node</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>卸载</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/uninstall-driver.sh | bash -s master --</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例\">示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 StorageClass</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f nfs-storage.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 查看 storageclass</span></span><br><span class=\"line\">$ k get sc</span><br><span class=\"line\">NAME      PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class=\"line\">nfs-csi   nfs.csi.k8s.io   Delete          Immediate           <span class=\"literal\">true</span>                   5s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 PVC 时指定 storageclass，StorageClass 会自动创建 PV</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nfs-pvc.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nfs-pvc</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs-csi</span>  <span class=\"comment\"># 指定 StorageClass 的名称，如果设置了默认的sc，此处可以删除该配置</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span>          <span class=\"comment\"># 指定访问模式</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">800Mi</span>         <span class=\"comment\"># 申请的容量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 PVC</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 PVC</span></span><br><span class=\"line\">$ k apply -f nfs-pvc.yaml</span><br><span class=\"line\">persistentvolumeclaim/nfs-pvc created</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 PV和PVC，可以看到 PV 自动创建了</span></span><br><span class=\"line\">$ k get pv,pvc</span><br><span class=\"line\">NAME                                                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">persistentvolume/pvc-c1d33fec-5e16-4156-8405-1af4fc171907   800Mi      RWX            Delete           Bound    default/nfs-pvc   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          2m4s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE</span><br><span class=\"line\">persistentvolumeclaim/nfs-pvc   Bound    pvc-c1d33fec-5e16-4156-8405-1af4fc171907   800Mi      RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 2m4s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>自动扩容，修改 PVC 容量到 1Gi</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit pvc nfs-pvc</span><br><span class=\"line\"><span class=\"comment\"># 修改如下</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;storage&quot;:&quot;1Gi&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看 PV 和 PVC，可以看到 自动扩容成功</span></span><br><span class=\"line\">$ k get pv,pvc</span><br><span class=\"line\">NAME                                                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">persistentvolume/pvc-c1d33fec-5e16-4156-8405-1af4fc171907   1Gi        RWX            Delete           Bound    default/nfs-pvc   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          4m50s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE</span><br><span class=\"line\">persistentvolumeclaim/nfs-pvc   Bound    pvc-c1d33fec-5e16-4156-8405-1af4fc171907   1Gi        RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 4m50s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除PVC，自动删除PV</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pvc nfs-pvc</span><br><span class=\"line\"><span class=\"comment\"># 再次查看 PV 和 PVC，可以看到 PV 已经被自动删除， reclaimPolicy: Delete</span></span><br><span class=\"line\">$ k get pv,pvc</span><br><span class=\"line\">No resources found</span><br><span class=\"line\"><span class=\"comment\"># 此时 nfs-server 的目录下的文件也会被删除，生产环境慎用</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"设置默认的-StorageClass\">设置默认的 StorageClass</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面我们创建 PVC 的时候需要指定 StorageClass，如果我们设置一个默认的 StorageClass，那么在PVC里就可以省略掉 StorageClass 的设置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>K8S 中只能设置一个默认的 StorageClass，如果有多个，那么就会报错。</p>\n</li>\n<li class=\"lvl-2\">\n<p>设置默认的 StorageClass</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 为 sc 添加 `默认` 注解，去掉该注解 或者 设置为 false 就取消默认了。</span></span><br><span class=\"line\">$ kubectl patch storageclass nfs-csi -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">storageclass.storage.k8s.io/nfs-csi patched</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看sc，此时看到名称后面多了一个 (default) ，表示这是默认的 StorageClass</span></span><br><span class=\"line\">$ k get sc</span><br><span class=\"line\">NAME                PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class=\"line\">nfs-csi (default)   nfs.csi.k8s.io   Delete          Immediate           <span class=\"literal\">true</span>                   14m</span><br></pre></td></tr></table></figure>\n<h2 id=\"StatefulSet-自动创建-PVC\">StatefulSet: 自动创建 PVC</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面的方式还是要求我们必须创建 PVC，有什么方法可以不用创建 PVC ，而是在创建控制器的时候就一起把 PVC 创建好呢？</p>\n</li>\n<li class=\"lvl-2\">\n<p>目前只有 <code>StatefulSet</code>控制器 才支持自动创建 PVC</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis-statefulset.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 StatefulSet 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span>                    <span class=\"comment\"># Kubernetes 资源类型，这里是部署（StatefulSet）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sts</span>                    <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">sts-ns</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">revisionHistoryLimit:</span> <span class=\"number\">10</span>           <span class=\"comment\"># 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                     <span class=\"comment\"># 选择器，指定 StatefulSet 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">updateStrategy:</span>                    <span class=\"comment\"># 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 StatefulSet 模板后， 老的 StatefulSet Pod 将被终止，并且将以受控方式自动创建新的 StatefulSet Pod。 更新期间，最多只能有 StatefulSet 的一个 Pod 运行于每个节点上。</span></span><br><span class=\"line\">                                     <span class=\"comment\"># 2.OnDelete：使用 OnDelete 更新策略时，在更新 StatefulSet 模板后，只有当你手动删除老的 StatefulSet Pod 之后，新的 StatefulSet Pod 才会被自动创建。</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动升级的配置</span></span><br><span class=\"line\">      <span class=\"attr\">partition:</span> <span class=\"number\">0</span>                   <span class=\"comment\"># 用于控制从第几个 Pod 开始滚动升级</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">redis-svc</span>             <span class=\"comment\"># 服务名称,sts对象使用无头服务，这个是必填项，需要事先创建好</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span>                        <span class=\"comment\"># 副本数，默认是 1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">redis:6.2</span>             <span class=\"comment\"># 容器使用的镜像，这里是官方的 redis 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">redis</span>                  <span class=\"comment\"># 容器的名称</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span>                <span class=\"comment\"># 挂载数据卷</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">redis-data</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/data</span>           <span class=\"comment\"># Redis 持久化数据存储路径，根据实际情况修改</span></span><br><span class=\"line\">  <span class=\"attr\">volumeClaimTemplates:</span>              <span class=\"comment\"># 配置 PVC 模板</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">redis-data</span>               <span class=\"comment\"># PVC 名称</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span>              <span class=\"comment\"># 访问模式：多节点读写</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">storage:</span> <span class=\"string\">500Mi</span>             <span class=\"comment\"># 请求的存储容量，根据实际需求调整</span></span><br><span class=\"line\">      <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs-csi</span>      <span class=\"comment\"># 存储类名称，如果使用默认存储类，则不需要指定</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 StatefulSet，并查看 PV,PVC</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 StatefulSet</span></span><br><span class=\"line\">$ kubectl apply -f redis-statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 PV,PVC</span></span><br><span class=\"line\">$ k get pv,pvc -n sts-ns</span><br><span class=\"line\">NAME                                                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                           STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">persistentvolume/pvc-748fc0d3-a142-4d08-b5c4-7320daea5618   500Mi      RWX            Delete           Bound    sts-ns/redis-data-redis-sts-1   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          19s</span><br><span class=\"line\">persistentvolume/pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784   500Mi      RWX            Delete           Bound    sts-ns/redis-data-redis-sts-0   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          22s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE</span><br><span class=\"line\">persistentvolumeclaim/redis-data-redis-sts-0   Bound    pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784   500Mi      RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 22s</span><br><span class=\"line\">persistentvolumeclaim/redis-data-redis-sts-1   Bound    pvc-748fc0d3-a142-4d08-b5c4-7320daea5618   500Mi      RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 20s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>StatefulSet 的 volumeClaimTemplates 每个 Pod 单独创建 PVC，Pod 和 PVC 一一对应，即有几个副本就创建几个 PVC。PVC 名称是：<code>&lt;volumeClaimTemplates.metadata.name&gt;-&lt;statefulset-name&gt;-&lt;pod-ordinal&gt;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>删除 StatefulSet</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete -f redis-statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 PV,PVC，发现删除 StatefulSet 后，PV 和 PVC 是不会被自动删除的，需要手动删除 PVC</span></span><br><span class=\"line\">$ k get pv,pvc -n sts-ns</span><br><span class=\"line\">NAME                                                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                           STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">persistentvolume/pvc-748fc0d3-a142-4d08-b5c4-7320daea5618   500Mi      RWX            Delete           Bound    sts-ns/redis-data-redis-sts-1   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          6m30s</span><br><span class=\"line\">persistentvolume/pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784   500Mi      RWX            Delete           Bound    sts-ns/redis-data-redis-sts-0   nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                          6m33s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE</span><br><span class=\"line\">persistentvolumeclaim/redis-data-redis-sts-0   Bound    pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784   500Mi      RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 6m33s</span><br><span class=\"line\">persistentvolumeclaim/redis-data-redis-sts-1   Bound    pvc-748fc0d3-a142-4d08-b5c4-7320daea5618   500Mi      RWX            nfs-csi        &lt;<span class=\"built_in\">unset</span>&gt;                 6m31s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手动删除 PVC，因为sc配置的回收策略为 Delete，所以 PV 也会被删除</span></span><br><span class=\"line\">k delete pvc -n sts-ns redis-data-redis-sts-0</span><br><span class=\"line\">k delete pvc -n sts-ns redis-data-redis-sts-1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上，无论是删除 statefulset 还是缩容 statefulset，PVC 都不会被自动删除。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 的 StorageClass，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s StorageClass 官方文档 本文底层存储卷是 NFS StorageClass(别名sc) 介绍 K8s 的存储资源分为两种供应模式：静态供应模式 和 动态供应模式。 静态模式下，管理员需要预先创建许多PV，等待 PVC 来绑定。 动态模式下，Kubernetes 会通过 StorageClass 自动创建 PV，并完成与 PVC 的绑定。 StorageClass 是 Kubernetes 中用来定义 存储后端类型和配置参数 的资源 作用： 自动创建 PV（PersistentVolume）的“模板”或“规则” 使用场景： 配合 PVC 使用时，Kubernetes 可以根据 StorageClass 自动 动态创建 对应的持久卷。 ✅ 核心优势： 无需手动创建 PV 支持多种存储后端（NFS、云盘、Ceph、GlusterFS、iSCSI…） 创建 StorageClass 一个 NFS 的 StorageClass 的 yaml 示例 12345678910111213141516# nfs-storage.yamlapiVersion: storage.k8s.io/v1kind: StorageClassmetadata: name: nfs-csi # 存储类名称provisioner: nfs.csi.k8s.io # 指定存储插件的 CSI 驱动名称，需要安装 nfs-csi-driverreclaimPolicy: Delete # Retain：PVC 删除后，PV 不会被自动删除（数据保留），默认是 Delete,生产环境慎用。allowVolumeExpansion: true # 是否允许 PVC 自动扩容，nfs 支持扩容mountOptions: # 挂载选项，csi插件不同，选项不同。这里是 nfs的 - hard # 服务器异常时客户端会一直发请求直到挂载成功 - nfsvers=4.1 # nfs版本 nfs4.1 - nolock # 允许多个客户端同时访问volumeBindingMode: Immediate # 默认值：Immediate: 创建PVC时立即绑定 ,WaitForFirstConsumer：等到 Pod 调度到节点后再分配卷，适合多可用区场景parameters: # 参数配置 server: 10.211.55.88 # nfs服务器地址 share: /nfs-server/data # nfs-server上的存储目录 csi-driver-nfs 从 v4.x 起，已经支持 Delete reclaimPolicy 和 allowVolumeExpansion 自动扩容。 生产环境慎用 Delete reclaimPolicy，因为此时删除 PVC 后，nfs-server 上的存储目录也会被删除。 每个 StorageClass 配置中有三个必填的参数：provisioner、parameters 和 reclaimPolicy 字段， 这些字段会在 StorageClass 需要动态制备 PersistentVolume (PV) 以满足 PersistentVolumeClaim (PVC) 时使用到。 provisioner: 存储制备器 每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。 比如 NFS 存储制备器：provisioner: nfs.csi.k8s.io，是 K8S 官方维护的 NFS CSI 插件。Github。 安装 NFS CSI 插件：Install NFS CSI Driver 123456# 在线安装curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/install-driver.sh | bash -s master --# 验证kubectl -n kube-system get pod -o wide -l app=csi-nfs-controllerkubectl -n kube-system get pod -o wide -l app=csi-nfs-node 卸载 1curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/uninstall-driver.sh | bash -s master -- 示例 创建 StorageClass 123456kubectl apply -f nfs-storage.yaml## 查看 storageclass$ k get scNAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGEnfs-csi nfs.csi.k8s.io Delete Immediate true 5s 创建 PVC 时指定 storageclass，StorageClass 会自动创建 PV 12345678910111213# nfs-pvc.yamlapiVersion: v1kind: PersistentVolumeClaimmetadata: name: nfs-pvc namespace: defaultspec: storageClassName: nfs-csi # 指定 StorageClass 的名称，如果设置了默认的sc，此处可以删除该配置 accessModes: - ReadWriteMany # 指定访问模式 resources: requests: storage: 800Mi # 申请的容量 创建 PVC 1234567891011# 创建 PVC$ k apply -f nfs-pvc.yamlpersistentvolumeclaim/nfs-pvc created# 查看 PV和PVC，可以看到 PV 自动创建了$ k get pv,pvcNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpersistentvolume/pvc-c1d33fec-5e16-4156-8405-1af4fc171907 800Mi RWX Delete Bound default/nfs-pvc nfs-csi &lt;unset&gt; 2m4sNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGEpersistentvolumeclaim/nfs-pvc Bound pvc-c1d33fec-5e16-4156-8405-1af4fc171907 800Mi RWX nfs-csi &lt;unset&gt; 2m4s 自动扩容，修改 PVC 容量到 1Gi 1234567891011kubectl edit pvc nfs-pvc# 修改如下# &quot;storage&quot;:&quot;1Gi&quot;# 再次查看 PV 和 PVC，可以看到 自动扩容成功$ k get pv,pvcNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpersistentvolume/pvc-c1d33fec-5e16-4156-8405-1af4fc171907 1Gi RWX Delete Bound default/nfs-pvc nfs-csi &lt;unset&gt; 4m50sNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGEpersistentvolumeclaim/nfs-pvc Bound pvc-c1d33fec-5e16-4156-8405-1af4fc171907 1Gi RWX nfs-csi &lt;unset&gt; 4m50s 删除PVC，自动删除PV 12345kubectl delete pvc nfs-pvc# 再次查看 PV 和 PVC，可以看到 PV 已经被自动删除， reclaimPolicy: Delete$ k get pv,pvcNo resources found# 此时 nfs-server 的目录下的文件也会被删除，生产环境慎用 设置默认的 StorageClass 上面我们创建 PVC 的时候需要指定 StorageClass，如果我们设置一个默认的 StorageClass，那么在PVC里就可以省略掉 StorageClass 的设置。 K8S 中只能设置一个默认的 StorageClass，如果有多个，那么就会报错。 设置默认的 StorageClass 12345678# 为 sc 添加 `默认` 注解，去掉该注解 或者 设置为 false 就取消默认了。$ kubectl patch storageclass nfs-csi -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;storageclass.storage.k8s.io/nfs-csi patched# 查看sc，此时看到名称后面多了一个 (default) ，表示这是默认的 StorageClass$ k get scNAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGEnfs-csi (default) nfs.csi.k8s.io Delete Immediate true 14m StatefulSet: 自动创建 PVC 上面的方式还是要求我们必须创建 PVC，有什么方法可以不用创建 PVC ，而是在创建控制器的时候就一起把 PVC 创建好呢？ 目前只有 StatefulSet控制器 才支持自动创建 PVC 123456789101112131415161718192021222324252627282930313233343536373839# redis-statefulset.yamlapiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 StatefulSet 资源kind: StatefulSet # Kubernetes 资源类型，这里是部署（StatefulSet）metadata: name: redis-sts # 资源名称，必须唯一（在同一命名空间下） namespace: sts-nsspec: # 配置项 revisionHistoryLimit: 10 # 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: redis # 选择器，指定 StatefulSet 管理哪些 Pod（标签必须与 template 中匹配） updateStrategy: # 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样 type: RollingUpdate # 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 StatefulSet 模板后， 老的 StatefulSet Pod 将被终止，并且将以受控方式自动创建新的 StatefulSet Pod。 更新期间，最多只能有 StatefulSet 的一个 Pod 运行于每个节点上。 # 2.OnDelete：使用 OnDelete 更新策略时，在更新 StatefulSet 模板后，只有当你手动删除老的 StatefulSet Pod 之后，新的 StatefulSet Pod 才会被自动创建。 rollingUpdate: # 滚动升级的配置 partition: 0 # 用于控制从第几个 Pod 开始滚动升级 serviceName: redis-svc # 服务名称,sts对象使用无头服务，这个是必填项，需要事先创建好 replicas: 2 # 副本数，默认是 1 template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: redis # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: redis:6.2 # 容器使用的镜像，这里是官方的 redis 镜像 name: redis # 容器的名称 volumeMounts: # 挂载数据卷 - name: redis-data mountPath: /data # Redis 持久化数据存储路径，根据实际情况修改 volumeClaimTemplates: # 配置 PVC 模板 - metadata: name: redis-data # PVC 名称 spec: accessModes: - ReadWriteMany # 访问模式：多节点读写 resources: requests: storage: 500Mi # 请求的存储容量，根据实际需求调整 storageClassName: nfs-csi # 存储类名称，如果使用默认存储类，则不需要指定 创建 StatefulSet，并查看 PV,PVC 123456789101112# 创建 StatefulSet$ kubectl apply -f redis-statefulset.yaml# 查看 PV,PVC$ k get pv,pvc -n sts-nsNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpersistentvolume/pvc-748fc0d3-a142-4d08-b5c4-7320daea5618 500Mi RWX Delete Bound sts-ns/redis-data-redis-sts-1 nfs-csi &lt;unset&gt; 19spersistentvolume/pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784 500Mi RWX Delete Bound sts-ns/redis-data-redis-sts-0 nfs-csi &lt;unset&gt; 22sNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGEpersistentvolumeclaim/redis-data-redis-sts-0 Bound pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784 500Mi RWX nfs-csi &lt;unset&gt; 22spersistentvolumeclaim/redis-data-redis-sts-1 Bound pvc-748fc0d3-a142-4d08-b5c4-7320daea5618 500Mi RWX nfs-csi &lt;unset&gt; 20s StatefulSet 的 volumeClaimTemplates 每个 Pod 单独创建 PVC，Pod 和 PVC 一一对应，即有几个副本就创建几个 PVC。PVC 名称是：&lt;volumeClaimTemplates.metadata.name&gt;-&lt;statefulset-name&gt;-&lt;pod-ordinal&gt; 删除 StatefulSet 123456789101112131415kubectl delete -f redis-statefulset.yaml# 查看 PV,PVC，发现删除 StatefulSet 后，PV 和 PVC 是不会被自动删除的，需要手动删除 PVC$ k get pv,pvc -n sts-nsNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpersistentvolume/pvc-748fc0d3-a142-4d08-b5c4-7320daea5618 500Mi RWX Delete Bound sts-ns/redis-data-redis-sts-1 nfs-csi &lt;unset&gt; 6m30spersistentvolume/pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784 500Mi RWX Delete Bound sts-ns/redis-data-redis-sts-0 nfs-csi &lt;unset&gt; 6m33sNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGEpersistentvolumeclaim/redis-data-redis-sts-0 Bound pvc-807018bb-ec66-4a5c-87f1-9c11df6f4784 500Mi RWX nfs-csi &lt;unset&gt; 6m33spersistentvolumeclaim/redis-data-redis-sts-1 Bound pvc-748fc0d3-a142-4d08-b5c4-7320daea5618 500Mi RWX nfs-csi &lt;unset&gt; 6m31s# 手动删除 PVC，因为sc配置的回收策略为 Delete，所以 PV 也会被删除k delete pvc -n sts-ns redis-data-redis-sts-0k delete pvc -n sts-ns redis-data-redis-sts-1 实际上，无论是删除 statefulset 还是缩容 statefulset，PVC 都不会被自动删除。","summary":"摘要 本文介绍 K8S 的 StorageClass，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s StorageClass 官方文档 本文底层存储卷是 NFS","date_published":"2025-07-22T12:35:15.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-pv-pvc/","url":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-pv-pvc/","title":"K8S 之 持久卷 PV 和 PVC","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 持久卷 PV 和 PVC ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/\">k8s PV/PVC 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文底层存储卷是 NFS</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"PV-和-PVC-介绍\">PV 和 PVC 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>PV(PersistentVolume) 是 Kubernetes 中的一种存储资源，用于将底层的物理存储（如 NFS、iSCSI、Ceph、云存储等）抽象成 Kubernetes 资源，供 Pod 使用。它是对存储的一种“声明式”管理，类似于 Pod 声明计算资源。PV 是集群级别的存储资源，不支持 Namespace。</p>\n</li>\n<li class=\"lvl-2\">\n<p>PVC(PersistentVolumeClaim)，持久卷声明， 是 Kubernetes 中用于申请存储资源的对象。PVC 是 Namespace 级别的资源。</p>\n</li>\n<li class=\"lvl-2\">\n<p>简而言之：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">PV 是集群中的一块存储，由管理员提前配置或动态创建。</li>\n<li class=\"lvl-4\">PVC（PersistentVolumeClaim） 是用户对存储的申请。</li>\n<li class=\"lvl-4\">Pod 通过 PVC 绑定到 PV，使用持久化存储。</li>\n<li class=\"lvl-4\">开发者用 PVC 来申请存储空间，不关心存储的具体实现方式。</li>\n<li class=\"lvl-4\">PVC 通过 Kubernetes 自动匹配一个合适的 PersistentVolume（PV）进行绑定。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>PV 与 PVC 的基本流程</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">管理员创建 PV（或者集群通过 StorageClass 自动创建）。</li>\n<li class=\"lvl-4\">用户提交 PVC，声明自己需要多少容量、什么访问模式。</li>\n<li class=\"lvl-4\">Kubernetes 查找可用的 PV，条件符合（容量、访问模式、StorageClass）就自动绑定。</li>\n<li class=\"lvl-4\">Pod 挂载 PVC，实现持久化存储。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PV-示例\">PV 示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个使用 NFS 存储卷的 PV 示例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pv-nfs.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-nfs-1g</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumeMode:</span> <span class=\"string\">Filesystem</span>                 <span class=\"comment\"># 存储卷模式，默认为 Filesystem</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span>                              <span class=\"comment\"># 存储能力</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span>                         <span class=\"comment\"># 容量大小，Gi 或 Mi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span>                           <span class=\"comment\"># 访问模式</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span>                      <span class=\"comment\"># 访问模式</span></span><br><span class=\"line\">  <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span>  <span class=\"comment\"># 回收策略</span></span><br><span class=\"line\">  <span class=\"attr\">nfs:</span>                                   <span class=\"comment\"># 持久卷类型（如 hostPath、nfs、ceph 等）</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/nfs-server/data/pv-nfs-1g</span>     <span class=\"comment\"># 存储路径要确保已经存在</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.88</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-nfs-2g</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span>                              <span class=\"comment\"># 存储能力</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">2Gi</span>                         <span class=\"comment\"># 容量大小，Gi 或 Mi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span>                           <span class=\"comment\"># 访问模式</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span>                      <span class=\"comment\"># 访问模式</span></span><br><span class=\"line\">  <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span>  <span class=\"comment\"># 回收策略</span></span><br><span class=\"line\">  <span class=\"attr\">nfs:</span>                                   <span class=\"comment\"># 存储类型（如 hostPath、nfs、ceph 等）</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/nfs-server/data/pv-nfs-2g</span>     <span class=\"comment\"># 存储路径要确保已经存在</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.88</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"存储卷模式\">存储卷模式</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-mode\">官网文档:存储卷模式</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 支持两种卷模式（volumeModes）：Filesystem（文件系统） 和 Block（块）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果该参数被省略，默认的卷模式是 Filesystem。</p>\n</li>\n<li class=\"lvl-2\">\n<p>volumeMode 属性设置为 Filesystem 的卷会被 Pod 挂载（Mount） 到某个目录。</p>\n</li>\n</ul>\n<h3 id=\"持久卷类型\">持久卷类型</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes\">官网文档:持久卷类型</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ 当前支持的插件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>插件类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>csi</strong></td>\n<td><strong>容器存储接口（CSI）</strong>，推荐的现代存储接口</td>\n</tr>\n<tr>\n<td><strong>fc</strong></td>\n<td>Fibre Channel 存储</td>\n</tr>\n<tr>\n<td><strong>hostPath</strong></td>\n<td>HostPath 卷（仅供单节点测试使用；多节点不推荐，推荐使用 local 卷替代）</td>\n</tr>\n<tr>\n<td><strong>iscsi</strong></td>\n<td>iSCSI（基于 IP 的 SCSI 存储）</td>\n</tr>\n<tr>\n<td><strong>local</strong></td>\n<td>节点本地存储设备</td>\n</tr>\n<tr>\n<td><strong>nfs</strong></td>\n<td>网络文件系统（NFS）存储</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 已弃用但仍可用（需 CSI 迁移）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>插件类型</th>\n<th>描述</th>\n<th>CSI 迁移状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>awsElasticBlockStore</strong></td>\n<td>AWS EBS 块存储</td>\n<td>从 v1.23 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>azureDisk</strong></td>\n<td>Azure 磁盘存储</td>\n<td>从 v1.23 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>azureFile</strong></td>\n<td>Azure 文件存储</td>\n<td>从 v1.24 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>cinder</strong></td>\n<td>OpenStack 块存储</td>\n<td>从 v1.21 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>flexVolume</strong></td>\n<td>FlexVolume（无迁移计划，但未计划移除）</td>\n<td>从 v1.23 开始弃用</td>\n</tr>\n<tr>\n<td><strong>gcePersistentDisk</strong></td>\n<td>GCP 持久磁盘</td>\n<td>从 v1.23 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>portworxVolume</strong></td>\n<td>Portworx 存储卷</td>\n<td>从 v1.31 开始默认迁移</td>\n</tr>\n<tr>\n<td><strong>vsphereVolume</strong></td>\n<td>vSphere VMDK 卷</td>\n<td>从 v1.25 开始默认迁移</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>❌ 已废弃/即将移除的 In-Tree 插件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>插件类型</th>\n<th>描述</th>\n<th>弃用/移除版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>cephfs</strong></td>\n<td>Ceph 文件系统卷</td>\n<td>v1.31 之后不可用</td>\n</tr>\n<tr>\n<td><strong>flocker</strong></td>\n<td>Flocker 存储</td>\n<td>v1.25 之后不可用</td>\n</tr>\n<tr>\n<td><strong>glusterfs</strong></td>\n<td>GlusterFS 存储</td>\n<td>v1.26 之后不可用</td>\n</tr>\n<tr>\n<td><strong>photonPersistentDisk</strong></td>\n<td>Photon 持久磁盘</td>\n<td>v1.15 之后不可用</td>\n</tr>\n<tr>\n<td><strong>quobyte</strong></td>\n<td>Quobyte 卷</td>\n<td>v1.25 之后不可用</td>\n</tr>\n<tr>\n<td><strong>rbd</strong></td>\n<td>Rados 块设备（Ceph RBD）</td>\n<td>v1.31 之后不可用</td>\n</tr>\n<tr>\n<td><strong>scaleIO</strong></td>\n<td>ScaleIO 卷</td>\n<td>v1.21 之后不可用</td>\n</tr>\n<tr>\n<td><strong>storageos</strong></td>\n<td>StorageOS 卷</td>\n<td>v1.25 之后不可用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"accessModes-访问模式\">accessModes 访问模式</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes\">官网文档:访问模式</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>访问模式</th>\n<th>说明</th>\n<th>是否跨节点挂载</th>\n<th>是否支持多 Pod 挂载</th>\n<th>是否支持读写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ReadWriteOnce (RWO)</strong></td>\n<td>卷可以被一个节点以读写方式挂载，同一节点内多个 Pod 可共享使用。</td>\n<td>❌ 否</td>\n<td>✅ 是（同一节点）</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><strong>ReadOnlyMany (ROX)</strong></td>\n<td>卷可以被多个节点以只读方式挂载。</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>❌ 否（只读）</td>\n</tr>\n<tr>\n<td><strong>ReadWriteMany (RWX)</strong></td>\n<td>卷可以被多个节点以读写方式挂载。</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><strong>ReadWriteOncePod (RWOP)</strong></td>\n<td>卷只能被单个 Pod 以读写方式挂载，确保集群中只有一个 Pod 使用该卷（v1.29+稳定）。</td>\n<td>❌ 否</td>\n<td>❌ 否（只能一个 Pod）</td>\n<td>✅ 是</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NFS 支持前三种访问模式，hostPath 只支持 ReadWriteOnce。</p>\n</li>\n</ul>\n<h3 id=\"persistentVolumeReclaimPolicy-回收策略\">persistentVolumeReclaimPolicy 回收策略</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reclaim-policy\">官方文档:回收策略</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>回收策略</th>\n<th>含义</th>\n<th>回收行为</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Retain</strong></td>\n<td><strong>保留</strong>：删除 PVC 后，PV 和后端存储仍然保留</td>\n<td>手动回收，PVC 删除后 PV 状态为 <code>Released</code>，需要手动清理或重新绑定</td>\n<td>重要数据，避免误删；如数据库数据盘</td>\n</tr>\n<tr>\n<td><strong>Delete</strong></td>\n<td><strong>删除</strong>：删除 PVC 后，PV 和后端存储都会被删除</td>\n<td>自动回收，PVC 删除时自动删除 PV 和后端存储资源（如云盘）</td>\n<td>临时数据、不重要的存储</td>\n</tr>\n<tr>\n<td><strong>Recycle</strong></td>\n<td><strong>回收</strong>：简单清空数据</td>\n<td>自动执行 <code>rm -rf /thevolume/*</code>，然后 PV 变回 <code>Available</code> 状态</td>\n<td>旧版本集群的小文件临时存储</td>\n</tr>\n</tbody>\n</table>\n<div class=\"warning\">\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p><strong>注意</strong>: 创建 <strong>Recycle</strong> 的 PV 时，会提示如下内容</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: spec.persistentVolumeReclaimPolicy: The Recycle reclaim policy is deprecated. Instead, the recommended approach is to use dynamic provisioning.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>意思就是 <strong>Recycle</strong> 策略已被弃用，建议使用<code>动态供应模式</code>。但<a href=\"https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reclaim-policy\">官方文档</a>中却提示 <code>对于 Kubernetes 1.33 来说，只有 nfs 和 hostPath 卷类型支持回收（Recycle）。</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>本人在 Kubernetes 1.33.2 中测试，NFS 支持 Recycle，删除 PVC 后 PV 状态会变为 <strong>Available</strong></p>\n</li>\n</ul>\n</div>\n<h3 id=\"管理-PV\">管理 PV</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建</span></span><br><span class=\"line\">kubectl create -f pv-nfs.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">$ k get pv</span><br><span class=\"line\">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">pv-nfs-1g   1Gi        RWO            Retain           Available                          &lt;<span class=\"built_in\">unset</span>&gt;                          80s</span><br><span class=\"line\">pv-nfs-2g   2Gi        RWX            Retain           Available                          &lt;<span class=\"built_in\">unset</span>&gt;                          80s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">kubectl delete pv pv-nfs-1g</span><br><span class=\"line\">k delete -f pv-nfs.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"PVC-示例\">PVC 示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 通过 PVC 向 PV 申请存储空间，如果 PVC 一直无法匹配到 PV，则 PVC 处于 Pending 状态。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pod 必须与 PVC 处于同一命名空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>PVC 与 PV 是 1:1 的关系。一旦 PV 绑定到 PVC，则 PVC 状态变为 Bound。该 PV 将不再被其他 PVC 绑定。</p>\n</li>\n<li class=\"lvl-2\">\n<p>PVC 与 PV 匹配的条件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>匹配条件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>容量</strong></td>\n<td><strong>PVC 请求的容量 ≤ PV 提供的容量</strong>。PV 必须至少满足 PVC 的容量请求。</td>\n</tr>\n<tr>\n<td><strong>访问模式</strong></td>\n<td><strong>PV 支持 PVC 请求的访问模式</strong>。PVC 要求的所有访问模式，PV 都必须具备。例如：PVC 要求 <code>ReadWriteOnce</code>，PV 至少要支持 <code>ReadWriteOnce</code>。</td>\n</tr>\n<tr>\n<td><strong>StorageClass</strong></td>\n<td><strong>PVC 和 PV 的 <code>storageClassName</code> 必须一致</strong>。如果 PVC 指定了 <code>storageClassName</code>，只能绑定同名的 PV。</td>\n</tr>\n<tr>\n<td><strong>Selector（可选）</strong></td>\n<td>如果 PVC 有设置 <code>selector</code>（基于标签），PV 的标签也必须匹配。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">PV 中声明的 <code>accessModes</code> 仅作为与 PVC 的访问模式进行匹配，实际挂载到 Pod 后，不会限制 Pod 的读写访问</li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个简单的 yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pvc.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mypvc</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span>   <span class=\"comment\"># 申请匹配的访问模式</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">500Mi</span>  <span class=\"comment\"># 申请的容量，实际容量以匹配的 PV 为准</span></span><br><span class=\"line\">  <span class=\"comment\"># selector:         # 匹配的 PV 标签</span></span><br><span class=\"line\">  <span class=\"comment\">#   matchLabels:</span></span><br><span class=\"line\">  <span class=\"comment\">#     pv: nfs-pv1   # pv 的标签，创建 pv 时要指定</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"管理-PVC\">管理 PVC</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 PVC</span></span><br><span class=\"line\">kubectl apply -f pvc.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看PVC，此时看到 pv-nfs-1g 绑定了 PVC</span></span><br><span class=\"line\">$ k get pv,pvc</span><br><span class=\"line\">NAME                         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM           STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">persistentvolume/pv-nfs-1g   1Gi        RWO            Retain           Available                                  &lt;<span class=\"built_in\">unset</span>&gt;                          16s</span><br><span class=\"line\">persistentvolume/pv-nfs-2g   2Gi        RWX            Retain           Bound       default/mypvc                  &lt;<span class=\"built_in\">unset</span>&gt;                          16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                          STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE</span><br><span class=\"line\">persistentvolumeclaim/mypvc   Bound    pv-nfs-2g   2Gi        RWX                           &lt;<span class=\"built_in\">unset</span>&gt;                 9s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 PVC</span></span><br><span class=\"line\">kubectl delete pvc mypvc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时再次查看 PV，pv-nfs-1g 状态变更为 Released，表示已经释放，但是不能再被其它 PVC 绑定了，只能删除重建了</span></span><br><span class=\"line\">$ k get pv</span><br><span class=\"line\">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM           STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE</span><br><span class=\"line\">pv-nfs-1g   1Gi        RWO            Retain           Available                                              &lt;<span class=\"built_in\">unset</span>&gt;                          18m</span><br><span class=\"line\">pv-nfs-2g   2Gi        RWX            Retain           Released     default/mypvc                             &lt;<span class=\"built_in\">unset</span>&gt;                          18m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 PV</span></span><br><span class=\"line\">k delete pv pv-nfs-1g</span><br></pre></td></tr></table></figure>\n<h2 id=\"Pod-绑定-PVC\">Pod 绑定 PVC</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里以 nginx deployment 为例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nginx-pvc-deployment.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-pvc-deployment</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>                              <span class=\"comment\"># 3个 pod会共享一个 PVC</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx-pvc</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx-pvc</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-storage</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span>  <span class=\"comment\"># 挂载到 nginx 的默认网页目录</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-storage</span></span><br><span class=\"line\">        <span class=\"attr\">persistentVolumeClaim:</span>              <span class=\"comment\"># 指定存储卷类型是 PVC</span></span><br><span class=\"line\">          <span class=\"attr\">claimName:</span> <span class=\"string\">mypvc</span>                  <span class=\"comment\"># 对应你创建的 PVC 名称</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 PVC 对应一个 PV，但是一个 PVC 可以对应多个 Deployment 等控制器。下面我们就再创建一个 Deployment，将 相同的 PVC 挂载到容器中，并且每隔5秒修改一次 PVC 挂载的网页，并通过 nginx 容器查看结果</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># busybox-deployment.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">busybox-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo $(date) &gt; /data/index.html; sleep 5; done&quot;</span>]</span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">shared-volume</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/data</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">shared-volume</span></span><br><span class=\"line\">        <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">          <span class=\"attr\">claimName:</span> <span class=\"string\">mypvc</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建后查看 pod ip</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get pod -o wide</span><br><span class=\"line\">NAME                                    READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">busybox-deployment-d7589665d-dx2rs      1/1     Running   0          2m59s   10.244.126.6     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">nginx-pvc-deployment-775b8c4f8b-89cw7   1/1     Running   0          44s     10.244.126.8     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">nginx-pvc-deployment-775b8c4f8b-fszlf   1/1     Running   0          44s     10.244.194.123   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">nginx-pvc-deployment-775b8c4f8b-w9qkt   1/1     Running   0          44s     10.244.126.7     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问任意一个 nginx pod</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时会看到页面内容在变化</span></span><br><span class=\"line\">watch -n 5 curl 10.244.194.123</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为 pod 绑定 pvc时，每次都要先创建 pv 和 pvc，非常麻烦。有什么好的解决方案吗？</p>\n<blockquote>\n<p>使用 StorageClass 实现自动创建 PV，我们下文将介绍如何实现。</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>如果 PVC 被 Pod 使用，则此时可以删除 PVC 吗？</p>\n<blockquote>\n<p>不可以，PVC 被 Pod 使用，此时只能等待 Pod 删除后才能删除 PVC。<br>\n若此时执行了删除 PVC 命令，终端会一直等待，ctrl + c 退出后再次查看 PVC 状态，会看到 PVC 状态为 Terminating。但此时不会影响存Pod对储卷的使用。<br>\n此时一旦Pod 删除，PVC 就会被删除。</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>如果PV 被 PVC 使用，则此时可以删除 PV 吗？</p>\n<blockquote>\n<p>不可以，PV 被 PVC 使用，此时只能等待 PVC 删除后才能删除 PV。<br>\n若此时执行了删除 PV 命令，终端会一直等待，ctrl + c 退出后再次查看 PV 状态，会看到 PV 状态为 Terminating。但此时不会影响Pod对存储卷的使用。<br>\n此时一旦 PVC 删除，PV 就会被删除。</p>\n</blockquote>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 的 持久卷 PV 和 PVC ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s PV/PVC 官方文档 本文底层存储卷是 NFS PV 和 PVC 介绍 PV(PersistentVolume) 是 Kubernetes 中的一种存储资源，用于将底层的物理存储（如 NFS、iSCSI、Ceph、云存储等）抽象成 Kubernetes 资源，供 Pod 使用。它是对存储的一种“声明式”管理，类似于 Pod 声明计算资源。PV 是集群级别的存储资源，不支持 Namespace。 PVC(PersistentVolumeClaim)，持久卷声明， 是 Kubernetes 中用于申请存储资源的对象。PVC 是 Namespace 级别的资源。 简而言之： PV 是集群中的一块存储，由管理员提前配置或动态创建。 PVC（PersistentVolumeClaim） 是用户对存储的申请。 Pod 通过 PVC 绑定到 PV，使用持久化存储。 开发者用 PVC 来申请存储空间，不关心存储的具体实现方式。 PVC 通过 Kubernetes 自动匹配一个合适的 PersistentVolume（PV）进行绑定。 PV 与 PVC 的基本流程 管理员创建 PV（或者集群通过 StorageClass 自动创建）。 用户提交 PVC，声明自己需要多少容量、什么访问模式。 Kubernetes 查找可用的 PV，条件符合（容量、访问模式、StorageClass）就自动绑定。 Pod 挂载 PVC，实现持久化存储。 PV 示例 一个使用 NFS 存储卷的 PV 示例 1234567891011121314151617181920212223242526272829# pv-nfs.yamlapiVersion: v1kind: PersistentVolumemetadata: name: pv-nfs-1gspec: volumeMode: Filesystem # 存储卷模式，默认为 Filesystem capacity: # 存储能力 storage: 1Gi # 容量大小，Gi 或 Mi accessModes: # 访问模式 - ReadWriteOnce # 访问模式 persistentVolumeReclaimPolicy: Retain # 回收策略 nfs: # 持久卷类型（如 hostPath、nfs、ceph 等） path: /nfs-server/data/pv-nfs-1g # 存储路径要确保已经存在 server: 10.211.55.88---apiVersion: v1kind: PersistentVolumemetadata: name: pv-nfs-2gspec: capacity: # 存储能力 storage: 2Gi # 容量大小，Gi 或 Mi accessModes: # 访问模式 - ReadWriteMany # 访问模式 persistentVolumeReclaimPolicy: Retain # 回收策略 nfs: # 存储类型（如 hostPath、nfs、ceph 等） path: /nfs-server/data/pv-nfs-2g # 存储路径要确保已经存在 server: 10.211.55.88 存储卷模式 官网文档:存储卷模式 Kubernetes 支持两种卷模式（volumeModes）：Filesystem（文件系统） 和 Block（块）。 如果该参数被省略，默认的卷模式是 Filesystem。 volumeMode 属性设置为 Filesystem 的卷会被 Pod 挂载（Mount） 到某个目录。 持久卷类型 官网文档:持久卷类型 ✅ 当前支持的插件 插件类型 描述 csi 容器存储接口（CSI），推荐的现代存储接口 fc Fibre Channel 存储 hostPath HostPath 卷（仅供单节点测试使用；多节点不推荐，推荐使用 local 卷替代） iscsi iSCSI（基于 IP 的 SCSI 存储） local 节点本地存储设备 nfs 网络文件系统（NFS）存储 ⚠️ 已弃用但仍可用（需 CSI 迁移） 插件类型 描述 CSI 迁移状态 awsElasticBlockStore AWS EBS 块存储 从 v1.23 开始默认迁移 azureDisk Azure 磁盘存储 从 v1.23 开始默认迁移 azureFile Azure 文件存储 从 v1.24 开始默认迁移 cinder OpenStack 块存储 从 v1.21 开始默认迁移 flexVolume FlexVolume（无迁移计划，但未计划移除） 从 v1.23 开始弃用 gcePersistentDisk GCP 持久磁盘 从 v1.23 开始默认迁移 portworxVolume Portworx 存储卷 从 v1.31 开始默认迁移 vsphereVolume vSphere VMDK 卷 从 v1.25 开始默认迁移 ❌ 已废弃/即将移除的 In-Tree 插件 插件类型 描述 弃用/移除版本 cephfs Ceph 文件系统卷 v1.31 之后不可用 flocker Flocker 存储 v1.25 之后不可用 glusterfs GlusterFS 存储 v1.26 之后不可用 photonPersistentDisk Photon 持久磁盘 v1.15 之后不可用 quobyte Quobyte 卷 v1.25 之后不可用 rbd Rados 块设备（Ceph RBD） v1.31 之后不可用 scaleIO ScaleIO 卷 v1.21 之后不可用 storageos StorageOS 卷 v1.25 之后不可用 accessModes 访问模式 官网文档:访问模式 访问模式 说明 是否跨节点挂载 是否支持多 Pod 挂载 是否支持读写 ReadWriteOnce (RWO) 卷可以被一个节点以读写方式挂载，同一节点内多个 Pod 可共享使用。 ❌ 否 ✅ 是（同一节点） ✅ 是 ReadOnlyMany (ROX) 卷可以被多个节点以只读方式挂载。 ✅ 是 ✅ 是 ❌ 否（只读） ReadWriteMany (RWX) 卷可以被多个节点以读写方式挂载。 ✅ 是 ✅ 是 ✅ 是 ReadWriteOncePod (RWOP) 卷只能被单个 Pod 以读写方式挂载，确保集群中只有一个 Pod 使用该卷（v1.29+稳定）。 ❌ 否 ❌ 否（只能一个 Pod） ✅ 是 NFS 支持前三种访问模式，hostPath 只支持 ReadWriteOnce。 persistentVolumeReclaimPolicy 回收策略 官方文档:回收策略 回收策略 含义 回收行为 典型使用场景 Retain 保留：删除 PVC 后，PV 和后端存储仍然保留 手动回收，PVC 删除后 PV 状态为 Released，需要手动清理或重新绑定 重要数据，避免误删；如数据库数据盘 Delete 删除：删除 PVC 后，PV 和后端存储都会被删除 自动回收，PVC 删除时自动删除 PV 和后端存储资源（如云盘） 临时数据、不重要的存储 Recycle 回收：简单清空数据 自动执行 rm -rf /thevolume/*，然后 PV 变回 Available 状态 旧版本集群的小文件临时存储 注意: 创建 Recycle 的 PV 时，会提示如下内容 1Warning: spec.persistentVolumeReclaimPolicy: The Recycle reclaim policy is deprecated. Instead, the recommended approach is to use dynamic provisioning. 意思就是 Recycle 策略已被弃用，建议使用动态供应模式。但官方文档中却提示 对于 Kubernetes 1.33 来说，只有 nfs 和 hostPath 卷类型支持回收（Recycle）。 本人在 Kubernetes 1.33.2 中测试，NFS 支持 Recycle，删除 PVC 后 PV 状态会变为 Available 管理 PV 123456789101112# 创建kubectl create -f pv-nfs.yaml# 查看$ k get pvNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpv-nfs-1g 1Gi RWO Retain Available &lt;unset&gt; 80spv-nfs-2g 2Gi RWX Retain Available &lt;unset&gt; 80s# 删除kubectl delete pv pv-nfs-1gk delete -f pv-nfs.yaml PVC 示例 Pod 通过 PVC 向 PV 申请存储空间，如果 PVC 一直无法匹配到 PV，则 PVC 处于 Pending 状态。 Pod 必须与 PVC 处于同一命名空间。 PVC 与 PV 是 1:1 的关系。一旦 PV 绑定到 PVC，则 PVC 状态变为 Bound。该 PV 将不再被其他 PVC 绑定。 PVC 与 PV 匹配的条件 匹配条件 说明 容量 PVC 请求的容量 ≤ PV 提供的容量。PV 必须至少满足 PVC 的容量请求。 访问模式 PV 支持 PVC 请求的访问模式。PVC 要求的所有访问模式，PV 都必须具备。例如：PVC 要求 ReadWriteOnce，PV 至少要支持 ReadWriteOnce。 StorageClass PVC 和 PV 的 storageClassName 必须一致。如果 PVC 指定了 storageClassName，只能绑定同名的 PV。 Selector（可选） 如果 PVC 有设置 selector（基于标签），PV 的标签也必须匹配。 小贴士 PV 中声明的 accessModes 仅作为与 PVC 的访问模式进行匹配，实际挂载到 Pod 后，不会限制 Pod 的读写访问 一个简单的 yaml 123456789101112131415# pvc.yamlapiVersion: v1kind: PersistentVolumeClaimmetadata: name: mypvc namespace: defaultspec: accessModes: - ReadWriteMany # 申请匹配的访问模式 resources: requests: storage: 500Mi # 申请的容量，实际容量以匹配的 PV 为准 # selector: # 匹配的 PV 标签 # matchLabels: # pv: nfs-pv1 # pv 的标签，创建 pv 时要指定 管理 PVC 1234567891011121314151617181920212223# 创建 PVCkubectl apply -f pvc.yaml# 查看PVC，此时看到 pv-nfs-1g 绑定了 PVC$ k get pv,pvcNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpersistentvolume/pv-nfs-1g 1Gi RWO Retain Available &lt;unset&gt; 16spersistentvolume/pv-nfs-2g 2Gi RWX Retain Bound default/mypvc &lt;unset&gt; 16sNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGEpersistentvolumeclaim/mypvc Bound pv-nfs-2g 2Gi RWX &lt;unset&gt; 9s# 删除 PVCkubectl delete pvc mypvc# 此时再次查看 PV，pv-nfs-1g 状态变更为 Released，表示已经释放，但是不能再被其它 PVC 绑定了，只能删除重建了$ k get pvNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS VOLUMEATTRIBUTESCLASS REASON AGEpv-nfs-1g 1Gi RWO Retain Available &lt;unset&gt; 18mpv-nfs-2g 2Gi RWX Retain Released default/mypvc &lt;unset&gt; 18m# 删除 PVk delete pv pv-nfs-1g Pod 绑定 PVC 这里以 nginx deployment 为例 12345678910111213141516171819202122232425262728# nginx-pvc-deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: nginx-pvc-deployment namespace: defaultspec: replicas: 3 # 3个 pod会共享一个 PVC selector: matchLabels: app: nginx-pvc template: metadata: labels: app: nginx-pvc spec: containers: - name: nginx image: nginx ports: - containerPort: 80 volumeMounts: - name: nginx-storage mountPath: /usr/share/nginx/html # 挂载到 nginx 的默认网页目录 volumes: - name: nginx-storage persistentVolumeClaim: # 指定存储卷类型是 PVC claimName: mypvc # 对应你创建的 PVC 名称 一个 PVC 对应一个 PV，但是一个 PVC 可以对应多个 Deployment 等控制器。下面我们就再创建一个 Deployment，将 相同的 PVC 挂载到容器中，并且每隔5秒修改一次 PVC 挂载的网页，并通过 nginx 容器查看结果 1234567891011121314151617181920212223242526# busybox-deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: busybox-deploymentspec: replicas: 1 selector: matchLabels: app: busybox template: metadata: labels: app: busybox spec: containers: - name: busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;while true; do echo $(date) &gt; /data/index.html; sleep 5; done&quot;] volumeMounts: - name: shared-volume mountPath: /data volumes: - name: shared-volume persistentVolumeClaim: claimName: mypvc 创建后查看 pod ip 123456$ k get pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESbusybox-deployment-d7589665d-dx2rs 1/1 Running 0 2m59s 10.244.126.6 k8s-worker2 &lt;none&gt; &lt;none&gt;nginx-pvc-deployment-775b8c4f8b-89cw7 1/1 Running 0 44s 10.244.126.8 k8s-worker2 &lt;none&gt; &lt;none&gt;nginx-pvc-deployment-775b8c4f8b-fszlf 1/1 Running 0 44s 10.244.194.123 k8s-worker1 &lt;none&gt; &lt;none&gt;nginx-pvc-deployment-775b8c4f8b-w9qkt 1/1 Running 0 44s 10.244.126.7 k8s-worker2 &lt;none&gt; &lt;none&gt; 访问任意一个 nginx pod 12# 此时会看到页面内容在变化watch -n 5 curl 10.244.194.123 后记 为 pod 绑定 pvc时，每次都要先创建 pv 和 pvc，非常麻烦。有什么好的解决方案吗？ 使用 StorageClass 实现自动创建 PV，我们下文将介绍如何实现。 如果 PVC 被 Pod 使用，则此时可以删除 PVC 吗？ 不可以，PVC 被 Pod 使用，此时只能等待 Pod 删除后才能删除 PVC。 若此时执行了删除 PVC 命令，终端会一直等待，ctrl + c 退出后再次查看 PVC 状态，会看到 PVC 状态为 Terminating。但此时不会影响存Pod对储卷的使用。 此时一旦Pod 删除，PVC 就会被删除。 如果PV 被 PVC 使用，则此时可以删除 PV 吗？ 不可以，PV 被 PVC 使用，此时只能等待 PVC 删除后才能删除 PV。 若此时执行了删除 PV 命令，终端会一直等待，ctrl + c 退出后再次查看 PV 状态，会看到 PV 状态为 Terminating。但此时不会影响Pod对存储卷的使用。 此时一旦 PVC 删除，PV 就会被删除。","summary":"摘要 本文介绍 K8S 的 持久卷 PV 和 PVC ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s PV/PVC 官方文档 本文底层存储卷是 NFS","date_published":"2025-07-21T15:35:15.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-nfs/","url":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-nfs/","title":"K8S 之 存储卷 NFS","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 存储卷 NFS ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"存储卷-NFS-介绍\">存储卷 NFS 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes 中，NFS (Network File System) 是一种通过网络将远程存储挂载到 Pod 的方式。它允许多个 Pod 跨节点共享相同的存储目录，常用于 ReadWriteMany（RWX） 场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们需要准备一个NFS 服务器，并配置 NFS 存储卷。具体可以参考 <a href=\"/2025/07/21/linux-nfs/\" title=\"Linux 安装 NFS\">Linux 安装 NFS</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>k8s中每个worker节点都需要安装 NFS 客户端，但是不需要挂载 NFS 存储卷，这个会在pod中进行。</p>\n</li>\n</ul>\n<h2 id=\"示例\">示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个使用 NFS 存储卷的 pod 示例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nfs-direct-pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nfs-direct-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;sleep 3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nfs-volume</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/data</span>          <span class=\"comment\"># 容器内挂载点</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nfs-volume</span></span><br><span class=\"line\">    <span class=\"attr\">nfs:</span></span><br><span class=\"line\">      <span class=\"attr\">server:</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.88</span>      <span class=\"comment\"># NFS 服务端地址</span></span><br><span class=\"line\">      <span class=\"attr\">path:</span> <span class=\"string\">/nfs-server/data</span>    <span class=\"comment\"># NFS 服务端共享目录</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"literal\">false</span>           <span class=\"comment\"># 是否只读挂载，false 表示可读写</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 Pod</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f nfs-direct-pod.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 Pod 挂载点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看pod部署到哪个节点</span></span><br><span class=\"line\">$ kubectl get pod nfs-direct-pod -o wide</span><br><span class=\"line\">NAME             READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">nfs-direct-pod   1/1     Running   0          12m   10.244.194.115   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录 k8s-worker1 节点，查看 nfs 挂载点，也就是说 创建 pod时会自动在宿主机上挂载 nfs</span></span><br><span class=\"line\">$ <span class=\"built_in\">df</span> -t nfs4</span><br><span class=\"line\">Filesystem                    1K-blocks    Used Available Use% Mounted on</span><br><span class=\"line\">10.211.55.88:/nfs-server/data  42872832 3630080  39242752   9% /var/lib/kubelet/pods/e44786a9-fbd9-4ee8-bb28-84eb074fb7d9/volumes/kubernetes.io~nfs/nfs-volume</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看pod挂载的目录</span></span><br><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it nfs-direct-pod -- <span class=\"built_in\">df</span> -t nfs4</span><br><span class=\"line\">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class=\"line\">10.211.55.88:/nfs-server/data</span><br><span class=\"line\">                      42872832   3630080  39242752   8% /data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 向nfs挂载目录中写入数据</span></span><br><span class=\"line\">k <span class=\"built_in\">exec</span> -it nfs-direct-pod -- sh -c <span class=\"string\">&#x27;echo &quot;hello world&quot; &gt; /data/test.txt&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除pod</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k delete pod nfs-direct-pod</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次登录 宿主机节点，发现 nfs 挂载点也被卸载了，但是 nfs-server 中的文件仍然存在</span></span><br><span class=\"line\">$ <span class=\"built_in\">df</span> -t nfs4</span><br><span class=\"line\"><span class=\"built_in\">df</span>: no file systems processed</span><br></pre></td></tr></table></figure>\n<h2 id=\"存储卷类型-emptyDir、hostPath、NFS-的对比表\">存储卷类型 emptyDir、hostPath、NFS 的对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>emptyDir</code></th>\n<th><code>hostPath</code></th>\n<th><code>nfs</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据生命周期</strong></td>\n<td>Pod 生命周期内有效，Pod 删除数据丢失</td>\n<td>绑定节点上的目录，Pod 删了数据仍保留</td>\n<td>存储在远程 NFS Server，Pod 删除数据不丢失</td>\n</tr>\n<tr>\n<td><strong>共享范围</strong></td>\n<td><strong>同一个 Pod 的多个容器可共享</strong></td>\n<td>同一节点上多个 Pod 可共享</td>\n<td>集群内多个 Pod 跨节点可共享</td>\n</tr>\n<tr>\n<td><strong>持久化能力</strong></td>\n<td>❌ 不持久化，随 Pod 生命周期结束消失</td>\n<td>✅ 持久化，只要宿主机目录存在数据就在</td>\n<td>✅ 持久化，NFS 存储独立于 Pod 存在</td>\n</tr>\n<tr>\n<td><strong>跨节点共享</strong></td>\n<td>❌ 不能</td>\n<td>❌ 不能</td>\n<td>✅ 支持跨节点共享</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>临时缓存、进程间共享数据</td>\n<td>宿主机特定目录挂载，日志存储、宿主机插件对接</td>\n<td>多副本服务共享存储、持久化数据、共享配置文件</td>\n</tr>\n<tr>\n<td><strong>数据安全性</strong></td>\n<td>随 Pod 删除，<strong>数据易丢失</strong></td>\n<td>容器有权限可修改宿主机文件，存在风险</td>\n<td>依赖 NFS Server 稳定性，配置不当可能被所有节点读写</td>\n</tr>\n<tr>\n<td><strong>典型用例</strong></td>\n<td>Redis 缓存目录、Sidecar 容器共享日志</td>\n<td>挂载宿主机 docker.sock、宿主机日志目录</td>\n<td>跨 Pod 文件共享、Web 静态资源、Tensorflow 多副本训练共享数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"为什么已经有-NFS，还推荐用-PV-PVC？\">为什么已经有 NFS，还推荐用 PV/PVC？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>✅ 简短回答：PV/PVC 是对底层存储（如 NFS）的抽象和标准化管理。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>原因</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ <strong>Kubernetes 标准资源</strong></td>\n<td>用 PVC 声明存储需求，由 K8s 统一调度和管理。</td>\n</tr>\n<tr>\n<td>✅ <strong>存储与 Pod 解耦</strong></td>\n<td>Pod 专注于应用逻辑，PVC 专注于声明“我要一个 10Gi 的 RWX 存储”，背后是 NFS、Ceph 还是别的，开发者无需关心。</td>\n</tr>\n<tr>\n<td>✅ <strong>动态供应</strong></td>\n<td>搭配 StorageClass 可以实现 <strong>自动创建 PV</strong>，不需要手动维护 PV。</td>\n</tr>\n<tr>\n<td>✅ <strong>生命周期管理</strong></td>\n<td>PVC 被删除时可触发 PV 回收、保留或删除策略（<code>Retain</code>、<code>Recycle</code>、<code>Delete</code>）。直接挂载 NFS 没有这些机制。</td>\n</tr>\n<tr>\n<td>✅ <strong>权限隔离</strong></td>\n<td>PV/PVC 可以通过 <code>accessModes</code> 控制访问级别，比如只允许特定 Pod 访问。直接挂载 NFS 容易权限混乱。</td>\n</tr>\n<tr>\n<td>✅ <strong>更好兼容性</strong></td>\n<td>某些工作负载（如 StatefulSet）<strong>只能用 PVC</strong>，不支持直接 <code>nfs</code> 卷。</td>\n</tr>\n<tr>\n<td>✅ <strong>更灵活的切换存储方案</strong></td>\n<td>后期如果换成 Ceph、EBS、GlusterFS，只需改 PV/PVC，不需要改 Pod 配置。</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 存储卷 NFS ，本文以 CentOS 8 为例。 K8S官网 k8s Github 存储卷 NFS 介绍 在 Kubernetes 中，NFS (Network File System) 是一种通过网络将远程存储挂载到 Pod 的方式。它允许多个 Pod 跨节点共享相同的存储目录，常用于 ReadWriteMany（RWX） 场景。 我们需要准备一个NFS 服务器，并配置 NFS 存储卷。具体可以参考 Linux 安装 NFS k8s中每个worker节点都需要安装 NFS 客户端，但是不需要挂载 NFS 存储卷，这个会在pod中进行。 示例 一个使用 NFS 存储卷的 pod 示例 12345678910111213141516171819# nfs-direct-pod.yamlapiVersion: v1kind: Podmetadata: name: nfs-direct-podspec: containers: - name: busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 3600&quot;] volumeMounts: - name: nfs-volume mountPath: /data # 容器内挂载点 volumes: - name: nfs-volume nfs: server: 10.211.55.88 # NFS 服务端地址 path: /nfs-server/data # NFS 服务端共享目录 readOnly: false # 是否只读挂载，false 表示可读写 创建 Pod 1kubectl apply -f nfs-direct-pod.yaml 查看 Pod 挂载点 123456789101112131415161718# 查看pod部署到哪个节点$ kubectl get pod nfs-direct-pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnfs-direct-pod 1/1 Running 0 12m 10.244.194.115 k8s-worker1 &lt;none&gt; &lt;none&gt;# 登录 k8s-worker1 节点，查看 nfs 挂载点，也就是说 创建 pod时会自动在宿主机上挂载 nfs$ df -t nfs4Filesystem 1K-blocks Used Available Use% Mounted on10.211.55.88:/nfs-server/data 42872832 3630080 39242752 9% /var/lib/kubelet/pods/e44786a9-fbd9-4ee8-bb28-84eb074fb7d9/volumes/kubernetes.io~nfs/nfs-volume# 查看pod挂载的目录$ k exec -it nfs-direct-pod -- df -t nfs4Filesystem 1K-blocks Used Available Use% Mounted on10.211.55.88:/nfs-server/data 42872832 3630080 39242752 8% /data# 向nfs挂载目录中写入数据k exec -it nfs-direct-pod -- sh -c &#x27;echo &quot;hello world&quot; &gt; /data/test.txt&#x27; 删除pod 12345k delete pod nfs-direct-pod# 再次登录 宿主机节点，发现 nfs 挂载点也被卸载了，但是 nfs-server 中的文件仍然存在$ df -t nfs4df: no file systems processed 存储卷类型 emptyDir、hostPath、NFS 的对比表 特性 emptyDir hostPath nfs 数据生命周期 Pod 生命周期内有效，Pod 删除数据丢失 绑定节点上的目录，Pod 删了数据仍保留 存储在远程 NFS Server，Pod 删除数据不丢失 共享范围 同一个 Pod 的多个容器可共享 同一节点上多个 Pod 可共享 集群内多个 Pod 跨节点可共享 持久化能力 ❌ 不持久化，随 Pod 生命周期结束消失 ✅ 持久化，只要宿主机目录存在数据就在 ✅ 持久化，NFS 存储独立于 Pod 存在 跨节点共享 ❌ 不能 ❌ 不能 ✅ 支持跨节点共享 适用场景 临时缓存、进程间共享数据 宿主机特定目录挂载，日志存储、宿主机插件对接 多副本服务共享存储、持久化数据、共享配置文件 数据安全性 随 Pod 删除，数据易丢失 容器有权限可修改宿主机文件，存在风险 依赖 NFS Server 稳定性，配置不当可能被所有节点读写 典型用例 Redis 缓存目录、Sidecar 容器共享日志 挂载宿主机 docker.sock、宿主机日志目录 跨 Pod 文件共享、Web 静态资源、Tensorflow 多副本训练共享数据 为什么已经有 NFS，还推荐用 PV/PVC？ ✅ 简短回答：PV/PVC 是对底层存储（如 NFS）的抽象和标准化管理。 原因 说明 ✅ Kubernetes 标准资源 用 PVC 声明存储需求，由 K8s 统一调度和管理。 ✅ 存储与 Pod 解耦 Pod 专注于应用逻辑，PVC 专注于声明“我要一个 10Gi 的 RWX 存储”，背后是 NFS、Ceph 还是别的，开发者无需关心。 ✅ 动态供应 搭配 StorageClass 可以实现 自动创建 PV，不需要手动维护 PV。 ✅ 生命周期管理 PVC 被删除时可触发 PV 回收、保留或删除策略（Retain、Recycle、Delete）。直接挂载 NFS 没有这些机制。 ✅ 权限隔离 PV/PVC 可以通过 accessModes 控制访问级别，比如只允许特定 Pod 访问。直接挂载 NFS 容易权限混乱。 ✅ 更好兼容性 某些工作负载（如 StatefulSet）只能用 PVC，不支持直接 nfs 卷。 ✅ 更灵活的切换存储方案 后期如果换成 Ceph、EBS、GlusterFS，只需改 PV/PVC，不需要改 Pod 配置。","summary":"摘要 本文介绍 K8S 的 存储卷 NFS ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-21T15:34:15.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/21/linux-nfs/","url":"https://blog.hanqunfeng.com/2025/07/21/linux-nfs/","title":"Linux 安装 NFS","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 linux 下 nfs 文件系统的安装与使用</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"NFS-简介\">NFS 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>NFS（网络文件系统，Network File System）是一个通过网络共享文件的协议，允许不同服务器或客户端像挂载本地磁盘一样访问远端的共享文件目录。</p>\n</li>\n</ul>\n<h2 id=\"准备一台服务器\">准备一台服务器</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置 hostname</span></span><br><span class=\"line\">hostnamectl set-hostname nfs-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网卡</span></span><br><span class=\"line\">ip a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置IP 分配方式，manual: 手动指定IP，auto: DHCP自动获取，disabled: 关闭IP</span></span><br><span class=\"line\">nmcli con mod enp0s5 ipv4.method manual</span><br><span class=\"line\"><span class=\"comment\"># 设置 IP</span></span><br><span class=\"line\">nmcli con mod enp0s5 ipv4.addresses 10.211.55.88/24</span><br><span class=\"line\"><span class=\"comment\"># 设置 gateway</span></span><br><span class=\"line\">nmcli con mod enp0s5 ipv4.gateway 10.211.55.1</span><br><span class=\"line\"><span class=\"comment\"># 设置 dns</span></span><br><span class=\"line\">nmcli con mod enp0s5 ipv4.dns <span class=\"string\">&quot;10.211.55.1,8.8.8.8&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 重新启动网卡</span></span><br><span class=\"line\">nmcli con up enp0s5</span><br></pre></td></tr></table></figure>\n<h2 id=\"NFS-安装：服务端\">NFS 安装：服务端</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 nfs-utils 和 rpcbind</span></span><br><span class=\"line\">dnf install rpcbind nfs-utils -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 nfs-server 存储目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /nfs-server/data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置 nfs-server，可以添加多个目录</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;/nfs-server/data *(insecure,rw,sync,no_root_squash,no_all_squash)&quot;</span> &gt;&gt; /etc/exports</span><br><span class=\"line\"><span class=\"comment\">## 配置项说明</span></span><br><span class=\"line\"><span class=\"comment\"># * ：允许所有客户端访问，也可以指定具体的客户端 IP 地址，比如：192.168.0.0/24(rw,sync,no_root_squash,no_all_squash)</span></span><br><span class=\"line\"><span class=\"comment\"># insecure ：允许任意端口（兼容性好,支持k8s），默认值是 secure：只允许 1024 以下端口，适合传统服务器</span></span><br><span class=\"line\"><span class=\"comment\"># rw ：读写权限，ro：只读权限</span></span><br><span class=\"line\"><span class=\"comment\"># sync ：同步模式，强一致性，async：异步模式，性能高，但存在丢数据风险</span></span><br><span class=\"line\"><span class=\"comment\"># no_root_squash ：允许 root 用户访问，默认情况下，root 用户访问时会被转换成 nobody 用户</span></span><br><span class=\"line\"><span class=\"comment\"># no_all_squash ：允许所有用户访问，默认情况下，所有用户访问时会被转换成 nobody 用户，默认就是这个，可以省略。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动 rpcbind、nfs 服务</span></span><br><span class=\"line\">systemctl start rpcbind &amp;&amp; systemctl start nfs-server</span><br><span class=\"line\"><span class=\"comment\"># 开机自启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rpcbind &amp;&amp; systemctl <span class=\"built_in\">enable</span> nfs-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件 /etc/exports，需要重载 nfs 配置</span></span><br><span class=\"line\">systemctl reload nfs-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 nfs 服务状态</span></span><br><span class=\"line\">systemctl status nfs-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 nfs 服务监听的端口，默认为 2049</span></span><br><span class=\"line\">$ rpcinfo -p | grep nfs</span><br><span class=\"line\">    100003    3   tcp   2049  nfs</span><br><span class=\"line\">    100003    4   tcp   2049  nfs</span><br><span class=\"line\">    100227    3   tcp   2049  nfs_acl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查导出的共享目录</span></span><br><span class=\"line\">$ exportfs -v</span><br><span class=\"line\">/nfs-server/data</span><br><span class=\"line\">                &lt;world&gt;(<span class=\"built_in\">sync</span>,wdelay,hide,no_subtree_check,sec=sys,rw,insecure,no_root_squash,no_all_squash)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"开放端口\">开放端口</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看当前使用的端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rpcinfo -p 10.211.55.88</span><br><span class=\"line\">   program vers proto   port  service</span><br><span class=\"line\">    100000    4   tcp    111  portmapper</span><br><span class=\"line\">    100000    3   tcp    111  portmapper</span><br><span class=\"line\">    100000    2   tcp    111  portmapper</span><br><span class=\"line\">    100000    4   udp    111  portmapper</span><br><span class=\"line\">    100000    3   udp    111  portmapper</span><br><span class=\"line\">    100000    2   udp    111  portmapper</span><br><span class=\"line\">    100024    1   udp  36578  status</span><br><span class=\"line\">    100024    1   tcp  46973  status</span><br><span class=\"line\">    100005    1   udp  20048  mountd</span><br><span class=\"line\">    100005    1   tcp  20048  mountd</span><br><span class=\"line\">    100005    2   udp  20048  mountd</span><br><span class=\"line\">    100005    2   tcp  20048  mountd</span><br><span class=\"line\">    100005    3   udp  20048  mountd</span><br><span class=\"line\">    100005    3   tcp  20048  mountd</span><br><span class=\"line\">    100003    3   tcp   2049  nfs</span><br><span class=\"line\">    100003    4   tcp   2049  nfs</span><br><span class=\"line\">    100227    3   tcp   2049  nfs_acl</span><br><span class=\"line\">    100021    1   udp  36529  nlockmgr</span><br><span class=\"line\">    100021    3   udp  36529  nlockmgr</span><br><span class=\"line\">    100021    4   udp  36529  nlockmgr</span><br><span class=\"line\">    100021    1   tcp  45917  nlockmgr</span><br><span class=\"line\">    100021    3   tcp  45917  nlockmgr</span><br><span class=\"line\">    100021    4   tcp  45917  nlockmgr</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>Program (编号)</th>\n<th>服务名称</th>\n<th>用途</th>\n<th>端口</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>100000</code></td>\n<td>portmapper</td>\n<td>RPC 服务注册表</td>\n<td>111/tcp, 111/udp</td>\n<td><strong>必须开放</strong>，客户端通过它查找其它服务端口</td>\n</tr>\n<tr>\n<td><code>100024</code></td>\n<td>status (rpc.statd)</td>\n<td>文件锁定状态管理</td>\n<td>36578/udp, 46973/tcp</td>\n<td>常配合 nlockmgr 使用，非必需</td>\n</tr>\n<tr>\n<td><code>100005</code></td>\n<td>mountd</td>\n<td>挂载服务</td>\n<td>20048/tcp, 20048/udp</td>\n<td><strong>挂载时必需</strong></td>\n</tr>\n<tr>\n<td><code>100003</code></td>\n<td>nfs</td>\n<td>NFS 主服务</td>\n<td>2049/tcp</td>\n<td><strong>核心服务，必需</strong></td>\n</tr>\n<tr>\n<td><code>100227</code></td>\n<td>nfs_acl</td>\n<td>NFS 的 ACL 权限控制</td>\n<td>2049/tcp</td>\n<td>通常与 nfs 一起</td>\n</tr>\n<tr>\n<td><code>100021</code></td>\n<td>nlockmgr</td>\n<td>文件锁管理</td>\n<td>36529/udp, 45917/tcp</td>\n<td>Stateful 应用涉及文件锁时需要</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最小端口要求（基本挂载用）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>需要开放的端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ <strong>基本 NFS 挂载读写</strong></td>\n<td><code>2049/tcp</code> + <code>111/tcp/udp</code></td>\n</tr>\n<tr>\n<td>✅ <strong>容器或 K8s 挂载</strong></td>\n<td>同上，一般还推荐 <code>20048/tcp/udp</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开放必须端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --permanent --add-port=2049/tcp</span><br><span class=\"line\">firewall-cmd --permanent --add-port=111/tcp</span><br><span class=\"line\">firewall-cmd --permanent --add-port=111/udp</span><br><span class=\"line\">firewall-cmd --permanent --add-port=20048/tcp</span><br><span class=\"line\">firewall-cmd --permanent --add-port=20048/udp</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<h2 id=\"NFS-安装：客户端\">NFS 安装：客户端</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 nfs-utils 和 rpcbind，安装后不需要启动 nfs-server 服务，只需要启动 rpcbind 服务，所有客户端都要运行</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install rpcbind nfs-utils -y</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start rpcbind &amp;&amp; systemctl <span class=\"built_in\">enable</span> rpcbind</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看服务器的共享资源列表</span></span><br><span class=\"line\"><span class=\"comment\"># showmount -e &lt;nfs-server-ip&gt;</span></span><br><span class=\"line\">$ showmount -e 10.211.55.88</span><br><span class=\"line\">Export list <span class=\"keyword\">for</span> 10.211.55.88:</span><br><span class=\"line\">/nfs-server/data *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 客户端挂载目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /nfs/data</span><br><span class=\"line\"><span class=\"comment\"># 挂载</span></span><br><span class=\"line\">mount -t nfs 10.211.55.88:/nfs-server/data /nfs/data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看挂载点</span></span><br><span class=\"line\">$ mount | grep nfs/data</span><br><span class=\"line\">10.211.55.88:/nfs-server/data on /nfs/data <span class=\"built_in\">type</span> nfs4 (rw,relatime,vers=4.2,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.211.55.11,local_lock=none,addr=10.211.55.88)</span><br><span class=\"line\"><span class=\"comment\"># 查看挂载点信息，这种方式更友好</span></span><br><span class=\"line\">$ <span class=\"built_in\">df</span> -t nfs4</span><br><span class=\"line\">Filesystem                    1K-blocks    Used Available Use% Mounted on</span><br><span class=\"line\">10.211.55.88:/nfs-server/data  42872832 3630080  39242752   9% /nfs/data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置自动挂载</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;10.211.55.88:/nfs-server/data /nfs/data nfs defaults 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class=\"line\"><span class=\"comment\"># 根据 /etc/fstab 文件的配置，尝试挂载所有未挂载的文件系统。修改 /etc/fstab 后执行 mount -a 立即生效</span></span><br><span class=\"line\">mount -a</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>客户端挂载的目录不能删除，需要先卸载</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -f 强制卸载</span></span><br><span class=\"line\">umount -f /nfs/data</span><br><span class=\"line\"></span><br><span class=\"line\">vim /etc/fstab</span><br><span class=\"line\"><span class=\"comment\"># 删除或注释掉对应的 NFS 挂载行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /nfs/data</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 linux 下 nfs 文件系统的安装与使用 本文基于CentOS8(x86_64) NFS 简介 NFS（网络文件系统，Network File System）是一个通过网络共享文件的协议，允许不同服务器或客户端像挂载本地磁盘一样访问远端的共享文件目录。 准备一台服务器 12345678910111213141516# 设置 hostnamehostnamectl set-hostname nfs-server# 查看网卡ip a# 设置IP 分配方式，manual: 手动指定IP，auto: DHCP自动获取，disabled: 关闭IPnmcli con mod enp0s5 ipv4.method manual# 设置 IPnmcli con mod enp0s5 ipv4.addresses 10.211.55.88/24# 设置 gatewaynmcli con mod enp0s5 ipv4.gateway 10.211.55.1# 设置 dnsnmcli con mod enp0s5 ipv4.dns &quot;10.211.55.1,8.8.8.8&quot;# 重新启动网卡nmcli con up enp0s5 NFS 安装：服务端 1234567891011121314151617181920212223242526272829303132333435363738# 安装 nfs-utils 和 rpcbinddnf install rpcbind nfs-utils -y# 创建 nfs-server 存储目录mkdir -p /nfs-server/data# 配置 nfs-server，可以添加多个目录echo &quot;/nfs-server/data *(insecure,rw,sync,no_root_squash,no_all_squash)&quot; &gt;&gt; /etc/exports## 配置项说明# * ：允许所有客户端访问，也可以指定具体的客户端 IP 地址，比如：192.168.0.0/24(rw,sync,no_root_squash,no_all_squash)# insecure ：允许任意端口（兼容性好,支持k8s），默认值是 secure：只允许 1024 以下端口，适合传统服务器# rw ：读写权限，ro：只读权限# sync ：同步模式，强一致性，async：异步模式，性能高，但存在丢数据风险# no_root_squash ：允许 root 用户访问，默认情况下，root 用户访问时会被转换成 nobody 用户# no_all_squash ：允许所有用户访问，默认情况下，所有用户访问时会被转换成 nobody 用户，默认就是这个，可以省略。# 启动 rpcbind、nfs 服务systemctl start rpcbind &amp;&amp; systemctl start nfs-server# 开机自启动systemctl enable rpcbind &amp;&amp; systemctl enable nfs-server# 修改配置文件 /etc/exports，需要重载 nfs 配置systemctl reload nfs-server# 查看 nfs 服务状态systemctl status nfs-server# 查看 nfs 服务监听的端口，默认为 2049$ rpcinfo -p | grep nfs 100003 3 tcp 2049 nfs 100003 4 tcp 2049 nfs 100227 3 tcp 2049 nfs_acl# 检查导出的共享目录$ exportfs -v/nfs-server/data &lt;world&gt;(sync,wdelay,hide,no_subtree_check,sec=sys,rw,insecure,no_root_squash,no_all_squash) 开放端口 查看当前使用的端口 12345678910111213141516171819202122232425$ rpcinfo -p 10.211.55.88 program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 100024 1 udp 36578 status 100024 1 tcp 46973 status 100005 1 udp 20048 mountd 100005 1 tcp 20048 mountd 100005 2 udp 20048 mountd 100005 2 tcp 20048 mountd 100005 3 udp 20048 mountd 100005 3 tcp 20048 mountd 100003 3 tcp 2049 nfs 100003 4 tcp 2049 nfs 100227 3 tcp 2049 nfs_acl 100021 1 udp 36529 nlockmgr 100021 3 udp 36529 nlockmgr 100021 4 udp 36529 nlockmgr 100021 1 tcp 45917 nlockmgr 100021 3 tcp 45917 nlockmgr 100021 4 tcp 45917 nlockmgr Program (编号) 服务名称 用途 端口 说明 100000 portmapper RPC 服务注册表 111/tcp, 111/udp 必须开放，客户端通过它查找其它服务端口 100024 status (rpc.statd) 文件锁定状态管理 36578/udp, 46973/tcp 常配合 nlockmgr 使用，非必需 100005 mountd 挂载服务 20048/tcp, 20048/udp 挂载时必需 100003 nfs NFS 主服务 2049/tcp 核心服务，必需 100227 nfs_acl NFS 的 ACL 权限控制 2049/tcp 通常与 nfs 一起 100021 nlockmgr 文件锁管理 36529/udp, 45917/tcp Stateful 应用涉及文件锁时需要 最小端口要求（基本挂载用） 场景 需要开放的端口 ✅ 基本 NFS 挂载读写 2049/tcp + 111/tcp/udp ✅ 容器或 K8s 挂载 同上，一般还推荐 20048/tcp/udp 开放必须端口 123456firewall-cmd --permanent --add-port=2049/tcpfirewall-cmd --permanent --add-port=111/tcpfirewall-cmd --permanent --add-port=111/udpfirewall-cmd --permanent --add-port=20048/tcpfirewall-cmd --permanent --add-port=20048/udpfirewall-cmd --reload NFS 安装：客户端 123456789101112131415161718192021222324252627# 安装 nfs-utils 和 rpcbind，安装后不需要启动 nfs-server 服务，只需要启动 rpcbind 服务，所有客户端都要运行sudo dnf install rpcbind nfs-utils -ysudo systemctl start rpcbind &amp;&amp; systemctl enable rpcbind# 查看服务器的共享资源列表# showmount -e &lt;nfs-server-ip&gt;$ showmount -e 10.211.55.88Export list for 10.211.55.88:/nfs-server/data *# 创建 客户端挂载目录mkdir -p /nfs/data# 挂载mount -t nfs 10.211.55.88:/nfs-server/data /nfs/data# 查看挂载点$ mount | grep nfs/data10.211.55.88:/nfs-server/data on /nfs/data type nfs4 (rw,relatime,vers=4.2,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.211.55.11,local_lock=none,addr=10.211.55.88)# 查看挂载点信息，这种方式更友好$ df -t nfs4Filesystem 1K-blocks Used Available Use% Mounted on10.211.55.88:/nfs-server/data 42872832 3630080 39242752 9% /nfs/data# 配置自动挂载echo &quot;10.211.55.88:/nfs-server/data /nfs/data nfs defaults 0 0&quot; &gt;&gt; /etc/fstab# 根据 /etc/fstab 文件的配置，尝试挂载所有未挂载的文件系统。修改 /etc/fstab 后执行 mount -a 立即生效mount -a 客户端挂载的目录不能删除，需要先卸载 1234567# -f 强制卸载umount -f /nfs/datavim /etc/fstab# 删除或注释掉对应的 NFS 挂载行rm -rf /nfs/data","summary":"摘要 本文介绍 linux 下 nfs 文件系统的安装与使用 本文基于CentOS8(x86_64)","date_published":"2025-07-21T15:34:05.000Z","tags":["技术","linux","nfs","linux","nfs"]},{"id":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-hostpath/","url":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-hostpath/","title":"K8S 之 存储卷 hostPath","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 存储卷 hostPath ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"存储卷-hostPath-介绍\">存储卷 hostPath 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>hostPath 是一种直接把 Node 节点本地文件或目录 挂载到 Pod 容器里的存储卷。</p>\n</li>\n<li class=\"lvl-2\">\n<p>容易破坏节点环境，不建议生产使用</p>\n</li>\n<li class=\"lvl-2\">\n<p>同一个 Deployment 的多个 Pod 被调度到同一个节点，并且它们的 hostPath 配置指向相同的宿主机路径，这些 Pod 之间是可以共享该目录中文件的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>典型使用场景</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>日志收集</td>\n<td>挂载 <code>/var/log</code> 到 Pod 内部</td>\n</tr>\n<tr>\n<td>挂载宿主机配置文件</td>\n<td>如挂载 <code>/etc/hosts</code>、<code>/etc/localtime</code></td>\n</tr>\n<tr>\n<td>使用宿主机 docker.sock</td>\n<td>挂载 <code>/var/run/docker.sock</code> 运行 Docker-in-Docker</td>\n</tr>\n<tr>\n<td>存储调试临时文件</td>\n<td>Pod 调试时访问宿主机特定目录</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"示例\">示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 内部 /mnt/hostdata 映射到宿主机 /data 目录</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hostpath-example</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;sleep 3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>                   <span class=\"comment\"># 存储卷挂载点</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">/mnt/hostdata</span>      <span class=\"comment\"># 挂载点路径，挂载到容器的 /mnt/hostdata 目录</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">myvolume</span>                <span class=\"comment\"># 存储卷名称 ，与 volumes 中定义的 volume 配置名称一致</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span>                          <span class=\"comment\"># 存储卷声明</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myvolume</span>                  <span class=\"comment\"># 存储卷名称</span></span><br><span class=\"line\">    <span class=\"attr\">hostPath:</span>                       <span class=\"comment\"># 存储卷类型，这里是 hostPath</span></span><br><span class=\"line\">      <span class=\"attr\">path:</span> <span class=\"string\">/data</span>                   <span class=\"comment\"># 主机目录</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">Directory</span>               <span class=\"comment\"># 可选字段，主要用于挂载前验证</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>hostPath.type</code> 可以配置的值如下，默认为 空。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>DirectoryOrCreate</code></td>\n<td>如果 <code>/data</code> 不存在则自动创建 ，权限为 0755</td>\n</tr>\n<tr>\n<td><code>Directory</code></td>\n<td>必须存在且为目录</td>\n</tr>\n<tr>\n<td><code>File</code></td>\n<td>必须存在且为文件</td>\n</tr>\n<tr>\n<td><code>Socket</code></td>\n<td>必须是 socket</td>\n</tr>\n<tr>\n<td><code>CharDevice</code></td>\n<td>字符设备</td>\n</tr>\n<tr>\n<td><code>BlockDevice</code></td>\n<td>块设备</td>\n</tr>\n<tr>\n<td><code>FileOrCreate</code></td>\n<td>不存在则自动创建空文件，权限设置为 0644</td>\n</tr>\n<tr>\n<td><code>不设置</code></td>\n<td>默认值是空，主机上的路径无论是文件、目录、甚至不存在，都会直接挂载 ,容易引起预期之外的挂载问题</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 在删除 Pod 时，不会删除 hostPath 所挂载的宿主机目录或文件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>存储卷类型</th>\n<th>删除 Pod 后目录会被删除吗？</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>emptyDir</code></td>\n<td>✅ <strong>会被删除</strong></td>\n<td>临时目录，Pod 生命周期结束自动清理</td>\n</tr>\n<tr>\n<td><code>hostPath</code></td>\n<td>❌ <strong>不会删除</strong></td>\n<td>宿主机路径独立于 Pod 生命周期，<strong>不会清理</strong></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 存储卷 hostPath ，本文以 CentOS 8 为例。 K8S官网 k8s Github 存储卷 hostPath 介绍 hostPath 是一种直接把 Node 节点本地文件或目录 挂载到 Pod 容器里的存储卷。 容易破坏节点环境，不建议生产使用 同一个 Deployment 的多个 Pod 被调度到同一个节点，并且它们的 hostPath 配置指向相同的宿主机路径，这些 Pod 之间是可以共享该目录中文件的。 典型使用场景 场景 示例 日志收集 挂载 /var/log 到 Pod 内部 挂载宿主机配置文件 如挂载 /etc/hosts、/etc/localtime 使用宿主机 docker.sock 挂载 /var/run/docker.sock 运行 Docker-in-Docker 存储调试临时文件 Pod 调试时访问宿主机特定目录 示例 Pod 内部 /mnt/hostdata 映射到宿主机 /data 目录 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: hostpath-examplespec: containers: - name: busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 3600&quot;] volumeMounts: # 存储卷挂载点 - mountPath: /mnt/hostdata # 挂载点路径，挂载到容器的 /mnt/hostdata 目录 name: myvolume # 存储卷名称 ，与 volumes 中定义的 volume 配置名称一致 volumes: # 存储卷声明 - name: myvolume # 存储卷名称 hostPath: # 存储卷类型，这里是 hostPath path: /data # 主机目录 type: Directory # 可选字段，主要用于挂载前验证 hostPath.type 可以配置的值如下，默认为 空。 type 含义 DirectoryOrCreate 如果 /data 不存在则自动创建 ，权限为 0755 Directory 必须存在且为目录 File 必须存在且为文件 Socket 必须是 socket CharDevice 字符设备 BlockDevice 块设备 FileOrCreate 不存在则自动创建空文件，权限设置为 0644 不设置 默认值是空，主机上的路径无论是文件、目录、甚至不存在，都会直接挂载 ,容易引起预期之外的挂载问题 Kubernetes 在删除 Pod 时，不会删除 hostPath 所挂载的宿主机目录或文件 存储卷类型 删除 Pod 后目录会被删除吗？ 说明 emptyDir ✅ 会被删除 临时目录，Pod 生命周期结束自动清理 hostPath ❌ 不会删除 宿主机路径独立于 Pod 生命周期，不会清理","summary":"摘要 本文介绍 K8S 的 存储卷 hostPath ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-21T15:33:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-emptydir/","url":"https://blog.hanqunfeng.com/2025/07/21/k8s-storage-emptydir/","title":"K8S 之 存储卷 emptyDir","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 存储卷 emptyDir ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"存储卷-emptyDir-介绍\">存储卷 emptyDir 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>emptyDir 是 Kubernetes 中最简单的一种 Pod 级别的临时存储卷。它的核心特点是：Pod 生命周期内共享临时存储，Pod 删除后数据自动丢弃。</p>\n</li>\n<li class=\"lvl-2\">\n<p>同一个 Pod 内的多个容器可以通过 emptyDir 共享数据。跨 Pod 不共享，适用于临时数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>emptyDir 只能挂载目录。</p>\n</li>\n</ul>\n<h2 id=\"示例\">示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>两个容器 app 和 sidecar 通过 /data 共享一个 emptyDir 卷。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># shared-emptydir-pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">shared-emptydir-pod</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app.sto:</span> <span class=\"string\">emptydir</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;echo Hello &gt; /data1/hello; sleep 3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>               <span class=\"comment\"># 存储卷挂载点</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">shared-data</span>         <span class=\"comment\"># 挂载点名称，与下面 volumes 中定义的 volume 名称一致</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/data1</span>          <span class=\"comment\"># 挂载点路径，挂载到容器的 /data1 目录</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">sidecar</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;sleep 3600&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>               <span class=\"comment\"># 存储卷挂载点</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">shared-data</span>         <span class=\"comment\"># 挂载点名称，与上面容器中的 volume 配置名称一致</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">/data2</span>         <span class=\"comment\"># 挂载点路径，挂载到容器的 /data2 目录</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span>                      <span class=\"comment\"># 存储卷声明</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">shared-data</span>           <span class=\"comment\"># 存储卷名称</span></span><br><span class=\"line\">    <span class=\"attr\">emptyDir:</span> &#123;&#125;                <span class=\"comment\"># 声明为 emptyDir 存储卷</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k apply -f shared-emptydir-pod.yaml</span><br><span class=\"line\"><span class=\"comment\"># 查看pod所在节点</span></span><br><span class=\"line\">$ k get pod -l app.sto=emptydir</span><br><span class=\"line\">NAME                  READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">shared-emptydir-pod   2/2     Running   0          22m   10.244.126.59   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"><span class=\"comment\"># 查看 pod-uid</span></span><br><span class=\"line\">$ kubectl get pod shared-emptydir-pod -o jsonpath=<span class=\"string\">&#x27;&#123;.metadata.uid&#125;&#x27;</span></span><br><span class=\"line\">d597b4d7-e6b6-4522-887e-73d3f4c01006</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>emptyDir 存储卷 默认使用节点本地磁盘，路径为 <code>/var/lib/kubelet/pods/&lt;pod-uid&gt;/volumes/kubernetes.io~empty-dir/&lt;volume-name&gt;</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录 k8s-worker2 节点</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> POD_UID=d597b4d7-e6b6-4522-887e-73d3f4c01006</span><br><span class=\"line\"><span class=\"built_in\">export</span> POD_UID=6ea6636c-4a24-4dc5-af2a-2448825913b6</span><br><span class=\"line\"><span class=\"built_in\">export</span> VOLUME_NAME=shared-data</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/kubelet/pods/<span class=\"variable\">$POD_UID</span>/volumes/kubernetes.io~empty-dir/<span class=\"variable\">$VOLUME_NAME</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> hello</span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入容器查看存储卷内容</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it shared-emptydir-pod -c app -- <span class=\"built_in\">cat</span> /data1/hello</span><br><span class=\"line\">Hello</span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it shared-emptydir-pod -c sidecar -- <span class=\"built_in\">cat</span> /data2/hello</span><br><span class=\"line\">Hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改内容，实际上在容器内部和外部都可以修改存储卷内容，修改后立刻生效</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it shared-emptydir-pod -c sidecar -- sh -c <span class=\"string\">&quot;echo &#x27;Hello World&#x27; &gt; /data2/hello&quot;</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it shared-emptydir-pod -c app -- <span class=\"built_in\">cat</span> /data1/hello</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除POD后emptydir存储卷会立刻删除</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pod shared-emptydir-pod</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录 k8s-worker2 节点查看 emptydir 存储卷</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> /var/lib/kubelet/pods/<span class=\"variable\">$POD_UID</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span>: cannot access <span class=\"string\">&#x27;/var/lib/kubelet/pods/d597b4d7-e6b6-4522-887e-73d3f4c01006&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>\n<h2 id=\"将-emptydir-存储卷改用-内存-存储\">将 emptydir 存储卷改用 内存 存储</h2>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">emptyDir:</span></span><br><span class=\"line\">  <span class=\"attr\">medium:</span> <span class=\"string\">Memory</span>        <span class=\"comment\"># 使用 内存 存储（tmpfs），适合高 IO 临时缓存</span></span><br><span class=\"line\">  <span class=\"attr\">sizeLimit:</span> <span class=\"string\">512Mi</span>      <span class=\"comment\"># 限制存储大小</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里要注意，即使这里使用内存存储，但是 <code>/var/lib/kubelet/pods/&lt;pod-uid&gt;/volumes/kubernetes.io~empty-dir/&lt;volume-name&gt;</code> 依然存在，但它挂载的是 tmpfs 文件系统</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录pod所在节点查看挂载点</span></span><br><span class=\"line\">$ mount | grep <span class=\"variable\">$POD_UID</span></span><br><span class=\"line\">tmpfs on /var/lib/kubelet/pods/6ea6636c-4a24-4dc5-af2a-2448825913b6/volumes/kubernetes.io~empty-dir/shared-data <span class=\"built_in\">type</span> tmpfs (rw,relatime,size=524288k)</span><br><span class=\"line\">tmpfs on /var/lib/kubelet/pods/6ea6636c-4a24-4dc5-af2a-2448825913b6/volumes/kubernetes.io~projected/kube-api-access-5nk7d <span class=\"built_in\">type</span> tmpfs (rw,relatime,size=3903212k)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>卷类型</th>\n<th>来源</th>\n<th>挂载路径</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>emptyDir</td>\n<td>你配置的</td>\n<td><code>/data1</code>, <code>/data2</code></td>\n<td>Pod 内部容器共享临时内存存储</td>\n</tr>\n<tr>\n<td>projected</td>\n<td>系统自动</td>\n<td><code>/var/run/secrets/kubernetes.io/serviceaccount/</code></td>\n<td>挂载 serviceaccount token，CA 证书</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看容器内挂载点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> shared-emptydir-pod -c app -- mount | grep /data1</span><br><span class=\"line\">tmpfs on /data1 <span class=\"built_in\">type</span> tmpfs (rw,relatime,size=524288k)</span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> shared-emptydir-pod -c app -- mount | grep serviceaccount</span><br><span class=\"line\">tmpfs on /var/run/secrets/kubernetes.io/serviceaccount <span class=\"built_in\">type</span> tmpfs (ro,relatime,size=3903212k)</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 的 存储卷 emptyDir ，本文以 CentOS 8 为例。 K8S官网 k8s Github 存储卷 emptyDir 介绍 emptyDir 是 Kubernetes 中最简单的一种 Pod 级别的临时存储卷。它的核心特点是：Pod 生命周期内共享临时存储，Pod 删除后数据自动丢弃。 同一个 Pod 内的多个容器可以通过 emptyDir 共享数据。跨 Pod 不共享，适用于临时数据。 emptyDir 只能挂载目录。 示例 两个容器 app 和 sidecar 通过 /data 共享一个 emptyDir 卷。 123456789101112131415161718192021222324# shared-emptydir-pod.yamlapiVersion: v1kind: Podmetadata: name: shared-emptydir-pod labels: app.sto: emptydirspec: containers: - name: app image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo Hello &gt; /data1/hello; sleep 3600&quot;] volumeMounts: # 存储卷挂载点 - name: shared-data # 挂载点名称，与下面 volumes 中定义的 volume 名称一致 mountPath: /data1 # 挂载点路径，挂载到容器的 /data1 目录 - name: sidecar image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 3600&quot;] volumeMounts: # 存储卷挂载点 - name: shared-data # 挂载点名称，与上面容器中的 volume 配置名称一致 mountPath: /data2 # 挂载点路径，挂载到容器的 /data2 目录 volumes: # 存储卷声明 - name: shared-data # 存储卷名称 emptyDir: &#123;&#125; # 声明为 emptyDir 存储卷 创建 12345678k apply -f shared-emptydir-pod.yaml# 查看pod所在节点$ k get pod -l app.sto=emptydirNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESshared-emptydir-pod 2/2 Running 0 22m 10.244.126.59 k8s-worker2 &lt;none&gt; &lt;none&gt;# 查看 pod-uid$ kubectl get pod shared-emptydir-pod -o jsonpath=&#x27;&#123;.metadata.uid&#125;&#x27;d597b4d7-e6b6-4522-887e-73d3f4c01006 emptyDir 存储卷 默认使用节点本地磁盘，路径为 /var/lib/kubelet/pods/&lt;pod-uid&gt;/volumes/kubernetes.io~empty-dir/&lt;volume-name&gt; 123456789# 登录 k8s-worker2 节点export POD_UID=d597b4d7-e6b6-4522-887e-73d3f4c01006export POD_UID=6ea6636c-4a24-4dc5-af2a-2448825913b6export VOLUME_NAME=shared-datacd /var/lib/kubelet/pods/$POD_UID/volumes/kubernetes.io~empty-dir/$VOLUME_NAME$ lshello$ cat helloHello 进入容器查看存储卷内容 123456789$ kubectl exec -it shared-emptydir-pod -c app -- cat /data1/helloHello$ kubectl exec -it shared-emptydir-pod -c sidecar -- cat /data2/helloHello# 修改内容，实际上在容器内部和外部都可以修改存储卷内容，修改后立刻生效$ kubectl exec -it shared-emptydir-pod -c sidecar -- sh -c &quot;echo &#x27;Hello World&#x27; &gt; /data2/hello&quot;$ kubectl exec -it shared-emptydir-pod -c app -- cat /data1/helloHello World 删除POD后emptydir存储卷会立刻删除 12345kubectl delete pod shared-emptydir-pod# 登录 k8s-worker2 节点查看 emptydir 存储卷$ ls /var/lib/kubelet/pods/$POD_UIDls: cannot access &#x27;/var/lib/kubelet/pods/d597b4d7-e6b6-4522-887e-73d3f4c01006&#x27;: No such file or directory 将 emptydir 存储卷改用 内存 存储 123emptyDir: medium: Memory # 使用 内存 存储（tmpfs），适合高 IO 临时缓存 sizeLimit: 512Mi # 限制存储大小 这里要注意，即使这里使用内存存储，但是 /var/lib/kubelet/pods/&lt;pod-uid&gt;/volumes/kubernetes.io~empty-dir/&lt;volume-name&gt; 依然存在，但它挂载的是 tmpfs 文件系统 1234# 登录pod所在节点查看挂载点$ mount | grep $POD_UIDtmpfs on /var/lib/kubelet/pods/6ea6636c-4a24-4dc5-af2a-2448825913b6/volumes/kubernetes.io~empty-dir/shared-data type tmpfs (rw,relatime,size=524288k)tmpfs on /var/lib/kubelet/pods/6ea6636c-4a24-4dc5-af2a-2448825913b6/volumes/kubernetes.io~projected/kube-api-access-5nk7d type tmpfs (rw,relatime,size=3903212k) 卷类型 来源 挂载路径 作用 emptyDir 你配置的 /data1, /data2 Pod 内部容器共享临时内存存储 projected 系统自动 /var/run/secrets/kubernetes.io/serviceaccount/ 挂载 serviceaccount token，CA 证书 查看容器内挂载点 1234$ kubectl exec shared-emptydir-pod -c app -- mount | grep /data1tmpfs on /data1 type tmpfs (rw,relatime,size=524288k)$ kubectl exec shared-emptydir-pod -c app -- mount | grep serviceaccounttmpfs on /var/run/secrets/kubernetes.io/serviceaccount type tmpfs (ro,relatime,size=3903212k)","summary":"摘要 本文介绍 K8S 的 存储卷 emptyDir ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-21T15:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/20/k8s-statefulset/","url":"https://blog.hanqunfeng.com/2025/07/20/k8s-statefulset/","title":"K8S 之 Statefulset","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Statefulset ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/\">k8s Statefulset 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Statefulset-介绍\">Statefulset 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Statefulset(缩写为 sts) 是 K8S 官方提供的一种控制器，用于管理有状态应用。例如，数据库应用，消息队列，等等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Statefulset(有状态) 与 Deployment(无状态) 的区别是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Statefulset 创建的 Pod 会有相同的名称，并且会分配相同的持久卷。</li>\n<li class=\"lvl-4\">Statefulset 创建的 Pod 使用 Headless Service(无头服务，没有ClusterIP)进行通信。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Statefulset-管理\">Statefulset 管理</h2>\n<h3 id=\"Statefulset-创建\">Statefulset 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Statefulset 只能 通过 <code>yaml</code> 创建，不支持 <code>create</code> 创建</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个简单的 <code>redis-statefulset.yaml</code> 文件说明</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                      <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>                       <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                           <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-svc</span>                   <span class=\"comment\"># service名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">sts-ns</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                               <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>                            <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span>                      <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>                   <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span>                <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                         <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                      <span class=\"comment\"># pod的标签，即匹配pod的标签 app=redis</span></span><br><span class=\"line\">  <span class=\"attr\">clusterIP:</span> <span class=\"string\">None</span>                   <span class=\"comment\"># 集群IP设置为None，即为“Headless Service”</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">ClusterIP</span>                   <span class=\"comment\"># 服务类型，默认为ClusterIP</span></span><br><span class=\"line\"><span class=\"string\">---</span>                                 <span class=\"comment\"># 分割线</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 StatefulSet 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span>                    <span class=\"comment\"># Kubernetes 资源类型，这里是部署（StatefulSet）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sts</span>                    <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">sts-ns</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">revisionHistoryLimit:</span> <span class=\"number\">10</span>           <span class=\"comment\"># 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                     <span class=\"comment\"># 选择器，指定 StatefulSet 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">updateStrategy:</span>                    <span class=\"comment\"># 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 StatefulSet 模板后， 老的 StatefulSet Pod 将被终止，并且将以受控方式自动创建新的 StatefulSet Pod。 更新期间，最多只能有 StatefulSet 的一个 Pod 运行于每个节点上。</span></span><br><span class=\"line\">                                     <span class=\"comment\"># 2.OnDelete：使用 OnDelete 更新策略时，在更新 StatefulSet 模板后，只有当你手动删除老的 StatefulSet Pod 之后，新的 StatefulSet Pod 才会被自动创建。</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动升级的配置</span></span><br><span class=\"line\">      <span class=\"attr\">partition:</span> <span class=\"number\">0</span>                    <span class=\"comment\"># 用于控制从第几个 Pod 开始滚动升级</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">redis-svc</span>             <span class=\"comment\"># 服务名称,sts对象使用无头服务，这个是必填项</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span>                        <span class=\"comment\"># 副本数，默认是 1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">redis:6.2</span>             <span class=\"comment\"># 容器使用的镜像，这里是官方的 redis 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">redis</span>                  <span class=\"comment\"># 容器的名称，实际的名称为 sts-redis-&lt;number&gt;，从 0 开始递增</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>执行创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建命名空间</span></span><br><span class=\"line\">kubectl create namespace sts-ns</span><br><span class=\"line\"><span class=\"comment\"># 创建 StatefulSet</span></span><br><span class=\"line\">kubectl apply -f redis-statefulset.yaml</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Statefulset\">查看 Statefulset</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get all -n sts-ns</span><br><span class=\"line\">NAME              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/redis-sts-0   1/1     Running   0          40s</span><br><span class=\"line\">pod/redis-sts-1   1/1     Running   0          24s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class=\"line\">service/redis-svc   ClusterIP   None         &lt;none&gt;        6379/TCP   40s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                         READY   AGE</span><br><span class=\"line\">statefulset.apps/redis-sts   2/2     40s</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问pod中的redis服务\">访问pod中的redis服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>既然是Headless Service，就只能在集群内部访问</p>\n</li>\n<li class=\"lvl-2\">\n<p>在相同的 namespace 中，可以通过 <code>serviceName</code> 直接访问，访问指定的 pod，可以通过 <code>&lt;pod-name&gt;.&lt;service-name&gt;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>在不同的 namespace 中，可以通过 <code>&lt;serviceName&gt;.&lt;namespace&gt;</code> 或者 <code>&lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local</code> 访问，访问指定的 pod，可以通过 <code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 访问，因为 pod-name 是固定且唯一的</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it pod/redis-sts-0 -n sts-ns -- getent hosts redis-svc</span><br><span class=\"line\">10.244.126.55   redis-svc.sts-ns.svc.cluster.local</span><br><span class=\"line\">10.244.194.110  redis-svc.sts-ns.svc.cluster.local</span><br><span class=\"line\"></span><br><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it pod/redis-sts-0 -n sts-ns -- getent hosts redis-sts-1.redis-svc</span><br><span class=\"line\">10.244.126.55   redis-sts-1.redis-svc.sts-ns.svc.cluster.local</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在集群外部访问，需要创建一个新的 Service，类型为 NodePort 或者 LoadBalancer，将redis服务暴露出去</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                      <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>                       <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                           <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-svc-out</span>               <span class=\"comment\"># service名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">sts-ns</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                               <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>                            <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span>                      <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>                   <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span>                <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                         <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis</span>                      <span class=\"comment\"># pod的标签，即匹配pod的标签 app=redis</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">LoadBalancer</span>                <span class=\"comment\"># 负载均衡</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>执行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建</span></span><br><span class=\"line\">$ k create -f redis-svc-out.yaml</span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">$ k get svc -n sts-ns</span><br><span class=\"line\">NAME            TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)          AGE</span><br><span class=\"line\">redis-svc       ClusterIP      None          &lt;none&gt;          6379/TCP         70m</span><br><span class=\"line\">redis-svc-out   LoadBalancer   10.96.21.96   10.211.55.202   6379:31806/TCP   54m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在集群外的机器上访问 redis，每次连接会轮询访问各个pod</span></span><br><span class=\"line\">$ redis-cli -h 10.211.55.202 info server | grep redis_version</span><br><span class=\"line\">redis_version:8.0.3</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Statefulset-详情\">查看 Statefulset 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 Statefulset 运行错误时，可以通过该命令查看 Statefulset 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe sts &lt;sts-name&gt;</span><br><span class=\"line\">kubectl describe sts &lt;sts-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-Statefulset\">删除 Statefulset</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete sts &lt;sts-name&gt;</span><br><span class=\"line\">kubectl delete sts &lt;sts-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件删除</span></span><br><span class=\"line\">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Statefulset-日志\">查看 Statefulset 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs sts/&lt;sts-name&gt;</span><br><span class=\"line\">kubectl logs sts/&lt;sts-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动升级与回滚-Statefulset\">滚动升级与回滚 Statefulset</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对 <code>RollingUpdate</code> 类型的 <code>Statefulset</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们修改过 <code>Statefulset</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it pod/redis-sts-0 -n sts-ns -- redis-server -v</span><br><span class=\"line\">Redis server v=6.2.19 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=c51c65e7ae83f735</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># kubectl set image sts/&lt;sts-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=true</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">set</span> image sts redis-sts redis=redis:8.0 --record=<span class=\"literal\">true</span> -n sts-ns</span><br><span class=\"line\"></span><br><span class=\"line\">$ k <span class=\"built_in\">exec</span> -it pod/redis-sts-0 -n sts-ns -- redis-server -v</span><br><span class=\"line\">Redis server v=8.0.3 sha=00000000:1 malloc=jemalloc-5.3.0 bits=64 build=d4cb0aa008da4ca9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看滚动升级状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl rollout status sts/&lt;sts-name&gt;</span></span><br><span class=\"line\">$ kubectl rollout status sts redis-sts -n sts-ns</span><br><span class=\"line\">partitioned roll out complete: 2 new pods have been updated...</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看历史版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前面的序号表示版本号</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> sts redis-sts -n sts-ns</span><br><span class=\"line\"><span class=\"comment\"># 查看指定版本的详情</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> sts redis-sts -n sts-ns --revision=1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>回滚</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回退到前一个版本</span></span><br><span class=\"line\">kubectl rollout undo sts redis-sts -n sts-ns</span><br><span class=\"line\"><span class=\"comment\"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class=\"line\">kubectl rollout undo sts redis-sts -n sts-nsx --to-revision=1</span><br></pre></td></tr></table></figure>\n<h2 id=\"Deployment-和-StatefulSet-的对比总结\">Deployment 和 StatefulSet 的对比总结</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><strong>Deployment</strong></th>\n<th><strong>StatefulSet</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>无状态应用（如 Web 服务、API 服务）</td>\n<td>有状态应用（如数据库、缓存：Redis、MySQL、Kafka）</td>\n</tr>\n<tr>\n<td><strong>Pod 名称</strong></td>\n<td>Pod 名字随机生成，如 <code>nginx-abc123</code></td>\n<td>Pod 名字有序，格式为 <code>name-0</code>、<code>name-1</code>、<code>name-2</code></td>\n</tr>\n<tr>\n<td><strong>稳定的标识</strong></td>\n<td><strong>不提供</strong>，每次重建 Pod 名字可能不同</td>\n<td><strong>提供</strong>，每个 Pod 的名字、网络 ID、存储持久化不变</td>\n</tr>\n<tr>\n<td><strong>存储卷</strong></td>\n<td>通常配合 PVC，但 Pod 重建时挂载卷可能变化</td>\n<td>配置 <code>volumeClaimTemplates</code>，每个 Pod 独立持久卷</td>\n</tr>\n<tr>\n<td><strong>滚动更新策略</strong></td>\n<td>支持 <code>maxSurge</code>、<code>maxUnavailable</code>，可并行更新 Pod</td>\n<td>默认 <strong>逐个顺序更新</strong> Pod（可用 <code>partition</code> 控制分批更新）</td>\n</tr>\n<tr>\n<td><strong>可用性</strong></td>\n<td>通常设计为 <strong>无状态多副本高可用</strong>，不保证 Pod 启动顺序或固定 IP</td>\n<td><strong>有状态且有序部署、删除、更新</strong>，通常单副本逐个维护可用性</td>\n</tr>\n<tr>\n<td><strong>服务访问</strong></td>\n<td>通过 ClusterIP、NodePort、LoadBalancer 访问</td>\n<td>推荐用 <strong>Headless Service (clusterIP: None)</strong>，Pod 有固定 DNS</td>\n</tr>\n<tr>\n<td><strong>典型应用场景</strong></td>\n<td>Web 应用、REST API、无状态微服务</td>\n<td>数据库（MySQL、PostgreSQL）、缓存（Redis）、队列（Kafka、RabbitMQ）</td>\n</tr>\n<tr>\n<td><strong>Pod 伸缩特性</strong></td>\n<td><strong>灵活伸缩</strong>，增加/减少副本无特定顺序</td>\n<td><strong>有序伸缩</strong>，<code>name-0</code> -&gt; <code>name-1</code> -&gt; <code>name-2</code>…</td>\n</tr>\n<tr>\n<td><strong>重建策略</strong></td>\n<td>Pod 崩溃后重建的是新 Pod，无持久存储数据可能丢失</td>\n<td>Pod 崩溃后重建的是相同 Pod 名字，挂载相同 PVC，不丢数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>StatefulSet 类似于 Deployment，同样支持扩缩容（scale 或者 hpa），但因为其是有状态的，所以需谨慎</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># scale</span></span><br><span class=\"line\">kubectl scale sts redis-sts --replicas=5 -n sts-ns</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># hpa，要求pod配置中有资源限制</span></span><br><span class=\"line\">kubectl autoscale sts redis-sts --name=<span class=\"string\">&quot;hpa-redis&quot;</span> --cpu-percent=50 --min=3 --max=10 -n sts-ns</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><strong>可行性</strong></th>\n<th><strong>推荐情况</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>扩容（增加副本数）</strong></td>\n<td>✅ <strong>推荐</strong></td>\n<td>安全，新增 Pod 按序从 N-1 开始创建（<code>sts-name-0</code> -&gt; <code>sts-name-1</code> -&gt; <code>sts-name-2</code>）</td>\n</tr>\n<tr>\n<td><strong>缩容（减少副本数）</strong></td>\n<td>⚠️ <strong>小心使用</strong></td>\n<td>可能导致 Pod 及其关联 PVC 被废弃，<strong>数据可能丢失</strong></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 Statefulset ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Statefulset 介绍 Statefulset 介绍 Statefulset(缩写为 sts) 是 K8S 官方提供的一种控制器，用于管理有状态应用。例如，数据库应用，消息队列，等等。 Statefulset(有状态) 与 Deployment(无状态) 的区别是： Statefulset 创建的 Pod 会有相同的名称，并且会分配相同的持久卷。 Statefulset 创建的 Pod 使用 Headless Service(无头服务，没有ClusterIP)进行通信。 Statefulset 管理 Statefulset 创建 Statefulset 只能 通过 yaml 创建，不支持 create 创建 一个简单的 redis-statefulset.yaml 文件说明 12345678910111213141516171819202122232425262728293031323334353637383940apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: redis-svc # service名称 namespace: sts-nsspec: # 配置 ports: # 端口 - port: 6379 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 6379 # 容器端口, pod的端口，这个必须与实际容器端口一致 selector: # 选择器 app: redis # pod的标签，即匹配pod的标签 app=redis clusterIP: None # 集群IP设置为None，即为“Headless Service” type: ClusterIP # 服务类型，默认为ClusterIP--- # 分割线apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 StatefulSet 资源kind: StatefulSet # Kubernetes 资源类型，这里是部署（StatefulSet）metadata: name: redis-sts # 资源名称，必须唯一（在同一命名空间下） namespace: sts-nsspec: # 配置项 revisionHistoryLimit: 10 # 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: redis # 选择器，指定 StatefulSet 管理哪些 Pod（标签必须与 template 中匹配） updateStrategy: # 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样 type: RollingUpdate # 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 StatefulSet 模板后， 老的 StatefulSet Pod 将被终止，并且将以受控方式自动创建新的 StatefulSet Pod。 更新期间，最多只能有 StatefulSet 的一个 Pod 运行于每个节点上。 # 2.OnDelete：使用 OnDelete 更新策略时，在更新 StatefulSet 模板后，只有当你手动删除老的 StatefulSet Pod 之后，新的 StatefulSet Pod 才会被自动创建。 rollingUpdate: # 滚动升级的配置 partition: 0 # 用于控制从第几个 Pod 开始滚动升级 serviceName: redis-svc # 服务名称,sts对象使用无头服务，这个是必填项 replicas: 2 # 副本数，默认是 1 template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: redis # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: redis:6.2 # 容器使用的镜像，这里是官方的 redis 镜像 name: redis # 容器的名称，实际的名称为 sts-redis-&lt;number&gt;，从 0 开始递增 执行创建 1234# 创建命名空间kubectl create namespace sts-ns# 创建 StatefulSetkubectl apply -f redis-statefulset.yaml 查看 Statefulset 12345678910$ k get all -n sts-nsNAME READY STATUS RESTARTS AGEpod/redis-sts-0 1/1 Running 0 40spod/redis-sts-1 1/1 Running 0 24sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/redis-svc ClusterIP None &lt;none&gt; 6379/TCP 40sNAME READY AGEstatefulset.apps/redis-sts 2/2 40s 访问pod中的redis服务 既然是Headless Service，就只能在集群内部访问 在相同的 namespace 中，可以通过 serviceName 直接访问，访问指定的 pod，可以通过 &lt;pod-name&gt;.&lt;service-name&gt; 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，访问指定的 pod，可以通过 &lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local 访问，因为 pod-name 是固定且唯一的 123456$ k exec -it pod/redis-sts-0 -n sts-ns -- getent hosts redis-svc10.244.126.55 redis-svc.sts-ns.svc.cluster.local10.244.194.110 redis-svc.sts-ns.svc.cluster.local$ k exec -it pod/redis-sts-0 -n sts-ns -- getent hosts redis-sts-1.redis-svc10.244.126.55 redis-sts-1.redis-svc.sts-ns.svc.cluster.local 在集群外部访问，需要创建一个新的 Service，类型为 NodePort 或者 LoadBalancer，将redis服务暴露出去 12345678910111213apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: redis-svc-out # service名称 namespace: sts-nsspec: # 配置 ports: # 端口 - port: 6379 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 6379 # 容器端口, pod的端口，这个必须与实际容器端口一致 selector: # 选择器 app: redis # pod的标签，即匹配pod的标签 app=redis type: LoadBalancer # 负载均衡 执行 1234567891011# 创建$ k create -f redis-svc-out.yaml# 查看$ k get svc -n sts-nsNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEredis-svc ClusterIP None &lt;none&gt; 6379/TCP 70mredis-svc-out LoadBalancer 10.96.21.96 10.211.55.202 6379:31806/TCP 54m# 在集群外的机器上访问 redis，每次连接会轮询访问各个pod$ redis-cli -h 10.211.55.202 info server | grep redis_versionredis_version:8.0.3 查看 Statefulset 详情 当 Statefulset 运行错误时，可以通过该命令查看 Statefulset 的详情，找到错误原因 12kubectl describe sts &lt;sts-name&gt;kubectl describe sts &lt;sts-name&gt; -n &lt;namespace-name&gt; 删除 Statefulset 12345kubectl delete sts &lt;sts-name&gt;kubectl delete sts &lt;sts-name&gt; -n &lt;namespace-name&gt;# 通过 yaml 文件删除kubectl delete -f &lt;yaml-file&gt; 查看 Statefulset 日志 12kubectl logs sts/&lt;sts-name&gt;kubectl logs sts/&lt;sts-name&gt; -n &lt;namespace-name&gt; 滚动升级与回滚 Statefulset 对 RollingUpdate 类型的 Statefulset 的 .spec.template 的任何更新都将触发滚动更新。 我们修改过 Statefulset 的 .spec.template，并保存后，重新运行 kubectl apply -f &lt;yaml-file&gt;即可触发滚动升级。 如果只是更新容器的镜像，也可以通过如下命令触发滚动升级 12345678$ k exec -it pod/redis-sts-0 -n sts-ns -- redis-server -vRedis server v=6.2.19 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=c51c65e7ae83f735# kubectl set image sts/&lt;sts-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=truekubectl set image sts redis-sts redis=redis:8.0 --record=true -n sts-ns$ k exec -it pod/redis-sts-0 -n sts-ns -- redis-server -vRedis server v=8.0.3 sha=00000000:1 malloc=jemalloc-5.3.0 bits=64 build=d4cb0aa008da4ca9 查看滚动升级状态 123# kubectl rollout status sts/&lt;sts-name&gt;$ kubectl rollout status sts redis-sts -n sts-nspartitioned roll out complete: 2 new pods have been updated... 查看历史版本 1234# 前面的序号表示版本号kubectl rollout history sts redis-sts -n sts-ns# 查看指定版本的详情kubectl rollout history sts redis-sts -n sts-ns --revision=1 回滚 1234# 回退到前一个版本kubectl rollout undo sts redis-sts -n sts-ns# 回到指定版本，这里 --to-revision=1 表示回到版本1kubectl rollout undo sts redis-sts -n sts-nsx --to-revision=1 Deployment 和 StatefulSet 的对比总结 特性 Deployment StatefulSet 用途 无状态应用（如 Web 服务、API 服务） 有状态应用（如数据库、缓存：Redis、MySQL、Kafka） Pod 名称 Pod 名字随机生成，如 nginx-abc123 Pod 名字有序，格式为 name-0、name-1、name-2 稳定的标识 不提供，每次重建 Pod 名字可能不同 提供，每个 Pod 的名字、网络 ID、存储持久化不变 存储卷 通常配合 PVC，但 Pod 重建时挂载卷可能变化 配置 volumeClaimTemplates，每个 Pod 独立持久卷 滚动更新策略 支持 maxSurge、maxUnavailable，可并行更新 Pod 默认 逐个顺序更新 Pod（可用 partition 控制分批更新） 可用性 通常设计为 无状态多副本高可用，不保证 Pod 启动顺序或固定 IP 有状态且有序部署、删除、更新，通常单副本逐个维护可用性 服务访问 通过 ClusterIP、NodePort、LoadBalancer 访问 推荐用 Headless Service (clusterIP: None)，Pod 有固定 DNS 典型应用场景 Web 应用、REST API、无状态微服务 数据库（MySQL、PostgreSQL）、缓存（Redis）、队列（Kafka、RabbitMQ） Pod 伸缩特性 灵活伸缩，增加/减少副本无特定顺序 有序伸缩，name-0 -&gt; name-1 -&gt; name-2… 重建策略 Pod 崩溃后重建的是新 Pod，无持久存储数据可能丢失 Pod 崩溃后重建的是相同 Pod 名字，挂载相同 PVC，不丢数据 后记 StatefulSet 类似于 Deployment，同样支持扩缩容（scale 或者 hpa），但因为其是有状态的，所以需谨慎 12345# scalekubectl scale sts redis-sts --replicas=5 -n sts-ns# hpa，要求pod配置中有资源限制kubectl autoscale sts redis-sts --name=&quot;hpa-redis&quot; --cpu-percent=50 --min=3 --max=10 -n sts-ns 操作 可行性 推荐情况 扩容（增加副本数） ✅ 推荐 安全，新增 Pod 按序从 N-1 开始创建（sts-name-0 -&gt; sts-name-1 -&gt; sts-name-2） 缩容（减少副本数） ⚠️ 小心使用 可能导致 Pod 及其关联 PVC 被废弃，数据可能丢失","summary":"摘要 本文介绍 K8S 的 Statefulset ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Statefulset 介绍","date_published":"2025-07-20T15:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/","url":"https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/","title":"K8S 之 Horizontal Pod Autoscaler（HPA）","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/autoscaling/\">Autoscaling k8s简介</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/\">Horizontal Pod Autoscaler（HPA）</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Horizontal-Pod-Autoscaler（HPA）-简介\">Horizontal Pod Autoscaler（HPA） 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Horizontal Pod Autoscaler（缩写为 hpa）基于资源 CPU 利用率自动调整 deployment、replication controller 或者 replica 中 pod 的数量，这有助于您的应用程序进行扩展以满足增长的需求，或在不需要资源时进行缩减，从而释放出节点用于其他应用程序。当您设置目标 CPU 利用率百分比时，HPA 扩展或缩减应用程序来尝试满足该目标。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 本身已经包含了 HPA 的 controller，所以不需要额外的安装或部署。</p>\n</li>\n<li class=\"lvl-2\">\n<p>HPA 需要获取 metrics 信息，metrics 信息需要从 Metrics Server 中获取，所以需要先安装 Metrics Server。</p>\n</li>\n<li class=\"lvl-2\">\n<p>HPA 会周期性(默认15秒)查询目标资源的使用情况，然后和 HPA 中定义的值做比较，并根据比较结果相应的调整 pod 数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建pod时，必须为其设定cpu资源，用于与目标值进行比较，目前最新的v2版本的HPA除了支持CPU的对比，还可以设定其它指标，具体参考<a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/\">HorizontalPodAutoscaler 演练</a>中的“基于多项度量指标和自定义度量指标自动扩缩”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>博主之前写过一篇在aws的eks中使用hpa的文章 <a href=\"/2023/07/17/aws-eks17-hpa/\" title=\"AWS-EKS-17--Horizontal Pod Autoscaler（HPA）\">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>，和在自己搭建 k8s集群 中使用 hpa 基本一致，所以本文不再对重复内容进行赘述，建议读者先阅读 <a href=\"/2023/07/17/aws-eks17-hpa/\" title=\"AWS-EKS-17--Horizontal Pod Autoscaler（HPA）\">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>。</p>\n</li>\n</ul>\n<h2 id=\"安装-Metrics-Server\">安装 Metrics Server</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 的 HPA 是依赖 Metrics API 的，默认并不内置。需要通过 metrics-server 来收集和提供节点/Pod 的资源用量数据（CPU、内存等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装 <a href=\"https://github.com/kubernetes-sigs/metrics-server\">metrics-server</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L -o metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br><span class=\"line\">$ kubectl apply -f metrics-server.yaml</span><br><span class=\"line\">serviceaccount/metrics-server created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class=\"line\">service/metrics-server created</span><br><span class=\"line\">deployment.apps/metrics-server created</span><br><span class=\"line\">apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>部署后发现pod没有运行成功</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  k get all -n kube-system -l k8s-app=metrics-server</span><br><span class=\"line\">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/metrics-server-867d48dc9c-fgdjq   0/1     Running   0          16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">service/metrics-server   ClusterIP   10.96.91.221   &lt;none&gt;        443/TCP   16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                             READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/metrics-server   0/1     1            0           16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                        DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/metrics-server-867d48dc9c   1         1         0       16s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>检查日志</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k logs deployment.apps/metrics-server -n kube-system</span><br><span class=\"line\"><span class=\"comment\">## 输出类似于</span></span><br><span class=\"line\">E0703 23:02:38.120831       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.15:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.15 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-worker1&quot;</span></span><br><span class=\"line\">E0703 23:02:38.127774       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.16:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.16 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-worker2&quot;</span></span><br><span class=\"line\">E0703 23:02:38.140583       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.11:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.11 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-master&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>意思是 metrics-server 在通过 https://<node-ip>:10250 请求 kubelet 的时候，发现 kubelet 的证书不包含该 IP 的 Subject Alternative Name (SAN)，因此 TLS 校验失败。</p>\n</li>\n<li class=\"lvl-2\">\n<p>解决方案: 添加 --kubelet-insecure-tls 参数，跳过 kubelet 的 TLS 证书校验(metrics-server 本身权限有限，风险可控，kubelet 自签证书维护成本高)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit deployment metrics-server -n kube-system</span><br><span class=\"line\"><span class=\"comment\">## 在 args 中添加 --kubelet-insecure-tls</span></span><br><span class=\"line\">  spec:</span><br><span class=\"line\">    containers:</span><br><span class=\"line\">    - args:</span><br><span class=\"line\">      - --cert-dir=/tmp</span><br><span class=\"line\">      - --secure-port=10250</span><br><span class=\"line\">      - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class=\"line\">      - --kubelet-use-node-status-port</span><br><span class=\"line\">      - --metric-resolution=15s</span><br><span class=\"line\">      - --kubelet-insecure-tls   <span class=\"comment\"># 添加此行</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>wq</code>保存后，等一会再次查看所有资源均已正常</p>\n</li>\n<li class=\"lvl-2\">\n<p>查看所有 node 的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k top nodes</span><br><span class=\"line\">NAME          CPU(cores)   CPU(%)   MEMORY(bytes)   MEMORY(%)</span><br><span class=\"line\">k8s-master    216m         10%      1712Mi          44%</span><br><span class=\"line\">k8s-worker1   79m          3%       1025Mi          26%</span><br><span class=\"line\">k8s-worker2   82m          4%       982Mi           25%</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NAME</strong></td>\n<td>节点名称，Kubernetes 集群的节点名字。</td>\n</tr>\n<tr>\n<td><strong>CPU(cores)</strong></td>\n<td>当前节点 CPU 的瞬时使用量，单位是核心数（Core），比如 <code>216m</code> = 0.216 核心。<code>m</code> = <strong>millicores</strong>，1000m = 1核。</td>\n</tr>\n<tr>\n<td><strong>CPU(%)</strong></td>\n<td>当前 CPU 使用率，相对于该节点 CPU 总核数的百分比。比如 <code>10%</code> 表示节点 CPU 的 10% 被使用。</td>\n</tr>\n<tr>\n<td><strong>MEMORY(bytes)</strong></td>\n<td>节点当前使用的内存，单位是字节（例如 <code>1712Mi</code> = 1712 Mebibytes ≈ 1.7 GB）。</td>\n</tr>\n<tr>\n<td><strong>MEMORY(%)</strong></td>\n<td>节点内存使用率，占总内存的百分比。比如 <code>44%</code> 表示该节点内存使用了 44%。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看所有 pod 的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k top pods -A</span><br><span class=\"line\">NAMESPACE     NAME                                       CPU(cores)   MEMORY(bytes)</span><br><span class=\"line\">default       nginx-5869d7778c-5682r                     0m           9Mi</span><br><span class=\"line\">default       nginx-5869d7778c-thw8f                     0m           4Mi</span><br><span class=\"line\">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   6m           35Mi</span><br><span class=\"line\">kube-system   calico-node-7pbbq                          42m          281Mi</span><br><span class=\"line\">kube-system   calico-node-v4hzr                          47m          260Mi</span><br><span class=\"line\">kube-system   calico-node-w47qq                          40m          263Mi</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-2tvld                   2m           23Mi</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-h6kx7                   2m           22Mi</span><br><span class=\"line\">kube-system   etcd-k8s-master                            27m          85Mi</span><br><span class=\"line\">kube-system   kube-apiserver-k8s-master                  49m          404Mi</span><br><span class=\"line\">kube-system   kube-controller-manager-k8s-master         28m          100Mi</span><br><span class=\"line\">kube-system   kube-proxy-nkbns                           1m           41Mi</span><br><span class=\"line\">kube-system   kube-proxy-plqw8                           1m           25Mi</span><br><span class=\"line\">kube-system   kube-proxy-sbgh6                           1m           34Mi</span><br><span class=\"line\">kube-system   kube-scheduler-k8s-master                  8m           38Mi</span><br><span class=\"line\">kube-system   metrics-server-56fb9549f4-rtt7n            4m           21Mi</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-HPA\">创建 HPA</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前面的文章中多次使用 nginx 镜像创建了 deployment，但是都没有配置过资源，为了测试 hpa，需要为其指定资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接修改 deployment，改变 spec.template，Pod 会被重建。保存后立刻生效</span></span><br><span class=\"line\">kubectl edit deployment nginx</span><br><span class=\"line\"><span class=\"comment\"># 增加资源限制</span></span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 1   <span class=\"comment\"># 修改副本数位 1，仅改变 replicas，Pod 不会被重建</span></span><br><span class=\"line\">  template:     <span class=\"comment\"># 修改 template，Pod 会被重建</span></span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: nginx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: nginx</span><br><span class=\"line\">        image: nginx</span><br><span class=\"line\">        resources:</span><br><span class=\"line\">          limits:</span><br><span class=\"line\">            cpu: 500m</span><br><span class=\"line\">            memory: 500Mi</span><br><span class=\"line\">          requests:</span><br><span class=\"line\">            cpu: 200m</span><br><span class=\"line\">            memory: 200Mi</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建 HPA</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建了一个叫“hpa-nginx”的 HPA，默认与 deployment 的名称相同，可以用 --name=&#x27;hpa-nginx&#x27; 指定hpa的名称</span></span><br><span class=\"line\"><span class=\"comment\"># replicas 变动范围是最小 3，最大 10</span></span><br><span class=\"line\"><span class=\"comment\"># 目标cpu利用率为 50%，上面我们设定 CPU request 值为 100m，所以当平均cpu值为 100m 时就会触发 autoscale</span></span><br><span class=\"line\"><span class=\"comment\"># 这里说平均cpu，是指所有pod的cpu利用率的平均值</span></span><br><span class=\"line\">$ k autoscale deployment nginx --name=<span class=\"string\">&quot;hpa-nginx&quot;</span> --cpu-percent=50 --min=3 --max=10</span><br><span class=\"line\">horizontalpodautoscaler.autoscaling/hpa-nginx autoscaled</span><br><span class=\"line\"><span class=\"comment\"># 观察，大约 15秒后，hpa-nginx 发现 replicas 值为1，30秒的时候自动扩容到3个，因为我们设置的hpa的replicas最小值为3，并且采集到了cpu使用率</span></span><br><span class=\"line\">$ k get hpa -w</span><br><span class=\"line\">NAME        REFERENCE          TARGETS              MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        0          0s</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        1          15s</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: 0%/50%          3         10        3          30s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ymal文件创建 HPA</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">autoscaling/v2</span>    <span class=\"comment\"># api版本，这里设置为 v2</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">HorizontalPodAutoscaler</span> <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hpa-nginx</span>             <span class=\"comment\"># hpa资源名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>          <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">maxReplicas:</span> <span class=\"number\">10</span>             <span class=\"comment\"># 最大副本数</span></span><br><span class=\"line\">  <span class=\"attr\">minReplicas:</span> <span class=\"number\">1</span>              <span class=\"comment\"># 最小副本数</span></span><br><span class=\"line\">  <span class=\"attr\">metrics:</span>                    <span class=\"comment\"># 指标设定</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span>            <span class=\"comment\"># 资源类型，可以配置为 Resource/Object/Pods</span></span><br><span class=\"line\">    <span class=\"attr\">resource:</span>                 <span class=\"comment\"># 资源对象</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>               <span class=\"comment\"># 资源名称 cpu/memory</span></span><br><span class=\"line\">      <span class=\"attr\">target:</span>                 <span class=\"comment\"># 目标对象</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>     <span class=\"comment\"># 目标类型，可以配置为 Utilization/AverageValue/Value</span></span><br><span class=\"line\">        <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span> <span class=\"comment\"># 目标值，这里是平均使用率的百分比</span></span><br><span class=\"line\">  <span class=\"attr\">scaleTargetRef:</span>             <span class=\"comment\"># 指定要自动伸缩的资源对象</span></span><br><span class=\"line\">    <span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>          <span class=\"comment\"># 资源类型为 Deployment</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>               <span class=\"comment\"># 资源名称为 nginx</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"HPA-支持的监控指标类型\">HPA 支持的监控指标类型</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字段名</th>\n<th>说明</th>\n<th>常见用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Resource</strong></td>\n<td><code>resource</code></td>\n<td>基于 Pod 资源使用情况（CPU、内存），最常用</td>\n<td>按 CPU 利用率自动扩缩容</td>\n</tr>\n<tr>\n<td><strong>Pods</strong></td>\n<td><code>pods</code></td>\n<td>基于每个 Pod 的自定义度量指标的平均值，需要第三方监控系统提供，比如 Prometheus</td>\n<td>按业务指标（如请求数、队列长度）扩缩容</td>\n</tr>\n<tr>\n<td><strong>Object</strong></td>\n<td><code>object</code></td>\n<td>基于单个 Kubernetes 对象（如 Service、Ingress）的指标，，比如 Prometheus</td>\n<td>按某个对象的指标扩缩容，例如队列长度</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Resource-资源指标（CPU-内存）\">Resource 资源指标（CPU/内存）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Utilization: 利用率百分比</p>\n</li>\n<li class=\"lvl-2\">\n<p>Utilization 不关心 limits，只看 requests。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果 resources.requests 没有设置，HPA Utilization 会报错（除非 AverageValue）。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metrics:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span>                   <span class=\"comment\"># 资源 指标</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>                 <span class=\"comment\"># cpu</span></span><br><span class=\"line\">    <span class=\"attr\">target:</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>       <span class=\"comment\"># 利用率百分比</span></span><br><span class=\"line\">      <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span>  <span class=\"comment\"># 50%</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当前有 3 个 Pod：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Pod</th>\n<th>CPU 实际使用</th>\n<th>CPU requests</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod-1</td>\n<td>150m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>pod-2</td>\n<td>100m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>pod-3</td>\n<td>50m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>合计</td>\n<td>400m</td>\n<td>600m</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>400m ÷ 600m × 100% ≈ 66.7%</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>由于 66.7% &gt; 50%，会扩容；如果小于 50%，HPA 会缩容。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>AverageValue: 指定资源使用平均值</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metrics:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">memory</span>                <span class=\"comment\"># 监控资源类型为 memory（内存）</span></span><br><span class=\"line\">    <span class=\"attr\">target:</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">AverageValue</span>        <span class=\"comment\"># 指标类型为 AverageValue，表示每个 Pod 平均使用多少</span></span><br><span class=\"line\">      <span class=\"attr\">averageValue:</span> <span class=\"string\">400Mi</span>       <span class=\"comment\"># 目标值：平均每个 Pod 使用 400Mi 内存</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假设当前部署了 3 个副本，内存使用情况如下：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Pod</th>\n<th>当前内存使用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod-1</td>\n<td>450Mi</td>\n</tr>\n<tr>\n<td>pod-2</td>\n<td>400Mi</td>\n</tr>\n<tr>\n<td>pod-3</td>\n<td>300Mi</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>(450+400+300)/3 = 383.3Mi</strong></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>因为 383.3Mi &lt; 400Mi，不触发扩容。如果将来平均使用超过 400Mi，HPA 就会扩容，反之缩容。</p>\n</blockquote>\n<h2 id=\"HPA-扩缩容速度配置\">HPA 扩缩容速度配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HPA 的扩缩容速度是可以控制的，通过 behavior 字段来自定义扩缩容的速度和策略。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是默认策略</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">behavior:</span></span><br><span class=\"line\">  <span class=\"attr\">scaleUp:</span>                                  <span class=\"comment\"># ⬆️ 扩容策略</span></span><br><span class=\"line\">    <span class=\"attr\">tolerance:</span> <span class=\"number\">0.1</span>                          <span class=\"comment\"># 容忍阈值，默认0.1(10%)，表示每次扩容时，pod使用率超过1.1倍目标值时才会进行扩容</span></span><br><span class=\"line\">    <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">0</span>           <span class=\"comment\"># 默认0，即增加或减少pod数量后保持不变的时间，单位为秒</span></span><br><span class=\"line\">    <span class=\"attr\">policies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 扩容速度按百分比限制</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒最多扩容 100% 的副本数</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒计算一次是否可以扩容，默认 15 秒</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Pods</span>                            <span class=\"comment\"># 按固定 Pod 数量限制扩容速度</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">4</span>                              <span class=\"comment\"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 同样 15 秒计算一次，默认 15 秒</span></span><br><span class=\"line\">    <span class=\"attr\">selectPolicy:</span> <span class=\"string\">Max</span>                       <span class=\"comment\"># 多个 policy 同时存在时，取 Percent 和 Pods 的最大值。Min 取最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">scaleDown:</span>                                <span class=\"comment\"># ⬇️ 缩容策略</span></span><br><span class=\"line\">    <span class=\"comment\"># selectPolicy: Disabled                  # 禁用缩容</span></span><br><span class=\"line\">    <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">300</span>         <span class=\"comment\"># 默认 300，即增加或减少pod数量后保持不变的时间，单位为秒，防止快速缩容（平滑策略）</span></span><br><span class=\"line\">    <span class=\"attr\">policies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 缩容速度按百分比限制</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒最多缩容 100% 的副本数</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次是否可以缩容</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整的 HPA 配置文件示例(一般情况下，我们无需修改扩缩容速度的配置，默认策略满足大部分场景)</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">autoscaling/v2</span>                    <span class=\"comment\"># api版本，使用 v2 版本支持 behavior 扩缩容策略</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">HorizontalPodAutoscaler</span>                 <span class=\"comment\"># 资源类型为 HPA</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hpa-nginx</span>                             <span class=\"comment\"># HPA 资源的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>                          <span class=\"comment\"># 命名空间，设置为 default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">maxReplicas:</span> <span class=\"number\">10</span>                             <span class=\"comment\"># HPA 自动扩容的最大副本数</span></span><br><span class=\"line\">  <span class=\"attr\">minReplicas:</span> <span class=\"number\">1</span>                              <span class=\"comment\"># HPA 自动缩容的最小副本数</span></span><br><span class=\"line\">  <span class=\"attr\">metrics:</span>                                    <span class=\"comment\"># 自动伸缩的指标配置</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span>                            <span class=\"comment\"># 指标类型为 Resource（资源型）</span></span><br><span class=\"line\">    <span class=\"attr\">resource:</span>                                 <span class=\"comment\"># 资源指标对象</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>                               <span class=\"comment\"># 资源名称为 cpu，也可以设置为 memory</span></span><br><span class=\"line\">      <span class=\"attr\">target:</span>                                 <span class=\"comment\"># 目标指标对象</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>                     <span class=\"comment\"># 指标类型为 Utilization（利用率百分比）</span></span><br><span class=\"line\">        <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span>                <span class=\"comment\"># CPU 平均使用率达到 50% 时进行扩缩容</span></span><br><span class=\"line\">  <span class=\"attr\">scaleTargetRef:</span>                             <span class=\"comment\"># HPA 绑定的目标资源对象</span></span><br><span class=\"line\">    <span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                          <span class=\"comment\"># 目标类型为 Deployment</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                               <span class=\"comment\"># 目标 Deployment 名称为 nginx</span></span><br><span class=\"line\">  <span class=\"attr\">behavior:</span>                                   <span class=\"comment\"># ⬇️ 扩缩容行为控制</span></span><br><span class=\"line\">    <span class=\"attr\">scaleUp:</span>                                  <span class=\"comment\"># 扩容策略</span></span><br><span class=\"line\">      <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">30</span>          <span class=\"comment\"># 扩容平滑窗口为 30 秒，防止短时间抖动频繁扩容</span></span><br><span class=\"line\">      <span class=\"attr\">policies:</span>                               <span class=\"comment\"># 扩容速度限制策略</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 按百分比计算</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒内最多扩容 100%</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次扩容速率</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Pods</span>                            <span class=\"comment\"># 按固定 Pod 数量计算</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">4</span>                              <span class=\"comment\"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次扩容速率</span></span><br><span class=\"line\">      <span class=\"attr\">selectPolicy:</span> <span class=\"string\">Max</span>                       <span class=\"comment\"># 如果多个 policy 同时满足，取最大值（更激进的扩容）</span></span><br><span class=\"line\">    <span class=\"attr\">scaleDown:</span>                                <span class=\"comment\"># 缩容策略</span></span><br><span class=\"line\">      <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">300</span>         <span class=\"comment\"># 缩容平滑窗口为 300 秒（5 分钟），避免短时流量降低快速缩容</span></span><br><span class=\"line\">      <span class=\"attr\">policies:</span>                               <span class=\"comment\"># 缩容速度限制策略</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 按百分比缩容</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">30</span>                             <span class=\"comment\"># 每 60 秒最多缩容 30%</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">60</span>                     <span class=\"comment\"># 每 60 秒评估一次缩容速率</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。 K8S官网 Autoscaling k8s简介 Horizontal Pod Autoscaler（HPA） Horizontal Pod Autoscaler（HPA） 简介 Horizontal Pod Autoscaler（缩写为 hpa）基于资源 CPU 利用率自动调整 deployment、replication controller 或者 replica 中 pod 的数量，这有助于您的应用程序进行扩展以满足增长的需求，或在不需要资源时进行缩减，从而释放出节点用于其他应用程序。当您设置目标 CPU 利用率百分比时，HPA 扩展或缩减应用程序来尝试满足该目标。 Kubernetes 本身已经包含了 HPA 的 controller，所以不需要额外的安装或部署。 HPA 需要获取 metrics 信息，metrics 信息需要从 Metrics Server 中获取，所以需要先安装 Metrics Server。 HPA 会周期性(默认15秒)查询目标资源的使用情况，然后和 HPA 中定义的值做比较，并根据比较结果相应的调整 pod 数量。 创建pod时，必须为其设定cpu资源，用于与目标值进行比较，目前最新的v2版本的HPA除了支持CPU的对比，还可以设定其它指标，具体参考HorizontalPodAutoscaler 演练中的“基于多项度量指标和自定义度量指标自动扩缩”。 博主之前写过一篇在aws的eks中使用hpa的文章 AWS-EKS-17--Horizontal Pod Autoscaler（HPA），和在自己搭建 k8s集群 中使用 hpa 基本一致，所以本文不再对重复内容进行赘述，建议读者先阅读 AWS-EKS-17--Horizontal Pod Autoscaler（HPA）。 安装 Metrics Server Kubernetes 的 HPA 是依赖 Metrics API 的，默认并不内置。需要通过 metrics-server 来收集和提供节点/Pod 的资源用量数据（CPU、内存等）。 安装 metrics-server 1234567891011$ curl -L -o metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml$ kubectl apply -f metrics-server.yamlserviceaccount/metrics-server createdclusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader createdclusterrole.rbac.authorization.k8s.io/system:metrics-server createdrolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader createdclusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator createdclusterrolebinding.rbac.authorization.k8s.io/system:metrics-server createdservice/metrics-server createddeployment.apps/metrics-server createdapiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created 部署后发现pod没有运行成功 123456789101112$ k get all -n kube-system -l k8s-app=metrics-serverNAME READY STATUS RESTARTS AGEpod/metrics-server-867d48dc9c-fgdjq 0/1 Running 0 16sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/metrics-server ClusterIP 10.96.91.221 &lt;none&gt; 443/TCP 16sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/metrics-server 0/1 1 0 16sNAME DESIRED CURRENT READY AGEreplicaset.apps/metrics-server-867d48dc9c 1 1 0 16s 检查日志 12345$ k logs deployment.apps/metrics-server -n kube-system## 输出类似于E0703 23:02:38.120831 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.15:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.15 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-worker1&quot;E0703 23:02:38.127774 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.16:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.16 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-worker2&quot;E0703 23:02:38.140583 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.11:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.11 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-master&quot; 意思是 metrics-server 在通过 https://:10250 请求 kubelet 的时候，发现 kubelet 的证书不包含该 IP 的 Subject Alternative Name (SAN)，因此 TLS 校验失败。 解决方案: 添加 --kubelet-insecure-tls 参数，跳过 kubelet 的 TLS 证书校验(metrics-server 本身权限有限，风险可控，kubelet 自签证书维护成本高) 1234567891011kubectl edit deployment metrics-server -n kube-system## 在 args 中添加 --kubelet-insecure-tls spec: containers: - args: - --cert-dir=/tmp - --secure-port=10250 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s - --kubelet-insecure-tls # 添加此行 wq保存后，等一会再次查看所有资源均已正常 查看所有 node 的资源 12345$ k top nodesNAME CPU(cores) CPU(%) MEMORY(bytes) MEMORY(%)k8s-master 216m 10% 1712Mi 44%k8s-worker1 79m 3% 1025Mi 26%k8s-worker2 82m 4% 982Mi 25% 字段 说明 NAME 节点名称，Kubernetes 集群的节点名字。 CPU(cores) 当前节点 CPU 的瞬时使用量，单位是核心数（Core），比如 216m = 0.216 核心。m = millicores，1000m = 1核。 CPU(%) 当前 CPU 使用率，相对于该节点 CPU 总核数的百分比。比如 10% 表示节点 CPU 的 10% 被使用。 MEMORY(bytes) 节点当前使用的内存，单位是字节（例如 1712Mi = 1712 Mebibytes ≈ 1.7 GB）。 MEMORY(%) 节点内存使用率，占总内存的百分比。比如 44% 表示该节点内存使用了 44%。 查看所有 pod 的资源 123456789101112131415161718$ k top pods -ANAMESPACE NAME CPU(cores) MEMORY(bytes)default nginx-5869d7778c-5682r 0m 9Midefault nginx-5869d7778c-thw8f 0m 4Mikube-system calico-kube-controllers-7bfdc5b57c-q5xwp 6m 35Mikube-system calico-node-7pbbq 42m 281Mikube-system calico-node-v4hzr 47m 260Mikube-system calico-node-w47qq 40m 263Mikube-system coredns-674b8bbfcf-2tvld 2m 23Mikube-system coredns-674b8bbfcf-h6kx7 2m 22Mikube-system etcd-k8s-master 27m 85Mikube-system kube-apiserver-k8s-master 49m 404Mikube-system kube-controller-manager-k8s-master 28m 100Mikube-system kube-proxy-nkbns 1m 41Mikube-system kube-proxy-plqw8 1m 25Mikube-system kube-proxy-sbgh6 1m 34Mikube-system kube-scheduler-k8s-master 8m 38Mikube-system metrics-server-56fb9549f4-rtt7n 4m 21Mi 创建 HPA 前面的文章中多次使用 nginx 镜像创建了 deployment，但是都没有配置过资源，为了测试 hpa，需要为其指定资源 1234567891011121314151617181920# 直接修改 deployment，改变 spec.template，Pod 会被重建。保存后立刻生效kubectl edit deployment nginx# 增加资源限制spec: replicas: 1 # 修改副本数位 1，仅改变 replicas，Pod 不会被重建 template: # 修改 template，Pod 会被重建 metadata: labels: app: nginx spec: containers: - name: nginx image: nginx resources: limits: cpu: 500m memory: 500Mi requests: cpu: 200m memory: 200Mi 命令行创建 HPA 123456789101112# 创建了一个叫“hpa-nginx”的 HPA，默认与 deployment 的名称相同，可以用 --name=&#x27;hpa-nginx&#x27; 指定hpa的名称# replicas 变动范围是最小 3，最大 10# 目标cpu利用率为 50%，上面我们设定 CPU request 值为 100m，所以当平均cpu值为 100m 时就会触发 autoscale# 这里说平均cpu，是指所有pod的cpu利用率的平均值$ k autoscale deployment nginx --name=&quot;hpa-nginx&quot; --cpu-percent=50 --min=3 --max=10horizontalpodautoscaler.autoscaling/hpa-nginx autoscaled# 观察，大约 15秒后，hpa-nginx 发现 replicas 值为1，30秒的时候自动扩容到3个，因为我们设置的hpa的replicas最小值为3，并且采集到了cpu使用率$ k get hpa -wNAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGEhpa-nginx Deployment/nginx cpu: &lt;unknown&gt;/50% 3 10 0 0shpa-nginx Deployment/nginx cpu: &lt;unknown&gt;/50% 3 10 1 15shpa-nginx Deployment/nginx cpu: 0%/50% 3 10 3 30s ymal文件创建 HPA 12345678910111213141516171819apiVersion: autoscaling/v2 # api版本，这里设置为 v2kind: HorizontalPodAutoscaler # 资源类型metadata: name: hpa-nginx # hpa资源名称 namespace: default # 命名空间spec: maxReplicas: 10 # 最大副本数 minReplicas: 1 # 最小副本数 metrics: # 指标设定 - type: Resource # 资源类型，可以配置为 Resource/Object/Pods resource: # 资源对象 name: cpu # 资源名称 cpu/memory target: # 目标对象 type: Utilization # 目标类型，可以配置为 Utilization/AverageValue/Value averageUtilization: 50 # 目标值，这里是平均使用率的百分比 scaleTargetRef: # 指定要自动伸缩的资源对象 apiVersion: apps/v1 kind: Deployment # 资源类型为 Deployment name: nginx # 资源名称为 nginx HPA 支持的监控指标类型 类型 字段名 说明 常见用途 Resource resource 基于 Pod 资源使用情况（CPU、内存），最常用 按 CPU 利用率自动扩缩容 Pods pods 基于每个 Pod 的自定义度量指标的平均值，需要第三方监控系统提供，比如 Prometheus 按业务指标（如请求数、队列长度）扩缩容 Object object 基于单个 Kubernetes 对象（如 Service、Ingress）的指标，，比如 Prometheus 按某个对象的指标扩缩容，例如队列长度 Resource 资源指标（CPU/内存） Utilization: 利用率百分比 Utilization 不关心 limits，只看 requests。 如果 resources.requests 没有设置，HPA Utilization 会报错（除非 AverageValue）。 1234567metrics:- type: Resource resource: # 资源 指标 name: cpu # cpu target: type: Utilization # 利用率百分比 averageUtilization: 50 # 50% 当前有 3 个 Pod： Pod CPU 实际使用 CPU requests pod-1 150m 200m pod-2 100m 200m pod-3 50m 200m 合计 400m 600m 平均 400m ÷ 600m × 100% ≈ 66.7% 由于 66.7% &gt; 50%，会扩容；如果小于 50%，HPA 会缩容。 AverageValue: 指定资源使用平均值 1234567metrics:- type: Resource resource: name: memory # 监控资源类型为 memory（内存） target: type: AverageValue # 指标类型为 AverageValue，表示每个 Pod 平均使用多少 averageValue: 400Mi # 目标值：平均每个 Pod 使用 400Mi 内存 假设当前部署了 3 个副本，内存使用情况如下： Pod 当前内存使用 pod-1 450Mi pod-2 400Mi pod-3 300Mi 平均 (450+400+300)/3 = 383.3Mi 因为 383.3Mi &lt; 400Mi，不触发扩容。如果将来平均使用超过 400Mi，HPA 就会扩容，反之缩容。 HPA 扩缩容速度配置 HPA 的扩缩容速度是可以控制的，通过 behavior 字段来自定义扩缩容的速度和策略。 以下是默认策略 1234567891011121314151617181920behavior: scaleUp: # ⬆️ 扩容策略 tolerance: 0.1 # 容忍阈值，默认0.1(10%)，表示每次扩容时，pod使用率超过1.1倍目标值时才会进行扩容 stabilizationWindowSeconds: 0 # 默认0，即增加或减少pod数量后保持不变的时间，单位为秒 policies: - type: Percent # 扩容速度按百分比限制 value: 100 # 每 15 秒最多扩容 100% 的副本数 periodSeconds: 15 # 每 15 秒计算一次是否可以扩容，默认 15 秒 - type: Pods # 按固定 Pod 数量限制扩容速度 value: 4 # 每 15 秒最多扩容 4 个 Pod periodSeconds: 15 # 同样 15 秒计算一次，默认 15 秒 selectPolicy: Max # 多个 policy 同时存在时，取 Percent 和 Pods 的最大值。Min 取最小值 scaleDown: # ⬇️ 缩容策略 # selectPolicy: Disabled # 禁用缩容 stabilizationWindowSeconds: 300 # 默认 300，即增加或减少pod数量后保持不变的时间，单位为秒，防止快速缩容（平滑策略） policies: - type: Percent # 缩容速度按百分比限制 value: 100 # 每 15 秒最多缩容 100% 的副本数 periodSeconds: 15 # 每 15 秒评估一次是否可以缩容 完整的 HPA 配置文件示例(一般情况下，我们无需修改扩缩容速度的配置，默认策略满足大部分场景) 123456789101112131415161718192021222324252627282930313233343536apiVersion: autoscaling/v2 # api版本，使用 v2 版本支持 behavior 扩缩容策略kind: HorizontalPodAutoscaler # 资源类型为 HPAmetadata: name: hpa-nginx # HPA 资源的名称 namespace: default # 命名空间，设置为 defaultspec: maxReplicas: 10 # HPA 自动扩容的最大副本数 minReplicas: 1 # HPA 自动缩容的最小副本数 metrics: # 自动伸缩的指标配置 - type: Resource # 指标类型为 Resource（资源型） resource: # 资源指标对象 name: cpu # 资源名称为 cpu，也可以设置为 memory target: # 目标指标对象 type: Utilization # 指标类型为 Utilization（利用率百分比） averageUtilization: 50 # CPU 平均使用率达到 50% 时进行扩缩容 scaleTargetRef: # HPA 绑定的目标资源对象 apiVersion: apps/v1 kind: Deployment # 目标类型为 Deployment name: nginx # 目标 Deployment 名称为 nginx behavior: # ⬇️ 扩缩容行为控制 scaleUp: # 扩容策略 stabilizationWindowSeconds: 30 # 扩容平滑窗口为 30 秒，防止短时间抖动频繁扩容 policies: # 扩容速度限制策略 - type: Percent # 按百分比计算 value: 100 # 每 15 秒内最多扩容 100% periodSeconds: 15 # 每 15 秒评估一次扩容速率 - type: Pods # 按固定 Pod 数量计算 value: 4 # 每 15 秒最多扩容 4 个 Pod periodSeconds: 15 # 每 15 秒评估一次扩容速率 selectPolicy: Max # 如果多个 policy 同时满足，取最大值（更激进的扩容） scaleDown: # 缩容策略 stabilizationWindowSeconds: 300 # 缩容平滑窗口为 300 秒（5 分钟），避免短时流量降低快速缩容 policies: # 缩容速度限制策略 - type: Percent # 按百分比缩容 value: 30 # 每 60 秒最多缩容 30% periodSeconds: 60 # 每 60 秒评估一次缩容速率","summary":"摘要 本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。 K8S官网 Autoscaling k8s简介 Horizontal Pod Autoscaler（HPA）","date_published":"2025-07-20T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/","url":"https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/","title":"K8S 之 Ingress Nginx","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.github.io/ingress-nginx/\">ingress-nginx 官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/\">ingress-nginx k8s简介</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/\">k8s支持的 ingress controller</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Ingress-简介\">Ingress 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ingress(缩写为 ing) 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由(7层)。 流量路由由 Ingress 资源所定义的规则来控制。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上 Ingress-Nginx 内置了 nginx，由 nginx 其负责接收请求并转发给后端服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/jVrIUP.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"安装-Ingress-Nginx\">安装 Ingress-Nginx</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装时要注意 ingress-nginx 的版本和 Kubernetes 的版本兼容性，参考 Github:<a href=\"https://github.com/kubernetes/ingress-nginx\">ingress-nginx</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>获取对应版本的yaml文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载最新的 v1.13.0 版本，其支持 Kubernetes 1.33 版本</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INGRESS_NGINX_VERSION=v1.13.0</span><br><span class=\"line\">curl -L -o ingress-nginx-controller.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-<span class=\"variable\">$&#123;INGRESS_NGINX_VERSION&#125;</span>/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 ingress-nginx</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意，ingress-nginx 的 <code>service/ingress-nginx-controller</code> 默认使用 LoadBalancer 类型，所以需要先使 k8s 集群支持 LoadBalancer 类型，可以参考 <a href=\"/2025/07/18/k8s-service/\" title=\"K8S 之 Service\">K8S 之 Service</a> 中 LoadBalancer 部分。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f ingress-nginx-controller.yaml</span><br><span class=\"line\">namespace/ingress-nginx created</span><br><span class=\"line\">serviceaccount/ingress-nginx created</span><br><span class=\"line\">serviceaccount/ingress-nginx-admission created</span><br><span class=\"line\">role.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">role.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">configmap/ingress-nginx-controller created</span><br><span class=\"line\">service/ingress-nginx-controller created</span><br><span class=\"line\">service/ingress-nginx-controller-admission created</span><br><span class=\"line\">deployment.apps/ingress-nginx-controller created</span><br><span class=\"line\">job.batch/ingress-nginx-admission-create created</span><br><span class=\"line\">job.batch/ingress-nginx-admission-patch created</span><br><span class=\"line\">ingressclass.networking.k8s.io/nginx created</span><br><span class=\"line\">validatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ingress-nginx资源</span></span><br><span class=\"line\">$ k get all -n ingress-nginx</span><br><span class=\"line\">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/ingress-nginx-controller-95f6586c6-nznwq   1/1     Running   0          2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                      AGE</span><br><span class=\"line\">service/ingress-nginx-controller             LoadBalancer   10.96.112.234   10.211.55.201   80:30168/TCP,443:30600/TCP   2m46s</span><br><span class=\"line\">service/ingress-nginx-controller-admission   ClusterIP      10.96.245.155   &lt;none&gt;          443/TCP                      2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/ingress-nginx-controller   1/1     1            1           2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                                 DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/ingress-nginx-controller-95f6586c6   1         1         1       2m46s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 IngressClass 资源</span></span><br><span class=\"line\">$ k get ingressclasses.networking.k8s.io</span><br><span class=\"line\">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class=\"line\">nginx   k8s.io/ingress-nginx   &lt;none&gt;       14m</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-Ingress-资源\">创建 Ingress 资源</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ingress-demo.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span>                   <span class=\"comment\"># Ingress 资源</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span>             <span class=\"comment\"># Ingress 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>            <span class=\"comment\"># Ingress 所在的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># Ingress 使用的 IngressClass</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span>  <span class=\"comment\"># 转发域名，支持通配符 *.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span>        <span class=\"comment\"># 路径匹配规则, 前缀匹配</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span>                 <span class=\"comment\"># 路径</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span>                <span class=\"comment\"># 后端服务</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span>              <span class=\"comment\"># 声明后端是一个 service</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>         <span class=\"comment\"># service名称，提前创建好 service，类型可以是ClusterIP、NodePort、LoadBalancer任意，推荐ClusterIP，因为使用 ingress 的话，就没必要创建其它类型的 service 了</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span>               <span class=\"comment\"># 端口</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span>        <span class=\"comment\"># service的端口</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 ingress 资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get ing -n ns1</span><br><span class=\"line\">NAME          CLASS   HOSTS                  ADDRESS         PORTS   AGE</span><br><span class=\"line\">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80      80s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问 web-ingress</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将域名 nginx.hanqunfeng.com 解析到 10.211.55.201，如果是内部域名可以通过 hosts 文件添加解析</span></span><br><span class=\"line\"><span class=\"comment\"># 只能通过 nginx.hanqunfeng.com 访问，不能通过 10.211.55.201 访问</span></span><br><span class=\"line\">curl http://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"让-Ingress-支持-HTTPS-访问\">让 Ingress 支持 HTTPS 访问</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建证书，可以在阿里云上申请一个免费的证书</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建 secret</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create secret tls nginx-tls \\</span><br><span class=\"line\">    --key=nginx.hanqunfeng.com.key \\</span><br><span class=\"line\">    --cert=nginx.hanqunfeng.com.pem \\</span><br><span class=\"line\">    -n default</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以通过yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-tls</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">tls.crt:</span> <span class=\"string\">base64</span> <span class=\"string\">编码的证书，而非文件路径</span></span><br><span class=\"line\">  <span class=\"attr\">tls.key:</span> <span class=\"string\">base64</span> <span class=\"string\">编码的私钥，而非文件路径</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">kubernetes.io/tls</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你的 Ingress 资源需要增加 tls 字段，引用一个 Secret 存储的 TLS 证书。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span>                   <span class=\"comment\"># Ingress 资源</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span>             <span class=\"comment\"># Ingress 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>            <span class=\"comment\"># Ingress 所在的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># Ingress 使用的 IngressClass</span></span><br><span class=\"line\">  <span class=\"attr\">tls:</span>                          <span class=\"comment\"># 配置 TLS</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">hosts:</span>                      <span class=\"comment\"># 域名列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nginx.hanqunfeng.com</span>      <span class=\"comment\"># 域名</span></span><br><span class=\"line\">    <span class=\"attr\">secretName:</span> <span class=\"string\">nginx-tls</span>       <span class=\"comment\"># 存放证书的 Secret</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span>  <span class=\"comment\">#转发域名</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span>        <span class=\"comment\"># 路径匹配规则, 前缀匹配</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span>                 <span class=\"comment\"># 路径</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span>                <span class=\"comment\"># 后端服务</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span>              <span class=\"comment\"># service</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>         <span class=\"comment\"># service名称</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span>               <span class=\"comment\"># 端口</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span>        <span class=\"comment\"># service的端口</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新运行ingress</span></span><br><span class=\"line\">k apply -f nginx-ingress.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ingress，此时多了一个 443 端口</span></span><br><span class=\"line\">$ k get ing</span><br><span class=\"line\">NAME          CLASS   HOSTS                  ADDRESS         PORTS     AGE</span><br><span class=\"line\">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80, 443   51s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 访问https，但此时 80 端口访问不了，需要配置 80 端口重定向到 443</span></span><br><span class=\"line\">curl https://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"80端口重定向到443\">80端口重定向到443</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>nginx ingress controller</code>，它内置支持重定向，你可以在 Ingress 上添加 annotation</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class=\"string\">&quot;true&quot;</span>  <span class=\"comment\"># 80 重定向到 443</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整的yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">tls:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">hosts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nginx.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">secretName:</span> <span class=\"string\">nginx-tls</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新运行ingress</span></span><br><span class=\"line\">k apply -f nginx-ingress.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 默认情况下 curl 不会自动跳转，使用浏览器访问会自动重定向，308 表示永久重定向</span></span><br><span class=\"line\">$ curl http://nginx.hanqunfeng.com</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;<span class=\"built_in\">head</span>&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;</span><br><span class=\"line\">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 -L 参数，curl 会自动跳转</span></span><br><span class=\"line\">$ curl -L http://nginx.hanqunfeng.com</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;<span class=\"built_in\">head</span>&gt;</span><br><span class=\"line\">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">html &#123; color-scheme: light dark; &#125;</span><br><span class=\"line\">body &#123; width: 35em; margin: 0 auto;</span><br><span class=\"line\">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class=\"line\">working. Further configuration is required.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For online documentation and support please refer to</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class=\"line\">Commercial support is available at</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;&lt;em&gt;Thank you <span class=\"keyword\">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<h3 id=\"ssl-证书过期怎么办？\">ssl 证书过期怎么办？</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># apply 会直接更新 Secret，而不是删除重建</span></span><br><span class=\"line\">kubectl create secret tls nginx-tls \\</span><br><span class=\"line\">    --key=新的.key \\</span><br><span class=\"line\">    --cert=新的.pem \\</span><br><span class=\"line\">    -n default --dry-run=client -o yaml | kubectl apply -f -</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ingress Controller（如 nginx-ingress）通常会自动监听 Secret 变化，大概 30 秒 ~ 1 分钟内自动热加载新证书，无需重启 Pod。</p>\n</li>\n</ul>\n<h3 id=\"pathType-可以设置哪些值？\">pathType 可以设置哪些值？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes Ingress 的 pathType 字段中，一共可以设置以下三种值</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>pathType 值</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>匹配规则说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Exact</strong></td>\n<td>精确匹配</td>\n<td>路径必须<strong>完全匹配</strong></td>\n</tr>\n<tr>\n<td><strong>Prefix</strong></td>\n<td>前缀匹配</td>\n<td>以指定路径为<strong>前缀</strong>即可匹配</td>\n</tr>\n<tr>\n<td><strong>ImplementationSpecific</strong></td>\n<td>由 Ingress Controller 自己决定</td>\n<td>nginx 常常表现为前缀匹配</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Exact 精确匹配，且区分大小写</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只匹配 http://example.com/foo</span></span><br><span class=\"line\"><span class=\"comment\"># 不会匹配 /foo/abc 或 /foo/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Exact</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Prefix 前缀匹配，且区分大小写</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配所有以 /foo 开头的路径：</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/   # 会忽略尾部的 /</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/abc</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/bar/test</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ImplementationSpecific 控制器自定义（不推荐）</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配规则由 Ingress Controller 决定；</span></span><br><span class=\"line\"><span class=\"comment\"># 在 nginx-ingress 中通常行为类似于 Prefix，但不保证兼容性；</span></span><br><span class=\"line\"><span class=\"comment\"># Kubernetes 官方不推荐生产使用，建议显式使用 Prefix 或 Exact。</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">ImplementationSpecific</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置缺省的-ingressclass\">设置缺省的 ingressclass</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以设置一个缺省的 ingressclass 为默认值，这样，当创建ingress时，如果未指定ingressclass，则使用缺省值</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以通过 kubectl patch 为 ingressclass 直接打上默认标识(通过 k edit ingressclass ingressclass-name 为其添加注解也可以)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 ingressclasses</span></span><br><span class=\"line\">$ k get ingressclasses</span><br><span class=\"line\">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class=\"line\">nginx   k8s.io/ingress-nginx   &lt;none&gt;       3h3m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 nginx 为默认 ingressclass，就是为其加上如下注解</span></span><br><span class=\"line\">$ kubectl patch ingressclass nginx -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;ingressclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ingerss-nginx-应用示例\">ingerss-nginx 应用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同一域名不同路径<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/s1XbqM.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">simple-fanout-example</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                       <span class=\"comment\"># 未指定 ingressClassName ,则使用 上文中设置的默认 ingressClassName</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">foo.bar.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service1</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">4200</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/bar</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service2</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不同域名的服务<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/sBhmbR.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">name-virtual-host-ingress</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">foo.bar.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service1</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">bar.foo.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service2</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令对 ingress 进行修改，修改保存(:wq)后会立刻生效</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit ingress web-ingress</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。 K8S官网 ingress-nginx 官网 ingress-nginx k8s简介 k8s支持的 ingress controller Ingress 简介 Ingress(缩写为 ing) 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由(7层)。 流量路由由 Ingress 资源所定义的规则来控制。 实际上 Ingress-Nginx 内置了 nginx，由 nginx 其负责接收请求并转发给后端服务。 下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service 安装 Ingress-Nginx 安装时要注意 ingress-nginx 的版本和 Kubernetes 的版本兼容性，参考 Github:ingress-nginx。 获取对应版本的yaml文件 123# 下载最新的 v1.13.0 版本，其支持 Kubernetes 1.33 版本export INGRESS_NGINX_VERSION=v1.13.0curl -L -o ingress-nginx-controller.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-$&#123;INGRESS_NGINX_VERSION&#125;/deploy/static/provider/cloud/deploy.yaml 安装 ingress-nginx 这里要注意，ingress-nginx 的 service/ingress-nginx-controller 默认使用 LoadBalancer 类型，所以需要先使 k8s 集群支持 LoadBalancer 类型，可以参考 K8S 之 Service 中 LoadBalancer 部分。 12345678910111213141516171819202122232425262728293031323334353637383940$ kubectl apply -f ingress-nginx-controller.yamlnamespace/ingress-nginx createdserviceaccount/ingress-nginx createdserviceaccount/ingress-nginx-admission createdrole.rbac.authorization.k8s.io/ingress-nginx createdrole.rbac.authorization.k8s.io/ingress-nginx-admission createdclusterrole.rbac.authorization.k8s.io/ingress-nginx createdclusterrole.rbac.authorization.k8s.io/ingress-nginx-admission createdrolebinding.rbac.authorization.k8s.io/ingress-nginx createdrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdconfigmap/ingress-nginx-controller createdservice/ingress-nginx-controller createdservice/ingress-nginx-controller-admission createddeployment.apps/ingress-nginx-controller createdjob.batch/ingress-nginx-admission-create createdjob.batch/ingress-nginx-admission-patch createdingressclass.networking.k8s.io/nginx createdvalidatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission created# 查看ingress-nginx资源$ k get all -n ingress-nginxNAME READY STATUS RESTARTS AGEpod/ingress-nginx-controller-95f6586c6-nznwq 1/1 Running 0 2m46sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/ingress-nginx-controller LoadBalancer 10.96.112.234 10.211.55.201 80:30168/TCP,443:30600/TCP 2m46sservice/ingress-nginx-controller-admission ClusterIP 10.96.245.155 &lt;none&gt; 443/TCP 2m46sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/ingress-nginx-controller 1/1 1 1 2m46sNAME DESIRED CURRENT READY AGEreplicaset.apps/ingress-nginx-controller-95f6586c6 1 1 1 2m46s# 查看 IngressClass 资源$ k get ingressclasses.networking.k8s.ioNAME CONTROLLER PARAMETERS AGEnginx k8s.io/ingress-nginx &lt;none&gt; 14m 创建 Ingress 资源 ingress-demo.yaml 123456789101112131415161718apiVersion: networking.k8s.io/v1kind: Ingress # Ingress 资源metadata: name: web-ingress # Ingress 名称 namespace: default # Ingress 所在的命名空间spec: ingressClassName: nginx # Ingress 使用的 IngressClass rules: - host: nginx.hanqunfeng.com # 转发域名，支持通配符 *.hanqunfeng.com http: paths: - pathType: Prefix # 路径匹配规则, 前缀匹配 path: / # 路径 backend: # 后端服务 service: # 声明后端是一个 service name: nginx # service名称，提前创建好 service，类型可以是ClusterIP、NodePort、LoadBalancer任意，推荐ClusterIP，因为使用 ingress 的话，就没必要创建其它类型的 service 了 port: # 端口 number: 80 # service的端口 查看 ingress 资源 123$ k get ing -n ns1NAME CLASS HOSTS ADDRESS PORTS AGEweb-ingress nginx nginx.hanqunfeng.com 10.211.55.201 80 80s 访问 web-ingress 123# 将域名 nginx.hanqunfeng.com 解析到 10.211.55.201，如果是内部域名可以通过 hosts 文件添加解析# 只能通过 nginx.hanqunfeng.com 访问，不能通过 10.211.55.201 访问curl http://nginx.hanqunfeng.com 让 Ingress 支持 HTTPS 访问 创建证书，可以在阿里云上申请一个免费的证书 创建 secret 1234kubectl create secret tls nginx-tls \\ --key=nginx.hanqunfeng.com.key \\ --cert=nginx.hanqunfeng.com.pem \\ -n default 也可以通过yaml创建 123456789apiVersion: v1kind: Secretmetadata: name: nginx-tls namespace: defaultdata: tls.crt: base64 编码的证书，而非文件路径 tls.key: base64 编码的私钥，而非文件路径type: kubernetes.io/tls 你的 Ingress 资源需要增加 tls 字段，引用一个 Secret 存储的 TLS 证书。 12345678910111213141516171819202122apiVersion: networking.k8s.io/v1kind: Ingress # Ingress 资源metadata: name: web-ingress # Ingress 名称 namespace: default # Ingress 所在的命名空间spec: ingressClassName: nginx # Ingress 使用的 IngressClass tls: # 配置 TLS - hosts: # 域名列表 - nginx.hanqunfeng.com # 域名 secretName: nginx-tls # 存放证书的 Secret rules: - host: nginx.hanqunfeng.com #转发域名 http: paths: - pathType: Prefix # 路径匹配规则, 前缀匹配 path: / # 路径 backend: # 后端服务 service: # service name: nginx # service名称 port: # 端口 number: 80 # service的端口 12345678910# 重新运行ingressk apply -f nginx-ingress.yaml# 查看ingress，此时多了一个 443 端口$ k get ingNAME CLASS HOSTS ADDRESS PORTS AGEweb-ingress nginx nginx.hanqunfeng.com 10.211.55.201 80, 443 51s# 访问https，但此时 80 端口访问不了，需要配置 80 端口重定向到 443curl https://nginx.hanqunfeng.com 80端口重定向到443 nginx ingress controller，它内置支持重定向，你可以在 Ingress 上添加 annotation 123metadata: annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot; # 80 重定向到 443 完整的yaml 123456789101112131415161718192021222324apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: web-ingress namespace: default annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;spec: ingressClassName: nginx tls: - hosts: - nginx.hanqunfeng.com secretName: nginx-tls rules: - host: nginx.hanqunfeng.com http: paths: - pathType: Prefix path: / backend: service: name: nginx port: number: 80 访问测试 1234567891011121314151617181920212223242526272829303132333435363738# 重新运行ingressk apply -f nginx-ingress.yaml# 默认情况下 curl 不会自动跳转，使用浏览器访问会自动重定向，308 表示永久重定向$ curl http://nginx.hanqunfeng.com&lt;html&gt;&lt;head&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;# 添加 -L 参数，curl 会自动跳转$ curl -L http://nginx.hanqunfeng.com&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 后记 ssl 证书过期怎么办？ 12345# apply 会直接更新 Secret，而不是删除重建kubectl create secret tls nginx-tls \\ --key=新的.key \\ --cert=新的.pem \\ -n default --dry-run=client -o yaml | kubectl apply -f - Ingress Controller（如 nginx-ingress）通常会自动监听 Secret 变化，大概 30 秒 ~ 1 分钟内自动热加载新证书，无需重启 Pod。 pathType 可以设置哪些值？ 在 Kubernetes Ingress 的 pathType 字段中，一共可以设置以下三种值 pathType 值 含义 匹配规则说明 Exact 精确匹配 路径必须完全匹配 Prefix 前缀匹配 以指定路径为前缀即可匹配 ImplementationSpecific 由 Ingress Controller 自己决定 nginx 常常表现为前缀匹配 Exact 精确匹配，且区分大小写 1234# 只匹配 http://example.com/foo# 不会匹配 /foo/abc 或 /foo/- pathType: Exact path: /foo Prefix 前缀匹配，且区分大小写 1234567# 匹配所有以 /foo 开头的路径：# /foo# /foo/ # 会忽略尾部的 /# /foo/abc# /foo/bar/test- pathType: Prefix path: /foo ImplementationSpecific 控制器自定义（不推荐） 12345# 匹配规则由 Ingress Controller 决定；# 在 nginx-ingress 中通常行为类似于 Prefix，但不保证兼容性；# Kubernetes 官方不推荐生产使用，建议显式使用 Prefix 或 Exact。- pathType: ImplementationSpecific path: /foo 设置缺省的 ingressclass 我们可以设置一个缺省的 ingressclass 为默认值，这样，当创建ingress时，如果未指定ingressclass，则使用缺省值 可以通过 kubectl patch 为 ingressclass 直接打上默认标识(通过 k edit ingressclass ingressclass-name 为其添加注解也可以) 1234567# 查看 ingressclasses$ k get ingressclassesNAME CONTROLLER PARAMETERS AGEnginx k8s.io/ingress-nginx &lt;none&gt; 3h3m# 设置 nginx 为默认 ingressclass，就是为其加上如下注解$ kubectl patch ingressclass nginx -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;ingressclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27; ingerss-nginx 应用示例 同一域名不同路径 1234567891011121314151617181920212223apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: simple-fanout-examplespec: # 未指定 ingressClassName ,则使用 上文中设置的默认 ingressClassName rules: - host: foo.bar.com http: paths: - path: /foo pathType: Prefix backend: service: name: service1 port: number: 4200 - path: /bar pathType: Prefix backend: service: name: service2 port: number: 8080 不同域名的服务 1234567891011121314151617181920212223242526apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: name-virtual-host-ingressspec: rules: - host: foo.bar.com http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: service1 port: number: 80 - host: bar.foo.com http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: service2 port: number: 80 通过如下命令对 ingress 进行修改，修改保存(:wq)后会立刻生效 1kubectl edit ingress web-ingress","summary":"摘要 本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。 K8S官网 ingress-nginx 官网 ingress-nginx k8s简介 k8s支持的 ingress controller","date_published":"2025-07-19T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/18/k8s-service/","url":"https://blog.hanqunfeng.com/2025/07/18/k8s-service/","title":"K8S 之 Service","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/\">k8s Service 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Service-介绍\">Service 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Service(缩写为 svc)是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service允许您的应用程序接收流量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service也可以用在ServiceSpec标记type的方式暴露，type类型如下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。</li>\n<li class=\"lvl-4\">NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用 <NodeIP>:<NodePort> 从集群外部访问Service。是ClusterIP的超集。</li>\n<li class=\"lvl-4\">LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。</li>\n<li class=\"lvl-4\">ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"创建Service\">创建Service</h2>\n<h3 id=\"ClusterIP\">ClusterIP</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只能在集群内部访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先创建deployment，此时会为每个pod添加一个label app=nginx</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建service，，将deployment的pod暴露出来，暴露类型为ClusterIP</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=ClusterIP --port=80</span><br><span class=\"line\">$ kubectl get svc nginx</span><br><span class=\"line\">NAME    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">nginx   ClusterIP   10.96.14.90   &lt;none&gt;        80/TCP    60s</span><br></pre></td></tr></table></figure>\n<h3 id=\"NodePort\">NodePort</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暴露宿主机的端口，供外部访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建service，将deployment的pod暴露出来，暴露类型为NodePort</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=NodePort --port=80</span><br><span class=\"line\"><span class=\"comment\"># 查看service，此时可以看到service的端口和节点的端口，与 ClusterIP 的区别就是是否暴露在节点上的端口</span></span><br><span class=\"line\">$ kubectl get svc nginx</span><br><span class=\"line\">NAME    TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class=\"line\">nginx   NodePort   10.96.7.8    &lt;none&gt;        80:32691/TCP   31s</span><br></pre></td></tr></table></figure>\n<h3 id=\"yaml文件创建service\">yaml文件创建service</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml文件格式</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>      <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>       <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>           <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># service名称</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>               <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>            <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span>        <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>   <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># node暴露的端口，service类型为 NodePort 时使用，默认范围在 30000-32767 之间</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>         <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>      <span class=\"comment\"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span>    <span class=\"comment\"># service类型</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有个问题需要注意，service 默认是通过<code>标签</code>来匹配pod的，所以创建service的时候，一定要保证pod的标签是存在的，否则service无法匹配pod，另外虽然我们通过命令行创建service时是通过<code>kubectl expose deployment nginx --type=NodePort --port=80</code>创建的，但也并不表示service只会匹配这个deployment创建的pod，而是会匹配所有具有指定标签的pod（app=nginx）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取service的 selector</span></span><br><span class=\"line\">$ k get svc -owide</span><br><span class=\"line\">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE    SELECTOR</span><br><span class=\"line\">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        4d5h   &lt;none&gt;</span><br><span class=\"line\">nginx        NodePort    10.96.9.77   &lt;none&gt;        80:30080/TCP   8s     app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里有个名称为 kubernetes 的 service，其作用是为了方便集群内部的 Pod 调用 API Server 的统一入口</span></span><br><span class=\"line\"><span class=\"comment\"># 无论 API Server 实际运行在哪个节点哪个 IP，集群内部只要访问如下地址就能访问 API Server。</span></span><br><span class=\"line\"><span class=\"comment\"># https://kubernetes.default.svc</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># https://10.96.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 这个 Service 是 系统自带的，不建议删除或修改。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ExternalName\">ExternalName</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以将其它 namespace 的 service 别名到 当前 namespace，这样访问 service 时就不需要加上命名空间名称了</p>\n</li>\n<li class=\"lvl-2\">\n<p>ExternalName Service 是纯 DNS CNAME 映射，我们不经可以映射集群内容服务，也可以映射集群外部服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>原先的 service 访问方式：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在不同命名空间下创建service</span></span><br><span class=\"line\"><span class=\"comment\"># 创建两个命名空间以及下面的资源</span></span><br><span class=\"line\"><span class=\"comment\">## ns1</span></span><br><span class=\"line\">kubectl create namespace ns1</span><br><span class=\"line\">kubectl create deployment alpine-demo -n ns1 --image=alpine/curl --replicas=1 -- /bin/sh -c <span class=\"string\">&quot;sleep infinity&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## ns2</span></span><br><span class=\"line\">kubectl create namespace ns2</span><br><span class=\"line\">kubectl create deployment nginx-demo -n ns2 --image=nginx --replicas=1</span><br><span class=\"line\">kubectl expose deployment nginx-demo -n ns2 --<span class=\"built_in\">type</span>=ClusterIP --port=80 --name=nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 ns1 中的 pod 访问 ns2 中的 nginx-service</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class=\"line\">curl nginx-service.ns2.svc.cluster.local</span><br><span class=\"line\">curl nginx-service.ns2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ExternalName 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 ns1 中创建 externalName 类型的 service，--external-name 指定 ns2 中的 nginx-service</span></span><br><span class=\"line\">kubectl create service externalname nginx-service -n ns1 --external-name=nginx-service.ns2.svc.cluster.local</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以通过 yaml 创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-service</span>                               <span class=\"comment\"># service 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                                    <span class=\"comment\"># 指定命名空间 为 ns1</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">externalName:</span> <span class=\"string\">nginx-service.ns2.svc.cluster.local</span> <span class=\"comment\"># 指定外部服务名，比如 www.baidu.com</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">ExternalName</span>                                <span class=\"comment\"># 指定为 ExternalName 类型</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                                         <span class=\"comment\"># 不需要配置 selector</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx-service</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get svc -n ns1</span><br><span class=\"line\">NAME            TYPE           CLUSTER-IP   EXTERNAL-IP                           PORT(S)   AGE</span><br><span class=\"line\">nginx-service   ExternalName   &lt;none&gt;       nginx-service.ns2.svc.cluster.local   &lt;none&gt;    16s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时再次进入 ns1 中的 pod 访问 ns2 中的 nginx-service 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class=\"line\"><span class=\"comment\"># 此时就不需要加上 ns2 的 namespace 了</span></span><br><span class=\"line\">curl nginx-service</span><br></pre></td></tr></table></figure>\n<h3 id=\"LoadBalancer\">LoadBalancer</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LoadBalancer 是 Kubernetes Service 的一种类型，用于自动申请一个云厂商的负载均衡器（如 AWS ELB、GCP LB、阿里云 SLB），将外部流量转发到 Kubernetes 集群内部的 Pod 上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在私有云上，需要借助第三方负载均衡器来实现，比如 <a href=\"https://metallb.io\">MetalLB</a>，<a href=\"https://github.com/metallb/metallb\">github</a></p>\n</li>\n</ul>\n<h4 id=\"安装-MetallB\">安装 MetallB</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果您在IPVS模式下使用kube代理，从Kubernetes v1.14.2开始，您必须启用严格的ARP模式。请注意，如果您使用kube-router作为服务代理，则不需要这个，因为它默认启用了严格的ARP。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看将要产生的变更，如果有变更则返回非零状态码</span></span><br><span class=\"line\">kubectl get configmap kube-proxy -n kube-system -o yaml | \\</span><br><span class=\"line\">sed -e <span class=\"string\">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \\</span><br><span class=\"line\">kubectl diff -f - -n kube-system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际应用变更，只有发生错误时才返回非零状态码</span></span><br><span class=\"line\">kubectl get configmap kube-proxy -n kube-system -o yaml | \\</span><br><span class=\"line\">sed -e <span class=\"string\">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \\</span><br><span class=\"line\">kubectl apply -f - -n kube-system</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装MetalLB</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> METLB_VERSION=v0.15.2</span><br><span class=\"line\">curl -L -o metallb.yaml https://raw.githubusercontent.com/metallb/metallb/<span class=\"variable\">$&#123;METLB_VERSION&#125;</span>/config/manifests/metallb-native.yaml</span><br><span class=\"line\">kubectl apply -f metallb.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看MetalLB资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get all -n metallb-system -owide</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS      AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/controller-58fdf44d87-bsp4z   1/1     Running   0             4m13s   10.244.194.104   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-sjvq5                 1/1     Running   0             4m13s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-srpp4                 1/1     Running   0             4m13s   10.211.55.16     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-tbnls                 1/1     Running   2 (98s ago)   4m13s   10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class=\"line\">service/metallb-webhook-service   ClusterIP   10.96.233.8   &lt;none&gt;        443/TCP   4m14s   component=controller</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS   IMAGES                            SELECTOR</span><br><span class=\"line\">daemonset.apps/speaker   3         3         3       3            3           kubernetes.io/os=linux   4m13s   speaker      quay.io/metallb/speaker:v0.15.2   app=metallb,component=speaker</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                         READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class=\"line\">deployment.apps/controller   1/1     1            1           4m14s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                    DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class=\"line\">replicaset.apps/controller-58fdf44d87   1         1         1       4m13s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller,pod-template-hash=58fdf44d87</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置地址池:metallb-pool.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">metallb.io/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">IPAddressPool</span>                 <span class=\"comment\"># 地址池类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">metallb-pool</span>                <span class=\"comment\"># 地址池名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">metallb-system</span>         <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">addresses:</span>                        <span class=\"comment\"># 配置地址池</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.200</span><span class=\"number\">-10.211</span><span class=\"number\">.55</span><span class=\"number\">.250</span>     <span class=\"comment\"># 与 节点 相同的网段，负载均衡器可以分配的IP范围</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f metallb-pool.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置地址池的二级公告:metallb-advertisement.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">metallb.io/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">L2Advertisement</span>               <span class=\"comment\"># 地址池二级公告类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">metallb-advertisement</span>       <span class=\"comment\"># 公告名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">metallb-system</span>         <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ipAddressPools:</span>                   <span class=\"comment\"># 地址池名称列表，只有被公告的地址池才会被使用</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">metallb-pool</span>                    <span class=\"comment\"># 地址池名称</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f metallb-advertisement.yaml</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建-LoadBalancer-类型的-service\">创建 LoadBalancer 类型的 service</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>metallb-service.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                     <span class=\"comment\"># 命名空间，默认为 default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>                        <span class=\"comment\"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br><span class=\"line\"><span class=\"string\">---</span>                                  <span class=\"comment\"># 分割线</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                       <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>                        <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                            <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># service名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                     <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>                             <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span>                         <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>                    <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>                   <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">LoadBalancer</span>                 <span class=\"comment\"># service类型</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k apply -f metallb-service.yaml</span><br><span class=\"line\">deployment.apps/nginx created</span><br><span class=\"line\">service/nginx created</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以看到 service 的类型为 LoadBalancer，并分配了 EXTERNAL-IP，这里还开放了nodePort 30613</span></span><br><span class=\"line\">$ kubectl get svc -n ns1</span><br><span class=\"line\">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE</span><br><span class=\"line\">nginx        LoadBalancer   10.96.210.244   10.211.55.200   80:30613/TCP   52s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 service 的 port 访问，这里是 80</span></span><br><span class=\"line\">curl 10.211.55.200</span><br><span class=\"line\"><span class=\"comment\"># 同样可以基于 nodeIP+nodePort 访问</span></span><br><span class=\"line\">curl 10.211.55.11:30613</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问service，轮询pod\">访问service，轮询pod</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 在集群内</span></span><br><span class=\"line\"><span class=\"comment\"># 在相同的 namespace 中，可以通过 serviceName 直接访问</span></span><br><span class=\"line\">curl nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以通过 CLUSTER-IP 访问</span></span><br><span class=\"line\">curl 10.96.9.77</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，比如本示例为</span></span><br><span class=\"line\">curl nginx.default</span><br><span class=\"line\">curl nginx.default.svc.cluster.local</span><br><span class=\"line\"><span class=\"comment\"># 这是因为在创建 service前，我们是不知道 service 的 IP 地址的，所以在其它pod中就可以预先使用 &lt;serviceName&gt;.&lt;namespace&gt; 占位，k8s会自动将其解析为 service 的 CLUSTER-IP</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 在集群外</span></span><br><span class=\"line\"><span class=\"comment\"># 通过 NODE-IP:NODE-PORT 访问</span></span><br><span class=\"line\">curl 10.211.55.16:30080</span><br></pre></td></tr></table></figure>\n<h2 id=\"管理service\">管理service</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看service</span></span><br><span class=\"line\">kubectl get svc</span><br><span class=\"line\"><span class=\"comment\"># 查看指定namespace下的service</span></span><br><span class=\"line\">kubectl get svc -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看全部service</span></span><br><span class=\"line\">kubectl get svc -A</span><br><span class=\"line\"><span class=\"comment\"># 查看service详情</span></span><br><span class=\"line\">kubectl get svc nginx -o yaml</span><br><span class=\"line\">kubectl describe svc nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\">k logs svc/nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编辑service，保存（:wq）后生效，不需要额外 apply 或 restart</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit svc nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete svc nginx</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Service 介绍 Service 介绍 Service(缩写为 svc)是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。 尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。 Service允许您的应用程序接收流量。 Service也可以用在ServiceSpec标记type的方式暴露，type类型如下： ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。 NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用 : 从集群外部访问Service。是ClusterIP的超集。 LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。 ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。 创建Service ClusterIP 只能在集群内部访问 12345678# 先创建deployment，此时会为每个pod添加一个label app=nginxkubectl create deployment nginx --image=nginx --replicas=2# 创建service，，将deployment的pod暴露出来，暴露类型为ClusterIPkubectl expose deployment nginx --type=ClusterIP --port=80$ kubectl get svc nginxNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx ClusterIP 10.96.14.90 &lt;none&gt; 80/TCP 60s NodePort 暴露宿主机的端口，供外部访问 123456# 创建service，将deployment的pod暴露出来，暴露类型为NodePortkubectl expose deployment nginx --type=NodePort --port=80# 查看service，此时可以看到service的端口和节点的端口，与 ClusterIP 的区别就是是否暴露在节点上的端口$ kubectl get svc nginxNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx NodePort 10.96.7.8 &lt;none&gt; 80:32691/TCP 31s yaml文件创建service yaml文件格式 12345678910111213apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: nginx # service名称spec: # 配置 ports: # 端口 - port: 80 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 80 # 容器端口, pod的端口，这个必须与实际容器端口一致 nodePort: 30080 # node暴露的端口，service类型为 NodePort 时使用，默认范围在 30000-32767 之间 selector: # 选择器 app: nginx # pod的标签，即匹配pod的标签 app=nginx type: NodePort # service类型 这里有个问题需要注意，service 默认是通过标签来匹配pod的，所以创建service的时候，一定要保证pod的标签是存在的，否则service无法匹配pod，另外虽然我们通过命令行创建service时是通过kubectl expose deployment nginx --type=NodePort --port=80创建的，但也并不表示service只会匹配这个deployment创建的pod，而是会匹配所有具有指定标签的pod（app=nginx）。 123456789101112# 获取service的 selector$ k get svc -owideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 4d5h &lt;none&gt;nginx NodePort 10.96.9.77 &lt;none&gt; 80:30080/TCP 8s app=nginx# 这里有个名称为 kubernetes 的 service，其作用是为了方便集群内部的 Pod 调用 API Server 的统一入口# 无论 API Server 实际运行在哪个节点哪个 IP，集群内部只要访问如下地址就能访问 API Server。# https://kubernetes.default.svc# 或者# https://10.96.0.1# 这个 Service 是 系统自带的，不建议删除或修改。 ExternalName 可以将其它 namespace 的 service 别名到 当前 namespace，这样访问 service 时就不需要加上命名空间名称了 ExternalName Service 是纯 DNS CNAME 映射，我们不经可以映射集群内容服务，也可以映射集群外部服务。 原先的 service 访问方式： 123456789101112131415# 在不同命名空间下创建service# 创建两个命名空间以及下面的资源## ns1kubectl create namespace ns1kubectl create deployment alpine-demo -n ns1 --image=alpine/curl --replicas=1 -- /bin/sh -c &quot;sleep infinity&quot;## ns2kubectl create namespace ns2kubectl create deployment nginx-demo -n ns2 --image=nginx --replicas=1kubectl expose deployment nginx-demo -n ns2 --type=ClusterIP --port=80 --name=nginx-service# 进入 ns1 中的 pod 访问 ns2 中的 nginx-servicekubectl exec -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/shcurl nginx-service.ns2.svc.cluster.localcurl nginx-service.ns2 ExternalName 访问 12# 在 ns1 中创建 externalName 类型的 service，--external-name 指定 ns2 中的 nginx-servicekubectl create service externalname nginx-service -n ns1 --external-name=nginx-service.ns2.svc.cluster.local 也可以通过 yaml 创建 12345678910apiVersion: v1kind: Servicemetadata: name: nginx-service # service 名称 namespace: ns1 # 指定命名空间 为 ns1spec: externalName: nginx-service.ns2.svc.cluster.local # 指定外部服务名，比如 www.baidu.com type: ExternalName # 指定为 ExternalName 类型 selector: # 不需要配置 selector app: nginx-service 查看 service 123$ k get svc -n ns1NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx-service ExternalName &lt;none&gt; nginx-service.ns2.svc.cluster.local &lt;none&gt; 16s 此时再次进入 ns1 中的 pod 访问 ns2 中的 nginx-service 服务 123kubectl exec -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh# 此时就不需要加上 ns2 的 namespace 了curl nginx-service LoadBalancer LoadBalancer 是 Kubernetes Service 的一种类型，用于自动申请一个云厂商的负载均衡器（如 AWS ELB、GCP LB、阿里云 SLB），将外部流量转发到 Kubernetes 集群内部的 Pod 上。 在私有云上，需要借助第三方负载均衡器来实现，比如 MetalLB，github 安装 MetallB 如果您在IPVS模式下使用kube代理，从Kubernetes v1.14.2开始，您必须启用严格的ARP模式。请注意，如果您使用kube-router作为服务代理，则不需要这个，因为它默认启用了严格的ARP。 123456789# 查看将要产生的变更，如果有变更则返回非零状态码kubectl get configmap kube-proxy -n kube-system -o yaml | \\sed -e &quot;s/strictARP: false/strictARP: true/&quot; | \\kubectl diff -f - -n kube-system# 实际应用变更，只有发生错误时才返回非零状态码kubectl get configmap kube-proxy -n kube-system -o yaml | \\sed -e &quot;s/strictARP: false/strictARP: true/&quot; | \\kubectl apply -f - -n kube-system 安装MetalLB 123export METLB_VERSION=v0.15.2curl -L -o metallb.yaml https://raw.githubusercontent.com/metallb/metallb/$&#123;METLB_VERSION&#125;/config/manifests/metallb-native.yamlkubectl apply -f metallb.yaml 查看MetalLB资源 123456789101112131415161718$ k get all -n metallb-system -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/controller-58fdf44d87-bsp4z 1/1 Running 0 4m13s 10.244.194.104 k8s-worker1 &lt;none&gt; &lt;none&gt;pod/speaker-sjvq5 1/1 Running 0 4m13s 10.211.55.15 k8s-worker1 &lt;none&gt; &lt;none&gt;pod/speaker-srpp4 1/1 Running 0 4m13s 10.211.55.16 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/speaker-tbnls 1/1 Running 2 (98s ago) 4m13s 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice/metallb-webhook-service ClusterIP 10.96.233.8 &lt;none&gt; 443/TCP 4m14s component=controllerNAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/speaker 3 3 3 3 3 kubernetes.io/os=linux 4m13s speaker quay.io/metallb/speaker:v0.15.2 app=metallb,component=speakerNAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdeployment.apps/controller 1/1 1 1 4m14s controller quay.io/metallb/controller:v0.15.2 app=metallb,component=controllerNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORreplicaset.apps/controller-58fdf44d87 1 1 1 4m13s controller quay.io/metallb/controller:v0.15.2 app=metallb,component=controller,pod-template-hash=58fdf44d87 配置地址池:metallb-pool.yaml 12345678apiVersion: metallb.io/v1beta1kind: IPAddressPool # 地址池类型metadata: name: metallb-pool # 地址池名称 namespace: metallb-system # 命名空间spec: addresses: # 配置地址池 - 10.211.55.200-10.211.55.250 # 与 节点 相同的网段，负载均衡器可以分配的IP范围 1kubectl apply -f metallb-pool.yaml 配置地址池的二级公告:metallb-advertisement.yaml 12345678apiVersion: metallb.io/v1beta1kind: L2Advertisement # 地址池二级公告类型metadata: name: metallb-advertisement # 公告名称 namespace: metallb-system # 命名空间spec: ipAddressPools: # 地址池名称列表，只有被公告的地址池才会被使用 - metallb-pool # 地址池名称 1kubectl apply -f metallb-advertisement.yaml 创建 LoadBalancer 类型的 service metallb-service.yaml 12345678910111213141516171819202122232425262728293031323334apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源kind: Deployment # Kubernetes 资源类型，这里是部署（Deployment）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下） namespace: ns1 # 命名空间，默认为 defaultspec: # 配置项 replicas: 3 # 副本数，表示希望运行多少个 Pod 实例 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配） template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称--- # 分割线apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: nginx # service名称 namespace: ns1 # 命名空间spec: # 配置 ports: # 端口 - port: 80 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 80 # 容器端口, pod的端口，这个必须与实际容器端口一致 selector: # 选择器 app: nginx # pod的标签，即匹配pod的标签 app=nginx type: LoadBalancer # service类型 123$ k apply -f metallb-service.yamldeployment.apps/nginx createdservice/nginx created 查看service 1234# 可以看到 service 的类型为 LoadBalancer，并分配了 EXTERNAL-IP，这里还开放了nodePort 30613$ kubectl get svc -n ns1NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx LoadBalancer 10.96.210.244 10.211.55.200 80:30613/TCP 52s 访问service 1234# 通过 service 的 port 访问，这里是 80curl 10.211.55.200# 同样可以基于 nodeIP+nodePort 访问curl 10.211.55.11:30613 访问service，轮询pod 12345678910111213141516## 在集群内# 在相同的 namespace 中，可以通过 serviceName 直接访问curl nginx# 也可以通过 CLUSTER-IP 访问curl 10.96.9.77# 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，比如本示例为curl nginx.defaultcurl nginx.default.svc.cluster.local# 这是因为在创建 service前，我们是不知道 service 的 IP 地址的，所以在其它pod中就可以预先使用 &lt;serviceName&gt;.&lt;namespace&gt; 占位，k8s会自动将其解析为 service 的 CLUSTER-IP## 在集群外# 通过 NODE-IP:NODE-PORT 访问curl 10.211.55.16:30080 管理service 查看service 123456789101112# 查看servicekubectl get svc# 查看指定namespace下的servicekubectl get svc -n kube-system# 查看全部servicekubectl get svc -A# 查看service详情kubectl get svc nginx -o yamlkubectl describe svc nginx# 查看日志k logs svc/nginx 编辑service，保存（:wq）后生效，不需要额外 apply 或 restart 1kubectl edit svc nginx 删除service 1kubectl delete svc nginx","summary":"摘要 本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Service 介绍","date_published":"2025-07-18T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/17/acme/","url":"https://blog.hanqunfeng.com/2025/07/17/acme/","title":"acme.sh 自动申请并续签 SSL 证书的工具","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍自动申请并续签 SSL 证书的工具: <a href=\"http://acme.sh\">acme.sh</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/acmesh-official/acme.sh\">acme.sh Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"acme-sh-介绍\"><a href=\"http://acme.sh\">acme.sh</a> 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 acme 协议，可以从 ZeroSSL，Let’s Encrypt 等 CA 生成免费的证书。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：shell脚本方式，几乎无依赖，极简，适合不想安装Python环境的人。</p>\n</li>\n<li class=\"lvl-2\">\n<p>特点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">纯 Shell 脚本，单文件运行</li>\n<li class=\"lvl-4\">支持 100+ DNS API 自动续签（如 Cloudflare、阿里云、腾讯云等）</li>\n<li class=\"lvl-4\">支持通配符证书</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"acme-sh-安装\"><a href=\"http://acme.sh\">acme.sh</a> 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需要先安装 crontab</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 crontab</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install cronie -y</span><br><span class=\"line\"><span class=\"comment\"># 启动 crond</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now crond</span><br><span class=\"line\"><span class=\"comment\"># 查看 crond 状态</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status crond</span><br><span class=\"line\"><span class=\"comment\"># 查看 crontab 是否正常</span></span><br><span class=\"line\">crontab -l</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 <a href=\"http://acme.sh\">acme.sh</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装成功后会自动安装到 ~/.acme.sh/ 目录下，证书也会生成在该目录下</span></span><br><span class=\"line\">curl https://get.acme.sh | sh -s email=qunfeng_han@aliyun.com</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装成功后会自动在 crontab 中添加了定时任务，每天检查一次证书是否到达下次更新日期，如果到期则自动更新</span></span><br><span class=\"line\"><span class=\"comment\"># 证书有效期默认为 90 天，还剩 30 天时会触发自动更新</span></span><br><span class=\"line\">crontab -l</span><br><span class=\"line\"><span class=\"comment\"># 输出类似于 以下内容</span></span><br><span class=\"line\">48 1 * * * <span class=\"string\">&quot;/root/.acme.sh&quot;</span>/acme.sh --cron --home <span class=\"string\">&quot;/root/.acme.sh&quot;</span> &gt; /dev/null</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">acme.sh -h</span><br><span class=\"line\"><span class=\"comment\"># 查看版本</span></span><br><span class=\"line\">acme.sh -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"升级-acme-sh\">升级 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 升级 acme.sh 到最新版</span></span><br><span class=\"line\">acme.sh --upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启自动升级</span></span><br><span class=\"line\">acme.sh --upgrade --auto-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以随时关闭自动更新</span></span><br><span class=\"line\">acme.sh --upgrade --auto-upgrade  0</span><br></pre></td></tr></table></figure>\n<h2 id=\"卸载-acme-sh\">卸载 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --uninstall</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf ~/.acme.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书\">生成证书</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 acme 协议支持的所有验证协议。</p>\n</li>\n<li class=\"lvl-2\">\n<p>证书创建后会保存在 ~/.acme.sh/目录下，比如我的域名是 <code>acme.hanqunfeng.com</code>，则证书保存在 <code>~/.acme.sh/acme.hanqunfeng.com_ecc/</code>目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建证书时一般有两种方式验证: HTTP 和 DNS 验证。</p>\n</li>\n</ul>\n<h3 id=\"HTTP-验证\">HTTP 验证</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只支持单个子域名的证书生成，不支持通配符域名</p>\n</li>\n<li class=\"lvl-2\">\n<p>需要提前将域名解析到本机的IP地址</p>\n</li>\n</ul>\n<h4 id=\"直接签发\">直接签发</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只需要指定域名，并指定域名所在的网站根目录. <a href=\"http://acme.sh\">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d 指定域名，可以添加多个，--webroot 指定网站根目录</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --server 指定 acme.sh 使用的 CA 服务商为 Let&#x27;s Encrypt，默认使用 ZeroSSL</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/ --server letsencrypt</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-Nginx-Apache-模式\">使用 Nginx/Apache 模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你用的 Nginx/Apache 服务器，或者反代，<a href=\"http://acme.sh\">acme.sh</a> 还可以智能的从 Nginx/Apache 的配置中自动完成验证，你不需要指定网站根目录</p>\n</li>\n<li class=\"lvl-2\">\n<p>nginx 或 httpd 命令要在系统Path中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d 域名，可以添加多个, --nginx 告诉 acme.sh 使用 Nginx 模式</span></span><br><span class=\"line\">acme.sh --issue --nginx -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br><span class=\"line\"><span class=\"comment\"># -d 域名，可以添加多个, --apache 告诉 acme.sh 使用 Apache 模式</span></span><br><span class=\"line\">acme.sh --issue --apache -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用独立服务模式\">使用独立服务模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 <a href=\"http://acme.sh\">acme.sh</a> 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证</p>\n</li>\n<li class=\"lvl-2\">\n<p>需要先安装 socat 命令，socat 常用于临时开启 TCP/UDP 监听端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install socat -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成证书，要求80端口空闲，否则会失败</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --standalone 独立服务模式</span></span><br><span class=\"line\">acme.sh --issue --standalone -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"DNS-验证\">DNS 验证</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持通配符域名</p>\n</li>\n</ul>\n<h4 id=\"手动验证\">手动验证</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意，如果使用手动验证，<a href=\"http://acme.sh\">acme.sh</a> 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 需要加上 --yes-I-know-dns-manual-mode-enough-go-ahead-please 选项</span></span><br><span class=\"line\">acme.sh --issue --dns -d acme.hanqunfeng.com -d www.hanqunfeng.com --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>然后，<a href=\"http://acme.sh\">acme.sh</a> 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add the following txt record:</span><br><span class=\"line\">Domain:_acme-challenge.acme.hanqunfeng.com</span><br><span class=\"line\">Txt value:mUWNg9kuQ9hwOkqYFQ_DFMQ4Eu0CEaxxxxxxxxxxx</span><br><span class=\"line\"></span><br><span class=\"line\">Add the following txt record:</span><br><span class=\"line\">Domain:_acme-challenge.www.hanqunfeng.com</span><br><span class=\"line\">Txt value:vLwDR48eHcmcScOwHrDjaFZo-yw_f9xxxxxxxxxxx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>等待解析完成之后，执行以下命令重新生成证书：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意这里现在用的是 --renew 参数</span></span><br><span class=\"line\">acme.sh --renew -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动验证（DNS-API）\">自动验证（DNS API）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 目前支持<a href=\"https://github.com/acmesh-official/acme.sh/wiki/dnsapi\">超过一百家的 DNS API</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以阿里云为例，登录阿里云帐号，获取 AccessKey 和 SecretKey，并设置环境变量：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只需要命令行执行一次，运行生成证书命令时会保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> Ali_Key=<span class=\"string\">&quot;&lt;key&gt;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> Ali_Secret=<span class=\"string\">&quot;&lt;secret&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --dns dns_ali 指定阿里云的DNS API</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书的其它说明\">生成证书的其它说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 脚本默认 CA 服务商是 ZeroSSL，<a href=\"https://github.com/acmesh-official/acme.sh/wiki/Server\">acme.sh 支持的CA 服务商及其使用方法</a>，可以在命令行中通过 --server 指定</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里使用 Let&#x27;s Encrypt 的 CA 服务商</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以设置全局默认的 CA 服务商，这样就不需要每次都指定 --server</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --set-default-ca --server letsencrypt</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\"><a href=\"http://acme.sh\">acme.sh</a> 官网说 默认的 CA 服务商 ZeroSSL 不是很稳定，有时可能会导致获取证书的时候一直出现：<code>Pending，The CA is processing your order，please just wait.</code>， 此时只需要把 CA 服务器改成 Let’s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功。</li>\n<li class=\"lvl-2\">但是 Let’s Encrypt 获取的证书，不支持比较旧的设备，比如 Android 5.0 以下的设备，如果有这方面的需要还是推荐使用 ZeroSSL。</li>\n<li class=\"lvl-2\">常见根证书表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>根证书（CN）</th>\n<th>Android 5.0</th>\n<th>常见签发方</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ISRG Root X1</strong></td>\n<td>❌ 不兼容</td>\n<td>Let’s Encrypt</td>\n</tr>\n<tr>\n<td><strong>DST Root CA X3</strong></td>\n<td>✅ 兼容（2021年过期）</td>\n<td>Let’s Encrypt 老版本</td>\n</tr>\n<tr>\n<td><strong>GlobalSign Root R1</strong></td>\n<td>✅ 兼容</td>\n<td>GlobalSign</td>\n</tr>\n<tr>\n<td><strong>USERTrust RSA Certification Authority</strong></td>\n<td>✅ 兼容</td>\n<td>ZeroSSL, Sectigo</td>\n</tr>\n<tr>\n<td><strong>Starfield Root CA - G2</strong></td>\n<td>❌ 不兼容</td>\n<td>GoDaddy 新版</td>\n</tr>\n<tr>\n<td><strong>Starfield Root CA - G1</strong></td>\n<td>✅ 兼容</td>\n<td>GoDaddy 老版</td>\n</tr>\n<tr>\n<td><strong>GTS Root R1/R3</strong></td>\n<td>❌ 不兼容</td>\n<td>Google Trust Services</td>\n</tr>\n<tr>\n<td><strong>Amazon Root CA 1</strong></td>\n<td>❌ 不兼容</td>\n<td>Amazon Trust</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>可以用在线工具直接查看证书链：<a href=\"https://www.ssllabs.com/ssltest/\">https://www.ssllabs.com/ssltest/</a> ，它会显示完整证书链和各种设备的兼容性</p>\n</li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看已经生成的证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ acme.sh --list</span><br><span class=\"line\">Main_Domain          KeyLength  SAN_Domains  CA           Created               Renew</span><br><span class=\"line\">acme.hanqunfeng.com  <span class=\"string\">&quot;ec-256&quot;</span>   no           ZeroSSL.com  2025-07-17T03:31:30Z  2025-09-14T03:31:30Z</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果生成证书时失败，可以通过添加 --debug 参数查看详细错误信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug</span><br><span class=\"line\"><span class=\"comment\"># --debug 2 输出更为详细的信息</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug 2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>目前证书每 60 天自动更新，你无需任何操作。但是你也可以强制续签证书：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意这里要将 --issue 改为 --renew，--issue 只有第一次生成正式时才会使用。同时加上 --force，未到更新时间强制重新生成证书。</span></span><br><span class=\"line\">acme.sh --renew -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书后自动部署和更新\">生成证书后自动部署和更新</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面无论是 http 还是 dns 模式，生成证书后，都会在 ~/.acme.sh/acme.hanqunfeng.com_ecc/ 目录下生成以下文件：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── acme.hanqunfeng.com.cer</span><br><span class=\"line\">├── acme.hanqunfeng.com.conf</span><br><span class=\"line\">├── acme.hanqunfeng.com.csr</span><br><span class=\"line\">├── acme.hanqunfeng.com.csr.conf</span><br><span class=\"line\">├── acme.hanqunfeng.com.key</span><br><span class=\"line\">├── ca.cer</span><br><span class=\"line\">└── fullchain.cer</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以手动将证书拷贝到真正使用证书的目录下，如果我们使用nginx或者apache，可以让 <a href=\"http://acme.sh\">acme.sh</a> 帮我们自动将证书拷贝到正确的目录下，并重启服务使证书生效，我们只需要通过如下命令进行设置即可，只需要运行一次命令，后续会通过 crontab 进行自动更新证书并完成部署。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nginx</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert \\</span><br><span class=\"line\">-d acme.hanqunfeng.com \\                               <span class=\"comment\"># 生成证书时指定的域名</span></span><br><span class=\"line\">--key-file /path/to/keyfile/in/nginx/key.pem \\    <span class=\"comment\"># nginx 中配置的 key 文件路径</span></span><br><span class=\"line\">--fullchain-file /path/to/fullchain/nginx/cert.pem \\  <span class=\"comment\"># nginx 中配置的证书文件路径</span></span><br><span class=\"line\">--reloadcmd <span class=\"string\">&quot;systemctl reload nginx&quot;</span>                   <span class=\"comment\"># nginx 重载命令，也可以使用 nginx -s reload</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件对应关系</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><a href=\"http://acme.sh\">acme.sh</a> 文件</th>\n<th>含义</th>\n<th>你配置的目标文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>acme.hanqunfeng.com.key</code></td>\n<td><strong>私钥 (Private Key)</strong></td>\n<td><code>/path/to/keyfile/in/nginx/key.pem</code></td>\n</tr>\n<tr>\n<td><code>fullchain.cer</code></td>\n<td><strong>证书 + 中间证书链 (Fullchain)</strong></td>\n<td><code>/path/to/fullchain/nginx/cert.pem</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Apache</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert \\</span><br><span class=\"line\">-d acme.hanqunfeng.com \\</span><br><span class=\"line\">--cert-file      /path/to/certfile/in/apache/cert.pem  \\ <span class=\"comment\"># apache 证书文件</span></span><br><span class=\"line\">--key-file       /path/to/keyfile/in/apache/key.pem  \\   <span class=\"comment\"># apache 密钥文件</span></span><br><span class=\"line\">--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\ <span class=\"comment\"># apache 全链文件</span></span><br><span class=\"line\">--reloadcmd     <span class=\"string\">&quot;systemctl reload httpd&quot;</span>  <span class=\"comment\"># apache 重载命令</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件对应关系</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><a href=\"http://acme.sh\">acme.sh</a> 文件</th>\n<th>含义</th>\n<th>你配置的目标文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>acme.hanqunfeng.com.key</code></td>\n<td><strong>私钥 (Private Key)</strong></td>\n<td><code>/path/to/keyfile/in/apache/key.pem</code></td>\n</tr>\n<tr>\n<td><code>acme.hanqunfeng.com.cer</code></td>\n<td><strong>仅域名证书 (Certificate)</strong></td>\n<td><code>/path/to/certfile/in/apache/cert.pem</code></td>\n</tr>\n<tr>\n<td><code>fullchain.cer</code></td>\n<td><strong>证书 + 中间证书链 (Fullchain)</strong></td>\n<td><code>/path/to/fullchain/certfile/apache/fullchain.pem</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"停止自动更新并删除证书\">停止自动更新并删除证书</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止自动更新</span></span><br><span class=\"line\">acme.sh --remove -d acme.hanqunfeng.com --ecc</span><br><span class=\"line\"><span class=\"comment\"># 删除证书</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf ~/.acme.sh/acme.hanqunfeng.com_ecc</span><br></pre></td></tr></table></figure>\n<h2 id=\"其它ssl自动续签工具\">其它ssl自动续签工具</h2>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>推荐场景</th>\n<th>官网地址</th>\n<th>依赖</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Certbot</td>\n<td>传统服务器、Nginx/Apache</td>\n<td><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></td>\n<td>Python</td>\n</tr>\n<tr>\n<td>Lego</td>\n<td>静态二进制、K8s</td>\n<td><a href=\"https://github.com/go-acme/lego\">https://github.com/go-acme/lego</a></td>\n<td>无依赖</td>\n</tr>\n<tr>\n<td>cert-manager</td>\n<td>K8s 集群</td>\n<td><a href=\"https://cert-manager.io/\">https://cert-manager.io/</a></td>\n<td>K8s CRD</td>\n</tr>\n<tr>\n<td>Caddy</td>\n<td>简单站点自动HTTPS</td>\n<td><a href=\"https://caddyserver.com/\">https://caddyserver.com/</a></td>\n<td>无需单独工具</td>\n</tr>\n<tr>\n<td>Traefik</td>\n<td>微服务网关</td>\n<td><a href=\"https://traefik.io/\">https://traefik.io/</a></td>\n<td>Docker/K8s</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍自动申请并续签 SSL 证书的工具: acme.sh acme.sh Github acme.sh 介绍 acme.sh 实现了 acme 协议，可以从 ZeroSSL，Let’s Encrypt 等 CA 生成免费的证书。 适用场景：shell脚本方式，几乎无依赖，极简，适合不想安装Python环境的人。 特点： 纯 Shell 脚本，单文件运行 支持 100+ DNS API 自动续签（如 Cloudflare、阿里云、腾讯云等） 支持通配符证书 acme.sh 安装 需要先安装 crontab 12345678# 安装 crontabsudo dnf install cronie -y# 启动 crondsudo systemctl enable --now crond# 查看 crond 状态sudo systemctl status crond# 查看 crontab 是否正常crontab -l 安装 acme.sh 123456789101112131415# 安装成功后会自动安装到 ~/.acme.sh/ 目录下，证书也会生成在该目录下curl https://get.acme.sh | sh -s email=qunfeng_han@aliyun.comecho &#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 安装成功后会自动在 crontab 中添加了定时任务，每天检查一次证书是否到达下次更新日期，如果到期则自动更新# 证书有效期默认为 90 天，还剩 30 天时会触发自动更新crontab -l# 输出类似于 以下内容48 1 * * * &quot;/root/.acme.sh&quot;/acme.sh --cron --home &quot;/root/.acme.sh&quot; &gt; /dev/null# 查看帮助acme.sh -h# 查看版本acme.sh -v 升级 acme.sh 12345678# 升级 acme.sh 到最新版acme.sh --upgrade# 开启自动升级acme.sh --upgrade --auto-upgrade# 可以随时关闭自动更新acme.sh --upgrade --auto-upgrade 0 卸载 acme.sh 12acme.sh --uninstallrm -rf ~/.acme.sh 生成证书 acme.sh 实现了 acme 协议支持的所有验证协议。 证书创建后会保存在 ~/.acme.sh/目录下，比如我的域名是 acme.hanqunfeng.com，则证书保存在 ~/.acme.sh/acme.hanqunfeng.com_ecc/目录下 创建证书时一般有两种方式验证: HTTP 和 DNS 验证。 HTTP 验证 只支持单个子域名的证书生成，不支持通配符域名 需要提前将域名解析到本机的IP地址 直接签发 只需要指定域名，并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。 12345# -d 指定域名，可以添加多个，--webroot 指定网站根目录acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/# --server 指定 acme.sh 使用的 CA 服务商为 Let&#x27;s Encrypt，默认使用 ZeroSSLacme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/ --server letsencrypt 使用 Nginx/Apache 模式 如果你用的 Nginx/Apache 服务器，或者反代，acme.sh 还可以智能的从 Nginx/Apache 的配置中自动完成验证，你不需要指定网站根目录 nginx 或 httpd 命令要在系统Path中 1234# -d 域名，可以添加多个, --nginx 告诉 acme.sh 使用 Nginx 模式acme.sh --issue --nginx -d acme.hanqunfeng.com -d www.hanqunfeng.com# -d 域名，可以添加多个, --apache 告诉 acme.sh 使用 Apache 模式acme.sh --issue --apache -d acme.hanqunfeng.com -d www.hanqunfeng.com 使用独立服务模式 如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 acme.sh 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证 需要先安装 socat 命令，socat 常用于临时开启 TCP/UDP 监听端口 1sudo dnf install socat -y 生成证书，要求80端口空闲，否则会失败 12# --standalone 独立服务模式acme.sh --issue --standalone -d acme.hanqunfeng.com -d www.hanqunfeng.com DNS 验证 如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。 支持通配符域名 手动验证 这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。 注意，如果使用手动验证，acme.sh 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。 12# 需要加上 --yes-I-know-dns-manual-mode-enough-go-ahead-please 选项acme.sh --issue --dns -d acme.hanqunfeng.com -d www.hanqunfeng.com --yes-I-know-dns-manual-mode-enough-go-ahead-please 然后，acme.sh 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。 1234567Add the following txt record:Domain:_acme-challenge.acme.hanqunfeng.comTxt value:mUWNg9kuQ9hwOkqYFQ_DFMQ4Eu0CEaxxxxxxxxxxxAdd the following txt record:Domain:_acme-challenge.www.hanqunfeng.comTxt value:vLwDR48eHcmcScOwHrDjaFZo-yw_f9xxxxxxxxxxx 等待解析完成之后，执行以下命令重新生成证书： 12# 注意这里现在用的是 --renew 参数acme.sh --renew -d acme.hanqunfeng.com -d www.hanqunfeng.com 自动验证（DNS API） DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。 acme.sh 目前支持超过一百家的 DNS API。 以阿里云为例，登录阿里云帐号，获取 AccessKey 和 SecretKey，并设置环境变量： 123# 只需要命令行执行一次，运行生成证书命令时会保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置export Ali_Key=&quot;&lt;key&gt;&quot;export Ali_Secret=&quot;&lt;secret&gt;&quot; 生成证书 12# --dns dns_ali 指定阿里云的DNS APIacme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali 生成证书的其它说明 acme.sh 脚本默认 CA 服务商是 ZeroSSL，acme.sh 支持的CA 服务商及其使用方法，可以在命令行中通过 --server 指定 12# 这里使用 Let&#x27;s Encrypt 的 CA 服务商acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt 也可以设置全局默认的 CA 服务商，这样就不需要每次都指定 --server 1acme.sh --set-default-ca --server letsencrypt 小贴士 acme.sh 官网说 默认的 CA 服务商 ZeroSSL 不是很稳定，有时可能会导致获取证书的时候一直出现：Pending，The CA is processing your order，please just wait.， 此时只需要把 CA 服务器改成 Let’s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功。 但是 Let’s Encrypt 获取的证书，不支持比较旧的设备，比如 Android 5.0 以下的设备，如果有这方面的需要还是推荐使用 ZeroSSL。 常见根证书表 根证书（CN） Android 5.0 常见签发方 ISRG Root X1 ❌ 不兼容 Let’s Encrypt DST Root CA X3 ✅ 兼容（2021年过期） Let’s Encrypt 老版本 GlobalSign Root R1 ✅ 兼容 GlobalSign USERTrust RSA Certification Authority ✅ 兼容 ZeroSSL, Sectigo Starfield Root CA - G2 ❌ 不兼容 GoDaddy 新版 Starfield Root CA - G1 ✅ 兼容 GoDaddy 老版 GTS Root R1/R3 ❌ 不兼容 Google Trust Services Amazon Root CA 1 ❌ 不兼容 Amazon Trust 可以用在线工具直接查看证书链：https://www.ssllabs.com/ssltest/ ，它会显示完整证书链和各种设备的兼容性 查看已经生成的证书 123$ acme.sh --listMain_Domain KeyLength SAN_Domains CA Created Renewacme.hanqunfeng.com &quot;ec-256&quot; no ZeroSSL.com 2025-07-17T03:31:30Z 2025-09-14T03:31:30Z 如果生成证书时失败，可以通过添加 --debug 参数查看详细错误信息 123acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug# --debug 2 输出更为详细的信息acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug 2 目前证书每 60 天自动更新，你无需任何操作。但是你也可以强制续签证书： 12# 注意这里要将 --issue 改为 --renew，--issue 只有第一次生成正式时才会使用。同时加上 --force，未到更新时间强制重新生成证书。acme.sh --renew -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --force 生成证书后自动部署和更新 上面无论是 http 还是 dns 模式，生成证书后，都会在 ~/.acme.sh/acme.hanqunfeng.com_ecc/ 目录下生成以下文件： 1234567├── acme.hanqunfeng.com.cer├── acme.hanqunfeng.com.conf├── acme.hanqunfeng.com.csr├── acme.hanqunfeng.com.csr.conf├── acme.hanqunfeng.com.key├── ca.cer└── fullchain.cer 我们可以手动将证书拷贝到真正使用证书的目录下，如果我们使用nginx或者apache，可以让 acme.sh 帮我们自动将证书拷贝到正确的目录下，并重启服务使证书生效，我们只需要通过如下命令进行设置即可，只需要运行一次命令，后续会通过 crontab 进行自动更新证书并完成部署。 Nginx 12345acme.sh --install-cert \\-d acme.hanqunfeng.com \\ # 生成证书时指定的域名--key-file /path/to/keyfile/in/nginx/key.pem \\ # nginx 中配置的 key 文件路径--fullchain-file /path/to/fullchain/nginx/cert.pem \\ # nginx 中配置的证书文件路径--reloadcmd &quot;systemctl reload nginx&quot; # nginx 重载命令，也可以使用 nginx -s reload 文件对应关系 acme.sh 文件 含义 你配置的目标文件 acme.hanqunfeng.com.key 私钥 (Private Key) /path/to/keyfile/in/nginx/key.pem fullchain.cer 证书 + 中间证书链 (Fullchain) /path/to/fullchain/nginx/cert.pem Apache 123456acme.sh --install-cert \\-d acme.hanqunfeng.com \\--cert-file /path/to/certfile/in/apache/cert.pem \\ # apache 证书文件--key-file /path/to/keyfile/in/apache/key.pem \\ # apache 密钥文件--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\ # apache 全链文件--reloadcmd &quot;systemctl reload httpd&quot; # apache 重载命令 文件对应关系 acme.sh 文件 含义 你配置的目标文件 acme.hanqunfeng.com.key 私钥 (Private Key) /path/to/keyfile/in/apache/key.pem acme.hanqunfeng.com.cer 仅域名证书 (Certificate) /path/to/certfile/in/apache/cert.pem fullchain.cer 证书 + 中间证书链 (Fullchain) /path/to/fullchain/certfile/apache/fullchain.pem 停止自动更新并删除证书 1234# 停止自动更新acme.sh --remove -d acme.hanqunfeng.com --ecc# 删除证书rm -rf ~/.acme.sh/acme.hanqunfeng.com_ecc 其它ssl自动续签工具 工具 推荐场景 官网地址 依赖 Certbot 传统服务器、Nginx/Apache https://certbot.eff.org/ Python Lego 静态二进制、K8s https://github.com/go-acme/lego 无依赖 cert-manager K8s 集群 https://cert-manager.io/ K8s CRD Caddy 简单站点自动HTTPS https://caddyserver.com/ 无需单独工具 Traefik 微服务网关 https://traefik.io/ Docker/K8s","summary":"摘要 本文介绍自动申请并续签 SSL 证书的工具: acme.sh acme.sh Github","date_published":"2025-07-17T14:30:05.000Z","tags":["技术","acme","ssl","certificate","ssl","acme"]},{"id":"https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/","url":"https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/","title":"K8S 镜像拉取 之 toomanyrequests 的解决方法","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 镜像拉取 的 <code>toomanyrequests</code> 的解决方法 ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"toomanyrequests-介绍\">toomanyrequests 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当我们通过k8s创建pod时需要从 dockerhub 上拉取镜像，但是 dockerhub 的api请求是有限制的，未认证用户限制为100/6h，如果超过这个限制就会返回<code>429 Too Many Requests响应</code>。<a href=\"https://docs.docker.com/docker-hub/usage/\">Docker Hub的使用和限制</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们可以进行用户认证，这样可以将限制提高到2000/6h。如果还需要进一步提高请求限制，可以申请dockerhub的pro plan。</p>\n</li>\n</ul>\n<h2 id=\"dockerhub-认证\">dockerhub 认证</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 Docker Registry Secret</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 namespace， 默认命名空间是 default</span></span><br><span class=\"line\">kubectl create secret docker-registry \\</span><br><span class=\"line\">  dockerhub-secret \\                            <span class=\"comment\"># 创建 secret 名称</span></span><br><span class=\"line\">  --namespace=你的命名空间 \\                      <span class=\"comment\"># 创建 secret 所在的命名空间</span></span><br><span class=\"line\">  --docker-server=https://index.docker.io/v1/ \\ <span class=\"comment\"># 指定 docker registry 地址，默认就是这个，其它仓库或私服请更改为对应的url</span></span><br><span class=\"line\">  --docker-username=你的用户名 \\                  <span class=\"comment\"># 仓库 的用户名</span></span><br><span class=\"line\">  --docker-password=你的密码或访问令牌 \\           <span class=\"comment\"># 仓库 的密码或访问令牌</span></span><br><span class=\"line\">  --docker-email=你的邮箱                        <span class=\"comment\"># 仓库 的邮箱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 secret</span></span><br><span class=\"line\">kubectl get secret dockerhub-secret -o yaml -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以在创建 pod 或 deployment 时指定凭证</p>\n</li>\n</ul>\n<blockquote>\n<p>pod</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">username/repository:tag</span></span><br><span class=\"line\">  <span class=\"attr\">imagePullSecrets:</span>                         <span class=\"comment\"># 添加凭证</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dockerhub-secret</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>deployment</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">username/repository:tag</span></span><br><span class=\"line\">      <span class=\"attr\">imagePullSecrets:</span>                       <span class=\"comment\"># 添加凭证</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dockerhub-secret</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 Secret 添加到 ServiceAccount，这样 Pod 创建的时候，会自动将 Secret 挂载到 Pod 中</p>\n</li>\n</ul>\n<blockquote>\n<p>每个 namespace 下 都有一个 名称为 default 的 ServiceAccount</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 pod 的 ServiceAccount</span></span><br><span class=\"line\">$ k describe pod pi-n65gn | grep <span class=\"string\">&quot;Service Account&quot;</span></span><br><span class=\"line\">Service Account:  default</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 namespace 下的 Pod 使用这个凭证</span></span><br><span class=\"line\">kubectl patch serviceaccount default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加多个凭证，这会覆盖之前的设置，多个 secret 按顺序生效，k8s 会逐个尝试去拉取镜像</span></span><br><span class=\"line\">kubectl patch serviceaccount default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;harbor-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;aliyun-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 追加一个凭证，不会覆盖原有的设置</span></span><br><span class=\"line\">kubectl patch serviceaccount default --<span class=\"built_in\">type</span>=<span class=\"string\">&#x27;json&#x27;</span> -p=<span class=\"string\">&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/imagePullSecrets/-&quot;, &quot;value&quot;: &#123;&quot;name&quot;: &quot;new-secret&quot;&#125;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前 imagePullSecrets 的索引，以下命令会输出凭证的名称，索引从 0 开始</span></span><br><span class=\"line\">kubectl get sa default -o jsonpath=<span class=\"string\">&#x27;&#123;.imagePullSecrets[*].name&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个凭证: 删除 index 为 1 的凭证</span></span><br><span class=\"line\">kubectl patch serviceaccount default --<span class=\"built_in\">type</span>=json -p=<span class=\"string\">&#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/imagePullSecrets/1&quot;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清空所有凭证</span></span><br><span class=\"line\">kubectl patch sa default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: []&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为所有 namespace 下的 Pod 添加凭证</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ns <span class=\"keyword\">in</span> $(kubectl get ns -o jsonpath=<span class=\"string\">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">  kubectl patch serviceaccount default -n <span class=\"variable\">$ns</span> \\</span><br><span class=\"line\">    --<span class=\"built_in\">type</span>=merge \\</span><br><span class=\"line\">    -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 ServiceAccount</span></span><br><span class=\"line\">$ kubectl get serviceaccount default -o yaml -n &lt;namespace&gt;</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">imagePullSecrets:</span><br><span class=\"line\">- name: dockerhub-secret</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-06-29T14:41:35Z&quot;</span></span><br><span class=\"line\">  name: default</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;361001&quot;</span></span><br><span class=\"line\">  uid: cb3a0f99-5804-4f21-816a-70533cc3d29d</span><br></pre></td></tr></table></figure>\n<h2 id=\"提高下载频率的其他建议\">提高下载频率的其他建议</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.使用镜像缓存:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">设置集群内镜像缓存（如 Harbor, Nexus Registry）</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改集群的镜像仓库配置（vim）</span></span><br><span class=\"line\">kubectl edit configmap -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 找到 imageRepository: 替换为你的仓库地址</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">使用 Docker Hub 镜像加速器（如果在中国大陆）\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果 k8s 使用的是 docker，则在<code>/etc/docker/daemon.json</code>添加镜像加速器配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">&#x27;EOF&#x27;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;registry-mirrors&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.1ms.run&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.xuanyuan.me&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.m.daocloud.io&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果 k8s 使用的是 containerd，则在<code>/etc/containerd/config.toml</code>添加镜像加速器配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/containerd/config.toml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 registry.mirrors 字段，添加加速器，比如：</span></span><br><span class=\"line\">[plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class=\"line\">  [plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class=\"string\">&quot;docker.io&quot;</span>]</span><br><span class=\"line\">    endpoint = [<span class=\"string\">&quot;https://docker.1ms.run&quot;</span>, <span class=\"string\">&quot;https://docker.xuanyuan.me&quot;</span>, <span class=\"string\">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改后重启 containerd</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>2.升级 Docker Hub 订阅:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">免费账户：200 pulls/6小时（匿名用户100 pulls/6小时）</li>\n<li class=\"lvl-4\">Pro/Team 账户：无限制拉取</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3.使用多个账户:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">为不同节点配置不同的 Docker Hub 凭证</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>4.减少不必要的拉取:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">使用 imagePullPolicy: IfNotPresent</li>\n<li class=\"lvl-4\">尽量使用固定版本标签而非 latest</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 镜像拉取 的 toomanyrequests 的解决方法 ，本文以 CentOS 8 为例。 K8S官网 k8s Github toomanyrequests 介绍 当我们通过k8s创建pod时需要从 dockerhub 上拉取镜像，但是 dockerhub 的api请求是有限制的，未认证用户限制为100/6h，如果超过这个限制就会返回429 Too Many Requests响应。Docker Hub的使用和限制 我们可以进行用户认证，这样可以将限制提高到2000/6h。如果还需要进一步提高请求限制，可以申请dockerhub的pro plan。 dockerhub 认证 创建 Docker Registry Secret 1234567891011# 指定 namespace， 默认命名空间是 defaultkubectl create secret docker-registry \\ dockerhub-secret \\ # 创建 secret 名称 --namespace=你的命名空间 \\ # 创建 secret 所在的命名空间 --docker-server=https://index.docker.io/v1/ \\ # 指定 docker registry 地址，默认就是这个，其它仓库或私服请更改为对应的url --docker-username=你的用户名 \\ # 仓库 的用户名 --docker-password=你的密码或访问令牌 \\ # 仓库 的密码或访问令牌 --docker-email=你的邮箱 # 仓库 的邮箱# 查看 secretkubectl get secret dockerhub-secret -o yaml -n &lt;namespace&gt; 可以在创建 pod 或 deployment 时指定凭证 pod 12345678910apiVersion: v1kind: Podmetadata: name: myappspec: containers: - name: myapp image: username/repository:tag imagePullSecrets: # 添加凭证 - name: dockerhub-secret deployment 12345678910111213141516171819apiVersion: apps/v1kind: Deploymentmetadata: name: myapp-deploymentspec: replicas: 3 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - name: myapp image: username/repository:tag imagePullSecrets: # 添加凭证 - name: dockerhub-secret 将 Secret 添加到 ServiceAccount，这样 Pod 创建的时候，会自动将 Secret 挂载到 Pod 中 每个 namespace 下 都有一个 名称为 default 的 ServiceAccount 123456789101112131415161718192021222324252627282930313233343536373839404142# 查看 pod 的 ServiceAccount$ k describe pod pi-n65gn | grep &quot;Service Account&quot;Service Account: default# 指定 namespace 下的 Pod 使用这个凭证kubectl patch serviceaccount default -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27; -n &lt;namespace&gt;# 添加多个凭证，这会覆盖之前的设置，多个 secret 按顺序生效，k8s 会逐个尝试去拉取镜像kubectl patch serviceaccount default -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;harbor-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;aliyun-secret&quot;&#125;]&#125;&#x27; -n &lt;namespace&gt;# 追加一个凭证，不会覆盖原有的设置kubectl patch serviceaccount default --type=&#x27;json&#x27; -p=&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/imagePullSecrets/-&quot;, &quot;value&quot;: &#123;&quot;name&quot;: &quot;new-secret&quot;&#125;&#125;]&#x27; -n &lt;namespace&gt;# 查看当前 imagePullSecrets 的索引，以下命令会输出凭证的名称，索引从 0 开始kubectl get sa default -o jsonpath=&#x27;&#123;.imagePullSecrets[*].name&#125;&#x27; -n &lt;namespace&gt;# 删除一个凭证: 删除 index 为 1 的凭证kubectl patch serviceaccount default --type=json -p=&#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/imagePullSecrets/1&quot;&#125;]&#x27; -n &lt;namespace&gt;# 清空所有凭证kubectl patch sa default -p &#x27;&#123;&quot;imagePullSecrets&quot;: []&#125;&#x27; -n &lt;namespace&gt;# 为所有 namespace 下的 Pod 添加凭证for ns in $(kubectl get ns -o jsonpath=&#x27;&#123;.items[*].metadata.name&#125;&#x27;); do kubectl patch serviceaccount default -n $ns \\ --type=merge \\ -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;done# 查看 ServiceAccount$ kubectl get serviceaccount default -o yaml -n &lt;namespace&gt;apiVersion: v1imagePullSecrets:- name: dockerhub-secretkind: ServiceAccountmetadata: creationTimestamp: &quot;2025-06-29T14:41:35Z&quot; name: default namespace: default resourceVersion: &quot;361001&quot; uid: cb3a0f99-5804-4f21-816a-70533cc3d29d 提高下载频率的其他建议 1.使用镜像缓存: 设置集群内镜像缓存（如 Harbor, Nexus Registry） 123# 修改集群的镜像仓库配置（vim）kubectl edit configmap -n kube-system# 找到 imageRepository: 替换为你的仓库地址 使用 Docker Hub 镜像加速器（如果在中国大陆） 如果 k8s 使用的是 docker，则在/etc/docker/daemon.json添加镜像加速器配置 123456789101112sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [ &quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot; ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 如果 k8s 使用的是 containerd，则在/etc/containerd/config.toml添加镜像加速器配置 123456789sudo vi /etc/containerd/config.toml# 找到 registry.mirrors 字段，添加加速器，比如：[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors] [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;] endpoint = [&quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot;]# 修改后重启 containerdsudo systemctl restart containerd 2.升级 Docker Hub 订阅: 免费账户：200 pulls/6小时（匿名用户100 pulls/6小时） Pro/Team 账户：无限制拉取 3.使用多个账户: 为不同节点配置不同的 Docker Hub 凭证 4.减少不必要的拉取: 使用 imagePullPolicy: IfNotPresent 尽量使用固定版本标签而非 latest","summary":"摘要 本文介绍 K8S 镜像拉取 的 toomanyrequests 的解决方法 ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-16T15:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/","url":"https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/","title":"K8S 之 Job/CronJob","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/\">k8s Job 介绍</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/\">k8s CronJob 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Job-介绍\">Job 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Job 表示一次性任务，运行完成后就会停止。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。</p>\n</li>\n<li class=\"lvl-2\">\n<p>随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。</p>\n</li>\n<li class=\"lvl-2\">\n<p>删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>\n</li>\n</ul>\n<h3 id=\"Job-创建\">Job 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 文件: job.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">batch/v1</span>                      <span class=\"comment\"># API 版本，这里使用 batch/v1，适用于 Job 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Job</span>                                 <span class=\"comment\"># 资源类型，Job 用于一次性任务，完成后自动退出</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pi</span>                                <span class=\"comment\"># Job 的名称，这里命名为 pi</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ttlSecondsAfterFinished:</span> <span class=\"number\">100</span>            <span class=\"comment\"># Job 完成后，自动删除job的延迟时间，单位为秒。默认不删除</span></span><br><span class=\"line\">  <span class=\"attr\">parallelism:</span> <span class=\"number\">1</span>                          <span class=\"comment\"># Job 的并发数，默认为1，即一次只能启动一个 Pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                               <span class=\"comment\"># Pod 模板，定义 Job 创建的 Pod 的规范</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span>                         <span class=\"comment\"># Pod 内的容器列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pi</span>                          <span class=\"comment\"># 容器名称，用户自定义的名字</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">perl:5.34.0</span>                <span class=\"comment\"># 使用的镜像，这里是 Perl 5.34.0 官方镜像</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">&quot;perl&quot;</span>,  <span class=\"string\">&quot;-Mbignum=bpi&quot;</span>, <span class=\"string\">&quot;-wle&quot;</span>, <span class=\"string\">&quot;print bpi(2000)&quot;</span>]  <span class=\"comment\"># 容器启动时执行的命令，计算并输出圆周率的 2000 位小数</span></span><br><span class=\"line\">      <span class=\"attr\">restartPolicy:</span> <span class=\"string\">Never</span>                <span class=\"comment\"># 重启策略，设置为 Never，表示 Pod 失败时不会自动重启</span></span><br><span class=\"line\">  <span class=\"attr\">backoffLimit:</span> <span class=\"number\">4</span>                         <span class=\"comment\"># Job 重试次数上限，若失败超过 4 次，则不再重试，Job 状态将标记为 Failed。默认为 6</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f job.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Job</span></span><br><span class=\"line\">kubectl get <span class=\"built_in\">jobs</span></span><br><span class=\"line\"><span class=\"comment\"># 查看日志，此时会看到输出 圆周率值</span></span><br><span class=\"line\">kubectl logs <span class=\"built_in\">jobs</span>/pi</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除 Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete <span class=\"built_in\">jobs</span>/pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yaml 删除</span></span><br><span class=\"line\">kubectl delete -f job.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"CronJob-介绍\">CronJob 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CronJob(缩写为 cj) 通过重复调度启动一次性的 Job。</p>\n</li>\n<li class=\"lvl-2\">\n<p>CronJob 用于执行排期操作，例如备份、生成报告等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p>\n</li>\n</ul>\n<h3 id=\"CronJob-示例：\">CronJob 示例：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apiVersion: batch/v1</span><br><span class=\"line\">kind: CronJob                               <span class=\"comment\"># 创建CronJob</span></span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: hello</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  schedule: <span class=\"string\">&quot;* * * * *&quot;</span>                     <span class=\"comment\"># 每分钟执行一次，不支持时区设置</span></span><br><span class=\"line\">  successfulJobsHistoryLimit: 3             <span class=\"comment\"># 指定要保留多少成功完成的 Job。默认值为 3</span></span><br><span class=\"line\">  failedJobsHistoryLimit: 1                 <span class=\"comment\"># 指定要保留多少失败完成的 Job。默认值为 1</span></span><br><span class=\"line\">  concurrencyPolicy: Allow                  <span class=\"comment\"># 默认值为 Allow：允许多个 Job 同时运行</span></span><br><span class=\"line\">                                            <span class=\"comment\"># Forbid：不允许多个 Job 同时运行。如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会忽略新 Job 的执行。 另请注意，当老 Job 执行完成时，仍然会考虑 .spec.startingDeadlineSeconds，可能会导致新的 Job 执行。</span></span><br><span class=\"line\">                                            <span class=\"comment\"># Replace：如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会用新 Job 替换当前正在运行的 Job。</span></span><br><span class=\"line\">  jobTemplate:</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      template:</span><br><span class=\"line\">        spec:</span><br><span class=\"line\">          containers:</span><br><span class=\"line\">          - name: hello</span><br><span class=\"line\">            image: busybox:1.28</span><br><span class=\"line\">            imagePullPolicy: IfNotPresent</span><br><span class=\"line\">            <span class=\"built_in\">command</span>:</span><br><span class=\"line\">            - /bin/sh</span><br><span class=\"line\">            - -c</span><br><span class=\"line\">            - <span class=\"built_in\">date</span>; <span class=\"built_in\">echo</span> Hello from the Kubernetes cluster</span><br><span class=\"line\">          restartPolicy: OnFailure</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>.spec.schedule</code> 字段是必需的。该字段的值遵循 Cron 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ┌───────────── 分钟 (0 - 59)</span></span><br><span class=\"line\"><span class=\"comment\"># │ ┌───────────── 小时 (0 - 23)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ ┌───────────── 月的某天 (1 - 31)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ ┌───────────── 月份 (1 - 12)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │</span></span><br><span class=\"line\"><span class=\"comment\"># * * * * *</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时间表中的问号 (?) 和星号 * 含义相同，它们用来表示给定字段的任何可用值。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>除了标准语法，还可以使用一些类似 @monthly 的宏</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>输入</strong></th>\n<th><strong>描述</strong></th>\n<th><strong>等价 Cron 表达式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@yearly</code> 或 <code>@annually</code></td>\n<td>每年 1 月 1 日的午夜运行一次</td>\n<td><code>0 0 1 1 *</code></td>\n</tr>\n<tr>\n<td><code>@monthly</code></td>\n<td>每月第一天的午夜运行一次</td>\n<td><code>0 0 1 * *</code></td>\n</tr>\n<tr>\n<td><code>@weekly</code></td>\n<td>每周的周日午夜运行一次</td>\n<td><code>0 0 * * 0</code></td>\n</tr>\n<tr>\n<td><code>@daily</code> 或 <code>@midnight</code></td>\n<td>每天午夜运行一次</td>\n<td><code>0 0 * * *</code></td>\n</tr>\n<tr>\n<td><code>@hourly</code></td>\n<td>每小时的开始运行一次</td>\n<td><code>0 * * * *</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管理cronjob</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建cronjob</span></span><br><span class=\"line\">kubectl create -f cronjob.yaml</span><br><span class=\"line\"><span class=\"comment\"># 查看cronjob</span></span><br><span class=\"line\">kubectl get cronjob hello -o yaml</span><br><span class=\"line\"><span class=\"comment\"># 删除cronjob</span></span><br><span class=\"line\">kubectl delete cronjob hello</span><br><span class=\"line\">k delete -f cronjob.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"以下是-Kubernetes-中-Job-和-CronJob-的对比表\">以下是 Kubernetes 中 Job 和 CronJob 的对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Job</th>\n<th>CronJob</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>一次性任务，完成即结束</td>\n<td>定时周期性任务，按照时间计划定时运行</td>\n</tr>\n<tr>\n<td><strong>调度方式</strong></td>\n<td>手动创建或由控制器触发</td>\n<td>按照 Cron 表达式自动周期性调度</td>\n</tr>\n<tr>\n<td><strong>常用场景</strong></td>\n<td>数据批处理、数据库迁移、一次性任务</td>\n<td>每天备份、定时报告生成、周期性检查</td>\n</tr>\n<tr>\n<td><strong>配置关键字段</strong></td>\n<td><code>spec.template</code></td>\n<td><code>spec.schedule</code>（Cron 表达式） + <code>spec.jobTemplate</code></td>\n</tr>\n<tr>\n<td><strong>启动频率</strong></td>\n<td>创建后立刻启动一次</td>\n<td>根据 <code>schedule</code> 定期启动</td>\n</tr>\n<tr>\n<td><strong>并发控制</strong></td>\n<td>不支持并发策略</td>\n<td>支持 <code>concurrencyPolicy</code>（Allow、Forbid、Replace）</td>\n</tr>\n<tr>\n<td><strong>保留历史任务</strong></td>\n<td>无保留，任务完成后直接终结</td>\n<td>可配置保留成功或失败任务数：<code>successfulJobsHistoryLimit</code>、<code>failedJobsHistoryLimit</code></td>\n</tr>\n<tr>\n<td><strong>失败重试机制</strong></td>\n<td>支持 <code>backoffLimit</code>、<code>restartPolicy</code></td>\n<td>同样支持，作用于每次周期性运行产生的 Job 上</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Job 介绍 k8s CronJob 介绍 Job 介绍 Job 表示一次性任务，运行完成后就会停止。 Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。 Job 创建 yaml 文件: job.yaml 123456789101112131415apiVersion: batch/v1 # API 版本，这里使用 batch/v1，适用于 Job 资源kind: Job # 资源类型，Job 用于一次性任务，完成后自动退出metadata: name: pi # Job 的名称，这里命名为 pispec: ttlSecondsAfterFinished: 100 # Job 完成后，自动删除job的延迟时间，单位为秒。默认不删除 parallelism: 1 # Job 的并发数，默认为1，即一次只能启动一个 Pod template: # Pod 模板，定义 Job 创建的 Pod 的规范 spec: containers: # Pod 内的容器列表 - name: pi # 容器名称，用户自定义的名字 image: perl:5.34.0 # 使用的镜像，这里是 Perl 5.34.0 官方镜像 command: [&quot;perl&quot;, &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] # 容器启动时执行的命令，计算并输出圆周率的 2000 位小数 restartPolicy: Never # 重启策略，设置为 Never，表示 Pod 失败时不会自动重启 backoffLimit: 4 # Job 重试次数上限，若失败超过 4 次，则不再重试，Job 状态将标记为 Failed。默认为 6 启动Job 1kubectl apply -f job.yaml 查看 Job 1234# 查看 Jobkubectl get jobs# 查看日志，此时会看到输出 圆周率值kubectl logs jobs/pi 删除 Job 1234kubectl delete jobs/pi# yaml 删除kubectl delete -f job.yaml CronJob 介绍 CronJob(缩写为 cj) 通过重复调度启动一次性的 Job。 CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。 CronJob 示例： 123456789101112131415161718192021222324apiVersion: batch/v1kind: CronJob # 创建CronJobmetadata: name: hellospec: schedule: &quot;* * * * *&quot; # 每分钟执行一次，不支持时区设置 successfulJobsHistoryLimit: 3 # 指定要保留多少成功完成的 Job。默认值为 3 failedJobsHistoryLimit: 1 # 指定要保留多少失败完成的 Job。默认值为 1 concurrencyPolicy: Allow # 默认值为 Allow：允许多个 Job 同时运行 # Forbid：不允许多个 Job 同时运行。如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会忽略新 Job 的执行。 另请注意，当老 Job 执行完成时，仍然会考虑 .spec.startingDeadlineSeconds，可能会导致新的 Job 执行。 # Replace：如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会用新 Job 替换当前正在运行的 Job。 jobTemplate: spec: template: spec: containers: - name: hello image: busybox:1.28 imagePullPolicy: IfNotPresent command: - /bin/sh - -c - date; echo Hello from the Kubernetes cluster restartPolicy: OnFailure .spec.schedule 字段是必需的。该字段的值遵循 Cron 语法： 1234567891011# ┌───────────── 分钟 (0 - 59)# │ ┌───────────── 小时 (0 - 23)# │ │ ┌───────────── 月的某天 (1 - 31)# │ │ │ ┌───────────── 月份 (1 - 12)# │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）# │ │ │ │ │ 或者是 sun，mon，tue，web，thu，fri，sat# │ │ │ │ │# │ │ │ │ │# * * * * *# 时间表中的问号 (?) 和星号 * 含义相同，它们用来表示给定字段的任何可用值。 除了标准语法，还可以使用一些类似 @monthly 的宏 输入 描述 等价 Cron 表达式 @yearly 或 @annually 每年 1 月 1 日的午夜运行一次 0 0 1 1 * @monthly 每月第一天的午夜运行一次 0 0 1 * * @weekly 每周的周日午夜运行一次 0 0 * * 0 @daily 或 @midnight 每天午夜运行一次 0 0 * * * @hourly 每小时的开始运行一次 0 * * * * 管理cronjob 1234567# 创建cronjobkubectl create -f cronjob.yaml# 查看cronjobkubectl get cronjob hello -o yaml# 删除cronjobkubectl delete cronjob hellok delete -f cronjob.yaml 以下是 Kubernetes 中 Job 和 CronJob 的对比表 特性 Job CronJob 用途 一次性任务，完成即结束 定时周期性任务，按照时间计划定时运行 调度方式 手动创建或由控制器触发 按照 Cron 表达式自动周期性调度 常用场景 数据批处理、数据库迁移、一次性任务 每天备份、定时报告生成、周期性检查 配置关键字段 spec.template spec.schedule（Cron 表达式） + spec.jobTemplate 启动频率 创建后立刻启动一次 根据 schedule 定期启动 并发控制 不支持并发策略 支持 concurrencyPolicy（Allow、Forbid、Replace） 保留历史任务 无保留，任务完成后直接终结 可配置保留成功或失败任务数：successfulJobsHistoryLimit、failedJobsHistoryLimit 失败重试机制 支持 backoffLimit、restartPolicy 同样支持，作用于每次周期性运行产生的 Job 上","summary":"摘要 本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Job 介绍 k8s CronJob 介绍","date_published":"2025-07-16T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/","url":"https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/","title":"K8S 之 DaemonSet","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/\">k8s DaemonSet 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"DaemonSet-介绍\">DaemonSet 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DaemonSet(缩写为 ds) 定义了提供节点本地设施的 Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具，或者作为 add-on 的一部分。</p>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 的一些典型用法：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">在每个节点上运行集群守护进程</li>\n<li class=\"lvl-4\">在每个节点上运行日志收集守护进程</li>\n<li class=\"lvl-4\">在每个节点上运行监控守护进程</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 与 Deployment 的主要区别是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">无法自定义副本数量</li>\n<li class=\"lvl-4\">每个node上都会运行且只允许运行一个 Pod</li>\n<li class=\"lvl-4\">当有新Node加入集群时，会自动在其上部署并运行Pod副本，当Node从集群移除时，这些Pod也会被回收</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DaemonSet-管理\">DaemonSet 管理</h2>\n<h3 id=\"DaemonSet-创建\">DaemonSet 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DaemonSet 只能 通过 <code>yaml</code> 创建，不支持 <code>create</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f daemonset.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个简单的 <code>daemonset.yaml</code> 文件说明</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 DaemonSet 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（DaemonSet）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">revisionHistoryLimit:</span> <span class=\"number\">10</span>           <span class=\"comment\"># 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 DaemonSet 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">updateStrategy:</span>                    <span class=\"comment\"># 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。</span></span><br><span class=\"line\">                                     <span class=\"comment\"># 2.OnDelete：使用 OnDelete 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet Pod 之后，新的 DaemonSet Pod 才会被自动创建。</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动升级的配置</span></span><br><span class=\"line\">      <span class=\"attr\">maxSurge:</span> <span class=\"number\">0</span>                    <span class=\"comment\"># 可以超出现有 DaemonSet Pod 的最大数或最大百分比，默认是 0。与 maxUnavailable 不能同时为 0</span></span><br><span class=\"line\">      <span class=\"attr\">maxUnavailable:</span> <span class=\"number\">1</span>              <span class=\"comment\"># 更新期间不可用的 DaemonSet Pod 的最大数或最大百分比，默认是 1。与 maxSurge 不能同时为 0</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet\">查看 DaemonSet</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 DaemonSet ，默认显示 default 命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get daemonsets</span><br><span class=\"line\">kubectl get ds <span class=\"comment\"># 简称</span></span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get ds -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get ds -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 deploy 的详细信息</span></span><br><span class=\"line\">kubectl get ds -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 DaemonSet 的标签</span></span><br><span class=\"line\">kubectl get ds --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 DaemonSet 的标签进程查询</span></span><br><span class=\"line\">kubectl get ds -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 DaemonSet 的状态，当 DaemonSet 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get ds -w</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 pod、ds 的详细信息</span></span><br><span class=\"line\">$ k get pod,ds -owide</span><br><span class=\"line\">NAME              READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-6g8j8   1/1     Running   0          9m3s   10.244.126.18   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-tnvhn   1/1     Running   0          9m3s   10.244.194.89   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE    CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">daemonset.apps/nginx   2         2         2       2            2           &lt;none&gt;          9m3s   nginx        nginx    app=nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"允许-master-节点运行-pod\">允许 master 节点运行 pod</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面看到pod只在worker1和worker2上运行,而没有在master节点上运行</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Kubernetes 不允许在 master 节点上运行 Pod，这是因为master节点有污点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe node k8s-master | grep Taints</span><br><span class=\"line\">Taints:             node-role.kubernetes.io/control-plane:NoSchedule</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了能让pod运行在具有污点的节点上，我们需要为pod指定容忍度(tolerations)，实际上 DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>容忍度键名</th>\n<th>效果</th>\n<th>操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>node.kubernetes.io/not-ready</code></td>\n<td><code>NoExecute</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到不健康或未就绪的节点上，且不会被驱逐。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/unreachable</code></td>\n<td><code>NoExecute</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到不可达的节点上，且不会被驱逐。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/disk-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在磁盘压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/memory-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在内存压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/pid-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在进程数压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/unschedulable</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到标记为不可调度的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/network-unavailable</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>针对 <code>spec.hostNetwork: true</code> 的 Pod，可以被调度到网络不可用的节点上。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>增加可以运行在 master 节点的容忍度</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">tolerations:</span>                                   <span class=\"comment\"># 增加容忍度</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">&quot;node-role.kubernetes.io/control-plane&quot;</span> <span class=\"comment\"># 容忍控制平面节点</span></span><br><span class=\"line\">        <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Exists&quot;</span>                           <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">        <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span>                         <span class=\"comment\"># 污点标签</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>增加容忍度后重新运行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f daemonset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">$ k get pod,ds -o wide</span><br><span class=\"line\">NAME              READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-4gxwh   1/1     Running   0          79m   10.244.235.205   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-gx7tf   1/1     Running   0          78m   10.244.126.21    k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-sl8cc   1/1     Running   0          78m   10.244.194.92    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">daemonset.apps/nginx   3         3         3       3            3           &lt;none&gt;          3h42m   nginx        nginx    app=nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上 daemonset 创建的 pod 同样支持 nodeName，nodeSelector,affinity 等调度策略</p>\n</li>\n</ul>\n<h3 id=\"访问pod中的nginx服务\">访问pod中的nginx服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任意pod的IP，端口80</span></span><br><span class=\"line\">curl http://10.244.194.92</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet-详情\">查看 DaemonSet 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 DaemonSet 运行错误时，可以通过该命令查看 DaemonSet 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe ds &lt;ds-name&gt;</span><br><span class=\"line\">kubectl describe ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-DaemonSet\">删除 DaemonSet</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete ds &lt;ds-name&gt;</span><br><span class=\"line\">kubectl delete ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件删除</span></span><br><span class=\"line\">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet-日志\">查看 DaemonSet 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs ds/&lt;ds-name&gt;</span><br><span class=\"line\">kubectl logs ds/&lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动升级与回滚-DaemonSet\">滚动升级与回滚 DaemonSet</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对 <code>RollingUpdate</code> 类型的 <code>DaemonSet</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们修改过 <code>DaemonSet</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl set image ds/&lt;ds-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=true</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">set</span> image ds nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看滚动升级状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl rollout status ds/&lt;ds-name&gt;</span></span><br><span class=\"line\">kubectl rollout status ds nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看历史版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前面的序号表示版本号</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> ds nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看指定版本的详情</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> ds nginx --revision=1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>回滚</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回退到前一个版本</span></span><br><span class=\"line\">kubectl rollout undo ds nginx</span><br><span class=\"line\"><span class=\"comment\"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class=\"line\">kubectl rollout undo ds nginx --to-revision=1</span><br></pre></td></tr></table></figure>\n<h2 id=\"Deployment-和-DaemonSet-的对比总结\">Deployment 和 DaemonSet 的对比总结</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><strong>Deployment</strong></th>\n<th><strong>DaemonSet</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>管理一组可水平扩展的 Pod，按需副本数运行</td>\n<td>在每个（或特定）节点上运行 <strong>一个副本</strong> 的 Pod</td>\n</tr>\n<tr>\n<td><strong>常见场景</strong></td>\n<td>无状态服务、Web 服务、API、后端服务</td>\n<td>日志采集（如 fluentd）、监控（如 node-exporter）、系统守护进程</td>\n</tr>\n<tr>\n<td><strong>副本控制</strong></td>\n<td>可通过 <code>spec.replicas</code> 灵活控制副本数</td>\n<td>每个匹配的节点自动运行一个 Pod，无需设置 <code>replicas</code></td>\n</tr>\n<tr>\n<td><strong>节点分布</strong></td>\n<td>Pod 分布随机，调度器选择可用节点</td>\n<td>Pod 分布固定，<strong>每个匹配节点必跑一个 Pod</strong></td>\n</tr>\n<tr>\n<td><strong>更新策略</strong></td>\n<td><code>RollingUpdate</code>（默认）、<code>Recreate</code>，支持回滚</td>\n<td><code>RollingUpdate</code>（默认从 Kubernetes 1.6 起支持）</td>\n</tr>\n<tr>\n<td><strong>伸缩方式</strong></td>\n<td><code>kubectl scale deployment</code> 可以水平扩缩容</td>\n<td><strong>不支持手动伸缩</strong>，跟随节点变化自动伸缩</td>\n</tr>\n<tr>\n<td><strong>Pod 更新行为</strong></td>\n<td>按策略滚动更新全部副本</td>\n<td>每个节点上的 Pod 逐个滚动更新</td>\n</tr>\n<tr>\n<td><strong>调度策略</strong></td>\n<td>通过调度器分配节点，可搭配 <code>affinity</code> 使用</td>\n<td>默认调度所有节点，可用 <code>nodeSelector</code>、<code>affinity</code>、<code>taints</code> 控制</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s DaemonSet 介绍 DaemonSet 介绍 DaemonSet(缩写为 ds) 定义了提供节点本地设施的 Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具，或者作为 add-on 的一部分。 DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。 DaemonSet 的一些典型用法： 在每个节点上运行集群守护进程 在每个节点上运行日志收集守护进程 在每个节点上运行监控守护进程 DaemonSet 与 Deployment 的主要区别是： 无法自定义副本数量 每个node上都会运行且只允许运行一个 Pod 当有新Node加入集群时，会自动在其上部署并运行Pod副本，当Node从集群移除时，这些Pod也会被回收 DaemonSet 管理 DaemonSet 创建 DaemonSet 只能 通过 yaml 创建，不支持 create 创建 12# 通过 yaml 文件创建kubectl apply -f daemonset.yaml 一个简单的 daemonset.yaml 文件说明 12345678910111213141516171819202122232425apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 DaemonSet 资源kind: DaemonSet # Kubernetes 资源类型，这里是部署（DaemonSet）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下）spec: # 配置项 revisionHistoryLimit: 10 # 保留的历史版本数，默认值为 10，Deployment 和 StatefulSet 都有这个配置项。回滚时有用。 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 DaemonSet 管理哪些 Pod（标签必须与 template 中匹配） updateStrategy: # 更新策略，这里要注意这个更新策略与Deployment的属性名字不一样 type: RollingUpdate # 1.RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。 # 2.OnDelete：使用 OnDelete 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet Pod 之后，新的 DaemonSet Pod 才会被自动创建。 rollingUpdate: # 滚动升级的配置 maxSurge: 0 # 可以超出现有 DaemonSet Pod 的最大数或最大百分比，默认是 0。与 maxUnavailable 不能同时为 0 maxUnavailable: 1 # 更新期间不可用的 DaemonSet Pod 的最大数或最大百分比，默认是 1。与 maxSurge 不能同时为 0 template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称 查看 DaemonSet 12345678910111213141516171819202122232425# 查看 DaemonSet ，默认显示 default 命名空间下的 DaemonSetkubectl get daemonsetskubectl get ds # 简称# 查看 kube-system 命名空间下的 DaemonSetkubectl get ds -n kube-system# 查看所有命名空间下的 DaemonSetkubectl get ds -A# -o wide: 显示 deploy 的详细信息kubectl get ds -o wide# 显示 DaemonSet 的标签kubectl get ds --show-labels# 按 DaemonSet 的标签进程查询kubectl get ds -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 DaemonSet 的状态，当 DaemonSet 状态发生改变时，会实时显示kubectl get ds -w# 查看 pod、ds 的详细信息$ k get pod,ds -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-6g8j8 1/1 Running 0 9m3s 10.244.126.18 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-tnvhn 1/1 Running 0 9m3s 10.244.194.89 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/nginx 2 2 2 2 2 &lt;none&gt; 9m3s nginx nginx app=nginx 允许 master 节点运行 pod 上面看到pod只在worker1和worker2上运行,而没有在master节点上运行 默认情况下，Kubernetes 不允许在 master 节点上运行 Pod，这是因为master节点有污点 12$ kubectl describe node k8s-master | grep TaintsTaints: node-role.kubernetes.io/control-plane:NoSchedule 为了能让pod运行在具有污点的节点上，我们需要为pod指定容忍度(tolerations)，实际上 DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod 容忍度键名 效果 操作 描述 node.kubernetes.io/not-ready NoExecute Exists DaemonSet Pod 可以被调度到不健康或未就绪的节点上，且不会被驱逐。 node.kubernetes.io/unreachable NoExecute Exists DaemonSet Pod 可以被调度到不可达的节点上，且不会被驱逐。 node.kubernetes.io/disk-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在磁盘压力的节点上。 node.kubernetes.io/memory-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在内存压力的节点上。 node.kubernetes.io/pid-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在进程数压力的节点上。 node.kubernetes.io/unschedulable NoSchedule Exists DaemonSet Pod 可以被调度到标记为不可调度的节点上。 node.kubernetes.io/network-unavailable NoSchedule Exists 针对 spec.hostNetwork: true 的 Pod，可以被调度到网络不可用的节点上。 增加可以运行在 master 节点的容忍度 12345678910111213141516171819202122apiVersion: apps/v1kind: DaemonSetmetadata: labels: app: nginx name: nginxspec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: tolerations: # 增加容忍度 - key: &quot;node-role.kubernetes.io/control-plane&quot; # 容忍控制平面节点 operator: &quot;Exists&quot; # 操作符 effect: &quot;NoSchedule&quot; # 污点标签 containers: - image: nginx name: nginx 增加容忍度后重新运行 1234567891011kubectl apply -f daemonset.yaml# 查看$ k get pod,ds -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-4gxwh 1/1 Running 0 79m 10.244.235.205 k8s-master &lt;none&gt; &lt;none&gt;pod/nginx-gx7tf 1/1 Running 0 78m 10.244.126.21 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-sl8cc 1/1 Running 0 78m 10.244.194.92 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/nginx 3 3 3 3 3 &lt;none&gt; 3h42m nginx nginx app=nginx 实际上 daemonset 创建的 pod 同样支持 nodeName，nodeSelector,affinity 等调度策略 访问pod中的nginx服务 此时我们还没有创建 Service(后面章节会介绍)，所以只能通过 Pod 的 IP 访问 12# 任意pod的IP，端口80curl http://10.244.194.92 查看 DaemonSet 详情 当 DaemonSet 运行错误时，可以通过该命令查看 DaemonSet 的详情，找到错误原因 12kubectl describe ds &lt;ds-name&gt;kubectl describe ds &lt;ds-name&gt; -n &lt;namespace-name&gt; 删除 DaemonSet 12345kubectl delete ds &lt;ds-name&gt;kubectl delete ds &lt;ds-name&gt; -n &lt;namespace-name&gt;# 通过 yaml 文件删除kubectl delete -f &lt;yaml-file&gt; 查看 DaemonSet 日志 12kubectl logs ds/&lt;ds-name&gt;kubectl logs ds/&lt;ds-name&gt; -n &lt;namespace-name&gt; 滚动升级与回滚 DaemonSet 对 RollingUpdate 类型的 DaemonSet 的 .spec.template 的任何更新都将触发滚动更新。 我们修改过 DaemonSet 的 .spec.template，并保存后，重新运行 kubectl apply -f &lt;yaml-file&gt;即可触发滚动升级。 如果只是更新容器的镜像，也可以通过如下命令触发滚动升级 12# kubectl set image ds/&lt;ds-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=truekubectl set image ds nginx nginx=nginx:1.9.1 --record=true 查看滚动升级状态 12# kubectl rollout status ds/&lt;ds-name&gt;kubectl rollout status ds nginx 查看历史版本 1234# 前面的序号表示版本号kubectl rollout history ds nginx# 查看指定版本的详情kubectl rollout history ds nginx --revision=1 回滚 1234# 回退到前一个版本kubectl rollout undo ds nginx# 回到指定版本，这里 --to-revision=1 表示回到版本1kubectl rollout undo ds nginx --to-revision=1 Deployment 和 DaemonSet 的对比总结 特性 Deployment DaemonSet 用途 管理一组可水平扩展的 Pod，按需副本数运行 在每个（或特定）节点上运行 一个副本 的 Pod 常见场景 无状态服务、Web 服务、API、后端服务 日志采集（如 fluentd）、监控（如 node-exporter）、系统守护进程 副本控制 可通过 spec.replicas 灵活控制副本数 每个匹配的节点自动运行一个 Pod，无需设置 replicas 节点分布 Pod 分布随机，调度器选择可用节点 Pod 分布固定，每个匹配节点必跑一个 Pod 更新策略 RollingUpdate（默认）、Recreate，支持回滚 RollingUpdate（默认从 Kubernetes 1.6 起支持） 伸缩方式 kubectl scale deployment 可以水平扩缩容 不支持手动伸缩，跟随节点变化自动伸缩 Pod 更新行为 按策略滚动更新全部副本 每个节点上的 Pod 逐个滚动更新 调度策略 通过调度器分配节点，可搭配 affinity 使用 默认调度所有节点，可用 nodeSelector、affinity、taints 控制","summary":"摘要 本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s DaemonSet 介绍","date_published":"2025-07-15T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/","url":"https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/","title":"K8S 之 Deployment","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/\">k8s Deployment 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Deployment-缩写为-deploy-介绍\">Deployment(缩写为 deploy) 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在使用k8s创建容器时，我们一般不会直接创建pod，而是创建 deployment，daemonSet，StatefulSet等等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Deployment 用于管理运行一个应用负载的一组 Pod，通常适用于不保持状态的负载。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Deployment 是最常用的无状态服务控制器，由Deployment、ReplicaSet、Pod组成、支持集群扩容缩容、滚动、更新、自动维护Pod可用性及副本数量等功能，<a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/\">ReplicaSet</a>和Pod由Deployment自动管理，用户无需干预，也就是说，创建一个Deployment后，K8S会自动创建ReplicaSet，并创建指定数量的Pod。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Tcj2Px.png\" alt=\"\" width=\"1200\" height=\"600\"></p>\n</li>\n</ul>\n<h2 id=\"Deployment-管理\">Deployment 管理</h2>\n<h3 id=\"Deployment-创建\">Deployment 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>create</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 deployment</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 多副本，--replicas=3 创建3个副本</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=3</span><br><span class=\"line\"><span class=\"comment\"># -o 生成 yaml 文件, --dry-run: 不真的执行创建</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml &gt; deployment.yaml</span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个简单的 <code>deployment.yaml</code> 文件说明</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>                        <span class=\"comment\"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">strategy:</span>                          <span class=\"comment\"># 用新Pod替换现有Pod的部署策略，可省略，默认就是滚动更新</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># 默认为滚动更新策略，还可以设置为 Recreate：在创建新pod之前，先删除所有现有的pod</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动更新方式，type: RollingUpdate 时有效</span></span><br><span class=\"line\">      <span class=\"attr\">maxSurge:</span> <span class=\"number\">30</span><span class=\"string\">%</span>                  <span class=\"comment\"># 最大额外可以存在的副本数，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class=\"line\">      <span class=\"attr\">maxUnavailable:</span> <span class=\"number\">30</span><span class=\"string\">%</span>            <span class=\"comment\"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要新了解的配置项就是spec下面几个选项：</span></span><br><span class=\"line\"><span class=\"comment\"># replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</span></span><br><span class=\"line\"><span class=\"comment\"># selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</span></span><br><span class=\"line\"><span class=\"comment\"># template：模板，就是当前控制器创建pod所使用的模板，里面其实就是前一章学过的pod的定义</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 deployment 的 yaml 文件配置项帮助</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比如，这里查看用新Pod替换现有Pod的部署策略</span></span><br><span class=\"line\">$ kubectl explain deployment.spec.strategy</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">DESCRIPTION:</span><br><span class=\"line\">    The deployment strategy to use to replace existing pods with new ones.</span><br><span class=\"line\">    DeploymentStrategy describes how to replace existing pods with new ones.</span><br><span class=\"line\"></span><br><span class=\"line\">FIELDS:</span><br><span class=\"line\">  rollingUpdate\t&lt;RollingUpdateDeployment&gt;</span><br><span class=\"line\">    Rolling update config params. Present only <span class=\"keyword\">if</span> DeploymentStrategyType =</span><br><span class=\"line\">    RollingUpdate.</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">type</span>\t&lt;string&gt;</span><br><span class=\"line\">  enum: Recreate, RollingUpdate</span><br><span class=\"line\">    Type of deployment. Can be <span class=\"string\">&quot;Recreate&quot;</span> or <span class=\"string\">&quot;RollingUpdate&quot;</span>. Default is</span><br><span class=\"line\">        RollingUpdate.</span><br><span class=\"line\"></span><br><span class=\"line\">        Possible enum values:</span><br><span class=\"line\">        <span class=\"comment\"># 在创建新pod之前，先删除所有现有的pod</span></span><br><span class=\"line\">        - `<span class=\"string\">&quot;Recreate&quot;</span>` Kill all existing pods before creating new ones.</span><br><span class=\"line\">        <span class=\"comment\"># 使用滚动更新方式用新的 ReplicaSet 替换旧的 ReplicaSet更新，即逐步缩减旧的ReplicaSet并扩大新的ReplicaSet</span></span><br><span class=\"line\">        - `<span class=\"string\">&quot;RollingUpdate&quot;</span>` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">yaml 文件中，出现了 <code>metadata.labels</code>,<code>spec.selector.matchLabels</code> 以及 <code>template.metadata.labels</code>，三者是什么关系？</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">metadata.labels（Deployment 的标签）</li>\n</ol>\n<blockquote>\n<p>给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系<br>\n常用于资源分组、查找（比如：kubectl get deploy -l app=nginx）</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>   <span class=\"comment\"># 属于这个 Deployment 的“标签”，只是标识它自己</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>spec.selector.matchLabels（选择器）</p>\n</li>\n</ol>\n<blockquote>\n<p>指定 Deployment 要管理哪些 Pod<br>\n必须精确匹配 Pod 的标签<br>\n决定 Deployment 会不会“接管”某些 Pod</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>template.metadata.labels（模板中的 Pod 标签）</p>\n</li>\n</ol>\n<blockquote>\n<p>Pod 模板中定义的标签<br>\nDeployment 按这个模板创建 Pod<br>\n必须与 matchLabels 完全一致，否则会报错</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">template:</span></span><br><span class=\"line\">  <span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>   <span class=\"comment\"># Pod 的标签，必须与 selector 匹配！</span></span><br></pre></td></tr></table></figure>\n<p>🔁 关系图示意：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">├─</span> <span class=\"string\">metadata.labels</span>                <span class=\"string\">←</span> <span class=\"string\">Deployment</span> <span class=\"string\">本身的标签（非关键）</span></span><br><span class=\"line\"><span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">├─</span> <span class=\"string\">spec.selector.matchLabels</span> <span class=\"string\">─┐</span></span><br><span class=\"line\"><span class=\"string\">│</span>                             <span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">└─</span> <span class=\"string\">spec.template.metadata.labels</span> <span class=\"string\">←</span> <span class=\"string\">必须匹配</span> <span class=\"string\">selector，才能让</span> <span class=\"string\">Pod</span> <span class=\"string\">被</span> <span class=\"string\">Deployment</span> <span class=\"string\">管理</span></span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"Deployment-扩缩容\">Deployment 扩缩容</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 扩容到5个，原先有3个，这里会再创建2个</span></span><br><span class=\"line\">kubectl scale deployment nginx --replicas=5</span><br><span class=\"line\"><span class=\"comment\"># 缩容到3个，原先有5个，这里会删除2个</span></span><br><span class=\"line\">kubectl scale deployment nginx --replicas=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment\">查看 Deployment</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Deployment ，默认显示 default 命名空间下的 deployments</span></span><br><span class=\"line\">kubectl get deployments</span><br><span class=\"line\">kubectl get deploy <span class=\"comment\"># 简称</span></span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 Deployment</span></span><br><span class=\"line\">kubectl get deploy -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 Deployment</span></span><br><span class=\"line\">kubectl get deploy -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 deploy 的详细信息</span></span><br><span class=\"line\">kubectl get deployments -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 Deployment 的标签</span></span><br><span class=\"line\">kubectl get deploy --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 Deployment 的标签进程查询</span></span><br><span class=\"line\">kubectl get deploy -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 Deployment 的状态，当 Deployment 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get deploy -w</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 pod、deploy、replicaset</span></span><br><span class=\"line\">$ k get pod,deploy,rs -owide</span><br><span class=\"line\">NAME                         READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-5869d7778c-4sqwf   1/1     Running   0          105s   10.244.126.11   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-5869d7778c-kn6pg   1/1     Running   0          105s   10.244.126.12   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-5869d7778c-zkwkd   1/1     Running   0          18m    10.244.194.82   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">deployment.apps/nginx   3/3     3            3           18m   nginx        nginx    app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                               DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">replicaset.apps/nginx-5869d7778c   3         3         3       18m   nginx        nginx    app=nginx,pod-template-hash=5869d7778c</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问pod中的nginx服务\">访问pod中的nginx服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任意pod的IP，端口80</span></span><br><span class=\"line\">curl http://10.244.194.82</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment-详情\">查看 Deployment 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 Deployment 运行错误时，可以通过该命令查看 Deployment 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe deploy &lt;deploy-name&gt;</span><br><span class=\"line\">kubectl describe deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-Deployment\">删除 Deployment</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete deploy &lt;deploy-name&gt;</span><br><span class=\"line\">kubectl delete deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件删除</span></span><br><span class=\"line\">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment-日志\">查看 Deployment 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs deploy/&lt;deploy-name&gt;</span><br><span class=\"line\">kubectl logs deploy/&lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动升级与回滚-Deployment\">滚动升级与回滚 Deployment</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对 <code>RollingUpdate</code> 类型的 <code>Deployment</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们修改过 <code>Deployment</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>通过<code>kubectl edit deploy &lt;deploy-name&gt;</code>修改<code>.spec.template</code>，也会触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># set image: 这里表示要改变的是镜像， --record=true 表示记录此次操作</span></span><br><span class=\"line\"><span class=\"comment\"># kubectl set image deploy &lt;deploy-name&gt; &lt;container-name&gt;=&lt;image-name&gt;:&lt;tag&gt;</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看历史版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前面的序号表示版本号</span></span><br><span class=\"line\">$ kubectl rollout <span class=\"built_in\">history</span> deploy nginx</span><br><span class=\"line\">deployment.apps/nginx</span><br><span class=\"line\">REVISION  CHANGE-CAUSE</span><br><span class=\"line\">1         &lt;none&gt;</span><br><span class=\"line\">2         kubectl <span class=\"built_in\">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定版本的详情</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> deploy nginx --revision=1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看更新状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl rollout status deploy nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>回滚</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回退到前一个版本</span></span><br><span class=\"line\">kubectl rollout undo deploy nginx</span><br><span class=\"line\"><span class=\"comment\"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class=\"line\">kubectl rollout undo deploy nginx --to-revision=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"重启-Deployment\">重启 Deployment</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>滚动重启</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl rollout restart deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span></span><br><span class=\"line\">kubectl rollout restart deploy nginx</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Deployment 介绍 Deployment(缩写为 deploy) 介绍 在使用k8s创建容器时，我们一般不会直接创建pod，而是创建 deployment，daemonSet，StatefulSet等等。 Deployment 用于管理运行一个应用负载的一组 Pod，通常适用于不保持状态的负载。 Deployment 是最常用的无状态服务控制器，由Deployment、ReplicaSet、Pod组成、支持集群扩容缩容、滚动、更新、自动维护Pod可用性及副本数量等功能，ReplicaSet和Pod由Deployment自动管理，用户无需干预，也就是说，创建一个Deployment后，K8S会自动创建ReplicaSet，并创建指定数量的Pod。 Deployment 管理 Deployment 创建 create 创建 12345678# 创建 deploymentkubectl create deployment nginx --image=nginx# 多副本，--replicas=3 创建3个副本kubectl create deployment nginx --image=nginx --replicas=3# -o 生成 yaml 文件, --dry-run: 不真的执行创建kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml &gt; deployment.yaml# 通过 yaml 文件创建kubectl apply -f deployment.yaml 一个简单的 deployment.yaml 文件说明 1234567891011121314151617181920212223242526272829apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源kind: Deployment # Kubernetes 资源类型，这里是部署（Deployment）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下）spec: # 配置项 replicas: 3 # 副本数，表示希望运行多少个 Pod 实例 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配） strategy: # 用新Pod替换现有Pod的部署策略，可省略，默认就是滚动更新 type: RollingUpdate # 默认为滚动更新策略，还可以设置为 Recreate：在创建新pod之前，先删除所有现有的pod rollingUpdate: # 滚动更新方式，type: RollingUpdate 时有效 maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数，默认为 25% maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数，默认为 25% template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称# 需要新了解的配置项就是spec下面几个选项：# replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1# selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了# template：模板，就是当前控制器创建pod所使用的模板，里面其实就是前一章学过的pod的定义 获取 deployment 的 yaml 文件配置项帮助 12345678910111213141516171819202122# 比如，这里查看用新Pod替换现有Pod的部署策略$ kubectl explain deployment.spec.strategy## 输出结果DESCRIPTION: The deployment strategy to use to replace existing pods with new ones. DeploymentStrategy describes how to replace existing pods with new ones.FIELDS: rollingUpdate &lt;RollingUpdateDeployment&gt; Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. type &lt;string&gt; enum: Recreate, RollingUpdate Type of deployment. Can be &quot;Recreate&quot; or &quot;RollingUpdate&quot;. Default is RollingUpdate. Possible enum values: # 在创建新pod之前，先删除所有现有的pod - `&quot;Recreate&quot;` Kill all existing pods before creating new ones. # 使用滚动更新方式用新的 ReplicaSet 替换旧的 ReplicaSet更新，即逐步缩减旧的ReplicaSet并扩大新的ReplicaSet - `&quot;RollingUpdate&quot;` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one. 小贴士 yaml 文件中，出现了 metadata.labels,spec.selector.matchLabels 以及 template.metadata.labels，三者是什么关系？ metadata.labels（Deployment 的标签） 给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系 常用于资源分组、查找（比如：kubectl get deploy -l app=nginx） 123metadata: labels: app: nginx # 属于这个 Deployment 的“标签”，只是标识它自己 spec.selector.matchLabels（选择器） 指定 Deployment 要管理哪些 Pod 必须精确匹配 Pod 的标签 决定 Deployment 会不会“接管”某些 Pod 1234spec: selector: matchLabels: app: nginx template.metadata.labels（模板中的 Pod 标签） Pod 模板中定义的标签 Deployment 按这个模板创建 Pod 必须与 matchLabels 完全一致，否则会报错 1234template: metadata: labels: app: nginx # Pod 的标签，必须与 selector 匹配！ 🔁 关系图示意： 1234567Deployment│├─ metadata.labels ← Deployment 本身的标签（非关键）│├─ spec.selector.matchLabels ─┐│ │└─ spec.template.metadata.labels ← 必须匹配 selector，才能让 Pod 被 Deployment 管理 Deployment 扩缩容 1234# 扩容到5个，原先有3个，这里会再创建2个kubectl scale deployment nginx --replicas=5# 缩容到3个，原先有5个，这里会删除2个kubectl scale deployment nginx --replicas=3 查看 Deployment 12345678910111213141516171819202122232425262728# 查看 Deployment ，默认显示 default 命名空间下的 deploymentskubectl get deploymentskubectl get deploy # 简称# 查看 kube-system 命名空间下的 Deploymentkubectl get deploy -n kube-system# 查看所有命名空间下的 Deploymentkubectl get deploy -A# -o wide: 显示 deploy 的详细信息kubectl get deployments -o wide# 显示 Deployment 的标签kubectl get deploy --show-labels# 按 Deployment 的标签进程查询kubectl get deploy -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 Deployment 的状态，当 Deployment 状态发生改变时，会实时显示kubectl get deploy -w# 查看 pod、deploy、replicaset$ k get pod,deploy,rs -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-5869d7778c-4sqwf 1/1 Running 0 105s 10.244.126.11 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-5869d7778c-kn6pg 1/1 Running 0 105s 10.244.126.12 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-5869d7778c-zkwkd 1/1 Running 0 18m 10.244.194.82 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdeployment.apps/nginx 3/3 3 3 18m nginx nginx app=nginxNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORreplicaset.apps/nginx-5869d7778c 3 3 3 18m nginx nginx app=nginx,pod-template-hash=5869d7778c 访问pod中的nginx服务 此时我们还没有创建 Service(后面章节会介绍)，所以只能通过 Pod 的 IP 访问 12# 任意pod的IP，端口80curl http://10.244.194.82 查看 Deployment 详情 当 Deployment 运行错误时，可以通过该命令查看 Deployment 的详情，找到错误原因 12kubectl describe deploy &lt;deploy-name&gt;kubectl describe deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt; 删除 Deployment 12345kubectl delete deploy &lt;deploy-name&gt;kubectl delete deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;# 通过 yaml 文件删除kubectl delete -f &lt;yaml-file&gt; 查看 Deployment 日志 12kubectl logs deploy/&lt;deploy-name&gt;kubectl logs deploy/&lt;deploy-name&gt; -n &lt;namespace-name&gt; 滚动升级与回滚 Deployment 对 RollingUpdate 类型的 Deployment 的 .spec.template 的任何更新都将触发滚动更新。 我们修改过 Deployment 的 .spec.template，并保存后，重新运行 kubectl apply -f &lt;yaml-file&gt;即可触发滚动升级。 通过kubectl edit deploy &lt;deploy-name&gt;修改.spec.template，也会触发滚动升级。 如果只是更新容器的镜像，也可以通过如下命令触发滚动升级 123# set image: 这里表示要改变的是镜像， --record=true 表示记录此次操作# kubectl set image deploy &lt;deploy-name&gt; &lt;container-name&gt;=&lt;image-name&gt;:&lt;tag&gt;kubectl set image deploy nginx nginx=nginx:1.9.1 --record=true 查看历史版本 123456789# 前面的序号表示版本号$ kubectl rollout history deploy nginxdeployment.apps/nginxREVISION CHANGE-CAUSE1 &lt;none&gt;2 kubectl set image deploy nginx nginx=nginx:1.9.1 --record=true# 查看指定版本的详情kubectl rollout history deploy nginx --revision=1 查看更新状态 1kubectl rollout status deploy nginx 回滚 1234# 回退到前一个版本kubectl rollout undo deploy nginx# 回到指定版本，这里 --to-revision=1 表示回到版本1kubectl rollout undo deploy nginx --to-revision=1 重启 Deployment 滚动重启 12# kubectl rollout restart deployment &lt;deployment-name&gt; -n &lt;namespace&gt;kubectl rollout restart deploy nginx","summary":"摘要 本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Deployment 介绍","date_published":"2025-07-14T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/04/k8s-pod/","url":"https://blog.hanqunfeng.com/2025/07/04/k8s-pod/","title":"K8S 之 Pod","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/\">k8s Pod 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Pod-介绍\">Pod 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod(缩写为 po) 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 集群中的 Pod 主要有两种用法：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>\n<li class=\"lvl-4\">运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nLmg0X.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pod-管理\">Pod 管理</h2>\n<h3 id=\"Pod-创建\">Pod 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>run</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl run nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 输出 yaml</span></span><br><span class=\"line\">kubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml</span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f pod.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>pod 中至少包含两个容器，一个是业务容器，比如这里的 nginx，另一个是 <code>pause</code> 容器，负责共享容器的网络，进程，存储等资源。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 crictl ps 是看不到 pause 容器的，我们可以使用 ctr 命令查看，ctr 是 containerd 的命令行工具</span></span><br><span class=\"line\">ctr --namespace=k8s.io c <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看容器所属的pod</span></span><br><span class=\"line\">ctr --namespace=k8s.io c info &lt;container-id&gt; | grep <span class=\"string\">&#x27;pod.name&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"pod-yaml-文件说明\"><code>pod.yaml</code> 文件说明</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为 Pod 不支持扩缩容，所以日常使用时一般不会直接创建 Pod，而是创建 <code>Deployment</code>, <code>DaemonSet</code>等这些工作负载资源，这些后面会介绍到。</p>\n</li>\n<li class=\"lvl-2\">\n<p>但我们这里还是要重点介绍一下 Pod 的 yaml 文件格式，因为它是后面所有资源创建的基础。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个最基础的 Pod 配置如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                   <span class=\"comment\"># 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>                        <span class=\"comment\"># 必填。资源类型：Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                        <span class=\"comment\"># 必填。元数据，包含 Pod 的名称、命名空间、标签、注解等信息</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                    <span class=\"comment\"># 必填。Pod 的名称，命名空间中唯一</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                            <span class=\"comment\"># 必填。资源的特性描述（规约），定义Pod具体行为的部分</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>                    <span class=\"comment\"># 必填。容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 必填。容器使用的镜像</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 必填。容器名称，在同一个 Pod 内必须唯一</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod是用来配置容器的，我们在学习docker时知道，容器有非常多的配置项，比如端口、网络、存储等，而 pod 的配置项更丰富。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个Pod的配置主要包含两大部分：<code>metadata</code> 和 <code>spec</code>，每一项中包含的配置项非常多，这里只对常用的配置项进行说明，若要查看每个配置项的说明可以通过如下命令获取：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod开头，配置项以 . 连接，例如：</span></span><br><span class=\"line\">kubectl explain pod.metadata</span><br><span class=\"line\">kubectl explain pod.metadata.labels</span><br><span class=\"line\">kubectl explain pod.spec</span><br><span class=\"line\">kubectl explain pod.spec.containers</span><br><span class=\"line\">kubectl explain pod.spec.containers.ports</span><br></pre></td></tr></table></figure>\n<h4 id=\"metadata\">metadata</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>metadata 是 Pod 的元数据，比如 Pod 的名称、命名空间、标签、注解等。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span>                 <span class=\"comment\"># 元数据部分</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp-pod</span>         <span class=\"comment\"># Pod 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>      <span class=\"comment\"># Pod 所在的命名空间，默认是 default</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span>                 <span class=\"comment\"># 标签，用于选择器、管理、分组</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">tier:</span> <span class=\"string\">frontend</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span>            <span class=\"comment\"># 注解，用于添加非结构化元信息</span></span><br><span class=\"line\">    <span class=\"attr\">description:</span> <span class=\"string\">&quot;A sample pod for demonstration&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec\">spec</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>spec 描述了 Pod 的配置信息，包括 Pod 的容器、存储、网络、资源限制、调度策略等</p>\n</li>\n</ul>\n<h5 id=\"spec-containers\">spec.containers</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>containers 描述了 Pod 中容器的配置信息，包括镜像、启动命令、环境变量、资源限制、卷挂载等</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                      <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>              <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>           <span class=\"comment\">#必选，容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">string</span>          <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> [ <span class=\"string\">Always|Never|IfNotPresent</span> ]   <span class=\"comment\">#获取镜像的策略，当镜像标签为 latest 时默认值为 Always，否则为 IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]      <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">string</span>]         <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\">    <span class=\"attr\">workingDir:</span> <span class=\"string\">string</span>     <span class=\"comment\">#容器的工作目录，如果为指定，则默认为镜像中的配置</span></span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>          <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">string</span>    <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"string\">boolean</span>    <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span>                 <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#端口的名称</span></span><br><span class=\"line\">      <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>    <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\">      <span class=\"attr\">hostPort:</span> <span class=\"string\">int</span>        <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>                   <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"string\">string</span>        <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span>             <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\">      <span class=\"attr\">limits:</span>              <span class=\"comment\">#资源限制的设置(上限)</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>        <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\">      <span class=\"attr\">requests:</span>            <span class=\"comment\">#资源请求的设置(下限)</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>        <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存请求,容器启动的初始可用数量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                         <span class=\"comment\"># Pod 的具体规范</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>                 <span class=\"comment\"># Pod 中的容器数组，可以有多个容器</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp-container</span>   <span class=\"comment\"># 容器名称</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.25</span>       <span class=\"comment\"># 使用的镜像</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span>                  <span class=\"comment\"># 容器开放的端口</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>   <span class=\"comment\"># 容器内部端口，只是声明性的字段，不具有决定作用</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span>                    <span class=\"comment\"># 环境变量配置</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ENVIRONMENT</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">production</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span>              <span class=\"comment\"># 资源限制和请求</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;512Mi&quot;</span>     <span class=\"comment\"># 最大内存限制</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>            <span class=\"comment\"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 1000m        # 1000m = 1 核</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;256Mi&quot;</span>     <span class=\"comment\"># 初始分配内存</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;0.5&quot;</span>          <span class=\"comment\"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span>           <span class=\"comment\"># 挂载到容器的卷</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app-storage</span>   <span class=\"comment\"># 卷名称，需要和 volumes 中定义的卷名称一致</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span> <span class=\"comment\"># 挂载到容器的目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-containers-command-args\">spec.containers.command | args</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器启动时执行的命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，容器启动时，会从镜像中获取命令并执行，如果这里配置了命令，则容器启动时，会执行这里的命令，而不是镜像中的命令</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>或者</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>或者</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">|</span>                  <span class=\"comment\"># 使用 | 符号，表示多行输入</span></span><br><span class=\"line\">        <span class=\"string\">while</span> <span class=\"literal\">true</span><span class=\"string\">;</span> <span class=\"string\">do</span></span><br><span class=\"line\">          <span class=\"string\">echo</span> <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">          <span class=\"string\">sleep</span> <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"string\">done</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-restartPolicy\">spec.restartPolicy</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指在系统发生故障或意外停机时，系统或应用程序如何处理和恢复的策略</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Always：总是重启</li>\n<li class=\"lvl-4\">OnFailure：失败时重启</li>\n<li class=\"lvl-4\">Never：不重启</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">restartPolicy:</span> <span class=\"string\">OnFailure</span> <span class=\"comment\">#失败时重启</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-terminationGracePeriodSeconds\">spec.terminationGracePeriodSeconds</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 删除时，系统给 Pod 留的时间，用于完成清理工作</p>\n</li>\n<li class=\"lvl-2\">\n<p>宽限期为避免服务突然中断,造成事物不一致的问题,当容器运行完自己的任务后,会等待一段时间,然后优雅的退出</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认值为 30s，单位为秒</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">terminationGracePeriodSeconds:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-volumes\">spec.volumes</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 中的卷（volumes）是为了在容器之间共享数据，或将数据从容器持久化到外部存储。</p>\n</li>\n</ul>\n<h5 id=\"emptyDir（最简单，Pod-生命周期内有效）\">emptyDir（最简单，Pod 生命周期内有效）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>emptyDir 卷是一个没有名字的临时目录，Pod 创建时创建，Pod 删除时删除。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">html-volume</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">html-volume</span></span><br><span class=\"line\">      <span class=\"attr\">emptyDir:</span> &#123;&#125;  <span class=\"comment\"># 表示一个空目录，在 Pod 生命周期内有效</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"hostPath（挂载宿主机路径）\">hostPath（挂载宿主机路径）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用于测试或非常了解宿主机结构的场景。生产不推荐。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mydata</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/tmp/data</span>        <span class=\"comment\"># 宿主机路径</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">DirectoryOrCreate</span>  <span class=\"comment\"># 如果目录不存在就创建</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"configMap（挂载配置文件）\">configMap（挂载配置文件）</h5>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config</span></span><br><span class=\"line\">      <span class=\"attr\">configMap:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">my-configmap</span>   <span class=\"comment\"># 需提前创建 ConfigMap，这个后面会介绍</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"使用-PVC（挂载持久化存储）\">使用 PVC（挂载持久化存储）</h5>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">persistent-storage</span></span><br><span class=\"line\">      <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">        <span class=\"attr\">claimName:</span> <span class=\"string\">mypvc</span>  <span class=\"comment\"># PVC 名称，需要提前创建，这个后面会介绍</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-tolerations-Pod容忍策略\">spec.tolerations: Pod容忍策略</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>tolerations 是 Kubernetes Pod 中用来“容忍”某些 Node 节点的污点（Taints） 的字段。它允许 Pod 被调度到带有相应 Taint 的节点上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Pod 会因为 Node 节点的 Taint 而不被调度。</p>\n</li>\n<li class=\"lvl-2\">\n<p>比如一个 Node 有 NoSchedule 类型的 taint，而 Pod 没有设置对应的 toleration，该 Pod 就不会被调度到这个 Node 上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例： 容忍 key=value:NoSchedule 的 Taint</p>\n</li>\n<li class=\"lvl-2\">\n<p>假设某节点打了如下污点（Taint）：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl taint nodes node1 key=value:NoSchedule</span><br><span class=\"line\"><span class=\"comment\"># NoSchedule\t不调度到该节点，除非容忍策略显式允许</span></span><br><span class=\"line\"><span class=\"comment\"># PreferNoSchedule\t尽量不调度到该节点，但非强制，即可能会被调度</span></span><br><span class=\"line\"><span class=\"comment\"># NoExecute\t不仅不调度到该节点，还会把现有 Pod 驱逐出去，除非设置容忍时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># key=value 是用来 区分不同类型的污点的。比如：</span></span><br><span class=\"line\"><span class=\"comment\">#   你可能给 node1 设置 env=prod:NoSchedule</span></span><br><span class=\"line\"><span class=\"comment\">#   给 node2 设置 gpu=true:NoSchedule</span></span><br><span class=\"line\"><span class=\"comment\">#   给 node3 设置 arch=arm64:NoSchedule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这些都属于不同的“原因”或“标签”，这样你可以：</span></span><br><span class=\"line\"><span class=\"comment\">#   用不同的 toleration 来容忍不同的 taint；</span></span><br><span class=\"line\"><span class=\"comment\">#   精准控制某些 Pod 只能被调度到符合条件的节点。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容忍该 Taint</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">tolerate-example</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">tolerations:</span>        <span class=\"comment\"># 定义容忍策略</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Equal&quot;</span> <span class=\"comment\"># 匹配方式，必选（Equal:精确匹配 key 和 value。Exists:只匹配 key 是否存在，不关心 value 是什么）</span></span><br><span class=\"line\">    <span class=\"attr\">key:</span> <span class=\"string\">&quot;key&quot;</span>        <span class=\"comment\"># 设置键值对的key，为空代表任意键值对</span></span><br><span class=\"line\">    <span class=\"attr\">value:</span> <span class=\"string\">&quot;value&quot;</span>    <span class=\"comment\"># 设置values的值，</span></span><br><span class=\"line\">    <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span> <span class=\"comment\"># 设置容忍的标签，为空代表所有污点标签</span></span><br><span class=\"line\">    <span class=\"attr\">tolerationSeconds:</span> <span class=\"number\">60</span> <span class=\"comment\"># 容忍时间，这里Pod 最多可停留 60 秒，之后仍会被驱逐，不设置表示永久容忍</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes 中，effect 有 三个可选值：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><code>effect</code> 值</th>\n<th>含义</th>\n<th>常见用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>NoSchedule</code></td>\n<td>节点上的污点会阻止 Pod 被调度到该节点，除非 Pod 有相应的 toleration。</td>\n<td><strong>最常用</strong>，例如 Master 节点的容忍。</td>\n</tr>\n<tr>\n<td><code>PreferNoSchedule</code></td>\n<td><strong>倾向于不调度</strong> 到该节点，但不是强制性的，调度器会尽量避免把 Pod 安排到该节点。</td>\n<td>用于软约束，尽量不调度。</td>\n</tr>\n<tr>\n<td><code>NoExecute</code></td>\n<td>不仅不调度新 Pod 到该节点，还会把当前节点上没有相应容忍度的 Pod 驱逐出去（<code>eviction</code>）。</td>\n<td>节点异常自动驱逐，比如 not-ready。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"spec-resources\">spec.resources</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod资源配额可以限制命名空间或项目中Pod使用的CPU、内存、存储等资源用量</p>\n</li>\n<li class=\"lvl-2\">\n<p>CPU资源的约束和请求以豪核（m）为单位。在k8s中1m是最小的调度单元，CPU的一个核心可以看作1000m</p>\n</li>\n</ul>\n<blockquote>\n<p>如果你有2颗cpu，且每CPU为4核心，那么你的CPU资源总量就是8000</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                     <span class=\"comment\"># Pod 的具体规范</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>             <span class=\"comment\"># Pod 中的容器数组，可以有多个容器</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp-container</span>    <span class=\"comment\"># 容器名称</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.25</span>        <span class=\"comment\"># 使用的镜像</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span>              <span class=\"comment\"># 资源限制和请求</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;512Mi&quot;</span>     <span class=\"comment\"># 最大内存限制</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>            <span class=\"comment\"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 1000m          # 1000m = 1 核</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;256Mi&quot;</span>     <span class=\"comment\"># 初始分配内存</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;0.5&quot;</span>          <span class=\"comment\"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果有大量的容器需要设置资源配额，为每个Pod设置资源配额策略不方便且不好管理</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以以名称空间为单位（namespace），限制其资源的使用与创建，在该名称空间中创建的容器都会受到规则的限制。</p>\n</li>\n</ul>\n<h5 id=\"LimitRange\">LimitRange</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对单个Pod内存、CPU进行配额</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">LimitRange</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mem-cpu-limit-range</span>          <span class=\"comment\"># LimitRange 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">demo</span>                    <span class=\"comment\"># 生效的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">limits:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Container</span>                  <span class=\"comment\"># 表示限制的是每个容器（也可设置为 Pod）</span></span><br><span class=\"line\">    <span class=\"attr\">default:</span>                         <span class=\"comment\"># 容器未指定 resources.limits 时使用的默认值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">500m</span>                      <span class=\"comment\"># 默认限制 CPU 为 0.5 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">512Mi</span>                  <span class=\"comment\"># 默认限制内存为 512 MiB</span></span><br><span class=\"line\">    <span class=\"attr\">defaultRequest:</span>                  <span class=\"comment\"># 容器未指定 resources.requests 时使用的默认请求值，初始值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">100m</span>                      <span class=\"comment\"># 默认请求 CPU 为 0.1 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">128Mi</span>                  <span class=\"comment\"># 默认请求内存为 128 MiB</span></span><br><span class=\"line\">    <span class=\"attr\">max:</span>                             <span class=\"comment\"># 容器可设置的最大限制值，即 容器中指定的 resources.limits 的最大允许值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>                       <span class=\"comment\"># 最大可使用 CPU 为 1 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">1Gi</span>                    <span class=\"comment\"># 最大可使用内存为 1 GiB</span></span><br><span class=\"line\">    <span class=\"attr\">min:</span>                             <span class=\"comment\"># 容器可设置的最小请求值，，即 容器中指定的 resources.requests 的最小允许值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">50m</span>                       <span class=\"comment\"># 最小请求 CPU 为 0.05 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">64Mi</span>                   <span class=\"comment\"># 最小请求内存为 64 MiB</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ResourceQuota\">ResourceQuota</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>限制整个 namespace 的资源总量</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ResourceQuota</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">compute-resources</span>           <span class=\"comment\"># ResourceQuota 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">demo</span>                   <span class=\"comment\"># 生效的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">hard:</span>                             <span class=\"comment\"># 定义各类资源的总配额上限</span></span><br><span class=\"line\">    <span class=\"attr\">pods:</span> <span class=\"string\">&quot;10&quot;</span>                      <span class=\"comment\"># 该命名空间最多允许创建 10 个 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">requests.cpu:</span> <span class=\"string\">&quot;2&quot;</span>               <span class=\"comment\"># 所有 Pod 的 requests.cpu 总和最多为 2 核</span></span><br><span class=\"line\">    <span class=\"attr\">requests.memory:</span> <span class=\"string\">4Gi</span>            <span class=\"comment\"># 所有 Pod 的 requests.memory 总和最多为 4 GiB</span></span><br><span class=\"line\">    <span class=\"attr\">limits.cpu:</span> <span class=\"string\">&quot;4&quot;</span>                 <span class=\"comment\"># 所有 Pod 的 limits.cpu 总和最多为 4 核</span></span><br><span class=\"line\">    <span class=\"attr\">limits.memory:</span> <span class=\"string\">8Gi</span>              <span class=\"comment\"># 所有 Pod 的 limits.memory 总和最多为 8 GiB</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-priorityClassName\">spec.priorityClassName</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 的优先级，优先级就是为了保证重要的Pod被优先调度并运行</p>\n</li>\n<li class=\"lvl-2\">\n<p>优先级策略：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">非抢占优先：指的是在调度阶段优先进行调度分配，一旦容器调度完成就不可以抢占，资源不足时，只能等待</li>\n<li class=\"lvl-4\">抢占优先：强制调度一个Pod，如果资源不足无法被调度，调度程序会抢占（删除）较低优先级的Pod的资 源，来保证高优先级Pod的运行</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>创建优先级</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PriorityClass</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">scheduling.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">high-non</span> <span class=\"comment\"># 优先级名称</span></span><br><span class=\"line\"><span class=\"attr\">preemptionPolicy:</span> <span class=\"string\">Never</span> <span class=\"comment\"># 策略：非抢占，PreemptLowerPriority:抢占（删除）较低优先级的Pod的资源，保证高优先级Pod的运行</span></span><br><span class=\"line\"><span class=\"attr\">value:</span> <span class=\"number\">1000</span> <span class=\"comment\"># 优先级，可以设置小于10亿的整数值，值越大，优先级越高，默认优先级0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeSelector:</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/hostname:</span> <span class=\"string\">node01</span> <span class=\"comment\"># 指定匹配具有当前标签的节点</span></span><br><span class=\"line\">  <span class=\"attr\">priorityClassName:</span> <span class=\"string\">high-non</span> <span class=\"comment\"># 优先级名称</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-nodeName-nodeSelector-Pod调度策略\">spec.nodeName | nodeSelector :Pod调度策略</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在k8s中，调度是将Pod分配到合适的节点并运行的过程，kube-scheduler是默认调度器，是集群的核心组件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>调度器通过k8s的监测（Watch）机制来发现集群中尚未被调度到节点上的Pod，调度器依据调度原则将Pod分配到一个合适的节点上运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>调度器给一个pod做调度包含两个步骤： 过滤 和 打分</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">过滤：首先要筛选出满足Pod所有的资源请求的节点，这里包含计算资源、内存、存储、网络、端口号等等，如果没有节点能满足Pod的需求，Pod将一直停留在Pending状态，直到调度器能够找到合适的节点运行它</li>\n<li class=\"lvl-4\">打分：调度器将节点按照打分规则进行打分，然后按照分数进行排序，将分数最高的节点作为Pod的运行节点。如果存在多个得分最高的节点，调度器会从中随机选取一个。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Pod 支持两种调度策略：<code>nodeName</code> 和 <code>nodeSelector</code></p>\n</li>\n</ul>\n<h5 id=\"spec-nodeName\">spec.nodeName</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指定 Pod 运行在指定名称的节点上</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeName:</span> <span class=\"string\">node-1</span> <span class=\"comment\"># 基于节点名进行调度</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myos:httpd</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-nodeSelector\">spec.nodeSelector</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点选择器，基于节点的标签进行调度</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeSelector:</span>         <span class=\"comment\"># 基于节点标签进行调度</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/hostname:</span> <span class=\"string\">node-2</span>  <span class=\"comment\"># 标签</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myos:httpd</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为节点设置标签</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 所有资源都可以设置标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;=&lt;标签value&gt;</span></span><br><span class=\"line\">kubectl label nodes node-2 kubernetes.io/hostname=node-2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;-</span></span><br><span class=\"line\"><span class=\"comment\"># 这里注意，删除标签就是在标签key后加上 - 符号</span></span><br><span class=\"line\">kubectl label nodes node-2 kubernetes.io/hostname-</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看资源标签：kubectl get &lt;资源&gt; --show-labels</span></span><br><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 查看指定节点的标签</span></span><br><span class=\"line\">kubectl get nodes node-2 --show-labels</span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-affinity\">spec.affinity</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点亲和性，用于控制 Pod 调度到具有特定标签的节点上，是 nodeSelector 的增强版本</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>功能</th>\n<th>示例用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node Affinity</td>\n<td>控制调度到有指定标签的节点</td>\n<td>SSD、高内存节点</td>\n</tr>\n<tr>\n<td>Pod Affinity</td>\n<td>调度到和某些 Pod 一起的节点</td>\n<td>微服务协同部署</td>\n</tr>\n<tr>\n<td>Pod Anti-Affinity</td>\n<td>避免和某些 Pod 一起的节点</td>\n<td>高可用副本分散部署</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"节点亲和性-Node-Affinity\">节点亲和性(Node Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 只能调度到具有标签 <code>disktype=ssd</code> 的节点上</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">node-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">affinity:</span>   <span class=\"comment\"># 亲和性配置</span></span><br><span class=\"line\">    <span class=\"attr\">nodeAffinity:</span> <span class=\"comment\"># 节点亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class=\"comment\"># 在调度期间必须满足，运行中忽略变化（即调度后标签变了不会驱逐 Pod）。也可以设置为 preferredDuringSchedulingIgnoredDuringExecution，表示节点亲和性优先级高，但不强制要求必须满足</span></span><br><span class=\"line\">        <span class=\"attr\">nodeSelectorTerms:</span> <span class=\"comment\"># 节点选择器</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span> <span class=\"comment\"># 匹配表达式，支持复杂逻辑，比如 In、NotIn、Exists、DoesNotExist、Gt、Lt。</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">disktype</span> <span class=\"comment\"># 键</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span> <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span> <span class=\"comment\"># 值</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">ssd</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Pod-亲和性-Pod-Affinity\">Pod 亲和性(Pod Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 会被调度到 与标签为 app=web 的 Pod 所在同一节点（或拓扑层）上。</p>\n</li>\n</ul>\n<blockquote>\n<p>通常用于需要紧密协作的服务部署在一起（如同一机器内通信）。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">affinity:</span></span><br><span class=\"line\">    <span class=\"attr\">podAffinity:</span>  <span class=\"comment\"># pod 亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">labelSelector:</span>  <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">          <span class=\"attr\">matchExpressions:</span> <span class=\"comment\"># 标签选择条件</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app</span> <span class=\"comment\"># 键</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span> <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span>  <span class=\"comment\"># 值</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">topologyKey:</span> <span class=\"string\">&quot;kubernetes.io/hostname&quot;</span> <span class=\"comment\"># 拓扑键，表示“同一主机”</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Pod-反亲和性-Pod-Anti-Affinity\">Pod 反亲和性(Pod Anti-Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>表示不能和 app=web 的 Pod 在同一节点上</p>\n</li>\n</ul>\n<blockquote>\n<p>常用于高可用部署，避免多个副本部署在同一个节点。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod-anti-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">affinity:</span></span><br><span class=\"line\">    <span class=\"attr\">podAntiAffinity:</span> <span class=\"comment\"># Pod 反亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">labelSelector:</span></span><br><span class=\"line\">          <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">topologyKey:</span> <span class=\"string\">&quot;kubernetes.io/hostname&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"节点亲和性-Node-Affinity-两种策略的对比\">节点亲和性 (Node Affinity) 两种策略的对比</h5>\n<table>\n<thead>\n<tr>\n<th>策略字段</th>\n<th>含义</th>\n<th>行为特点</th>\n<th>场景适用</th>\n<th>是否强制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td>\n<td><strong>“必须满足”亲和性规则</strong></td>\n<td>Pod <strong>调度时必须满足条件</strong>，不满足则不调度；调度后节点变化不触发驱逐</td>\n<td>硬性约束，比如必须调度到有 GPU 的节点</td>\n<td>✅ 强制</td>\n</tr>\n<tr>\n<td><code>preferredDuringSchedulingIgnoredDuringExecution</code></td>\n<td><strong>“尽量满足”亲和性规则</strong></td>\n<td>Pod <strong>调度时优先考虑满足条件的节点</strong>，但条件不满足时仍然可以调度到其他节点；调度后同样不会强制迁移</td>\n<td>软性倾向，比如尽量调度到 SSD 节点，但实在没有也可调度</td>\n<td>❌ 非强制</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"spec-securityContext-设置安全上下文\">spec.securityContext: 设置安全上下文</h4>\n<h5 id=\"runAsUser-设置运行用户\">runAsUser: 设置运行用户</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认情况下容器都是以root用户运行的，但是很多应用需要以非root用户运行，比如 Elasticsearch 。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod1</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">runAsUser:</span> <span class=\"number\">1000</span>   <span class=\"comment\"># 设置运行用户，这个UID可以不存在</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"privileged-是否以特权方式运行\">privileged: 是否以特权方式运行</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器与宿主机是共享内核的，默认情况下，容器用户是不允许修改内核参数的，但是可以通过设置 <code>privileged: true</code> 来允许容器以特权方式运行。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">privileged:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># 特权方式运行，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"allowPrivilegeEscalation-是否可以提权（SUID）\">allowPrivilegeEscalation: 是否可以提权（SUID）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>s位：当某可执行命令的所有者的位置上有s位时，那么当普通用户执行这个命令时将具有所有者的权限。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">allowPrivilegeEscalation:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># 提权运行，可以使用suid，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Pod\">查看 Pod</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Pod，默认显示 default 命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods</span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息</span></span><br><span class=\"line\">kubectl get pods -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 Pod 的详细信息，输出为 json/yaml 格式</span></span><br><span class=\"line\">kubectl get pods -o json/yaml</span><br><span class=\"line\"><span class=\"comment\"># 显示 Pod 的标签</span></span><br><span class=\"line\">kubectl get pod --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 Pod 的标签进程查询</span></span><br><span class=\"line\">kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get pods -w</span><br><span class=\"line\"><span class=\"comment\">## 状态类型</span></span><br><span class=\"line\">- Pending: Pod 尚未就绪</span><br><span class=\"line\">- ContainerCreating: Pod 正在创建容器</span><br><span class=\"line\">- Running: Pod 正在运行</span><br><span class=\"line\">- Error: Pod 运行错误</span><br><span class=\"line\">- Terminating: Pod 正在删除</span><br><span class=\"line\">- Completed: Pod 执行完成</span><br><span class=\"line\">- Failed: Pod中的所有容器至少有一个容器退出是非0状态</span><br><span class=\"line\">- Unkown: 无法正常获取Pod对象的状态信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Pod-详情\">查看 Pod 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe pod &lt;pod-name&gt;</span><br><span class=\"line\">kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程</span></span><br><span class=\"line\">Events:</span><br><span class=\"line\">  Type    Reason     Age        From               Message</span><br><span class=\"line\">  ----    ------     ----       ----               -------</span><br><span class=\"line\">  <span class=\"comment\"># 被调度器分配到 k8s-worker2 节点</span></span><br><span class=\"line\">  Normal  Scheduled  4s         default-scheduler  Successfully assigned default/nginx to k8s-worker2</span><br><span class=\"line\">  <span class=\"comment\"># 开始拉取镜像</span></span><br><span class=\"line\">  Normal  Pulling    &lt;invalid&gt;  kubelet            Pulling image <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># 镜像拉取成功</span></span><br><span class=\"line\">  Normal  Pulled     &lt;invalid&gt;  kubelet            Successfully pulled image <span class=\"string\">&quot;nginx&quot;</span> <span class=\"keyword\">in</span> 2.067s (2.067s including waiting). Image size: 72225394 bytes.</span><br><span class=\"line\">  <span class=\"comment\"># 开始创建容器</span></span><br><span class=\"line\">  Normal  Created    &lt;invalid&gt;  kubelet            Created container: nginx</span><br><span class=\"line\">  <span class=\"comment\"># 容器启动成功</span></span><br><span class=\"line\">  Normal  Started    &lt;invalid&gt;  kubelet            Started container nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入容器\">进入容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it nginx  -- /bin/bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-Pod\">删除 Pod</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pod &lt;pod-name&gt;</span><br><span class=\"line\">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制删除</span></span><br><span class=\"line\"><span class=\"comment\">## 1.移除 Pod 上的 Finalizers</span></span><br><span class=\"line\"><span class=\"comment\">## finalizers 是 Kubernetes 对象上的一个字段，用来告诉 Kubernetes，在删除我之前，请先做一些清理工作（如释放资源、通知外部系统等），等我自己删掉 finalizer 后，你才能真正删除我。</span></span><br><span class=\"line\">kubectl patch pod &lt;pod-name&gt; \\</span><br><span class=\"line\">  -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:[]&#125;&#125;&#x27;</span> --<span class=\"built_in\">type</span>=merge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 2.强制删除</span></span><br><span class=\"line\">kubectl delete pod &lt;pod-name&gt; --force --grace-period=0 --<span class=\"built_in\">wait</span>=<span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --force: 强制删除，比如遇到了 pod 处于 Terminating 状态，此时无法删除，可以使用 --force 参数强制删除</span></span><br><span class=\"line\"><span class=\"comment\"># --grace-period=0: 强制删除的等待时间，默认是 30 秒，设置为 0 表示立即删除</span></span><br><span class=\"line\"><span class=\"comment\"># --wait=false: 删除完成后是否等待 Pod 完全删除，比较适合脚本中使用</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>长时间处于 Terminating 状态的 Pod，这类 Pod 大概率是由于所在节点异常（失联、被重装、或 kubelet 停止），导致 Kubernetes 控制面无法与该 Pod 对应的 kubelet 通信完成删除操作，从而卡在 Terminating 状态，其实它已经死了，但 etcd 里的记录一直保留着。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 查看 Pod 日志</span><br><span class=\"line\">```bash</span><br><span class=\"line\">kubectl logs &lt;pod-name&gt;</span><br><span class=\"line\">kubectl logs pod/&lt;pod-name&gt;</span><br><span class=\"line\">kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问-Pod\">访问 Pod</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们刚刚创建了一个nginx的pod，该如何访问呢？</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取pod的ip</span></span><br><span class=\"line\">$ k get pod -o wide</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE   IP             NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">nginx   1/1     Running   0          12m   10.244.126.8   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在任意节点上访问，nginx 默认端口是80</span></span><br><span class=\"line\">$ curl 10.244.126.8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问</p>\n</li>\n</ul>\n<h3 id=\"一个-Pod-运行多个容器\">一个 Pod 运行多个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 文件</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">multi-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">shareProcessNamespace:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 允许相同pod中多个容器共享进程空间，即在一个容器里可以看到另一个容器中的进程，默认值为 false</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">tomcat</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">tomcat</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 pod</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f multi_pod.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看运行结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里看到，READY 里有两个，表示两个容器都运行成功</span></span><br><span class=\"line\">$ kubectl get pods -owide</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">multi-pod   2/2     Running   0          118s   10.244.194.81   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问nginx和tomcat</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 访问nginx，ngxin默认端口是80</span></span><br><span class=\"line\">curl http://10.244.194.81</span><br><span class=\"line\"><span class=\"comment\"># 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常</span></span><br><span class=\"line\">curl http://10.244.194.81:8080</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入容器执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入nginx容器，-c 指定容器名称</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it multi-pod -c nginx -- /bin/bash</span><br><span class=\"line\"><span class=\"comment\">## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享网络和存储</span></span><br><span class=\"line\">curl http://localhost:8080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入tomcat容器</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it multi-pod -c tomcat -- /bin/bash</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Pod 介绍 Pod 介绍 Pod(缩写为 po) 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。 Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Kubernetes 集群中的 Pod 主要有两种用法： 运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。 运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。 Pod 管理 Pod 创建 run 创建 12345kubectl run nginx --image=nginx# 输出 yamlkubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml# 通过 yaml 文件创建kubectl apply -f pod.yaml pod 中至少包含两个容器，一个是业务容器，比如这里的 nginx，另一个是 pause 容器，负责共享容器的网络，进程，存储等资源。 1234# 通过 crictl ps 是看不到 pause 容器的，我们可以使用 ctr 命令查看，ctr 是 containerd 的命令行工具ctr --namespace=k8s.io c ls# 查看容器所属的podctr --namespace=k8s.io c info &lt;container-id&gt; | grep &#x27;pod.name&#x27; pod.yaml 文件说明 因为 Pod 不支持扩缩容，所以日常使用时一般不会直接创建 Pod，而是创建 Deployment, DaemonSet等这些工作负载资源，这些后面会介绍到。 但我们这里还是要重点介绍一下 Pod 的 yaml 文件格式，因为它是后面所有资源创建的基础。 一个最基础的 Pod 配置如下： 12345678apiVersion: v1 # 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1kind: Pod # 必填。资源类型：Podmetadata: # 必填。元数据，包含 Pod 的名称、命名空间、标签、注解等信息 name: nginx # 必填。Pod 的名称，命名空间中唯一spec: # 必填。资源的特性描述（规约），定义Pod具体行为的部分 containers: # 必填。容器列表 - image: nginx # 必填。容器使用的镜像 name: nginx # 必填。容器名称，在同一个 Pod 内必须唯一 Pod是用来配置容器的，我们在学习docker时知道，容器有非常多的配置项，比如端口、网络、存储等，而 pod 的配置项更丰富。 一个Pod的配置主要包含两大部分：metadata 和 spec，每一项中包含的配置项非常多，这里只对常用的配置项进行说明，若要查看每个配置项的说明可以通过如下命令获取： 123456# pod开头，配置项以 . 连接，例如：kubectl explain pod.metadatakubectl explain pod.metadata.labelskubectl explain pod.speckubectl explain pod.spec.containerskubectl explain pod.spec.containers.ports metadata metadata 是 Pod 的元数据，比如 Pod 的名称、命名空间、标签、注解等。 12345678metadata: # 元数据部分 name: myapp-pod # Pod 的名称 namespace: default # Pod 所在的命名空间，默认是 default labels: # 标签，用于选择器、管理、分组 app: myapp tier: frontend annotations: # 注解，用于添加非结构化元信息 description: &quot;A sample pod for demonstration&quot; spec spec 描述了 Pod 的配置信息，包括 Pod 的容器、存储、网络、资源限制、调度策略等 spec.containers containers 描述了 Pod 中容器的配置信息，包括镜像、启动命令、环境变量、资源限制、卷挂载等 123456789101112131415161718192021222324252627spec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [ Always|Never|IfNotPresent ] #获取镜像的策略，当镜像标签为 latest 时默认值为 Always，否则为 IfNotPresent command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录，如果为指定，则默认为镜像中的配置 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口的名称 containerPort: 80 #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置(上限) cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置(下限) cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存请求,容器启动的初始可用数量 示例 123456789101112131415161718192021spec: # Pod 的具体规范 containers: # Pod 中的容器数组，可以有多个容器 - name: myapp-container # 容器名称 image: nginx:1.25 # 使用的镜像 ports: # 容器开放的端口 - containerPort: 80 # 容器内部端口，只是声明性的字段，不具有决定作用 env: # 环境变量配置 - name: ENVIRONMENT value: production resources: # 资源限制和请求 limits: memory: &quot;512Mi&quot; # 最大内存限制 cpu: &quot;1&quot; # 最大 CPU 核心数，这里是 1 核 # cpu: 1000m # 1000m = 1 核 requests: memory: &quot;256Mi&quot; # 初始分配内存 cpu: &quot;0.5&quot; # 初始分配 CPU, 这里0.5 表示 0.5 核 # cpu: 500m # 500 毫核，也就是 0.5 核 volumeMounts: # 挂载到容器的卷 - name: app-storage # 卷名称，需要和 volumes 中定义的卷名称一致 mountPath: /usr/share/nginx/html # 挂载到容器的目录 spec.containers.command | args 容器启动时执行的命令 默认情况下，容器启动时，会从镜像中获取命令并执行，如果这里配置了命令，则容器启动时，会执行这里的命令，而不是镜像中的命令 12345spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] 或者 123456spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/sh&quot;,&quot;-c&quot;] args: [&quot;while true; do echo hello; sleep 10;done&quot;] 或者 1234567891011spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/bash&quot;, &quot;-c&quot;] args: - | # 使用 | 符号，表示多行输入 while true; do echo &quot;hello world&quot; sleep 5 done spec.restartPolicy 指在系统发生故障或意外停机时，系统或应用程序如何处理和恢复的策略 Always：总是重启 OnFailure：失败时重启 Never：不重启 12345spec: containers: - name: my-nginx image: nginx restartPolicy: OnFailure #失败时重启 spec.terminationGracePeriodSeconds Pod 删除时，系统给 Pod 留的时间，用于完成清理工作 宽限期为避免服务突然中断,造成事物不一致的问题,当容器运行完自己的任务后,会等待一段时间,然后优雅的退出 默认值为 30s，单位为秒 12345spec: containers: - name: my-nginx image: nginx terminationGracePeriodSeconds: 60 spec.volumes Kubernetes 中的卷（volumes）是为了在容器之间共享数据，或将数据从容器持久化到外部存储。 emptyDir（最简单，Pod 生命周期内有效） emptyDir 卷是一个没有名字的临时目录，Pod 创建时创建，Pod 删除时删除。 12345678910spec: containers: - name: app image: nginx volumeMounts: - mountPath: /usr/share/nginx/html name: html-volume volumes: - name: html-volume emptyDir: &#123;&#125; # 表示一个空目录，在 Pod 生命周期内有效 hostPath（挂载宿主机路径） 用于测试或非常了解宿主机结构的场景。生产不推荐。 123456spec: volumes: - name: mydata hostPath: path: /tmp/data # 宿主机路径 type: DirectoryOrCreate # 如果目录不存在就创建 configMap（挂载配置文件） 12345spec: volumes: - name: config configMap: name: my-configmap # 需提前创建 ConfigMap，这个后面会介绍 使用 PVC（挂载持久化存储） 12345spec: volumes: - name: persistent-storage persistentVolumeClaim: claimName: mypvc # PVC 名称，需要提前创建，这个后面会介绍 spec.tolerations: Pod容忍策略 tolerations 是 Kubernetes Pod 中用来“容忍”某些 Node 节点的污点（Taints） 的字段。它允许 Pod 被调度到带有相应 Taint 的节点上。 默认情况下，Pod 会因为 Node 节点的 Taint 而不被调度。 比如一个 Node 有 NoSchedule 类型的 taint，而 Pod 没有设置对应的 toleration，该 Pod 就不会被调度到这个 Node 上。 示例： 容忍 key=value:NoSchedule 的 Taint 假设某节点打了如下污点（Taint）： 12345678910111213kubectl taint nodes node1 key=value:NoSchedule# NoSchedule 不调度到该节点，除非容忍策略显式允许# PreferNoSchedule 尽量不调度到该节点，但非强制，即可能会被调度# NoExecute 不仅不调度到该节点，还会把现有 Pod 驱逐出去，除非设置容忍时间# key=value 是用来 区分不同类型的污点的。比如：# 你可能给 node1 设置 env=prod:NoSchedule# 给 node2 设置 gpu=true:NoSchedule# 给 node3 设置 arch=arm64:NoSchedule# 这些都属于不同的“原因”或“标签”，这样你可以：# 用不同的 toleration 来容忍不同的 taint；# 精准控制某些 Pod 只能被调度到符合条件的节点。 容忍该 Taint 123456789101112131415apiVersion: v1kind: Podmetadata: name: tolerate-examplespec: containers: - name: busybox image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] tolerations: # 定义容忍策略 - operator: &quot;Equal&quot; # 匹配方式，必选（Equal:精确匹配 key 和 value。Exists:只匹配 key 是否存在，不关心 value 是什么） key: &quot;key&quot; # 设置键值对的key，为空代表任意键值对 value: &quot;value&quot; # 设置values的值， effect: &quot;NoSchedule&quot; # 设置容忍的标签，为空代表所有污点标签 tolerationSeconds: 60 # 容忍时间，这里Pod 最多可停留 60 秒，之后仍会被驱逐，不设置表示永久容忍 在 Kubernetes 中，effect 有 三个可选值： effect 值 含义 常见用途 NoSchedule 节点上的污点会阻止 Pod 被调度到该节点，除非 Pod 有相应的 toleration。 最常用，例如 Master 节点的容忍。 PreferNoSchedule 倾向于不调度 到该节点，但不是强制性的，调度器会尽量避免把 Pod 安排到该节点。 用于软约束，尽量不调度。 NoExecute 不仅不调度新 Pod 到该节点，还会把当前节点上没有相应容忍度的 Pod 驱逐出去（eviction）。 节点异常自动驱逐，比如 not-ready。 spec.resources Pod资源配额可以限制命名空间或项目中Pod使用的CPU、内存、存储等资源用量 CPU资源的约束和请求以豪核（m）为单位。在k8s中1m是最小的调度单元，CPU的一个核心可以看作1000m 如果你有2颗cpu，且每CPU为4核心，那么你的CPU资源总量就是8000 12345678910111213spec: # Pod 的具体规范 containers: # Pod 中的容器数组，可以有多个容器 - name: myapp-container # 容器名称 image: nginx:1.25 # 使用的镜像 resources: # 资源限制和请求 limits: memory: &quot;512Mi&quot; # 最大内存限制 cpu: &quot;1&quot; # 最大 CPU 核心数，这里是 1 核 # cpu: 1000m # 1000m = 1 核 requests: memory: &quot;256Mi&quot; # 初始分配内存 cpu: &quot;0.5&quot; # 初始分配 CPU, 这里0.5 表示 0.5 核 # cpu: 500m # 500 毫核，也就是 0.5 核 如果有大量的容器需要设置资源配额，为每个Pod设置资源配额策略不方便且不好管理 可以以名称空间为单位（namespace），限制其资源的使用与创建，在该名称空间中创建的容器都会受到规则的限制。 LimitRange 对单个Pod内存、CPU进行配额 1234567891011121314151617181920apiVersion: v1kind: LimitRangemetadata: name: mem-cpu-limit-range # LimitRange 的名称 namespace: demo # 生效的命名空间spec: limits: - type: Container # 表示限制的是每个容器（也可设置为 Pod） default: # 容器未指定 resources.limits 时使用的默认值 cpu: 500m # 默认限制 CPU 为 0.5 核 memory: 512Mi # 默认限制内存为 512 MiB defaultRequest: # 容器未指定 resources.requests 时使用的默认请求值，初始值 cpu: 100m # 默认请求 CPU 为 0.1 核 memory: 128Mi # 默认请求内存为 128 MiB max: # 容器可设置的最大限制值，即 容器中指定的 resources.limits 的最大允许值 cpu: &quot;1&quot; # 最大可使用 CPU 为 1 核 memory: 1Gi # 最大可使用内存为 1 GiB min: # 容器可设置的最小请求值，，即 容器中指定的 resources.requests 的最小允许值 cpu: 50m # 最小请求 CPU 为 0.05 核 memory: 64Mi # 最小请求内存为 64 MiB ResourceQuota 限制整个 namespace 的资源总量 123456789101112apiVersion: v1kind: ResourceQuotametadata: name: compute-resources # ResourceQuota 的名称 namespace: demo # 生效的命名空间spec: hard: # 定义各类资源的总配额上限 pods: &quot;10&quot; # 该命名空间最多允许创建 10 个 Pod requests.cpu: &quot;2&quot; # 所有 Pod 的 requests.cpu 总和最多为 2 核 requests.memory: 4Gi # 所有 Pod 的 requests.memory 总和最多为 4 GiB limits.cpu: &quot;4&quot; # 所有 Pod 的 limits.cpu 总和最多为 4 核 limits.memory: 8Gi # 所有 Pod 的 limits.memory 总和最多为 8 GiB spec.priorityClassName Pod 的优先级，优先级就是为了保证重要的Pod被优先调度并运行 优先级策略： 非抢占优先：指的是在调度阶段优先进行调度分配，一旦容器调度完成就不可以抢占，资源不足时，只能等待 抢占优先：强制调度一个Pod，如果资源不足无法被调度，调度程序会抢占（删除）较低优先级的Pod的资 源，来保证高优先级Pod的运行 创建优先级 1234567891011121314151617181920---kind: PriorityClassapiVersion: scheduling.k8s.io/v1metadata: name: high-non # 优先级名称preemptionPolicy: Never # 策略：非抢占，PreemptLowerPriority:抢占（删除）较低优先级的Pod的资源，保证高优先级Pod的运行value: 1000 # 优先级，可以设置小于10亿的整数值，值越大，优先级越高，默认优先级0---kind: PodapiVersion: v1metadata: name: nginxspec: nodeSelector: kubernetes.io/hostname: node01 # 指定匹配具有当前标签的节点 priorityClassName: high-non # 优先级名称 containers: - name: my-nginx image: nginx spec.nodeName | nodeSelector :Pod调度策略 在k8s中，调度是将Pod分配到合适的节点并运行的过程，kube-scheduler是默认调度器，是集群的核心组件。 调度器通过k8s的监测（Watch）机制来发现集群中尚未被调度到节点上的Pod，调度器依据调度原则将Pod分配到一个合适的节点上运行。 调度器给一个pod做调度包含两个步骤： 过滤 和 打分 过滤：首先要筛选出满足Pod所有的资源请求的节点，这里包含计算资源、内存、存储、网络、端口号等等，如果没有节点能满足Pod的需求，Pod将一直停留在Pending状态，直到调度器能够找到合适的节点运行它 打分：调度器将节点按照打分规则进行打分，然后按照分数进行排序，将分数最高的节点作为Pod的运行节点。如果存在多个得分最高的节点，调度器会从中随机选取一个。 Pod 支持两种调度策略：nodeName 和 nodeSelector spec.nodeName 指定 Pod 运行在指定名称的节点上 12345spec: nodeName: node-1 # 基于节点名进行调度 containers: - name: apache image: myos:httpd spec.nodeSelector 节点选择器，基于节点的标签进行调度 123456spec: nodeSelector: # 基于节点标签进行调度 kubernetes.io/hostname: node-2 # 标签 containers: - name: apache image: myos:httpd 为节点设置标签 1234567891011# 所有资源都可以设置标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;=&lt;标签value&gt;kubectl label nodes node-2 kubernetes.io/hostname=node-2# 删除标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;-# 这里注意，删除标签就是在标签key后加上 - 符号kubectl label nodes node-2 kubernetes.io/hostname-# 查看资源标签：kubectl get &lt;资源&gt; --show-labelskubectl get nodes --show-labels# 查看指定节点的标签kubectl get nodes node-2 --show-labels spec.affinity 节点亲和性，用于控制 Pod 调度到具有特定标签的节点上，是 nodeSelector 的增强版本 类型 功能 示例用途 Node Affinity 控制调度到有指定标签的节点 SSD、高内存节点 Pod Affinity 调度到和某些 Pod 一起的节点 微服务协同部署 Pod Anti-Affinity 避免和某些 Pod 一起的节点 高可用副本分散部署 节点亲和性(Node Affinity) Pod 只能调度到具有标签 disktype=ssd 的节点上 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: node-affinity-podspec: containers: - name: nginx image: nginx affinity: # 亲和性配置 nodeAffinity: # 节点亲和性 requiredDuringSchedulingIgnoredDuringExecution: # 在调度期间必须满足，运行中忽略变化（即调度后标签变了不会驱逐 Pod）。也可以设置为 preferredDuringSchedulingIgnoredDuringExecution，表示节点亲和性优先级高，但不强制要求必须满足 nodeSelectorTerms: # 节点选择器 - matchExpressions: # 匹配表达式，支持复杂逻辑，比如 In、NotIn、Exists、DoesNotExist、Gt、Lt。 - key: disktype # 键 operator: In # 操作符 values: # 值 - ssd Pod 亲和性(Pod Affinity) Pod 会被调度到 与标签为 app=web 的 Pod 所在同一节点（或拓扑层）上。 通常用于需要紧密协作的服务部署在一起（如同一机器内通信）。 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: pod-affinity-podspec: containers: - name: app image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] affinity: podAffinity: # pod 亲和性 requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: # 标签选择器 matchExpressions: # 标签选择条件 - key: app # 键 operator: In # 操作符 values: # 值 - web topologyKey: &quot;kubernetes.io/hostname&quot; # 拓扑键，表示“同一主机” Pod 反亲和性(Pod Anti-Affinity) 表示不能和 app=web 的 Pod 在同一节点上 常用于高可用部署，避免多个副本部署在同一个节点。 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: pod-anti-affinity-podspec: containers: - name: app image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] affinity: podAntiAffinity: # Pod 反亲和性 requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - web topologyKey: &quot;kubernetes.io/hostname&quot; 节点亲和性 (Node Affinity) 两种策略的对比 策略字段 含义 行为特点 场景适用 是否强制 requiredDuringSchedulingIgnoredDuringExecution “必须满足”亲和性规则 Pod 调度时必须满足条件，不满足则不调度；调度后节点变化不触发驱逐 硬性约束，比如必须调度到有 GPU 的节点 ✅ 强制 preferredDuringSchedulingIgnoredDuringExecution “尽量满足”亲和性规则 Pod 调度时优先考虑满足条件的节点，但条件不满足时仍然可以调度到其他节点；调度后同样不会强制迁移 软性倾向，比如尽量调度到 SSD 节点，但实在没有也可调度 ❌ 非强制 spec.securityContext: 设置安全上下文 runAsUser: 设置运行用户 默认情况下容器都是以root用户运行的，但是很多应用需要以非root用户运行，比如 Elasticsearch 。 123456789101112apiVersion: v1kind: Podmetadata: name: pod1spec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: runAsUser: 1000 # 设置运行用户，这个UID可以不存在 privileged: 是否以特权方式运行 容器与宿主机是共享内核的，默认情况下，容器用户是不允许修改内核参数的，但是可以通过设置 privileged: true 来允许容器以特权方式运行。 123456789101112apiVersion: v1kind: Podmetadata: name: nginxspec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: privileged: true # 特权方式运行，默认为 false allowPrivilegeEscalation: 是否可以提权（SUID） s位：当某可执行命令的所有者的位置上有s位时，那么当普通用户执行这个命令时将具有所有者的权限。 123456789101112apiVersion: v1kind: Podmetadata: name: nginxspec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: allowPrivilegeEscalation: true # 提权运行，可以使用suid，默认为 false 查看 Pod 12345678910111213141516171819202122232425# 查看 Pod，默认显示 default 命名空间下的 Podkubectl get pods# 查看 kube-system 命名空间下的 Podkubectl get pods -n kube-system# 查看所有命名空间下的 Podkubectl get pods -A# -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息kubectl get pods -o wide# 显示 Pod 的详细信息，输出为 json/yaml 格式kubectl get pods -o json/yaml# 显示 Pod 的标签kubectl get pod --show-labels# 按 Pod 的标签进程查询kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示kubectl get pods -w## 状态类型- Pending: Pod 尚未就绪- ContainerCreating: Pod 正在创建容器- Running: Pod 正在运行- Error: Pod 运行错误- Terminating: Pod 正在删除- Completed: Pod 执行完成- Failed: Pod中的所有容器至少有一个容器退出是非0状态- Unkown: 无法正常获取Pod对象的状态信息 查看 Pod 详情 当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因 1234567891011121314151617kubectl describe pod &lt;pod-name&gt;kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程Events: Type Reason Age From Message ---- ------ ---- ---- ------- # 被调度器分配到 k8s-worker2 节点 Normal Scheduled 4s default-scheduler Successfully assigned default/nginx to k8s-worker2 # 开始拉取镜像 Normal Pulling &lt;invalid&gt; kubelet Pulling image &quot;nginx&quot; # 镜像拉取成功 Normal Pulled &lt;invalid&gt; kubelet Successfully pulled image &quot;nginx&quot; in 2.067s (2.067s including waiting). Image size: 72225394 bytes. # 开始创建容器 Normal Created &lt;invalid&gt; kubelet Created container: nginx # 容器启动成功 Normal Started &lt;invalid&gt; kubelet Started container nginx 进入容器 12# kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;kubectl exec -it nginx -- /bin/bash 删除 Pod 123456789101112131415kubectl delete pod &lt;pod-name&gt;kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt;# 强制删除## 1.移除 Pod 上的 Finalizers## finalizers 是 Kubernetes 对象上的一个字段，用来告诉 Kubernetes，在删除我之前，请先做一些清理工作（如释放资源、通知外部系统等），等我自己删掉 finalizer 后，你才能真正删除我。kubectl patch pod &lt;pod-name&gt; \\ -p &#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:[]&#125;&#125;&#x27; --type=merge## 2.强制删除kubectl delete pod &lt;pod-name&gt; --force --grace-period=0 --wait=false## 参数说明# --force: 强制删除，比如遇到了 pod 处于 Terminating 状态，此时无法删除，可以使用 --force 参数强制删除# --grace-period=0: 强制删除的等待时间，默认是 30 秒，设置为 0 表示立即删除# --wait=false: 删除完成后是否等待 Pod 完全删除，比较适合脚本中使用 长时间处于 Terminating 状态的 Pod，这类 Pod 大概率是由于所在节点异常（失联、被重装、或 kubelet 停止），导致 Kubernetes 控制面无法与该 Pod 对应的 kubelet 通信完成删除操作，从而卡在 Terminating 状态，其实它已经死了，但 etcd 里的记录一直保留着。 123456### 查看 Pod 日志```bashkubectl logs &lt;pod-name&gt;kubectl logs pod/&lt;pod-name&gt;kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt; 访问 Pod 我们刚刚创建了一个nginx的pod，该如何访问呢？ 1234567# 获取pod的ip$ k get pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnginx 1/1 Running 0 12m 10.244.126.8 k8s-worker2 &lt;none&gt; &lt;none&gt;# 在任意节点上访问，nginx 默认端口是80$ curl 10.244.126.8 暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问 一个 Pod 运行多个容器 yaml 文件 1234567891011apiVersion: v1kind: Podmetadata: name: multi-podspec: shareProcessNamespace: true # 允许相同pod中多个容器共享进程空间，即在一个容器里可以看到另一个容器中的进程，默认值为 false containers: - name: nginx image: nginx - name: tomcat image: tomcat 运行 pod 1kubectl apply -f multi_pod.yaml 查看运行结果 1234# 这里看到，READY 里有两个，表示两个容器都运行成功$ kubectl get pods -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESmulti-pod 2/2 Running 0 118s 10.244.194.81 k8s-worker1 &lt;none&gt; &lt;none&gt; 访问nginx和tomcat 1234# 访问nginx，ngxin默认端口是80curl http://10.244.194.81# 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常curl http://10.244.194.81:8080 进入容器执行命令 1234567# 进入nginx容器，-c 指定容器名称kubectl exec -it multi-pod -c nginx -- /bin/bash## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享网络和存储curl http://localhost:8080# 进入tomcat容器kubectl exec -it multi-pod -c tomcat -- /bin/bash","summary":"摘要 本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Pod 介绍","date_published":"2025-07-04T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/","url":"https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/","title":"K8S 之 Namespace","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/\">k8s Namespace 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"命名空间-Namespace-介绍\">命名空间(Namespace) 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。</p>\n</li>\n<li class=\"lvl-2\">\n<p>基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Namespace(缩写为 ns) 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>避免使用前缀 <code>kube-</code> 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 启动时会创建四个初始 Namespace：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称空间名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default</code></td>\n<td>默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。</td>\n</tr>\n<tr>\n<td><code>kube-node-lease</code></td>\n<td>存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。</td>\n</tr>\n<tr>\n<td><code>kube-public</code></td>\n<td>所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。</td>\n</tr>\n<tr>\n<td><code>kube-system</code></td>\n<td>Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"查看集群中的命名空间\">查看集群中的命名空间</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># namespace 可以简写为 ns</span></span><br><span class=\"line\">kubectl get namespace</span><br><span class=\"line\">kubectl get ns</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建命名空间\">创建命名空间</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 方式</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>  <span class=\"comment\"># API 版本，可以通过 kubectl api-resources | grep Namespace 获取</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Namespace</span> <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">&lt;namespace-name&gt;</span> <span class=\"comment\"># 命名空间名称</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过命令行直接生成yaml文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式</span></span><br><span class=\"line\">kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除命名空间\">删除命名空间</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置名字空间偏好\">设置名字空间偏好</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Pod</span></span><br><span class=\"line\">kubectl config set-context --current --namespace=&lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看资源时指定命名空间\">查看资源时指定命名空间</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n &lt;namespace-name&gt;</span><br><span class=\"line\">kubectl get service -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的资源，-A, --all-namespaces</span></span><br><span class=\"line\">kubectl get pod -A</span><br><span class=\"line\">kubectl get service -A</span><br></pre></td></tr></table></figure>\n<h2 id=\"并非所有对象都在名字空间中\">并非所有对象都在名字空间中</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 位于名字空间中的资源</span></span><br><span class=\"line\">kubectl api-resources --namespaced=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不在名字空间中的资源</span></span><br><span class=\"line\">kubectl api-resources --namespaced=<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>kubectl api-resources</code> 这个命令很有用，我们可以通过该命令获取所有资源的 <code>简写</code>，也可以获取资源的 <code>apiVersion</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl api-resources</span><br><span class=\"line\">NAME: 资源名称</span><br><span class=\"line\">SHORTNAMES: 简写</span><br><span class=\"line\">APIVERSION: apiVersion</span><br><span class=\"line\">NAMESPACED: 是否在名字空间中</span><br><span class=\"line\">KIND: 资源类型</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kubernetes-中关于-命名空间（namespace）与-DNS-的机制\">Kubernetes 中关于 命名空间（namespace）与 DNS 的机制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。</p>\n</li>\n</ul>\n<h3 id=\"举个例子说明服务-DNS-是怎么工作的\">举个例子说明服务 DNS 是怎么工作的</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景：你在两个命名空间中部署了两个 nginx 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命名空间 dev 中创建服务 nginx</span></span><br><span class=\"line\">kubectl create ns dev</span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2 -n dev</span><br><span class=\"line\">kubectl expose deployment nginx --port=80 --<span class=\"built_in\">type</span>=NodePort -n dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命名空间 prod 中也创建服务 nginx</span></span><br><span class=\"line\">kubectl create ns prod</span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2 -n prod</span><br><span class=\"line\">kubectl expose deployment nginx --port=80 --<span class=\"built_in\">type</span>=NodePort -n prod</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 <code>nginx.dev.svc.cluster.local</code>，也就是 <code>&lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://nginx.prod.svc.cluster.local</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速生成-k8s-资源的yaml模板\">快速生成 k8s 资源的yaml模板</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 vscode 插件：YAML(Red Hat)，Kubernetes Templates(lunuan)</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用时打开一个yaml文件，或者将文件格式切换为yaml，然后输入关键字 pod、deploy、service 等等 k8s 资源名称，就会弹出模板选择，选择后回车就会生成模板</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Namespace 介绍 命名空间(Namespace) 介绍 在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。 基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。 Namespace(缩写为 ns) 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。 避免使用前缀 kube- 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。 Kubernetes 启动时会创建四个初始 Namespace： 名称空间名称 说明 default 默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。 kube-node-lease 存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。 kube-public 所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。 kube-system Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。 查看集群中的命名空间 123# namespace 可以简写为 nskubectl get namespacekubectl get ns 创建命名空间 命令行方式 1kubectl create namespace &lt;namespace-name&gt; yaml 方式 1234apiVersion: v1 # API 版本，可以通过 kubectl api-resources | grep Namespace 获取kind: Namespace # 资源类型metadata: # 元数据 name: &lt;namespace-name&gt; # 命名空间名称 1kubectl apply -f &lt;namespace.yaml&gt; 通过命令行直接生成yaml文件 12# --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt; 删除命名空间 命令行方式 1kubectl delete namespace &lt;namespace-name&gt; yaml 方式 1kubectl delete -f &lt;namespace.yaml&gt; 设置名字空间偏好 12# 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Podkubectl config set-context --current --namespace=&lt;namespace-name&gt; 查看资源时指定命名空间 123456kubectl get pod -n &lt;namespace-name&gt;kubectl get service -n &lt;namespace-name&gt;# 查看所有命名空间下的资源，-A, --all-namespaceskubectl get pod -Akubectl get service -A 并非所有对象都在名字空间中 12345# 位于名字空间中的资源kubectl api-resources --namespaced=true# 不在名字空间中的资源kubectl api-resources --namespaced=false kubectl api-resources 这个命令很有用，我们可以通过该命令获取所有资源的 简写，也可以获取资源的 apiVersion 123456kubectl api-resourcesNAME: 资源名称SHORTNAMES: 简写APIVERSION: apiVersionNAMESPACED: 是否在名字空间中KIND: 资源类型 Kubernetes 中关于 命名空间（namespace）与 DNS 的机制 Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。 命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。 举个例子说明服务 DNS 是怎么工作的 场景：你在两个命名空间中部署了两个 nginx 服务 123456789# 命名空间 dev 中创建服务 nginxkubectl create ns devkubectl create deployment nginx --image=nginx --replicas=2 -n devkubectl expose deployment nginx --port=80 --type=NodePort -n dev# 命名空间 prod 中也创建服务 nginxkubectl create ns prodkubectl create deployment nginx --image=nginx --replicas=2 -n prodkubectl expose deployment nginx --port=80 --type=NodePort -n prod 1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 nginx.dev.svc.cluster.local，也就是 &lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local 1curl http://nginx 2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问 1curl http://nginx.prod.svc.cluster.local 快速生成 k8s 资源的yaml模板 安装 vscode 插件：YAML(Red Hat)，Kubernetes Templates(lunuan) 使用时打开一个yaml文件，或者将文件格式切换为yaml，然后输入关键字 pod、deploy、service 等等 k8s 资源名称，就会弹出模板选择，选择后回车就会生成模板","summary":"摘要 本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Namespace 介绍","date_published":"2025-07-02T13:30:05.000Z","tags":["技术","k8s","K8S"]}]}