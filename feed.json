{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2026/01/08/redis7-datatype-19-RoaringBitmap/","url":"https://blog.hanqunfeng.com/2026/01/08/redis7-datatype-19-RoaringBitmap/","title":"Redis 命令及数据类型 -- RoaringBitmap","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisRoaring 中 RoaringBitmap 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisRoaring 的安装参见 <a href=\"/2026/01/08/redis7-module-RedisRoaring/\" title=\"Redis 扩展模块 -- RedisRoaring 的安装方法\">Redis 扩展模块 -- RedisRoaring 的安装方法</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RoaringBitmap-命令\">RoaringBitmap 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以在 redis-cli 中执行 <code>help @module</code>，找出所有 <code>R.*</code> 和 <code>R64.*</code> 的命令说明</p>\n</li>\n<li class=\"lvl-2\">\n<p>R.*：操作的是 32 位无符号整数（最大约 2^32-1）</p>\n</li>\n<li class=\"lvl-2\">\n<p>R64.*：操作的是 64 位无符号整数（最大约 2^64-1），适合超大 ID 空间，如 Snowflake / 时间戳映射</p>\n<blockquote>\n<p>R64.* 支持的整数理论上是 0 ~ 2⁶⁴-1（约 1.84e19），但工程上应谨慎使用超大 offset，避免稀疏爆炸和性能退化。</p>\n</blockquote>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">high 32 bits  -&gt; container key 大桶</span><br><span class=\"line\">low  32 bits  -&gt; container offset 小桶</span><br><span class=\"line\"></span><br><span class=\"line\">当你写入一个非常大的值，例如 10^18</span><br><span class=\"line\">   虽然 Roaring 只为存在数据的 container 分配内存。</span><br><span class=\"line\">   但 container 的 key 本身是一个 map / array 索引结构。</span><br><span class=\"line\">   极端稀疏、超大 offset 会增加索引管理成本，会导致某些命令操作会变得很慢。</span><br><span class=\"line\">   另外，一个容器至少要 几十字节 ~ 几百字节级别，容器的数量过多，单机内存也无法满足</span><br><span class=\"line\">   如果你创建 10 亿个 container，假设每个 container 占用 100 字节，那么内存占用为：</span><br><span class=\"line\">   10^9 containers × 100 bytes ≈ 100 GB 内存</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>两者语义完全一致，仅支持的 offset 范围不同，以下示例以 R.* 为主。</p>\n</li>\n<li class=\"lvl-2\">\n<p>对比 R 与 R64</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>R.*</th>\n<th>R64.*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Offset 类型</td>\n<td>uint32</td>\n<td>uint64</td>\n</tr>\n<tr>\n<td>最大值</td>\n<td>4,294,967,295 (~4.29e9)</td>\n<td>18,446,744,073,709,551,615 (~1.84e19)</td>\n</tr>\n<tr>\n<td>可表达规模</td>\n<td>十亿级</td>\n<td>万亿亿级</td>\n</tr>\n<tr>\n<td>典型用途</td>\n<td>用户ID、索引</td>\n<td>时间戳、雪花ID、全局唯一ID</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一、数据写入-修改类\">一、数据写入 / 修改类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>典型用途</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>R.SETBIT</td>\n<td>设置单个 bit（0/1），返回旧值</td>\n<td>单点标记</td>\n<td><code>R.SETBIT users 1001 1</code></td>\n</tr>\n<tr>\n<td>R.SETRANGE</td>\n<td>批量设置区间 bit=1</td>\n<td>连续区间打标</td>\n<td><code>R.SETRANGE users 3000 3999</code>，不包含3999</td>\n</tr>\n<tr>\n<td>R.APPENDINTARRAY</td>\n<td>追加多个整数（bit=1）</td>\n<td>批量插入 ID</td>\n<td><code>R.APPENDINTARRAY users 1001 1002 1003</code></td>\n</tr>\n<tr>\n<td>R.SETINTARRAY</td>\n<td>用整数数组重建 bitmap</td>\n<td>初始化数据</td>\n<td><code>R.SETINTARRAY users 1 3 5 7</code></td>\n</tr>\n<tr>\n<td>R.SETBITARRAY</td>\n<td>用 bit 字符串重建 bitmap</td>\n<td>外部导入</td>\n<td><code>R.SETBITARRAY users &quot;101001&quot;</code></td>\n</tr>\n<tr>\n<td>R.DELETEINTARRAY</td>\n<td>删除多个整数（bit=0）</td>\n<td>批量删除</td>\n<td><code>R.DELETEINTARRAY users 1002 2000</code></td>\n</tr>\n<tr>\n<td>R.CLEARBITS</td>\n<td>清除指定 offset</td>\n<td>精确清理</td>\n<td><code>R.CLEARBITS users 1001 1003</code></td>\n</tr>\n<tr>\n<td>R.SETFULL</td>\n<td>填充整个 bitmap</td>\n<td>全量初始化</td>\n<td><code>R.SETFULL users</code></td>\n</tr>\n<tr>\n<td>R.CLEAR</td>\n<td>删除整个 bitmap</td>\n<td>释放资源</td>\n<td><code>R.CLEAR users</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二、数据读取-查询类\">二、数据读取 / 查询类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>典型用途</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>R.GETBIT</td>\n<td>获取单个 bit</td>\n<td>判断是否存在</td>\n<td><code>R.GETBIT users 1001</code></td>\n</tr>\n<tr>\n<td>R.GETBITS</td>\n<td>批量获取 bit</td>\n<td>多点查询</td>\n<td><code>R.GETBITS users 1001 1002 1003</code></td>\n</tr>\n<tr>\n<td>R.GETBITARRAY</td>\n<td>返回完整 bit 字符串</td>\n<td>调试 / 导出</td>\n<td><code>R.GETBITARRAY users</code></td>\n</tr>\n<tr>\n<td>R.GETINTARRAY</td>\n<td>返回所有为 1 的整数</td>\n<td>全量遍历</td>\n<td><code>R.GETINTARRAY users</code></td>\n</tr>\n<tr>\n<td>R.RANGEINTARRAY</td>\n<td>返回区间内整数，注意这里参数是<code>索引下标</code>，不是<code>数值</code></td>\n<td>分页扫描</td>\n<td><code>R.RANGEINTARRAY users 1 5</code></td>\n</tr>\n<tr>\n<td>R.MIN</td>\n<td>最小 offset</td>\n<td>最小 ID 查询</td>\n<td><code>R.MIN users</code></td>\n</tr>\n<tr>\n<td>R.MAX</td>\n<td>最大 offset</td>\n<td>最大 ID 查询</td>\n<td><code>R.MAX users</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三、统计类\">三、统计类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>典型用途</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>R.BITCOUNT</td>\n<td>bit=1 数量统计</td>\n<td>集合基数</td>\n<td><code>R.BITCOUNT users</code></td>\n</tr>\n<tr>\n<td>R.BITPOS</td>\n<td>查找第一个 1 或 0</td>\n<td>稀疏分析</td>\n<td><code>R.BITPOS users 1</code></td>\n</tr>\n<tr>\n<td>R.MIN</td>\n<td>最小 bit 位置</td>\n<td>边界检测</td>\n<td><code>R.MIN users</code></td>\n</tr>\n<tr>\n<td>R.MAX</td>\n<td>最大 bit 位置</td>\n<td>边界检测</td>\n<td><code>R.MAX users</code></td>\n</tr>\n<tr>\n<td>R.STAT</td>\n<td>容器 / 内存统计</td>\n<td>性能调优</td>\n<td><code>R.STAT users TEXT</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四、集合运算类\">四、集合运算类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>集合语义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>R.BITOP AND</td>\n<td>位图交集</td>\n<td>A ∩ B</td>\n<td><code>R.BITOP AND res a b</code></td>\n</tr>\n<tr>\n<td>R.BITOP OR</td>\n<td>位图并集</td>\n<td>A ∪ B</td>\n<td><code>R.BITOP OR res a b</code></td>\n</tr>\n<tr>\n<td>R.BITOP XOR</td>\n<td>对称差集</td>\n<td>A ⊕ B</td>\n<td><code>R.BITOP XOR res a b</code></td>\n</tr>\n<tr>\n<td>R.DIFF</td>\n<td>差集</td>\n<td>A - B</td>\n<td><code>R.DIFF res a b</code></td>\n</tr>\n<tr>\n<td>R.CONTAINS</td>\n<td>包含关系判断</td>\n<td>子集检测</td>\n<td><code>R.CONTAINS a b ALL</code></td>\n</tr>\n<tr>\n<td>R.JACCARD</td>\n<td>相似度计算</td>\n<td>J(A,B)</td>\n<td><code>R.JACCARD a b</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"五、维护-优化类\">五、维护 / 优化类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>典型用途</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>R.OPTIMIZE</td>\n<td>容器重整 / 压缩</td>\n<td>降低内存</td>\n<td><code>R.OPTIMIZE users MEM</code></td>\n</tr>\n<tr>\n<td>R.CLEAR</td>\n<td>清理 bitmap</td>\n<td>回收资源</td>\n<td><code>R.CLEAR users</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"六、R-R64-对照表（含示例）\">六、R / R64 对照表（含示例）</h3>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>R (32bit)</th>\n<th>R64 (64bit)</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置 bit</td>\n<td>R.SETBIT</td>\n<td>R64.SETBIT</td>\n<td><code>R64.SETBIT users64 90000000000 1</code></td>\n</tr>\n<tr>\n<td>批量插入</td>\n<td>R.APPENDINTARRAY</td>\n<td>R64.APPENDINTARRAY</td>\n<td><code>R64.APPENDINTARRAY users64 90000000001 90000000002</code></td>\n</tr>\n<tr>\n<td>查询 bit</td>\n<td>R.GETBIT</td>\n<td>R64.GETBIT</td>\n<td><code>R64.GETBIT users64 90000000001</code></td>\n</tr>\n<tr>\n<td>统计</td>\n<td>R.BITCOUNT</td>\n<td>R64.BITCOUNT</td>\n<td><code>R64.BITCOUNT users64</code></td>\n</tr>\n<tr>\n<td>集合运算</td>\n<td>R.BITOP</td>\n<td>R64.BITOP</td>\n<td><code>R64.BITOP OR res64 a64 b64</code></td>\n</tr>\n<tr>\n<td>优化</td>\n<td>R.OPTIMIZE</td>\n<td>R64.OPTIMIZE</td>\n<td><code>R64.OPTIMIZE users64 MEM</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"真实案例\">真实案例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设我们有一个电商平台，需要统计以下指标：</span><br><span class=\"line\">   VIP 用户（购买金额超过 1000 的用户）</span><br><span class=\"line\">   付费用户（至少购买一次的用户）</span><br><span class=\"line\">   最近活跃用户（过去 7 天内登录过的用户）</span><br><span class=\"line\"></span><br><span class=\"line\">我们想要计算：</span><br><span class=\"line\">   VIP 用户人数</span><br><span class=\"line\">   VIP 且最近活跃的用户人数</span><br><span class=\"line\">   VIP 且付费用户且最近活跃的人数</span><br><span class=\"line\">   付费用户与最近活跃用户的 Jaccard 相似度</span><br><span class=\"line\"></span><br><span class=\"line\">假设用户 ID 为整数（最大值 &lt; 2^32，使用 R.* 即可）。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">写入数据（模拟）</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># VIP 用户</span></span><br><span class=\"line\">R.APPENDINTARRAY vip_users 1001 1002 1003 1004 1005</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 付费用户</span></span><br><span class=\"line\">R.APPENDINTARRAY paid_users 1002 1003 1005 1006 1007</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最近活跃用户</span></span><br><span class=\"line\">R.APPENDINTARRAY active_users 1001 1003 1005 1008</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> active_users</span><br><span class=\"line\">reroaring</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">查询基础统计</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># VIP 用户人数</span></span><br><span class=\"line\">R.BITCOUNT vip_users</span><br><span class=\"line\"><span class=\"comment\"># 返回 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最近活跃用户人数</span></span><br><span class=\"line\">R.BITCOUNT active_users</span><br><span class=\"line\"><span class=\"comment\"># 返回 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 付费用户人数</span></span><br><span class=\"line\">R.BITCOUNT paid_users</span><br><span class=\"line\"><span class=\"comment\"># 返回 5</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">计算交集 / 子集</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.VIP 且最近活跃用户</span></span><br><span class=\"line\">R.BITOP AND vip_active vip_users active_users</span><br><span class=\"line\">R.BITCOUNT vip_active</span><br><span class=\"line\"><span class=\"comment\"># 返回 3</span></span><br><span class=\"line\"><span class=\"comment\"># 解释：用户 1001, 1003, 1005 同时是 VIP 且最近活跃。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.VIP 且付费用户且最近活跃</span></span><br><span class=\"line\"><span class=\"comment\"># 先计算 VIP 与付费交集</span></span><br><span class=\"line\">R.BITOP AND vip_paid vip_users paid_users</span><br><span class=\"line\"><span class=\"comment\"># 再计算 vip_paid 与活跃用户交集</span></span><br><span class=\"line\">R.BITOP AND vip_paid_active vip_paid active_users</span><br><span class=\"line\">R.BITCOUNT vip_paid_active</span><br><span class=\"line\"><span class=\"comment\"># 返回 2</span></span><br><span class=\"line\"><span class=\"comment\"># 解释：用户 1003, 1005 同时满足三条件。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">计算 Jaccard 相似度</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算 付费用户 与 最近活跃用户 的相似度</span></span><br><span class=\"line\">R.JACCARD paid_users active_users</span><br><span class=\"line\"><span class=\"comment\"># 返回 &quot;0.2857142857142857&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># Jaccard 相似度计算公式：</span></span><br><span class=\"line\">   J(A, B) = |A ∩ B| / |A ∪ B| = 交集 / 并集</span><br><span class=\"line\">   0.2857142857142857 = |1003, 1005| / |1001, 1002, 1003, 1005, 1006, 1007, 1008| = 2 / 7 = 0.2857142857142857</span><br></pre></td></tr></table></figure>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>J</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mi mathvariant=\"normal\">∣</mi></mrow><mrow><mi mathvariant=\"normal\">∣</mi><mi>A</mi><mo>∪</mo><mi>B</mi><mi mathvariant=\"normal\">∣</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">∣</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">∣</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"5\">\n<li class=\"lvl-5\">范围 / ID 查询</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.获取 VIP 用户 ID 列表</span></span><br><span class=\"line\">R.GETINTARRAY vip_users</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1001  <span class=\"comment\"># 1 是索引，1001 是值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1002</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1003</span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1004</span><br><span class=\"line\">5) (<span class=\"built_in\">integer</span>) 1005</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.获取最近活跃用户 ID，索引范围 在 1~3 范围，注意这里的索引是 R.GETINTARRAY 返回的索引下标，不是值。</span></span><br><span class=\"line\">R.RANGEINTARRAY active_users 1 3</span><br><span class=\"line\"><span class=\"comment\"># 返回 1003, 1005, 1008</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1003</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1005</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1008</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"6\">\n<li class=\"lvl-5\">优化存储</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果数据量非常大，可以优化内存</span></span><br><span class=\"line\">R.OPTIMIZE vip_users MEM</span><br><span class=\"line\">R.OPTIMIZE paid_users MEM</span><br><span class=\"line\">R.OPTIMIZE active_users MEM</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisRoaring 中 RoaringBitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisRoaring 的安装参见 Redis 扩展模块 -- RedisRoaring 的安装方法 RoaringBitmap 命令 可以在 redis-cli 中执行 help @module，找出所有 R.* 和 R64.* 的命令说明 R.*：操作的是 32 位无符号整数（最大约 2^32-1） R64.*：操作的是 64 位无符号整数（最大约 2^64-1），适合超大 ID 空间，如 Snowflake / 时间戳映射 R64.* 支持的整数理论上是 0 ~ 2⁶⁴-1（约 1.84e19），但工程上应谨慎使用超大 offset，避免稀疏爆炸和性能退化。 12345678910high 32 bits -&gt; container key 大桶low 32 bits -&gt; container offset 小桶当你写入一个非常大的值，例如 10^18 虽然 Roaring 只为存在数据的 container 分配内存。 但 container 的 key 本身是一个 map / array 索引结构。 极端稀疏、超大 offset 会增加索引管理成本，会导致某些命令操作会变得很慢。 另外，一个容器至少要 几十字节 ~ 几百字节级别，容器的数量过多，单机内存也无法满足 如果你创建 10 亿个 container，假设每个 container 占用 100 字节，那么内存占用为： 10^9 containers × 100 bytes ≈ 100 GB 内存 两者语义完全一致，仅支持的 offset 范围不同，以下示例以 R.* 为主。 对比 R 与 R64 维度 R.* R64.* Offset 类型 uint32 uint64 最大值 4,294,967,295 (~4.29e9) 18,446,744,073,709,551,615 (~1.84e19) 可表达规模 十亿级 万亿亿级 典型用途 用户ID、索引 时间戳、雪花ID、全局唯一ID 一、数据写入 / 修改类 命令 功能 典型用途 示例 R.SETBIT 设置单个 bit（0/1），返回旧值 单点标记 R.SETBIT users 1001 1 R.SETRANGE 批量设置区间 bit=1 连续区间打标 R.SETRANGE users 3000 3999，不包含3999 R.APPENDINTARRAY 追加多个整数（bit=1） 批量插入 ID R.APPENDINTARRAY users 1001 1002 1003 R.SETINTARRAY 用整数数组重建 bitmap 初始化数据 R.SETINTARRAY users 1 3 5 7 R.SETBITARRAY 用 bit 字符串重建 bitmap 外部导入 R.SETBITARRAY users &quot;101001&quot; R.DELETEINTARRAY 删除多个整数（bit=0） 批量删除 R.DELETEINTARRAY users 1002 2000 R.CLEARBITS 清除指定 offset 精确清理 R.CLEARBITS users 1001 1003 R.SETFULL 填充整个 bitmap 全量初始化 R.SETFULL users R.CLEAR 删除整个 bitmap 释放资源 R.CLEAR users 二、数据读取 / 查询类 命令 功能 典型用途 示例 R.GETBIT 获取单个 bit 判断是否存在 R.GETBIT users 1001 R.GETBITS 批量获取 bit 多点查询 R.GETBITS users 1001 1002 1003 R.GETBITARRAY 返回完整 bit 字符串 调试 / 导出 R.GETBITARRAY users R.GETINTARRAY 返回所有为 1 的整数 全量遍历 R.GETINTARRAY users R.RANGEINTARRAY 返回区间内整数，注意这里参数是索引下标，不是数值 分页扫描 R.RANGEINTARRAY users 1 5 R.MIN 最小 offset 最小 ID 查询 R.MIN users R.MAX 最大 offset 最大 ID 查询 R.MAX users 三、统计类 命令 功能 典型用途 示例 R.BITCOUNT bit=1 数量统计 集合基数 R.BITCOUNT users R.BITPOS 查找第一个 1 或 0 稀疏分析 R.BITPOS users 1 R.MIN 最小 bit 位置 边界检测 R.MIN users R.MAX 最大 bit 位置 边界检测 R.MAX users R.STAT 容器 / 内存统计 性能调优 R.STAT users TEXT 四、集合运算类 命令 功能 集合语义 示例 R.BITOP AND 位图交集 A ∩ B R.BITOP AND res a b R.BITOP OR 位图并集 A ∪ B R.BITOP OR res a b R.BITOP XOR 对称差集 A ⊕ B R.BITOP XOR res a b R.DIFF 差集 A - B R.DIFF res a b R.CONTAINS 包含关系判断 子集检测 R.CONTAINS a b ALL R.JACCARD 相似度计算 J(A,B) R.JACCARD a b 五、维护 / 优化类 命令 功能 典型用途 示例 R.OPTIMIZE 容器重整 / 压缩 降低内存 R.OPTIMIZE users MEM R.CLEAR 清理 bitmap 回收资源 R.CLEAR users 六、R / R64 对照表（含示例） 功能 R (32bit) R64 (64bit) 示例 设置 bit R.SETBIT R64.SETBIT R64.SETBIT users64 90000000000 1 批量插入 R.APPENDINTARRAY R64.APPENDINTARRAY R64.APPENDINTARRAY users64 90000000001 90000000002 查询 bit R.GETBIT R64.GETBIT R64.GETBIT users64 90000000001 统计 R.BITCOUNT R64.BITCOUNT R64.BITCOUNT users64 集合运算 R.BITOP R64.BITOP R64.BITOP OR res64 a64 b64 优化 R.OPTIMIZE R64.OPTIMIZE R64.OPTIMIZE users64 MEM 真实案例 场景说明 123456789101112假设我们有一个电商平台，需要统计以下指标： VIP 用户（购买金额超过 1000 的用户） 付费用户（至少购买一次的用户） 最近活跃用户（过去 7 天内登录过的用户）我们想要计算： VIP 用户人数 VIP 且最近活跃的用户人数 VIP 且付费用户且最近活跃的人数 付费用户与最近活跃用户的 Jaccard 相似度假设用户 ID 为整数（最大值 &lt; 2^32，使用 R.* 即可）。 写入数据（模拟） 123456789101112# VIP 用户R.APPENDINTARRAY vip_users 1001 1002 1003 1004 1005# 付费用户R.APPENDINTARRAY paid_users 1002 1003 1005 1006 1007# 最近活跃用户R.APPENDINTARRAY active_users 1001 1003 1005 1008# 查看数据类型127.0.0.1:6379&gt; type active_usersreroaring 查询基础统计 1234567891011# VIP 用户人数R.BITCOUNT vip_users# 返回 5# 最近活跃用户人数R.BITCOUNT active_users# 返回 4# 付费用户人数R.BITCOUNT paid_users# 返回 5 计算交集 / 子集 123456789101112131415# 1.VIP 且最近活跃用户R.BITOP AND vip_active vip_users active_usersR.BITCOUNT vip_active# 返回 3# 解释：用户 1001, 1003, 1005 同时是 VIP 且最近活跃。# 2.VIP 且付费用户且最近活跃# 先计算 VIP 与付费交集R.BITOP AND vip_paid vip_users paid_users# 再计算 vip_paid 与活跃用户交集R.BITOP AND vip_paid_active vip_paid active_usersR.BITCOUNT vip_paid_active# 返回 2# 解释：用户 1003, 1005 同时满足三条件。 计算 Jaccard 相似度 123456# 计算 付费用户 与 最近活跃用户 的相似度R.JACCARD paid_users active_users# 返回 &quot;0.2857142857142857&quot;# Jaccard 相似度计算公式： J(A, B) = |A ∩ B| / |A ∪ B| = 交集 / 并集 0.2857142857142857 = |1003, 1005| / |1001, 1002, 1003, 1005, 1006, 1007, 1008| = 2 / 7 = 0.2857142857142857 J(A,B)=∣A∩B∣∣A∪B∣J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|} J(A,B)=∣A∪B∣∣A∩B∣​ 范围 / ID 查询 12345678910111213141516# 1.获取 VIP 用户 ID 列表R.GETINTARRAY vip_users# 输出1) (integer) 1001 # 1 是索引，1001 是值2) (integer) 10023) (integer) 10034) (integer) 10045) (integer) 1005# 2.获取最近活跃用户 ID，索引范围 在 1~3 范围，注意这里的索引是 R.GETINTARRAY 返回的索引下标，不是值。R.RANGEINTARRAY active_users 1 3# 返回 1003, 1005, 10081) (integer) 10032) (integer) 10053) (integer) 1008 优化存储 1234# 如果数据量非常大，可以优化内存R.OPTIMIZE vip_users MEMR.OPTIMIZE paid_users MEMR.OPTIMIZE active_users MEM","summary":"摘要 本文介绍 Redis 扩展模块 – RedisRoaring 中 RoaringBitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisRoaring 的安装参见 Redis 扩展模块 -- RedisRoaring 的安装方法","date_published":"2026-01-08T14:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2026/01/08/redis7-module-RedisRoaring/","url":"https://blog.hanqunfeng.com/2026/01/08/redis7-module-RedisRoaring/","title":"Redis 扩展模块 -- RedisRoaring 的安装方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisRoaring 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisRoaring-简介\">RedisRoaring 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/aviggiano/redis-roaring\">RedisRoaring</a>是一个开源的 Redis 模块（Redis Module），由 Antonio Guilherme Ferreira Viggiano 维护，目的是将 Roaring Bitmap 数据结构原生集成到 Redis 中作为新的数据类型与命令集。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它基于 CRoaring 库实现压缩位图（Roaring Bitmap）功能，这是一种高效、压缩的位图数据结构，适合处理大规模整数集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p>兼容 Redis 6.0 及以上版本，在不同版本中对命令元数据、ACL 分类等功能有自动适配支持。</p>\n</li>\n</ul>\n<h2 id=\"原生的redis-bitmap有哪些问题\">原生的<code>redis bitmap</code>有哪些问题?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>结论先行：Redis 原生 Bitmap 的核心问题是「空间不可控 + 大规模位运算性能随最大偏移线性增长」，而 redis-roaring 通过 Roaring Bitmap 解决了稀疏数据内存浪费和大范围扫描效率问题。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Bitmap 是连续数组，不支持稀疏压缩， 其必须 从 0 到最大 bit offset 全部连续分配内存。你只要设置了 bit=1 的最大下标是 N，那么 Redis 至少要分配 N/8 字节内存。</p>\n</li>\n<li class=\"lvl-2\">\n<p>假设你要存储用户ID集合，但是存储的ID范围较大，比如 1-2000000000，那么就会导致Bitmap的bit offset非常大，导致Bitmap的存储空间非常大。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外如果数据比较稀疏，极端情况下只存储了2个ID，ID1:1，ID2:2000000000，那么Bitmap就要按照最大的 offset进行分配空间，导致Bitmap的存储空间非常大，但是中间的空间又被浪费了。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT user:bitmap 1 1</span><br><span class=\"line\">SETBIT user:bitmap 2000000000 1</span><br><span class=\"line\"><span class=\"comment\"># 2_000_000_000 bits ≈ 250 MB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 内部必须扫描：0 ... max_offset，即使只有 2 个 bit 为 1，也必须扫描 250MB 内存。</span></span><br><span class=\"line\">BITCOUNT user:bitmap</span><br></pre></td></tr></table></figure>\n<h2 id=\"Roaring-Bitmap实现思路\">Roaring Bitmap实现思路</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将32位的int类型数据进行<code>高16位</code>、<code>低16位</code>划分，高16位就被划分成<code>2^16=65536个大桶（容器）</code>，低16位最多被划分成<code>2^16=65536个小桶（元素）</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>把要统计的数字拆分位高16位和低16位，高16位用作容器的索引、用于定位数字在哪个容器；低16位用作容器内元素的索引、用作定位数字在容器内的位置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>高16位和低16位的计算</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">公式：x = high * 2^16 + low</span><br><span class=\"line\">对一个整数 x：</span><br><span class=\"line\">高 16 位（High） = x / 2^16（整数除法）</span><br><span class=\"line\">低 16 位（Low） = x % 2^16</span><br><span class=\"line\"></span><br><span class=\"line\">高 16 位用于定位“容器（container）”，低 16 位用于定位容器内部的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">假设一个 32 位整数：x = 305419896 = 0x12345678 （十六进制）</span><br><span class=\"line\">高 16 位（High） = x / 2^16 = 305419896 / 65536 = 4660</span><br><span class=\"line\">低 16 位（Low） = x % 2^16  = 305419896 % 65536 = 22136</span><br><span class=\"line\">属于：container 4660, offset 22136</span><br><span class=\"line\"></span><br><span class=\"line\">转为二进制（32 位）进行验证：</span><br><span class=\"line\">0001 0010 0011 0100 | 0101 0110 0111 1000</span><br><span class=\"line\">   ↑ 高 16 位       |    ↑ 低 16 位</span><br><span class=\"line\"></span><br><span class=\"line\">| 部分   | 二进制              | 十六进制   | 十进制   |</span><br><span class=\"line\">| ---- | ------------------- | ------ | ----- |</span><br><span class=\"line\">| 高16位 | 0001 0010 0011 0100 | 0x1234 | 4660  |</span><br><span class=\"line\">| 低16位 | 0101 0110 0111 1000 | 0x5678 | 22136 |</span><br><span class=\"line\"></span><br><span class=\"line\">边界例子（容器切换点）</span><br><span class=\"line\">x = 65535</span><br><span class=\"line\">high = 65535 / 65536 = 0</span><br><span class=\"line\">low  = 65535 % 65536 = 65535</span><br><span class=\"line\">属于：container 0, offset 65535 （容器0的最后一个位置）</span><br><span class=\"line\"></span><br><span class=\"line\">x = 65536</span><br><span class=\"line\">high = 65536 / 65536 = 1</span><br><span class=\"line\">low  = 65536 % 65536 = 0</span><br><span class=\"line\">属于：container 1, offset 0 （容器1的第一个位置）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器有三种不同类型: <code>ArrayContainer</code>、<code>BitmapContainer</code>和<code>RunContainer</code>，根据要统计的数字的数量和数字的连续性自动选择合适的容器。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ArrayContainer</td>\n<td>稀疏（少量整数），元素为short类型的有序数组<br>最多存储 65536 个 short 元素，占用 128 KB 内存</td>\n</tr>\n<tr>\n<td>BitmapContainer</td>\n<td>密集 ，使用bitmap存储数据，固定占用 8kB 内存</td>\n</tr>\n<tr>\n<td>RunContainer</td>\n<td>连续区间，使用Run-Length Encoding方式压缩存储的元素，对连续数据的压缩效果特别好。<br>它的原理是，对于连续出现的数字，只记录初始数字和后续数量。即：<br>对于数据集：5，会压缩为5, 0<br>对于数据集：5, 6, 7, 8, 9, 10，会压缩为5, 5<br>对于数据集：5, 7, 9, 11, 12，会压缩为5, 0, 7, 0, 9, 0, 11, 1 <br>最好情况：全部是连续数字，只会存储 2 个 short ，占用 4 bytes<br>最坏情况：0~65535的范围内填充所有的奇数位或偶数位，需要 65536 个short，占用 128 KB</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"容器的使用及容器之间的转换\">容器的使用及容器之间的转换</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Roaring 的目标是：在保证操作性能的前提下，使内存占用最小。</p>\n</li>\n<li class=\"lvl-2\">\n<p>因此：插入、删除、合并、运算后，会评估当前 container 的“最优类型”，必要时自动转换</p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ Array → Bitmap，触发条件：容器中元素数量 &gt; 4096</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原因：</span><br><span class=\"line\">   Array 每个元素占 2 bytes</span><br><span class=\"line\">   4096 × 2 = 8192 bytes</span><br><span class=\"line\">   Bitmap 固定 8192 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">超过这个点，Bitmap 更省内存 + 查询更快。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>✅ Bitmap → Array，触发条件：容器中元素数量 &lt;= 4096，一般在大量删除或 AND 运算后触发。</p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ RunContainer ↔ Array / Bitmap，Run 没有固定阈值，而是 动态评估内存模型，基于如下三个指标：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">run_count : 当前 RunContainer 中有多少个连续区间</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如集合：&#123;1,2,3,4,5,  10,11,12,  100&#125;</span><br><span class=\"line\">连续区间：[1..5], [10..12], [100..100]</span><br><span class=\"line\">因此：run_count = 3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>run_count</th>\n<th>数据形态</th>\n<th>适合 Run 吗</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>很小（1~几十）</td>\n<td>大段连续</td>\n<td>极其适合</td>\n</tr>\n<tr>\n<td>中等（几百）</td>\n<td>稍碎</td>\n<td>可能适合</td>\n</tr>\n<tr>\n<td>很大（上千）</td>\n<td>高度碎片化</td>\n<td>不适合</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-5\">\n<p>run_total_coverage : run 覆盖的总元素数量(本质就是元素的数量)</p>\n</li>\n</ul>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1..5]  → 5 个</span><br><span class=\"line\">[10..12] → 3 个</span><br><span class=\"line\">[100..100] → 1 个</span><br><span class=\"line\"></span><br><span class=\"line\">run_total_coverage = 9</span><br><span class=\"line\"></span><br><span class=\"line\">实际上更重要的指标是 平均 run 长度</span><br><span class=\"line\">平均 run 长度 = run_total_coverage / run_count = 9 / 3 = 3</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>run_count</th>\n<th>coverage</th>\n<th>平均长度</th>\n<th>形态</th>\n<th>适合 Run 吗</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>60,000</td>\n<td>60,000</td>\n<td>超长连续</td>\n<td>极适合</td>\n</tr>\n<tr>\n<td>10</td>\n<td>50,000</td>\n<td>5,000</td>\n<td>大段连续</td>\n<td>适合</td>\n</tr>\n<tr>\n<td>5,000</td>\n<td>50,000</td>\n<td>10</td>\n<td>碎片连续</td>\n<td>非常不适合</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-5\">\n<p>estimated_memory : 估算内存占用，这是核心决策指标</p>\n</li>\n</ul>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memory_run: 如果用 RunContainer，需要多少内存， ≈ run_count × RUN_ENTRY_SIZE(4 bytes)</span><br><span class=\"line\">memory_array: 如果用 ArrayContainer，需要多少内存， ≈ 元素数量 × 2 bytes</span><br><span class=\"line\">memory_bitmap: 如果用 BitmapContainer，需要多少内存，固定内存 = 8192 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">▶ 选择逻辑（简化）</span><br><span class=\"line\"><span class=\"keyword\">if</span> memory_run &lt; min(memory_array, memory_bitmap):</span><br><span class=\"line\">   use RunContainer</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> memory_array &lt; memory_bitmap:</span><br><span class=\"line\">   use ArrayContainer</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   use BitmapContainer</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>转换方向</th>\n<th>触发条件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Array → Bitmap</td>\n<td>元素数量 &gt; 4096</td>\n</tr>\n<tr>\n<td>Bitmap → Array</td>\n<td>元素数量 ≤ 4096</td>\n</tr>\n<tr>\n<td>任意 → Run</td>\n<td>连续区间压缩明显</td>\n</tr>\n<tr>\n<td>Run → Array / Bitmap</td>\n<td>run 碎片化或内存劣化</td>\n</tr>\n<tr>\n<td>批量运算</td>\n<td>根据结果自动选择</td>\n</tr>\n<tr>\n<td>optimize</td>\n<td>强制重新评估</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>✅ 在 Roaring 的自动选择机制下，正常情况下单个 container 的内存占用会被控制在 ≈ 8KB 左右或更小，在“理论极限完全填满65535个 container”情况下，大约占 520 MB 内存(除了数据本身还有一些元数据)</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>估算</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bitmap 数据</td>\n<td>~512 MB</td>\n</tr>\n<tr>\n<td>Container 元数据</td>\n<td>~4 MB</td>\n</tr>\n<tr>\n<td>索引结构</td>\n<td>~1 MB</td>\n</tr>\n<tr>\n<td>Redis Key 自身</td>\n<td>~0.1 MB</td>\n</tr>\n<tr>\n<td><strong>合计</strong></td>\n<td><strong>约 517 MB</strong></td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Vw540M.png\" alt=\"\" width=\"1000\" height=\"500\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>直观对比表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Redis Bitmap</th>\n<th>redis-roaring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储结构</td>\n<td>连续 bit array</td>\n<td>压缩 bitmap（分块）</td>\n</tr>\n<tr>\n<td>稀疏数据内存</td>\n<td>极差</td>\n<td>极优</td>\n</tr>\n<tr>\n<td>最大 offset</td>\n<td>越大内存越爆</td>\n<td>几乎无影响</td>\n</tr>\n<tr>\n<td>BITCOUNT / BITOP</td>\n<td>扫描整个 bitmap</td>\n<td>只扫描有效 container</td>\n</tr>\n<tr>\n<td>扩容成本</td>\n<td>可能大规模 realloc</td>\n<td>局部 container 扩展</td>\n</tr>\n<tr>\n<td>单 bit 读写</td>\n<td>极快</td>\n<td>略慢（结构层）</td>\n</tr>\n<tr>\n<td>模块依赖</td>\n<td>原生</td>\n<td>Redis Module</td>\n</tr>\n<tr>\n<td>运维复杂度</td>\n<td>最低</td>\n<td>稍高</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RedisRoaring核心价值与优势\">RedisRoaring核心价值与优势</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">内存效率更高</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">Roaring Bitmap 会根据数据稀疏/密集自动选择最优表示方式（数组、位图或运行长度编码），显著减少内存占用，相比传统 Redis Bitmap 在稀疏数据上能节省大量空间。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">高性能位操作</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">对单个位的操作保持 O(1) 性能，与 Redis 原生位图操作一致。</li>\n<li class=\"lvl-5\">对于大规模操作（例如 BITOP AND/OR/XOR）性能显著优于原生位图，某些操作可达到 8 倍性能提升。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">结构丰富的命令集</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">除了传统位图命令之外，redis-roaring 提供更丰富的数据操作命令，支持批量和分析型用例。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装-RedisRoaring\">安装 RedisRoaring</h2>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redistimeseries.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/aviggiano/redis-roaring.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-roaring/</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v1.7.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译构建，作者将下载子模块、编译安装等命令都封装到一个脚本中，这里直接执行脚本即可</span></span><br><span class=\"line\">./configure.sh</span><br><span class=\"line\"><span class=\"comment\"># 如果没有错误，则说明编译成功，输出: dist/libredis-roaring.so</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上<code>redis-roaring</code>在构建后会在<code>dist</code>目录下生成好 Redis 相关命令和配置文件，如果没有安装Redis则可以直接使用。<code>v1.7.1</code>版本提供的Redis的版本为<code>8.2.1</code>，但此时是不带 Stack 相关模块的。</p>\n</li>\n</ul>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <code>libredis-roaring.so</code> 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要包含可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> dist/libredis-roaring.so /usr/local/soft/redis-7.4.7/modules/libredis-roaring.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 libredis-roaring.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/libredis-roaring.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20816</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 11209</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 21025</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;REDIS-ROARING&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 10700</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/libredis-roaring.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisRoaring 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisRoaring 简介 RedisRoaring是一个开源的 Redis 模块（Redis Module），由 Antonio Guilherme Ferreira Viggiano 维护，目的是将 Roaring Bitmap 数据结构原生集成到 Redis 中作为新的数据类型与命令集。 它基于 CRoaring 库实现压缩位图（Roaring Bitmap）功能，这是一种高效、压缩的位图数据结构，适合处理大规模整数集合。 兼容 Redis 6.0 及以上版本，在不同版本中对命令元数据、ACL 分类等功能有自动适配支持。 原生的redis bitmap有哪些问题? 结论先行：Redis 原生 Bitmap 的核心问题是「空间不可控 + 大规模位运算性能随最大偏移线性增长」，而 redis-roaring 通过 Roaring Bitmap 解决了稀疏数据内存浪费和大范围扫描效率问题。 Bitmap 是连续数组，不支持稀疏压缩， 其必须 从 0 到最大 bit offset 全部连续分配内存。你只要设置了 bit=1 的最大下标是 N，那么 Redis 至少要分配 N/8 字节内存。 假设你要存储用户ID集合，但是存储的ID范围较大，比如 1-2000000000，那么就会导致Bitmap的bit offset非常大，导致Bitmap的存储空间非常大。 另外如果数据比较稀疏，极端情况下只存储了2个ID，ID1:1，ID2:2000000000，那么Bitmap就要按照最大的 offset进行分配空间，导致Bitmap的存储空间非常大，但是中间的空间又被浪费了。 123456SETBIT user:bitmap 1 1SETBIT user:bitmap 2000000000 1# 2_000_000_000 bits ≈ 250 MB# Redis 内部必须扫描：0 ... max_offset，即使只有 2 个 bit 为 1，也必须扫描 250MB 内存。BITCOUNT user:bitmap Roaring Bitmap实现思路 将32位的int类型数据进行高16位、低16位划分，高16位就被划分成2^16=65536个大桶（容器），低16位最多被划分成2^16=65536个小桶（元素） 把要统计的数字拆分位高16位和低16位，高16位用作容器的索引、用于定位数字在哪个容器；低16位用作容器内元素的索引、用作定位数字在容器内的位置。 高16位和低16位的计算 12345678910111213141516171819202122232425262728293031公式：x = high * 2^16 + low对一个整数 x：高 16 位（High） = x / 2^16（整数除法）低 16 位（Low） = x % 2^16高 16 位用于定位“容器（container）”，低 16 位用于定位容器内部的位置。假设一个 32 位整数：x = 305419896 = 0x12345678 （十六进制）高 16 位（High） = x / 2^16 = 305419896 / 65536 = 4660低 16 位（Low） = x % 2^16 = 305419896 % 65536 = 22136属于：container 4660, offset 22136转为二进制（32 位）进行验证：0001 0010 0011 0100 | 0101 0110 0111 1000 ↑ 高 16 位 | ↑ 低 16 位| 部分 | 二进制 | 十六进制 | 十进制 || ---- | ------------------- | ------ | ----- || 高16位 | 0001 0010 0011 0100 | 0x1234 | 4660 || 低16位 | 0101 0110 0111 1000 | 0x5678 | 22136 |边界例子（容器切换点）x = 65535high = 65535 / 65536 = 0low = 65535 % 65536 = 65535属于：container 0, offset 65535 （容器0的最后一个位置）x = 65536high = 65536 / 65536 = 1low = 65536 % 65536 = 0属于：container 1, offset 0 （容器1的第一个位置） 容器有三种不同类型: ArrayContainer、BitmapContainer和RunContainer，根据要统计的数字的数量和数字的连续性自动选择合适的容器。 类型 说明 ArrayContainer 稀疏（少量整数），元素为short类型的有序数组最多存储 65536 个 short 元素，占用 128 KB 内存 BitmapContainer 密集 ，使用bitmap存储数据，固定占用 8kB 内存 RunContainer 连续区间，使用Run-Length Encoding方式压缩存储的元素，对连续数据的压缩效果特别好。它的原理是，对于连续出现的数字，只记录初始数字和后续数量。即：对于数据集：5，会压缩为5, 0对于数据集：5, 6, 7, 8, 9, 10，会压缩为5, 5对于数据集：5, 7, 9, 11, 12，会压缩为5, 0, 7, 0, 9, 0, 11, 1 最好情况：全部是连续数字，只会存储 2 个 short ，占用 4 bytes最坏情况：0~65535的范围内填充所有的奇数位或偶数位，需要 65536 个short，占用 128 KB 容器的使用及容器之间的转换 Roaring 的目标是：在保证操作性能的前提下，使内存占用最小。 因此：插入、删除、合并、运算后，会评估当前 container 的“最优类型”，必要时自动转换 ✅ Array → Bitmap，触发条件：容器中元素数量 &gt; 4096 123456原因： Array 每个元素占 2 bytes 4096 × 2 = 8192 bytes Bitmap 固定 8192 bytes超过这个点，Bitmap 更省内存 + 查询更快。 ✅ Bitmap → Array，触发条件：容器中元素数量 &lt;= 4096，一般在大量删除或 AND 运算后触发。 ✅ RunContainer ↔ Array / Bitmap，Run 没有固定阈值，而是 动态评估内存模型，基于如下三个指标： run_count : 当前 RunContainer 中有多少个连续区间 123例如集合：&#123;1,2,3,4,5, 10,11,12, 100&#125;连续区间：[1..5], [10..12], [100..100]因此：run_count = 3 run_count 数据形态 适合 Run 吗 很小（1~几十） 大段连续 极其适合 中等（几百） 稍碎 可能适合 很大（上千） 高度碎片化 不适合 run_total_coverage : run 覆盖的总元素数量(本质就是元素的数量) 12345678[1..5] → 5 个[10..12] → 3 个[100..100] → 1 个run_total_coverage = 9实际上更重要的指标是 平均 run 长度平均 run 长度 = run_total_coverage / run_count = 9 / 3 = 3 run_count coverage 平均长度 形态 适合 Run 吗 1 60,000 60,000 超长连续 极适合 10 50,000 5,000 大段连续 适合 5,000 50,000 10 碎片连续 非常不适合 estimated_memory : 估算内存占用，这是核心决策指标 1234567891011memory_run: 如果用 RunContainer，需要多少内存， ≈ run_count × RUN_ENTRY_SIZE(4 bytes)memory_array: 如果用 ArrayContainer，需要多少内存， ≈ 元素数量 × 2 bytesmemory_bitmap: 如果用 BitmapContainer，需要多少内存，固定内存 = 8192 bytes▶ 选择逻辑（简化）if memory_run &lt; min(memory_array, memory_bitmap): use RunContainerelse if memory_array &lt; memory_bitmap: use ArrayContainerelse: use BitmapContainer 转换方向 触发条件 Array → Bitmap 元素数量 &gt; 4096 Bitmap → Array 元素数量 ≤ 4096 任意 → Run 连续区间压缩明显 Run → Array / Bitmap run 碎片化或内存劣化 批量运算 根据结果自动选择 optimize 强制重新评估 ✅ 在 Roaring 的自动选择机制下，正常情况下单个 container 的内存占用会被控制在 ≈ 8KB 左右或更小，在“理论极限完全填满65535个 container”情况下，大约占 520 MB 内存(除了数据本身还有一些元数据) 项目 估算 Bitmap 数据 ~512 MB Container 元数据 ~4 MB 索引结构 ~1 MB Redis Key 自身 ~0.1 MB 合计 约 517 MB 直观对比表 维度 Redis Bitmap redis-roaring 存储结构 连续 bit array 压缩 bitmap（分块） 稀疏数据内存 极差 极优 最大 offset 越大内存越爆 几乎无影响 BITCOUNT / BITOP 扫描整个 bitmap 只扫描有效 container 扩容成本 可能大规模 realloc 局部 container 扩展 单 bit 读写 极快 略慢（结构层） 模块依赖 原生 Redis Module 运维复杂度 最低 稍高 RedisRoaring核心价值与优势 内存效率更高 Roaring Bitmap 会根据数据稀疏/密集自动选择最优表示方式（数组、位图或运行长度编码），显著减少内存占用，相比传统 Redis Bitmap 在稀疏数据上能节省大量空间。 高性能位操作 对单个位的操作保持 O(1) 性能，与 Redis 原生位图操作一致。 对于大规模操作（例如 BITOP AND/OR/XOR）性能显著优于原生位图，某些操作可达到 8 倍性能提升。 结构丰富的命令集 除了传统位图命令之外，redis-roaring 提供更丰富的数据操作命令，支持批量和分析型用例。 安装 RedisRoaring 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redistimeseries.so上传到国内服务器即可。 1234567891011mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码git clone https://github.com/aviggiano/redis-roaring.gitcd redis-roaring/# 推荐切换到稳定的release版本git checkout v1.7.1# 编译构建，作者将下载子模块、编译安装等命令都封装到一个脚本中，这里直接执行脚本即可./configure.sh# 如果没有错误，则说明编译成功，输出: dist/libredis-roaring.so 实际上redis-roaring在构建后会在dist目录下生成好 Redis 相关命令和配置文件，如果没有安装Redis则可以直接使用。v1.7.1版本提供的Redis的版本为8.2.1，但此时是不带 Stack 相关模块的。 Redis 启用模块 将生成的 libredis-roaring.so 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建 12# 注意 .so 文件需要包含可执行权限cp dist/libredis-roaring.so /usr/local/soft/redis-7.4.7/modules/libredis-roaring.so 本文采用 loadmodule 加载模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 将 libredis-roaring.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/libredis-roaring.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 20816 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 11209 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 21025 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;REDIS-ROARING&quot; 3) &quot;ver&quot; 4) (integer) 10700 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/libredis-roaring.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisRoaring 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2026-01-08T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2026/01/07/redis7-datatype-18-TimeSeries/","url":"https://blog.hanqunfeng.com/2026/01/07/redis7-datatype-18-TimeSeries/","title":"Redis 命令及数据类型 -- TimeSeries","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisTimeSeries 中 TimeSeries 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisTimeSeries 的安装参见 <a href=\"/2026/01/07/redis7-module-RedisTimeSeries/\" title=\"Redis 扩展模块 -- RedisTimeSeries 的安装方法\">Redis 扩展模块 -- RedisTimeSeries 的安装方法</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"TimeSeries-简介\">TimeSeries 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>TimeSeries 是 Redis 的一个扩展模块，用于处理时间序列数据，<a href=\"https://redis.io/modules/redis-timeseries/?utm_source=chatgpt.com\">RedisTimeSeries | A NoSQL Time Series Database</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>核心设计与数据模型</p>\n</li>\n</ul>\n<blockquote>\n<p>一个 Redis 时间序列（Time Series） 是有序的一系列采样数据点：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>组成部分</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>时间戳（timestamp）</strong></td>\n<td>毫秒级时间标签，可客户端指定或由服务器填充</td>\n</tr>\n<tr>\n<td><strong>值（value）</strong></td>\n<td>64 位浮点数</td>\n</tr>\n<tr>\n<td><strong>元数据（labels）</strong></td>\n<td>一组键值对，可用于过滤与聚合查询</td>\n</tr>\n<tr>\n<td><strong>保留策略（retention）</strong></td>\n<td>数据生命周期控制，过期自动丢弃</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主要功能与特性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>高吞吐写入</strong></td>\n<td>支持每秒接收大量数据点，延迟极低</td>\n</tr>\n<tr>\n<td><strong>区间查询</strong></td>\n<td>可按时间范围检索数据，如 <code>TS.RANGE</code> / <code>TS.MRANGE</code></td>\n</tr>\n<tr>\n<td><strong>聚合查询</strong></td>\n<td>内建 min、max、avg、sum、count、first、last 等聚合功能</td>\n</tr>\n<tr>\n<td><strong>自动下采样 &amp; 累积规则</strong></td>\n<td>通过 aggregation rules 自动生成更粗粒度指标</td>\n</tr>\n<tr>\n<td><strong>保留策略（Retention）</strong></td>\n<td>设置最大保存时间或样本数量</td>\n</tr>\n<tr>\n<td><strong>标签索引（Labels）</strong></td>\n<td>支持基于标签的跨序列查询</td>\n</tr>\n<tr>\n<td><strong>高效存储</strong></td>\n<td>使用压缩与内存结构优化空间成本</td>\n</tr>\n<tr>\n<td><strong>工具整合</strong></td>\n<td>支持 Grafana、Prometheus、Telegraf 等生态集成</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>应用场景</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>物联网（IoT）监控</strong></td>\n<td>温度、湿度、设备状态等</td>\n</tr>\n<tr>\n<td><strong>系统监控与指标收集</strong></td>\n<td>CPU、内存、网络指标的实时存储与分析</td>\n</tr>\n<tr>\n<td><strong>业务指标分析</strong></td>\n<td>每日/每小时活跃用户数量、请求延迟等</td>\n</tr>\n<tr>\n<td><strong>金融时间序列</strong></td>\n<td>股票价格、交易量的快速写入和分析</td>\n</tr>\n<tr>\n<td><strong>实时告警</strong></td>\n<td>数据越界时触发告警逻辑</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"TimeSeries-命令说明\">TimeSeries 命令说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按“生命周期”视角的快速索引</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>对应命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建</td>\n<td>TS.CREATE</td>\n</tr>\n<tr>\n<td>修改结构</td>\n<td>TS.ALTER</td>\n</tr>\n<tr>\n<td>建立聚合</td>\n<td>TS.CREATERULE / TS.DELETERULE</td>\n</tr>\n<tr>\n<td>写入</td>\n<td>TS.ADD / TS.MADD / TS.INCRBY / TS.DECRBY</td>\n</tr>\n<tr>\n<td>查询单序列</td>\n<td>TS.GET / TS.RANGE / TS.REVRANGE</td>\n</tr>\n<tr>\n<td>查询多序列</td>\n<td>TS.MGET / TS.MRANGE / TS.MREVRANGE / TS.QUERYINDEX</td>\n</tr>\n<tr>\n<td>清理数据</td>\n<td>TS.DEL</td>\n</tr>\n<tr>\n<td>查看状态</td>\n<td><a href=\"http://TS.INFO\">TS.INFO</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一、时间序列创建与结构管理类\">一、时间序列创建与结构管理类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TS.CREATE</strong></td>\n<td>创建一个新的时间序列（可指定保留策略、标签、chunk 大小等）</td>\n<td>初始化指标，如创建 CPU、QPS、延迟等指标序列</td>\n</tr>\n<tr>\n<td><strong>TS.ALTER</strong></td>\n<td>修改已有时间序列的配置（retention、chunk size、duplicate policy、labels）</td>\n<td>动态调整数据保留周期、标签信息</td>\n</tr>\n<tr>\n<td><strong>TS.CREATERULE</strong></td>\n<td>创建压缩 / 聚合规则（从 source series 自动聚合到 dest series）</td>\n<td>原始数据 → 按分钟 / 小时聚合</td>\n</tr>\n<tr>\n<td><strong>TS.DELETERULE</strong></td>\n<td>删除已有的压缩 / 聚合规则</td>\n<td>停止某条自动聚合规则</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-TS-CREATE-创建时间序列\">1️⃣ TS.CREATE : 创建时间序列</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.CREATE key</span><br><span class=\"line\">  [RETENTION retentionPeriod]</span><br><span class=\"line\">  [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;]</span><br><span class=\"line\">  [CHUNK_SIZE size]</span><br><span class=\"line\">  [DUPLICATE_POLICY policy]</span><br><span class=\"line\">  [IGNORE ignoreMaxTimediff ignoreMaxValDiff]</span><br><span class=\"line\">  [LABELS [label value ...]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>可选值 / 约束</th>\n<th>默认值</th>\n<th>典型使用建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>时间序列的 Redis Key</td>\n<td>任意合法 Redis key</td>\n<td>无</td>\n<td>建议包含业务语义，如 <code>ts:cpu:node1</code></td>\n</tr>\n<tr>\n<td><strong>RETENTION</strong></td>\n<td>数据保留时长（毫秒），超过自动删除</td>\n<td>≥ 0，0 表示永久保留</td>\n<td>0</td>\n<td>高频指标必须设置，避免内存无限增长</td>\n</tr>\n<tr>\n<td><strong>ENCODING</strong></td>\n<td>数据存储编码方式</td>\n<td><code>COMPRESSED</code>: 内存占用低，CPU 有轻微开销<br>  <code>UNCOMPRESSED</code>:查询快，占用内存高</td>\n<td><code>COMPRESSED</code></td>\n<td>绝大多数场景保持默认</td>\n</tr>\n<tr>\n<td><strong>CHUNK_SIZE</strong></td>\n<td>每个数据块的大小（字节），影响内存碎片与压缩效率</td>\n<td>≥ 128 bytes（通常 1KB–64KB）</td>\n<td>4096</td>\n<td>写入频繁时适当调大</td>\n</tr>\n<tr>\n<td><strong>DUPLICATE_POLICY</strong></td>\n<td>同一 timestamp 重复写入时的处理策略</td>\n<td>见下表</td>\n<td>全局配置</td>\n<td>明确指定，避免默认行为变化</td>\n</tr>\n<tr>\n<td><strong>IGNORE</strong></td>\n<td>忽略与上一点差异过小的数据</td>\n<td><code>ignoreMaxTimediff</code>: 最大允许时间差（毫秒）<br> <code>ignoreMaxValDiff</code>: 最大允许的数值差</td>\n<td>关闭</td>\n<td>用于降噪和降采样 <br>示例：<code>IGNORE 1000 0.01</code>： 1 秒内，变化小于 0.01 的数据将被忽略</td>\n</tr>\n<tr>\n<td><strong>LABELS</strong></td>\n<td>标签键值对，用于索引和过滤</td>\n<td>任意字符串对<br><code>LABELS key1 value1 key2 value2 ... </code></td>\n<td>无</td>\n<td>强烈建议用于查询</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DUPLICATE_POLICY（重复时间戳策略）</p>\n</li>\n</ul>\n<blockquote>\n<p>当同一个 timestamp 被多次写入时生效</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>处理逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>BLOCK</strong></td>\n<td>默认，重复时间戳直接失败</td>\n</tr>\n<tr>\n<td><strong>FIRST</strong></td>\n<td>保留已有值，忽略新值</td>\n</tr>\n<tr>\n<td><strong>LAST</strong></td>\n<td>覆盖已有值，用新值替代</td>\n</tr>\n<tr>\n<td><strong>MIN</strong></td>\n<td>仅当新值更小才覆盖</td>\n</tr>\n<tr>\n<td><strong>MAX</strong></td>\n<td>仅当新值更大才覆盖</td>\n</tr>\n<tr>\n<td><strong>SUM</strong></td>\n<td>累加值（已有值 + 新值）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例: 创建一个 CPU 指标时间序列，自动过期 1 小时之前的数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.CREATE ts:cpu:server1</span><br><span class=\"line\">  RETENTION 3600000</span><br><span class=\"line\">  ENCODING COMPRESSED</span><br><span class=\"line\">  CHUNK_SIZE 8192</span><br><span class=\"line\">  DUPLICATE_POLICY LAST</span><br><span class=\"line\">  IGNORE 1000 0.1</span><br><span class=\"line\">  LABELS host server1 metric cpu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> ts:cpu:server1</span><br><span class=\"line\">TSDB-TYPE</span><br></pre></td></tr></table></figure>\n<h4 id=\"2️⃣-TS-ALTER-修改时间序列配置\">2️⃣ TS.ALTER : 修改时间序列配置</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.ALTER key</span><br><span class=\"line\">  [RETENTION retentionPeriod]</span><br><span class=\"line\">  [CHUNK_SIZE size]</span><br><span class=\"line\">  [DUPLICATE_POLICY policy]</span><br><span class=\"line\">  [LABELS [label value ...]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：修改保留周期和标签</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.ALTER ts:cpu:server1</span><br><span class=\"line\">  RETENTION 7200000</span><br><span class=\"line\">  LABELS host server1 metric cpu <span class=\"built_in\">env</span> prod</span><br></pre></td></tr></table></figure>\n<h4 id=\"3️⃣-TS-CREATERULE-创建自动聚合规则\">3️⃣ TS.CREATERULE : 创建自动聚合规则</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">原始序列：ts:cpu:server1（秒级数据）</li>\n<li class=\"lvl-6\">聚合目标：ts:cpu:server1:avg1m（按 1 分钟平均值聚合）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.CREATERULE sourceKey destKey</span><br><span class=\"line\">  AGGREGATION aggregator bucketDuration</span><br><span class=\"line\">  [alignTimestamp]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>可选值 / 约束</th>\n<th>是否必填</th>\n<th>行为说明</th>\n<th>使用注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>sourceKey</strong></td>\n<td>源时间序列 Key</td>\n<td>必须是已存在的 TS key</td>\n<td>是</td>\n<td>新写入数据从该序列触发聚合</td>\n<td>必须先创建</td>\n</tr>\n<tr>\n<td><strong>destKey</strong></td>\n<td>目标聚合时间序列 Key</td>\n<td>必须是已存在的 TS key</td>\n<td>是</td>\n<td>聚合结果写入该序列</td>\n<td>通常 retention 更长</td>\n</tr>\n<tr>\n<td><strong>aggregator</strong></td>\n<td>聚合函数</td>\n<td>见下表</td>\n<td>是</td>\n<td>定义每个 bucket 内如何计算</td>\n<td>不同函数计算成本不同</td>\n</tr>\n<tr>\n<td><strong>bucketDuration</strong></td>\n<td>聚合时间桶宽度（毫秒）</td>\n<td>&gt; 0</td>\n<td>是</td>\n<td>控制聚合粒度</td>\n<td>决定数据降采样程度</td>\n</tr>\n<tr>\n<td><strong>alignTimestamp</strong></td>\n<td>对齐时间戳基准</td>\n<td>毫秒时间戳</td>\n<td>否</td>\n<td>控制 bucket 起始对齐方式</td>\n<td>跨系统对齐时非常重要</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>aggregator（聚合函数）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>聚合器</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>AVG</strong></td>\n<td>平均值</td>\n</tr>\n<tr>\n<td><strong>SUM</strong></td>\n<td>求和</td>\n</tr>\n<tr>\n<td><strong>MIN</strong></td>\n<td>最小值</td>\n</tr>\n<tr>\n<td><strong>MAX</strong></td>\n<td>最大值</td>\n</tr>\n<tr>\n<td><strong>COUNT</strong></td>\n<td>样本数量</td>\n</tr>\n<tr>\n<td><strong>FIRST</strong></td>\n<td>第一个样本</td>\n</tr>\n<tr>\n<td><strong>LAST</strong></td>\n<td>最后一个样本</td>\n</tr>\n<tr>\n<td><strong>RANGE</strong></td>\n<td>MAX - MIN</td>\n</tr>\n<tr>\n<td><strong>STD.P</strong></td>\n<td>总体标准差</td>\n</tr>\n<tr>\n<td><strong>STD.S</strong></td>\n<td>样本标准差</td>\n</tr>\n<tr>\n<td><strong>VAR.P</strong></td>\n<td>总体方差</td>\n</tr>\n<tr>\n<td><strong>VAR.S</strong></td>\n<td>样本方差</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>alignTimestamp（对齐时间戳基准）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>示例值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0（Unix Epoch）</strong>（推荐做法）</td>\n<td><code>0</code></td>\n<td>从 1970-01-01 00:00:00 UTC 对齐</td>\n</tr>\n<tr>\n<td><strong>任意固定时间戳</strong></td>\n<td><code>1700000000000</code></td>\n<td>从指定时间点对齐</td>\n</tr>\n<tr>\n<td><strong>当前时间戳</strong></td>\n<td><code>$(date +%s%3N)</code></td>\n<td>从创建规则时刻对齐</td>\n</tr>\n<tr>\n<td><strong>业务时间边界</strong></td>\n<td>某天 00:00 的毫秒值</td>\n<td>对齐到业务周期</td>\n</tr>\n<tr>\n<td><strong>不指定</strong></td>\n<td>（参数省略）</td>\n<td>自动使用首条写入时间</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例: 每 60,000ms（1分钟）做一次平均聚合</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.创建目标聚合序列</span></span><br><span class=\"line\">TS.CREATE ts:cpu:server1:avg1m</span><br><span class=\"line\">  RETENTION 86400000</span><br><span class=\"line\">  LABELS host server1 metric cpu_1m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.创建自动聚合规则</span></span><br><span class=\"line\">TS.CREATERULE ts:cpu:server1 ts:cpu:server1:avg1m</span><br><span class=\"line\">  AGGREGATION AVG 60000</span><br><span class=\"line\"><span class=\"comment\">## 如果未设置 alignTimestamp，则以创建的第一条记录的时间为基准</span></span><br><span class=\"line\"><span class=\"comment\">## 比如第一条记录的时间为：12:00:23</span></span><br><span class=\"line\"><span class=\"comment\">## bucket 会对齐到:</span></span><br><span class=\"line\">    <span class=\"comment\"># 12:00:23 ~ 12:01:23</span></span><br><span class=\"line\">    <span class=\"comment\"># 12:01:23 ~ 12:02:23</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 alignTimestamp 对齐到整分钟</span></span><br><span class=\"line\">TS.CREATERULE ts:cpu:server1 ts:cpu:server1:avg1m</span><br><span class=\"line\">  AGGREGATION AVG 60000 0</span><br><span class=\"line\"><span class=\"comment\">## bucket 会严格对齐:</span></span><br><span class=\"line\">    <span class=\"comment\"># 12:00:00 ~ 12:01:00</span></span><br><span class=\"line\">    <span class=\"comment\"># 12:01:00 ~ 12:02:00</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4️⃣-TS-DELETERULE-删除自动聚合规则\">4️⃣ TS.DELETERULE : 删除自动聚合规则</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.DELETERULE sourceKey destKey</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：删除自动聚合规则</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.DELETERULE ts:cpu:server1 ts:cpu:server1:avg1m</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、数据写入与更新类\">二、数据写入与更新类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TS.ADD</strong></td>\n<td>向时间序列追加一个样本点（timestamp, value）</td>\n<td>实时写入监控数据</td>\n</tr>\n<tr>\n<td><strong>TS.MADD</strong></td>\n<td>批量向多个时间序列追加样本</td>\n<td>高吞吐场景，减少网络 RTT</td>\n</tr>\n<tr>\n<td><strong>TS.INCRBY</strong></td>\n<td>对最新时间戳的值做自增（不存在则创建新样本）</td>\n<td>计数器、累计指标</td>\n</tr>\n<tr>\n<td><strong>TS.DECRBY</strong></td>\n<td>对最新时间戳的值做自减（不存在则创建新样本）</td>\n<td>库存、余额类递减指标</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-TS-ADD-向时间序列追加一个样本点\">1️⃣ TS.ADD : 向时间序列追加一个样本点</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.ADD key timestamp value</span><br><span class=\"line\">  [RETENTION retentionPeriod]</span><br><span class=\"line\">  [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;]</span><br><span class=\"line\">  [CHUNK_SIZE size]</span><br><span class=\"line\">  [DUPLICATE_POLICY policy]</span><br><span class=\"line\">  [ON_DUPLICATE policy_ovr]</span><br><span class=\"line\">  [IGNORE ignoreMaxTimediff ignoreMaxValDiff]</span><br><span class=\"line\">  [LABELS [label value ...]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 key 不存在，TS.ADD 会 隐式创建时间序列（类似 TS.CREATE）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>可选值 / 约束</th>\n<th>是否覆盖已有配置</th>\n<th>生效范围</th>\n<th>使用注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>时间序列 Key</td>\n<td>合法 Redis key</td>\n<td>—</td>\n<td>—</td>\n<td>不存在时自动创建</td>\n</tr>\n<tr>\n<td><strong>timestamp</strong></td>\n<td>样本时间戳</td>\n<td>毫秒整数 / <code>*</code></td>\n<td>—</td>\n<td>当前写入</td>\n<td><code>*</code> 表示服务器当前时间</td>\n</tr>\n<tr>\n<td><strong>value</strong></td>\n<td>样本值</td>\n<td>浮点数</td>\n<td>—</td>\n<td>当前写入</td>\n<td>NaN / Inf 不允许</td>\n</tr>\n<tr>\n<td><strong>RETENTION</strong></td>\n<td>设置保留周期</td>\n<td>≥ 0（毫秒）</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>已存在 key 不会被修改</td>\n</tr>\n<tr>\n<td><strong>ENCODING</strong></td>\n<td>存储编码</td>\n<td>COMPRESSED / UNCOMPRESSED</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>生产推荐 COMPRESSED</td>\n</tr>\n<tr>\n<td><strong>CHUNK_SIZE</strong></td>\n<td>数据块大小</td>\n<td>≥ 128 bytes</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>不影响已有 chunk</td>\n</tr>\n<tr>\n<td><strong>DUPLICATE_POLICY</strong></td>\n<td>设置默认重复策略</td>\n<td>BLOCK / FIRST / LAST / MIN / MAX / SUM</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>与 ON_DUPLICATE 有优先级关系</td>\n</tr>\n<tr>\n<td><strong>ON_DUPLICATE</strong></td>\n<td>本次写入的重复策略</td>\n<td>同上</td>\n<td>覆盖序列级策略</td>\n<td>当前写入</td>\n<td>推荐用于临时覆盖</td>\n</tr>\n<tr>\n<td><strong>IGNORE</strong></td>\n<td>忽略微小变化写入</td>\n<td>两个阈值</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>用于降噪</td>\n</tr>\n<tr>\n<td><strong>LABELS</strong></td>\n<td>设置标签</td>\n<td>键值对</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>已存在 key 不会修改</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：写入一个时间序列</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.ADD ts:cpu:server1 * 80.5</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1767777655255 <span class=\"comment\"># 当前时间戳</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2️⃣-TS-MADD-批量向多个时间序列追加样本\">2️⃣ TS.MADD : 批量向多个时间序列追加样本</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.MADD key timestamp value [key timestamp value ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：批量写入多个时间序列</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 批量写入三个时间序列，时间序列必须存在</span></span><br><span class=\"line\">TS.MADD ts:cpu:server1 * 80.5 ts:cpu:server2 * 90.5 ts:cpu:server3 * 70.5</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1767777807933</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1767777807933</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1767777807933</span><br></pre></td></tr></table></figure>\n<h4 id=\"3️⃣-TS-INCRBY-对最新时间戳的值做自增（不存在则创建新样本）\">3️⃣ TS.INCRBY : 对最新时间戳的值做自增（不存在则创建新样本）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.INCRBY key addend</span><br><span class=\"line\">  [TIMESTAMP timestamp]</span><br><span class=\"line\">  [RETENTION retentionPeriod]</span><br><span class=\"line\">  [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;]</span><br><span class=\"line\">  [CHUNK_SIZE size]</span><br><span class=\"line\">  [DUPLICATE_POLICY policy]</span><br><span class=\"line\">  [IGNORE ignoreMaxTimediff ignoreMaxValDiff]</span><br><span class=\"line\">  [LABELS [label value ...]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>可选值 / 约束</th>\n<th>是否覆盖已有配置</th>\n<th>生效范围</th>\n<th>使用注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>时间序列 Key</td>\n<td>合法 Redis key</td>\n<td>—</td>\n<td>—</td>\n<td>不存在会自动创建</td>\n</tr>\n<tr>\n<td><strong>addend</strong></td>\n<td>增量值</td>\n<td>浮点数</td>\n<td>—</td>\n<td>当前写入</td>\n<td>支持负数（等价 DECR）</td>\n</tr>\n<tr>\n<td><strong>TIMESTAMP</strong></td>\n<td>指定写入时间戳</td>\n<td>毫秒整数</td>\n<td>—</td>\n<td>当前写入</td>\n<td>默认使用服务器时间</td>\n</tr>\n<tr>\n<td><strong>RETENTION</strong></td>\n<td>设置保留周期</td>\n<td>≥ 0（毫秒）</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>已存在 key 不生效</td>\n</tr>\n<tr>\n<td><strong>ENCODING</strong></td>\n<td>存储编码</td>\n<td>COMPRESSED / UNCOMPRESSED</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>推荐 COMPRESSED</td>\n</tr>\n<tr>\n<td><strong>CHUNK_SIZE</strong></td>\n<td>数据块大小</td>\n<td>≥ 128 bytes</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>高频写入可调大</td>\n</tr>\n<tr>\n<td><strong>DUPLICATE_POLICY</strong></td>\n<td>默认重复时间戳策略</td>\n<td>BLOCK / FIRST / LAST / MIN / MAX / SUM</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>对计数器通常设 SUM</td>\n</tr>\n<tr>\n<td><strong>IGNORE</strong></td>\n<td>忽略微小变化</td>\n<td>两个阈值</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>计数器一般不使用</td>\n</tr>\n<tr>\n<td><strong>LABELS</strong></td>\n<td>标签</td>\n<td>键值对</td>\n<td>仅首次创建生效</td>\n<td>序列级</td>\n<td>用于 MGET / MRANGE</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 key 不存在，TS.INCRBY 会 隐式创建时间序列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有指定 TIMESTAMP，则自动使用服务器当前时间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>写入逻辑等价于：读取最新值 + addend → 写回一个新样本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对最新时间戳的值做自增</span></span><br><span class=\"line\">TS.INCRBY ts:cpu:server1 10</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1767778308125</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定时间戳，TIMESTAMP 必须大于或等于当前时间序列中最大的时间戳</span></span><br><span class=\"line\">TS.INCRBY ts:cpu:server1 5 TIMESTAMP 1767778308126</span><br></pre></td></tr></table></figure>\n<h4 id=\"4️⃣-TS-DECRBY-对最新时间戳的值做自减（不存在则创建新样本）\">4️⃣ TS.DECRBY : 对最新时间戳的值做自减（不存在则创建新样本）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>与 <code>TS.INCRBY</code> 相似，不再赘述。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上 <code>TS.INCRBY</code> 中设置 <code>addend</code> 为负数 就是 <code>TS.DECR</code></p>\n</li>\n</ul>\n<h3 id=\"三、数据查询（单序列）类\">三、数据查询（单序列）类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TS.GET</strong></td>\n<td>获取某个时间序列最新（最大 timestamp）的样本</td>\n<td>获取当前最新指标值</td>\n</tr>\n<tr>\n<td><strong>TS.RANGE</strong></td>\n<td>按时间正序查询一个时间序列的区间数据</td>\n<td>绘图、趋势分析</td>\n</tr>\n<tr>\n<td><strong>TS.REVRANGE</strong></td>\n<td>按时间逆序查询一个时间序列的区间数据</td>\n<td>获取最近 N 条数据</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-TS-GET-获取某个时间序列最新（最大-timestamp）的样本\">1️⃣ TS.GET : 获取某个时间序列最新（最大 timestamp）的样本</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.GET key [LATEST]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>时间序列 Key</td>\n</tr>\n<tr>\n<td><strong>LATEST</strong></td>\n<td>获取最新样本</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LATEST 说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">当一个时间序列是经过聚合（compaction）处理的时，LATEST 参数会生效。使用 LATEST 时，TS.GET 会返回最新（可能是部分的）桶的聚合值。不使用 LATEST 时，TS.GET 不会返回最新（可能是部分的）桶的值。当时间序列不是聚合的时，LATEST 会被忽略。</li>\n<li class=\"lvl-6\">最新桶中的数据可能是不完整的。只有当有新的样本到来并开启一个新的最新桶时，原桶才会被关闭并进行聚合。然而，在某些情况下，也需要获取最新（可能是部分的）桶的聚合值，此时就可以使用 LATEST。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.GET ts:cpu:server1 LATEST</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\">2) 115.5</span><br></pre></td></tr></table></figure>\n<h4 id=\"2️⃣-TS-RANGE-按时间正序查询一个时间序列的区间数据\">2️⃣ TS.RANGE : 按时间正序查询一个时间序列的区间数据</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.RANGE key fromTimestamp toTimestamp</span><br><span class=\"line\">  [LATEST]</span><br><span class=\"line\">  [FILTER_BY_TS ts...]</span><br><span class=\"line\">  [FILTER_BY_VALUE min max]</span><br><span class=\"line\">  [COUNT count]</span><br><span class=\"line\">  [[ALIGN align] AGGREGATION aggregator bucketDuration [BUCKETTIMESTAMP bt] [EMPTY]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n<th>可选值 / 说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>key</code></td>\n<td>string</td>\n<td>时间序列的键名</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>fromTimestamp</code></td>\n<td>integer</td>\n<td>查询起始时间戳，<code>-</code>: 最小值</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>toTimestamp</code></td>\n<td>integer</td>\n<td>查询结束时间戳 ，<code>+</code>: 最大值</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>LATEST</code></td>\n<td>flag</td>\n<td>当时间序列是 compaction 时，返回最新（可能部分）的桶的聚合值</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>FILTER_BY_TS ts...</code></td>\n<td>list of integers</td>\n<td>只返回指定时间戳的样本</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>FILTER_BY_VALUE min max</code></td>\n<td>range</td>\n<td>只返回值在 <code>[min, max]</code> 区间的样本</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>COUNT count</code></td>\n<td>integer</td>\n<td>限制返回的样本数量（最多 <code>count</code> 个）</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>ALIGN align</code></td>\n<td>string</td>\n<td>对齐聚合桶的时间戳（如 <code>start</code>、<code>end</code>、自定义时间戳）</td>\n<td>可选，需与 <code>AGGREGATION</code> 一起使用</td>\n</tr>\n<tr>\n<td><code>AGGREGATION aggregator bucketDuration</code></td>\n<td>aggregation</td>\n<td>对数据进行聚合计算，<code>aggregator</code> 为聚合函数（如 <code>avg</code>, <code>sum</code>, <code>min</code>, <code>max</code> 等），<code>bucketDuration</code> 为桶的时长</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>BUCKETTIMESTAMP bt</code></td>\n<td>string</td>\n<td>聚合桶时间戳选择，<code>bt</code> 可为 <code>start</code> 或 <code>end</code></td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>EMPTY</code></td>\n<td>flag</td>\n<td>即使桶为空也返回结果</td>\n<td>可选</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询时间序列 ts:cpu:server1 的区间数据</span></span><br><span class=\"line\">TS.RANGE ts:cpu:server1 0 1767778308126</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 1767777655255</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">2) 1) (<span class=\"built_in\">integer</span>) 1767777807933</span><br><span class=\"line\">   2) 70.5</span><br><span class=\"line\">3) 1) (<span class=\"built_in\">integer</span>) 1767777873866</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">4) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">5) 1) (<span class=\"built_in\">integer</span>) 1767778300909</span><br><span class=\"line\">   2) 90.5</span><br><span class=\"line\">6) 1) (<span class=\"built_in\">integer</span>) 1767778308125</span><br><span class=\"line\">   2) 105.5</span><br><span class=\"line\">7) 1) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\">   2) 115.5</span><br><span class=\"line\"><span class=\"comment\"># 查询时间序列 ts:cpu:server1 的区间数据，并返回聚合结果，求1000ms内平均值</span></span><br><span class=\"line\">TS.RANGE ts:cpu:server1 - + AGGREGATION avg 1000</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 1767777655000</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">2) 1) (<span class=\"built_in\">integer</span>) 1767777807000</span><br><span class=\"line\">   2) 70.5</span><br><span class=\"line\">3) 1) (<span class=\"built_in\">integer</span>) 1767777873000</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">4) 1) (<span class=\"built_in\">integer</span>) 1767777965000</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">5) 1) (<span class=\"built_in\">integer</span>) 1767778300000</span><br><span class=\"line\">   2) 90.5</span><br><span class=\"line\">6) 1) (<span class=\"built_in\">integer</span>) 1767778308000</span><br><span class=\"line\">   2) 110.5</span><br></pre></td></tr></table></figure>\n<h4 id=\"3️⃣-TS-REVRANGE-按时间逆序查询一个时间序列的区间数据\">3️⃣ TS.REVRANGE : 按时间逆序查询一个时间序列的区间数据</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>与 TS.RANGE 类似，只是返回结果是倒序的</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.REVRANGE ts:cpu:server1 0 1767778308126</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\">   2) 115.5</span><br><span class=\"line\">2) 1) (<span class=\"built_in\">integer</span>) 1767778308125</span><br><span class=\"line\">   2) 105.5</span><br><span class=\"line\">3) 1) (<span class=\"built_in\">integer</span>) 1767778300909</span><br><span class=\"line\">   2) 90.5</span><br><span class=\"line\">4) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">5) 1) (<span class=\"built_in\">integer</span>) 1767777873866</span><br><span class=\"line\">   2) 80.5</span><br><span class=\"line\">6) 1) (<span class=\"built_in\">integer</span>) 1767777807933</span><br><span class=\"line\">   2) 70.5</span><br><span class=\"line\">7) 1) (<span class=\"built_in\">integer</span>) 1767777655255</span><br><span class=\"line\">   2) 80.5</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、数据查询（多序列-聚合）类\">四、数据查询（多序列 / 聚合）类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TS.MGET</strong></td>\n<td>根据标签过滤，获取多个时间序列的最新值</td>\n<td>批量获取多个实例的当前指标</td>\n</tr>\n<tr>\n<td><strong>TS.MRANGE</strong></td>\n<td>按标签过滤，正序查询多个时间序列的区间数据</td>\n<td>多维指标分析、聚合</td>\n</tr>\n<tr>\n<td><strong>TS.MREVRANGE</strong></td>\n<td>按标签过滤，逆序查询多个时间序列的区间数据</td>\n<td>最近数据聚合分析</td>\n</tr>\n<tr>\n<td><strong>TS.QUERYINDEX</strong></td>\n<td>根据标签过滤，返回匹配的时间序列 key 列表</td>\n<td>发现有哪些指标符合条件</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-TS-MGET-根据标签过滤，获取多个时间序列的最新值\">1️⃣ TS.MGET : 根据标签过滤，获取多个时间序列的最新值</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.MGET [LATEST] [WITHLABELS | &lt;SELECTED_LABELS label...&gt;] FILTER filterExpr...</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n<th>可选值 / 说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>LATEST</code></td>\n<td>flag</td>\n<td>对 compaction 类型的时间序列，返回最新（可能部分）的样本值</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>WITHLABELS</code></td>\n<td>flag</td>\n<td>返回样本的同时附带时间序列的所有标签</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>&lt;SELECTED_LABELS label...&gt;</code></td>\n<td>list</td>\n<td>返回样本时只附带指定标签</td>\n<td>可选，不能与 <code>WITHLABELS</code> 一起使用</td>\n</tr>\n<tr>\n<td><code>FILTER filterExpr...</code></td>\n<td>list of expressions</td>\n<td>过滤时间序列，根据标签匹配规则筛选出符合条件的序列</td>\n<td>必选，支持标签匹配表达式，如 <code>sensor=temperature</code> 或 <code>region=*</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有时间序列的最新值，根据标签过滤</span></span><br><span class=\"line\">TS.MGET WITHLABELS FILTER metric=cpu</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;ts:cpu:server1&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;host&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;server1&quot;</span></span><br><span class=\"line\">      2) 1) <span class=\"string\">&quot;metric&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">      3) 1) <span class=\"string\">&quot;env&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;prod&quot;</span></span><br><span class=\"line\">   3) 1) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\">      2) 115.5</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;ts:cpu:server2&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;host&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;server1&quot;</span></span><br><span class=\"line\">      2) 1) <span class=\"string\">&quot;metric&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">   3) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">      2) 90.5</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;ts:cpu:server3&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;host&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;server1&quot;</span></span><br><span class=\"line\">      2) 1) <span class=\"string\">&quot;metric&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">   3) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">      2) 70.5</span><br></pre></td></tr></table></figure>\n<h4 id=\"2️⃣-TS-MRANGE-按标签过滤，正序查询多个时间序列的区间数据\">2️⃣ TS.MRANGE : 按标签过滤，正序查询多个时间序列的区间数据</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.MRANGE fromTimestamp toTimestamp</span><br><span class=\"line\">  [LATEST]</span><br><span class=\"line\">  [FILTER_BY_TS ts...]</span><br><span class=\"line\">  [FILTER_BY_VALUE min max]</span><br><span class=\"line\">  [WITHLABELS | &lt;SELECTED_LABELS label...&gt;]</span><br><span class=\"line\">  [COUNT count]</span><br><span class=\"line\">  [[ALIGN align] AGGREGATION aggregator bucketDuration [BUCKETTIMESTAMP bt] [EMPTY]]</span><br><span class=\"line\">  FILTER filterExpr...</span><br><span class=\"line\">  [GROUPBY label REDUCE reducer]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n<th>可选值 / 说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>fromTimestamp</code></td>\n<td>integer</td>\n<td>查询起始时间戳，<code>-</code>: 最小值</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>toTimestamp</code></td>\n<td>integer</td>\n<td>查询结束时间戳，<code>+</code>: 最大值</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>LATEST</code></td>\n<td>flag</td>\n<td>对 compaction 类型的时间序列，返回最新（可能部分）的桶的聚合值</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>FILTER_BY_TS ts...</code></td>\n<td>list of integers</td>\n<td>只返回指定时间戳的样本</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>FILTER_BY_VALUE min max</code></td>\n<td>range</td>\n<td>只返回值在 <code>[min, max]</code> 区间的样本</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>WITHLABELS</code></td>\n<td>flag</td>\n<td>返回样本的同时附带时间序列的所有标签</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>&lt;SELECTED_LABELS label...&gt;</code></td>\n<td>list</td>\n<td>返回样本时只附带指定标签</td>\n<td>可选，不能与 <code>WITHLABELS</code> 一起使用</td>\n</tr>\n<tr>\n<td><code>COUNT count</code></td>\n<td>integer</td>\n<td>限制返回的样本数量（最多 <code>count</code> 个）</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>ALIGN align</code></td>\n<td>string</td>\n<td>对齐聚合桶的时间戳（如 <code>start</code>、<code>end</code> 或自定义时间戳）</td>\n<td>可选，需与 <code>AGGREGATION</code> 一起使用</td>\n</tr>\n<tr>\n<td><code>AGGREGATION aggregator bucketDuration</code></td>\n<td>aggregation</td>\n<td>对数据进行聚合计算，<code>aggregator</code> 为聚合函数（如 <code>avg</code>, <code>sum</code>, <code>min</code>, <code>max</code> 等），<code>bucketDuration</code> 为桶的时长</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>BUCKETTIMESTAMP bt</code></td>\n<td>string</td>\n<td>聚合桶时间戳选择，<code>bt</code> 可为 <code>start</code> 或 <code>end</code></td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>EMPTY</code></td>\n<td>flag</td>\n<td>即使桶为空也返回结果</td>\n<td>可选</td>\n</tr>\n<tr>\n<td><code>FILTER filterExpr...</code></td>\n<td>list of expressions</td>\n<td>过滤时间序列，根据标签匹配规则筛选出符合条件的序列</td>\n<td>必选</td>\n</tr>\n<tr>\n<td><code>GROUPBY label REDUCE reducer</code></td>\n<td>aggregation</td>\n<td>对返回结果按指定标签分组并应用 reducer 聚合函数（如 <code>SUM</code>, <code>MIN</code>, <code>MAX</code> 等）</td>\n<td>可选</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.MRANGE - + FILTER metric=cpu</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;ts:cpu:server1&quot;</span></span><br><span class=\"line\">   2) (empty array)</span><br><span class=\"line\">   3) 1) 1) (<span class=\"built_in\">integer</span>) 1767777655255</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      2) 1) (<span class=\"built_in\">integer</span>) 1767777807933</span><br><span class=\"line\">         2) 70.5</span><br><span class=\"line\">      3) 1) (<span class=\"built_in\">integer</span>) 1767777873866</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      4) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      5) 1) (<span class=\"built_in\">integer</span>) 1767778300909</span><br><span class=\"line\">         2) 90.5</span><br><span class=\"line\">      6) 1) (<span class=\"built_in\">integer</span>) 1767778308125</span><br><span class=\"line\">         2) 105.5</span><br><span class=\"line\">      7) 1) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\">         2) 115.5</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;ts:cpu:server2&quot;</span></span><br><span class=\"line\">   2) (empty array)</span><br><span class=\"line\">   3) 1) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">         2) 90.5</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;ts:cpu:server3&quot;</span></span><br><span class=\"line\">   2) (empty array)</span><br><span class=\"line\">   3) 1) 1) (<span class=\"built_in\">integer</span>) 1767777965870</span><br><span class=\"line\">         2) 70.5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按标签聚合</span></span><br><span class=\"line\">TS.MRANGE - +</span><br><span class=\"line\">    AGGREGATION avg 1000</span><br><span class=\"line\">    FILTER metric=cpu</span><br><span class=\"line\">    GROUPBY host REDUCE avg</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;host=server1&quot;</span></span><br><span class=\"line\">   2) (empty array)</span><br><span class=\"line\">   3) 1) 1) (<span class=\"built_in\">integer</span>) 1767777655000</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      2) 1) (<span class=\"built_in\">integer</span>) 1767777807000</span><br><span class=\"line\">         2) 70.5</span><br><span class=\"line\">      3) 1) (<span class=\"built_in\">integer</span>) 1767777873000</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      4) 1) (<span class=\"built_in\">integer</span>) 1767777965000</span><br><span class=\"line\">         2) 80.5</span><br><span class=\"line\">      5) 1) (<span class=\"built_in\">integer</span>) 1767778300000</span><br><span class=\"line\">         2) 90.5</span><br><span class=\"line\">      6) 1) (<span class=\"built_in\">integer</span>) 1767778308000</span><br><span class=\"line\">         2) 110.5</span><br></pre></td></tr></table></figure>\n<h4 id=\"3️⃣-TS-MREVRANGE-按标签过滤，逆序查询多个时间序列的区间数据\">3️⃣ TS.MREVRANGE : 按标签过滤，逆序查询多个时间序列的区间数据</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>与 TS.MRANGE 类似，只是查询结果是逆序的</p>\n</li>\n</ul>\n<h4 id=\"4️⃣-TS-QUERYINDEX-根据标签过滤，返回匹配的时间序列-key-列表\">4️⃣ TS.QUERYINDEX : 根据标签过滤，返回匹配的时间序列 key 列表</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S.QUERYINDEX filterExpr...</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.QUERYINDEX metric=cpu host=server1</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;ts:cpu:server1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;ts:cpu:server2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;ts:cpu:server3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"五、数据删除与维护类\">五、数据删除与维护类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TS.DEL</strong></td>\n<td>删除某个时间序列在指定时间范围内的样本</td>\n<td>清理异常数据、历史数据修正</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.DEL key fromTimestamp toTimestamp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.DEL ts:cpu:server1 0 1767777965870</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4 <span class=\"comment\"># 删除了 4 个样本</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"六、元数据与状态查询类\">六、元数据与状态查询类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><a href=\"http://TS.INFO\">TS.INFO</a></strong></td>\n<td>返回时间序列的元信息与统计信息</td>\n<td>排查问题、容量评估、监控状态</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.INFO key [DEBUG]</span><br><span class=\"line\"><span class=\"comment\"># DEBUG: 显示更为详细的信息</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TS.INFO ts:cpu:server1</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) totalSamples</span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"> 3) memoryUsage</span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 9184</span><br><span class=\"line\"> 5) firstTimestamp</span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1767778300909</span><br><span class=\"line\"> 7) lastTimestamp</span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 1767778308126</span><br><span class=\"line\"> 9) retentionTime</span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 7200000</span><br><span class=\"line\">11) chunkCount</span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">13) chunkSize</span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 8192</span><br><span class=\"line\">15) chunkType</span><br><span class=\"line\">16) compressed</span><br><span class=\"line\">17) duplicatePolicy</span><br><span class=\"line\">18) last</span><br><span class=\"line\">19) labels</span><br><span class=\"line\">20) 1) 1) <span class=\"string\">&quot;host&quot;</span></span><br><span class=\"line\">       2) <span class=\"string\">&quot;server1&quot;</span></span><br><span class=\"line\">    2) 1) <span class=\"string\">&quot;metric&quot;</span></span><br><span class=\"line\">       2) <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">    3) 1) <span class=\"string\">&quot;env&quot;</span></span><br><span class=\"line\">       2) <span class=\"string\">&quot;prod&quot;</span></span><br><span class=\"line\">21) sourceKey</span><br><span class=\"line\">22) (nil)</span><br><span class=\"line\">23) rules</span><br><span class=\"line\">24) (empty array)</span><br><span class=\"line\">25) ignoreMaxTimeDiff</span><br><span class=\"line\">26) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\">27) ignoreMaxValDiff</span><br><span class=\"line\">28) <span class=\"string\">&quot;0.1&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"真实案例\">真实案例</h2>\n<h3 id=\"场景说明\">场景说明</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>假设我们有一个 IoT 设备监控系统，每台设备每分钟会上报一次温度和湿度数据。我们希望：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">存储每台设备的时间序列数据。</li>\n<li class=\"lvl-6\">查询最近一小时的数据。</li>\n<li class=\"lvl-6\">统计每 5 分钟的平均温度和湿度。</li>\n<li class=\"lvl-6\">获取最新的温度值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"步骤\">步骤</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">创建时间序列</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建设备 device:1001 的温度时间序列</span></span><br><span class=\"line\">TS.CREATE device:1001:temperature RETENTION 86400000 LABELS device_id 1001 <span class=\"built_in\">type</span> temperature</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建设备 device:1001 的湿度时间序列</span></span><br><span class=\"line\">TS.CREATE device:1001:humidity RETENTION 86400000 LABELS device_id 1001 <span class=\"built_in\">type</span> humidity</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\">    <span class=\"comment\"># RETENTION 86400000：数据保留 24 小时（单位毫秒）。</span></span><br><span class=\"line\">    <span class=\"comment\"># LABELS：方便后续按标签聚合查询。</span></span><br><span class=\"line\">    <span class=\"comment\"># TS.CREATE 用于创建时间序列 key。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">插入数据</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假设时间戳为当前毫秒</span></span><br><span class=\"line\">TS.ADD device:1001:temperature * 26.5</span><br><span class=\"line\">TS.ADD device:1001:humidity * 60.2</span><br><span class=\"line\"><span class=\"comment\"># 此处假设会每分钟插入一次数据</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">查询时间范围数据</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取 过去一小时的温度数据：</span></span><br><span class=\"line\"><span class=\"comment\"># 过去一小时的时间戳可以这样获得</span></span><br><span class=\"line\">EVAL <span class=\"string\">&quot;return redis.call(&#x27;TIME&#x27;)[1]*1000 - 3600000&quot;</span> 0</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1767777794000</span><br><span class=\"line\"></span><br><span class=\"line\">TS.RANGE device:1001:temperature 1767777794000 +</span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\">    <span class=\"comment\"># -3600000 表示一小时前。</span></span><br><span class=\"line\">    <span class=\"comment\"># + 表示到现在。</span></span><br><span class=\"line\">    <span class=\"comment\"># 返回结果为 [timestamp, value] 数组。</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 1767781256846</span><br><span class=\"line\">   2) 26.5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">聚合查询（Downsampling）</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 统计 每 5 分钟平均温度：</span></span><br><span class=\"line\">TS.RANGE device:1001:temperature 1767777794000 + AGGREGATION avg 300000</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    <span class=\"comment\"># AGGREGATION avg 300000 表示每 300,000 ms（5 分钟）聚合一次。</span></span><br><span class=\"line\">    <span class=\"comment\"># RedisTimeSeries 支持多种聚合函数：avg, sum, min, max, count。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"5\">\n<li class=\"lvl-5\">获取最新值</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取最新的温度值：</span></span><br><span class=\"line\">TS.GET device:1001:temperature</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">    <span class=\"comment\"># TS.GET 会返回最新一个数据点 [timestamp, value]。</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果使用了压缩策略 LATEST，返回的值可能是当前聚合桶的值。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"6\">\n<li class=\"lvl-5\">按标签查询</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果我们想获取 所有设备的温度平均值（假设有很多设备）：</span></span><br><span class=\"line\">TS.MRANGE - + AGGREGATION avg 300000 FILTER <span class=\"built_in\">type</span>=temperature</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    <span class=\"comment\"># TS.MRANGE 支持多 key 查询，并且可以按标签过滤。</span></span><br><span class=\"line\">    <span class=\"comment\"># 聚合函数可以对每个匹配 key 单独计算。</span></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;device:1001:temperature&quot;</span></span><br><span class=\"line\">   2) (empty array)</span><br><span class=\"line\">   3) 1) 1) (<span class=\"built_in\">integer</span>) 1767781200000</span><br><span class=\"line\">         2) 26.5</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisTimeSeries 中 TimeSeries 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisTimeSeries 的安装参见 Redis 扩展模块 -- RedisTimeSeries 的安装方法 TimeSeries 简介 TimeSeries 是 Redis 的一个扩展模块，用于处理时间序列数据，RedisTimeSeries | A NoSQL Time Series Database 核心设计与数据模型 一个 Redis 时间序列（Time Series） 是有序的一系列采样数据点： 组成部分 说明 时间戳（timestamp） 毫秒级时间标签，可客户端指定或由服务器填充 值（value） 64 位浮点数 元数据（labels） 一组键值对，可用于过滤与聚合查询 保留策略（retention） 数据生命周期控制，过期自动丢弃 主要功能与特性 特性 说明 高吞吐写入 支持每秒接收大量数据点，延迟极低 区间查询 可按时间范围检索数据，如 TS.RANGE / TS.MRANGE 聚合查询 内建 min、max、avg、sum、count、first、last 等聚合功能 自动下采样 &amp; 累积规则 通过 aggregation rules 自动生成更粗粒度指标 保留策略（Retention） 设置最大保存时间或样本数量 标签索引（Labels） 支持基于标签的跨序列查询 高效存储 使用压缩与内存结构优化空间成本 工具整合 支持 Grafana、Prometheus、Telegraf 等生态集成 应用场景 场景 描述 物联网（IoT）监控 温度、湿度、设备状态等 系统监控与指标收集 CPU、内存、网络指标的实时存储与分析 业务指标分析 每日/每小时活跃用户数量、请求延迟等 金融时间序列 股票价格、交易量的快速写入和分析 实时告警 数据越界时触发告警逻辑 TimeSeries 命令说明 按“生命周期”视角的快速索引 阶段 对应命令 创建 TS.CREATE 修改结构 TS.ALTER 建立聚合 TS.CREATERULE / TS.DELETERULE 写入 TS.ADD / TS.MADD / TS.INCRBY / TS.DECRBY 查询单序列 TS.GET / TS.RANGE / TS.REVRANGE 查询多序列 TS.MGET / TS.MRANGE / TS.MREVRANGE / TS.QUERYINDEX 清理数据 TS.DEL 查看状态 TS.INFO 一、时间序列创建与结构管理类 命令 功能说明 典型使用场景 TS.CREATE 创建一个新的时间序列（可指定保留策略、标签、chunk 大小等） 初始化指标，如创建 CPU、QPS、延迟等指标序列 TS.ALTER 修改已有时间序列的配置（retention、chunk size、duplicate policy、labels） 动态调整数据保留周期、标签信息 TS.CREATERULE 创建压缩 / 聚合规则（从 source series 自动聚合到 dest series） 原始数据 → 按分钟 / 小时聚合 TS.DELETERULE 删除已有的压缩 / 聚合规则 停止某条自动聚合规则 1️⃣ TS.CREATE : 创建时间序列 语法： 1234567TS.CREATE key [RETENTION retentionPeriod] [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;] [CHUNK_SIZE size] [DUPLICATE_POLICY policy] [IGNORE ignoreMaxTimediff ignoreMaxValDiff] [LABELS [label value ...]] 参数说明： 参数 作用 可选值 / 约束 默认值 典型使用建议 key 时间序列的 Redis Key 任意合法 Redis key 无 建议包含业务语义，如 ts:cpu:node1 RETENTION 数据保留时长（毫秒），超过自动删除 ≥ 0，0 表示永久保留 0 高频指标必须设置，避免内存无限增长 ENCODING 数据存储编码方式 COMPRESSED: 内存占用低，CPU 有轻微开销 UNCOMPRESSED:查询快，占用内存高 COMPRESSED 绝大多数场景保持默认 CHUNK_SIZE 每个数据块的大小（字节），影响内存碎片与压缩效率 ≥ 128 bytes（通常 1KB–64KB） 4096 写入频繁时适当调大 DUPLICATE_POLICY 同一 timestamp 重复写入时的处理策略 见下表 全局配置 明确指定，避免默认行为变化 IGNORE 忽略与上一点差异过小的数据 ignoreMaxTimediff: 最大允许时间差（毫秒） ignoreMaxValDiff: 最大允许的数值差 关闭 用于降噪和降采样 示例：IGNORE 1000 0.01： 1 秒内，变化小于 0.01 的数据将被忽略 LABELS 标签键值对，用于索引和过滤 任意字符串对LABELS key1 value1 key2 value2 ... 无 强烈建议用于查询 DUPLICATE_POLICY（重复时间戳策略） 当同一个 timestamp 被多次写入时生效 策略 处理逻辑 BLOCK 默认，重复时间戳直接失败 FIRST 保留已有值，忽略新值 LAST 覆盖已有值，用新值替代 MIN 仅当新值更小才覆盖 MAX 仅当新值更大才覆盖 SUM 累加值（已有值 + 新值） 示例: 创建一个 CPU 指标时间序列，自动过期 1 小时之前的数据 1234567891011TS.CREATE ts:cpu:server1 RETENTION 3600000 ENCODING COMPRESSED CHUNK_SIZE 8192 DUPLICATE_POLICY LAST IGNORE 1000 0.1 LABELS host server1 metric cpu# 查看数据类型127.0.0.1:6379&gt; type ts:cpu:server1TSDB-TYPE 2️⃣ TS.ALTER : 修改时间序列配置 语法： 12345TS.ALTER key [RETENTION retentionPeriod] [CHUNK_SIZE size] [DUPLICATE_POLICY policy] [LABELS [label value ...]] 示例：修改保留周期和标签 123TS.ALTER ts:cpu:server1 RETENTION 7200000 LABELS host server1 metric cpu env prod 3️⃣ TS.CREATERULE : 创建自动聚合规则 场景说明 原始序列：ts:cpu:server1（秒级数据） 聚合目标：ts:cpu:server1:avg1m（按 1 分钟平均值聚合） 语法： 123TS.CREATERULE sourceKey destKey AGGREGATION aggregator bucketDuration [alignTimestamp] 参数说明 参数 作用 可选值 / 约束 是否必填 行为说明 使用注意事项 sourceKey 源时间序列 Key 必须是已存在的 TS key 是 新写入数据从该序列触发聚合 必须先创建 destKey 目标聚合时间序列 Key 必须是已存在的 TS key 是 聚合结果写入该序列 通常 retention 更长 aggregator 聚合函数 见下表 是 定义每个 bucket 内如何计算 不同函数计算成本不同 bucketDuration 聚合时间桶宽度（毫秒） &gt; 0 是 控制聚合粒度 决定数据降采样程度 alignTimestamp 对齐时间戳基准 毫秒时间戳 否 控制 bucket 起始对齐方式 跨系统对齐时非常重要 aggregator（聚合函数） 聚合器 说明 AVG 平均值 SUM 求和 MIN 最小值 MAX 最大值 COUNT 样本数量 FIRST 第一个样本 LAST 最后一个样本 RANGE MAX - MIN STD.P 总体标准差 STD.S 样本标准差 VAR.P 总体方差 VAR.S 样本方差 alignTimestamp（对齐时间戳基准） 类型 示例值 含义 0（Unix Epoch）（推荐做法） 0 从 1970-01-01 00:00:00 UTC 对齐 任意固定时间戳 1700000000000 从指定时间点对齐 当前时间戳 $(date +%s%3N) 从创建规则时刻对齐 业务时间边界 某天 00:00 的毫秒值 对齐到业务周期 不指定 （参数省略） 自动使用首条写入时间 示例: 每 60,000ms（1分钟）做一次平均聚合 1234567891011121314151617181920# 1.创建目标聚合序列TS.CREATE ts:cpu:server1:avg1m RETENTION 86400000 LABELS host server1 metric cpu_1m# 2.创建自动聚合规则TS.CREATERULE ts:cpu:server1 ts:cpu:server1:avg1m AGGREGATION AVG 60000## 如果未设置 alignTimestamp，则以创建的第一条记录的时间为基准## 比如第一条记录的时间为：12:00:23## bucket 会对齐到: # 12:00:23 ~ 12:01:23 # 12:01:23 ~ 12:02:23# 指定 alignTimestamp 对齐到整分钟TS.CREATERULE ts:cpu:server1 ts:cpu:server1:avg1m AGGREGATION AVG 60000 0## bucket 会严格对齐: # 12:00:00 ~ 12:01:00 # 12:01:00 ~ 12:02:00 4️⃣ TS.DELETERULE : 删除自动聚合规则 语法： 1TS.DELETERULE sourceKey destKey 示例：删除自动聚合规则 1TS.DELETERULE ts:cpu:server1 ts:cpu:server1:avg1m 二、数据写入与更新类 命令 功能说明 典型使用场景 TS.ADD 向时间序列追加一个样本点（timestamp, value） 实时写入监控数据 TS.MADD 批量向多个时间序列追加样本 高吞吐场景，减少网络 RTT TS.INCRBY 对最新时间戳的值做自增（不存在则创建新样本） 计数器、累计指标 TS.DECRBY 对最新时间戳的值做自减（不存在则创建新样本） 库存、余额类递减指标 1️⃣ TS.ADD : 向时间序列追加一个样本点 语法： 12345678TS.ADD key timestamp value [RETENTION retentionPeriod] [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;] [CHUNK_SIZE size] [DUPLICATE_POLICY policy] [ON_DUPLICATE policy_ovr] [IGNORE ignoreMaxTimediff ignoreMaxValDiff] [LABELS [label value ...]] 如果 key 不存在，TS.ADD 会 隐式创建时间序列（类似 TS.CREATE）。 参数说明 参数 作用 可选值 / 约束 是否覆盖已有配置 生效范围 使用注意事项 key 时间序列 Key 合法 Redis key — — 不存在时自动创建 timestamp 样本时间戳 毫秒整数 / * — 当前写入 * 表示服务器当前时间 value 样本值 浮点数 — 当前写入 NaN / Inf 不允许 RETENTION 设置保留周期 ≥ 0（毫秒） 仅首次创建生效 序列级 已存在 key 不会被修改 ENCODING 存储编码 COMPRESSED / UNCOMPRESSED 仅首次创建生效 序列级 生产推荐 COMPRESSED CHUNK_SIZE 数据块大小 ≥ 128 bytes 仅首次创建生效 序列级 不影响已有 chunk DUPLICATE_POLICY 设置默认重复策略 BLOCK / FIRST / LAST / MIN / MAX / SUM 仅首次创建生效 序列级 与 ON_DUPLICATE 有优先级关系 ON_DUPLICATE 本次写入的重复策略 同上 覆盖序列级策略 当前写入 推荐用于临时覆盖 IGNORE 忽略微小变化写入 两个阈值 仅首次创建生效 序列级 用于降噪 LABELS 设置标签 键值对 仅首次创建生效 序列级 已存在 key 不会修改 示例：写入一个时间序列 123TS.ADD ts:cpu:server1 * 80.5## 输出(integer) 1767777655255 # 当前时间戳 2️⃣ TS.MADD : 批量向多个时间序列追加样本 语法 1TS.MADD key timestamp value [key timestamp value ...] 示例：批量写入多个时间序列 123456# 批量写入三个时间序列，时间序列必须存在TS.MADD ts:cpu:server1 * 80.5 ts:cpu:server2 * 90.5 ts:cpu:server3 * 70.5## 输出1) (integer) 17677778079332) (integer) 17677778079333) (integer) 1767777807933 3️⃣ TS.INCRBY : 对最新时间戳的值做自增（不存在则创建新样本） 语法： 12345678TS.INCRBY key addend [TIMESTAMP timestamp] [RETENTION retentionPeriod] [ENCODING &lt;COMPRESSED|UNCOMPRESSED&gt;] [CHUNK_SIZE size] [DUPLICATE_POLICY policy] [IGNORE ignoreMaxTimediff ignoreMaxValDiff] [LABELS [label value ...]] 参数说明 参数 作用 可选值 / 约束 是否覆盖已有配置 生效范围 使用注意事项 key 时间序列 Key 合法 Redis key — — 不存在会自动创建 addend 增量值 浮点数 — 当前写入 支持负数（等价 DECR） TIMESTAMP 指定写入时间戳 毫秒整数 — 当前写入 默认使用服务器时间 RETENTION 设置保留周期 ≥ 0（毫秒） 仅首次创建生效 序列级 已存在 key 不生效 ENCODING 存储编码 COMPRESSED / UNCOMPRESSED 仅首次创建生效 序列级 推荐 COMPRESSED CHUNK_SIZE 数据块大小 ≥ 128 bytes 仅首次创建生效 序列级 高频写入可调大 DUPLICATE_POLICY 默认重复时间戳策略 BLOCK / FIRST / LAST / MIN / MAX / SUM 仅首次创建生效 序列级 对计数器通常设 SUM IGNORE 忽略微小变化 两个阈值 仅首次创建生效 序列级 计数器一般不使用 LABELS 标签 键值对 仅首次创建生效 序列级 用于 MGET / MRANGE 如果 key 不存在，TS.INCRBY 会 隐式创建时间序列。 如果没有指定 TIMESTAMP，则自动使用服务器当前时间。 写入逻辑等价于：读取最新值 + addend → 写回一个新样本。 示例 1234567# 对最新时间戳的值做自增TS.INCRBY ts:cpu:server1 10## 输出(integer) 1767778308125# 指定时间戳，TIMESTAMP 必须大于或等于当前时间序列中最大的时间戳TS.INCRBY ts:cpu:server1 5 TIMESTAMP 1767778308126 4️⃣ TS.DECRBY : 对最新时间戳的值做自减（不存在则创建新样本） 与 TS.INCRBY 相似，不再赘述。 实际上 TS.INCRBY 中设置 addend 为负数 就是 TS.DECR 三、数据查询（单序列）类 命令 功能说明 典型使用场景 TS.GET 获取某个时间序列最新（最大 timestamp）的样本 获取当前最新指标值 TS.RANGE 按时间正序查询一个时间序列的区间数据 绘图、趋势分析 TS.REVRANGE 按时间逆序查询一个时间序列的区间数据 获取最近 N 条数据 1️⃣ TS.GET : 获取某个时间序列最新（最大 timestamp）的样本 语法： 1TS.GET key [LATEST] 参数说明： 参数 作用 key 时间序列 Key LATEST 获取最新样本 LATEST 说明 当一个时间序列是经过聚合（compaction）处理的时，LATEST 参数会生效。使用 LATEST 时，TS.GET 会返回最新（可能是部分的）桶的聚合值。不使用 LATEST 时，TS.GET 不会返回最新（可能是部分的）桶的值。当时间序列不是聚合的时，LATEST 会被忽略。 最新桶中的数据可能是不完整的。只有当有新的样本到来并开启一个新的最新桶时，原桶才会被关闭并进行聚合。然而，在某些情况下，也需要获取最新（可能是部分的）桶的聚合值，此时就可以使用 LATEST。 示例： 1234TS.GET ts:cpu:server1 LATEST## 输出1) (integer) 17677783081262) 115.5 2️⃣ TS.RANGE : 按时间正序查询一个时间序列的区间数据 语法： 123456TS.RANGE key fromTimestamp toTimestamp [LATEST] [FILTER_BY_TS ts...] [FILTER_BY_VALUE min max] [COUNT count] [[ALIGN align] AGGREGATION aggregator bucketDuration [BUCKETTIMESTAMP bt] [EMPTY]] 参数说明： 参数 类型 说明 可选值 / 说明 key string 时间序列的键名 必选 fromTimestamp integer 查询起始时间戳，-: 最小值 必选 toTimestamp integer 查询结束时间戳 ，+: 最大值 必选 LATEST flag 当时间序列是 compaction 时，返回最新（可能部分）的桶的聚合值 可选 FILTER_BY_TS ts... list of integers 只返回指定时间戳的样本 可选 FILTER_BY_VALUE min max range 只返回值在 [min, max] 区间的样本 可选 COUNT count integer 限制返回的样本数量（最多 count 个） 可选 ALIGN align string 对齐聚合桶的时间戳（如 start、end、自定义时间戳） 可选，需与 AGGREGATION 一起使用 AGGREGATION aggregator bucketDuration aggregation 对数据进行聚合计算，aggregator 为聚合函数（如 avg, sum, min, max 等），bucketDuration 为桶的时长 可选 BUCKETTIMESTAMP bt string 聚合桶时间戳选择，bt 可为 start 或 end 可选 EMPTY flag 即使桶为空也返回结果 可选 示例： 1234567891011121314151617181920212223242526272829303132# 查询时间序列 ts:cpu:server1 的区间数据TS.RANGE ts:cpu:server1 0 1767778308126## 输出1) 1) (integer) 1767777655255 2) 80.52) 1) (integer) 1767777807933 2) 70.53) 1) (integer) 1767777873866 2) 80.54) 1) (integer) 1767777965870 2) 80.55) 1) (integer) 1767778300909 2) 90.56) 1) (integer) 1767778308125 2) 105.57) 1) (integer) 1767778308126 2) 115.5# 查询时间序列 ts:cpu:server1 的区间数据，并返回聚合结果，求1000ms内平均值TS.RANGE ts:cpu:server1 - + AGGREGATION avg 1000## 输出1) 1) (integer) 1767777655000 2) 80.52) 1) (integer) 1767777807000 2) 70.53) 1) (integer) 1767777873000 2) 80.54) 1) (integer) 1767777965000 2) 80.55) 1) (integer) 1767778300000 2) 90.56) 1) (integer) 1767778308000 2) 110.5 3️⃣ TS.REVRANGE : 按时间逆序查询一个时间序列的区间数据 与 TS.RANGE 类似，只是返回结果是倒序的 示例 12345678910111213141516TS.REVRANGE ts:cpu:server1 0 1767778308126## 输出1) 1) (integer) 1767778308126 2) 115.52) 1) (integer) 1767778308125 2) 105.53) 1) (integer) 1767778300909 2) 90.54) 1) (integer) 1767777965870 2) 80.55) 1) (integer) 1767777873866 2) 80.56) 1) (integer) 1767777807933 2) 70.57) 1) (integer) 1767777655255 2) 80.5 四、数据查询（多序列 / 聚合）类 命令 功能说明 典型使用场景 TS.MGET 根据标签过滤，获取多个时间序列的最新值 批量获取多个实例的当前指标 TS.MRANGE 按标签过滤，正序查询多个时间序列的区间数据 多维指标分析、聚合 TS.MREVRANGE 按标签过滤，逆序查询多个时间序列的区间数据 最近数据聚合分析 TS.QUERYINDEX 根据标签过滤，返回匹配的时间序列 key 列表 发现有哪些指标符合条件 1️⃣ TS.MGET : 根据标签过滤，获取多个时间序列的最新值 语法： 1TS.MGET [LATEST] [WITHLABELS | &lt;SELECTED_LABELS label...&gt;] FILTER filterExpr... 参数说明： 参数 类型 说明 可选值 / 说明 LATEST flag 对 compaction 类型的时间序列，返回最新（可能部分）的样本值 可选 WITHLABELS flag 返回样本的同时附带时间序列的所有标签 可选 &lt;SELECTED_LABELS label...&gt; list 返回样本时只附带指定标签 可选，不能与 WITHLABELS 一起使用 FILTER filterExpr... list of expressions 过滤时间序列，根据标签匹配规则筛选出符合条件的序列 必选，支持标签匹配表达式，如 sensor=temperature 或 region=* 示例： 1234567891011121314151617181920212223242526# 获取所有时间序列的最新值，根据标签过滤TS.MGET WITHLABELS FILTER metric=cpu## 输出1) 1) &quot;ts:cpu:server1&quot; 2) 1) 1) &quot;host&quot; 2) &quot;server1&quot; 2) 1) &quot;metric&quot; 2) &quot;cpu&quot; 3) 1) &quot;env&quot; 2) &quot;prod&quot; 3) 1) (integer) 1767778308126 2) 115.52) 1) &quot;ts:cpu:server2&quot; 2) 1) 1) &quot;host&quot; 2) &quot;server1&quot; 2) 1) &quot;metric&quot; 2) &quot;cpu&quot; 3) 1) (integer) 1767777965870 2) 90.53) 1) &quot;ts:cpu:server3&quot; 2) 1) 1) &quot;host&quot; 2) &quot;server1&quot; 2) 1) &quot;metric&quot; 2) &quot;cpu&quot; 3) 1) (integer) 1767777965870 2) 70.5 2️⃣ TS.MRANGE : 按标签过滤，正序查询多个时间序列的区间数据 语法： 123456789TS.MRANGE fromTimestamp toTimestamp [LATEST] [FILTER_BY_TS ts...] [FILTER_BY_VALUE min max] [WITHLABELS | &lt;SELECTED_LABELS label...&gt;] [COUNT count] [[ALIGN align] AGGREGATION aggregator bucketDuration [BUCKETTIMESTAMP bt] [EMPTY]] FILTER filterExpr... [GROUPBY label REDUCE reducer] 参数说明： 参数 类型 说明 可选值 / 说明 fromTimestamp integer 查询起始时间戳，-: 最小值 必选 toTimestamp integer 查询结束时间戳，+: 最大值 必选 LATEST flag 对 compaction 类型的时间序列，返回最新（可能部分）的桶的聚合值 可选 FILTER_BY_TS ts... list of integers 只返回指定时间戳的样本 可选 FILTER_BY_VALUE min max range 只返回值在 [min, max] 区间的样本 可选 WITHLABELS flag 返回样本的同时附带时间序列的所有标签 可选 &lt;SELECTED_LABELS label...&gt; list 返回样本时只附带指定标签 可选，不能与 WITHLABELS 一起使用 COUNT count integer 限制返回的样本数量（最多 count 个） 可选 ALIGN align string 对齐聚合桶的时间戳（如 start、end 或自定义时间戳） 可选，需与 AGGREGATION 一起使用 AGGREGATION aggregator bucketDuration aggregation 对数据进行聚合计算，aggregator 为聚合函数（如 avg, sum, min, max 等），bucketDuration 为桶的时长 可选 BUCKETTIMESTAMP bt string 聚合桶时间戳选择，bt 可为 start 或 end 可选 EMPTY flag 即使桶为空也返回结果 可选 FILTER filterExpr... list of expressions 过滤时间序列，根据标签匹配规则筛选出符合条件的序列 必选 GROUPBY label REDUCE reducer aggregation 对返回结果按指定标签分组并应用 reducer 聚合函数（如 SUM, MIN, MAX 等） 可选 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647TS.MRANGE - + FILTER metric=cpu## 输出1) 1) &quot;ts:cpu:server1&quot; 2) (empty array) 3) 1) 1) (integer) 1767777655255 2) 80.5 2) 1) (integer) 1767777807933 2) 70.5 3) 1) (integer) 1767777873866 2) 80.5 4) 1) (integer) 1767777965870 2) 80.5 5) 1) (integer) 1767778300909 2) 90.5 6) 1) (integer) 1767778308125 2) 105.5 7) 1) (integer) 1767778308126 2) 115.52) 1) &quot;ts:cpu:server2&quot; 2) (empty array) 3) 1) 1) (integer) 1767777965870 2) 90.53) 1) &quot;ts:cpu:server3&quot; 2) (empty array) 3) 1) 1) (integer) 1767777965870 2) 70.5# 按标签聚合TS.MRANGE - + AGGREGATION avg 1000 FILTER metric=cpu GROUPBY host REDUCE avg## 输出1) 1) &quot;host=server1&quot; 2) (empty array) 3) 1) 1) (integer) 1767777655000 2) 80.5 2) 1) (integer) 1767777807000 2) 70.5 3) 1) (integer) 1767777873000 2) 80.5 4) 1) (integer) 1767777965000 2) 80.5 5) 1) (integer) 1767778300000 2) 90.5 6) 1) (integer) 1767778308000 2) 110.5 3️⃣ TS.MREVRANGE : 按标签过滤，逆序查询多个时间序列的区间数据 与 TS.MRANGE 类似，只是查询结果是逆序的 4️⃣ TS.QUERYINDEX : 根据标签过滤，返回匹配的时间序列 key 列表 语法： 1S.QUERYINDEX filterExpr... 示例： 12345TS.QUERYINDEX metric=cpu host=server1## 输出1) &quot;ts:cpu:server1&quot;2) &quot;ts:cpu:server2&quot;3) &quot;ts:cpu:server3&quot; 五、数据删除与维护类 命令 功能说明 典型使用场景 TS.DEL 删除某个时间序列在指定时间范围内的样本 清理异常数据、历史数据修正 语法 1TS.DEL key fromTimestamp toTimestamp 示例： 123TS.DEL ts:cpu:server1 0 1767777965870## 输出(integer) 4 # 删除了 4 个样本 六、元数据与状态查询类 命令 功能说明 典型使用场景 TS.INFO 返回时间序列的元信息与统计信息 排查问题、容量评估、监控状态 语法 12TS.INFO key [DEBUG]# DEBUG: 显示更为详细的信息 示例： 1234567891011121314151617181920212223242526272829303132333435TS.INFO ts:cpu:server1## 输出1) totalSamples 2) (integer) 3 3) memoryUsage 4) (integer) 9184 5) firstTimestamp 6) (integer) 1767778300909 7) lastTimestamp 8) (integer) 1767778308126 9) retentionTime10) (integer) 720000011) chunkCount12) (integer) 113) chunkSize14) (integer) 819215) chunkType16) compressed17) duplicatePolicy18) last19) labels20) 1) 1) &quot;host&quot; 2) &quot;server1&quot; 2) 1) &quot;metric&quot; 2) &quot;cpu&quot; 3) 1) &quot;env&quot; 2) &quot;prod&quot;21) sourceKey22) (nil)23) rules24) (empty array)25) ignoreMaxTimeDiff26) (integer) 100027) ignoreMaxValDiff28) &quot;0.1&quot; 真实案例 场景说明 假设我们有一个 IoT 设备监控系统，每台设备每分钟会上报一次温度和湿度数据。我们希望： 存储每台设备的时间序列数据。 查询最近一小时的数据。 统计每 5 分钟的平均温度和湿度。 获取最新的温度值。 步骤 创建时间序列 12345678910# 创建设备 device:1001 的温度时间序列TS.CREATE device:1001:temperature RETENTION 86400000 LABELS device_id 1001 type temperature# 创建设备 device:1001 的湿度时间序列TS.CREATE device:1001:humidity RETENTION 86400000 LABELS device_id 1001 type humidity## 说明： # RETENTION 86400000：数据保留 24 小时（单位毫秒）。 # LABELS：方便后续按标签聚合查询。 # TS.CREATE 用于创建时间序列 key。 插入数据 1234# 假设时间戳为当前毫秒TS.ADD device:1001:temperature * 26.5TS.ADD device:1001:humidity * 60.2# 此处假设会每分钟插入一次数据 查询时间范围数据 1234567891011121314# 获取 过去一小时的温度数据：# 过去一小时的时间戳可以这样获得EVAL &quot;return redis.call(&#x27;TIME&#x27;)[1]*1000 - 3600000&quot; 0## 输出(integer) 1767777794000TS.RANGE device:1001:temperature 1767777794000 +## 说明 # -3600000 表示一小时前。 # + 表示到现在。 # 返回结果为 [timestamp, value] 数组。## 输出1) 1) (integer) 1767781256846 2) 26.5 聚合查询（Downsampling） 12345# 统计 每 5 分钟平均温度：TS.RANGE device:1001:temperature 1767777794000 + AGGREGATION avg 300000# 说明： # AGGREGATION avg 300000 表示每 300,000 ms（5 分钟）聚合一次。 # RedisTimeSeries 支持多种聚合函数：avg, sum, min, max, count。 获取最新值 12345# 获取最新的温度值：TS.GET device:1001:temperature# 说明 # TS.GET 会返回最新一个数据点 [timestamp, value]。 # 如果使用了压缩策略 LATEST，返回的值可能是当前聚合桶的值。 按标签查询 12345678910# 如果我们想获取 所有设备的温度平均值（假设有很多设备）：TS.MRANGE - + AGGREGATION avg 300000 FILTER type=temperature# 说明： # TS.MRANGE 支持多 key 查询，并且可以按标签过滤。 # 聚合函数可以对每个匹配 key 单独计算。# 输出1) 1) &quot;device:1001:temperature&quot; 2) (empty array) 3) 1) 1) (integer) 1767781200000 2) 26.5","summary":"摘要 本文介绍 Redis 扩展模块 – RedisTimeSeries 中 TimeSeries 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisTimeSeries 的安装参见 Redis 扩展模块 -- RedisTimeSeries 的安装方法","date_published":"2026-01-07T14:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2026/01/07/redis7-module-RedisTimeSeries/","url":"https://blog.hanqunfeng.com/2026/01/07/redis7-module-RedisTimeSeries/","title":"Redis 扩展模块 -- RedisTimeSeries 的安装方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisTimeSeries 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisTimeSeries-简介\">RedisTimeSeries 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisTimeSeries/RedisTimeSeries\">RedisTimeSeries</a> 是 Redis 官方提供的一个 时序数据模块（Time Series Module），用于高效地存储、查询和分析时间序列数据。它可以作为 Redis 的一个模块加载使用（在 Redis Stack 中内置支持），将时序数据建模、存储和聚合能力扩展到 Redis 之外。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisTimeSeries 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n</ul>\n<h2 id=\"安装-RedisTimeSeries\">安装 RedisTimeSeries</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>虽然<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中提供了所有Redis模块编译后的<code>.so</code>文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redistimeseries.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y \\</span><br><span class=\"line\">  gcc \\</span><br><span class=\"line\">  gcc-c++ \\</span><br><span class=\"line\">  make \\</span><br><span class=\"line\">  cmake \\</span><br><span class=\"line\">  autoconf \\</span><br><span class=\"line\">  automake \\</span><br><span class=\"line\">  libtool \\</span><br><span class=\"line\">  pkgconfig \\</span><br><span class=\"line\">  openssl-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译 RedisTimeSeries</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisTimeSeries/RedisTimeSeries.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisTimeSeries</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v1.12.9</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: af92230</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">dnf install -q -y git jq</span><br><span class=\"line\">/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y autoconf libtool m4 automake</span><br><span class=\"line\">dnf install -q -y openssl</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepel</span><br><span class=\"line\">dnf install -q -y openssl-devel</span><br><span class=\"line\">/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getgcc --modern</span><br><span class=\"line\">dnf install -q -y valgrind</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getaws</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r /usr/local/soft/modules/RedisTimeSeries/tests/flow/requirements.txt</span><br><span class=\"line\">NO_PY2=1 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getpudb</span><br><span class=\"line\">amazon_linux_2023</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RedisTimeSeries</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/redistimeseries.so`</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">……</span><br><span class=\"line\">Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 172.67.157.246)</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepel:</span><br><span class=\"line\">346      \t\t<span class=\"comment\"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class=\"line\">347      \t<span class=\"keyword\">fi</span></span><br><span class=\"line\">348</span><br><span class=\"line\">349  &gt;&gt;&gt; \tinstall_raven</span><br><span class=\"line\">350      \tinstall_remi</span><br><span class=\"line\">351      \t<span class=\"comment\"># install_centos_stream_repos</span></span><br><span class=\"line\">352</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepel</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisTimeSeries/sbin/setup:</span><br><span class=\"line\">18       \tpython3 -m pip list</span><br><span class=\"line\">19       <span class=\"keyword\">fi</span></span><br><span class=\"line\">20</span><br><span class=\"line\">21   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py <span class=\"variable\">$SETUP_ARGS</span></span><br><span class=\"line\">22       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">23       \tpython3 -m pip list</span><br><span class=\"line\">24       <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">错误分析与解决方法：\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">这个错误与安装 RedisBloom 时一样，禁用掉 <code>install_raven</code> 即可，具体参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a> 进行修改。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <code>redistimeseries.so</code> 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要包含可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> bin/linux-x64-release/redistimeseries.so /usr/local/soft/redis-7.4.7/modules/redistimeseries.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 redistimeseries.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redistimeseries.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 11209</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20816</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 21025</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisTimeSeries 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisTimeSeries 简介 RedisTimeSeries 是 Redis 官方提供的一个 时序数据模块（Time Series Module），用于高效地存储、查询和分析时间序列数据。它可以作为 Redis 的一个模块加载使用（在 Redis Stack 中内置支持），将时序数据建模、存储和聚合能力扩展到 Redis 之外。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisTimeSeries 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 安装 RedisTimeSeries 虽然Redis Cloud的Download Center中提供了所有Redis模块编译后的.so文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redistimeseries.so上传到国内服务器即可。 安装依赖 12345678910sudo dnf install -y \\ gcc \\ gcc-c++ \\ make \\ cmake \\ autoconf \\ automake \\ libtool \\ pkgconfig \\ openssl-devel 编译 RedisTimeSeries 1234567891011121314151617181920212223242526272829303132333435363738mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisTimeSeries/RedisTimeSeries.gitcd RedisTimeSeries# 推荐切换到稳定的release版本git checkout v1.12.9# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: af92230dnf install -q -y ca-certificatesdnf install -q -y wget unzipdnf install -q -y git jq/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/enable-utf8dnf install -q -y autoconf libtool m4 automakednf install -q -y openssldnf install -q -y which/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepeldnf install -q -y openssl-devel/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getgcc --moderndnf install -q -y valgrind/usr/bin/python3 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getcmake --usrdnf install -q -y lcov/usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getaws/usr/bin/python3 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 -m pip install --disable-pip-version-check --user -r /usr/local/soft/modules/RedisTimeSeries/tests/flow/requirements.txtNO_PY2=1 /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getpudbamazon_linux_2023# 编译 RedisTimeSeriesmake# 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/redistimeseries.so` ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，类似于CentOS 9，第一次运行会报错，大致报错信息如下： 123456789101112131415161718192021222324./sbin/setup## 错误信息……Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 172.67.157.246)In /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepel:346 # xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm347 fi348349 &gt;&gt;&gt; install_raven350 install_remi351 # install_centos_stream_repos352command failed: /usr/local/soft/modules/RedisTimeSeries/deps/readies/bin/getepelIn /usr/local/soft/modules/RedisTimeSeries/sbin/setup:18 python3 -m pip list19 fi2021 &gt;&gt;&gt; $ROOT/sbin/system-setup.py $SETUP_ARGS22 if [[ $VERBOSE == 1 ]]; then23 python3 -m pip list24 fi 错误分析与解决方法： 这个错误与安装 RedisBloom 时一样，禁用掉 install_raven 即可，具体参见 Redis 扩展模块 -- RedisBloom 的安装方法 进行修改。 Redis 启用模块 将生成的 redistimeseries.so 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建 12# 注意 .so 文件需要包含可执行权限cp bin/linux-x64-release/redistimeseries.so /usr/local/soft/redis-7.4.7/modules/redistimeseries.so 本文采用 loadmodule 加载模块 12345678910111213141516171819202122232425262728293031323334353637383940414243# 将 redistimeseries.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redistimeseries.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 11209 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 20816 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 21025 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisTimeSeries 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2026-01-07T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2026/01/06/redis7-datatype-17-AutoSuggest/","url":"https://blog.hanqunfeng.com/2026/01/06/redis7-datatype-17-AutoSuggest/","title":"Redis 命令及数据类型 -- AutoSuggest","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RediSearch 中 AutoSuggest 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RediSearch 的安装参见 <a href=\"/2025/12/26/redis7-module-RediSearch/\" title=\"Redis 扩展模块 -- RediSearch 的安装方法\">Redis 扩展模块 -- RediSearch 的安装方法</a></li>\n<li class=\"lvl-2\">示例代码：<a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/redis-demo/redisson-demo\">GitHub</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"AutoSuggest-搜索建议（自动补全）\">AutoSuggest 搜索建议（自动补全）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Suggest 本质解决的问题：“当用户只输入部分前缀时，如何高性能地给出候选词，而不是全文搜索结果。”</p>\n</li>\n<li class=\"lvl-2\">\n<p>Suggest 能解决什么业务问题?</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>业务痛点</th>\n<th>传统方案问题</th>\n<th>Suggest 的价值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索框自动补全</td>\n<td>LIKE / 模糊查询性能差</td>\n<td>O(logN) 级前缀匹配</td>\n</tr>\n<tr>\n<td>热门词推荐</td>\n<td>需要额外统计系统</td>\n<td>内置 score 排序</td>\n</tr>\n<tr>\n<td>拼写不准确</td>\n<td>普通前缀无法命中</td>\n<td>FUZZY 模糊匹配</td>\n</tr>\n<tr>\n<td>联想提示</td>\n<td>搜索索引过重</td>\n<td>Suggest 独立结构，轻量</td>\n</tr>\n<tr>\n<td>高并发提示</td>\n<td>数据库压力大</td>\n<td>Redis 内存级吞吐</td>\n</tr>\n<tr>\n<td>实时更新</td>\n<td>离线词库复杂</td>\n<td>动态增删</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Suggest 命令与使用场景对照表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>典型使用场景</th>\n<th>是否高频</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>FT.SUGADD</strong></td>\n<td>添加 / 更新补全词</td>\n<td>构建词库、动态热词更新</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>FT.SUGGET</strong></td>\n<td>查询补全建议</td>\n<td>用户输入联想提示</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>FT.SUGDEL</strong></td>\n<td>删除补全词</td>\n<td>词下架、清理脏数据</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><strong>FT.SUGLEN</strong></td>\n<td>统计补全词数量</td>\n<td>监控、容量评估</td>\n<td>⭐</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景 → 命令映射总结表（推荐收藏）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>业务目标</th>\n<th>推荐命令组合</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>自动补全</td>\n<td>SUGADD + SUGGET</td>\n<td>基础能力</td>\n</tr>\n<tr>\n<td>热词排行</td>\n<td>SUGADD(INCR) + SUGGET(WITHSCORES)</td>\n<td>权重驱动</td>\n</tr>\n<tr>\n<td>拼写纠错</td>\n<td>SUGGET(FUZZY)</td>\n<td>容错</td>\n</tr>\n<tr>\n<td>分类推荐</td>\n<td>SUGADD(PAYLOAD) + SUGGET(WITHPAYLOADS)</td>\n<td>携带业务信息</td>\n</tr>\n<tr>\n<td>词库治理</td>\n<td>SUGDEL + SUGLEN</td>\n<td>运维</td>\n</tr>\n<tr>\n<td>容量监控</td>\n<td>SUGLEN</td>\n<td>规模评估</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>👉 原则：输入框提示用 Suggest，搜索结果用 FT.SEARCH。</p>\n</li>\n</ul>\n<h3 id=\"1️⃣-FT-SUGADD-——-添加-更新补全词\">1️⃣ FT.SUGADD —— 添加 / 更新补全词</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>向补全词库中添加一个候选词</p>\n</li>\n<li class=\"lvl-2\">\n<p>可设置 权重、payload</p>\n</li>\n<li class=\"lvl-2\">\n<p>可用于 热词排序</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGADD key string score</span><br><span class=\"line\">  [INCR]</span><br><span class=\"line\">  [PAYLOAD payload]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>key</code></td>\n<td>Suggestion 词库 Key，索引名称</td>\n</tr>\n<tr>\n<td><code>string</code></td>\n<td>补全文本</td>\n</tr>\n<tr>\n<td><code>score</code></td>\n<td>权重（越大越靠前）</td>\n</tr>\n<tr>\n<td><code>INCR</code></td>\n<td>递增，累加权重</td>\n</tr>\n<tr>\n<td><code>PAYLOAD</code></td>\n<td>附加元数据</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGADD sug:search <span class=\"string\">&quot;iphone&quot;</span> 100</span><br><span class=\"line\">FT.SUGADD sug:search <span class=\"string\">&quot;iphone 15&quot;</span> 200</span><br><span class=\"line\">FT.SUGADD sug:search <span class=\"string\">&quot;ipad&quot;</span> 50 PAYLOAD <span class=\"string\">&quot;category=tablet&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> sug:search</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">trietype0</span><br></pre></td></tr></table></figure>\n<h3 id=\"2️⃣-FT-SUGGET-——-获取补全建议\">2️⃣ FT.SUGGET —— 获取补全建议</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>根据 前缀 返回最相关的候选词</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持模糊匹配</p>\n</li>\n<li class=\"lvl-2\">\n<p>可返回 payload / score</p>\n</li>\n<li class=\"lvl-2\">\n<p>可用于 搜索框输入联想、拼写纠错</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGGET key prefix</span><br><span class=\"line\">  [FUZZY]</span><br><span class=\"line\">  [WITHSCORES]</span><br><span class=\"line\">  [WITHPAYLOADS]</span><br><span class=\"line\">  [MAX num]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>prefix</code></td>\n<td>用户输入前缀</td>\n</tr>\n<tr>\n<td><code>FUZZY</code></td>\n<td>模糊匹配（允许拼写错误）</td>\n</tr>\n<tr>\n<td><code>WITHSCORES</code></td>\n<td>返回权重</td>\n</tr>\n<tr>\n<td><code>WITHPAYLOADS</code></td>\n<td>返回 payload</td>\n</tr>\n<tr>\n<td><code>MAX</code></td>\n<td>最大返回数量</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGGET sug:search <span class=\"string\">&quot;ip&quot;</span> MAX 5</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;iphone 15&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;iphone&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;ipad&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">FT.SUGGET sug:search <span class=\"string\">&quot;iphne&quot;</span> FUZZY</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;iphone 15&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;iphone&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">FT.SUGGET sug:search <span class=\"string\">&quot;ip&quot;</span> WITHSCORES WITHPAYLOADS</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;iphone 15&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;70.71067810058594&quot;</span></span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">4) <span class=\"string\">&quot;iphone&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;44.72135925292969&quot;</span></span><br><span class=\"line\">6) (nil)</span><br><span class=\"line\">7) <span class=\"string\">&quot;ipad&quot;</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;28.86751365661621&quot;</span></span><br><span class=\"line\">9) <span class=\"string\">&quot;category=tablet&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3️⃣-FT-SUGDEL-——-删除补全词\">3️⃣ FT.SUGDEL —— 删除补全词</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从补全词库中移除指定词条</p>\n</li>\n<li class=\"lvl-2\">\n<p>可用于 商品下架、敏感词移除、过期关键词清理</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGDEL key string</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGDEL sug:search <span class=\"string\">&quot;iphone&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4️⃣-FT-SUGLEN-——-查看词库规模\">4️⃣ FT.SUGLEN —— 查看词库规模</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取当前词库的词条数量</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGLEN key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SUGLEN sug:search</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例代码\">示例代码</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>AutoSuggest</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisSuggestTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo.redissug;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 补全建议工具类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisSuggestTool</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;T&gt; T <span class=\"title function_\">executeLua</span><span class=\"params\">(String script, List&lt;String&gt; keys, Object... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) stringRedisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Object.class),</span><br><span class=\"line\">                keys,</span><br><span class=\"line\">                Arrays.stream(args)</span><br><span class=\"line\">                        .map(String::valueOf)</span><br><span class=\"line\">                        .toArray(String[]::<span class=\"keyword\">new</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加 / 更新补全词</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * FT.SUGADD key string score</span></span><br><span class=\"line\"><span class=\"comment\">     * [INCR]</span></span><br><span class=\"line\"><span class=\"comment\">     * [PAYLOAD payload]</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key     索引名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value   补全文本</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> score   分数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> incr    是否递增，默认为false</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> payload 补全词的附加信息，默认为空</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">sugAdd</span><span class=\"params\">(String key,</span></span><br><span class=\"line\"><span class=\"params\">                       String value,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">double</span> score,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">boolean</span> incr,</span></span><br><span class=\"line\"><span class=\"params\">                       String payload)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lua</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">                local args = &#123;&#x27;FT.SUGADD&#x27;, KEYS[1], ARGV[1], ARGV[2]&#125;</span></span><br><span class=\"line\"><span class=\"string\">                if ARGV[3] == &#x27;1&#x27; then table.insert(args, &#x27;INCR&#x27;) end</span></span><br><span class=\"line\"><span class=\"string\">                if ARGV[4] ~= &#x27;&#x27; then table.insert(args, &#x27;PAYLOAD&#x27;); table.insert(args, ARGV[4]) end</span></span><br><span class=\"line\"><span class=\"string\">                return redis.call(unpack(args))</span></span><br><span class=\"line\"><span class=\"string\">                &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> executeLua(</span><br><span class=\"line\">                lua,</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value,</span><br><span class=\"line\">                score,</span><br><span class=\"line\">                incr ? <span class=\"string\">&quot;1&quot;</span> : <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">                payload == <span class=\"literal\">null</span> ? <span class=\"string\">&quot;&quot;</span> : payload</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">sugAdd</span><span class=\"params\">(String key,</span></span><br><span class=\"line\"><span class=\"params\">                       String value,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sugAdd(key, value, score, <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询补全建议</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * FT.SUGGET key prefix</span></span><br><span class=\"line\"><span class=\"comment\">     * [FUZZY]</span></span><br><span class=\"line\"><span class=\"comment\">     * [WITHSCORES]</span></span><br><span class=\"line\"><span class=\"comment\">     * [WITHPAYLOADS]</span></span><br><span class=\"line\"><span class=\"comment\">     * [MAX num]</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key          索引名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prefix       前缀</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fuzzy        是否模糊匹配，默认为false</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> withScores   是否返回分数，默认为false</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> withPayloads 是否返回附加信息，默认为false</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> max           最大返回数量，默认为5</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Suggestion&gt; <span class=\"title function_\">sugGet</span><span class=\"params\">(String key,</span></span><br><span class=\"line\"><span class=\"params\">                                   String prefix,</span></span><br><span class=\"line\"><span class=\"params\">                                   <span class=\"type\">boolean</span> fuzzy,</span></span><br><span class=\"line\"><span class=\"params\">                                   <span class=\"type\">boolean</span> withScores,</span></span><br><span class=\"line\"><span class=\"params\">                                   <span class=\"type\">boolean</span> withPayloads,</span></span><br><span class=\"line\"><span class=\"params\">                                   <span class=\"type\">int</span> max)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lua</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">                local args = &#123;&#x27;FT.SUGGET&#x27;, KEYS[1], ARGV[1]&#125;</span></span><br><span class=\"line\"><span class=\"string\">                if ARGV[2] == &#x27;1&#x27; then table.insert(args, &#x27;FUZZY&#x27;) end</span></span><br><span class=\"line\"><span class=\"string\">                if ARGV[3] == &#x27;1&#x27; then table.insert(args, &#x27;WITHSCORES&#x27;) end</span></span><br><span class=\"line\"><span class=\"string\">                if ARGV[4] == &#x27;1&#x27; then table.insert(args, &#x27;WITHPAYLOADS&#x27;) end</span></span><br><span class=\"line\"><span class=\"string\">                if tonumber(ARGV[5]) &gt; 0 then table.insert(args, &#x27;MAX&#x27;); table.insert(args, ARGV[5]) end</span></span><br><span class=\"line\"><span class=\"string\">                return redis.call(unpack(args))</span></span><br><span class=\"line\"><span class=\"string\">                &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Object&gt; raw = executeLua(</span><br><span class=\"line\">                lua,</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                prefix,</span><br><span class=\"line\">                fuzzy ? <span class=\"string\">&quot;1&quot;</span> : <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">                withScores ? <span class=\"string\">&quot;1&quot;</span> : <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">                withPayloads ? <span class=\"string\">&quot;1&quot;</span> : <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">                max</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> parseSuggestionResult(raw, withScores, withPayloads);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 结果解析器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Suggestion&gt; <span class=\"title function_\">parseSuggestionResult</span><span class=\"params\">(List&lt;Object&gt; raw,</span></span><br><span class=\"line\"><span class=\"params\">                                                   <span class=\"type\">boolean</span> withScores,</span></span><br><span class=\"line\"><span class=\"params\">                                                   <span class=\"type\">boolean</span> withPayloads)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (raw == <span class=\"literal\">null</span> || raw.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Suggestion&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">                + (withScores ? <span class=\"number\">1</span> : <span class=\"number\">0</span>)</span><br><span class=\"line\">                + (withPayloads ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; raw.size(); i += step) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> String.valueOf(raw.get(idx++));</span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">score</span> <span class=\"operator\">=</span> withScores ? Double.valueOf(String.valueOf(raw.get(idx++))) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">payload</span> <span class=\"operator\">=</span> withPayloads ? String.valueOf(raw.get(idx++)) : <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Suggestion</span>(value, score, payload));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除补全词</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * FT.SUGDEL key string</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   索引名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 补全词</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Boolean <span class=\"title function_\">sugDel</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lua</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;FT.SUGDEL&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> executeLua(</span><br><span class=\"line\">                lua,</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Long.valueOf(<span class=\"number\">1</span>).equals(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取补全词数量</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * FT.SUGLEN key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 索引名称</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">sugLen</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lua</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;FT.SUGLEN&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> executeLua(</span><br><span class=\"line\">                lua,</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Suggestion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Double score;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String payload;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RediSearch 中 AutoSuggest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RediSearch 的安装参见 Redis 扩展模块 -- RediSearch 的安装方法 示例代码：GitHub AutoSuggest 搜索建议（自动补全） Suggest 本质解决的问题：“当用户只输入部分前缀时，如何高性能地给出候选词，而不是全文搜索结果。” Suggest 能解决什么业务问题? 业务痛点 传统方案问题 Suggest 的价值 搜索框自动补全 LIKE / 模糊查询性能差 O(logN) 级前缀匹配 热门词推荐 需要额外统计系统 内置 score 排序 拼写不准确 普通前缀无法命中 FUZZY 模糊匹配 联想提示 搜索索引过重 Suggest 独立结构，轻量 高并发提示 数据库压力大 Redis 内存级吞吐 实时更新 离线词库复杂 动态增删 Suggest 命令与使用场景对照表 命令 作用 典型使用场景 是否高频 FT.SUGADD 添加 / 更新补全词 构建词库、动态热词更新 ⭐⭐⭐⭐ FT.SUGGET 查询补全建议 用户输入联想提示 ⭐⭐⭐⭐⭐ FT.SUGDEL 删除补全词 词下架、清理脏数据 ⭐⭐ FT.SUGLEN 统计补全词数量 监控、容量评估 ⭐ 场景 → 命令映射总结表（推荐收藏） 业务目标 推荐命令组合 说明 自动补全 SUGADD + SUGGET 基础能力 热词排行 SUGADD(INCR) + SUGGET(WITHSCORES) 权重驱动 拼写纠错 SUGGET(FUZZY) 容错 分类推荐 SUGADD(PAYLOAD) + SUGGET(WITHPAYLOADS) 携带业务信息 词库治理 SUGDEL + SUGLEN 运维 容量监控 SUGLEN 规模评估 👉 原则：输入框提示用 Suggest，搜索结果用 FT.SEARCH。 1️⃣ FT.SUGADD —— 添加 / 更新补全词 向补全词库中添加一个候选词 可设置 权重、payload 可用于 热词排序 语法 123FT.SUGADD key string score [INCR] [PAYLOAD payload] 参数说明 参数 含义 key Suggestion 词库 Key，索引名称 string 补全文本 score 权重（越大越靠前） INCR 递增，累加权重 PAYLOAD 附加元数据 示例 12345678FT.SUGADD sug:search &quot;iphone&quot; 100FT.SUGADD sug:search &quot;iphone 15&quot; 200FT.SUGADD sug:search &quot;ipad&quot; 50 PAYLOAD &quot;category=tablet&quot;# 查看类型127.0.0.1:6379&gt; type sug:search## 输出trietype0 2️⃣ FT.SUGGET —— 获取补全建议 根据 前缀 返回最相关的候选词 支持模糊匹配 可返回 payload / score 可用于 搜索框输入联想、拼写纠错 语法 12345FT.SUGGET key prefix [FUZZY] [WITHSCORES] [WITHPAYLOADS] [MAX num] 参数说明 参数 含义 prefix 用户输入前缀 FUZZY 模糊匹配（允许拼写错误） WITHSCORES 返回权重 WITHPAYLOADS 返回 payload MAX 最大返回数量 示例 12345678910111213141516171819202122FT.SUGGET sug:search &quot;ip&quot; MAX 5## 输出1) &quot;iphone 15&quot;2) &quot;iphone&quot;3) &quot;ipad&quot;FT.SUGGET sug:search &quot;iphne&quot; FUZZY## 输出1) &quot;iphone 15&quot;2) &quot;iphone&quot;FT.SUGGET sug:search &quot;ip&quot; WITHSCORES WITHPAYLOADS## 输出1) &quot;iphone 15&quot;2) &quot;70.71067810058594&quot;3) (nil)4) &quot;iphone&quot;5) &quot;44.72135925292969&quot;6) (nil)7) &quot;ipad&quot;8) &quot;28.86751365661621&quot;9) &quot;category=tablet&quot; 3️⃣ FT.SUGDEL —— 删除补全词 从补全词库中移除指定词条 可用于 商品下架、敏感词移除、过期关键词清理 语法 1FT.SUGDEL key string 示例 1FT.SUGDEL sug:search &quot;iphone&quot; 4️⃣ FT.SUGLEN —— 查看词库规模 获取当前词库的词条数量 语法 1FT.SUGLEN key 示例 123FT.SUGLEN sug:search## 输出(integer) 3 示例代码 SpringBoot 的 RedisTemplate 中没有提供对AutoSuggest的封装，需要自己封装，我这里封装了一个简易的RedisSuggestTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.example.demo.redissug;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * 补全建议工具类 */@Componentpublic class RedisSuggestTool &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @SuppressWarnings(&quot;unchecked&quot;) private &lt;T&gt; T executeLua(String script, List&lt;String&gt; keys, Object... args) &#123; return (T) stringRedisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Object.class), keys, Arrays.stream(args) .map(String::valueOf) .toArray(String[]::new) ); &#125; /** * 添加 / 更新补全词 * &lt;p&gt; * FT.SUGADD key string score * [INCR] * [PAYLOAD payload] * * @param key 索引名称 * @param value 补全文本 * @param score 分数 * @param incr 是否递增，默认为false * @param payload 补全词的附加信息，默认为空 */ public Long sugAdd(String key, String value, double score, boolean incr, String payload) &#123; String lua = &quot;&quot;&quot; local args = &#123;&#x27;FT.SUGADD&#x27;, KEYS[1], ARGV[1], ARGV[2]&#125; if ARGV[3] == &#x27;1&#x27; then table.insert(args, &#x27;INCR&#x27;) end if ARGV[4] ~= &#x27;&#x27; then table.insert(args, &#x27;PAYLOAD&#x27;); table.insert(args, ARGV[4]) end return redis.call(unpack(args)) &quot;&quot;&quot;; return executeLua( lua, Collections.singletonList(key), value, score, incr ? &quot;1&quot; : &quot;0&quot;, payload == null ? &quot;&quot; : payload ); &#125; public Long sugAdd(String key, String value, double score) &#123; return sugAdd(key, value, score, false, &quot;&quot;); &#125; /** * 查询补全建议 * &lt;p&gt; * FT.SUGGET key prefix * [FUZZY] * [WITHSCORES] * [WITHPAYLOADS] * [MAX num] * * @param key 索引名称 * @param prefix 前缀 * @param fuzzy 是否模糊匹配，默认为false * @param withScores 是否返回分数，默认为false * @param withPayloads 是否返回附加信息，默认为false * @param max 最大返回数量，默认为5 */ public List&lt;Suggestion&gt; sugGet(String key, String prefix, boolean fuzzy, boolean withScores, boolean withPayloads, int max) &#123; String lua = &quot;&quot;&quot; local args = &#123;&#x27;FT.SUGGET&#x27;, KEYS[1], ARGV[1]&#125; if ARGV[2] == &#x27;1&#x27; then table.insert(args, &#x27;FUZZY&#x27;) end if ARGV[3] == &#x27;1&#x27; then table.insert(args, &#x27;WITHSCORES&#x27;) end if ARGV[4] == &#x27;1&#x27; then table.insert(args, &#x27;WITHPAYLOADS&#x27;) end if tonumber(ARGV[5]) &gt; 0 then table.insert(args, &#x27;MAX&#x27;); table.insert(args, ARGV[5]) end return redis.call(unpack(args)) &quot;&quot;&quot;; List&lt;Object&gt; raw = executeLua( lua, Collections.singletonList(key), prefix, fuzzy ? &quot;1&quot; : &quot;0&quot;, withScores ? &quot;1&quot; : &quot;0&quot;, withPayloads ? &quot;1&quot; : &quot;0&quot;, max ); return parseSuggestionResult(raw, withScores, withPayloads); &#125; // 结果解析器 private List&lt;Suggestion&gt; parseSuggestionResult(List&lt;Object&gt; raw, boolean withScores, boolean withPayloads) &#123; if (raw == null || raw.isEmpty()) &#123; return Collections.emptyList(); &#125; List&lt;Suggestion&gt; list = new ArrayList&lt;&gt;(); int step = 1 + (withScores ? 1 : 0) + (withPayloads ? 1 : 0); for (int i = 0; i &lt; raw.size(); i += step) &#123; int idx = i; String value = String.valueOf(raw.get(idx++)); Double score = withScores ? Double.valueOf(String.valueOf(raw.get(idx++))) : null; String payload = withPayloads ? String.valueOf(raw.get(idx++)) : null; list.add(new Suggestion(value, score, payload)); &#125; return list; &#125; /** * 删除补全词 * &lt;p&gt; * FT.SUGDEL key string * * @param key 索引名称 * @param value 补全词 */ public Boolean sugDel(String key, String value) &#123; String lua = &quot;return redis.call(&#x27;FT.SUGDEL&#x27;, KEYS[1], ARGV[1])&quot;; Object result = executeLua( lua, Collections.singletonList(key), value ); return Long.valueOf(1).equals(result); &#125; /** * 获取补全词数量 * &lt;p&gt; * FT.SUGLEN key * * @param key 索引名称 */ public Long sugLen(String key) &#123; String lua = &quot;return redis.call(&#x27;FT.SUGLEN&#x27;, KEYS[1])&quot;; return executeLua( lua, Collections.singletonList(key) ); &#125;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class Suggestion &#123; private String value; private Double score; private String payload;&#125;","summary":"摘要 本文介绍 Redis 扩展模块 – RediSearch 中 AutoSuggest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RediSearch 的安装参见 Redis 扩展模块 -- RediSearch 的安装方法 示例代码：GitHub","date_published":"2026-01-06T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2026/01/05/redis7-module-RediSearch-study/","url":"https://blog.hanqunfeng.com/2026/01/05/redis7-module-RediSearch-study/","title":"RediSearch 开发实战","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RediSearch 的使用方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RediSearch 的安装参见 <a href=\"/2025/12/26/redis7-module-RediSearch/\" title=\"Redis 扩展模块 -- RediSearch 的安装方法\">Redis 扩展模块 -- RediSearch 的安装方法</a></li>\n<li class=\"lvl-2\">示例代码：<a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/redis-demo/redisson-demo\">GitHub</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RediSearch-命令\">RediSearch 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了展示命令的使用方法，这里以JSON文档进行索引，初始化数据如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.SET user:10001 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Alice Bob&quot;,&quot;age&quot;:28,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:59.9,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a phone&quot;,&quot;items&quot;:[&quot;SpringCloud技术指南&quot;,&quot;Shell脚本基础&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10002 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Bob Frank&quot;,&quot;age&quot;:35,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:899.0,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a iphone&quot;,&quot;items&quot;:[&quot;Linux必知必会&quot;,&quot;Java多线程详解&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10003 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Carol&quot;,&quot;age&quot;:22,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:19.9,&quot;status&quot;:&quot;CANCELLED&quot;&#125;],&quot;comment&quot;: &quot;I have a mobile&quot;,&quot;items&quot;:[&quot;MySQL从删库到跑路&quot;,&quot;Oracle开发实践&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10004 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;David Bob&quot;,&quot;age&quot;:41,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:1200,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:300,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a car&quot;,&quot;items&quot;:[&quot;Spring技术指南&quot;,&quot;RocketMQ由浅入深&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10005 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Eve&quot;,&quot;age&quot;:30,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:88.8,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a pencil&quot;,&quot;items&quot;:[&quot;Kafka从零开始&quot;,&quot;Java由浅入深&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10006 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Frank&quot;,&quot;age&quot;:27,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:499,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:129,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a phone&quot;,&quot;items&quot;:[&quot;Redis开发实战&quot;,&quot;MongoDB从入门到实战&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10007 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Grace&quot;,&quot;age&quot;:33,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:999.9,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a book&quot;,&quot;items&quot;:[&quot;Android开发手册&quot;,&quot;Gradle从零开始&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10008 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Henry&quot;,&quot;age&quot;:45,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:59.9,&quot;status&quot;:&quot;CANCELLED&quot;&#125;],&quot;comment&quot;: &quot;I have a macbook&quot;,&quot;items&quot;:[&quot;SpringBoot技术指南&quot;,&quot;Maven由浅入深&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10009 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Ivy&quot;,&quot;age&quot;:26,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:299,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:199,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a watch&quot;,&quot;items&quot;:[&quot;Spring融会贵通&quot;,&quot;Java技术开发指南&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">JSON.SET user:10010 $ <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:38,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:150,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a apple&quot;,&quot;items&quot;:[&quot;Spring技术指南&quot;,&quot;Java由浅入深&quot;]&#125;&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot暂时没有支持 RediSearch ，你可以编写Lua脚本来实现相应的功能，另外 <a href=\"https://redisson.pro/docs/data-and-services/services/#redisearch-service\">Redisson</a>已经提供了对 RediSearch 的支持，下面结合命令给出代码示例。</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.52.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">RSearch</span> <span class=\"variable\">rSearch</span> <span class=\"operator\">=</span> redissonClient.getSearch(StringCodec.INSTANCE);</span><br></pre></td></tr></table></figure>\n<h3 id=\"一、索引生命周期管理类\">一、索引生命周期管理类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>核心参数</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.CREATE</code></td>\n<td>创建索引</td>\n<td>索引名、ON、PREFIX、SCHEMA</td>\n<td>见下</td>\n</tr>\n<tr>\n<td><code>FT.ALTER</code></td>\n<td>给已有索引新增字段</td>\n<td>索引名、SCHEMA ADD</td>\n<td>见下</td>\n</tr>\n<tr>\n<td><code>FT.DROPINDEX</code></td>\n<td>删除索引</td>\n<td>索引名、DD</td>\n<td>见下</td>\n</tr>\n<tr>\n<td><code>FT.INFO</code></td>\n<td>查看索引信息</td>\n<td>索引名</td>\n<td>见下</td>\n</tr>\n<tr>\n<td><code>FT._LIST</code></td>\n<td>列出所有索引</td>\n<td>无</td>\n<td>见下</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-FT-CREATE\">1️⃣ FT.CREATE</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.CREATE 基本语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.CREATE index_name</span><br><span class=\"line\">[ON HASH | JSON]</span><br><span class=\"line\">[PREFIX count prefix ...]</span><br><span class=\"line\">[FILTER filter]</span><br><span class=\"line\">[LANGUAGE default_lang]</span><br><span class=\"line\">[LANGUAGE_FIELD lang_attribute]</span><br><span class=\"line\">[SCORE default_score]</span><br><span class=\"line\">[SCORE_FIELD score_attribute]</span><br><span class=\"line\">[PAYLOAD_FIELD payload_attribute]</span><br><span class=\"line\">[MAXTEXTFIELDS]</span><br><span class=\"line\">[TEMPORARY seconds]</span><br><span class=\"line\">[NOOFFSETS] [NOHL] [NOFIELDS] [NOFREQS]</span><br><span class=\"line\">[STOPWORDS count stopword ...]</span><br><span class=\"line\">[SKIPINITIALSCAN]</span><br><span class=\"line\">SCHEMA</span><br><span class=\"line\">  field_name [AS <span class=\"built_in\">alias</span>] TEXT | TAG | NUMERIC | GEO | VECTOR</span><br><span class=\"line\">  [SORTABLE [UNF]]</span><br><span class=\"line\">  [NOINDEX]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.CREATE 参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>index_name</code></td>\n<td>索引名称</td>\n</tr>\n<tr>\n<td><code>ON HASH | JSON</code></td>\n<td>指定索引数据来源类型，默认 <code>HASH</code></td>\n</tr>\n<tr>\n<td><code>PREFIX count prefix...</code></td>\n<td>指定索引 Key 前缀</td>\n</tr>\n<tr>\n<td><code>FILTER filter</code></td>\n<td>对索引数据设置过滤表达式</td>\n</tr>\n<tr>\n<td><code>LANGUAGE</code></td>\n<td>指定默认分词语言（默认 english，中文是 chinese）</td>\n</tr>\n<tr>\n<td><code>LANGUAGE_FIELD</code></td>\n<td>指定文档中的语言字段</td>\n</tr>\n<tr>\n<td><code>SCORE</code></td>\n<td>设置文档默认评分</td>\n</tr>\n<tr>\n<td><code>SCORE_FIELD</code></td>\n<td>从字段中读取评分</td>\n</tr>\n<tr>\n<td><code>PAYLOAD_FIELD</code></td>\n<td>指定存储的二进制负载字段</td>\n</tr>\n<tr>\n<td><code>MAXTEXTFIELDS</code></td>\n<td>允许更多 TEXT 字段（消耗更多内存）</td>\n</tr>\n<tr>\n<td><code>TEMPORARY seconds</code></td>\n<td>创建临时索引，超时后自动删除</td>\n</tr>\n<tr>\n<td><code>NOOFFSETS</code></td>\n<td>不存储文本偏移量（节省内存）</td>\n</tr>\n<tr>\n<td><code>NOHL</code></td>\n<td>禁用高亮</td>\n</tr>\n<tr>\n<td><code>NOFIELDS</code></td>\n<td>不保存字段内容</td>\n</tr>\n<tr>\n<td><code>NOFREQS</code></td>\n<td>不保存词频信息</td>\n</tr>\n<tr>\n<td><code>STOPWORDS count ...</code></td>\n<td>指定停用词</td>\n</tr>\n<tr>\n<td><code>SKIPINITIALSCAN</code></td>\n<td>创建索引时不扫描已有数据</td>\n</tr>\n<tr>\n<td><code>SCHEMA</code></td>\n<td>索引字段定义起始</td>\n</tr>\n<tr>\n<td><code>AS alias</code></td>\n<td>字段别名</td>\n</tr>\n<tr>\n<td><code>TEXT</code></td>\n<td>全文索引字段</td>\n</tr>\n<tr>\n<td><code>TAG</code></td>\n<td>精确匹配字段</td>\n</tr>\n<tr>\n<td><code>NUMERIC</code></td>\n<td>数值字段</td>\n</tr>\n<tr>\n<td><code>GEO</code></td>\n<td>地理位置字段</td>\n</tr>\n<tr>\n<td><code>VECTOR</code></td>\n<td>向量字段</td>\n</tr>\n<tr>\n<td><code>SORTABLE</code></td>\n<td>允许排序</td>\n</tr>\n<tr>\n<td><code>UNF</code></td>\n<td>不规范化排序</td>\n</tr>\n<tr>\n<td><code>NOINDEX</code></td>\n<td>字段不参与索引</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.CREATE 的核心语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.CREATE &lt;index&gt;</span><br><span class=\"line\">[ON HASH | JSON]</span><br><span class=\"line\">[PREFIX count prefix ...]</span><br><span class=\"line\">[LANGUAGE default_lang]</span><br><span class=\"line\">SCHEMA</span><br><span class=\"line\">  field_name [AS <span class=\"built_in\">alias</span>] TEXT | TAG | NUMERIC | GEO | VECTOR</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建索引示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.CREATE idx:user</span><br><span class=\"line\">  ON JSON</span><br><span class=\"line\">  PREFIX 1 user:</span><br><span class=\"line\">  LANGUAGE chinese</span><br><span class=\"line\">  SCHEMA</span><br><span class=\"line\">    $.name AS name TEXT</span><br><span class=\"line\">    $.age AS age NUMERIC SORTABLE</span><br><span class=\"line\">    $.orders[*].amount AS amount NUMERIC</span><br><span class=\"line\">    $.orders[*].status AS status TAG</span><br><span class=\"line\">    $.comment AS comment TEXT</span><br><span class=\"line\">    $.items[*] AS items TEXT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\">  <span class=\"comment\"># idx:user：索引名</span></span><br><span class=\"line\">  <span class=\"comment\"># ON JSON：索引 JSON 文档，RediSearch 仅支持对 HASH 和 JSON 进行索引</span></span><br><span class=\"line\">  <span class=\"comment\"># PREFIX 1 user: ：索引指定 key 前缀，1 表示索引一个，user: 表示索引的 key 前缀，如果索引两个：PREFIX 2 user: order:</span></span><br><span class=\"line\">  <span class=\"comment\"># LANGUAGE chinese：指定默认分词语言，默认是英文 english，中文是 chinese，如果索引中有中文，则必须指定 LANGUAGE 为 chinese</span></span><br><span class=\"line\">  <span class=\"comment\"># SCHEMA：索引字段</span></span><br><span class=\"line\">  <span class=\"comment\"># $.name AS name TEXT：索引字段 $.name(注意：JSON类型以 $. 开头，Hash类型就不需要了)，字段别名为 name，字段类型为 TEXT</span></span><br><span class=\"line\">  <span class=\"comment\"># AS：字段别名（查询时使用）</span></span><br><span class=\"line\">  <span class=\"comment\"># TEXT / NUMERIC / TAG：字段类型，这几个是最常用的</span></span><br><span class=\"line\">  <span class=\"comment\"># SORTABLE：NUMERIC、TAG、TEXT 或 GEO 类型的字段可以带有一个可选的 SORTABLE 参数，表示为字段建立专门的排序数据结构（类似列式存储），从而避免在查询阶段对大量结果进行临时排序。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.createIndex(</span><br><span class=\"line\">    <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">    IndexOptions.defaults()</span><br><span class=\"line\">            .on(IndexType.JSON)</span><br><span class=\"line\">            .prefix(List.of(<span class=\"string\">&quot;user:&quot;</span>))</span><br><span class=\"line\">            .language(<span class=\"string\">&quot;chinese&quot;</span>),</span><br><span class=\"line\">    FieldIndex.text(<span class=\"string\">&quot;$.name&quot;</span>).as(<span class=\"string\">&quot;name&quot;</span>),</span><br><span class=\"line\">    FieldIndex.numeric(<span class=\"string\">&quot;$.age&quot;</span>).as(<span class=\"string\">&quot;age&quot;</span>),</span><br><span class=\"line\">    FieldIndex.numeric(<span class=\"string\">&quot;$.orders[*].amount&quot;</span>).as(<span class=\"string\">&quot;amount&quot;</span>),</span><br><span class=\"line\">    FieldIndex.tag(<span class=\"string\">&quot;$.orders[*].status&quot;</span>).as(<span class=\"string\">&quot;status&quot;</span>),</span><br><span class=\"line\">    FieldIndex.text(<span class=\"string\">&quot;$.comment&quot;</span>).as(<span class=\"string\">&quot;comment&quot;</span>),</span><br><span class=\"line\">    FieldIndex.text(<span class=\"string\">&quot;$.items[*]&quot;</span>).as(<span class=\"string\">&quot;items&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>索引字段的类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段类型</th>\n<th>中文名称</th>\n<th>功能说明</th>\n<th>典型使用场景</th>\n<th>备注 / 限制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TEXT</strong></td>\n<td>全文文本字段</td>\n<td>支持对字段值进行全文检索（分词、相关度计算、模糊匹配等）</td>\n<td>文章内容、用户名、描述信息</td>\n<td>支持权重（WEIGHT）、排序（SORTABLE）等选项</td>\n</tr>\n<tr>\n<td><strong>TAG</strong></td>\n<td>标签字段 / 精确匹配字段</td>\n<td>支持精确匹配查询，适用于枚举值或离散分类</td>\n<td>分类、状态、主键、类型字段</td>\n<td>不分词；可自定义分隔符</td>\n</tr>\n<tr>\n<td><strong>NUMERIC</strong></td>\n<td>数值字段</td>\n<td>支持数值范围查询</td>\n<td>年龄、价格、分数、时间戳</td>\n<td>支持区间查询（<code>[min max]</code>）</td>\n</tr>\n<tr>\n<td><strong>GEO</strong></td>\n<td>地理位置字段（点）</td>\n<td>支持以“点”为中心的半径范围查询</td>\n<td>门店位置、用户位置</td>\n<td>值格式必须为 <code>&quot;经度,纬度&quot;</code></td>\n</tr>\n<tr>\n<td><strong>VECTOR</strong></td>\n<td>向量字段</td>\n<td>支持向量相似度搜索（KNN 等）</td>\n<td>语义搜索、推荐系统、Embedding 向量</td>\n<td>需要 <strong>Query Dialect ≥ 2</strong>（RediSearch ≥ 2.4）</td>\n</tr>\n<tr>\n<td><strong>GEOSHAPE</strong></td>\n<td>地理形状字段（多边形）</td>\n<td>支持多边形空间查询</td>\n<td>行政区、商圈、地图区域</td>\n<td>使用 WKT 格式；不支持 JSON 多值和 SORTABLE</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>GEOSHAPE 字段补充说明</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据格式</td>\n<td>WKT（Well-Known Text）格式，如：<code>POLYGON((x1 y1, x2 y2, ...))</code></td>\n</tr>\n<tr>\n<td>坐标系统</td>\n<td><code>SPHERICAL</code>（球面坐标，经纬度）<br><code>FLAT</code>（平面坐标，笛卡尔 X/Y）</td>\n</tr>\n<tr>\n<td>默认坐标系统</td>\n<td><code>SPHERICAL</code></td>\n</tr>\n<tr>\n<td>当前限制</td>\n<td>❌ 不支持 JSON 多值<br>❌ 不支持 <code>SORTABLE</code> 选项</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>索引字段类型选型建议</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>使用场景</th>\n<th>推荐字段类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>全文检索</td>\n<td><strong>TEXT</strong></td>\n<td>支持分词、相关度计算、模糊匹配等全文搜索能力</td>\n</tr>\n<tr>\n<td>精确过滤 / 分类</td>\n<td><strong>TAG</strong></td>\n<td>精确匹配，不分词，适合枚举值、状态、类型等字段</td>\n</tr>\n<tr>\n<td>区间筛选 / 排序</td>\n<td><strong>NUMERIC</strong></td>\n<td>支持数值区间查询与排序，适合价格、时间、分数等</td>\n</tr>\n<tr>\n<td>附近的人 / 门店</td>\n<td><strong>GEO</strong></td>\n<td>基于经纬度点进行半径范围查询</td>\n</tr>\n<tr>\n<td>语义搜索 / 向量召回</td>\n<td><strong>VECTOR</strong></td>\n<td>基于向量相似度（KNN）的语义搜索，需要 Dialect ≥ 2</td>\n</tr>\n<tr>\n<td>复杂地理区域判断</td>\n<td><strong>GEOSHAPE</strong></td>\n<td>支持多边形（Polygon）区域查询，适合行政区、商圈等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>哪些字段适合使用 SORTABLE</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>字段类型</th>\n<th>是否适合 SORTABLE</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NUMERIC</td>\n<td>✅ 强烈推荐</td>\n<td>数值排序最常见，如价格、时间、评分</td>\n</tr>\n<tr>\n<td>TAG</td>\n<td>⚠️ 视情况</td>\n<td>一般用于过滤，排序意义不大</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>⚠️ 谨慎</td>\n<td>文本可能很大，内存开销高</td>\n</tr>\n<tr>\n<td>GEO</td>\n<td>⚠️ 特殊场景</td>\n<td>通常按距离排序，更多依赖 <code>GEOFILTER</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>小贴士：如何在redis终端输入多行的命令？</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">先说结论：redis终端 不支持多行输入，但可以通过如下方式输入多行命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">HSET user:1 \\</span></span><br><span class=\"line\"><span class=\"string\">name Tom \\</span></span><br><span class=\"line\"><span class=\"string\">age 18 \\</span></span><br><span class=\"line\"><span class=\"string\">city Beijing</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">这种方法是利用了 Bash 的能力，即 <code>&lt;&lt;EOF</code> 后面的内容会作为标准输入，直到 <code>EOF</code> 为止，并通过 <code>\\</code> 符换行。</li>\n<li class=\"lvl-2\">如果在VSCode中，可以选中要合并的多行内容，然后通过 <code>Ctrl + Shift + J</code> 快捷键将多行合并到一行。</li>\n</ul>\n</div>\n<h4 id=\"2️⃣-FT-ALTER\">2️⃣ FT.ALTER</h4>\n<blockquote>\n<p>⚠️ 只能 新增字段，不能修改或删除已有字段</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.ALTER idx:user SCHEMA ADD $.vip AS vip TAG</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.alter(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"literal\">false</span>,</span><br><span class=\"line\">        FieldIndex.tag(<span class=\"string\">&quot;$.vip&quot;</span>).as(<span class=\"string\">&quot;vip&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3️⃣-FT-DROPINDEX\">3️⃣ FT.DROPINDEX</h4>\n<blockquote>\n<p>⚠️ 删除索引</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.DROPINDEX idx:user</span><br><span class=\"line\"><span class=\"comment\"># ⚠️ DD：删除索引的同时删除被索引数据，谨慎使用</span></span><br><span class=\"line\">FT.DROPINDEX idx:user DD</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.dropIndex(<span class=\"string\">&quot;idx:user&quot;</span>);</span><br><span class=\"line\">rSearch.dropIndexAndDocuments(<span class=\"string\">&quot;idx:user&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4️⃣-FT-INFO\">4️⃣ <a href=\"http://FT.INFO\">FT.INFO</a></h4>\n<blockquote>\n<p>查看索引信息</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.INFO idx:user</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">IndexInfo</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> rSearch.info(<span class=\"string\">&quot;idx:user&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>重点关注字段</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>num_docs</code></td>\n<td><strong>当前被索引、可被搜索的文档数量</strong></td>\n<td>user:10001 ~ user:10010，10条文档</td>\n</tr>\n<tr>\n<td><code>num_terms</code></td>\n<td><strong>词典中唯一词项 term 的数量</strong><br><strong>主要来源于 TEXT（name） 和 TAG（vip, status） 字段去重之后的数量</strong></td>\n<td>name: alice, bob, carol, …<br>vip: yes, no<br>status: PAID, CREATED, CANCELLED<br></td>\n</tr>\n<tr>\n<td><code>num_records</code></td>\n<td><strong>倒排索引中的记录条目总数</strong><br><strong>所有 term 在所有文档中的出现次数之和</strong></td>\n<td>JSON 数组字段 orders[],每个 order 都会生成独立的索引 entry<br>多值字段 × 多文档 = record 爆炸式增长<br><br>num_records 真正影响：内存、查询速度、聚合成本</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5️⃣-FT-LIST\">5️⃣ FT._LIST</h4>\n<blockquote>\n<p>列出所有索引</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT._LIST</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; indexes = rSearch.getIndexes();</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、查询类（核心）\">二、查询类（核心）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.SEARCH</code></td>\n<td>标准搜索</td>\n<td>90% 场景</td>\n</tr>\n<tr>\n<td><code>FT.AGGREGATE</code></td>\n<td>分组 / 统计 / 聚合</td>\n<td>报表、分析</td>\n</tr>\n<tr>\n<td><code>FT.HYBRID</code></td>\n<td>文本 + 向量混合</td>\n<td>向量搜索</td>\n</tr>\n<tr>\n<td><code>FT.EXPLAIN</code></td>\n<td>查询执行计划</td>\n<td>调优</td>\n</tr>\n<tr>\n<td><code>FT.EXPLAINCLI</code></td>\n<td>CLI 可读执行计划</td>\n<td>调试</td>\n</tr>\n<tr>\n<td><code>FT.PROFILE</code></td>\n<td>性能分析</td>\n<td>慢查询</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1️⃣-FT-SEARCH\">1️⃣ FT.SEARCH</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.SEARCH 基本语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SEARCH index query</span><br><span class=\"line\">[NOCOENTENT] [VERBATIM] [NOSTOPWORDS]</span><br><span class=\"line\">[WITHSCORES] [WITHPAYLOADS] [WITHSORTKEYS]</span><br><span class=\"line\">[FILTER numeric_field min max ...]</span><br><span class=\"line\">[GEOFILTER geo_field lon lat radius m|km|mi|ft]</span><br><span class=\"line\">[INKEYS count key ...]</span><br><span class=\"line\">[INFIELDS count field ...]</span><br><span class=\"line\">[RETURN count identifier [AS property] ...]</span><br><span class=\"line\">[SUMMARIZE FIELDS count field ... FRAGS num LEN fragsize SEPARATOR sep]</span><br><span class=\"line\">[HIGHLIGHT FIELDS count field ... TAGS open close]</span><br><span class=\"line\">[SLOP slop] [TIMEOUT <span class=\"built_in\">timeout</span>] [INORDER]</span><br><span class=\"line\">[LANGUAGE language]</span><br><span class=\"line\">[EXPANDER expander]</span><br><span class=\"line\">[SCORER scorer]</span><br><span class=\"line\">[EXPLAINSCORE]</span><br><span class=\"line\">[PAYLOAD payload]</span><br><span class=\"line\">[SORTBY sortby ASC|DESC]</span><br><span class=\"line\">[LIMIT offset num]</span><br><span class=\"line\">[PARAMS nargs name value ...]</span><br><span class=\"line\">[DIALECT dialect]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.SEARCH 参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>index</code></td>\n<td>索引名称</td>\n</tr>\n<tr>\n<td><code>query</code></td>\n<td>查询条件（类似 SQL WHERE）</td>\n</tr>\n<tr>\n<td><code>NOCONTENT</code></td>\n<td>仅返回文档 ID，不返回内容</td>\n</tr>\n<tr>\n<td><code>VERBATIM</code></td>\n<td>禁用查询优化，完全按原查询执行</td>\n</tr>\n<tr>\n<td><code>NOSTOPWORDS</code></td>\n<td>查询时不忽略停用词</td>\n</tr>\n<tr>\n<td><code>WITHSCORES</code></td>\n<td>返回匹配文档的相关性评分</td>\n</tr>\n<tr>\n<td><code>WITHPAYLOADS</code></td>\n<td>返回文档的 payload 数据</td>\n</tr>\n<tr>\n<td><code>WITHSORTKEYS</code></td>\n<td>返回排序使用的 key</td>\n</tr>\n<tr>\n<td><code>FILTER</code></td>\n<td>数值字段过滤（范围查询）</td>\n</tr>\n<tr>\n<td><code>GEOFILTER</code></td>\n<td>地理位置范围查询</td>\n</tr>\n<tr>\n<td><code>INKEYS</code></td>\n<td>仅在指定的 key 集合中搜索</td>\n</tr>\n<tr>\n<td><code>INFIELDS</code></td>\n<td>仅在指定字段中搜索</td>\n</tr>\n<tr>\n<td><code>RETURN</code></td>\n<td>指定返回的字段</td>\n</tr>\n<tr>\n<td><code>SUMMARIZE</code></td>\n<td>返回字段内容摘要</td>\n</tr>\n<tr>\n<td><code>HIGHLIGHT</code></td>\n<td>高亮匹配的关键词</td>\n</tr>\n<tr>\n<td><code>SLOP</code></td>\n<td>设置短语查询中允许的词距</td>\n</tr>\n<tr>\n<td><code>TIMEOUT</code></td>\n<td>设置查询超时时间</td>\n</tr>\n<tr>\n<td><code>INORDER</code></td>\n<td>短语必须按顺序匹配</td>\n</tr>\n<tr>\n<td><code>LANGUAGE</code></td>\n<td>指定查询语言</td>\n</tr>\n<tr>\n<td><code>EXPANDER</code></td>\n<td>使用自定义查询扩展器</td>\n</tr>\n<tr>\n<td><code>SCORER</code></td>\n<td>使用自定义评分函数</td>\n</tr>\n<tr>\n<td><code>EXPLAINSCORE</code></td>\n<td>返回评分计算详情</td>\n</tr>\n<tr>\n<td><code>PAYLOAD</code></td>\n<td>给评分函数传入自定义参数</td>\n</tr>\n<tr>\n<td><code>SORTBY</code></td>\n<td>按指定字段排序</td>\n</tr>\n<tr>\n<td><code>ASC / DESC</code></td>\n<td>排序方向</td>\n</tr>\n<tr>\n<td><code>LIMIT</code></td>\n<td>分页控制</td>\n</tr>\n<tr>\n<td><code>PARAMS</code></td>\n<td>参数化查询</td>\n</tr>\n<tr>\n<td><code>DIALECT</code></td>\n<td>指定查询语法版本</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.SEARCH 核心语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SEARCH index</span><br><span class=\"line\">query</span><br><span class=\"line\">[RETURN count identifier [AS property] ...]</span><br><span class=\"line\">[SORTBY sortby ASC|DESC]</span><br><span class=\"line\">[LIMIT offset num]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>标准搜索</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SEARCH idx:user</span><br><span class=\"line\">  <span class=\"string\">&#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27;</span></span><br><span class=\"line\">  RETURN 3 name status amount</span><br><span class=\"line\">  SORTBY amount DESC</span><br><span class=\"line\">  LIMIT 0 10</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\">  <span class=\"comment\"># 查询条件：&#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\"># 查询条件语法：</span></span><br><span class=\"line\">  <span class=\"comment\"># &#x27;xxx&#x27;: 全文检索包含 xxx 的数据，会从 TEXT 字段中匹配</span></span><br><span class=\"line\">  <span class=\"comment\"># &#x27;@field:value&#x27;: 匹配字段 field 的值是 value，要求 field 的类型为 TEXT，全文检索</span></span><br><span class=\"line\">  <span class=\"comment\"># &#x27;@field:&#123;xxx&#125;&#x27;:精确匹配，&#123;xxx*&#125;:匹配前缀，&#123;xxx|yyy&#125;:匹配任意一个，要求 field 的类型为 TAG</span></span><br><span class=\"line\">  <span class=\"comment\"># &#x27;@field:[min max]&#x27;: 范围匹配，这里 +inf 表示正无穷大，要求 field 的类型为 NUMERIC</span></span><br><span class=\"line\">  <span class=\"comment\"># 多个条件空格分隔</span></span><br><span class=\"line\">  <span class=\"comment\"># 模糊匹配：* 表示任意字符，即匹配所有</span></span><br><span class=\"line\"><span class=\"comment\"># RETURN 3 name status amount 返回字段，3:表示返回 3 个字段</span></span><br><span class=\"line\"><span class=\"comment\"># LIMIT 0 10 分页，0:表示从第 0 条开始，10:表示返回 10 条数据</span></span><br><span class=\"line\"><span class=\"comment\"># SORTBY amount DESC 排序，amount:表示排序字段，DESC:表示降序</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SearchResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.search(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;@status:&#123;PAID&#125; @amount:[50 +inf]&quot;</span>,</span><br><span class=\"line\">        QueryOptions.defaults()</span><br><span class=\"line\">        .returnAttributes(<span class=\"keyword\">new</span> <span class=\"title class_\">ReturnAttribute</span>(<span class=\"string\">&quot;name&quot;</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">ReturnAttribute</span>(<span class=\"string\">&quot;status&quot;</span>),<span class=\"keyword\">new</span> <span class=\"title class_\">ReturnAttribute</span>(<span class=\"string\">&quot;amount&quot;</span>))</span><br><span class=\"line\">                .sortBy(<span class=\"string\">&quot;amount&quot;</span>)</span><br><span class=\"line\">                .sortOrder(SortOrder.DESC)</span><br><span class=\"line\">                .limit(<span class=\"number\">0</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> result.getTotal();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;total = &quot;</span> + total);</span><br><span class=\"line\">List&lt;Document&gt; docs = result.getDocuments();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Document doc: docs) &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> doc.getId();</span><br><span class=\"line\">    Map&lt;String, Object&gt; attrs = doc.getAttributes();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;id = &quot;</span> + id + <span class=\"string\">&quot; attrs = &quot;</span> + attrs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全文检索，从 所有 TEXT 字段中匹配，不区分大小写，即 phone/Phone/PHONE 都匹配</span></span><br><span class=\"line\">FT.SEARCH idx:user <span class=\"string\">&#x27;phone&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 示例结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">2) <span class=\"string\">&quot;user:10006&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Frank\\&quot;,\\&quot;age\\&quot;:27,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:499,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:129,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Redis\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;,\\&quot;MongoDB\\xe4\\xbb\\x8e\\xe5\\x85\\xa5\\xe9\\x97\\xa8\\xe5\\x88\\xb0\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;]&#125;&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user:10001&quot;</span></span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Alice Bob\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;SpringCloud\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe6\\x8c\\x87\\xe5\\x8d\\x97\\&quot;,\\&quot;Shell\\xe8\\x84\\x9a\\xe6\\x9c\\xac\\xe5\\x9f\\xba\\xe7\\xa1\\x80\\&quot;]&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SearchResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.search(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;phone&quot;</span>,</span><br><span class=\"line\">        QueryOptions.defaults()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 中文检索</span></span><br><span class=\"line\">FT.SEARCH idx:user <span class=\"string\">&#x27;开始&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 示例结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">2) <span class=\"string\">&quot;user:10005&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Eve\\&quot;,\\&quot;age\\&quot;:30,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:88.8,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a pencil\\&quot;,\\&quot;items\\&quot;:[\\&quot;Kafka\\xe4\\xbb\\x8e\\xe9\\x9b\\xb6\\xe5\\xbc\\x80\\xe5\\xa7\\x8b\\&quot;,\\&quot;Java\\xe7\\x94\\xb1\\xe6\\xb5\\x85\\xe5\\x85\\xa5\\xe6\\xb7\\xb1\\&quot;]&#125;&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user:10007&quot;</span></span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Grace\\&quot;,\\&quot;age\\&quot;:33,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:999.9,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a book\\&quot;,\\&quot;items\\&quot;:[\\&quot;Android\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe6\\x89\\x8b\\xe5\\x86\\x8c\\&quot;,\\&quot;Gradle\\xe4\\xbb\\x8e\\xe9\\x9b\\xb6\\xe5\\xbc\\x80\\xe5\\xa7\\x8b\\&quot;]&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SearchResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.search(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;开始&quot;</span>,</span><br><span class=\"line\">        QueryOptions.defaults()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">看到中文输出是乱码，可以在登录客户端时加上 --raw</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --user admin -a 123456 --raw</span><br><span class=\"line\">127.0.0.1:6379&gt; FT.SEARCH idx:user <span class=\"string\">&#x27;开始&#x27;</span></span><br><span class=\"line\">2</span><br><span class=\"line\">user:10005</span><br><span class=\"line\">$</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;Eve&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:30,<span class=\"string\">&quot;vip&quot;</span>:<span class=\"string\">&quot;no&quot;</span>,<span class=\"string\">&quot;orders&quot;</span>:[&#123;<span class=\"string\">&quot;amount&quot;</span>:88.8,<span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;CREATED&quot;</span>&#125;],<span class=\"string\">&quot;comment&quot;</span>:<span class=\"string\">&quot;I have a pencil&quot;</span>,<span class=\"string\">&quot;items&quot;</span>:[<span class=\"string\">&quot;Kafka从零开始&quot;</span>,<span class=\"string\">&quot;Java由浅入深&quot;</span>]&#125;</span><br><span class=\"line\">user:10007</span><br><span class=\"line\">$</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;Grace&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:33,<span class=\"string\">&quot;vip&quot;</span>:<span class=\"string\">&quot;yes&quot;</span>,<span class=\"string\">&quot;orders&quot;</span>:[&#123;<span class=\"string\">&quot;amount&quot;</span>:999.9,<span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;PAID&quot;</span>&#125;],<span class=\"string\">&quot;comment&quot;</span>:<span class=\"string\">&quot;I have a book&quot;</span>,<span class=\"string\">&quot;items&quot;</span>:[<span class=\"string\">&quot;Android开发手册&quot;</span>,<span class=\"string\">&quot;Gradle从零开始&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n</div>\n<h5 id=\"SQL-WHERE-与-RediSearch-查询语法对照表\">SQL WHERE 与 RediSearch 查询语法对照表</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>x/y/name</code> → <code>TEXT/TAG(要加上&#123;&#125;)</code> 字段，<code>num</code>→<code>NUMERIC</code> 字段，查询语法用于 <code>FT.SEARCH</code>/<code>FT.AGGREGATE</code> 的查询字符串部分</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>SQL 条件</th>\n<th>RediSearch 对等写法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>WHERE x = 'book' AND y = 'phone'</code></td>\n<td><code>@x:book @y:phone</code></td>\n<td>AND 为默认关系（空格）</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>WHERE x = 'book' AND y != 'phone'</code></td>\n<td><code>@x:book -@y:phone</code></td>\n<td><code>-</code> 表示 NOT</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>WHERE x = 'book' OR y = 'phone'</code></td>\n<td><code>(@x:book) | (@y:phone)</code></td>\n<td>OR 必须显式写 <code>|</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>WHERE x IN ('book','phone','hello world')</code></td>\n<td><code>@x:(book|phone|&quot;hello world&quot;)</code></td>\n<td>多值 OR，短语需加引号</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>WHERE y='book' AND x NOT IN ('book','phone')</code></td>\n<td><code>@y:book -(@x:book|@x:phone)</code></td>\n<td>NOT IN = NOT + OR</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>WHERE x NOT IN ('book','phone')</code></td>\n<td><code>-@x:(book|phone)</code></td>\n<td>整体否定</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>WHERE num BETWEEN 10 AND 20</code></td>\n<td><code>@num:[10 20]</code></td>\n<td>数值区间（闭区间）</td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>WHERE num &gt;= 10</code></td>\n<td><code>@num:[10 +inf]</code></td>\n<td><code>+inf</code> 表示正无穷</td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>WHERE num &gt; 10</code></td>\n<td><code>@num:[(10 +inf]</code></td>\n<td><code>(</code> 表示不包含</td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>WHERE num &lt; 10</code></td>\n<td><code>@num:[-inf (10]</code></td>\n<td>小于（不含 10）</td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>WHERE num &lt;= 10</code></td>\n<td><code>@num:[-inf 10]</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>12</td>\n<td><code>WHERE num &lt; 10 OR num &gt; 20</code></td>\n<td><code>@num:[-inf (10] | @num:[(20 +inf]</code></td>\n<td>数值 OR</td>\n</tr>\n<tr>\n<td>13</td>\n<td><code>WHERE name LIKE 'Li%'</code></td>\n<td><code>@name:Li*</code></td>\n<td>前缀匹配</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2️⃣-FT-AGGREGATE\">2️⃣ FT.AGGREGATE</h4>\n<blockquote>\n<p>分组 / 统计 / 聚合，语法</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.AGGREGATE 基本语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE index query</span><br><span class=\"line\">[VERBATIM]</span><br><span class=\"line\">[LOAD count field ... | LOAD *]</span><br><span class=\"line\">[TIMEOUT <span class=\"built_in\">timeout</span>]</span><br><span class=\"line\">[GROUPBY nargs property ...</span><br><span class=\"line\">   REDUCE <span class=\"keyword\">function</span> nargs arg ... [AS name] ...]</span><br><span class=\"line\">[SORTBY nargs property ASC|DESC ... [MAX num]]</span><br><span class=\"line\">[APPLY expression AS name]</span><br><span class=\"line\">[LIMIT offset num]</span><br><span class=\"line\">[FILTER filter]</span><br><span class=\"line\">[WITHCURSOR [COUNT read_size]]</span><br><span class=\"line\">[MAXIDLE idle_time]</span><br><span class=\"line\">[PARAMS nargs name value ...]</span><br><span class=\"line\">[DIALECT dialect]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.AGGREGATE 参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>index</code></td>\n<td>索引名称</td>\n</tr>\n<tr>\n<td><code>query</code></td>\n<td>查询条件（类似 WHERE）</td>\n</tr>\n<tr>\n<td><code>VERBATIM</code></td>\n<td>禁用查询优化</td>\n</tr>\n<tr>\n<td><code>LOAD</code></td>\n<td>加载原始字段</td>\n</tr>\n<tr>\n<td><code>TIMEOUT</code></td>\n<td>查询超时时间</td>\n</tr>\n<tr>\n<td><code>GROUPBY</code></td>\n<td>分组字段（类似 SQL GROUP BY）</td>\n</tr>\n<tr>\n<td><code>REDUCE</code></td>\n<td>聚合函数（COUNT / SUM / AVG / MIN / MAX 等）</td>\n</tr>\n<tr>\n<td><code>AS</code></td>\n<td>聚合结果别名</td>\n</tr>\n<tr>\n<td><code>SORTBY</code></td>\n<td>对聚合结果排序</td>\n</tr>\n<tr>\n<td><code>ASC / DESC</code></td>\n<td>排序方向</td>\n</tr>\n<tr>\n<td><code>MAX</code></td>\n<td>最大返回条数</td>\n</tr>\n<tr>\n<td><code>APPLY</code></td>\n<td>对结果字段进行表达式计算</td>\n</tr>\n<tr>\n<td><code>LIMIT</code></td>\n<td>分页控制</td>\n</tr>\n<tr>\n<td><code>FILTER</code></td>\n<td>结果过滤（WHERE / HAVING）</td>\n</tr>\n<tr>\n<td><code>WITHCURSOR</code></td>\n<td>使用游标（大结果集）</td>\n</tr>\n<tr>\n<td><code>COUNT</code></td>\n<td>每次读取数量</td>\n</tr>\n<tr>\n<td><code>MAXIDLE</code></td>\n<td>游标最大空闲时间</td>\n</tr>\n<tr>\n<td><code>PARAMS</code></td>\n<td>参数化查询</td>\n</tr>\n<tr>\n<td><code>DIALECT</code></td>\n<td>查询语法版本</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.AGGREGATE 的核心语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE &lt;index&gt; &lt;query&gt;</span><br><span class=\"line\">  [GROUPBY ...]</span><br><span class=\"line\">  [REDUCE ...]</span><br><span class=\"line\">  [SORTBY ...]</span><br><span class=\"line\">  [LIMIT ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 1：按 status 分组统计数量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE idx:user</span><br><span class=\"line\">  <span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE COUNT 0 AS cnt</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># *: 查询条件，* 表示匹配索引中的 所有文档，也可以是 FT.SEARCH 中的查询条件，比如：&#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># GROUPBY 1 @status: 分组字段</span></span><br><span class=\"line\">  <span class=\"comment\"># 1:表示分组字段数量</span></span><br><span class=\"line\">  <span class=\"comment\"># @status:表示分组字段</span></span><br><span class=\"line\"><span class=\"comment\"># REDUCE COUNT 0 AS cnt: 聚合字段</span></span><br><span class=\"line\">  <span class=\"comment\"># COUNT:聚合函数：计数</span></span><br><span class=\"line\">  <span class=\"comment\"># 0:参数个数（COUNT 不需要参数）</span></span><br><span class=\"line\">  <span class=\"comment\"># AS cnt:表示聚合字段别名</span></span><br><span class=\"line\"><span class=\"comment\">## 返回结果示例</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CANCELLED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;PAID&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CREATED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对应SQL 语句：</span></span><br><span class=\"line\">SELECT status, COUNT(*) AS cnt</span><br><span class=\"line\">  FROM user</span><br><span class=\"line\">  GROUP BY status;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AggregationResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.aggregate(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;*&quot;</span>,</span><br><span class=\"line\">        AggregationOptions.defaults()</span><br><span class=\"line\">                .groupBy(GroupBy.fieldNames(<span class=\"string\">&quot;@status&quot;</span>).reducers(Reducer.count().as(<span class=\"string\">&quot;cnt&quot;</span>)))</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> result.getTotal();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;total = &quot;</span> + total);</span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Map&lt;String, Object&gt;&gt; attributes = result.getAttributes();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map&lt;String, Object&gt; attribute : attributes) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;attribute = &quot;</span> + attribute);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 2：按 status 分组统计金额总和</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE idx:user <span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE SUM 1 @amount AS total_amount</span><br><span class=\"line\">  SORTBY 2 @total_amount DESC</span><br><span class=\"line\">  LIMIT 0 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># SUM:聚合函数：求和</span></span><br><span class=\"line\"><span class=\"comment\"># 1:参数个数</span></span><br><span class=\"line\"><span class=\"comment\"># @amount:要参与求和的字段</span></span><br><span class=\"line\"><span class=\"comment\"># total_amount:表示聚合字段别名</span></span><br><span class=\"line\"><span class=\"comment\"># SORTBY 2 @total_amount DESC: 排序</span></span><br><span class=\"line\">  <span class=\"comment\"># 2: 表示后面跟 2 个参数（字段 + 排序方向）</span></span><br><span class=\"line\">  <span class=\"comment\"># @total_amount: 表示排序字段（REDUCE 产生的别名），DESC:表示降序</span></span><br><span class=\"line\"><span class=\"comment\"># LIMIT 0 3: 分页，0:表示从第 0 条开始，3:表示返回 3 条数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 示例结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;PAID&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;4096.89&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CREATED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;238.8&quot;</span></span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CANCELLED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;79.8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对应SQL 语句：</span></span><br><span class=\"line\">SELECT status, SUM(amount) AS total_amount</span><br><span class=\"line\">  FROM user</span><br><span class=\"line\">  GROUP BY status</span><br><span class=\"line\">  ORDER BY total_amount DESC</span><br><span class=\"line\">  LIMIT 0 3;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AggregationResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.aggregate(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;*&quot;</span>,</span><br><span class=\"line\">        AggregationOptions.defaults()</span><br><span class=\"line\">                .groupBy(GroupBy.fieldNames(<span class=\"string\">&quot;@status&quot;</span>)</span><br><span class=\"line\">                        .reducers(</span><br><span class=\"line\">                                Reducer.sum(<span class=\"string\">&quot;@amount&quot;</span>).as(<span class=\"string\">&quot;total_amount&quot;</span>)</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .sortBy(<span class=\"keyword\">new</span> <span class=\"title class_\">SortedField</span>(<span class=\"string\">&quot;@total_amount&quot;</span>, SortOrder.DESC))</span><br><span class=\"line\">                .limit(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 3：同时输出数量 + 金额，并按金额降序，数量升序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE idx:user <span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE COUNT 0 AS cnt</span><br><span class=\"line\">  REDUCE SUM 1 @amount AS total_amount</span><br><span class=\"line\">  SORTBY 4 @total_amount DESC @cnt ASC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 示例结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;PAID&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;4096.89&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CREATED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;238.8&quot;</span></span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;CANCELLED&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;cnt&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;79.8&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AggregationResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.aggregate(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;*&quot;</span>,</span><br><span class=\"line\">        AggregationOptions.defaults()</span><br><span class=\"line\">                .groupBy(GroupBy.fieldNames(<span class=\"string\">&quot;@status&quot;</span>)</span><br><span class=\"line\">                        .reducers(</span><br><span class=\"line\">                                Reducer.count().as(<span class=\"string\">&quot;cnt&quot;</span>),</span><br><span class=\"line\">                                Reducer.sum(<span class=\"string\">&quot;@amount&quot;</span>).as(<span class=\"string\">&quot;total_amount&quot;</span>)</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .sortBy(<span class=\"keyword\">new</span> <span class=\"title class_\">SortedField</span>(<span class=\"string\">&quot;@total_amount&quot;</span>, SortOrder.DESC))</span><br><span class=\"line\">                .sortBy(<span class=\"keyword\">new</span> <span class=\"title class_\">SortedField</span>(<span class=\"string\">&quot;@cnt&quot;</span>, SortOrder.ASC))</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 4：按状态分组，筛选总金额 &gt; 200</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE idx:user <span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE SUM 1 @amount AS total_amount</span><br><span class=\"line\">  FILTER @total_amount &gt; 200</span><br><span class=\"line\">  SORTBY 2 @total_amount DESC</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># FILTER: 过滤器，作用在 GROUPBY + REDUCE 之后，语义等价于 SQL 的：HAVING SUM(amount) &gt; 1000</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AggregationResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.aggregate(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;*&quot;</span>,</span><br><span class=\"line\">        AggregationOptions.defaults()</span><br><span class=\"line\">                .groupBy(GroupBy.fieldNames(<span class=\"string\">&quot;@status&quot;</span>)</span><br><span class=\"line\">                        .reducers(</span><br><span class=\"line\">                                Reducer.sum(<span class=\"string\">&quot;@amount&quot;</span>).as(<span class=\"string\">&quot;total_amount&quot;</span>)</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .filter(<span class=\"string\">&quot;@total_amount &gt; 200&quot;</span>)</span><br><span class=\"line\">                .sortBy(<span class=\"keyword\">new</span> <span class=\"title class_\">SortedField</span>(<span class=\"string\">&quot;@total_amount&quot;</span>, SortOrder.DESC))</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>语义执行顺序： SCAN → GROUPBY → REDUCE → FILTER (HAVING) → SORTBY → LIMIT</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常见可用 REDUCE 函数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COUNT</td>\n<td>行数</td>\n</tr>\n<tr>\n<td>SUM</td>\n<td>求和</td>\n</tr>\n<tr>\n<td>AVG</td>\n<td>平均</td>\n</tr>\n<tr>\n<td>MIN / MAX</td>\n<td>极值</td>\n</tr>\n<tr>\n<td>TO_LIST</td>\n<td>收集字段</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3️⃣-FT-EXPLAIN-FT-EXPLAINCLI\">3️⃣ FT.EXPLAIN/FT.EXPLAINCLI</h4>\n<blockquote>\n<p>查询执行计划， 不会考虑分组聚合，只看查询条件，它的定位是：看“会不会用索引、怎么用索引”，而不是看“跑得慢不慢”。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.EXPLAINCLI idx:user <span class=\"string\">&#x27;@status:&#123;PAID&#125;  @amount:[100 +inf]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 示例结果</span></span><br><span class=\"line\">1) INTERSECT &#123;</span><br><span class=\"line\">2)   TAG:@status &#123;</span><br><span class=\"line\">3)     paid</span><br><span class=\"line\">4)   &#125;</span><br><span class=\"line\">5)   NUMERIC &#123;100.000000 &lt;= @amount &lt;= inf&#125;</span><br><span class=\"line\">6) &#125;</span><br><span class=\"line\">7)</span><br></pre></td></tr></table></figure>\n<h4 id=\"4️⃣-FT-PROFILE\">4️⃣ FT.PROFILE</h4>\n<blockquote>\n<p>性能分析，看“跑得慢不慢”。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.PROFILE idx:user</span><br><span class=\"line\">  SEARCH</span><br><span class=\"line\">  QUERY <span class=\"string\">&#x27;@status:&#123;PAID&#125;  @amount:[100 +inf]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># SEARCH: 标准查询，AGGREGATE: 聚合查询</span></span><br><span class=\"line\"><span class=\"comment\"># QUERY: 查询条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">FT.PROFILE idx:user</span><br><span class=\"line\">  AGGREGATE</span><br><span class=\"line\">  QUERY <span class=\"string\">&quot;@status:&#123;PAID&#125; @amount:[100 +inf]&quot;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE SUM 1 @amount AS total_amount</span><br></pre></td></tr></table></figure>\n<h5 id=\"关注指标\">关注指标</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一优先级指标（直接决定查询是否慢）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>所在位置</th>\n<th>含义</th>\n<th>健康阈值</th>\n<th>需要警惕</th>\n<th>常见优化手段</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Total profile time</strong></td>\n<td>Shards → Total profile time</td>\n<td>查询在搜索引擎层面的总耗时（不含网络）</td>\n<td><strong>&lt; 1 ms：优秀</strong><br>1–10 ms：可接受</td>\n<td>&gt; 20 ms：需要优化<br>&gt; 50 ms：结构性问题</td>\n<td>减少结果集、拆分查询、优化索引字段</td>\n</tr>\n<tr>\n<td><strong>Iterator Type</strong></td>\n<td>Iterators profile → Type</td>\n<td>查询执行策略</td>\n<td><strong>INTERSECT / UNION</strong></td>\n<td><strong>SCAN / WILDCARD</strong></td>\n<td>增加可索引字段、避免模糊前缀</td>\n</tr>\n<tr>\n<td><strong>Estimated number of matches</strong></td>\n<td>Child iterators</td>\n<td>索引层估算的候选文档数</td>\n<td><strong>&lt; 1k：理想</strong><br>1k–10k：可接受</td>\n<td>&gt; 50k：过滤条件过宽</td>\n<td>改用 TAG / NUMERIC / 冗余字段</td>\n</tr>\n<tr>\n<td><strong>Loader Time</strong></td>\n<td>Result processors → Loader</td>\n<td>从 Redis 加载并反序列化文档</td>\n<td>&lt; 30% Total time</td>\n<td>&gt; 40% Total time</td>\n<td>RETURN 精简字段、NOCONTENT、缩小 JSON</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二优先级指标（判断索引或模型是否合理）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>所在位置</th>\n<th>含义</th>\n<th>健康阈值</th>\n<th>需要警惕</th>\n<th>常见优化手段</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Number of reading operations</strong></td>\n<td>Iterators profile</td>\n<td>实际扫描的倒排表条目数</td>\n<td>≈ Estimated matches</td>\n<td>明显大于结果数</td>\n<td>提高字段选择性、拆分条件</td>\n</tr>\n<tr>\n<td><strong>Estimated matches vs 实际结果数</strong></td>\n<td>Iterator + Result</td>\n<td>索引估算精度</td>\n<td>估算值略大于实际</td>\n<td>估算 &gt;&gt; 实际（10x+）</td>\n<td>调整 schema，避免低基数字段</td>\n</tr>\n<tr>\n<td><strong>Parsing time</strong></td>\n<td>Shards → Parsing time</td>\n<td>查询语法解析耗时</td>\n<td>&lt; 0.1 ms</td>\n<td>&gt; 1 ms</td>\n<td>减少动态拼接、简化语法</td>\n</tr>\n<tr>\n<td><strong>Pipeline creation time</strong></td>\n<td>Shards → Pipeline creation</td>\n<td>执行计划构建时间</td>\n<td>&lt; 0.05 ms</td>\n<td>&gt; 0.5 ms</td>\n<td>减少子句、避免复杂嵌套</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>经验型“红线判断”速查表（非常实用）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>现象</th>\n<th>含义</th>\n<th>是否必须处理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Estimated matches &gt; 100k</td>\n<td>索引字段选择错误</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>Iterator Type = SCAN</td>\n<td>全表扫描</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>Loader &gt; 50% 总耗时</td>\n<td>返回数据过重</td>\n<td>强烈建议</td>\n</tr>\n<tr>\n<td>reading ops ≫ results</td>\n<td>倒排效率低</td>\n<td>建议</td>\n</tr>\n<tr>\n<td>Total time &gt; 20 ms</td>\n<td>在线查询风险</td>\n<td>必须</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心执行策略型 Iterator（最重要）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>语义</th>\n<th>典型触发场景</th>\n<th>性能特征</th>\n<th>调优结论</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>INTERSECT</strong></td>\n<td>多条件取交集（AND）</td>\n<td><code>@a:&#123;x&#125; @b:[1 10]</code></td>\n<td>基于最小倒排表，效率最高</td>\n<td><strong>理想状态，优先使用</strong></td>\n</tr>\n<tr>\n<td><strong>UNION</strong></td>\n<td>多条件取并集（OR）</td>\n<td><code>@a:&#123;x|y&#125;</code></td>\n<td>候选集扩大，随 OR 数量线性增长</td>\n<td>可接受，避免过多 OR</td>\n</tr>\n<tr>\n<td><strong>SCAN</strong></td>\n<td>全量扫描</td>\n<td>字段未索引 / JSON Path 不可索引</td>\n<td>O(N)，文档越多越慢</td>\n<td><strong>必须消灭</strong></td>\n</tr>\n<tr>\n<td><strong>WILDCARD</strong></td>\n<td>无过滤条件</td>\n<td><code>&quot;*&quot;</code>、<code>@field:*</code></td>\n<td>候选集=全部文档</td>\n<td>仅限分析，线上慎用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>索引访问型 Iterator（INTERSECT / UNION 的子节点）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>对应字段类型</th>\n<th>示例查询</th>\n<th>性能特征</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TAG</strong></td>\n<td>TAG</td>\n<td><code>@status:&#123;PAID&#125;</code></td>\n<td>哈希倒排，最快</td>\n<td>强烈推荐</td>\n</tr>\n<tr>\n<td><strong>NUMERIC</strong></td>\n<td>NUMERIC</td>\n<td><code>@amount:[100 +inf]</code></td>\n<td>跳表范围扫描</td>\n<td>范围越窄越快</td>\n</tr>\n<tr>\n<td><strong>TEXT</strong></td>\n<td>TEXT</td>\n<td><code>@name:alice</code></td>\n<td>分词匹配</td>\n<td>分词数影响性能</td>\n</tr>\n<tr>\n<td><strong>GEO</strong></td>\n<td>GEO</td>\n<td><code>@loc:[13.4 52.5 10 km]</code></td>\n<td>空间索引</td>\n<td>半径影响结果数</td>\n</tr>\n<tr>\n<td><strong>VECTOR</strong></td>\n<td>VECTOR</td>\n<td><code>=&gt;[KNN 10 @v $q]</code></td>\n<td>向量搜索</td>\n<td>常与 FILTER 联用</td>\n</tr>\n<tr>\n<td><strong>IDLIST</strong></td>\n<td>内部</td>\n<td>小结果集</td>\n<td>枚举 ID</td>\n<td>自动优化</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>逻辑 / 结构型 Iterator</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>含义</th>\n<th>触发示例</th>\n<th>性能影响</th>\n<th>是否常见</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NOT</strong></td>\n<td>取反</td>\n<td><code>-@status:&#123;PAID&#125;</code></td>\n<td>依赖全集</td>\n<td>较少</td>\n</tr>\n<tr>\n<td><strong>OPTIONAL</strong></td>\n<td>可选子句</td>\n<td><code>( @a:&#123;x&#125; )?</code></td>\n<td>增加候选集</td>\n<td>少见</td>\n</tr>\n<tr>\n<td><strong>EMPTY</strong></td>\n<td>无匹配</td>\n<td>条件不可能满足</td>\n<td>极快</td>\n<td>偶发</td>\n</tr>\n<tr>\n<td><strong>PHRASE</strong></td>\n<td>短语匹配</td>\n<td><code>&quot;hello world&quot;</code></td>\n<td>比 TEXT 慢</td>\n<td>低频</td>\n</tr>\n<tr>\n<td><strong>PREFIX</strong></td>\n<td>前缀匹配</td>\n<td><code>abc*</code></td>\n<td>可能退化</td>\n<td>需谨慎</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三、别名管理（生产必备）\">三、别名管理（生产必备）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.ALIASADD</code></td>\n<td>添加别名</td>\n</tr>\n<tr>\n<td><code>FT.ALIASDEL</code></td>\n<td>删除别名</td>\n</tr>\n<tr>\n<td><code>FT.ALIASUPDATE</code></td>\n<td>更新别名指向</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个索引可以有多个别名，一旦创建别名，所有 FT.SEARCH / FT.AGGREGATE / <a href=\"http://FT.INFO\">FT.INFO</a> 等命令都可以直接使用 alias</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加别名: FT.ALIASADD alias index</span></span><br><span class=\"line\">FT.ALIASADD <span class=\"built_in\">alias</span>:user idx:user</span><br><span class=\"line\"><span class=\"comment\"># 更新别名指向: FT.ALIASUPDATE alias index</span></span><br><span class=\"line\">FT.ALIASUPDATE <span class=\"built_in\">alias</span>:user idx:user:v2</span><br><span class=\"line\"><span class=\"comment\"># 删除别名: FT.ALIASDEL alias</span></span><br><span class=\"line\">FT.ALIASDEL <span class=\"built_in\">alias</span>:user</span><br><span class=\"line\"><span class=\"comment\"># 判断索引名称是否为别名</span></span><br><span class=\"line\">FT.INFO <span class=\"built_in\">alias</span>:user</span><br><span class=\"line\"> 1) index_name</span><br><span class=\"line\"> 2) idx:user  <span class=\"comment\"># 真实索引名称</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.addAlias(<span class=\"string\">&quot;alias:user&quot;</span>, <span class=\"string\">&quot;idx:user&quot;</span>);</span><br><span class=\"line\">rSearch.updateAlias(<span class=\"string\">&quot;alias:user&quot;</span>, <span class=\"string\">&quot;idx:user:v2&quot;</span>);</span><br><span class=\"line\">rSearch.delAlias(<span class=\"string\">&quot;alias:user&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"索引别名的核心价值\">索引别名的核心价值</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">索引无损重建（最典型场景）</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">RediSearch 不支持在线修改 schema，字段变更通常需要重建索引，索引重建时业务将不可用。</li>\n<li class=\"lvl-4\">有了别名，我们可以创建一个新的索引，创建好后将别名指向新的索引，旧索引不再使用，业务无影响。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 旧索引</span><br><span class=\"line\"> FT.ALIASADD user_idx user_idx_v1</span><br><span class=\"line\"></span><br><span class=\"line\">2. 新建索引</span><br><span class=\"line\">  FT.CREATE user_idx_v2 ...</span><br><span class=\"line\"></span><br><span class=\"line\">3. 数据回填完成后，原子切换</span><br><span class=\"line\">  FT.ALIASUPDATE user_idx user_idx_v2</span><br><span class=\"line\"></span><br><span class=\"line\">4. 删除旧索引（可选）</span><br><span class=\"line\">  FT.DROPINDEX user_idx_v1</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">灰度 / 多版本并存</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">不同环境（dev / staging / prod）</li>\n<li class=\"lvl-4\">不同 schema 版本</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">运维与发布规范化（强烈推荐）</li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">在生产环境中：永远不要让业务代码直接使用物理索引名</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">索引真实名: 业务名_版本_时间戳</span><br><span class=\"line\">索引别名 : 业务名</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"四、游标（大结果集）\">四、游标（大结果集）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.CURSOR READ</code></td>\n<td>分批读取</td>\n</tr>\n<tr>\n<td><code>FT.CURSOR DEL</code></td>\n<td>删除游标</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>游标用于聚合查询（AGGREGATE）的大结果集分页/分批拉取，典型场景包括：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GROUPBY / REDUCE 后结果集很大</span><br><span class=\"line\">需要流式处理聚合结果，避免一次性返回占用大量内存</span><br><span class=\"line\">客户端按批消费结果（类似数据库的 server-side cursor）</span><br><span class=\"line\">注意：游标主要用于 FT.AGGREGATE，普通 FT.SEARCH 不支持游标分页。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过 <code>FT.AGGREGATE ... WITHCURSOR</code> 创建游标，通过 <code>FT.CURSOR READ</code> 获取结果。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE idx:user <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\">  GROUPBY 1 @status</span><br><span class=\"line\">  REDUCE SUM 1 @amount AS total_amount</span><br><span class=\"line\">  WITHCURSOR COUNT 2 MAXIDLE 60000</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCURSOR : 启用游标</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT 2 : 每次从游标中返回的行数（批大小）</span></span><br><span class=\"line\"><span class=\"comment\"># MAXIDLE 60000 : 游标最大空闲时间（毫秒），超时后自动销毁</span></span><br><span class=\"line\"><span class=\"comment\">## 返回结果</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 3   <span class=\"comment\"># GROUP BY 后，一共会产生 3 行聚合结果，这里返回的是实际查询的总行数，不受COUNT 参数限制</span></span><br><span class=\"line\">   2) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;CANCELLED&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;79.8&quot;</span></span><br><span class=\"line\">   3) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;PAID&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;4096.89&quot;</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 116452546  <span class=\"comment\"># 游标ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取游标</span></span><br><span class=\"line\">FT.CURSOR READ idx:user 116452546 COUNT 2</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># 116452546 : 游标ID</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT 2 : 每次从游标中返回的行数(可覆盖初始游标中的 COUNT）</span></span><br><span class=\"line\"><span class=\"comment\">## 返回结果</span></span><br><span class=\"line\">1) 1) (<span class=\"built_in\">integer</span>) 0   <span class=\"comment\"># 当前游标中“剩余可读的行数”为 0</span></span><br><span class=\"line\">   2) 1) <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;CREATED&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;total_amount&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;238.8&quot;</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># 0 表示没有更多结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 销毁游标，如果设置了 MAXIDLE 参数，则该游标在 MAXIDLE 时间内自动销毁，所以无需手工销毁</span></span><br><span class=\"line\">FT.CURSOR DEL idx:user 116452546</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AggregationResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> rSearch.aggregate(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;*&quot;</span>,</span><br><span class=\"line\">        AggregationOptions.defaults()</span><br><span class=\"line\">                .groupBy(GroupBy.fieldNames(<span class=\"string\">&quot;@status&quot;</span>)</span><br><span class=\"line\">                        .reducers(</span><br><span class=\"line\">                                Reducer.sum(<span class=\"string\">&quot;@amount&quot;</span>).as(<span class=\"string\">&quot;total_amount&quot;</span>)</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                )</span><br><span class=\"line\">                .withCursor(<span class=\"number\">2</span>, <span class=\"number\">60000</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"type\">long</span> total;</span><br><span class=\"line\"><span class=\"type\">long</span> cursorId;</span><br><span class=\"line\">List&lt;Map&lt;String, Object&gt;&gt; attributes;</span><br><span class=\"line\"></span><br><span class=\"line\">total = result.getTotal();</span><br><span class=\"line\">cursorId = result.getCursorId();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;total = &quot;</span> + total);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;cursorId = &quot;</span> + cursorId);</span><br><span class=\"line\">attributes = result.getAttributes();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map&lt;String, Object&gt; attribute : attributes) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;attribute = &quot;</span> + attribute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (cursorId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;===============================================&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 游标读取，Redisson的readCursor方法有bug，无法继续读取游标数据</span></span><br><span class=\"line\">    <span class=\"comment\">// result = rSearch.readCursor(&quot;idx:user&quot;, cursorId, 2);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里游标读取可以自己编写一个基于Lua 的实现</span></span><br><span class=\"line\">    result = readCursor(<span class=\"string\">&quot;idx:user&quot;</span>, cursorId, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    total = result.getTotal();</span><br><span class=\"line\">    cursorId = result.getCursorId();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;total = &quot;</span> + total);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;cursorId = &quot;</span> + cursorId);</span><br><span class=\"line\">    attributes = result.getAttributes();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map&lt;String, Object&gt; attribute : attributes) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;attribute = &quot;</span> + attribute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cursorId=0 或 到期 时会自动删除游标，此处无需删除</span></span><br><span class=\"line\"><span class=\"comment\">// rSearch.delCursor(&quot;idx:user&quot;, cursorId);</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AggregationResult <span class=\"title function_\">readCursor</span><span class=\"params\">(String indexName, <span class=\"type\">long</span> cursorId, <span class=\"type\">int</span> count)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;FT.CURSOR&#x27;, &#x27;READ&#x27;, KEYS[1], ARGV[1], &#x27;COUNT&#x27;, ARGV[2])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Object&gt; results = stringRedisTemplate.execute(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">            Collections.singletonList(indexName),</span><br><span class=\"line\">            String.valueOf(cursorId),</span><br><span class=\"line\">            String.valueOf(count)</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    cursorId = (<span class=\"type\">long</span>) results.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">    List&lt;Object&gt; lo = (List) results.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AggregationResult</span>(</span><br><span class=\"line\">            (<span class=\"type\">long</span>) lo.get(<span class=\"number\">0</span>),</span><br><span class=\"line\">            toListOfMap(lo),</span><br><span class=\"line\">            cursorId</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Map&lt;String, Object&gt;&gt; <span class=\"title function_\">toListOfMap</span><span class=\"params\">(List&lt;Object&gt; lo)</span> &#123;</span><br><span class=\"line\">    List&lt;Map&lt;String, Object&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo == <span class=\"literal\">null</span> || lo.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从索引 1 开始，跳过聚合总数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; lo.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">rowObj</span> <span class=\"operator\">=</span> lo.get(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(rowObj <span class=\"keyword\">instanceof</span> List&lt;?&gt; row)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; row.size() - <span class=\"number\">1</span>; j += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> String.valueOf(row.get(j));</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> row.get(j + <span class=\"number\">1</span>);</span><br><span class=\"line\">            map.put(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.add(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整生命周期总结</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.AGGREGATE ... WITHCURSOR      <span class=\"comment\"># 创建游标（并返回第一批 + cursorId）</span></span><br><span class=\"line\">        ↓</span><br><span class=\"line\">FT.CURSOR READ                  <span class=\"comment\"># 读取第 N 批</span></span><br><span class=\"line\">        ↓</span><br><span class=\"line\">FT.CURSOR READ                  <span class=\"comment\"># 继续读取</span></span><br><span class=\"line\">        ↓</span><br><span class=\"line\">FT.CURSOR DEL（可选）           <span class=\"comment\"># 提前释放资源</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>游标与 OFFSET/LIMIT 的区别</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>游标</th>\n<th>OFFSET / LIMIT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>性能</td>\n<td>高（流式）</td>\n<td>大 OFFSET 性能差</td>\n</tr>\n<tr>\n<td>适合大结果集</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>服务器状态</td>\n<td>有</td>\n<td>无</td>\n</tr>\n<tr>\n<td>适用命令</td>\n<td>FT.AGGREGATE</td>\n<td>FT.SEARCH</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"五、词典-同义词（搜索增强）\">五、词典 &amp; 同义词（搜索增强）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>词典（DICT）和同义词（SYNONYM）只对 TEXT / TAG 搜索生效</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 <code>FT.AGGREGATE</code> 无关，但与 <code>FT.SEARCH</code> 强相关。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.DICTADD</code></td>\n<td>添加词</td>\n</tr>\n<tr>\n<td><code>FT.DICTDEL</code></td>\n<td>删除词</td>\n</tr>\n<tr>\n<td><code>FT.DICTDUMP</code></td>\n<td>查看词典</td>\n</tr>\n<tr>\n<td><code>FT.SYNUPDATE</code></td>\n<td>更新同义词</td>\n</tr>\n<tr>\n<td><code>FT.SYNDUMP</code></td>\n<td>查看同义词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"词典\">词典</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>词典作用：控制“合法搜索词”，比如将词典的内容发送给用户，让用户只能搜索这些词。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">⚠️ 词典本身不参与搜索匹配</li>\n<li class=\"lvl-4\">⚠️ 只是为搜索增强提供数据来源</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例：添加商品相关词</span></span><br><span class=\"line\">FT.DICTADD product_dict iphone mobile phone android huawei</span><br><span class=\"line\"><span class=\"comment\"># 查看词典内容（FT.DICTDUMP）</span></span><br><span class=\"line\">FT.DICTDUMP product_dict</span><br><span class=\"line\"><span class=\"comment\"># 删除词典中的词（FT.DICTDEL）</span></span><br><span class=\"line\">FT.DICTDEL product_dict iphone</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.addDict(<span class=\"string\">&quot;product_dict&quot;</span>, <span class=\"string\">&quot;iphone&quot;</span>, <span class=\"string\">&quot;mobile&quot;</span>,<span class=\"string\">&quot;phone&quot;</span>,<span class=\"string\">&quot;android&quot;</span>,<span class=\"string\">&quot;huawei&quot;</span>);</span><br><span class=\"line\">List&lt;String&gt; productDict = rSearch.dumpDict(<span class=\"string\">&quot;product_dict&quot;</span>);</span><br><span class=\"line\">rSearch.delDict(<span class=\"string\">&quot;product_dict&quot;</span>, <span class=\"string\">&quot;iphone&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"同义词\">同义词</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同义词的作用: 让不同的搜索词 命中同一批文档</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如：</span><br><span class=\"line\">  搜 iphone</span><br><span class=\"line\">  搜 mobile</span><br><span class=\"line\">  搜 phone</span><br><span class=\"line\"></span><br><span class=\"line\">  👉 命中同一批订单</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加 / 更新同义词（FT.SYNUPDATE）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义“手机”的同义词集合，注意同义词是绑定到 索引 的</span></span><br><span class=\"line\">FT.SYNUPDATE idx:user</span><br><span class=\"line\">  phone_group</span><br><span class=\"line\">  iphone mobile phone</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># phone_group: 同义词集合名称（你自己定义）</span></span><br><span class=\"line\"><span class=\"comment\"># iphone mobile phone: 添加同义词，多个词用空格隔开</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看同义词集合</span></span><br><span class=\"line\">FT.SYNDUMP idx:user</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;phone&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;phone_group&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;iphone&quot;</span></span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;phone_group&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;mobile&quot;</span></span><br><span class=\"line\">6) 1) <span class=\"string\">&quot;phone_group&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rSearch.updateSynonyms(<span class=\"string\">&quot;idx:user&quot;</span>, <span class=\"string\">&quot;phone_group&quot;</span>, <span class=\"string\">&quot;iphone&quot;</span>, <span class=\"string\">&quot;mobile&quot;</span>, <span class=\"string\">&quot;phone&quot;</span>);</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; synonyms = rSearch.dumpSynonyms(<span class=\"string\">&quot;idx:user&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们再进行搜索，就会命中所有同义词</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SEARCH idx:user <span class=\"string\">&#x27;phone&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 4</span><br><span class=\"line\">2) <span class=\"string\">&quot;user:10001&quot;</span></span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Alice Bob\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;SpringCloud\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe6\\x8c\\x87\\xe5\\x8d\\x97\\&quot;,\\&quot;Shell\\xe8\\x84\\x9a\\xe6\\x9c\\xac\\xe5\\x9f\\xba\\xe7\\xa1\\x80\\&quot;]&#125;&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user:10006&quot;</span></span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Frank\\&quot;,\\&quot;age\\&quot;:27,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:499,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:129,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Redis\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;,\\&quot;MongoDB\\xe4\\xbb\\x8e\\xe5\\x85\\xa5\\xe9\\x97\\xa8\\xe5\\x88\\xb0\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;]&#125;&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;user:10002&quot;</span></span><br><span class=\"line\">7) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Bob Frank\\&quot;,\\&quot;age\\&quot;:35,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:899.0,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a iphone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Linux\\xe5\\xbf\\x85\\xe7\\x9f\\xa5\\xe5\\xbf\\x85\\xe4\\xbc\\x9a\\&quot;,\\&quot;Java\\xe5\\xa4\\x9a\\xe7\\xba\\xbf\\xe7\\xa8\\x8b\\xe8\\xaf\\xa6\\xe8\\xa7\\xa3\\&quot;]&#125;&quot;</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;user:10003&quot;</span></span><br><span class=\"line\">9) 1) <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;:\\&quot;Carol\\&quot;,\\&quot;age\\&quot;:22,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:19.9,\\&quot;status\\&quot;:\\&quot;CANCELLED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a mobile\\&quot;,\\&quot;items\\&quot;:[\\&quot;MySQL\\xe4\\xbb\\x8e\\xe5\\x88\\xa0\\xe5\\xba\\x93\\xe5\\x88\\xb0\\xe8\\xb7\\x91\\xe8\\xb7\\xaf\\&quot;,\\&quot;Oracle\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe8\\xb7\\xb5\\&quot;]&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>词典 + 同义词的组合使用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 用户输入: 手机</span><br><span class=\"line\">2. 前端 / 服务端 → 从 product_dict 给提示</span><br><span class=\"line\">3. 搜索请求 → FT.SEARCH</span><br><span class=\"line\">4. RediSearch → 同义词扩展</span><br><span class=\"line\">5. 返回统一结果</span><br></pre></td></tr></table></figure>\n<h3 id=\"六、FT-SPELLCHECK（拼写纠错）\">六、FT.SPELLCHECK（拼写纠错）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.SPELLCHECK 用于对用户输入的搜索词进行拼写纠错与相似词推荐</p>\n</li>\n<li class=\"lvl-2\">\n<p>它并不会真正执行搜索，而是：<br>\n✅ 分析输入词是否存在于索引词典<br>\n✅ 如果不存在，基于编辑距离（Levenshtein）给出候选纠错词<br>\n✅ 支持自定义词典（Dictionary）增强效果</p>\n</li>\n<li class=\"lvl-2\">\n<p>🎯 核心目标</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>拼写纠错</td>\n<td>iphone → ipohne</td>\n</tr>\n<tr>\n<td>模糊推荐</td>\n<td>用户拼错关键词</td>\n</tr>\n<tr>\n<td>搜索前置纠错</td>\n<td>提升召回率</td>\n</tr>\n<tr>\n<td>自动学习索引词</td>\n<td>自动从索引词库构建词典</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基本语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SPELLCHECK index query</span><br><span class=\"line\">  [DISTANCE maxDistance]</span><br><span class=\"line\">  [TERMS &#123;INCLUDE | EXCLUDE&#125; dictionary ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>索引名称</td>\n<td>必填</td>\n</tr>\n<tr>\n<td>query</td>\n<td>用户输入词</td>\n<td>必填</td>\n</tr>\n<tr>\n<td>DISTANCE</td>\n<td>最大编辑距离（1~4）</td>\n<td>1</td>\n</tr>\n<tr>\n<td>TERMS INCLUDE</td>\n<td>仅使用指定词典</td>\n<td>全部</td>\n</tr>\n<tr>\n<td>TERMS EXCLUDE</td>\n<td>排除指定词典</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.SPELLCHECK idx:user <span class=\"string\">&#x27;iphnoe&#x27;</span> DISTANCE 2</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) TERM         <span class=\"comment\"># 固定标识，表示这是一个被分析的词</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;iphnoe&quot;</span>     <span class=\"comment\"># 用户输入词</span></span><br><span class=\"line\">   3) 1) 1) <span class=\"string\">&quot;0.4&quot;</span>  <span class=\"comment\"># 相似度评分，越小越相似</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;iphone&quot;</span> <span class=\"comment\"># 推荐词，建议替换词</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索多个词</span></span><br><span class=\"line\">FT.SPELLCHECK idx:user <span class=\"string\">&#x27;iphnoe linu&#x27;</span> DISTANCE 2</span><br><span class=\"line\">1) 1) TERM</span><br><span class=\"line\">   2) <span class=\"string\">&quot;iphnoe&quot;</span></span><br><span class=\"line\">   3) 1) 1) <span class=\"string\">&quot;0.4&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;iphone&quot;</span></span><br><span class=\"line\">2) 1) TERM</span><br><span class=\"line\">   2) <span class=\"string\">&quot;linu&quot;</span></span><br><span class=\"line\">   3) 1) 1) <span class=\"string\">&quot;0.4&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 增加编辑距离会显示更多的候选词</span></span><br><span class=\"line\">FT.SPELLCHECK idx:user <span class=\"string\">&#x27;phnoe&#x27;</span> DISTANCE 3</span><br><span class=\"line\">1) 1) TERM</span><br><span class=\"line\">   2) <span class=\"string\">&quot;phnoe&quot;</span></span><br><span class=\"line\">   3) 1) 1) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;have&quot;</span></span><br><span class=\"line\">      2) 1) <span class=\"string\">&quot;0.8&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;phone&quot;</span></span><br><span class=\"line\">      3) 1) <span class=\"string\">&quot;0.4&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;iphone&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Map&lt;String, Double&gt;&gt; spellcheck = rSearch.spellcheck(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;iphnoe linu&quot;</span>,</span><br><span class=\"line\">        SpellcheckOptions.defaults().distance(<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>score = 编辑距离 / max(len(用户输入词), len(候选词))，但并不是总是这样</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>输入</th>\n<th>候选</th>\n<th>编辑距离</th>\n<th>maxLen</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>phnoe</td>\n<td>iphone</td>\n<td>2</td>\n<td>6</td>\n<td>2/6 = 0.333 ≈ 0.4</td>\n</tr>\n<tr>\n<td>phnoe</td>\n<td>phone</td>\n<td>1</td>\n<td>5</td>\n<td>0.2 → ~0.8（内部权重可能反转或调整）</td>\n</tr>\n<tr>\n<td>phnoe</td>\n<td>have</td>\n<td></td>\n<td></td>\n<td>“4” → 表示 phnoe 与 have 的编辑距离是 4</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">phnoe → have</span><br><span class=\"line\">p → h (1)</span><br><span class=\"line\">h → a (2)</span><br><span class=\"line\">n → v (3)</span><br><span class=\"line\">o → e (4)</span><br><span class=\"line\">e → (删除) (5)   （不同算法可能计为 4 或 5）</span><br><span class=\"line\">该词明显是低质量候选，只是 DISTANCE=3/4 时被勉强收录。</span><br><span class=\"line\"></span><br><span class=\"line\">业务侧做合理过滤</span><br><span class=\"line\">如果 score &gt;= 2     → 直接丢弃（明显噪声）</span><br><span class=\"line\">如果 score &lt;= 1.0   → 可信候选</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>建议策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索框实时提示</td>\n<td>1</td>\n</tr>\n<tr>\n<td>搜索提交后纠错</td>\n<td>2</td>\n</tr>\n<tr>\n<td>模糊容错系统</td>\n<td>2~3</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>词典增强（Dictionary Integration）</p>\n</li>\n</ul>\n<blockquote>\n<p>通过 FT.DICTADD / FT.DICTDEL 人工维护一个或多个词典，把“业务词汇”主动注入到 SpellCheck 的候选词空间中。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认情况下：</span><br><span class=\"line\">SpellCheck 只能从 索引倒排词典（Inverted Index Terms） 中生成候选词。</span><br><span class=\"line\"></span><br><span class=\"line\">如果某些词：</span><br><span class=\"line\">  不在索引里</span><br><span class=\"line\">  出现频率极低</span><br><span class=\"line\">  属于专有名词</span><br><span class=\"line\">  新词、品牌词</span><br><span class=\"line\">那么 SpellCheck 很可能无法正确纠错。</span><br><span class=\"line\"></span><br><span class=\"line\">词典增强解决的正是这个问题。</span><br><span class=\"line\"></span><br><span class=\"line\">用户输入 → Tokenizer → 拆词 →</span><br><span class=\"line\">  ↓</span><br><span class=\"line\">候选源合并：</span><br><span class=\"line\">  - 倒排索引词典</span><br><span class=\"line\">  - 自定义词典（FT.DICTADD）</span><br><span class=\"line\">  ↓</span><br><span class=\"line\">编辑距离计算</span><br><span class=\"line\">  ↓</span><br><span class=\"line\">候选排序</span><br><span class=\"line\">  ↓</span><br><span class=\"line\">返回纠错词</span><br><span class=\"line\"></span><br><span class=\"line\">✅ SpellCheck 的候选空间被人为扩大。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FT.DICTADD dict:tech iphone ipad macbook airpods</span><br><span class=\"line\"><span class=\"comment\"># 使用指定词典纠错，白名单</span></span><br><span class=\"line\">FT.SPELLCHECK idx:user <span class=\"string\">&quot;macboo&quot;</span> TERMS INCLUDE dict:tech</span><br><span class=\"line\">1) 1) TERM</span><br><span class=\"line\">   2) <span class=\"string\">&quot;macboo&quot;</span></span><br><span class=\"line\">   3) 1) 1) <span class=\"string\">&quot;0.4&quot;</span></span><br><span class=\"line\">         2) <span class=\"string\">&quot;macbook&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 排除词典，黑名单</span></span><br><span class=\"line\">FT.SPELLCHECK idx:user <span class=\"string\">&quot;iphnoe&quot;</span> TERMS EXCLUDE dict:noise</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Map&lt;String, Double&gt;&gt; spellcheck = rSearch.spellcheck(</span><br><span class=\"line\">        <span class=\"string\">&quot;idx:user&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;macboo&quot;</span>,</span><br><span class=\"line\">        SpellcheckOptions.defaults()</span><br><span class=\"line\">                .distance(<span class=\"number\">2</span>)</span><br><span class=\"line\">                .includedTerms(<span class=\"string\">&quot;dict:tech&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FT.SPELLCHECK 与 Suggest 的差异对比（关键）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>FT.SPELLCHECK</th>\n<th>FT.SUGGET</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目标</td>\n<td>拼写纠错</td>\n<td>前缀联想</td>\n</tr>\n<tr>\n<td>输入</td>\n<td>完整词</td>\n<td>前缀</td>\n</tr>\n<tr>\n<td>返回</td>\n<td>相似词</td>\n<td>补全词</td>\n</tr>\n<tr>\n<td>数据来源</td>\n<td>索引词典</td>\n<td>独立 Trie</td>\n</tr>\n<tr>\n<td>是否排序</td>\n<td>否（距离优先）</td>\n<td>是（score）</td>\n</tr>\n<tr>\n<td>是否模糊</td>\n<td>编辑距离</td>\n<td>前缀 + FUZZY</td>\n</tr>\n<tr>\n<td>使用阶段</td>\n<td>搜索前修正</td>\n<td>输入过程中</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"已废弃命令（不建议使用）\">已废弃命令（不建议使用）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FT.CONFIG GET</code></td>\n<td>Reids8 将其标记为 Deprecated</td>\n<td>使用 <code>CONFIG GET search-*</code></td>\n</tr>\n<tr>\n<td><code>FT.CONFIG SET</code></td>\n<td>Reids8 将其标记为 Deprecated</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>FT.TAGVALS</code></td>\n<td>已经标记为 Deprecated</td>\n<td>改用 AGGREGATE</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 这里要注意，只有 <code>Redis 8.0.0</code> 以上版本支持 <code>CONFIG GET search-*</code>。</p>\n</li>\n</ul>\n<h4 id=\"FT-CONFIG-GET-和-CONFIG-GET-search-对应参数整理\"><code>FT.CONFIG GET *</code> 和 <code>CONFIG GET search-*</code> 对应参数整理</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 索引基本 / 文档表配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>FT.CONFIG 参数</th>\n<th>FT.CONFIG 值</th>\n<th>CONFIG search-* 参数</th>\n<th>CONFIG 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MINPREFIX</td>\n<td>2</td>\n<td>search-min-prefix</td>\n<td>2</td>\n<td>自动补全最小前缀长度</td>\n</tr>\n<tr>\n<td>MINSTEMLEN</td>\n<td>4</td>\n<td>search-min-stem-len</td>\n<td>4</td>\n<td>最小词干长度</td>\n</tr>\n<tr>\n<td>MAXDOCTABLESIZE</td>\n<td>1000000</td>\n<td>search-max-doctablesize</td>\n<td>1000000</td>\n<td>最大文档表大小</td>\n</tr>\n<tr>\n<td>MAXSEARCHRESULTS</td>\n<td>1000000</td>\n<td>search-max-search-results</td>\n<td>1000000</td>\n<td>搜索结果限制</td>\n</tr>\n<tr>\n<td>MAXAGGREGATERESULTS</td>\n<td>unlimited</td>\n<td>search-max-aggregate-results</td>\n<td>2147483648</td>\n<td>聚合结果限制</td>\n</tr>\n<tr>\n<td>MAXEXPANSIONS</td>\n<td>200</td>\n<td>search-max-prefix-expansions</td>\n<td>200</td>\n<td>前缀扩展限制</td>\n</tr>\n<tr>\n<td>MAXPREFIXEXPANSIONS</td>\n<td>200</td>\n<td>search-max-prefix-expansions</td>\n<td>200</td>\n<td>前缀扩展限制（兼容）</td>\n</tr>\n<tr>\n<td>RAW_DOCID_ENCODING</td>\n<td>false</td>\n<td>search-raw-docid-encoding</td>\n<td>no</td>\n<td>文档ID是否原始编码</td>\n</tr>\n<tr>\n<td>UPGRADE_INDEX</td>\n<td>Upgrade config for upgrading</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>升级索引配置提示</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 查询 / 评分相关配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>FT.CONFIG 参数</th>\n<th>FT.CONFIG 值</th>\n<th>CONFIG search-* 参数</th>\n<th>CONFIG 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TIMEOUT</td>\n<td>500</td>\n<td>search-timeout</td>\n<td>500</td>\n<td>查询超时（ms）</td>\n</tr>\n<tr>\n<td>ON_TIMEOUT</td>\n<td>return</td>\n<td>search-on-timeout</td>\n<td>return</td>\n<td>超时策略</td>\n</tr>\n<tr>\n<td>DEFAULT_SCORER</td>\n<td>TFIDF</td>\n<td>search-default-scorer</td>\n<td>BM25STD</td>\n<td>默认评分算法</td>\n</tr>\n<tr>\n<td>BM25STD_TANH_FACTOR</td>\n<td>4</td>\n<td>search-bm25std-tanh-factor</td>\n<td>4</td>\n<td>BM25 调整因子</td>\n</tr>\n<tr>\n<td>MULTI_TEXT_SLOP</td>\n<td>100</td>\n<td>search-multi-text-slop</td>\n<td>100</td>\n<td>多字段查询 slop</td>\n</tr>\n<tr>\n<td>DEFAULT_DIALECT</td>\n<td>1</td>\n<td>search-default-dialect</td>\n<td>1</td>\n<td>查询方言</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ GC / 后台索引配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>FT.CONFIG 参数</th>\n<th>FT.CONFIG 值</th>\n<th>CONFIG search-* 参数</th>\n<th>CONFIG 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NOGC</td>\n<td>false</td>\n<td>search-no-gc</td>\n<td>no</td>\n<td>禁用 GC</td>\n</tr>\n<tr>\n<td>GC_POLICY</td>\n<td>fork</td>\n<td>search-fork-gc-policy (implicit)</td>\n<td>fork</td>\n<td>GC 策略</td>\n</tr>\n<tr>\n<td>FORKGC_SLEEP_BEFORE_EXIT</td>\n<td>0</td>\n<td>search-fork-gc-sleep-before-exit</td>\n<td>0</td>\n<td>fork GC 退出前睡眠</td>\n</tr>\n<tr>\n<td>FORK_GC_RUN_INTERVAL</td>\n<td>30</td>\n<td>search-fork-gc-run-interval</td>\n<td>30</td>\n<td>fork GC 执行间隔（秒）</td>\n</tr>\n<tr>\n<td>FORK_GC_CLEAN_THRESHOLD</td>\n<td>100</td>\n<td>search-fork-gc-clean-threshold</td>\n<td>100</td>\n<td>fork GC 清理阈值</td>\n</tr>\n<tr>\n<td>FORK_GC_RETRY_INTERVAL</td>\n<td>5</td>\n<td>search-fork-gc-retry-interval</td>\n<td>5</td>\n<td>fork GC 重试间隔</td>\n</tr>\n<tr>\n<td>FORK_GC_CLEAN_NUMERIC_EMPTY_NODES</td>\n<td>true</td>\n<td>search-_numeric-compress</td>\n<td>no</td>\n<td>清理空数值节点</td>\n</tr>\n<tr>\n<td>GCSCANSIZE</td>\n<td>100</td>\n<td>search-gc-scan-size</td>\n<td>100</td>\n<td>GC 每次扫描大小</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4️⃣ 游标 / 线程 / 并发配置</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>FT.CONFIG 参数</th>\n<th>FT.CONFIG 值</th>\n<th>CONFIG search-* 参数</th>\n<th>CONFIG 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CURSOR_MAX_IDLE</td>\n<td>300000</td>\n<td>search-cursor-max-idle</td>\n<td>300000</td>\n<td>游标最大空闲时间</td>\n</tr>\n<tr>\n<td>INDEX_CURSOR_LIMIT</td>\n<td>128</td>\n<td>search-index-cursor-limit</td>\n<td>128</td>\n<td>单索引游标限制</td>\n</tr>\n<tr>\n<td>UNION_ITERATOR_HEAP</td>\n<td>20</td>\n<td>search-union-iterator-heap</td>\n<td>20</td>\n<td>UNION 查询堆大小</td>\n</tr>\n<tr>\n<td>NO_MEM_POOLS</td>\n<td>false</td>\n<td>search-no-mem-pools</td>\n<td>no</td>\n<td>禁用内存池</td>\n</tr>\n<tr>\n<td>_FREE_RESOURCE_ON_THREAD</td>\n<td>true</td>\n<td>search-_free-resource-on-thread</td>\n<td>yes</td>\n<td>线程释放资源</td>\n</tr>\n<tr>\n<td>search_min_operation_workers</td>\n<td>N/A</td>\n<td>search-min-operation-workers</td>\n<td>4</td>\n<td>最小操作线程数</td>\n</tr>\n<tr>\n<td>search-workers</td>\n<td>N/A</td>\n<td>search-workers</td>\n<td>0</td>\n<td>工作线程数</td>\n</tr>\n<tr>\n<td>search-workers-priority-bias-threshold</td>\n<td>N/A</td>\n<td>search-workers-priority-bias-threshold</td>\n<td>1</td>\n<td>线程优先级偏置</td>\n</tr>\n<tr>\n<td>INDEXER_YIELD_EVERY_OPS</td>\n<td>1000</td>\n<td>search-indexer-yield-every-ops</td>\n<td>1000</td>\n<td>索引器 yield 每操作数</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5️⃣ 实验 / 内部 /其他</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>FT.CONFIG 参数</th>\n<th>FT.CONFIG 值</th>\n<th>CONFIG search-* 参数</th>\n<th>CONFIG 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EXTLOAD</td>\n<td>nil</td>\n<td>search-ext-load</td>\n<td>“”</td>\n<td>外部加载模块</td>\n</tr>\n<tr>\n<td>FRISOINI</td>\n<td>nil</td>\n<td>search-friso-ini</td>\n<td>“”</td>\n<td>中文分词初始化</td>\n</tr>\n<tr>\n<td>ENABLE_UNSTABLE_FEATURES</td>\n<td>false</td>\n<td>search-enable-unstable-features</td>\n<td>no</td>\n<td>启用实验特性</td>\n</tr>\n<tr>\n<td>_PRINT_PROFILE_CLOCK</td>\n<td>true</td>\n<td>search-_print-profile-clock</td>\n<td>yes</td>\n<td>Profiling 开关</td>\n</tr>\n<tr>\n<td>_NUMERIC_RANGES_PARENTS</td>\n<td>0</td>\n<td>search-_numeric-ranges-parents</td>\n<td>0</td>\n<td>数值范围父节点数</td>\n</tr>\n<tr>\n<td>VSS_MAX_RESIZE</td>\n<td>0</td>\n<td>search-vss-max-resize</td>\n<td>1024</td>\n<td>向量索引最大重分配</td>\n</tr>\n<tr>\n<td>PARTIAL_INDEXED_DOCS</td>\n<td>false</td>\n<td>search-partial-indexed-docs</td>\n<td>no</td>\n<td>部分索引文档标记</td>\n</tr>\n<tr>\n<td>_PRIORITIZE_INTERSECT_UNION_CHILDREN</td>\n<td>false</td>\n<td>search-_prioritize-intersect-union-children</td>\n<td>no</td>\n<td>优先处理 INTERSECT/UNION 子节点</td>\n</tr>\n<tr>\n<td>_BG_INDEX_MEM_PCT_THR</td>\n<td>100</td>\n<td>search-_bg-index-mem-pct-thr</td>\n<td>100</td>\n<td>后台索引内存阈值</td>\n</tr>\n<tr>\n<td>_NUMERIC_COMPRESS</td>\n<td>false</td>\n<td>search-_numeric-compress</td>\n<td>no</td>\n<td>数值压缩</td>\n</tr>\n<tr>\n<td>_BG_INDEX_OOM_PAUSE_TIME</td>\n<td>0</td>\n<td>search-_bg-index-oom-pause-time</td>\n<td>0</td>\n<td>后台索引 OOM 暂停时间</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RediSearch 的使用方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RediSearch 的安装参见 Redis 扩展模块 -- RediSearch 的安装方法 示例代码：GitHub RediSearch 命令 为了展示命令的使用方法，这里以JSON文档进行索引，初始化数据如下： 1234567891011121314151617181920JSON.SET user:10001 $ &#x27;&#123;&quot;name&quot;:&quot;Alice Bob&quot;,&quot;age&quot;:28,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:59.9,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a phone&quot;,&quot;items&quot;:[&quot;SpringCloud技术指南&quot;,&quot;Shell脚本基础&quot;]&#125;&#x27;JSON.SET user:10002 $ &#x27;&#123;&quot;name&quot;:&quot;Bob Frank&quot;,&quot;age&quot;:35,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:899.0,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a iphone&quot;,&quot;items&quot;:[&quot;Linux必知必会&quot;,&quot;Java多线程详解&quot;]&#125;&#x27;JSON.SET user:10003 $ &#x27;&#123;&quot;name&quot;:&quot;Carol&quot;,&quot;age&quot;:22,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:19.9,&quot;status&quot;:&quot;CANCELLED&quot;&#125;],&quot;comment&quot;: &quot;I have a mobile&quot;,&quot;items&quot;:[&quot;MySQL从删库到跑路&quot;,&quot;Oracle开发实践&quot;]&#125;&#x27;JSON.SET user:10004 $ &#x27;&#123;&quot;name&quot;:&quot;David Bob&quot;,&quot;age&quot;:41,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:1200,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:300,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a car&quot;,&quot;items&quot;:[&quot;Spring技术指南&quot;,&quot;RocketMQ由浅入深&quot;]&#125;&#x27;JSON.SET user:10005 $ &#x27;&#123;&quot;name&quot;:&quot;Eve&quot;,&quot;age&quot;:30,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:88.8,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a pencil&quot;,&quot;items&quot;:[&quot;Kafka从零开始&quot;,&quot;Java由浅入深&quot;]&#125;&#x27;JSON.SET user:10006 $ &#x27;&#123;&quot;name&quot;:&quot;Frank&quot;,&quot;age&quot;:27,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:499,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:129,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a phone&quot;,&quot;items&quot;:[&quot;Redis开发实战&quot;,&quot;MongoDB从入门到实战&quot;]&#125;&#x27;JSON.SET user:10007 $ &#x27;&#123;&quot;name&quot;:&quot;Grace&quot;,&quot;age&quot;:33,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:999.9,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a book&quot;,&quot;items&quot;:[&quot;Android开发手册&quot;,&quot;Gradle从零开始&quot;]&#125;&#x27;JSON.SET user:10008 $ &#x27;&#123;&quot;name&quot;:&quot;Henry&quot;,&quot;age&quot;:45,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:59.9,&quot;status&quot;:&quot;CANCELLED&quot;&#125;],&quot;comment&quot;: &quot;I have a macbook&quot;,&quot;items&quot;:[&quot;SpringBoot技术指南&quot;,&quot;Maven由浅入深&quot;]&#125;&#x27;JSON.SET user:10009 $ &#x27;&#123;&quot;name&quot;:&quot;Ivy&quot;,&quot;age&quot;:26,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:299,&quot;status&quot;:&quot;PAID&quot;&#125;,&#123;&quot;amount&quot;:199,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;: &quot;I have a watch&quot;,&quot;items&quot;:[&quot;Spring融会贵通&quot;,&quot;Java技术开发指南&quot;]&#125;&#x27;JSON.SET user:10010 $ &#x27;&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:38,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:150,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;: &quot;I have a apple&quot;,&quot;items&quot;:[&quot;Spring技术指南&quot;,&quot;Java由浅入深&quot;]&#125;&#x27; SpringBoot暂时没有支持 RediSearch ，你可以编写Lua脚本来实现相应的功能，另外 Redisson已经提供了对 RediSearch 的支持，下面结合命令给出代码示例。 123456&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.52.0&lt;/version&gt;&lt;/dependency&gt; 通用代码 1234@Autowiredprivate RedissonClient redissonClient;RSearch rSearch = redissonClient.getSearch(StringCodec.INSTANCE); 一、索引生命周期管理类 命令 作用 核心参数 示例 FT.CREATE 创建索引 索引名、ON、PREFIX、SCHEMA 见下 FT.ALTER 给已有索引新增字段 索引名、SCHEMA ADD 见下 FT.DROPINDEX 删除索引 索引名、DD 见下 FT.INFO 查看索引信息 索引名 见下 FT._LIST 列出所有索引 无 见下 1️⃣ FT.CREATE FT.CREATE 基本语法 123456789101112131415161718FT.CREATE index_name[ON HASH | JSON][PREFIX count prefix ...][FILTER filter][LANGUAGE default_lang][LANGUAGE_FIELD lang_attribute][SCORE default_score][SCORE_FIELD score_attribute][PAYLOAD_FIELD payload_attribute][MAXTEXTFIELDS][TEMPORARY seconds][NOOFFSETS] [NOHL] [NOFIELDS] [NOFREQS][STOPWORDS count stopword ...][SKIPINITIALSCAN]SCHEMA field_name [AS alias] TEXT | TAG | NUMERIC | GEO | VECTOR [SORTABLE [UNF]] [NOINDEX] FT.CREATE 参数说明表 参数 作用说明 index_name 索引名称 ON HASH | JSON 指定索引数据来源类型，默认 HASH PREFIX count prefix... 指定索引 Key 前缀 FILTER filter 对索引数据设置过滤表达式 LANGUAGE 指定默认分词语言（默认 english，中文是 chinese） LANGUAGE_FIELD 指定文档中的语言字段 SCORE 设置文档默认评分 SCORE_FIELD 从字段中读取评分 PAYLOAD_FIELD 指定存储的二进制负载字段 MAXTEXTFIELDS 允许更多 TEXT 字段（消耗更多内存） TEMPORARY seconds 创建临时索引，超时后自动删除 NOOFFSETS 不存储文本偏移量（节省内存） NOHL 禁用高亮 NOFIELDS 不保存字段内容 NOFREQS 不保存词频信息 STOPWORDS count ... 指定停用词 SKIPINITIALSCAN 创建索引时不扫描已有数据 SCHEMA 索引字段定义起始 AS alias 字段别名 TEXT 全文索引字段 TAG 精确匹配字段 NUMERIC 数值字段 GEO 地理位置字段 VECTOR 向量字段 SORTABLE 允许排序 UNF 不规范化排序 NOINDEX 字段不参与索引 FT.CREATE 的核心语法 123456FT.CREATE &lt;index&gt;[ON HASH | JSON][PREFIX count prefix ...][LANGUAGE default_lang]SCHEMA field_name [AS alias] TEXT | TAG | NUMERIC | GEO | VECTOR 创建索引示例 12345678910111213141516171819202122FT.CREATE idx:user ON JSON PREFIX 1 user: LANGUAGE chinese SCHEMA $.name AS name TEXT $.age AS age NUMERIC SORTABLE $.orders[*].amount AS amount NUMERIC $.orders[*].status AS status TAG $.comment AS comment TEXT $.items[*] AS items TEXT# 参数说明 # idx:user：索引名 # ON JSON：索引 JSON 文档，RediSearch 仅支持对 HASH 和 JSON 进行索引 # PREFIX 1 user: ：索引指定 key 前缀，1 表示索引一个，user: 表示索引的 key 前缀，如果索引两个：PREFIX 2 user: order: # LANGUAGE chinese：指定默认分词语言，默认是英文 english，中文是 chinese，如果索引中有中文，则必须指定 LANGUAGE 为 chinese # SCHEMA：索引字段 # $.name AS name TEXT：索引字段 $.name(注意：JSON类型以 $. 开头，Hash类型就不需要了)，字段别名为 name，字段类型为 TEXT # AS：字段别名（查询时使用） # TEXT / NUMERIC / TAG：字段类型，这几个是最常用的 # SORTABLE：NUMERIC、TAG、TEXT 或 GEO 类型的字段可以带有一个可选的 SORTABLE 参数，表示为字段建立专门的排序数据结构（类似列式存储），从而避免在查询阶段对大量结果进行临时排序。 12345678910111213rSearch.createIndex( &quot;idx:user&quot;, IndexOptions.defaults() .on(IndexType.JSON) .prefix(List.of(&quot;user:&quot;)) .language(&quot;chinese&quot;), FieldIndex.text(&quot;$.name&quot;).as(&quot;name&quot;), FieldIndex.numeric(&quot;$.age&quot;).as(&quot;age&quot;), FieldIndex.numeric(&quot;$.orders[*].amount&quot;).as(&quot;amount&quot;), FieldIndex.tag(&quot;$.orders[*].status&quot;).as(&quot;status&quot;), FieldIndex.text(&quot;$.comment&quot;).as(&quot;comment&quot;), FieldIndex.text(&quot;$.items[*]&quot;).as(&quot;items&quot;)); 索引字段的类型 字段类型 中文名称 功能说明 典型使用场景 备注 / 限制 TEXT 全文文本字段 支持对字段值进行全文检索（分词、相关度计算、模糊匹配等） 文章内容、用户名、描述信息 支持权重（WEIGHT）、排序（SORTABLE）等选项 TAG 标签字段 / 精确匹配字段 支持精确匹配查询，适用于枚举值或离散分类 分类、状态、主键、类型字段 不分词；可自定义分隔符 NUMERIC 数值字段 支持数值范围查询 年龄、价格、分数、时间戳 支持区间查询（[min max]） GEO 地理位置字段（点） 支持以“点”为中心的半径范围查询 门店位置、用户位置 值格式必须为 &quot;经度,纬度&quot; VECTOR 向量字段 支持向量相似度搜索（KNN 等） 语义搜索、推荐系统、Embedding 向量 需要 Query Dialect ≥ 2（RediSearch ≥ 2.4） GEOSHAPE 地理形状字段（多边形） 支持多边形空间查询 行政区、商圈、地图区域 使用 WKT 格式；不支持 JSON 多值和 SORTABLE GEOSHAPE 字段补充说明 项目 说明 数据格式 WKT（Well-Known Text）格式，如：POLYGON((x1 y1, x2 y2, ...)) 坐标系统 SPHERICAL（球面坐标，经纬度）FLAT（平面坐标，笛卡尔 X/Y） 默认坐标系统 SPHERICAL 当前限制 ❌ 不支持 JSON 多值❌ 不支持 SORTABLE 选项 索引字段类型选型建议 使用场景 推荐字段类型 说明 全文检索 TEXT 支持分词、相关度计算、模糊匹配等全文搜索能力 精确过滤 / 分类 TAG 精确匹配，不分词，适合枚举值、状态、类型等字段 区间筛选 / 排序 NUMERIC 支持数值区间查询与排序，适合价格、时间、分数等 附近的人 / 门店 GEO 基于经纬度点进行半径范围查询 语义搜索 / 向量召回 VECTOR 基于向量相似度（KNN）的语义搜索，需要 Dialect ≥ 2 复杂地理区域判断 GEOSHAPE 支持多边形（Polygon）区域查询，适合行政区、商圈等 哪些字段适合使用 SORTABLE 字段类型 是否适合 SORTABLE 原因 NUMERIC ✅ 强烈推荐 数值排序最常见，如价格、时间、评分 TAG ⚠️ 视情况 一般用于过滤，排序意义不大 TEXT ⚠️ 谨慎 文本可能很大，内存开销高 GEO ⚠️ 特殊场景 通常按距离排序，更多依赖 GEOFILTER 小贴士：如何在redis终端输入多行的命令？ 先说结论：redis终端 不支持多行输入，但可以通过如下方式输入多行命令： 123456redis-cli &lt;&lt;EOFHSET user:1 \\name Tom \\age 18 \\city BeijingEOF 这种方法是利用了 Bash 的能力，即 &lt;&lt;EOF 后面的内容会作为标准输入，直到 EOF 为止，并通过 \\ 符换行。 如果在VSCode中，可以选中要合并的多行内容，然后通过 Ctrl + Shift + J 快捷键将多行合并到一行。 2️⃣ FT.ALTER ⚠️ 只能 新增字段，不能修改或删除已有字段 1FT.ALTER idx:user SCHEMA ADD $.vip AS vip TAG 12345rSearch.alter( &quot;idx:user&quot;, false, FieldIndex.tag(&quot;$.vip&quot;).as(&quot;vip&quot;)); 3️⃣ FT.DROPINDEX ⚠️ 删除索引 123FT.DROPINDEX idx:user# ⚠️ DD：删除索引的同时删除被索引数据，谨慎使用FT.DROPINDEX idx:user DD 12rSearch.dropIndex(&quot;idx:user&quot;);rSearch.dropIndexAndDocuments(&quot;idx:user&quot;); 4️⃣ FT.INFO 查看索引信息 1FT.INFO idx:user 1IndexInfo info = rSearch.info(&quot;idx:user&quot;); 重点关注字段 字段 含义 解释 num_docs 当前被索引、可被搜索的文档数量 user:10001 ~ user:10010，10条文档 num_terms 词典中唯一词项 term 的数量主要来源于 TEXT（name） 和 TAG（vip, status） 字段去重之后的数量 name: alice, bob, carol, …vip: yes, nostatus: PAID, CREATED, CANCELLED num_records 倒排索引中的记录条目总数所有 term 在所有文档中的出现次数之和 JSON 数组字段 orders[],每个 order 都会生成独立的索引 entry多值字段 × 多文档 = record 爆炸式增长num_records 真正影响：内存、查询速度、聚合成本 5️⃣ FT._LIST 列出所有索引 1FT._LIST 1List&lt;String&gt; indexes = rSearch.getIndexes(); 二、查询类（核心） 命令 作用 适用场景 FT.SEARCH 标准搜索 90% 场景 FT.AGGREGATE 分组 / 统计 / 聚合 报表、分析 FT.HYBRID 文本 + 向量混合 向量搜索 FT.EXPLAIN 查询执行计划 调优 FT.EXPLAINCLI CLI 可读执行计划 调试 FT.PROFILE 性能分析 慢查询 1️⃣ FT.SEARCH FT.SEARCH 基本语法 1234567891011121314151617181920FT.SEARCH index query[NOCOENTENT] [VERBATIM] [NOSTOPWORDS][WITHSCORES] [WITHPAYLOADS] [WITHSORTKEYS][FILTER numeric_field min max ...][GEOFILTER geo_field lon lat radius m|km|mi|ft][INKEYS count key ...][INFIELDS count field ...][RETURN count identifier [AS property] ...][SUMMARIZE FIELDS count field ... FRAGS num LEN fragsize SEPARATOR sep][HIGHLIGHT FIELDS count field ... TAGS open close][SLOP slop] [TIMEOUT timeout] [INORDER][LANGUAGE language][EXPANDER expander][SCORER scorer][EXPLAINSCORE][PAYLOAD payload][SORTBY sortby ASC|DESC][LIMIT offset num][PARAMS nargs name value ...][DIALECT dialect] FT.SEARCH 参数说明表 参数 作用说明 index 索引名称 query 查询条件（类似 SQL WHERE） NOCONTENT 仅返回文档 ID，不返回内容 VERBATIM 禁用查询优化，完全按原查询执行 NOSTOPWORDS 查询时不忽略停用词 WITHSCORES 返回匹配文档的相关性评分 WITHPAYLOADS 返回文档的 payload 数据 WITHSORTKEYS 返回排序使用的 key FILTER 数值字段过滤（范围查询） GEOFILTER 地理位置范围查询 INKEYS 仅在指定的 key 集合中搜索 INFIELDS 仅在指定字段中搜索 RETURN 指定返回的字段 SUMMARIZE 返回字段内容摘要 HIGHLIGHT 高亮匹配的关键词 SLOP 设置短语查询中允许的词距 TIMEOUT 设置查询超时时间 INORDER 短语必须按顺序匹配 LANGUAGE 指定查询语言 EXPANDER 使用自定义查询扩展器 SCORER 使用自定义评分函数 EXPLAINSCORE 返回评分计算详情 PAYLOAD 给评分函数传入自定义参数 SORTBY 按指定字段排序 ASC / DESC 排序方向 LIMIT 分页控制 PARAMS 参数化查询 DIALECT 指定查询语法版本 FT.SEARCH 核心语法 12345FT.SEARCH indexquery[RETURN count identifier [AS property] ...][SORTBY sortby ASC|DESC][LIMIT offset num] 标准搜索 1234567891011121314151617FT.SEARCH idx:user &#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27; RETURN 3 name status amount SORTBY amount DESC LIMIT 0 10## 参数说明 # 查询条件：&#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27; # 查询条件语法： # &#x27;xxx&#x27;: 全文检索包含 xxx 的数据，会从 TEXT 字段中匹配 # &#x27;@field:value&#x27;: 匹配字段 field 的值是 value，要求 field 的类型为 TEXT，全文检索 # &#x27;@field:&#123;xxx&#125;&#x27;:精确匹配，&#123;xxx*&#125;:匹配前缀，&#123;xxx|yyy&#125;:匹配任意一个，要求 field 的类型为 TAG # &#x27;@field:[min max]&#x27;: 范围匹配，这里 +inf 表示正无穷大，要求 field 的类型为 NUMERIC # 多个条件空格分隔 # 模糊匹配：* 表示任意字符，即匹配所有# RETURN 3 name status amount 返回字段，3:表示返回 3 个字段# LIMIT 0 10 分页，0:表示从第 0 条开始，10:表示返回 10 条数据# SORTBY amount DESC 排序，amount:表示排序字段，DESC:表示降序 123456789101112131415161718SearchResult result = rSearch.search( &quot;idx:user&quot;, &quot;@status:&#123;PAID&#125; @amount:[50 +inf]&quot;, QueryOptions.defaults() .returnAttributes(new ReturnAttribute(&quot;name&quot;), new ReturnAttribute(&quot;status&quot;),new ReturnAttribute(&quot;amount&quot;)) .sortBy(&quot;amount&quot;) .sortOrder(SortOrder.DESC) .limit(0, 10));long total = result.getTotal();System.out.println(&quot;total = &quot; + total);List&lt;Document&gt; docs = result.getDocuments();for (Document doc: docs) &#123; String id = doc.getId(); Map&lt;String, Object&gt; attrs = doc.getAttributes(); System.out.println(&quot;id = &quot; + id + &quot; attrs = &quot; + attrs);&#125; 12345678910# 全文检索，从 所有 TEXT 字段中匹配，不区分大小写，即 phone/Phone/PHONE 都匹配FT.SEARCH idx:user &#x27;phone&#x27;## 示例结果1) (integer) 22) &quot;user:10006&quot;3) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Frank\\&quot;,\\&quot;age\\&quot;:27,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:499,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:129,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Redis\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;,\\&quot;MongoDB\\xe4\\xbb\\x8e\\xe5\\x85\\xa5\\xe9\\x97\\xa8\\xe5\\x88\\xb0\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;]&#125;&quot;4) &quot;user:10001&quot;5) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Alice Bob\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;SpringCloud\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe6\\x8c\\x87\\xe5\\x8d\\x97\\&quot;,\\&quot;Shell\\xe8\\x84\\x9a\\xe6\\x9c\\xac\\xe5\\x9f\\xba\\xe7\\xa1\\x80\\&quot;]&#125;&quot; 12345SearchResult result = rSearch.search( &quot;idx:user&quot;, &quot;phone&quot;, QueryOptions.defaults()); 12345678910# 中文检索FT.SEARCH idx:user &#x27;开始&#x27;## 示例结果1) (integer) 22) &quot;user:10005&quot;3) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Eve\\&quot;,\\&quot;age\\&quot;:30,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:88.8,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a pencil\\&quot;,\\&quot;items\\&quot;:[\\&quot;Kafka\\xe4\\xbb\\x8e\\xe9\\x9b\\xb6\\xe5\\xbc\\x80\\xe5\\xa7\\x8b\\&quot;,\\&quot;Java\\xe7\\x94\\xb1\\xe6\\xb5\\x85\\xe5\\x85\\xa5\\xe6\\xb7\\xb1\\&quot;]&#125;&quot;4) &quot;user:10007&quot;5) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Grace\\&quot;,\\&quot;age\\&quot;:33,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:999.9,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a book\\&quot;,\\&quot;items\\&quot;:[\\&quot;Android\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe6\\x89\\x8b\\xe5\\x86\\x8c\\&quot;,\\&quot;Gradle\\xe4\\xbb\\x8e\\xe9\\x9b\\xb6\\xe5\\xbc\\x80\\xe5\\xa7\\x8b\\&quot;]&#125;&quot; 12345SearchResult result = rSearch.search( &quot;idx:user&quot;, &quot;开始&quot;, QueryOptions.defaults()); 小贴士 看到中文输出是乱码，可以在登录客户端时加上 --raw 123456789redis-cli --user admin -a 123456 --raw127.0.0.1:6379&gt; FT.SEARCH idx:user &#x27;开始&#x27;2user:10005$&#123;&quot;name&quot;:&quot;Eve&quot;,&quot;age&quot;:30,&quot;vip&quot;:&quot;no&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:88.8,&quot;status&quot;:&quot;CREATED&quot;&#125;],&quot;comment&quot;:&quot;I have a pencil&quot;,&quot;items&quot;:[&quot;Kafka从零开始&quot;,&quot;Java由浅入深&quot;]&#125;user:10007$&#123;&quot;name&quot;:&quot;Grace&quot;,&quot;age&quot;:33,&quot;vip&quot;:&quot;yes&quot;,&quot;orders&quot;:[&#123;&quot;amount&quot;:999.9,&quot;status&quot;:&quot;PAID&quot;&#125;],&quot;comment&quot;:&quot;I have a book&quot;,&quot;items&quot;:[&quot;Android开发手册&quot;,&quot;Gradle从零开始&quot;]&#125; SQL WHERE 与 RediSearch 查询语法对照表 x/y/name → TEXT/TAG(要加上&#123;&#125;) 字段，num→NUMERIC 字段，查询语法用于 FT.SEARCH/FT.AGGREGATE 的查询字符串部分 ID SQL 条件 RediSearch 对等写法 说明 1 WHERE x = 'book' AND y = 'phone' @x:book @y:phone AND 为默认关系（空格） 2 WHERE x = 'book' AND y != 'phone' @x:book -@y:phone - 表示 NOT 3 WHERE x = 'book' OR y = 'phone' (@x:book) | (@y:phone) OR 必须显式写 | 4 WHERE x IN ('book','phone','hello world') @x:(book|phone|&quot;hello world&quot;) 多值 OR，短语需加引号 5 WHERE y='book' AND x NOT IN ('book','phone') @y:book -(@x:book|@x:phone) NOT IN = NOT + OR 6 WHERE x NOT IN ('book','phone') -@x:(book|phone) 整体否定 7 WHERE num BETWEEN 10 AND 20 @num:[10 20] 数值区间（闭区间） 8 WHERE num &gt;= 10 @num:[10 +inf] +inf 表示正无穷 9 WHERE num &gt; 10 @num:[(10 +inf] ( 表示不包含 10 WHERE num &lt; 10 @num:[-inf (10] 小于（不含 10） 11 WHERE num &lt;= 10 @num:[-inf 10] 小于等于 12 WHERE num &lt; 10 OR num &gt; 20 @num:[-inf (10] | @num:[(20 +inf] 数值 OR 13 WHERE name LIKE 'Li%' @name:Li* 前缀匹配 2️⃣ FT.AGGREGATE 分组 / 统计 / 聚合，语法 FT.AGGREGATE 基本语法 1234567891011121314FT.AGGREGATE index query[VERBATIM][LOAD count field ... | LOAD *][TIMEOUT timeout][GROUPBY nargs property ... REDUCE function nargs arg ... [AS name] ...][SORTBY nargs property ASC|DESC ... [MAX num]][APPLY expression AS name][LIMIT offset num][FILTER filter][WITHCURSOR [COUNT read_size]][MAXIDLE idle_time][PARAMS nargs name value ...][DIALECT dialect] FT.AGGREGATE 参数说明表 参数 作用说明 index 索引名称 query 查询条件（类似 WHERE） VERBATIM 禁用查询优化 LOAD 加载原始字段 TIMEOUT 查询超时时间 GROUPBY 分组字段（类似 SQL GROUP BY） REDUCE 聚合函数（COUNT / SUM / AVG / MIN / MAX 等） AS 聚合结果别名 SORTBY 对聚合结果排序 ASC / DESC 排序方向 MAX 最大返回条数 APPLY 对结果字段进行表达式计算 LIMIT 分页控制 FILTER 结果过滤（WHERE / HAVING） WITHCURSOR 使用游标（大结果集） COUNT 每次读取数量 MAXIDLE 游标最大空闲时间 PARAMS 参数化查询 DIALECT 查询语法版本 FT.AGGREGATE 的核心语法 12345FT.AGGREGATE &lt;index&gt; &lt;query&gt; [GROUPBY ...] [REDUCE ...] [SORTBY ...] [LIMIT ...] 示例 1：按 status 分组统计数量 1234567891011121314151617181920212223242526272829303132FT.AGGREGATE idx:user &#x27;*&#x27; GROUPBY 1 @status REDUCE COUNT 0 AS cnt## 参数说明# *: 查询条件，* 表示匹配索引中的 所有文档，也可以是 FT.SEARCH 中的查询条件，比如：&#x27;@status:&#123;PAID&#125; @amount:[50 +inf]&#x27;# GROUPBY 1 @status: 分组字段 # 1:表示分组字段数量 # @status:表示分组字段# REDUCE COUNT 0 AS cnt: 聚合字段 # COUNT:聚合函数：计数 # 0:参数个数（COUNT 不需要参数） # AS cnt:表示聚合字段别名## 返回结果示例1) (integer) 32) 1) &quot;status&quot; 2) &quot;CANCELLED&quot; 3) &quot;cnt&quot; 4) &quot;2&quot;3) 1) &quot;status&quot; 2) &quot;PAID&quot; 3) &quot;cnt&quot; 4) &quot;6&quot;4) 1) &quot;status&quot; 2) &quot;CREATED&quot; 3) &quot;cnt&quot; 4) &quot;2&quot;# 对应SQL 语句：SELECT status, COUNT(*) AS cnt FROM user GROUP BY status; 123456789101112AggregationResult result = rSearch.aggregate( &quot;idx:user&quot;, &quot;*&quot;, AggregationOptions.defaults() .groupBy(GroupBy.fieldNames(&quot;@status&quot;).reducers(Reducer.count().as(&quot;cnt&quot;))));final long total = result.getTotal();System.out.println(&quot;total = &quot; + total);final List&lt;Map&lt;String, Object&gt;&gt; attributes = result.getAttributes();for (Map&lt;String, Object&gt; attribute : attributes) &#123; System.out.println(&quot;attribute = &quot; + attribute);&#125; 示例 2：按 status 分组统计金额总和 12345678910111213141516171819202122232425262728293031323334353637FT.AGGREGATE idx:user &#x27;*&#x27; GROUPBY 1 @status REDUCE SUM 1 @amount AS total_amount SORTBY 2 @total_amount DESC LIMIT 0 3## 参数说明# SUM:聚合函数：求和# 1:参数个数# @amount:要参与求和的字段# total_amount:表示聚合字段别名# SORTBY 2 @total_amount DESC: 排序 # 2: 表示后面跟 2 个参数（字段 + 排序方向） # @total_amount: 表示排序字段（REDUCE 产生的别名），DESC:表示降序# LIMIT 0 3: 分页，0:表示从第 0 条开始，3:表示返回 3 条数据## 示例结果1) (integer) 32) 1) &quot;status&quot; 2) &quot;PAID&quot; 3) &quot;total_amount&quot; 4) &quot;4096.89&quot;3) 1) &quot;status&quot; 2) &quot;CREATED&quot; 3) &quot;total_amount&quot; 4) &quot;238.8&quot;4) 1) &quot;status&quot; 2) &quot;CANCELLED&quot; 3) &quot;total_amount&quot; 4) &quot;79.8&quot;# 对应SQL 语句：SELECT status, SUM(amount) AS total_amount FROM user GROUP BY status ORDER BY total_amount DESC LIMIT 0 3; 123456789101112AggregationResult result = rSearch.aggregate( &quot;idx:user&quot;, &quot;*&quot;, AggregationOptions.defaults() .groupBy(GroupBy.fieldNames(&quot;@status&quot;) .reducers( Reducer.sum(&quot;@amount&quot;).as(&quot;total_amount&quot;) ) ) .sortBy(new SortedField(&quot;@total_amount&quot;, SortOrder.DESC)) .limit(0, 3)); 示例 3：同时输出数量 + 金额，并按金额降序，数量升序 1234567891011121314151617181920212223242526FT.AGGREGATE idx:user &#x27;*&#x27; GROUPBY 1 @status REDUCE COUNT 0 AS cnt REDUCE SUM 1 @amount AS total_amount SORTBY 4 @total_amount DESC @cnt ASC## 示例结果1) (integer) 32) 1) &quot;status&quot; 2) &quot;PAID&quot; 3) &quot;cnt&quot; 4) &quot;6&quot; 5) &quot;total_amount&quot; 6) &quot;4096.89&quot;3) 1) &quot;status&quot; 2) &quot;CREATED&quot; 3) &quot;cnt&quot; 4) &quot;2&quot; 5) &quot;total_amount&quot; 6) &quot;238.8&quot;4) 1) &quot;status&quot; 2) &quot;CANCELLED&quot; 3) &quot;cnt&quot; 4) &quot;2&quot; 5) &quot;total_amount&quot; 6) &quot;79.8&quot; 12345678910111213AggregationResult result = rSearch.aggregate( &quot;idx:user&quot;, &quot;*&quot;, AggregationOptions.defaults() .groupBy(GroupBy.fieldNames(&quot;@status&quot;) .reducers( Reducer.count().as(&quot;cnt&quot;), Reducer.sum(&quot;@amount&quot;).as(&quot;total_amount&quot;) ) ) .sortBy(new SortedField(&quot;@total_amount&quot;, SortOrder.DESC)) .sortBy(new SortedField(&quot;@cnt&quot;, SortOrder.ASC))); 示例 4：按状态分组，筛选总金额 &gt; 200 1234567FT.AGGREGATE idx:user &#x27;*&#x27; GROUPBY 1 @status REDUCE SUM 1 @amount AS total_amount FILTER @total_amount &gt; 200 SORTBY 2 @total_amount DESC## 参数说明# FILTER: 过滤器，作用在 GROUPBY + REDUCE 之后，语义等价于 SQL 的：HAVING SUM(amount) &gt; 1000 123456789101112AggregationResult result = rSearch.aggregate( &quot;idx:user&quot;, &quot;*&quot;, AggregationOptions.defaults() .groupBy(GroupBy.fieldNames(&quot;@status&quot;) .reducers( Reducer.sum(&quot;@amount&quot;).as(&quot;total_amount&quot;) ) ) .filter(&quot;@total_amount &gt; 200&quot;) .sortBy(new SortedField(&quot;@total_amount&quot;, SortOrder.DESC))); 语义执行顺序： SCAN → GROUPBY → REDUCE → FILTER (HAVING) → SORTBY → LIMIT 常见可用 REDUCE 函数 函数 用途 COUNT 行数 SUM 求和 AVG 平均 MIN / MAX 极值 TO_LIST 收集字段 3️⃣ FT.EXPLAIN/FT.EXPLAINCLI 查询执行计划， 不会考虑分组聚合，只看查询条件，它的定位是：看“会不会用索引、怎么用索引”，而不是看“跑得慢不慢”。 123456789FT.EXPLAINCLI idx:user &#x27;@status:&#123;PAID&#125; @amount:[100 +inf]&#x27;## 示例结果1) INTERSECT &#123;2) TAG:@status &#123;3) paid4) &#125;5) NUMERIC &#123;100.000000 &lt;= @amount &lt;= inf&#125;6) &#125;7) 4️⃣ FT.PROFILE 性能分析，看“跑得慢不慢”。 123456789101112FT.PROFILE idx:user SEARCH QUERY &#x27;@status:&#123;PAID&#125; @amount:[100 +inf]&#x27;## 参数说明# SEARCH: 标准查询，AGGREGATE: 聚合查询# QUERY: 查询条件FT.PROFILE idx:user AGGREGATE QUERY &quot;@status:&#123;PAID&#125; @amount:[100 +inf]&quot; GROUPBY 1 @status REDUCE SUM 1 @amount AS total_amount 关注指标 第一优先级指标（直接决定查询是否慢） 指标 所在位置 含义 健康阈值 需要警惕 常见优化手段 Total profile time Shards → Total profile time 查询在搜索引擎层面的总耗时（不含网络） &lt; 1 ms：优秀1–10 ms：可接受 &gt; 20 ms：需要优化&gt; 50 ms：结构性问题 减少结果集、拆分查询、优化索引字段 Iterator Type Iterators profile → Type 查询执行策略 INTERSECT / UNION SCAN / WILDCARD 增加可索引字段、避免模糊前缀 Estimated number of matches Child iterators 索引层估算的候选文档数 &lt; 1k：理想1k–10k：可接受 &gt; 50k：过滤条件过宽 改用 TAG / NUMERIC / 冗余字段 Loader Time Result processors → Loader 从 Redis 加载并反序列化文档 &lt; 30% Total time &gt; 40% Total time RETURN 精简字段、NOCONTENT、缩小 JSON 第二优先级指标（判断索引或模型是否合理） 指标 所在位置 含义 健康阈值 需要警惕 常见优化手段 Number of reading operations Iterators profile 实际扫描的倒排表条目数 ≈ Estimated matches 明显大于结果数 提高字段选择性、拆分条件 Estimated matches vs 实际结果数 Iterator + Result 索引估算精度 估算值略大于实际 估算 &gt;&gt; 实际（10x+） 调整 schema，避免低基数字段 Parsing time Shards → Parsing time 查询语法解析耗时 &lt; 0.1 ms &gt; 1 ms 减少动态拼接、简化语法 Pipeline creation time Shards → Pipeline creation 执行计划构建时间 &lt; 0.05 ms &gt; 0.5 ms 减少子句、避免复杂嵌套 经验型“红线判断”速查表（非常实用） 现象 含义 是否必须处理 Estimated matches &gt; 100k 索引字段选择错误 必须 Iterator Type = SCAN 全表扫描 必须 Loader &gt; 50% 总耗时 返回数据过重 强烈建议 reading ops ≫ results 倒排效率低 建议 Total time &gt; 20 ms 在线查询风险 必须 核心执行策略型 Iterator（最重要） Type 语义 典型触发场景 性能特征 调优结论 INTERSECT 多条件取交集（AND） @a:&#123;x&#125; @b:[1 10] 基于最小倒排表，效率最高 理想状态，优先使用 UNION 多条件取并集（OR） @a:&#123;x|y&#125; 候选集扩大，随 OR 数量线性增长 可接受，避免过多 OR SCAN 全量扫描 字段未索引 / JSON Path 不可索引 O(N)，文档越多越慢 必须消灭 WILDCARD 无过滤条件 &quot;*&quot;、@field:* 候选集=全部文档 仅限分析，线上慎用 索引访问型 Iterator（INTERSECT / UNION 的子节点） Type 对应字段类型 示例查询 性能特征 备注 TAG TAG @status:&#123;PAID&#125; 哈希倒排，最快 强烈推荐 NUMERIC NUMERIC @amount:[100 +inf] 跳表范围扫描 范围越窄越快 TEXT TEXT @name:alice 分词匹配 分词数影响性能 GEO GEO @loc:[13.4 52.5 10 km] 空间索引 半径影响结果数 VECTOR VECTOR =&gt;[KNN 10 @v $q] 向量搜索 常与 FILTER 联用 IDLIST 内部 小结果集 枚举 ID 自动优化 逻辑 / 结构型 Iterator Type 含义 触发示例 性能影响 是否常见 NOT 取反 -@status:&#123;PAID&#125; 依赖全集 较少 OPTIONAL 可选子句 ( @a:&#123;x&#125; )? 增加候选集 少见 EMPTY 无匹配 条件不可能满足 极快 偶发 PHRASE 短语匹配 &quot;hello world&quot; 比 TEXT 慢 低频 PREFIX 前缀匹配 abc* 可能退化 需谨慎 三、别名管理（生产必备） 命令 作用 FT.ALIASADD 添加别名 FT.ALIASDEL 删除别名 FT.ALIASUPDATE 更新别名指向 一个索引可以有多个别名，一旦创建别名，所有 FT.SEARCH / FT.AGGREGATE / FT.INFO 等命令都可以直接使用 alias 12345678910# 添加别名: FT.ALIASADD alias indexFT.ALIASADD alias:user idx:user# 更新别名指向: FT.ALIASUPDATE alias indexFT.ALIASUPDATE alias:user idx:user:v2# 删除别名: FT.ALIASDEL aliasFT.ALIASDEL alias:user# 判断索引名称是否为别名FT.INFO alias:user 1) index_name 2) idx:user # 真实索引名称 123rSearch.addAlias(&quot;alias:user&quot;, &quot;idx:user&quot;);rSearch.updateAlias(&quot;alias:user&quot;, &quot;idx:user:v2&quot;);rSearch.delAlias(&quot;alias:user&quot;); 索引别名的核心价值 索引无损重建（最典型场景） RediSearch 不支持在线修改 schema，字段变更通常需要重建索引，索引重建时业务将不可用。 有了别名，我们可以创建一个新的索引，创建好后将别名指向新的索引，旧索引不再使用，业务无影响。 12345678910111. 旧索引 FT.ALIASADD user_idx user_idx_v12. 新建索引 FT.CREATE user_idx_v2 ...3. 数据回填完成后，原子切换 FT.ALIASUPDATE user_idx user_idx_v24. 删除旧索引（可选） FT.DROPINDEX user_idx_v1 灰度 / 多版本并存 不同环境（dev / staging / prod） 不同 schema 版本 运维与发布规范化（强烈推荐） 在生产环境中：永远不要让业务代码直接使用物理索引名 12索引真实名: 业务名_版本_时间戳索引别名 : 业务名 四、游标（大结果集） 命令 作用 FT.CURSOR READ 分批读取 FT.CURSOR DEL 删除游标 游标用于聚合查询（AGGREGATE）的大结果集分页/分批拉取，典型场景包括： 1234GROUPBY / REDUCE 后结果集很大需要流式处理聚合结果，避免一次性返回占用大量内存客户端按批消费结果（类似数据库的 server-side cursor）注意：游标主要用于 FT.AGGREGATE，普通 FT.SEARCH 不支持游标分页。 通过 FT.AGGREGATE ... WITHCURSOR 创建游标，通过 FT.CURSOR READ 获取结果。 1234567891011121314151617181920212223242526272829303132333435FT.AGGREGATE idx:user &quot;*&quot; GROUPBY 1 @status REDUCE SUM 1 @amount AS total_amount WITHCURSOR COUNT 2 MAXIDLE 60000## 参数说明# WITHCURSOR : 启用游标# COUNT 2 : 每次从游标中返回的行数（批大小）# MAXIDLE 60000 : 游标最大空闲时间（毫秒），超时后自动销毁## 返回结果1) 1) (integer) 3 # GROUP BY 后，一共会产生 3 行聚合结果，这里返回的是实际查询的总行数，不受COUNT 参数限制 2) 1) &quot;status&quot; 2) &quot;CANCELLED&quot; 3) &quot;total_amount&quot; 4) &quot;79.8&quot; 3) 1) &quot;status&quot; 2) &quot;PAID&quot; 3) &quot;total_amount&quot; 4) &quot;4096.89&quot;2) (integer) 116452546 # 游标ID# 读取游标FT.CURSOR READ idx:user 116452546 COUNT 2# 参数说明# 116452546 : 游标ID# COUNT 2 : 每次从游标中返回的行数(可覆盖初始游标中的 COUNT）## 返回结果1) 1) (integer) 0 # 当前游标中“剩余可读的行数”为 0 2) 1) &quot;status&quot; 2) &quot;CREATED&quot; 3) &quot;total_amount&quot; 4) &quot;238.8&quot;2) (integer) 0 # 0 表示没有更多结果# 销毁游标，如果设置了 MAXIDLE 参数，则该游标在 MAXIDLE 时间内自动销毁，所以无需手工销毁FT.CURSOR DEL idx:user 116452546 1234567891011121314151617181920212223242526272829303132333435363738394041424344AggregationResult result = rSearch.aggregate( &quot;idx:user&quot;, &quot;*&quot;, AggregationOptions.defaults() .groupBy(GroupBy.fieldNames(&quot;@status&quot;) .reducers( Reducer.sum(&quot;@amount&quot;).as(&quot;total_amount&quot;) ) ) .withCursor(2, 60000));long total;long cursorId;List&lt;Map&lt;String, Object&gt;&gt; attributes;total = result.getTotal();cursorId = result.getCursorId();System.out.println(&quot;total = &quot; + total);System.out.println(&quot;cursorId = &quot; + cursorId);attributes = result.getAttributes();for (Map&lt;String, Object&gt; attribute : attributes) &#123; System.out.println(&quot;attribute = &quot; + attribute);&#125;while (cursorId != 0) &#123; System.out.println(&quot;===============================================&quot;); // 游标读取，Redisson的readCursor方法有bug，无法继续读取游标数据 // result = rSearch.readCursor(&quot;idx:user&quot;, cursorId, 2); // 这里游标读取可以自己编写一个基于Lua 的实现 result = readCursor(&quot;idx:user&quot;, cursorId, 2); total = result.getTotal(); cursorId = result.getCursorId(); System.out.println(&quot;total = &quot; + total); System.out.println(&quot;cursorId = &quot; + cursorId); attributes = result.getAttributes(); for (Map&lt;String, Object&gt; attribute : attributes) &#123; System.out.println(&quot;attribute = &quot; + attribute); &#125;&#125;// cursorId=0 或 到期 时会自动删除游标，此处无需删除// rSearch.delCursor(&quot;idx:user&quot;, cursorId); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public AggregationResult readCursor(String indexName, long cursorId, int count) &#123; String script = &quot;return redis.call(&#x27;FT.CURSOR&#x27;, &#x27;READ&#x27;, KEYS[1], ARGV[1], &#x27;COUNT&#x27;, ARGV[2])&quot;; List&lt;Object&gt; results = stringRedisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(indexName), String.valueOf(cursorId), String.valueOf(count) ); cursorId = (long) results.get(1); List&lt;Object&gt; lo = (List) results.get(0); return new AggregationResult( (long) lo.get(0), toListOfMap(lo), cursorId );&#125;public static List&lt;Map&lt;String, Object&gt;&gt; toListOfMap(List&lt;Object&gt; lo) &#123; List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;(); if (lo == null || lo.size() &lt;= 1) &#123; return result; &#125; // 从索引 1 开始，跳过聚合总数 for (int i = 1; i &lt; lo.size(); i++) &#123; Object rowObj = lo.get(i); if (!(rowObj instanceof List&lt;?&gt; row)) &#123; continue; &#125; Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); for (int j = 0; j &lt; row.size() - 1; j += 2) &#123; String key = String.valueOf(row.get(j)); Object value = row.get(j + 1); map.put(key, value); &#125; result.add(map); &#125; return result;&#125; 完整生命周期总结 1234567FT.AGGREGATE ... WITHCURSOR # 创建游标（并返回第一批 + cursorId） ↓FT.CURSOR READ # 读取第 N 批 ↓FT.CURSOR READ # 继续读取 ↓FT.CURSOR DEL（可选） # 提前释放资源 游标与 OFFSET/LIMIT 的区别 对比项 游标 OFFSET / LIMIT 性能 高（流式） 大 OFFSET 性能差 适合大结果集 是 否 服务器状态 有 无 适用命令 FT.AGGREGATE FT.SEARCH 五、词典 &amp; 同义词（搜索增强） 词典（DICT）和同义词（SYNONYM）只对 TEXT / TAG 搜索生效 与 FT.AGGREGATE 无关，但与 FT.SEARCH 强相关。 命令 作用 FT.DICTADD 添加词 FT.DICTDEL 删除词 FT.DICTDUMP 查看词典 FT.SYNUPDATE 更新同义词 FT.SYNDUMP 查看同义词 词典 词典作用：控制“合法搜索词”，比如将词典的内容发送给用户，让用户只能搜索这些词。 ⚠️ 词典本身不参与搜索匹配 ⚠️ 只是为搜索增强提供数据来源 123456# 示例：添加商品相关词FT.DICTADD product_dict iphone mobile phone android huawei# 查看词典内容（FT.DICTDUMP）FT.DICTDUMP product_dict# 删除词典中的词（FT.DICTDEL）FT.DICTDEL product_dict iphone 123rSearch.addDict(&quot;product_dict&quot;, &quot;iphone&quot;, &quot;mobile&quot;,&quot;phone&quot;,&quot;android&quot;,&quot;huawei&quot;);List&lt;String&gt; productDict = rSearch.dumpDict(&quot;product_dict&quot;);rSearch.delDict(&quot;product_dict&quot;, &quot;iphone&quot;); 同义词 同义词的作用: 让不同的搜索词 命中同一批文档 123456例如： 搜 iphone 搜 mobile 搜 phone 👉 命中同一批订单 添加 / 更新同义词（FT.SYNUPDATE） 1234567891011121314151617# 定义“手机”的同义词集合，注意同义词是绑定到 索引 的FT.SYNUPDATE idx:user phone_group iphone mobile phone## 参数说明# phone_group: 同义词集合名称（你自己定义）# iphone mobile phone: 添加同义词，多个词用空格隔开# 查看同义词集合FT.SYNDUMP idx:user## 输出1) &quot;phone&quot;2) 1) &quot;phone_group&quot;3) &quot;iphone&quot;4) 1) &quot;phone_group&quot;5) &quot;mobile&quot;6) 1) &quot;phone_group&quot; 12rSearch.updateSynonyms(&quot;idx:user&quot;, &quot;phone_group&quot;, &quot;iphone&quot;, &quot;mobile&quot;, &quot;phone&quot;);Map&lt;String, List&lt;String&gt;&gt; synonyms = rSearch.dumpSynonyms(&quot;idx:user&quot;); 此时我们再进行搜索，就会命中所有同义词 123456789101112131415FT.SEARCH idx:user &#x27;phone&#x27;# 搜索结果1) (integer) 42) &quot;user:10001&quot;3) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Alice Bob\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:\\&quot;yes\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;SpringCloud\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe6\\x8c\\x87\\xe5\\x8d\\x97\\&quot;,\\&quot;Shell\\xe8\\x84\\x9a\\xe6\\x9c\\xac\\xe5\\x9f\\xba\\xe7\\xa1\\x80\\&quot;]&#125;&quot;4) &quot;user:10006&quot;5) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Frank\\&quot;,\\&quot;age\\&quot;:27,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:499,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;,&#123;\\&quot;amount\\&quot;:129,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a phone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Redis\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;,\\&quot;MongoDB\\xe4\\xbb\\x8e\\xe5\\x85\\xa5\\xe9\\x97\\xa8\\xe5\\x88\\xb0\\xe5\\xae\\x9e\\xe6\\x88\\x98\\&quot;]&#125;&quot;6) &quot;user:10002&quot;7) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Bob Frank\\&quot;,\\&quot;age\\&quot;:35,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:899.0,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a iphone\\&quot;,\\&quot;items\\&quot;:[\\&quot;Linux\\xe5\\xbf\\x85\\xe7\\x9f\\xa5\\xe5\\xbf\\x85\\xe4\\xbc\\x9a\\&quot;,\\&quot;Java\\xe5\\xa4\\x9a\\xe7\\xba\\xbf\\xe7\\xa8\\x8b\\xe8\\xaf\\xa6\\xe8\\xa7\\xa3\\&quot;]&#125;&quot;8) &quot;user:10003&quot;9) 1) &quot;$&quot; 2) &quot;&#123;\\&quot;name\\&quot;:\\&quot;Carol\\&quot;,\\&quot;age\\&quot;:22,\\&quot;vip\\&quot;:\\&quot;no\\&quot;,\\&quot;orders\\&quot;:[&#123;\\&quot;amount\\&quot;:19.9,\\&quot;status\\&quot;:\\&quot;CANCELLED\\&quot;&#125;],\\&quot;comment\\&quot;:\\&quot;I have a mobile\\&quot;,\\&quot;items\\&quot;:[\\&quot;MySQL\\xe4\\xbb\\x8e\\xe5\\x88\\xa0\\xe5\\xba\\x93\\xe5\\x88\\xb0\\xe8\\xb7\\x91\\xe8\\xb7\\xaf\\&quot;,\\&quot;Oracle\\xe5\\xbc\\x80\\xe5\\x8f\\x91\\xe5\\xae\\x9e\\xe8\\xb7\\xb5\\&quot;]&#125;&quot; 词典 + 同义词的组合使用 123451. 用户输入: 手机2. 前端 / 服务端 → 从 product_dict 给提示3. 搜索请求 → FT.SEARCH4. RediSearch → 同义词扩展5. 返回统一结果 六、FT.SPELLCHECK（拼写纠错） FT.SPELLCHECK 用于对用户输入的搜索词进行拼写纠错与相似词推荐 它并不会真正执行搜索，而是： ✅ 分析输入词是否存在于索引词典 ✅ 如果不存在，基于编辑距离（Levenshtein）给出候选纠错词 ✅ 支持自定义词典（Dictionary）增强效果 🎯 核心目标 能力 说明 拼写纠错 iphone → ipohne 模糊推荐 用户拼错关键词 搜索前置纠错 提升召回率 自动学习索引词 自动从索引词库构建词典 基本语法 123FT.SPELLCHECK index query [DISTANCE maxDistance] [TERMS &#123;INCLUDE | EXCLUDE&#125; dictionary ...] 参数说明表 参数 说明 默认值 index 索引名称 必填 query 用户输入词 必填 DISTANCE 最大编辑距离（1~4） 1 TERMS INCLUDE 仅使用指定词典 全部 TERMS EXCLUDE 排除指定词典 无 示例 12345678910111213141516171819202122232425262728FT.SPELLCHECK idx:user &#x27;iphnoe&#x27; DISTANCE 2# 输出1) 1) TERM # 固定标识，表示这是一个被分析的词 2) &quot;iphnoe&quot; # 用户输入词 3) 1) 1) &quot;0.4&quot; # 相似度评分，越小越相似 2) &quot;iphone&quot; # 推荐词，建议替换词# 搜索多个词FT.SPELLCHECK idx:user &#x27;iphnoe linu&#x27; DISTANCE 21) 1) TERM 2) &quot;iphnoe&quot; 3) 1) 1) &quot;0.4&quot; 2) &quot;iphone&quot;2) 1) TERM 2) &quot;linu&quot; 3) 1) 1) &quot;0.4&quot; 2) &quot;linux&quot;# 增加编辑距离会显示更多的候选词FT.SPELLCHECK idx:user &#x27;phnoe&#x27; DISTANCE 31) 1) TERM 2) &quot;phnoe&quot; 3) 1) 1) &quot;4&quot; 2) &quot;have&quot; 2) 1) &quot;0.8&quot; 2) &quot;phone&quot; 3) 1) &quot;0.4&quot; 2) &quot;iphone&quot; 1234Map&lt;String, Map&lt;String, Double&gt;&gt; spellcheck = rSearch.spellcheck( &quot;idx:user&quot;, &quot;iphnoe linu&quot;, SpellcheckOptions.defaults().distance(2)); score = 编辑距离 / max(len(用户输入词), len(候选词))，但并不是总是这样 输入 候选 编辑距离 maxLen score phnoe iphone 2 6 2/6 = 0.333 ≈ 0.4 phnoe phone 1 5 0.2 → ~0.8（内部权重可能反转或调整） phnoe have “4” → 表示 phnoe 与 have 的编辑距离是 4 1234567891011phnoe → havep → h (1)h → a (2)n → v (3)o → e (4)e → (删除) (5) （不同算法可能计为 4 或 5）该词明显是低质量候选，只是 DISTANCE=3/4 时被勉强收录。业务侧做合理过滤如果 score &gt;= 2 → 直接丢弃（明显噪声）如果 score &lt;= 1.0 → 可信候选 建议策略 场景 建议 搜索框实时提示 1 搜索提交后纠错 2 模糊容错系统 2~3 词典增强（Dictionary Integration） 通过 FT.DICTADD / FT.DICTDEL 人工维护一个或多个词典，把“业务词汇”主动注入到 SpellCheck 的候选词空间中。 12345678910111213141516171819202122232425默认情况下：SpellCheck 只能从 索引倒排词典（Inverted Index Terms） 中生成候选词。如果某些词： 不在索引里 出现频率极低 属于专有名词 新词、品牌词那么 SpellCheck 很可能无法正确纠错。词典增强解决的正是这个问题。用户输入 → Tokenizer → 拆词 → ↓候选源合并： - 倒排索引词典 - 自定义词典（FT.DICTADD） ↓编辑距离计算 ↓候选排序 ↓返回纠错词✅ SpellCheck 的候选空间被人为扩大。 123456789FT.DICTADD dict:tech iphone ipad macbook airpods# 使用指定词典纠错，白名单FT.SPELLCHECK idx:user &quot;macboo&quot; TERMS INCLUDE dict:tech1) 1) TERM 2) &quot;macboo&quot; 3) 1) 1) &quot;0.4&quot; 2) &quot;macbook&quot;# 排除词典，黑名单FT.SPELLCHECK idx:user &quot;iphnoe&quot; TERMS EXCLUDE dict:noise 1234567Map&lt;String, Map&lt;String, Double&gt;&gt; spellcheck = rSearch.spellcheck( &quot;idx:user&quot;, &quot;macboo&quot;, SpellcheckOptions.defaults() .distance(2) .includedTerms(&quot;dict:tech&quot;)); FT.SPELLCHECK 与 Suggest 的差异对比（关键） 维度 FT.SPELLCHECK FT.SUGGET 目标 拼写纠错 前缀联想 输入 完整词 前缀 返回 相似词 补全词 数据来源 索引词典 独立 Trie 是否排序 否（距离优先） 是（score） 是否模糊 编辑距离 前缀 + FUZZY 使用阶段 搜索前修正 输入过程中 已废弃命令（不建议使用） 命令 状态 说明 FT.CONFIG GET Reids8 将其标记为 Deprecated 使用 CONFIG GET search-* FT.CONFIG SET Reids8 将其标记为 Deprecated 同上 FT.TAGVALS 已经标记为 Deprecated 改用 AGGREGATE ⚠️ 这里要注意，只有 Redis 8.0.0 以上版本支持 CONFIG GET search-*。 FT.CONFIG GET * 和 CONFIG GET search-* 对应参数整理 1️⃣ 索引基本 / 文档表配置 FT.CONFIG 参数 FT.CONFIG 值 CONFIG search-* 参数 CONFIG 值 说明 MINPREFIX 2 search-min-prefix 2 自动补全最小前缀长度 MINSTEMLEN 4 search-min-stem-len 4 最小词干长度 MAXDOCTABLESIZE 1000000 search-max-doctablesize 1000000 最大文档表大小 MAXSEARCHRESULTS 1000000 search-max-search-results 1000000 搜索结果限制 MAXAGGREGATERESULTS unlimited search-max-aggregate-results 2147483648 聚合结果限制 MAXEXPANSIONS 200 search-max-prefix-expansions 200 前缀扩展限制 MAXPREFIXEXPANSIONS 200 search-max-prefix-expansions 200 前缀扩展限制（兼容） RAW_DOCID_ENCODING false search-raw-docid-encoding no 文档ID是否原始编码 UPGRADE_INDEX Upgrade config for upgrading N/A N/A 升级索引配置提示 2️⃣ 查询 / 评分相关配置 FT.CONFIG 参数 FT.CONFIG 值 CONFIG search-* 参数 CONFIG 值 说明 TIMEOUT 500 search-timeout 500 查询超时（ms） ON_TIMEOUT return search-on-timeout return 超时策略 DEFAULT_SCORER TFIDF search-default-scorer BM25STD 默认评分算法 BM25STD_TANH_FACTOR 4 search-bm25std-tanh-factor 4 BM25 调整因子 MULTI_TEXT_SLOP 100 search-multi-text-slop 100 多字段查询 slop DEFAULT_DIALECT 1 search-default-dialect 1 查询方言 3️⃣ GC / 后台索引配置 FT.CONFIG 参数 FT.CONFIG 值 CONFIG search-* 参数 CONFIG 值 说明 NOGC false search-no-gc no 禁用 GC GC_POLICY fork search-fork-gc-policy (implicit) fork GC 策略 FORKGC_SLEEP_BEFORE_EXIT 0 search-fork-gc-sleep-before-exit 0 fork GC 退出前睡眠 FORK_GC_RUN_INTERVAL 30 search-fork-gc-run-interval 30 fork GC 执行间隔（秒） FORK_GC_CLEAN_THRESHOLD 100 search-fork-gc-clean-threshold 100 fork GC 清理阈值 FORK_GC_RETRY_INTERVAL 5 search-fork-gc-retry-interval 5 fork GC 重试间隔 FORK_GC_CLEAN_NUMERIC_EMPTY_NODES true search-_numeric-compress no 清理空数值节点 GCSCANSIZE 100 search-gc-scan-size 100 GC 每次扫描大小 4️⃣ 游标 / 线程 / 并发配置 FT.CONFIG 参数 FT.CONFIG 值 CONFIG search-* 参数 CONFIG 值 说明 CURSOR_MAX_IDLE 300000 search-cursor-max-idle 300000 游标最大空闲时间 INDEX_CURSOR_LIMIT 128 search-index-cursor-limit 128 单索引游标限制 UNION_ITERATOR_HEAP 20 search-union-iterator-heap 20 UNION 查询堆大小 NO_MEM_POOLS false search-no-mem-pools no 禁用内存池 _FREE_RESOURCE_ON_THREAD true search-_free-resource-on-thread yes 线程释放资源 search_min_operation_workers N/A search-min-operation-workers 4 最小操作线程数 search-workers N/A search-workers 0 工作线程数 search-workers-priority-bias-threshold N/A search-workers-priority-bias-threshold 1 线程优先级偏置 INDEXER_YIELD_EVERY_OPS 1000 search-indexer-yield-every-ops 1000 索引器 yield 每操作数 5️⃣ 实验 / 内部 /其他 FT.CONFIG 参数 FT.CONFIG 值 CONFIG search-* 参数 CONFIG 值 说明 EXTLOAD nil search-ext-load “” 外部加载模块 FRISOINI nil search-friso-ini “” 中文分词初始化 ENABLE_UNSTABLE_FEATURES false search-enable-unstable-features no 启用实验特性 _PRINT_PROFILE_CLOCK true search-_print-profile-clock yes Profiling 开关 _NUMERIC_RANGES_PARENTS 0 search-_numeric-ranges-parents 0 数值范围父节点数 VSS_MAX_RESIZE 0 search-vss-max-resize 1024 向量索引最大重分配 PARTIAL_INDEXED_DOCS false search-partial-indexed-docs no 部分索引文档标记 _PRIORITIZE_INTERSECT_UNION_CHILDREN false search-_prioritize-intersect-union-children no 优先处理 INTERSECT/UNION 子节点 _BG_INDEX_MEM_PCT_THR 100 search-_bg-index-mem-pct-thr 100 后台索引内存阈值 _NUMERIC_COMPRESS false search-_numeric-compress no 数值压缩 _BG_INDEX_OOM_PAUSE_TIME 0 search-_bg-index-oom-pause-time 0 后台索引 OOM 暂停时间","summary":"摘要 本文介绍 Redis 扩展模块 – RediSearch 的使用方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RediSearch 的安装参见 Redis 扩展模块 -- RediSearch 的安装方法 示例代码：GitHub","date_published":"2026-01-05T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/26/redis7-module-RediSearch/","url":"https://blog.hanqunfeng.com/2025/12/26/redis7-module-RediSearch/","title":"Redis 扩展模块 -- RediSearch 的安装方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RediSearch 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RediSearch-简介\">RediSearch 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RediSearch/RediSearch\">RediSearch</a> 是 Redis 官方推出的 <code>全文搜索</code>与<code>二级索引</code>模块，用于在 Redis 之上提供类似<code>搜索引擎</code>的能力，解决“只能按 key 查、无法高效按字段查询”的问题。它是 Redis Stack 的核心组件之一，常用于搜索、过滤、排序和聚合场景。仅支持对 Hash 和 RedisJSON 类型进行索引。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RediSearch 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RediSearch 通过 <code>索引结构</code> + <code>查询语言</code>，提供：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">全文搜索（Text Search）</li>\n<li class=\"lvl-4\">二级索引（按字段查询）</li>\n<li class=\"lvl-4\">多条件过滤 / 排序</li>\n<li class=\"lvl-4\">聚合分析（GROUP BY、COUNT、SUM 等）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>性能与设计特点</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">索引在内存中，查询延迟低（毫秒级）</li>\n<li class=\"lvl-4\">写入时同步更新索引（写入成本略高）</li>\n<li class=\"lvl-4\">适合 读多写少 / 查询复杂 的业务</li>\n<li class=\"lvl-4\">非事务型搜索引擎（不替代 ES，而是互补）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>与原生 Redis 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Redis 原生</th>\n<th>RediSearch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查询方式</td>\n<td>key 精确</td>\n<td>多字段查询</td>\n</tr>\n<tr>\n<td>全文搜索</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>范围查询</td>\n<td>有限</td>\n<td>强</td>\n</tr>\n<tr>\n<td>聚合统计</td>\n<td>基本没有</td>\n<td>类 SQL</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>极快</td>\n<td>近实时，内存换性能</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RediSearch-vs-Elasticsearch\">RediSearch vs Elasticsearch</h2>\n<table>\n<thead>\n<tr>\n<th>对比点</th>\n<th>RediSearch</th>\n<th>Elasticsearch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>部署复杂度</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>延迟</td>\n<td>极低</td>\n<td>较高</td>\n</tr>\n<tr>\n<td>数据规模</td>\n<td>中小规模</td>\n<td>超大规模</td>\n</tr>\n<tr>\n<td>实时性</td>\n<td>强</td>\n<td>近实时</td>\n</tr>\n<tr>\n<td>场景</td>\n<td>业务内搜索</td>\n<td>搜索平台</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装-RediSearch\">安装 RediSearch</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是从<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中进行下载，其提供了所有Redis模块编译后的<code>.so</code>文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/rguEIA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>源码编译</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisearch.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y \\</span><br><span class=\"line\">  gcc \\</span><br><span class=\"line\">  gcc-c++ \\</span><br><span class=\"line\">  make \\</span><br><span class=\"line\">  cmake \\</span><br><span class=\"line\">  autoconf \\</span><br><span class=\"line\">  automake \\</span><br><span class=\"line\">  libtool \\</span><br><span class=\"line\">  pkgconfig \\</span><br><span class=\"line\">  openssl-devel \\</span><br><span class=\"line\">  libstdc++ \\</span><br><span class=\"line\">  libstdc++-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RediSearch 最新版本 依赖 CMake 3.25+，dnf源中的版本较低，所以这里需要手动安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMAKE_VERSION=3.25.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/src</span><br><span class=\"line\">wget https://github.com/Kitware/CMake/releases/download/v<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>/cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>.tar.gz</span><br><span class=\"line\">tar -xf cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">./bootstrap --prefix=/usr/local</span><br><span class=\"line\">make -j$(<span class=\"built_in\">nproc</span>)</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证版本 /usr/local/bin/cmake</span></span><br><span class=\"line\">/usr/local/bin/cmake --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译RediSearch</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RediSearch/RediSearch.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RediSearch</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.10.25</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 build_dir 目录，编译失败要先删除该目录在重新创建</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir &amp;&amp; <span class=\"built_in\">cd</span> build_dir</span><br><span class=\"line\"><span class=\"comment\"># 生成 Makefile</span></span><br><span class=\"line\">/usr/local/bin/cmake .. \\</span><br><span class=\"line\">  -DCMAKE_BUILD_TYPE=Release \\</span><br><span class=\"line\">  -DCMAKE_C_COMPILER=gcc \\</span><br><span class=\"line\">  -DCMAKE_CXX_COMPILER=g++</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RediSearch</span></span><br><span class=\"line\">make -j$(<span class=\"built_in\">nproc</span>)</span><br><span class=\"line\"><span class=\"comment\"># 编译过程会报错，同样在 Rocky9 上也会遇到这个问题</span></span><br><span class=\"line\">[100%] Linking CXX shared library redisearch.so</span><br><span class=\"line\">/usr/bin/ld: cannot find -lstdc++: No such file or directory</span><br><span class=\"line\">collect2: error: ld returned 1 <span class=\"built_in\">exit</span> status</span><br><span class=\"line\">make[2]: *** [CMakeFiles/redisearch.dir/build.make:557: redisearch.so] Error 1</span><br><span class=\"line\">make[1]: *** [CMakeFiles/Makefile2:2958: CMakeFiles/redisearch.dir/all] Error 2</span><br><span class=\"line\">make: *** [Makefile:136: all] Error 2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译错误原因分析</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RediSearch 2.10.x 在链接 redisearch.so 时 强制 使用 -static-libstdc++，而 libstdc++.a 静态文件不存在，导致编译失败</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法是安装静态库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y libstdc++-static</span><br><span class=\"line\"><span class=\"comment\"># 验证静态文件是否存在</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> /usr/lib/gcc/x86_64-amazon-linux/*/libstdc++.a</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">/usr/lib/gcc/x86_64-amazon-linux/11/libstdc++.a</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装后重新编译RediSearch</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># 删除 build_dir 目录</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf build_dir</span><br><span class=\"line\"><span class=\"comment\"># 创建 build_dir 目录，编译失败要先删除该目录再重新创建</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir &amp;&amp; <span class=\"built_in\">cd</span> build_dir</span><br><span class=\"line\"><span class=\"comment\"># 生成 Makefile</span></span><br><span class=\"line\">/usr/local/bin/cmake .. \\</span><br><span class=\"line\">  -DCMAKE_BUILD_TYPE=Release \\</span><br><span class=\"line\">  -DCMAKE_C_COMPILER=gcc \\</span><br><span class=\"line\">  -DCMAKE_CXX_COMPILER=g++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RediSearch，如果没有错误，则说明编译成功，输出: build_dir/redisearch.so</span></span><br><span class=\"line\">make -j$(<span class=\"built_in\">nproc</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <code>redisearch.so</code> 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要包含可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> build_dir/redisearch.so /usr/local/soft/redis-7.4.7/modules/redisearch.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 redisearch.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisearch.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20816</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 21025</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Rocky9-编译安装-RediSearch\">Rocky9 编译安装 RediSearch</h2>\n<blockquote>\n<p>系统版本：<code>Rocky Linux release 9.4 (Blue Onyx)</code></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y \\</span><br><span class=\"line\">  gcc \\</span><br><span class=\"line\">  gcc-c++ \\</span><br><span class=\"line\">  make \\</span><br><span class=\"line\">  cmake \\</span><br><span class=\"line\">  autoconf \\</span><br><span class=\"line\">  automake \\</span><br><span class=\"line\">  libtool \\</span><br><span class=\"line\">  pkgconfig \\</span><br><span class=\"line\">  openssl-devel \\</span><br><span class=\"line\">  libstdc++ \\</span><br><span class=\"line\">  libstdc++-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启用 CRB</p>\n</li>\n</ul>\n<blockquote>\n<p>在 Rocky Linux 9 中，<code>libstdc++-static</code> 不在默认仓库里，它位于 CRB（CodeReady Builder）仓库，默认是 关闭的，所以我们需要先启用它</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果你系统里没有 config-manager，需要先先装</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y dnf-plugins-core</span><br><span class=\"line\"><span class=\"comment\"># 启用 CRB</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf config-manager --set-enabled crb</span><br><span class=\"line\"><span class=\"comment\"># 刷新缓存</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf makecache</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装静态库，解决<code>/usr/bin/ld: cannot find -lstdc++: No such file or directory</code>的问题</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y libstdc++-static</span><br><span class=\"line\"><span class=\"comment\"># 验证静态文件是否存在</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> /usr/lib/gcc/x86_64-redhat-linux/*/libstdc++.a</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译RediSearch</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RediSearch/RediSearch.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RediSearch</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.10.25</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 build_dir 目录，编译失败要先删除该目录再重新创建</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir &amp;&amp; <span class=\"built_in\">cd</span> build_dir</span><br><span class=\"line\"><span class=\"comment\"># 生成 Makefile</span></span><br><span class=\"line\">cmake .. \\</span><br><span class=\"line\">  -DCMAKE_BUILD_TYPE=Release \\</span><br><span class=\"line\">  -DCMAKE_C_COMPILER=gcc \\</span><br><span class=\"line\">  -DCMAKE_CXX_COMPILER=g++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RediSearch，如果没有错误，则说明编译成功，输出: build_dir/redisearch.so</span></span><br><span class=\"line\">make -j$(<span class=\"built_in\">nproc</span>)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RediSearch 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RediSearch 简介 RediSearch 是 Redis 官方推出的 全文搜索与二级索引模块，用于在 Redis 之上提供类似搜索引擎的能力，解决“只能按 key 查、无法高效按字段查询”的问题。它是 Redis Stack 的核心组件之一，常用于搜索、过滤、排序和聚合场景。仅支持对 Hash 和 RedisJSON 类型进行索引。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RediSearch 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 RediSearch 通过 索引结构 + 查询语言，提供： 全文搜索（Text Search） 二级索引（按字段查询） 多条件过滤 / 排序 聚合分析（GROUP BY、COUNT、SUM 等） 性能与设计特点 索引在内存中，查询延迟低（毫秒级） 写入时同步更新索引（写入成本略高） 适合 读多写少 / 查询复杂 的业务 非事务型搜索引擎（不替代 ES，而是互补） 与原生 Redis 的对比 维度 Redis 原生 RediSearch 查询方式 key 精确 多字段查询 全文搜索 不支持 支持 范围查询 有限 强 聚合统计 基本没有 类 SQL 性能 极快 近实时，内存换性能 RediSearch vs Elasticsearch 对比点 RediSearch Elasticsearch 部署复杂度 低 高 延迟 极低 较高 数据规模 中小规模 超大规模 实时性 强 近实时 场景 业务内搜索 搜索平台 安装 RediSearch 最简单的方式就是从Redis Cloud的Download Center中进行下载，其提供了所有Redis模块编译后的.so文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 源码编译 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redisearch.so上传到国内服务器即可。 安装依赖 123456789101112sudo dnf install -y \\ gcc \\ gcc-c++ \\ make \\ cmake \\ autoconf \\ automake \\ libtool \\ pkgconfig \\ openssl-devel \\ libstdc++ \\ libstdc++-devel RediSearch 最新版本 依赖 CMake 3.25+，dnf源中的版本较低，所以这里需要手动安装 12345678910111213CMAKE_VERSION=3.25.1cd /usr/local/srcwget https://github.com/Kitware/CMake/releases/download/v$&#123;CMAKE_VERSION&#125;/cmake-$&#123;CMAKE_VERSION&#125;.tar.gztar -xf cmake-$&#123;CMAKE_VERSION&#125;.tar.gzcd cmake-$&#123;CMAKE_VERSION&#125;./bootstrap --prefix=/usr/localmake -j$(nproc)sudo make install# 验证版本 /usr/local/bin/cmake/usr/local/bin/cmake --version 编译RediSearch 12345678910111213141516171819202122232425262728mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RediSearch/RediSearch.gitcd RediSearch# 推荐切换到稳定的release版本git checkout v2.10.25# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 创建 build_dir 目录，编译失败要先删除该目录在重新创建mkdir build_dir &amp;&amp; cd build_dir# 生成 Makefile/usr/local/bin/cmake .. \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_C_COMPILER=gcc \\ -DCMAKE_CXX_COMPILER=g++# 编译 RediSearchmake -j$(nproc)# 编译过程会报错，同样在 Rocky9 上也会遇到这个问题[100%] Linking CXX shared library redisearch.so/usr/bin/ld: cannot find -lstdc++: No such file or directorycollect2: error: ld returned 1 exit statusmake[2]: *** [CMakeFiles/redisearch.dir/build.make:557: redisearch.so] Error 1make[1]: *** [CMakeFiles/Makefile2:2958: CMakeFiles/redisearch.dir/all] Error 2make: *** [Makefile:136: all] Error 2 编译错误原因分析 1RediSearch 2.10.x 在链接 redisearch.so 时 强制 使用 -static-libstdc++，而 libstdc++.a 静态文件不存在，导致编译失败 解决方法是安装静态库 12345sudo dnf install -y libstdc++-static# 验证静态文件是否存在ls /usr/lib/gcc/x86_64-amazon-linux/*/libstdc++.a# 输出/usr/lib/gcc/x86_64-amazon-linux/11/libstdc++.a 安装后重新编译RediSearch 12345678910111213cd /usr/local/soft/modules# 删除 build_dir 目录rm -rf build_dir# 创建 build_dir 目录，编译失败要先删除该目录再重新创建mkdir build_dir &amp;&amp; cd build_dir# 生成 Makefile/usr/local/bin/cmake .. \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_C_COMPILER=gcc \\ -DCMAKE_CXX_COMPILER=g++# 编译 RediSearch，如果没有错误，则说明编译成功，输出: build_dir/redisearch.somake -j$(nproc) Redis 启用模块 将生成的 redisearch.so 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建 12# 注意 .so 文件需要包含可执行权限cp build_dir/redisearch.so /usr/local/soft/redis-7.4.7/modules/redisearch.so 本文采用 loadmodule 加载模块 1234567891011121314151617181920212223242526272829303132333435# 将 redisearch.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisearch.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 20816 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 21025 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array) Rocky9 编译安装 RediSearch 系统版本：Rocky Linux release 9.4 (Blue Onyx) 安装依赖 123456789101112sudo dnf install -y \\ gcc \\ gcc-c++ \\ make \\ cmake \\ autoconf \\ automake \\ libtool \\ pkgconfig \\ openssl-devel \\ libstdc++ \\ libstdc++-devel 启用 CRB 在 Rocky Linux 9 中，libstdc++-static 不在默认仓库里，它位于 CRB（CodeReady Builder）仓库，默认是 关闭的，所以我们需要先启用它 123456# 如果你系统里没有 config-manager，需要先先装sudo dnf install -y dnf-plugins-core# 启用 CRBsudo dnf config-manager --set-enabled crb# 刷新缓存sudo dnf makecache 安装静态库，解决/usr/bin/ld: cannot find -lstdc++: No such file or directory的问题 123sudo dnf install -y libstdc++-static# 验证静态文件是否存在ls /usr/lib/gcc/x86_64-redhat-linux/*/libstdc++.a 编译RediSearch 1234567891011121314151617181920mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RediSearch/RediSearch.gitcd RediSearch# 推荐切换到稳定的release版本git checkout v2.10.25# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 创建 build_dir 目录，编译失败要先删除该目录再重新创建mkdir build_dir &amp;&amp; cd build_dir# 生成 Makefilecmake .. \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_C_COMPILER=gcc \\ -DCMAKE_CXX_COMPILER=g++# 编译 RediSearch，如果没有错误，则说明编译成功，输出: build_dir/redisearch.somake -j$(nproc)","summary":"摘要 本文介绍 Redis 扩展模块 – RediSearch 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-26T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/","url":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-amazon-linux-2023/","title":"Amazon Linux 2023(内核 6.1) 安装 Redis8","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Linux 安装 Redis8 的方法</li>\n<li class=\"lvl-2\">Linux 版本：<code>Amazon Linux 2023(内核 6.1)</code>。</li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\"><a href=\"https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/\">Redis官网安装手册</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Yum-安装\">Yum 安装</h2>\n<blockquote>\n<p>最省事，国内环境也可以顺利完成安装。<br>\n<code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Redis]</span></span><br><span class=\"line\"><span class=\"string\">name=Redis</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装 Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> rpm --import /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.查看redis安装信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看已安装的redis版本</span></span><br><span class=\"line\">$ rpm -qa | grep redis</span><br><span class=\"line\">redis-8.4.0-1.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装信息</span></span><br><span class=\"line\">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class=\"line\">Name        : redis</span><br><span class=\"line\">Version     : 8.4.0</span><br><span class=\"line\">Release     : 1</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class=\"line\">Group       : Applications/Databases</span><br><span class=\"line\">Size        : 83034075</span><br><span class=\"line\">License     :</span><br><span class=\"line\">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class=\"line\">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class=\"line\">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class=\"line\">Build Host  : 331d5099e900</span><br><span class=\"line\">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class=\"line\">URL         : https://redis.io/</span><br><span class=\"line\">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装的文件</span></span><br><span class=\"line\">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class=\"line\">/etc/redis</span><br><span class=\"line\">/etc/redis/redis.conf</span><br><span class=\"line\">/etc/redis/sentinel</span><br><span class=\"line\">/etc/redis/sentinel/sentinel.conf</span><br><span class=\"line\">/run/redis</span><br><span class=\"line\">/run/redis/redis-server.pid</span><br><span class=\"line\">/usr/bin/redis-benchmark</span><br><span class=\"line\">/usr/bin/redis-check-aof</span><br><span class=\"line\">/usr/bin/redis-check-rdb</span><br><span class=\"line\">/usr/bin/redis-cli</span><br><span class=\"line\">/usr/bin/redis-sentinel</span><br><span class=\"line\">/usr/bin/redis-server</span><br><span class=\"line\">/usr/lib/redis</span><br><span class=\"line\">/usr/lib/redis/modules</span><br><span class=\"line\">/usr/lib/redis/modules/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/modules/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/modules/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/modules/rejson.so</span><br><span class=\"line\">/usr/lib/redis/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/rejson.so</span><br><span class=\"line\">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class=\"line\">/usr/lib/systemd/system/redis.service</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.fc</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.te</span><br><span class=\"line\">/var/lib/redis</span><br><span class=\"line\">/var/log/redis</span><br><span class=\"line\">/var/log/redis/redis-sentinel.log</span><br><span class=\"line\">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启动redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<h2 id=\"源码安装\">源码安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.更新环境(非必须)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装依赖包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y --nobest --skip-broken \\</span><br><span class=\"line\">    pkg-config \\</span><br><span class=\"line\">    xz \\</span><br><span class=\"line\">    wget \\</span><br><span class=\"line\">    <span class=\"built_in\">which</span> \\</span><br><span class=\"line\">    git \\</span><br><span class=\"line\">    make \\</span><br><span class=\"line\">    openssl \\</span><br><span class=\"line\">    openssl-devel \\</span><br><span class=\"line\">    python3 \\</span><br><span class=\"line\">    python3-pip \\</span><br><span class=\"line\">    python3-devel \\</span><br><span class=\"line\">    unzip \\</span><br><span class=\"line\">    rsync \\</span><br><span class=\"line\">    clang \\</span><br><span class=\"line\">    llvm \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    libtool \\</span><br><span class=\"line\">    automake \\</span><br><span class=\"line\">    autoconf \\</span><br><span class=\"line\">    jq \\</span><br><span class=\"line\">    systemd-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.下载并提取Redis源代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.编译Redis</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意，不会自动安装模块，需要手动安装。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用GCC工具集</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src/redis-8.4.0</span><br><span class=\"line\"><span class=\"comment\"># 构建TLS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_TLS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 构建Redis模块，配不配都不会自动安装模块</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_WITH_MODULES=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 安装Rust工具链</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INSTALL_RUST_TOOLCHAIN=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭警告</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DISABLE_WERRORS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开始编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> make -j <span class=\"string\">&quot;<span class=\"subst\">$(nproc)</span>&quot;</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">./src/redis-server --version</span><br><span class=\"line\">./src/redis-cli --version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.启动Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> ./src/redis-server redis.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6.登录Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7.安装模块，可以参考如下文章中的介绍</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">\n<a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON 的安装方法\">Redis 扩展模块 -- RedisJSON 的安装方法</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2025/12/26/redis7-module-RediSearch/\" title=\"Redis 扩展模块 -- RediSearch 的安装方法\">Redis 扩展模块 -- RediSearch 的安装方法</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2026/01/07/redis7-module-RedisTimeSeries/\" title=\"Redis 扩展模块 -- RedisTimeSeries 的安装方法\">Redis 扩展模块 -- RedisTimeSeries 的安装方法</a>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Amazon Linux 2023(内核 6.1)。 Redis官网：https://redis.io/ Redis官网安装手册 Yum 安装 最省事，国内环境也可以顺利完成安装。 Amazon Linux 2023(内核 6.1) 和 Rocky Linux release 9.4 (Blue Onyx) 均成功安装。 1.添加仓库 1234567sudo tee /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;EOF[Redis]name=Redisbaseurl=http://packages.redis.io/rpm/rockylinux9enabled=1gpgcheck=1EOF 2.安装 Redis 123curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.keysudo rpm --import /tmp/redis.keysudo yum install redis -y 3.查看redis安装信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 查看已安装的redis版本$ rpm -qa | grep redisredis-8.4.0-1.x86_64# 查看redis安装信息$ rpm -qi redis-8.4.0-1.x86_64Name : redisVersion : 8.4.0Release : 1Architecture: x86_64Install Date: Wed 24 Dec 2025 06:05:22 AM UTCGroup : Applications/DatabasesSize : 83034075License :Signature : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0cSource RPM : redis-8.4.0-1.src.rpmBuild Date : Tue 18 Nov 2025 04:41:58 PM UTCBuild Host : 331d5099e900Packager : Redis Labs &lt;redis@redis.io&gt;URL : https://redis.io/Summary : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.Description :Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.# 查看redis安装的文件$ rpm -ql redis-8.4.0-1.x86_64/etc/redis/etc/redis/redis.conf/etc/redis/sentinel/etc/redis/sentinel/sentinel.conf/run/redis/run/redis/redis-server.pid/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli/usr/bin/redis-sentinel/usr/bin/redis-server/usr/lib/redis/usr/lib/redis/modules/usr/lib/redis/modules/redisbloom.so/usr/lib/redis/modules/redisearch.so/usr/lib/redis/modules/redistimeseries.so/usr/lib/redis/modules/rejson.so/usr/lib/redis/redisbloom.so/usr/lib/redis/redisearch.so/usr/lib/redis/redistimeseries.so/usr/lib/redis/rejson.so/usr/lib/systemd/system/redis-sentinel.service/usr/lib/systemd/system/redis.service/usr/share/selinux/packages/redis-ce.fc/usr/share/selinux/packages/redis-ce.te/var/lib/redis/var/log/redis/var/log/redis/redis-sentinel.log/var/log/redis/redis-server.log 4.启动redis 123sudo systemctl enable redissudo systemctl start redissudo systemctl status redis 5.登录redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array) 源码安装 1.更新环境(非必须) 1sudo dnf update -y 2.安装依赖包 12345678910111213141516171819202122sudo dnf install -y --nobest --skip-broken \\ pkg-config \\ xz \\ wget \\ which \\ git \\ make \\ openssl \\ openssl-devel \\ python3 \\ python3-pip \\ python3-devel \\ unzip \\ rsync \\ clang \\ llvm \\ curl \\ libtool \\ automake \\ autoconf \\ jq \\ systemd-devel 3.下载并提取Redis源代码 123cd /usr/srcsudo wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gzsudo tar -xzf redis-8.4.0.tar.gz 4.编译Redis 这里要注意，不会自动安装模块，需要手动安装。 1234567891011121314151617# 启用GCC工具集cd /usr/src/redis-8.4.0# 构建TLSexport BUILD_TLS=yes# 构建Redis模块，配不配都不会自动安装模块export BUILD_WITH_MODULES=yes# 安装Rust工具链export INSTALL_RUST_TOOLCHAIN=yes# 关闭警告export DISABLE_WERRORS=yes# 开始编译sudo make -j &quot;$(nproc)&quot; all# 验证./src/redis-server --version./src/redis-cli --version 5.启动Redis 1sudo ./src/redis-server redis.conf 6.登录Redis 12345678910$ ./src/redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array) 7.安装模块，可以参考如下文章中的介绍 Redis 扩展模块 -- RedisJSON 的安装方法 Redis 扩展模块 -- RedisBloom 的安装方法 Redis 扩展模块 -- RediSearch 的安装方法 Redis 扩展模块 -- RedisTimeSeries 的安装方法","summary":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Amazon Linux 2023(内核 6.1)。 Redis官网：https://redis.io/ Redis官网安装手册","date_published":"2025-12-25T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/","url":"https://blog.hanqunfeng.com/2025/12/25/redis8-install-rocky9/","title":"Rcoky9 安装 Redis8","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Linux 安装 Redis8 的方法</li>\n<li class=\"lvl-2\">Linux 版本：<code>Rocky Linux release 9.4 (Blue Onyx)</code>。</li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\"><a href=\"https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/rpm/\">Redis官网安装手册</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Yum-安装\">Yum 安装</h2>\n<blockquote>\n<p>最省事，国内环境也可以顺利完成安装。<br>\n<code>Amazon Linux 2023(内核 6.1)</code> 和 <code>Rocky Linux release 9.4 (Blue Onyx)</code> 均成功安装。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Redis]</span></span><br><span class=\"line\"><span class=\"string\">name=Redis</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://packages.redis.io/rpm/rockylinux9</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装 Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> rpm --import /tmp/redis.key</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install redis -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.查看redis安装信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看已安装的redis版本</span></span><br><span class=\"line\">$ rpm -qa | grep redis</span><br><span class=\"line\">redis-8.4.0-1.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装信息</span></span><br><span class=\"line\">$ rpm -qi redis-8.4.0-1.x86_64</span><br><span class=\"line\">Name        : redis</span><br><span class=\"line\">Version     : 8.4.0</span><br><span class=\"line\">Release     : 1</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: Wed 24 Dec 2025 06:05:22 AM UTC</span><br><span class=\"line\">Group       : Applications/Databases</span><br><span class=\"line\">Size        : 83034075</span><br><span class=\"line\">License     :</span><br><span class=\"line\">Signature   : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0c</span><br><span class=\"line\">Source RPM  : redis-8.4.0-1.src.rpm</span><br><span class=\"line\">Build Date  : Tue 18 Nov 2025 04:41:58 PM UTC</span><br><span class=\"line\">Build Host  : 331d5099e900</span><br><span class=\"line\">Packager    : Redis Labs &lt;redis@redis.io&gt;</span><br><span class=\"line\">URL         : https://redis.io/</span><br><span class=\"line\">Summary     : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看redis安装的文件</span></span><br><span class=\"line\">$ rpm -ql redis-8.4.0-1.x86_64</span><br><span class=\"line\">/etc/redis</span><br><span class=\"line\">/etc/redis/redis.conf</span><br><span class=\"line\">/etc/redis/sentinel</span><br><span class=\"line\">/etc/redis/sentinel/sentinel.conf</span><br><span class=\"line\">/run/redis</span><br><span class=\"line\">/run/redis/redis-server.pid</span><br><span class=\"line\">/usr/bin/redis-benchmark</span><br><span class=\"line\">/usr/bin/redis-check-aof</span><br><span class=\"line\">/usr/bin/redis-check-rdb</span><br><span class=\"line\">/usr/bin/redis-cli</span><br><span class=\"line\">/usr/bin/redis-sentinel</span><br><span class=\"line\">/usr/bin/redis-server</span><br><span class=\"line\">/usr/lib/redis</span><br><span class=\"line\">/usr/lib/redis/modules</span><br><span class=\"line\">/usr/lib/redis/modules/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/modules/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/modules/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/modules/rejson.so</span><br><span class=\"line\">/usr/lib/redis/redisbloom.so</span><br><span class=\"line\">/usr/lib/redis/redisearch.so</span><br><span class=\"line\">/usr/lib/redis/redistimeseries.so</span><br><span class=\"line\">/usr/lib/redis/rejson.so</span><br><span class=\"line\">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class=\"line\">/usr/lib/systemd/system/redis.service</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.fc</span><br><span class=\"line\">/usr/share/selinux/packages/redis-ce.te</span><br><span class=\"line\">/var/lib/redis</span><br><span class=\"line\">/var/log/redis</span><br><span class=\"line\">/var/log/redis/redis-sentinel.log</span><br><span class=\"line\">/var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启动redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start redis</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/lib/redis/modules/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<h2 id=\"源码安装\">源码安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.添加仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/yum.repos.d/goreleaser.repo &gt; /dev/null &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[goreleaser]</span></span><br><span class=\"line\"><span class=\"string\">name=GoReleaser</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://repo.goreleaser.com/yum/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf clean all</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf makecache</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf update -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.安装依赖包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y --nobest --skip-broken \\</span><br><span class=\"line\">    pkg-config \\</span><br><span class=\"line\">    xz \\</span><br><span class=\"line\">    wget \\</span><br><span class=\"line\">    <span class=\"built_in\">which</span> \\</span><br><span class=\"line\">    gcc-toolset-13-gcc \\</span><br><span class=\"line\">    gcc-toolset-13-gcc-c++ \\</span><br><span class=\"line\">    git \\</span><br><span class=\"line\">    make \\</span><br><span class=\"line\">    openssl \\</span><br><span class=\"line\">    openssl-devel \\</span><br><span class=\"line\">    python3 \\</span><br><span class=\"line\">    python3-pip \\</span><br><span class=\"line\">    python3-devel \\</span><br><span class=\"line\">    unzip \\</span><br><span class=\"line\">    rsync \\</span><br><span class=\"line\">    clang \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    libtool \\</span><br><span class=\"line\">    automake \\</span><br><span class=\"line\">    autoconf \\</span><br><span class=\"line\">    jq \\</span><br><span class=\"line\">    systemd-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.创建一个Python虚拟环境</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> python3 -m venv /opt/venv</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.启用GCC工具集</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> /opt/rh/gcc-toolset-13/enable /etc/profile.d/gcc-toolset-13.sh</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /etc/profile.d/gcc-toolset-13.sh&quot;</span> | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> -a /etc/bashrc</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.安装CMake</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMAKE_VERSION=3.25.1</span><br><span class=\"line\">ARCH=$(<span class=\"built_in\">uname</span> -m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$ARCH</span>&quot;</span> = <span class=\"string\">&quot;x86_64&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  CMAKE_FILE=cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>-linux-x86_64.sh</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  CMAKE_FILE=cmake-<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>-linux-aarch64.sh</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget https://github.com/Kitware/CMake/releases/download/v<span class=\"variable\">$&#123;CMAKE_VERSION&#125;</span>/<span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> +x <span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> ./<span class=\"variable\">$&#123;CMAKE_FILE&#125;</span> --skip-license --prefix=/usr/local --exclude-subdir</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;CMAKE_FILE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/local/bin</span><br><span class=\"line\">cmake --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6.下载并提取Redis源代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> tar -xzf redis-8.4.0.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7.编译Redis</p>\n</li>\n</ul>\n<blockquote>\n<p>国内环境安装时因为需要从GitHub下载模块，速度很慢，而且经常失败，建议安装时先不要安装模块，安装好redis后再按需安装模块。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用GCC工具集</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/gcc-toolset-13.sh</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/src/redis-8.4.0</span><br><span class=\"line\"><span class=\"comment\"># 构建TLS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_TLS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 构建Redis模块，如果不安装模块，则不需要此参数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> BUILD_WITH_MODULES=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 安装Rust工具链</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INSTALL_RUST_TOOLCHAIN=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭警告</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DISABLE_WERRORS=<span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开始编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> make -j <span class=\"string\">&quot;<span class=\"subst\">$(nproc)</span>&quot;</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">./src/redis-server --version</span><br><span class=\"line\">./src/redis-cli --version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>8.启动Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> ./src/redis-server redis-full.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>9.登录Redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;search&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80402</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisearch/redisearch.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;vectorset&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">3) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisjson/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">4) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redisbloom/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">5) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;timeseries&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 80400</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;./modules/redistimeseries/redistimeseries.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>10.安装模块，如果安装时没有安装模块，可以参考如下文章中的介绍</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">\n<a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON 的安装方法\">Redis 扩展模块 -- RedisJSON 的安装方法</a>\n</li>\n<li class=\"lvl-5\">\n<a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a>\n</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Rocky Linux release 9.4 (Blue Onyx)。 Redis官网：https://redis.io/ Redis官网安装手册 Yum 安装 最省事，国内环境也可以顺利完成安装。 Amazon Linux 2023(内核 6.1) 和 Rocky Linux release 9.4 (Blue Onyx) 均成功安装。 1.添加仓库 1234567sudo tee /etc/yum.repos.d/redis.repo &gt; /dev/null &lt;&lt;EOF[Redis]name=Redisbaseurl=http://packages.redis.io/rpm/rockylinux9enabled=1gpgcheck=1EOF 2.安装 Redis 123curl -fsSL https://packages.redis.io/gpg &gt; /tmp/redis.keysudo rpm --import /tmp/redis.keysudo yum install redis -y 3.查看redis安装信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 查看已安装的redis版本$ rpm -qa | grep redisredis-8.4.0-1.x86_64# 查看redis安装信息$ rpm -qi redis-8.4.0-1.x86_64Name : redisVersion : 8.4.0Release : 1Architecture: x86_64Install Date: Wed 24 Dec 2025 06:05:22 AM UTCGroup : Applications/DatabasesSize : 83034075License :Signature : RSA/SHA512, Mon 01 Dec 2025 12:05:10 PM UTC, Key ID 5f4349d6bf53aa0cSource RPM : redis-8.4.0-1.src.rpmBuild Date : Tue 18 Nov 2025 04:41:58 PM UTCBuild Host : 331d5099e900Packager : Redis Labs &lt;redis@redis.io&gt;URL : https://redis.io/Summary : Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.Description :Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.# 查看redis安装的文件$ rpm -ql redis-8.4.0-1.x86_64/etc/redis/etc/redis/redis.conf/etc/redis/sentinel/etc/redis/sentinel/sentinel.conf/run/redis/run/redis/redis-server.pid/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli/usr/bin/redis-sentinel/usr/bin/redis-server/usr/lib/redis/usr/lib/redis/modules/usr/lib/redis/modules/redisbloom.so/usr/lib/redis/modules/redisearch.so/usr/lib/redis/modules/redistimeseries.so/usr/lib/redis/modules/rejson.so/usr/lib/redis/redisbloom.so/usr/lib/redis/redisearch.so/usr/lib/redis/redistimeseries.so/usr/lib/redis/rejson.so/usr/lib/systemd/system/redis-sentinel.service/usr/lib/systemd/system/redis.service/usr/share/selinux/packages/redis-ce.fc/usr/share/selinux/packages/redis-ce.te/var/lib/redis/var/log/redis/var/log/redis/redis-sentinel.log/var/log/redis/redis-server.log 4.启动redis 123sudo systemctl enable redissudo systemctl start redissudo systemctl status redis 5.登录redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;/usr/lib/redis/modules/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array) 源码安装 1.添加仓库 1234567891011sudo tee /etc/yum.repos.d/goreleaser.repo &gt; /dev/null &lt;&lt;EOF[goreleaser]name=GoReleaserbaseurl=https://repo.goreleaser.com/yum/enabled=1gpgcheck=0EOFsudo dnf clean allsudo dnf makecachesudo dnf update -y 2.安装依赖包 1234567891011121314151617181920212223sudo dnf install -y --nobest --skip-broken \\ pkg-config \\ xz \\ wget \\ which \\ gcc-toolset-13-gcc \\ gcc-toolset-13-gcc-c++ \\ git \\ make \\ openssl \\ openssl-devel \\ python3 \\ python3-pip \\ python3-devel \\ unzip \\ rsync \\ clang \\ curl \\ libtool \\ automake \\ autoconf \\ jq \\ systemd-devel 3.创建一个Python虚拟环境 1sudo python3 -m venv /opt/venv 4.启用GCC工具集 12sudo cp /opt/rh/gcc-toolset-13/enable /etc/profile.d/gcc-toolset-13.shecho &quot;source /etc/profile.d/gcc-toolset-13.sh&quot; | sudo tee -a /etc/bashrc 5.安装CMake 12345678910111213141516CMAKE_VERSION=3.25.1ARCH=$(uname -m)if [ &quot;$ARCH&quot; = &quot;x86_64&quot; ]; then CMAKE_FILE=cmake-$&#123;CMAKE_VERSION&#125;-linux-x86_64.shelse CMAKE_FILE=cmake-$&#123;CMAKE_VERSION&#125;-linux-aarch64.shfisudo wget https://github.com/Kitware/CMake/releases/download/v$&#123;CMAKE_VERSION&#125;/$&#123;CMAKE_FILE&#125;sudo chmod +x $&#123;CMAKE_FILE&#125;sudo ./$&#123;CMAKE_FILE&#125; --skip-license --prefix=/usr/local --exclude-subdirsudo rm $&#123;CMAKE_FILE&#125;export PATH=$PATH:/usr/local/bincmake --version 6.下载并提取Redis源代码 123cd /usr/srcsudo wget -O redis-8.4.0.tar.gz https://github.com/redis/redis/archive/refs/tags/8.4.0.tar.gzsudo tar -xzf redis-8.4.0.tar.gz 7.编译Redis 国内环境安装时因为需要从GitHub下载模块，速度很慢，而且经常失败，建议安装时先不要安装模块，安装好redis后再按需安装模块。 123456789101112131415161718# 启用GCC工具集source /etc/profile.d/gcc-toolset-13.shcd /usr/src/redis-8.4.0# 构建TLSexport BUILD_TLS=yes# 构建Redis模块，如果不安装模块，则不需要此参数export BUILD_WITH_MODULES=yes# 安装Rust工具链export INSTALL_RUST_TOOLCHAIN=yes# 关闭警告export DISABLE_WERRORS=yes# 开始编译sudo make -j &quot;$(nproc)&quot; all# 验证./src/redis-server --version./src/redis-cli --version 8.启动Redis 1sudo ./src/redis-server redis-full.conf 9.登录Redis 123456789101112131415161718192021222324252627282930313233343536373839404142$ ./src/redis-cli127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;search&quot; 3) &quot;ver&quot; 4) (integer) 80402 5) &quot;path&quot; 6) &quot;./modules/redisearch/redisearch.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;vectorset&quot; 3) &quot;ver&quot; 4) (integer) 1 5) &quot;path&quot; 6) &quot;&quot; 7) &quot;args&quot; 8) (empty array)3) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redisjson/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)4) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redisbloom/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)5) 1) &quot;name&quot; 2) &quot;timeseries&quot; 3) &quot;ver&quot; 4) (integer) 80400 5) &quot;path&quot; 6) &quot;./modules/redistimeseries/redistimeseries.so&quot; 7) &quot;args&quot; 8) (empty array) 10.安装模块，如果安装时没有安装模块，可以参考如下文章中的介绍 Redis 扩展模块 -- RedisJSON 的安装方法 Redis 扩展模块 -- RedisBloom 的安装方法","summary":"摘要 本文介绍 Linux 安装 Redis8 的方法 Linux 版本：Rocky Linux release 9.4 (Blue Onyx)。 Redis官网：https://redis.io/ Redis官网安装手册","date_published":"2025-12-25T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/","url":"https://blog.hanqunfeng.com/2025/12/24/redis7-datatype-16-JSON/","title":"Redis 命令及数据类型 -- JSON","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisJSON 的安装参见 <a href=\"/2025/12/24/redis7-module-RedisJSON/\" title=\"Redis 扩展模块 -- RedisJSON 的安装方法\">Redis 扩展模块 -- RedisJSON 的安装方法</a></li>\n<li class=\"lvl-2\">示例代码：<a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/redis-demo/redisson-demo\">GitHub</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"JSON-vs-String\">JSON vs String</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis JSON存储数据的性能更高。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Redis JSON 底层其实是以一种高效的二进制的格式存储。</li>\n<li class=\"lvl-6\">相比简单的文本格式，二进制格式进行 JOSN 格式读写的性能更高，也更节省内存。</li>\n<li class=\"lvl-6\">根据官网的性能测试报告，使用 Redis JSON 读写 JSON数据，性能已经能够媲美 MongoDB 以及 ElasticSearch 等传统 NoSQL 数据库。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Redis JSON 使用树状结构来存储JSON。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">这种存储方式可以快速访问子元素。</li>\n<li class=\"lvl-6\">与传统的文本存储方案相比，树状存储结构能够更高效的执行查询操作。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>与Redis生态集成度高。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">作为Redis的扩展模块，Redis JSON 和Redis的其他功能和工具无缝集成。</li>\n<li class=\"lvl-6\">这意味着开发者可以继续使用TTL、Redis事务、发布/订阅、Lua脚本等功能。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JSONPath\">JSONPath</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSONPath 是一种用于查询和修改 JSON 数据的语法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>JSONPath 语法</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语法元素</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>$</code></td>\n<td>根节点（最外层 JSON 元素），JSONPath 的起点</td>\n<td><code>$</code>、<code>$.user.name</code></td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>访问子字段（对象属性访问）</td>\n<td><code>$.user.age</code></td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td>子元素选择器（字段名或数组索引）</td>\n<td><code>$['user']['name']</code></td>\n</tr>\n<tr>\n<td><code>..</code></td>\n<td>递归下降，遍历所有层级的节点</td>\n<td><code>$..id</code></td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>通配符，匹配当前层级的所有元素</td>\n<td><code>$.users[*]</code></td>\n</tr>\n<tr>\n<td><code>[index]</code></td>\n<td>数组下标访问（支持负索引）</td>\n<td><code>$.scores[0]</code></td>\n</tr>\n<tr>\n<td><code>[a,b,c]</code></td>\n<td>联合选择，返回多个指定元素</td>\n<td><code>$.scores[0,2,4]</code></td>\n</tr>\n<tr>\n<td><code>[start:end:step]</code></td>\n<td>数组切片（起始索引 : 结束索引 : 步长）</td>\n<td><code>$.scores[1:5:2]</code></td>\n</tr>\n<tr>\n<td><code>[*]</code></td>\n<td>选择数组中的所有元素</td>\n<td><code>$.items[*]</code></td>\n</tr>\n<tr>\n<td><code>[:]</code></td>\n<td>选择数组中的所有元素（切片写法）</td>\n<td><code>$.items[:]</code></td>\n</tr>\n<tr>\n<td><code>?()</code></td>\n<td>过滤表达式，用于数组或对象的条件筛选</td>\n<td><code>$.users[?(@.age&gt;=18)]</code></td>\n</tr>\n<tr>\n<td><code>()</code></td>\n<td>脚本表达式，用于计算或复杂逻辑判断</td>\n<td><code>$.items[?((@.a+@.b)&gt;10)]</code></td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>当前元素引用，常用于过滤或脚本表达式中</td>\n<td><code>@.price&lt;100</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数组切片 <code>[start:end:step]</code> 详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[3:]</code></td>\n<td>从索引 3 到末尾</td>\n</tr>\n<tr>\n<td><code>[:8]</code></td>\n<td>从头到索引 7</td>\n</tr>\n<tr>\n<td><code>[:8:2]</code></td>\n<td>从头到 7，每隔 2 个取一个</td>\n</tr>\n<tr>\n<td><code>[::]</code></td>\n<td>等价于 <code>[:]</code>，取全部</td>\n</tr>\n<tr>\n<td><code>[*]</code></td>\n<td>推荐写法，取全部</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>默认值规则：<br>\nstart 默认 0<br>\nend 默认数组末尾<br>\nstep 默认 1</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>过滤表达式 <code>?()</code> 支持的运算符</p>\n</li>\n</ul>\n<blockquote>\n<p>比较运算符，实测中仅支持数字比较，且注意两边不能有空格</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>==</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>!=</code></td>\n<td>不等于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>=~</code></td>\n<td>正则匹配</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>逻辑运算符</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>与</td>\n</tr>\n<tr>\n<td><code>||</code></td>\n<td>或</td>\n</tr>\n<tr>\n<td><code>()</code></td>\n<td>分组优先级</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 的 RedisJSON 模块（提供 JSON 操作功能）支持的 JSONPath 语法是受限的子集，尤其是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">❌ 不支持复杂表达式</li>\n<li class=\"lvl-6\">❌ 不支持嵌套数组条件（@.items[*].xxx）</li>\n<li class=\"lvl-6\">⚠️ 对 ?() 的支持非常有限</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>如果需要复杂的查询推荐使用 <code>RediSearch</code> 模块，这个我们后面的章节会介绍。</p>\n</li>\n</ul>\n<h2 id=\"JSON-命令\">JSON 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON 命令 汇总</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基础读写</td>\n<td>SET / MSET / GET / MGET</td>\n</tr>\n<tr>\n<td>数组操作</td>\n<td>ARRAPPEND / ARRINSERT / ARRPOP / ARRLEN / ARRINDEX / ARRTRIM</td>\n</tr>\n<tr>\n<td>对象操作</td>\n<td>OBJKEYS / OBJLEN / TYPE</td>\n</tr>\n<tr>\n<td>数值运算</td>\n<td>NUMINCRBY / NUMMULTBY / TOGGLE</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>STRAPPEND / STRLEN</td>\n</tr>\n<tr>\n<td>删除清空</td>\n<td>DEL / FORGET / CLEAR</td>\n</tr>\n<tr>\n<td>合并输出</td>\n<td>MERGE / RESP</td>\n</tr>\n<tr>\n<td>调试诊断</td>\n<td>DEBUG / DEBUG MEMORY</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一、基础读写类（CRUD）\">一、基础读写类（CRUD）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>关键参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.SET</td>\n<td>设置或更新某个 path 的值</td>\n<td><code>key</code>：键名<br><code>path</code>：JSONPath（如 <code>$</code>、<code>$.a.b</code>）<br><code>value</code>：JSON 值</td>\n<td><code>JSON.SET user:1 $ '&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;'</code></td>\n</tr>\n<tr>\n<td>JSON.MSET</td>\n<td>批量设置多个 key</td>\n<td><code>(key path value)...</code></td>\n<td><code>JSON.MSET k1 $ '&#123;&quot;a&quot;:1&#125;' k2 $.b 2</code></td>\n</tr>\n<tr>\n<td>JSON.GET</td>\n<td>获取一个 key 的 JSON 值</td>\n<td><code>key</code><br><code>path...</code>：可多个</td>\n<td><code>JSON.GET user:1 $.name $.age</code></td>\n</tr>\n<tr>\n<td>JSON.MGET</td>\n<td>从多个 key 获取同一路径</td>\n<td><code>key... path</code></td>\n<td><code>JSON.MGET k1 k2 $.a</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">JSON.GET 返回 字符串化 JSON</li>\n<li class=\"lvl-6\">JSON.MGET 返回数组，对应多个 key</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、数组操作类（Array）\">二、数组操作类（Array）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.ARRAPPEND</td>\n<td>向数组末尾追加元素</td>\n<td><code>key path value...</code></td>\n<td><code>JSON.ARRAPPEND k $.tags &quot;redis&quot; &quot;json&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRINSERT</td>\n<td>在指定索引插入元素</td>\n<td><code>key path index value...</code></td>\n<td><code>JSON.ARRINSERT k $.tags 1 &quot;nosql&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRPOP</td>\n<td>删除并返回指定索引元素</td>\n<td><code>key path [index]</code></td>\n<td><code>JSON.ARRPOP k $.tags -1</code></td>\n</tr>\n<tr>\n<td>JSON.ARRLEN</td>\n<td>获取数组长度</td>\n<td><code>key path</code></td>\n<td><code>JSON.ARRLEN k $.tags</code></td>\n</tr>\n<tr>\n<td>JSON.ARRINDEX</td>\n<td>查找元素索引</td>\n<td><code>key path value</code></td>\n<td><code>JSON.ARRINDEX k $.tags &quot;redis&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.ARRTRIM</td>\n<td>截取数组区间</td>\n<td><code>key path start stop</code></td>\n<td><code>JSON.ARRTRIM k $.scores 0 9</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">索引支持负数（-1 表示最后一个）</li>\n<li class=\"lvl-6\">ARRTRIM 类似 LTRIM</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、对象操作类（Object）\">三、对象操作类（Object）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.OBJKEYS</td>\n<td>获取对象的所有 key</td>\n<td><code>key path</code></td>\n<td><code>JSON.OBJKEYS k $.user</code></td>\n</tr>\n<tr>\n<td>JSON.OBJLEN</td>\n<td>获取对象字段数量</td>\n<td><code>key path</code></td>\n<td><code>JSON.OBJLEN k $.user</code></td>\n</tr>\n<tr>\n<td>JSON.TYPE</td>\n<td>返回 path 对应值类型</td>\n<td><code>key path</code></td>\n<td><code>JSON.TYPE k $.user.name</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON.TYPE 返回类型包括：object / array / string / number / boolean / null</p>\n</li>\n</ul>\n<h3 id=\"四、数值运算类（Numeric）\">四、数值运算类（Numeric）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.NUMINCRBY</td>\n<td>数值自增</td>\n<td><code>key path number</code></td>\n<td><code>JSON.NUMINCRBY k $.count 1</code></td>\n</tr>\n<tr>\n<td>JSON.NUMMULTBY</td>\n<td>数值乘法</td>\n<td><code>key path number</code></td>\n<td><code>JSON.NUMMULTBY k $.price 0.8</code></td>\n</tr>\n<tr>\n<td>JSON.TOGGLE</td>\n<td>布尔值取反</td>\n<td><code>key path</code></td>\n<td><code>JSON.TOGGLE k $.enabled</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">保证 原子性</li>\n<li class=\"lvl-6\">常用于计数、开关状态</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、字符串操作类（String）\">五、字符串操作类（String）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.STRAPPEND</td>\n<td>追加字符串</td>\n<td><code>key path value</code></td>\n<td><code>JSON.STRAPPEND k $.msg &quot; world&quot;</code></td>\n</tr>\n<tr>\n<td>JSON.STRLEN</td>\n<td>字符串长度</td>\n<td><code>key path</code></td>\n<td><code>JSON.STRLEN k $.msg</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"六、删除-清空类\">六、删除 / 清空类</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.DEL</td>\n<td>删除指定 path</td>\n<td><code>key path</code></td>\n<td><code>JSON.DEL k $.user.age</code></td>\n</tr>\n<tr>\n<td>JSON.FORGET</td>\n<td>等价 JSON.DEL</td>\n<td>同上</td>\n<td><code>JSON.FORGET k $.tmp</code></td>\n</tr>\n<tr>\n<td>JSON.CLEAR</td>\n<td>清空值</td>\n<td><code>key path</code></td>\n<td><code>JSON.CLEAR k $.list</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>JSON.CLEAR 行为说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">数组 → []</li>\n<li class=\"lvl-6\">对象 → {}</li>\n<li class=\"lvl-6\">数值 → 0</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、合并与高级操作\">七、合并与高级操作</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.MERGE</td>\n<td>合并 JSON（RFC7396）</td>\n<td><code>key path value</code></td>\n<td><code>JSON.MERGE k $ '&#123;&quot;a&quot;:2,&quot;b&quot;:3&#125;'</code></td>\n</tr>\n<tr>\n<td>JSON.RESP</td>\n<td>RESP 格式返回</td>\n<td><code>key path</code></td>\n<td><code>JSON.RESP k $.user</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">MERGE 支持字段覆盖、删除、扩展</li>\n<li class=\"lvl-6\">RESP 适合客户端直接解析</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"八、调试与诊断类（Debug）\">八、调试与诊断类（Debug）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSON.DEBUG</td>\n<td>调试命令容器</td>\n<td>子命令</td>\n<td><code>JSON.DEBUG MEMORY k</code></td>\n</tr>\n<tr>\n<td>JSON.DEBUG MEMORY</td>\n<td>查看 JSON 占用内存</td>\n<td><code>key</code></td>\n<td><code>JSON.DEBUG MEMORY user:1</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"应用示例\">应用示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景选用：电商用户画像 + 订单系统（结构复杂、字段多、非常适合 JSONPath）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们要存储一个用户的完整画像：</span><br><span class=\"line\">    基本信息</span><br><span class=\"line\">    地址列表</span><br><span class=\"line\">    订单列表（包含商品、价格、数量）</span><br><span class=\"line\">    标签(偏好)</span><br><span class=\"line\">    账户状态</span><br><span class=\"line\">    统计信息</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot暂时没有支持RedisJSON，你可以编写Lua脚本来实现相应的功能，另外 <a href=\"https://redisson.pro/docs/data-and-services/objects/#json-object-holder\">Redisson</a>已经提供了对JSON的支持，但是实际使用中发现还有一些Bug，下面结合命令给出代码示例。</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.52.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建完整 JSON 文档（JSON.SET）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 JSON 文档，实际执行中不支持多行，这里只是为了看着清楚些，实际运行时要将其改成一行</span></span><br><span class=\"line\">JSON.SET user:10001 $ <span class=\"string\">&#x27;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;profile&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;age&quot;: 28,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;vip&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;addresses&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;orders&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;orderId&quot;: &quot;O1001&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;amount&quot;: 199.99,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;status&quot;: &quot;PAID&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">      &quot;orderId&quot;: &quot;O1002&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;amount&quot;: 59.90,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;status&quot;: &quot;CREATED&quot;,</span></span><br><span class=\"line\"><span class=\"string\">      &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">      ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;stats&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;loginCount&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;balance&quot;: 300.5</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用单行模式一点点组装</span></span><br><span class=\"line\">JSON.SET user:10001 $ <span class=\"string\">&#x27;&#123;&#125;&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.profile <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:28,&quot;vip&quot;:true&#125;&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.tags <span class=\"string\">&#x27;[&quot;vip&quot;,&quot;electronics&quot;,&quot;promotion&quot;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.addresses <span class=\"string\">&#x27;[&#123;&quot;city&quot;:&quot;Beijing&quot;,&quot;zip&quot;:&quot;100000&quot;&#125;,&#123;&quot;city&quot;:&quot;Shanghai&quot;,&quot;zip&quot;:&quot;200000&quot;&#125;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.orders <span class=\"string\">&#x27;[&#123;&quot;orderId&quot;:&quot;O1001&quot;,&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-1&quot;,&quot;price&quot;:99.99,&quot;qty&quot;:1&#125;,&#123;&quot;sku&quot;:&quot;SKU-2&quot;,&quot;price&quot;:100,&quot;qty&quot;:1&#125;]&#125;,&#123;&quot;orderId&quot;:&quot;O1002&quot;,&quot;amount&quot;:59.90,&quot;status&quot;:&quot;CREATED&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-3&quot;,&quot;price&quot;:59.90,&quot;qty&quot;:1&#125;]&#125;]&#x27;</span></span><br><span class=\"line\">JSON.SET user:10001 $.stats <span class=\"string\">&#x27;&#123;&quot;loginCount&quot;:10,&quot;balance&quot;:300.5&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> user:10001</span><br><span class=\"line\">ReJSON-RL</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">userStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            &#123;</span></span><br><span class=\"line\"><span class=\"string\">              &quot;profile&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">                &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;age&quot;: 28,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;vip&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">              &#125;,</span></span><br><span class=\"line\"><span class=\"string\">              &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;addresses&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125;</span></span><br><span class=\"line\"><span class=\"string\">              ],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;orders&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                &#123;</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;orderId&quot;: &quot;O1001&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;amount&quot;: 199.99,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;status&quot;: &quot;PAID&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">                  ]</span></span><br><span class=\"line\"><span class=\"string\">                &#125;,</span></span><br><span class=\"line\"><span class=\"string\">                &#123;</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;orderId&quot;: &quot;O1002&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;amount&quot;: 59.90,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;status&quot;: &quot;CREATED&quot;,</span></span><br><span class=\"line\"><span class=\"string\">                  &quot;items&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">                    &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125;</span></span><br><span class=\"line\"><span class=\"string\">                  ]</span></span><br><span class=\"line\"><span class=\"string\">                &#125;</span></span><br><span class=\"line\"><span class=\"string\">              ],</span></span><br><span class=\"line\"><span class=\"string\">              &quot;stats&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">                &quot;loginCount&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">                &quot;balance&quot;: 300.5</span></span><br><span class=\"line\"><span class=\"string\">              &#125;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">RJsonBucket&lt;User&gt; bucket = redissonClient.getJsonBucket(<span class=\"string\">&quot;user:10001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(User.class));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> objectMapper.readValue(userStr, User.class);</span><br><span class=\"line\">bucket.set(user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSONPath-查询示例\">JSONPath 查询示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基础路径访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取全部数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取用户信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.profile</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Alice\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:true&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取用户名</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.profile.name</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;Alice\\&quot;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;User&gt;() &#123;&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">User.<span class=\"type\">ProfileBean</span> <span class=\"variable\">profile</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;User.ProfileBean&gt;() &#123;&#125;),<span class=\"string\">&quot;profile&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;String&gt;() &#123;&#125;),<span class=\"string\">&quot;profile.name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加上 $. 前缀，返回值必须是 List&lt;T&gt;</span></span><br><span class=\"line\">List&lt;String&gt; names = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.profile.name&quot;</span>);</span><br><span class=\"line\">System.out.println(names.get(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 数组访问 &amp; 通配符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有订单ID</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[*].orderId</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;O1001\\&quot;,\\&quot;O1002\\&quot;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取所有地址的城市</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.addresses[*].city</span><br><span class=\"line\"><span class=\"string\">&quot;[\\&quot;Beijing\\&quot;,\\&quot;Shanghai\\&quot;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; orderIds = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[*].orderId&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; citys = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.addresses[*].city&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ 数组下标与切片</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取第一个订单</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取第一个和第二个订单，切片逻辑是 [start:end]， start &lt;= x &lt; end ，end不写默认为数组末尾</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0:2]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取所有订单，这里等同于 $.orders[*]</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[:]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;OrdersBean&gt; orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[0]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[0:2]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[:]&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4️⃣ 递归查询（…）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 找出所有商品价格（不管在哪一层）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $..price</span><br><span class=\"line\"><span class=\"string\">&quot;[99.99,100,59.9]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Double&gt; prices = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;Double&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$..price&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5️⃣ 条件过滤（JSONPath 核心能力）</p>\n</li>\n</ul>\n<blockquote>\n<p>✅ 支持的查询</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单金额大于100的订单，✅ 数字比较</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单中第一个商品价格大于50的订单，✅ 数组条件</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[0].price&gt;50)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 找出所有订单金额大于100并且订单中第一个商品价格大于50的订单，✅ 逻辑运算符</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]</span><br><span class=\"line\"><span class=\"string\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;OrdersBean&gt; orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.amount&gt;100)]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.items[0].price&gt;50)]&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">orders = bucket.get(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonCodec</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),<span class=\"string\">&quot;$.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>❌ 不支持的查询</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 👉 找出所有已支付订单，❌ 不支持字符串的比较</span><br><span class=\"line\">JSON.GET user:10001 $.orders[?(@.status==&quot;PAID&quot;)]</span><br><span class=\"line\"># 👉 找出所有已支付订单，❌ 不支持正则匹配</span><br><span class=\"line\">JSON.GET user:10001 $.orders[?(@.status=~&quot;PAID&quot;)]</span><br><span class=\"line\"></span><br><span class=\"line\"># 👉 找出所有订单中商品价格大于50的订单，这个就不准，❌ 不支持嵌套数组条件（@.items[*].xxx）</span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[*].price&gt;50)]</span><br><span class=\"line\">&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>6️⃣ 修改数据（JSON.SET / JSON.NUMINCRBY）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 修改用户名</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.SET user:10001 $.profile.name <span class=\"string\">&#x27;&quot;Alice Zhang&quot;&#x27;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 👉 用户登录次数 +1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.NUMINCRBY user:10001 $.stats.loginCount 1</span><br><span class=\"line\"><span class=\"string\">&quot;[11]&quot;</span> <span class=\"comment\"># 返回修改后的值</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bucket.set(<span class=\"string\">&quot;$.profile.name&quot;</span>, <span class=\"string\">&quot;Alice Zhang&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意如下方法会增加成功，但是会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\"><span class=\"comment\">// Caused by: java.lang.NumberFormatException: For input string: &quot;[11]&quot;</span></span><br><span class=\"line\">bucket.incrementAndGet(<span class=\"string\">&quot;$.stats.loginCount&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>7️⃣ 数组操作（ARRAPPEND / ARRINSERT）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 添加一个订单</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.orders <span class=\"string\">&#x27;&#123;&quot;orderId&quot;: &quot;O1003&quot;,&quot;amount&quot;: 399,&quot;status&quot;: &quot;PAID&quot;,&quot;items&quot;: [&#123; &quot;sku&quot;: &quot;SKU-9&quot;, &quot;price&quot;: 399, &quot;qty&quot;: 1 &#125;]&#125;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3 <span class=\"comment\"># 返回添加后的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 在 tags 的最后添加一个标签</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.tags <span class=\"string\">&#x27;&quot;newTag&quot;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 4 <span class=\"comment\"># 添加后的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 在 tags 中的指定位置插入一个标签</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRINSERT user:10001 $.tags 1 <span class=\"string\">&#x27;&quot;newTag2&quot;&#x27;</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 5 <span class=\"comment\"># 插入后的长度</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OrdersBean</span> <span class=\"variable\">ordersBean</span> <span class=\"operator\">=</span> OrdersBean.builder()</span><br><span class=\"line\">                .orderId(<span class=\"string\">&quot;O1003&quot;</span>)</span><br><span class=\"line\">                .amount(<span class=\"number\">399</span>)</span><br><span class=\"line\">                .status(<span class=\"string\">&quot;CREATED&quot;</span>)</span><br><span class=\"line\">                .items(List.of(</span><br><span class=\"line\">                        OrdersBean.ItemsBean.builder()</span><br><span class=\"line\">                                .sku(<span class=\"string\">&quot;SKU-9&quot;</span>)</span><br><span class=\"line\">                                .qty(<span class=\"number\">1</span>)</span><br><span class=\"line\">                                .price(<span class=\"number\">399</span>).build()</span><br><span class=\"line\">                )).build();</span><br><span class=\"line\"><span class=\"comment\">// 添加一个订单，返回添加后的长度</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> bucket.arrayAppend(<span class=\"string\">&quot;$.orders&quot;</span>, ordersBean);</span><br><span class=\"line\"></span><br><span class=\"line\">num = bucket.arrayAppend(<span class=\"string\">&quot;$.tags&quot;</span>, <span class=\"string\">&quot;newTag&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入成功，但是会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\">num = bucket.arrayInsert(<span class=\"string\">&quot;$.tags&quot;</span>, <span class=\"number\">1</span>, <span class=\"string\">&quot;newTag2&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>8️⃣ 删除 &amp; 清理操作（JSON.DEL &amp; JSON.CLEAR）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 删除用户年龄，$.profile.age 不存在了</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.DEL user:10001 $.profile.age</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 删除成功，返回0，表示路径不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 👉 清空用户所有标签，$.tags 保留，只是变成了 [] 空数组</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.CLEAR user:10001 $.tags</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 清空成功，返回0，表示路径不存在或已经清空</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">delete</span> <span class=\"operator\">=</span> bucket.delete(<span class=\"string\">&quot;$.profile.age&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">clear</span> <span class=\"operator\">=</span> bucket.clear(<span class=\"string\">&quot;$.tags&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>9️⃣ 统计数组长度</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 👉 统计用户订单的长度</span></span><br><span class=\"line\">127.0.0.1:6379&gt; JSON.ARRLEN user:10001 $.orders</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 会抛异常，应该是Redisson的bug</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> bucket.arraySize(<span class=\"string\">&quot;$.orders&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>🔟 查看 JSON 占用内存</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; JSON.DEBUG MEMORY user:10001</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1896 <span class=\"comment\"># 占用内存大小，单位字节</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">sizeInMemory</span> <span class=\"operator\">=</span> bucket.sizeInMemory();</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 的安装参见 Redis 扩展模块 -- RedisJSON 的安装方法 示例代码：GitHub JSON vs String Redis JSON存储数据的性能更高。 Redis JSON 底层其实是以一种高效的二进制的格式存储。 相比简单的文本格式，二进制格式进行 JOSN 格式读写的性能更高，也更节省内存。 根据官网的性能测试报告，使用 Redis JSON 读写 JSON数据，性能已经能够媲美 MongoDB 以及 ElasticSearch 等传统 NoSQL 数据库。 Redis JSON 使用树状结构来存储JSON。 这种存储方式可以快速访问子元素。 与传统的文本存储方案相比，树状存储结构能够更高效的执行查询操作。 与Redis生态集成度高。 作为Redis的扩展模块，Redis JSON 和Redis的其他功能和工具无缝集成。 这意味着开发者可以继续使用TTL、Redis事务、发布/订阅、Lua脚本等功能。 JSONPath JSONPath 是一种用于查询和修改 JSON 数据的语法。 JSONPath 语法 语法元素 中文说明 示例 $ 根节点（最外层 JSON 元素），JSONPath 的起点 $、$.user.name . 访问子字段（对象属性访问） $.user.age [] 子元素选择器（字段名或数组索引） $['user']['name'] .. 递归下降，遍历所有层级的节点 $..id * 通配符，匹配当前层级的所有元素 $.users[*] [index] 数组下标访问（支持负索引） $.scores[0] [a,b,c] 联合选择，返回多个指定元素 $.scores[0,2,4] [start:end:step] 数组切片（起始索引 : 结束索引 : 步长） $.scores[1:5:2] [*] 选择数组中的所有元素 $.items[*] [:] 选择数组中的所有元素（切片写法） $.items[:] ?() 过滤表达式，用于数组或对象的条件筛选 $.users[?(@.age&gt;=18)] () 脚本表达式，用于计算或复杂逻辑判断 $.items[?((@.a+@.b)&gt;10)] @ 当前元素引用，常用于过滤或脚本表达式中 @.price&lt;100 数组切片 [start:end:step] 详解 写法 含义 [3:] 从索引 3 到末尾 [:8] 从头到索引 7 [:8:2] 从头到 7，每隔 2 个取一个 [::] 等价于 [:]，取全部 [*] 推荐写法，取全部 默认值规则： start 默认 0 end 默认数组末尾 step 默认 1 过滤表达式 ?() 支持的运算符 比较运算符，实测中仅支持数字比较，且注意两边不能有空格 运算符 含义 == 等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 =~ 正则匹配 逻辑运算符 运算符 含义 &amp;&amp; 与 || 或 () 分组优先级 Redis 的 RedisJSON 模块（提供 JSON 操作功能）支持的 JSONPath 语法是受限的子集，尤其是： ❌ 不支持复杂表达式 ❌ 不支持嵌套数组条件（@.items[*].xxx） ⚠️ 对 ?() 的支持非常有限 如果需要复杂的查询推荐使用 RediSearch 模块，这个我们后面的章节会介绍。 JSON 命令 JSON 命令 汇总 分类 命令 基础读写 SET / MSET / GET / MGET 数组操作 ARRAPPEND / ARRINSERT / ARRPOP / ARRLEN / ARRINDEX / ARRTRIM 对象操作 OBJKEYS / OBJLEN / TYPE 数值运算 NUMINCRBY / NUMMULTBY / TOGGLE 字符串 STRAPPEND / STRLEN 删除清空 DEL / FORGET / CLEAR 合并输出 MERGE / RESP 调试诊断 DEBUG / DEBUG MEMORY 一、基础读写类（CRUD） 命令 作用 关键参数说明 示例 JSON.SET 设置或更新某个 path 的值 key：键名path：JSONPath（如 $、$.a.b）value：JSON 值 JSON.SET user:1 $ '&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;' JSON.MSET 批量设置多个 key (key path value)... JSON.MSET k1 $ '&#123;&quot;a&quot;:1&#125;' k2 $.b 2 JSON.GET 获取一个 key 的 JSON 值 keypath...：可多个 JSON.GET user:1 $.name $.age JSON.MGET 从多个 key 获取同一路径 key... path JSON.MGET k1 k2 $.a 说明： JSON.GET 返回 字符串化 JSON JSON.MGET 返回数组，对应多个 key 二、数组操作类（Array） 命令 作用 参数含义 示例 JSON.ARRAPPEND 向数组末尾追加元素 key path value... JSON.ARRAPPEND k $.tags &quot;redis&quot; &quot;json&quot; JSON.ARRINSERT 在指定索引插入元素 key path index value... JSON.ARRINSERT k $.tags 1 &quot;nosql&quot; JSON.ARRPOP 删除并返回指定索引元素 key path [index] JSON.ARRPOP k $.tags -1 JSON.ARRLEN 获取数组长度 key path JSON.ARRLEN k $.tags JSON.ARRINDEX 查找元素索引 key path value JSON.ARRINDEX k $.tags &quot;redis&quot; JSON.ARRTRIM 截取数组区间 key path start stop JSON.ARRTRIM k $.scores 0 9 说明： 索引支持负数（-1 表示最后一个） ARRTRIM 类似 LTRIM 三、对象操作类（Object） 命令 作用 参数说明 示例 JSON.OBJKEYS 获取对象的所有 key key path JSON.OBJKEYS k $.user JSON.OBJLEN 获取对象字段数量 key path JSON.OBJLEN k $.user JSON.TYPE 返回 path 对应值类型 key path JSON.TYPE k $.user.name JSON.TYPE 返回类型包括：object / array / string / number / boolean / null 四、数值运算类（Numeric） 命令 作用 参数说明 示例 JSON.NUMINCRBY 数值自增 key path number JSON.NUMINCRBY k $.count 1 JSON.NUMMULTBY 数值乘法 key path number JSON.NUMMULTBY k $.price 0.8 JSON.TOGGLE 布尔值取反 key path JSON.TOGGLE k $.enabled 说明： 保证 原子性 常用于计数、开关状态 五、字符串操作类（String） 命令 作用 参数说明 示例 JSON.STRAPPEND 追加字符串 key path value JSON.STRAPPEND k $.msg &quot; world&quot; JSON.STRLEN 字符串长度 key path JSON.STRLEN k $.msg 六、删除 / 清空类 命令 作用 参数说明 示例 JSON.DEL 删除指定 path key path JSON.DEL k $.user.age JSON.FORGET 等价 JSON.DEL 同上 JSON.FORGET k $.tmp JSON.CLEAR 清空值 key path JSON.CLEAR k $.list JSON.CLEAR 行为说明： 数组 → [] 对象 → {} 数值 → 0 七、合并与高级操作 命令 作用 参数说明 示例 JSON.MERGE 合并 JSON（RFC7396） key path value JSON.MERGE k $ '&#123;&quot;a&quot;:2,&quot;b&quot;:3&#125;' JSON.RESP RESP 格式返回 key path JSON.RESP k $.user 说明： MERGE 支持字段覆盖、删除、扩展 RESP 适合客户端直接解析 八、调试与诊断类（Debug） 命令 作用 参数说明 示例 JSON.DEBUG 调试命令容器 子命令 JSON.DEBUG MEMORY k JSON.DEBUG MEMORY 查看 JSON 占用内存 key JSON.DEBUG MEMORY user:1 应用示例 场景选用：电商用户画像 + 订单系统（结构复杂、字段多、非常适合 JSONPath） 1234567我们要存储一个用户的完整画像： 基本信息 地址列表 订单列表（包含商品、价格、数量） 标签(偏好) 账户状态 统计信息 SpringBoot暂时没有支持RedisJSON，你可以编写Lua脚本来实现相应的功能，另外 Redisson已经提供了对JSON的支持，但是实际使用中发现还有一些Bug，下面结合命令给出代码示例。 123456&lt;!-- 引入 Redisson ，这里要注意，现在最新版是 4.0.0，需要 springboot 4.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.52.0&lt;/version&gt;&lt;/dependency&gt; 创建完整 JSON 文档（JSON.SET） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 创建 JSON 文档，实际执行中不支持多行，这里只是为了看着清楚些，实际运行时要将其改成一行JSON.SET user:10001 $ &#x27;&#123; &quot;profile&quot;: &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28, &quot;vip&quot;: true &#125;, &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;], &quot;addresses&quot;: [ &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;, &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125; ], &quot;orders&quot;: [ &#123; &quot;orderId&quot;: &quot;O1001&quot;, &quot;amount&quot;: 199.99, &quot;status&quot;: &quot;PAID&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;, &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125; ] &#125;, &#123; &quot;orderId&quot;: &quot;O1002&quot;, &quot;amount&quot;: 59.90, &quot;status&quot;: &quot;CREATED&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125; ] &#125; ], &quot;stats&quot;: &#123; &quot;loginCount&quot;: 10, &quot;balance&quot;: 300.5 &#125;&#125;&#x27;# 也可以使用单行模式一点点组装JSON.SET user:10001 $ &#x27;&#123;&#125;&#x27;JSON.SET user:10001 $.profile &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:28,&quot;vip&quot;:true&#125;&#x27;JSON.SET user:10001 $.tags &#x27;[&quot;vip&quot;,&quot;electronics&quot;,&quot;promotion&quot;]&#x27;JSON.SET user:10001 $.addresses &#x27;[&#123;&quot;city&quot;:&quot;Beijing&quot;,&quot;zip&quot;:&quot;100000&quot;&#125;,&#123;&quot;city&quot;:&quot;Shanghai&quot;,&quot;zip&quot;:&quot;200000&quot;&#125;]&#x27;JSON.SET user:10001 $.orders &#x27;[&#123;&quot;orderId&quot;:&quot;O1001&quot;,&quot;amount&quot;:199.99,&quot;status&quot;:&quot;PAID&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-1&quot;,&quot;price&quot;:99.99,&quot;qty&quot;:1&#125;,&#123;&quot;sku&quot;:&quot;SKU-2&quot;,&quot;price&quot;:100,&quot;qty&quot;:1&#125;]&#125;,&#123;&quot;orderId&quot;:&quot;O1002&quot;,&quot;amount&quot;:59.90,&quot;status&quot;:&quot;CREATED&quot;,&quot;items&quot;:[&#123;&quot;sku&quot;:&quot;SKU-3&quot;,&quot;price&quot;:59.90,&quot;qty&quot;:1&#125;]&#125;]&#x27;JSON.SET user:10001 $.stats &#x27;&#123;&quot;loginCount&quot;:10,&quot;balance&quot;:300.5&#125;&#x27;# 查看类型127.0.0.1:6379&gt; type user:10001ReJSON-RL 通用代码 123456789101112131415161718192021222324252627282930313233343536373839404142@Autowiredprivate RedissonClient redissonClient;String userStr = &quot;&quot;&quot; &#123; &quot;profile&quot;: &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28, &quot;vip&quot;: true &#125;, &quot;tags&quot;: [&quot;vip&quot;, &quot;electronics&quot;, &quot;promotion&quot;], &quot;addresses&quot;: [ &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125;, &#123; &quot;city&quot;: &quot;Shanghai&quot;, &quot;zip&quot;: &quot;200000&quot; &#125; ], &quot;orders&quot;: [ &#123; &quot;orderId&quot;: &quot;O1001&quot;, &quot;amount&quot;: 199.99, &quot;status&quot;: &quot;PAID&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-1&quot;, &quot;price&quot;: 99.99, &quot;qty&quot;: 1 &#125;, &#123; &quot;sku&quot;: &quot;SKU-2&quot;, &quot;price&quot;: 100.00, &quot;qty&quot;: 1 &#125; ] &#125;, &#123; &quot;orderId&quot;: &quot;O1002&quot;, &quot;amount&quot;: 59.90, &quot;status&quot;: &quot;CREATED&quot;, &quot;items&quot;: [ &#123; &quot;sku&quot;: &quot;SKU-3&quot;, &quot;price&quot;: 59.90, &quot;qty&quot;: 1 &#125; ] &#125; ], &quot;stats&quot;: &#123; &quot;loginCount&quot;: 10, &quot;balance&quot;: 300.5 &#125; &#125; &quot;&quot;&quot;;ObjectMapper objectMapper = new ObjectMapper();RJsonBucket&lt;User&gt; bucket = redissonClient.getJsonBucket(&quot;user:10001&quot;, new JacksonCodec&lt;&gt;(User.class)); 12User user = objectMapper.readValue(userStr, User.class);bucket.set(user); JSONPath 查询示例 1️⃣ 基础路径访问 12345678910# 获取全部数据127.0.0.1:6379&gt; JSON.GET user:10001# 获取用户信息127.0.0.1:6379&gt; JSON.GET user:10001 $.profile&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Alice\\&quot;,\\&quot;age\\&quot;:28,\\&quot;vip\\&quot;:true&#125;]&quot;# 获取用户名127.0.0.1:6379&gt; JSON.GET user:10001 $.profile.name&quot;[\\&quot;Alice\\&quot;]&quot; 123456789User user = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;User&gt;() &#123;&#125;));User.ProfileBean profile = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;User.ProfileBean&gt;() &#123;&#125;),&quot;profile&quot;);String name = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;String&gt;() &#123;&#125;),&quot;profile.name&quot;);// 加上 $. 前缀，返回值必须是 List&lt;T&gt;List&lt;String&gt; names = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.profile.name&quot;);System.out.println(names.get(0)); 2️⃣ 数组访问 &amp; 通配符 1234567# 获取所有订单ID127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[*].orderId&quot;[\\&quot;O1001\\&quot;,\\&quot;O1002\\&quot;]&quot;# 获取所有地址的城市127.0.0.1:6379&gt; JSON.GET user:10001 $.addresses[*].city&quot;[\\&quot;Beijing\\&quot;,\\&quot;Shanghai\\&quot;]&quot; 123List&lt;String&gt; orderIds = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.orders[*].orderId&quot;);List&lt;String&gt; citys = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;),&quot;$.addresses[*].city&quot;); 3️⃣ 数组下标与切片 1234567891011# 获取第一个订单127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 获取第一个和第二个订单，切片逻辑是 [start:end]， start &lt;= x &lt; end ，end不写默认为数组末尾127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[0:2]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 获取所有订单，这里等同于 $.orders[*]127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[:]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 12345List&lt;OrdersBean&gt; orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[0]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[0:2]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[:]&quot;); 4️⃣ 递归查询（…） 123# 👉 找出所有商品价格（不管在哪一层）127.0.0.1:6379&gt; JSON.GET user:10001 $..price&quot;[99.99,100,59.9]&quot; 1List&lt;Double&gt; prices = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;Double&gt;&gt;() &#123;&#125;),&quot;$..price&quot;); 5️⃣ 条件过滤（JSONPath 核心能力） ✅ 支持的查询 1234567891011# 👉 找出所有订单金额大于100的订单，✅ 数字比较127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 👉 找出所有订单中第一个商品价格大于50的订单，✅ 数组条件127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[0].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;,&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot;# 👉 找出所有订单金额大于100并且订单中第一个商品价格大于50的订单，✅ 逻辑运算符127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1001\\&quot;,\\&quot;amount\\&quot;:199.99,\\&quot;status\\&quot;:\\&quot;PAID\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-1\\&quot;,\\&quot;price\\&quot;:99.99,\\&quot;qty\\&quot;:1&#125;,&#123;\\&quot;sku\\&quot;:\\&quot;SKU-2\\&quot;,\\&quot;price\\&quot;:100,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 12345List&lt;OrdersBean&gt; orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.amount&gt;100)]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.items[0].price&gt;50)]&quot;);orders = bucket.get(new JacksonCodec&lt;&gt;(new TypeReference&lt;List&lt;OrdersBean&gt;&gt;() &#123;&#125;),&quot;$.orders[?(@.amount&gt;100)&amp;&amp;(@.items[0].price&gt;50)]&quot;); ❌ 不支持的查询 12345678# 👉 找出所有已支付订单，❌ 不支持字符串的比较JSON.GET user:10001 $.orders[?(@.status==&quot;PAID&quot;)]# 👉 找出所有已支付订单，❌ 不支持正则匹配JSON.GET user:10001 $.orders[?(@.status=~&quot;PAID&quot;)]# 👉 找出所有订单中商品价格大于50的订单，这个就不准，❌ 不支持嵌套数组条件（@.items[*].xxx）127.0.0.1:6379&gt; JSON.GET user:10001 $.orders[?(@.items[*].price&gt;50)]&quot;[&#123;\\&quot;orderId\\&quot;:\\&quot;O1002\\&quot;,\\&quot;amount\\&quot;:59.9,\\&quot;status\\&quot;:\\&quot;CREATED\\&quot;,\\&quot;items\\&quot;:[&#123;\\&quot;sku\\&quot;:\\&quot;SKU-3\\&quot;,\\&quot;price\\&quot;:59.9,\\&quot;qty\\&quot;:1&#125;]&#125;]&quot; 6️⃣ 修改数据（JSON.SET / JSON.NUMINCRBY） 123456# 👉 修改用户名127.0.0.1:6379&gt; JSON.SET user:10001 $.profile.name &#x27;&quot;Alice Zhang&quot;&#x27;OK# 👉 用户登录次数 +1127.0.0.1:6379&gt; JSON.NUMINCRBY user:10001 $.stats.loginCount 1&quot;[11]&quot; # 返回修改后的值 1234bucket.set(&quot;$.profile.name&quot;, &quot;Alice Zhang&quot;);// 注意如下方法会增加成功，但是会抛异常，应该是Redisson的bug// Caused by: java.lang.NumberFormatException: For input string: &quot;[11]&quot;bucket.incrementAndGet(&quot;$.stats.loginCount&quot;, 1); 7️⃣ 数组操作（ARRAPPEND / ARRINSERT） 1234567891011# 👉 添加一个订单127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.orders &#x27;&#123;&quot;orderId&quot;: &quot;O1003&quot;,&quot;amount&quot;: 399,&quot;status&quot;: &quot;PAID&quot;,&quot;items&quot;: [&#123; &quot;sku&quot;: &quot;SKU-9&quot;, &quot;price&quot;: 399, &quot;qty&quot;: 1 &#125;]&#125;&#x27;1) (integer) 3 # 返回添加后的长度# 👉 在 tags 的最后添加一个标签127.0.0.1:6379&gt; JSON.ARRAPPEND user:10001 $.tags &#x27;&quot;newTag&quot;&#x27;1) (integer) 4 # 添加后的长度# 👉 在 tags 中的指定位置插入一个标签127.0.0.1:6379&gt; JSON.ARRINSERT user:10001 $.tags 1 &#x27;&quot;newTag2&quot;&#x27;1) (integer) 5 # 插入后的长度 1234567891011121314151617OrdersBean ordersBean = OrdersBean.builder() .orderId(&quot;O1003&quot;) .amount(399) .status(&quot;CREATED&quot;) .items(List.of( OrdersBean.ItemsBean.builder() .sku(&quot;SKU-9&quot;) .qty(1) .price(399).build() )).build();// 添加一个订单，返回添加后的长度long num = bucket.arrayAppend(&quot;$.orders&quot;, ordersBean);num = bucket.arrayAppend(&quot;$.tags&quot;, &quot;newTag&quot;);// 插入成功，但是会抛异常，应该是Redisson的bugnum = bucket.arrayInsert(&quot;$.tags&quot;, 1, &quot;newTag2&quot;); 8️⃣ 删除 &amp; 清理操作（JSON.DEL &amp; JSON.CLEAR） 1234567# 👉 删除用户年龄，$.profile.age 不存在了127.0.0.1:6379&gt; JSON.DEL user:10001 $.profile.age(integer) 1 # 删除成功，返回0，表示路径不存在# 👉 清空用户所有标签，$.tags 保留，只是变成了 [] 空数组127.0.0.1:6379&gt; JSON.CLEAR user:10001 $.tags(integer) 1 # 清空成功，返回0，表示路径不存在或已经清空 123long delete = bucket.delete(&quot;$.profile.age&quot;);long clear = bucket.clear(&quot;$.tags&quot;); 9️⃣ 统计数组长度 123# 👉 统计用户订单的长度127.0.0.1:6379&gt; JSON.ARRLEN user:10001 $.orders1) (integer) 3 12// 会抛异常，应该是Redisson的buglong length = bucket.arraySize(&quot;$.orders&quot;); 🔟 查看 JSON 占用内存 12127.0.0.1:6379&gt; JSON.DEBUG MEMORY user:10001(integer) 1896 # 占用内存大小，单位字节 1long sizeInMemory = bucket.sizeInMemory();","summary":"摘要 本文介绍 Redis 扩展模型 RedisJSON 中的 JSON 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 的安装参见 Redis 扩展模块 -- RedisJSON 的安装方法 示例代码：GitHub","date_published":"2025-12-24T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/","url":"https://blog.hanqunfeng.com/2025/12/24/redis7-module-RedisJSON/","title":"Redis 扩展模块 -- RedisJSON 的安装方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisJSON 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisJSON-简介\">RedisJSON 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisJSON/RedisJSON\">RedisJSON</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于对JSON数据进行操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisJSON 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n</ul>\n<h2 id=\"安装-RedisJSON\">安装 RedisJSON</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>虽然<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中提供了所有Redis模块编译后的<code>.so</code>文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>rejson.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y \\</span><br><span class=\"line\">  gcc \\</span><br><span class=\"line\">  gcc-c++ \\</span><br><span class=\"line\">  make \\</span><br><span class=\"line\">  cmake \\</span><br><span class=\"line\">  autoconf \\</span><br><span class=\"line\">  automake \\</span><br><span class=\"line\">  libtool \\</span><br><span class=\"line\">  pkgconfig \\</span><br><span class=\"line\">  openssl-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译RedisJSON</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisJSON/RedisJSON.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisJSON</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.8.16</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: 7fc8e62</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y git unzip rsync</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getrust</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getgcc --modern</span><br><span class=\"line\"><span class=\"built_in\">dir</span>=$(<span class=\"built_in\">mktemp</span> -d /tmp/tar.XXXXXX); (<span class=\"built_in\">cd</span> <span class=\"variable\">$dir</span>; wget --no-verbose -O tar.tgz http://redismodules.s3.amazonaws.com/readies/gnu/gnu-tar-1.32-x64-centos7.tgz; tar -xzf tar.tgz -C /; ); <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$dir</span></span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r /usr/local/soft/modules/RedisJSON/tests/pytest/requirements.txt</span><br><span class=\"line\">/usr/local/soft/modules/RedisJSON/deps/readies/bin/getaws</span><br><span class=\"line\">NO_PY2=1 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getpudb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RedisJSON 的编译依赖 Rust 工具链，所以编译前需要安装rust，若已经安装则忽略</span></span><br><span class=\"line\"><span class=\"comment\"># 安装 rustup</span></span><br><span class=\"line\">curl --proto <span class=\"string\">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按提示选择默认安装（通常选择 1）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 让 Rust 生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.cargo/env</span><br><span class=\"line\"><span class=\"comment\"># 检查 rust 版本</span></span><br><span class=\"line\">rustc --version <span class=\"comment\"># rustc 1.92.0 (ded5c06cf 2025-12-08)</span></span><br><span class=\"line\">cargo --version <span class=\"comment\"># cargo 1.92.0 (344c4567c 2025-10-21)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译 RedisJSON</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/rejson.so`</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">……</span><br><span class=\"line\">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\">Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisJSON/deps/readies/bin/getepel:</span><br><span class=\"line\">346      \t\t<span class=\"comment\"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class=\"line\">347      \t<span class=\"keyword\">fi</span></span><br><span class=\"line\">348</span><br><span class=\"line\">349  &gt;&gt;&gt; \tinstall_raven</span><br><span class=\"line\">350      \tinstall_remi</span><br><span class=\"line\">351      \t<span class=\"comment\"># install_centos_stream_repos</span></span><br><span class=\"line\">352</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getepel</span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisJSON/sbin/setup:</span><br><span class=\"line\">18       \tpython3 -m pip list</span><br><span class=\"line\">19       <span class=\"keyword\">fi</span></span><br><span class=\"line\">20</span><br><span class=\"line\">21   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py</span><br><span class=\"line\">22       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">23       \tpython3 -m pip list</span><br><span class=\"line\">24       <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>错误分析与解决方法：</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">\n<p>这里实际上是两个错误，第一个错误与安装 RedisBloom 时一样，禁用掉 <code>install_raven</code> 即可，具体参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a> 进行修改。</p>\n</li>\n<li class=\"lvl-6\">\n<p>第二个错误还是操作系统的事，在 <code>deps/readies/bin/getclang</code>中有一个方法，其实一看就明白了</p>\n</li>\n</ul>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">redhat_compat</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"variable language_\">self</span>.modern:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.run(<span class=\"string\">&quot;%s/bin/getepel&quot;</span> % READIES, sudo=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.dist <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;centos&#x27;</span>, <span class=\"string\">&#x27;ol&#x27;</span>] <span class=\"keyword\">and</span> <span class=\"variable language_\">self</span>.os_version[<span class=\"number\">0</span>] &gt;= <span class=\"number\">8</span>:</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.install(<span class=\"string\">&quot;clang&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.install(<span class=\"string\">&quot;llvm-toolset&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.install(<span class=\"string\">&quot;llvm-toolset-7.0&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.cp_to_profile_d(<span class=\"string\">&quot;/opt/rh/llvm-toolset-7.0/enable&quot;</span>, <span class=\"string\">&quot;llvm-toolset-7.0.sh&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>我使用的机器不是 centos，所以就走<code>else</code>的逻辑了，另外这里即便走了 centos 逻辑，也有问题，就是el9中已经没有 <code>llvm-toolset</code> 了，取而代之的是 <code>llvm</code>，所以需要修改该方法</p>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">修改方法如下：</li>\n</ul>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">redhat_compat</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"variable language_\">self</span>.modern:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.run(<span class=\"string\">&quot;%s/bin/getepel&quot;</span> % READIES, sudo=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 去掉判断，直接安装，前提是 el9，当然这里也可以什么都不写，而是通过命令行安装：dnf install -y clang llvm llvm-devel</span></span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.install(<span class=\"string\">&quot;clang&quot;</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.install(<span class=\"string\">&quot;llvm&quot;</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <code>rejson.so</code> 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要包含可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> bin/linux-x64-release/rejson.so /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 rejson.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/rejson.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; info Modules</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\">module:name=ReJSON,ver=20816,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;ReJSON&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20816</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisJSON 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisJSON 简介 RedisJSON 是 Redis 官方维护的一个扩展模块，隶属于 Redis Stack，专门用于对JSON数据进行操作。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisJSON 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 安装 RedisJSON 虽然Redis Cloud的Download Center中提供了所有Redis模块编译后的.so文件，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的rejson.so上传到国内服务器即可。 安装依赖 12345678910sudo dnf install -y \\ gcc \\ gcc-c++ \\ make \\ cmake \\ autoconf \\ automake \\ libtool \\ pkgconfig \\ openssl-devel 编译RedisJSON 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisJSON/RedisJSON.gitcd RedisJSON# 推荐切换到稳定的release版本git checkout v2.8.16# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: 7fc8e62dnf install -q -y ca-certificatesdnf install -q -y wget unzip/usr/local/soft/modules/RedisJSON/deps/readies/bin/enable-utf8dnf install -q -y git unzip rsync/usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modern/usr/local/soft/modules/RedisJSON/deps/readies/bin/getrust/usr/local/soft/modules/RedisJSON/deps/readies/bin/getcmake --usrdnf install -q -y which/usr/local/soft/modules/RedisJSON/deps/readies/bin/getgcc --moderndir=$(mktemp -d /tmp/tar.XXXXXX); (cd $dir; wget --no-verbose -O tar.tgz http://redismodules.s3.amazonaws.com/readies/gnu/gnu-tar-1.32-x64-centos7.tgz; tar -xzf tar.tgz -C /; ); rm -rf $dirdnf install -q -y lcov/usr/bin/python3 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 -m pip install --disable-pip-version-check --user -r /usr/local/soft/modules/RedisJSON/tests/pytest/requirements.txt/usr/local/soft/modules/RedisJSON/deps/readies/bin/getawsNO_PY2=1 /usr/local/soft/modules/RedisJSON/deps/readies/bin/getpudb# RedisJSON 的编译依赖 Rust 工具链，所以编译前需要安装rust，若已经安装则忽略# 安装 rustupcurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh# 按提示选择默认安装（通常选择 1）# 让 Rust 生效source $HOME/.cargo/env# 检查 rust 版本rustc --version # rustc 1.92.0 (ded5c06cf 2025-12-08)cargo --version # cargo 1.92.0 (344c4567c 2025-10-21)# 编译 RedisJSONmake# 编译过程未报错说明编译成功，编译后的文件位于 `bin/linux-x64-release/rejson.so` ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，类似于CentOS 9，第一次运行会报错，大致报错信息如下： 1234567891011121314151617181920212223242526./sbin/setup## 错误信息……[FAILED] raven-release.el9.noarch.rpm: Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)In /usr/local/soft/modules/RedisJSON/deps/readies/bin/getepel:346 # xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm347 fi348349 &gt;&gt;&gt; install_raven350 install_remi351 # install_centos_stream_repos352command failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getepelcommand failed: /usr/local/soft/modules/RedisJSON/deps/readies/bin/getclang --modernIn /usr/local/soft/modules/RedisJSON/sbin/setup:18 python3 -m pip list19 fi2021 &gt;&gt;&gt; $ROOT/sbin/system-setup.py22 if [[ $VERBOSE == 1 ]]; then23 python3 -m pip list24 fi 错误分析与解决方法： 这里实际上是两个错误，第一个错误与安装 RedisBloom 时一样，禁用掉 install_raven 即可，具体参见 Redis 扩展模块 -- RedisBloom 的安装方法 进行修改。 第二个错误还是操作系统的事，在 deps/readies/bin/getclang中有一个方法，其实一看就明白了 12345678910def redhat_compat(self): if not self.modern: return self.run(&quot;%s/bin/getepel&quot; % READIES, sudo=True) if self.dist in [&#x27;centos&#x27;, &#x27;ol&#x27;] and self.os_version[0] &gt;= 8: self.install(&quot;clang&quot;) self.install(&quot;llvm-toolset&quot;) else: self.install(&quot;llvm-toolset-7.0&quot;) self.cp_to_profile_d(&quot;/opt/rh/llvm-toolset-7.0/enable&quot;, &quot;llvm-toolset-7.0.sh&quot;) 我使用的机器不是 centos，所以就走else的逻辑了，另外这里即便走了 centos 逻辑，也有问题，就是el9中已经没有 llvm-toolset 了，取而代之的是 llvm，所以需要修改该方法 修改方法如下： 1234567def redhat_compat(self): if not self.modern: return self.run(&quot;%s/bin/getepel&quot; % READIES, sudo=True) # 去掉判断，直接安装，前提是 el9，当然这里也可以什么都不写，而是通过命令行安装：dnf install -y clang llvm llvm-devel self.install(&quot;clang&quot;) self.install(&quot;llvm&quot;) Redis 启用模块 将生成的 rejson.so 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建 12# 注意 .so 文件需要包含可执行权限cp bin/linux-x64-release/rejson.so /usr/local/soft/redis-7.4.7/modules/rejson.so 本文采用 loadmodule 加载模块 12345678910111213141516171819202122232425262728293031323334# 将 rejson.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/rejson.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; info Modules## 输出# Modulesmodule:name=ReJSON,ver=20816,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;ReJSON&quot; 3) &quot;ver&quot; 4) (integer) 20816 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/rejson.so&quot; 7) &quot;args&quot; 8) (empty array)2) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisJSON 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-24T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-15-TDigest/","title":"Redis 命令及数据类型 -- TDigest","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"T-Digest-分位数估计算法\">T-Digest(分位数估计算法)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>T-Digest（TDigest）解决的问题与 CMS、TopK 完全不同，核心目标是 分位数（quantile）统计。</p>\n</li>\n<li class=\"lvl-2\">\n<p>T-Digest 由 Ted Dunning 提出，专门为 <code>高精度尾部分位数</code> 设计。</p>\n</li>\n<li class=\"lvl-2\">\n<p>TDigest 可以在极低内存占用下，近似计算分位数（P50 / P90 / P99 / Median 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>分位数（Percentile）指标对照表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>英文全称</th>\n<th>数学含义</th>\n<th>通俗解释</th>\n<th>典型业务解读</th>\n<th>常见使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Median</td>\n<td>Median</td>\n<td>排序后位于中间位置的值</td>\n<td>一半数据在它左右</td>\n<td>“一般用户的体验”</td>\n<td>基础体验评估</td>\n</tr>\n<tr>\n<td>P50</td>\n<td>50th Percentile</td>\n<td>50% 的数据 ≤ 该值</td>\n<td>和 Median 完全相同</td>\n<td>“典型请求耗时”</td>\n<td>常规性能监控</td>\n</tr>\n<tr>\n<td>P90</td>\n<td>90th Percentile</td>\n<td>90% 的数据 ≤ 该值</td>\n<td>10% 的请求更慢</td>\n<td>“大多数用户的体验”</td>\n<td>业务体验监控</td>\n</tr>\n<tr>\n<td>P95</td>\n<td>95th Percentile</td>\n<td>95% 的数据 ≤ 该值</td>\n<td>5% 的请求更慢</td>\n<td>“尾部开始恶化”</td>\n<td>SLA 边界监控</td>\n</tr>\n<tr>\n<td>P99</td>\n<td>99th Percentile</td>\n<td>99% 的数据 ≤ 该值</td>\n<td>1% 的请求最慢</td>\n<td>“极端但真实的用户体验”</td>\n<td>核心 SLA / SLO</td>\n</tr>\n<tr>\n<td>P99.9</td>\n<td>99.9th Percentile</td>\n<td>99.9% 的数据 ≤ 该值</td>\n<td>千分之一最慢请求</td>\n<td>“极端尾延迟”</td>\n<td>金融 / 核心链路</td>\n</tr>\n<tr>\n<td>Max</td>\n<td>Maximum</td>\n<td>数据中的最大值</td>\n<td>最慢的那一次</td>\n<td>噪音极大</td>\n<td>几乎不用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>一个快速理解示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设 100 次请求：</span><br><span class=\"line\">    99 次耗时：10 ms</span><br><span class=\"line\">    1 次耗时：3000 ms</span><br><span class=\"line\"></span><br><span class=\"line\">所以：</span><br><span class=\"line\">    P99 = 3000 ms</span><br><span class=\"line\">    P90 = 10 ms</span><br><span class=\"line\">    P50/Median = 10 ms</span><br><span class=\"line\">    平均值 = （99*10 + 1*3000）/ 100 = 39.9 ms</span><br><span class=\"line\"></span><br><span class=\"line\">👉 只有 P99 真实暴露了问题。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>工程实践中的“标准搭配”</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>应用场景</th>\n<th>常看指标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web / API 服务</td>\n<td>P90 / P99</td>\n</tr>\n<tr>\n<td>微服务链路</td>\n<td>P99 / P99.9</td>\n</tr>\n<tr>\n<td>数据库 / 存储</td>\n<td>P95 / P99</td>\n</tr>\n<tr>\n<td>前端体验</td>\n<td>P50 / P90</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一句话：TDigest 用于统计数字的分布，P50 看中间，P90 看大多数，P99 看最差那 1%</p>\n</li>\n</ul>\n<h2 id=\"RedisBloom-中-TDigest-的核心命令\">RedisBloom 中 TDigest 的核心命令</h2>\n<h3 id=\"创建-TDigest\">创建 TDigest</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.CREATE key [COMPRESSION compression]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.CREATE latency:td COMPRESSION 200</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取 TDigest 的类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">TDIS-TYPE</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加样本\">添加样本</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.ADD key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.ADD latency:td 12.3 15.7 100.4</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看最大-最小值\">查看最大/最小值</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取最大值</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.MAX key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MAX latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\"><span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取最小值</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.MIN key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MIN latency:td</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\"><span class=\"string\">&quot;12.3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询分位数\">查询分位数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.QUANTILE key quantile [quantile ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># quantile： 查询的分位数，0.5=&gt;P50 / 0.9=&gt;P90 / 0.99=&gt;P99</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.QUANTILE latency:td 0.5 0.9 0.99</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;15.7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;100.4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"反向查询（值-→-百分位）\">反向查询（值 → 百分位）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.CDF key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.CDF latency:td 12.3 15.7 100.4 20</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;0.16666666666666666&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;0.5&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;0.8333333333333334&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;0.6666666666666666&quot;</span>  <span class=\"comment\"># 这里注意 value 不必须在 TDIGEST 中，这里的含义是 P66=20，即 66% 的值都 ≤ 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"合并-TDigest\">合并 TDigest</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.MERGE destination-key numkeys source-key [source-key ...] [COMPRESSION compression] [OVERRIDE]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># destination-key： 目标 TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># numkeys： 源 TDigest 的数量</span></span><br><span class=\"line\"><span class=\"comment\"># source-key： 源 TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大</span></span><br><span class=\"line\"><span class=\"comment\"># OVERRIDE： 是否覆盖目标 TDigest，默认为 false</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.MERGE latency:td 2 latency:td:1 latency:td:2 COMPRESSION 200 OVERRIDE</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取近似排名\">获取近似排名</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.RANK key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.ADD latency:td 12.3 15.7 100.4 # 假设这些数据已经写入了 TDigest</span></span><br><span class=\"line\"><span class=\"comment\"># 如果把 value 放入当前分布中，它的 rank（小于该值的样本数量）是多少</span></span><br><span class=\"line\">TDIGEST.RANK latency:td 0 12.3 15.7 20 100.4 200</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) -1   <span class=\"comment\"># 0: 小于最小值 12.3 → 返回 -1</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0    <span class=\"comment\"># 12.3: 第 0 位 → 返回 0，真实存在的位数</span></span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1    <span class=\"comment\"># 15.7: 排在 12.3 后 → 返回 1，真实存在的位数</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 2    <span class=\"comment\"># 20: 介于 15.7 与 100.4 之间 → 返回 2</span></span><br><span class=\"line\">5) (<span class=\"built_in\">integer</span>) 2    <span class=\"comment\"># 100.4: 第 2 位 → 20，真实存在的位数</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 3    <span class=\"comment\"># 200: 大于 100.4 → 返回 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 反向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.REVRANK key value [value ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.REVRANK latency:td 0 12.3 15.7 20 100.4 200</span><br></pre></td></tr></table></figure>\n<h2 id=\"根据排名获取元素\">根据排名获取元素</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.BYRANK key rank [rank ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.BYRANK latency:td 0 1 2 3</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;12.3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;15.7&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;100.4&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;inf&quot;</span>  <span class=\"comment\"># 不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 反向排名</span></span><br><span class=\"line\"><span class=\"comment\"># TDIGEST.BYREVRANK key rank [rank ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.BYREVRANK latency:td 0 1 2 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"计算-TDigest-内部样本-去掉尾部极值后的平均近似值（Trimmed-Mean，截断均值）\">计算 TDigest 内部样本 去掉尾部极值后的平均近似值（Trimmed Mean，截断均值）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉数据分布的极端尾部，只算主要集中区域的平均值，这样更能代表“绝大多数用户的体验”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.TRIMMED_MEAN key low_cut_quantile high_cut_quantile</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key： TDigest 的名称</span></span><br><span class=\"line\"><span class=\"comment\"># low_cut_quantile： 去掉的左侧百分比</span></span><br><span class=\"line\"><span class=\"comment\"># high_cut_quantile： 去掉的右侧百分比</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.TRIMMED_MEAN latency:td 0.05 0.95</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;42.800000000000004&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-TDigest-的信息\">获取 TDigest 的信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.INFO key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.INFO latency:td</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"> 1) Compression     <span class=\"comment\"># 压缩级别，控制质心的数量与精度。值越大 → 精度越高，内存稍大。</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 200</span><br><span class=\"line\"> 3) Capacity       <span class=\"comment\"># 质心最大容量。表示内部能容纳的最大节点数，实际使用中 TDigest 会动态合并质心以控制内存。</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 1210</span><br><span class=\"line\"> 5) Merged nodes   <span class=\"comment\"># 已合并的质心数量。这些是 TDigest 当前压缩后的节点，用于计算 rank / quantile。</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"> 7) Unmerged nodes <span class=\"comment\"># 未合并的节点数量。表示新加入但尚未压缩到质心的样本。</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"> 9) Merged weight  <span class=\"comment\"># 已合并质心的总权重。每个样本权重默认为 1，3 表示目前总共有 3 个样本被合并进质心。</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">11) Unmerged weight <span class=\"comment\"># 未合并节点的权重总和。0 表示没有未压缩的样本</span></span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">13) Observations    <span class=\"comment\"># 观测到的样本总数。你 TDIGEST.ADD 的 3 个样本正好对应这个值。</span></span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">15) Total compressions <span class=\"comment\"># 已经执行的压缩次数。每次 TDigest 内部质心合并称为一次压缩。</span></span><br><span class=\"line\">16) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">17) Memory usage     <span class=\"comment\"># Redis 为这个 TDigest 分配的内存（字节）。包含质心、索引、结构开销。TDigest 内存使用是固定的、与样本数量无关（主要由 Compression 决定）</span></span><br><span class=\"line\">18) (<span class=\"built_in\">integer</span>) 19368</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空元素\">清空元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TDIGEST.RESET key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">TDIGEST.RESET latency:td</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h2 id=\"TDigest-的内存与精度\">TDigest 的内存与精度</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存占用</td>\n<td>与 COMPRESSION 成正比（通常 KB 级）</td>\n</tr>\n<tr>\n<td>精度</td>\n<td>尾部分位数（P95/P99）极高</td>\n</tr>\n<tr>\n<td>写入复杂度</td>\n<td>近似 O(log n)</td>\n</tr>\n<tr>\n<td>查询复杂度</td>\n<td>O(log n)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>与样本数量无关。</p>\n</blockquote>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 T-Digest(分位数估计算法) T-Digest（TDigest）解决的问题与 CMS、TopK 完全不同，核心目标是 分位数（quantile）统计。 T-Digest 由 Ted Dunning 提出，专门为 高精度尾部分位数 设计。 TDigest 可以在极低内存占用下，近似计算分位数（P50 / P90 / P99 / Median 等）。 分位数（Percentile）指标对照表 指标 英文全称 数学含义 通俗解释 典型业务解读 常见使用场景 Median Median 排序后位于中间位置的值 一半数据在它左右 “一般用户的体验” 基础体验评估 P50 50th Percentile 50% 的数据 ≤ 该值 和 Median 完全相同 “典型请求耗时” 常规性能监控 P90 90th Percentile 90% 的数据 ≤ 该值 10% 的请求更慢 “大多数用户的体验” 业务体验监控 P95 95th Percentile 95% 的数据 ≤ 该值 5% 的请求更慢 “尾部开始恶化” SLA 边界监控 P99 99th Percentile 99% 的数据 ≤ 该值 1% 的请求最慢 “极端但真实的用户体验” 核心 SLA / SLO P99.9 99.9th Percentile 99.9% 的数据 ≤ 该值 千分之一最慢请求 “极端尾延迟” 金融 / 核心链路 Max Maximum 数据中的最大值 最慢的那一次 噪音极大 几乎不用 一个快速理解示例 1234567891011假设 100 次请求： 99 次耗时：10 ms 1 次耗时：3000 ms所以： P99 = 3000 ms P90 = 10 ms P50/Median = 10 ms 平均值 = （99*10 + 1*3000）/ 100 = 39.9 ms👉 只有 P99 真实暴露了问题。 工程实践中的“标准搭配” 应用场景 常看指标 Web / API 服务 P90 / P99 微服务链路 P99 / P99.9 数据库 / 存储 P95 / P99 前端体验 P50 / P90 一句话：TDigest 用于统计数字的分布，P50 看中间，P90 看大多数，P99 看最差那 1% RedisBloom 中 TDigest 的核心命令 创建 TDigest 12345678910111213# TDIGEST.CREATE key [COMPRESSION compression]# 参数说明# key： TDigest 的名称# compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大# 示例TDIGEST.CREATE latency:td COMPRESSION 200# 返回值OK# 获取 TDigest 的类型type latency:td# 返回值TDIS-TYPE 添加样本 12345# TDIGEST.ADD key value [value ...]# 示例TDIGEST.ADD latency:td 12.3 15.7 100.4# 返回值OK 查看最大/最小值 12345678910111213# 获取最大值# TDIGEST.MAX key# 示例TDIGEST.MAX latency:td# 返回值&quot;100.4&quot;# 取最小值# TDIGEST.MIN key# 示例TDIGEST.MIN latency:td# 返回值&quot;12.3&quot; 查询分位数 12345678910# TDIGEST.QUANTILE key quantile [quantile ...]# 参数说明# key： TDigest 的名称# quantile： 查询的分位数，0.5=&gt;P50 / 0.9=&gt;P90 / 0.99=&gt;P99# 示例TDIGEST.QUANTILE latency:td 0.5 0.9 0.99# 返回值1) &quot;15.7&quot;2) &quot;100.4&quot;3) &quot;100.4&quot; 反向查询（值 → 百分位） 12345678# TDIGEST.CDF key value [value ...]# 示例TDIGEST.CDF latency:td 12.3 15.7 100.4 20# 返回值1) &quot;0.16666666666666666&quot;2) &quot;0.5&quot;3) &quot;0.8333333333333334&quot;4) &quot;0.6666666666666666&quot; # 这里注意 value 不必须在 TDIGEST 中，这里的含义是 P66=20，即 66% 的值都 ≤ 20 合并 TDigest 1234567891011# TDIGEST.MERGE destination-key numkeys source-key [source-key ...] [COMPRESSION compression] [OVERRIDE]# 参数说明# destination-key： 目标 TDigest 的名称# numkeys： 源 TDigest 的数量# source-key： 源 TDigest 的名称# compression： 压缩级别，默认为 100，越大 → 精度越高 → 内存越大# OVERRIDE： 是否覆盖目标 TDigest，默认为 false# 示例TDIGEST.MERGE latency:td 2 latency:td:1 latency:td:2 COMPRESSION 200 OVERRIDE# 返回值OK 获取近似排名 123456789101112131415161718# 正向排名# TDIGEST.RANK key value [value ...]# 示例# TDIGEST.ADD latency:td 12.3 15.7 100.4 # 假设这些数据已经写入了 TDigest# 如果把 value 放入当前分布中，它的 rank（小于该值的样本数量）是多少TDIGEST.RANK latency:td 0 12.3 15.7 20 100.4 200# 返回值1) (integer) -1 # 0: 小于最小值 12.3 → 返回 -12) (integer) 0 # 12.3: 第 0 位 → 返回 0，真实存在的位数3) (integer) 1 # 15.7: 排在 12.3 后 → 返回 1，真实存在的位数4) (integer) 2 # 20: 介于 15.7 与 100.4 之间 → 返回 25) (integer) 2 # 100.4: 第 2 位 → 20，真实存在的位数6) (integer) 3 # 200: 大于 100.4 → 返回 3# 反向排名# TDIGEST.REVRANK key value [value ...]# 示例TDIGEST.REVRANK latency:td 0 12.3 15.7 20 100.4 200 根据排名获取元素 1234567891011121314# 正向排名# TDIGEST.BYRANK key rank [rank ...]# 示例TDIGEST.BYRANK latency:td 0 1 2 3# 输出结果1) &quot;12.3&quot;2) &quot;15.7&quot;3) &quot;100.4&quot;4) &quot;inf&quot; # 不存在# 反向排名# TDIGEST.BYREVRANK key rank [rank ...]# 示例TDIGEST.BYREVRANK latency:td 0 1 2 3 计算 TDigest 内部样本 去掉尾部极值后的平均近似值（Trimmed Mean，截断均值） 去掉数据分布的极端尾部，只算主要集中区域的平均值，这样更能代表“绝大多数用户的体验” 123456789# TDIGEST.TRIMMED_MEAN key low_cut_quantile high_cut_quantile# 参数说明# key： TDigest 的名称# low_cut_quantile： 去掉的左侧百分比# high_cut_quantile： 去掉的右侧百分比# 示例TDIGEST.TRIMMED_MEAN latency:td 0.05 0.95# 输出结果&quot;42.800000000000004&quot; 获取 TDigest 的信息 12345678910111213141516171819202122# TDIGEST.INFO key# 示例TDIGEST.INFO latency:td# 输出结果 1) Compression # 压缩级别，控制质心的数量与精度。值越大 → 精度越高，内存稍大。 2) (integer) 200 3) Capacity # 质心最大容量。表示内部能容纳的最大节点数，实际使用中 TDigest 会动态合并质心以控制内存。 4) (integer) 1210 5) Merged nodes # 已合并的质心数量。这些是 TDigest 当前压缩后的节点，用于计算 rank / quantile。 6) (integer) 3 7) Unmerged nodes # 未合并的节点数量。表示新加入但尚未压缩到质心的样本。 8) (integer) 0 9) Merged weight # 已合并质心的总权重。每个样本权重默认为 1，3 表示目前总共有 3 个样本被合并进质心。10) (integer) 311) Unmerged weight # 未合并节点的权重总和。0 表示没有未压缩的样本12) (integer) 013) Observations # 观测到的样本总数。你 TDIGEST.ADD 的 3 个样本正好对应这个值。14) (integer) 315) Total compressions # 已经执行的压缩次数。每次 TDigest 内部质心合并称为一次压缩。16) (integer) 117) Memory usage # Redis 为这个 TDigest 分配的内存（字节）。包含质心、索引、结构开销。TDigest 内存使用是固定的、与样本数量无关（主要由 Compression 决定）18) (integer) 19368 清空元素 12345# TDIGEST.RESET key# 示例TDIGEST.RESET latency:td# 输出结果OK TDigest 的内存与精度 维度 特性 内存占用 与 COMPRESSION 成正比（通常 KB 级） 精度 尾部分位数（P95/P99）极高 写入复杂度 近似 O(log n) 查询复杂度 O(log n) 与样本数量无关。","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TDigest 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法","date_published":"2025-12-23T07:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-14-TopK/","title":"Redis 命令及数据类型 -- TopK","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"TopK\">TopK</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>TopK，专门用于解决 “在海量数据流中，实时找出最热门的 N 个元素” 这一类问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>Top-K 属于流式重频（Heavy Hitters）算法家族，其目标不是记录所有元素，而是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">在受限内存下，持续维护出现频率最高的 K 个元素</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>TopK 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">固定容量：只维护 K 个元素</span><br><span class=\"line\">近似统计：计数可能略有误差</span><br><span class=\"line\">自动淘汰：低频元素会被踢出</span><br><span class=\"line\">写入极快：适合高 QPS</span><br><span class=\"line\">内存稳定：与数据规模无关</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RedisBloom 的 TopK 内部使用 CMS 作为频次估算基础，并结合<code>堆+淘汰策略</code>来维护热点集合。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">CMS: 参考 <a href=\"/2025/12/23/redis7-datatype-13-CMS/\" title=\"Redis 命令及数据类型 -- CMS(Count-Min Sketch)\">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li>\n<li class=\"lvl-6\">堆+淘汰策略: TopK 在内部如何决定谁能进入 TopK、谁必须被踢出 TopK 的一整套机制。\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">堆：TopK 使用一个最小堆来维护 TopK 元素，TopK 维护 K 个候选元素，堆顶永远是 当前 TopK 中频次最低的那个</li>\n<li class=\"lvl-10\">淘汰策略：TopK 使用一个 LRU 缓存来记录最近访问的元素，当 TopK 元素数量达到上限时，将 LRU 缓存中的元素逐个加入 TopK，并更新 TopK 元素的频率。</li>\n<li class=\"lvl-10\">一句话：当新元素的估算频次超过当前最弱的那个时，就把弱者淘汰掉，让新元素进榜。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"当一个新元素到来时，我该不该让它进入-TopK？\">当一个新元素到来时，我该不该让它进入 TopK？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>下面是 TopK 在 TOPK.ADD 时的真实逻辑抽象</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Step 1：更新 CMS（不存 item，只更新计数器）</span></span><br><span class=\"line\">CMS.increment(item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 2：item 是否在 TopK 显式集合中？</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> item <span class=\"keyword\">in</span> TopK:</span><br><span class=\"line\">    <span class=\"comment\"># 重新平衡堆位置</span></span><br><span class=\"line\">    update_heap(item)</span><br><span class=\"line\">    <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 3：TopK 是否未满？</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> TopK.size &lt; K:</span><br><span class=\"line\">    TopK.insert(item)</span><br><span class=\"line\">    <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 4：比较 CMS 估算值</span></span><br><span class=\"line\">freq_new = CMS.query(item)</span><br><span class=\"line\">freq_min = CMS.query(TopK.min_item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> freq_new &gt; freq_min:</span><br><span class=\"line\">    TopK.evict_min()</span><br><span class=\"line\">    TopK.insert(item)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 什么都不做</span></span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-的应用场景\">TopK 的应用场景</h2>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>TopK 是否适合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>当前访问量最高的 URL</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>搜索热词 Top 10</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>商品点击榜</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>所有商品的点击次数</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>精确计数</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RedisBloom-TopK-的核心命令\">RedisBloom TopK 的核心命令</h2>\n<h3 id=\"创建-TopK\">创建 TopK</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用 TopK 前必须先创建 TopK</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.RESERVE key topk [width depth decay]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key: 键名</span></span><br><span class=\"line\"><span class=\"comment\"># topk: 存储的元素数量，即统计的前 K 个元素</span></span><br><span class=\"line\"><span class=\"comment\"># width: 内部CMS 的宽度，默认 8</span></span><br><span class=\"line\"><span class=\"comment\"># depth: 内部CMS 的深度，默认 7</span></span><br><span class=\"line\"><span class=\"comment\"># decay: 衰减因子（0 ~ 1），默认 0.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：维护访问量最高的 100 个 URL，允许历史热度逐渐衰减。</span></span><br><span class=\"line\">TOPK.RESERVE topk:urls 100 2000 7 0.9</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> topk:urls</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">TopK-TYPE</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加元素\">添加元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.ADD key items [items ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：添加元素 &quot;a&quot; 和 &quot;b&quot; 到 TopK 中</span></span><br><span class=\"line\">TOPK.ADD topk:urls a b</span><br><span class=\"line\"><span class=\"comment\"># 返回值，被挤出 TopK 的元素（如果有）</span></span><br><span class=\"line\">1) (nil)</span><br><span class=\"line\">2) (nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加元素的频率\">增加元素的频率</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.INCRBY key item increment [item increment ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：将元素 &quot;a&quot; 的频率增加 1</span></span><br><span class=\"line\">TOPK.INCRBY topk:urls a 1</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) (nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询元素是否在-TopK-中\">查询元素是否在 TopK 中</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.QUERY key item [item ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：查询元素 &quot;a&quot; 是否在 TopK 中</span></span><br><span class=\"line\">TOPK.QUERY topk:urls a</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 1 表示元素 &quot;a&quot; 在 TopK 中，0 表示元素 &quot;a&quot; 不在 TopK 中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-TopK-中的元素\">获取 TopK 中的元素</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.LIST key [WITHCOUNT]</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCOUNT: 是否返回每个元素出现的次数，默认不返回</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：获取 TopK 中的元素，并返回每个元素出现的次数</span></span><br><span class=\"line\">TOPK.LIST topk:urls WITHCOUNT</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">3) <span class=\"string\">&quot;b&quot;</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取近似计数\">获取近似计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.COUNT key item [item ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：获取元素 &quot;a&quot; 的近似计数</span></span><br><span class=\"line\">TOPK.COUNT topk:urls a</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看TopK-的状态\">查看TopK 的状态</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TOPK.INFO key</span></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 含义：查看 TopK 的状态</span></span><br><span class=\"line\">TOPK.INFO topk:urls</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">1) k                    <span class=\"comment\"># topk 的大小</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 100</span><br><span class=\"line\">3) width                <span class=\"comment\"># 内部 CMS 的宽度</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 2000</span><br><span class=\"line\">5) depth                <span class=\"comment\"># 内部 CMS 的深度</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 7</span><br><span class=\"line\">7) decay                <span class=\"comment\"># 衰减因子</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;0.9&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-的衰减（decay）参数怎么理解\">TopK 的衰减（decay）参数怎么理解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>decay 用于解决一个问题：“老热点永远霸榜，新热点上不来”</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>decay</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.0</td>\n<td>永不衰减（全历史统计）</td>\n</tr>\n<tr>\n<td>0.9</td>\n<td>越老的数据权重越低</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>热点更新非常快</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>经验值：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">实时热点：0.8 ~ 0.9</li>\n<li class=\"lvl-6\">长周期榜单：0.95 ~ 1.0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CMS-和-TopK-组合使用场景\">CMS 和 TopK 组合使用场景</h2>\n<h3 id=\"📌场景1：-实时热搜榜（最经典组合）\">📌场景1： 实时热搜榜（最经典组合）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计所有搜索词频次（CMS），同时实时出TOP10热搜（TOPK），既知热度又能排序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 初始化CMS（统计全量搜索词计数，误差0.001）</span></span><br><span class=\"line\">cms.initbyprob search_count 0.001 0.01</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 初始化TOPK（取TOP10热搜）</span></span><br><span class=\"line\">topk.reserve search_top10 10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 用户搜索核心操作（2命令必一起执行）</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索&quot;周杰伦&quot;，CMS计数+1，同时录入TOPK（自动累加热度）</span></span><br><span class=\"line\">cms.incrby search_count 周杰伦 1</span><br><span class=\"line\">topk.incrby search_top10 周杰伦 1</span><br><span class=\"line\"></span><br><span class=\"line\">cms.incrby search_count 原神 1</span><br><span class=\"line\">topk.incrby search_top10 原神 1</span><br><span class=\"line\">cms.incrby search_count 周杰伦 1  <span class=\"comment\"># 重复搜索，双端同步+1</span></span><br><span class=\"line\">topk.incrby search_top10 周杰伦 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 核心查询：先取TOP10，再查精准计数（组合核心）</span></span><br><span class=\"line\"><span class=\"comment\"># 第一步：取TOP10热搜列表</span></span><br><span class=\"line\">topk.list search_top10  <span class=\"comment\"># 返回：周杰伦、原神...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二步：查热搜词精准近似计数（CMS比TOPK.count更准）</span></span><br><span class=\"line\">cms.query search_count 周杰伦  <span class=\"comment\"># 返回2（精准）</span></span><br><span class=\"line\">topk.count search_top10 周杰伦  <span class=\"comment\"># 参考值，优先用CMS结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 辅助查询：判断词是否在热搜榜</span></span><br><span class=\"line\">topk.query search_top10 周杰伦  <span class=\"comment\"># 1=在，0=不在</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TopK-vs-ZSET\">TopK vs ZSET</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能力边界对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>TopK</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否近似</td>\n<td>✔️ 是</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td>是否保存全部元素</td>\n<td>❌ 只保存 Top K</td>\n<td>✔️ 保存全部</td>\n</tr>\n<tr>\n<td>频次是否精确</td>\n<td>❌ 估计</td>\n<td>✔️ 精确</td>\n</tr>\n<tr>\n<td>是否支持排序</td>\n<td>⚠️ 仅 Top K</td>\n<td>✔️ 全量排序</td>\n</tr>\n<tr>\n<td>是否可遍历</td>\n<td>❌ 仅 K 个</td>\n<td>✔️ 全量</td>\n</tr>\n<tr>\n<td>是否支持删除</td>\n<td>❌ 不支持</td>\n<td>✔️ 支持</td>\n</tr>\n<tr>\n<td>是否支持范围查询</td>\n<td>❌</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>Top N 查询</td>\n<td>✔️ 原生</td>\n<td>✔️</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>性能与吞吐量对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>TopK</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入复杂度</td>\n<td>O(d)</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>高并发写入</td>\n<td>极优</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>查询 TopK</td>\n<td>O(K)</td>\n<td>O(K)</td>\n</tr>\n<tr>\n<td>查询单元素频次</td>\n<td>O(d)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>批量写入</td>\n<td>极快</td>\n<td>较慢</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 TopK TopK，专门用于解决 “在海量数据流中，实时找出最热门的 N 个元素” 这一类问题 Top-K 属于流式重频（Heavy Hitters）算法家族，其目标不是记录所有元素，而是： 在受限内存下，持续维护出现频率最高的 K 个元素 TopK 的核心特性 12345固定容量：只维护 K 个元素近似统计：计数可能略有误差自动淘汰：低频元素会被踢出写入极快：适合高 QPS内存稳定：与数据规模无关 RedisBloom 的 TopK 内部使用 CMS 作为频次估算基础，并结合堆+淘汰策略来维护热点集合。 CMS: 参考 Redis 命令及数据类型 -- CMS(Count-Min Sketch) 堆+淘汰策略: TopK 在内部如何决定谁能进入 TopK、谁必须被踢出 TopK 的一整套机制。 堆：TopK 使用一个最小堆来维护 TopK 元素，TopK 维护 K 个候选元素，堆顶永远是 当前 TopK 中频次最低的那个 淘汰策略：TopK 使用一个 LRU 缓存来记录最近访问的元素，当 TopK 元素数量达到上限时，将 LRU 缓存中的元素逐个加入 TopK，并更新 TopK 元素的频率。 一句话：当新元素的估算频次超过当前最弱的那个时，就把弱者淘汰掉，让新元素进榜。 当一个新元素到来时，我该不该让它进入 TopK？ 下面是 TopK 在 TOPK.ADD 时的真实逻辑抽象 123456789101112131415161718192021222324# Step 1：更新 CMS（不存 item，只更新计数器）CMS.increment(item)# Step 2：item 是否在 TopK 显式集合中？if item in TopK: # 重新平衡堆位置 update_heap(item) return# Step 3：TopK 是否未满？if TopK.size &lt; K: TopK.insert(item) return# Step 4：比较 CMS 估算值freq_new = CMS.query(item)freq_min = CMS.query(TopK.min_item)if freq_new &gt; freq_min: TopK.evict_min() TopK.insert(item)else: # 什么都不做 pass TopK 的应用场景 问题 TopK 是否适合 当前访问量最高的 URL ✅ 搜索热词 Top 10 ✅ 商品点击榜 ✅ 所有商品的点击次数 ❌ 精确计数 ❌ RedisBloom TopK 的核心命令 创建 TopK 使用 TopK 前必须先创建 TopK 123456789101112131415161718# TOPK.RESERVE key topk [width depth decay]# 参数说明# key: 键名# topk: 存储的元素数量，即统计的前 K 个元素# width: 内部CMS 的宽度，默认 8# depth: 内部CMS 的深度，默认 7# decay: 衰减因子（0 ~ 1），默认 0.9# 示例# 含义：维护访问量最高的 100 个 URL，允许历史热度逐渐衰减。TOPK.RESERVE topk:urls 100 2000 7 0.9# 返回值OK# 验证类型type topk:urls# 返回值TopK-TYPE 添加元素 1234567# TOPK.ADD key items [items ...]# 示例# 含义：添加元素 &quot;a&quot; 和 &quot;b&quot; 到 TopK 中TOPK.ADD topk:urls a b# 返回值，被挤出 TopK 的元素（如果有）1) (nil)2) (nil) 增加元素的频率 123456# TOPK.INCRBY key item increment [item increment ...]# 示例# 含义：将元素 &quot;a&quot; 的频率增加 1TOPK.INCRBY topk:urls a 1# 输出结果1) (nil) 查询元素是否在 TopK 中 123456# TOPK.QUERY key item [item ...]# 示例# 含义：查询元素 &quot;a&quot; 是否在 TopK 中TOPK.QUERY topk:urls a# 返回值1) (integer) 1 # 1 表示元素 &quot;a&quot; 在 TopK 中，0 表示元素 &quot;a&quot; 不在 TopK 中 获取 TopK 中的元素 1234567891011# TOPK.LIST key [WITHCOUNT]# 参数说明# WITHCOUNT: 是否返回每个元素出现的次数，默认不返回# 示例# 含义：获取 TopK 中的元素，并返回每个元素出现的次数TOPK.LIST topk:urls WITHCOUNT# 输出结果1) &quot;a&quot;2) (integer) 23) &quot;b&quot;4) (integer) 1 获取近似计数 123456# TOPK.COUNT key item [item ...]# 示例# 含义：获取元素 &quot;a&quot; 的近似计数TOPK.COUNT topk:urls a# 输出结果1) (integer) 2 查看TopK 的状态 12345678910111213# TOPK.INFO key# 示例# 含义：查看 TopK 的状态TOPK.INFO topk:urls# 输出结果1) k # topk 的大小2) (integer) 1003) width # 内部 CMS 的宽度4) (integer) 20005) depth # 内部 CMS 的深度6) (integer) 77) decay # 衰减因子8) &quot;0.9&quot; TopK 的衰减（decay）参数怎么理解 decay 用于解决一个问题：“老热点永远霸榜，新热点上不来” decay 行为 1.0 永不衰减（全历史统计） 0.9 越老的数据权重越低 0.5 热点更新非常快 经验值： 实时热点：0.8 ~ 0.9 长周期榜单：0.95 ~ 1.0 CMS 和 TopK 组合使用场景 📌场景1： 实时热搜榜（最经典组合） 需求：统计所有搜索词频次（CMS），同时实时出TOP10热搜（TOPK），既知热度又能排序 1234567891011121314151617181920212223242526# 1. 初始化CMS（统计全量搜索词计数，误差0.001）cms.initbyprob search_count 0.001 0.01# 2. 初始化TOPK（取TOP10热搜）topk.reserve search_top10 10# 3. 用户搜索核心操作（2命令必一起执行）# 搜索&quot;周杰伦&quot;，CMS计数+1，同时录入TOPK（自动累加热度）cms.incrby search_count 周杰伦 1topk.incrby search_top10 周杰伦 1cms.incrby search_count 原神 1topk.incrby search_top10 原神 1cms.incrby search_count 周杰伦 1 # 重复搜索，双端同步+1topk.incrby search_top10 周杰伦 1# 4. 核心查询：先取TOP10，再查精准计数（组合核心）# 第一步：取TOP10热搜列表topk.list search_top10 # 返回：周杰伦、原神...# 第二步：查热搜词精准近似计数（CMS比TOPK.count更准）cms.query search_count 周杰伦 # 返回2（精准）topk.count search_top10 周杰伦 # 参考值，优先用CMS结果# 5. 辅助查询：判断词是否在热搜榜topk.query search_top10 周杰伦 # 1=在，0=不在 TopK vs ZSET 能力边界对比 能力 TopK ZSet 是否近似 ✔️ 是 ❌ 否 是否保存全部元素 ❌ 只保存 Top K ✔️ 保存全部 频次是否精确 ❌ 估计 ✔️ 精确 是否支持排序 ⚠️ 仅 Top K ✔️ 全量排序 是否可遍历 ❌ 仅 K 个 ✔️ 全量 是否支持删除 ❌ 不支持 ✔️ 支持 是否支持范围查询 ❌ ✔️ Top N 查询 ✔️ 原生 ✔️ 性能与吞吐量对比 维度 TopK ZSet 写入复杂度 O(d) O(log N) 高并发写入 极优 一般 查询 TopK O(K) O(K) 查询单元素频次 O(d) O(1) 批量写入 极快 较慢","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 TopK 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法","date_published":"2025-12-23T06:50:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/","url":"https://blog.hanqunfeng.com/2025/12/23/redis7-datatype-13-CMS/","title":"Redis 命令及数据类型 -- CMS(Count-Min Sketch)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Count-Min-Sketch\">Count-Min Sketch</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Count-Min Sketch（CMS） 用于在极低内存占用下，对高频写入的计数型数据进行近似统计，非常适合流量、事件、关键词等“只关心频次规模、不要求精确值”的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Count-Min Sketch 是一种基于哈希的概率型计数结构，用于估算元素出现次数，具有以下核心特征：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">只会高估，不会低估（over-estimation）</li>\n<li class=\"lvl-6\">固定内存，与元素种类数无关</li>\n<li class=\"lvl-6\">O(1) 的更新与查询复杂度</li>\n<li class=\"lvl-6\">不支持删除（或只能近似删除）</li>\n<li class=\"lvl-6\">只能返回给定元素近似统计其频次，而无法返回全部元素的统计频次</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>基本工作原理（简化版）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.初始化一个二维数组 counter[d][w]</span><br><span class=\"line\">2.对每个元素 x：</span><br><span class=\"line\">    a. 通过 d 个哈希函数映射到 d 行中的 w 个位置</span><br><span class=\"line\">    b. 对对应的 d 个计数器全部 +1</span><br><span class=\"line\">3.查询元素 x 的频次：</span><br><span class=\"line\">    a.取这 d 个计数器的 最小值(取最小值是为了尽量抵消哈希冲突带来的“多加”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意下图中的数组不是二进制的，每次映射都会+1<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Ybl5tj.png\" alt=\"\"></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>误差与空间复杂度</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>误差上界</td>\n<td>≤ ε × 总插入次数</td>\n</tr>\n<tr>\n<td>错误概率</td>\n<td>≤ δ</td>\n</tr>\n<tr>\n<td>空间复杂度</td>\n<td>O(1 / ε × log(1 / δ))</td>\n</tr>\n<tr>\n<td>查询复杂度</td>\n<td>O(d)</td>\n</tr>\n<tr>\n<td>更新复杂度</td>\n<td>O(d)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>结论：数据量再大，内存不增长，代价是“精度换空间”</p>\n</blockquote>\n<h2 id=\"RedisBloom-中-CMS-的核心命令\">RedisBloom 中 CMS 的核心命令</h2>\n<h3 id=\"创建-CMS\">创建 CMS</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按底层维度初始化</span></span><br><span class=\"line\"><span class=\"comment\"># CMS.INITBYDIM key width depth</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># width (w)：每一行的桶数（影响误差）</span></span><br><span class=\"line\"><span class=\"comment\"># depth (d)：哈希函数数量（影响冲突概率）</span></span><br><span class=\"line\"><span class=\"comment\"># 比如：</span></span><br><span class=\"line\">CMS.INITBYDIM page:view 1000 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> page:view</span><br><span class=\"line\"><span class=\"comment\"># 返回值</span></span><br><span class=\"line\">CMSk-TYPE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按误差+容量初始化</span></span><br><span class=\"line\"><span class=\"comment\"># CMS.INITBYPROB page:view error probability</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># error (ε)：误差上界</span></span><br><span class=\"line\"><span class=\"comment\"># probability (δ)：超过误差上界的概率，这个数字越接近零，每个项目的内存消耗就越大，每次操作的CPU使用就越多。</span></span><br><span class=\"line\"><span class=\"comment\"># RedisBloom 会自动换算 w 和 d</span></span><br><span class=\"line\"><span class=\"comment\"># 比如：</span></span><br><span class=\"line\">CMS.INITBYPROB key 0.001 0.01</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>数值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>error</code></td>\n<td><code>0.001</code></td>\n<td>最大相对误差 ε = 0.1%</td>\n</tr>\n<tr>\n<td><code>probability</code></td>\n<td><code>0.01</code></td>\n<td>只有 1% 的概率超过该误差</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"增加计数\">增加计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.INCRBY key item1 count1 item2 count2 ...</span></span><br><span class=\"line\">CMS.INCRBY page:view home 1 about 1 home 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询计数\">查询计数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.QUERY key item1 item2 ...</span></span><br><span class=\"line\">CMS.QUERY page:view home about</span><br><span class=\"line\"><span class=\"comment\"># 返回的是 估算值（可能偏大）</span></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并-CMS\">合并 CMS</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.MERGE dest numkeys src1 src2 ... WEIGHTS w1 w2 ...</span></span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># dest：目标 CMS，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># numkeys：源 CMS 数量</span></span><br><span class=\"line\"><span class=\"comment\"># src1 src2 ...：源 CMS，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># WEIGHTS w1 w2 ...：源 CMS 权重</span></span><br><span class=\"line\">CMS.MERGE page:view 2 page:view:1 page:view:2 WEIGHTS 1 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取-CMS-的信息\">获取 CMS 的信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMS.INFO key</span></span><br><span class=\"line\">CMS.INFO page:view</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) width            <span class=\"comment\"># 每一行桶数 w</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\">3) depth            <span class=\"comment\"># 哈希函数数量 d</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">5) count            <span class=\"comment\"># 当前已插入的元素数量</span></span><br><span class=\"line\">6) (<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h2 id=\"CMS-的使用场景\">CMS 的使用场景</h2>\n<h3 id=\"场景1：网站PV统计\">场景1：网站PV统计</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计网站 PV，即页面被访问的次数，允许0.1%的误差</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化 CMS</span></span><br><span class=\"line\">CMS.INITBYPROB page:pv 0.001 0.01</span><br><span class=\"line\"><span class=\"comment\"># 添加计数</span></span><br><span class=\"line\">CMS.INCRBY page:pv /home 1 /about 1</span><br><span class=\"line\">CMS.INCRBY page:pv /home 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询计数</span></span><br><span class=\"line\">CMS.QUERY page:pv /home</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景2：接口调用频次限流前置统计\">场景2：接口调用频次限流前置统计</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：统计接口调用次数，为限流提供已经，不需要精准计数，允许0.1%的误差</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 CMS</span></span><br><span class=\"line\">CMS.INITBYPROB api:<span class=\"built_in\">limit</span> 0.001 0.01</span><br><span class=\"line\"><span class=\"comment\"># 添加计数</span></span><br><span class=\"line\">CMS.INCRBY api:<span class=\"built_in\">limit</span> /api/user/list 1</span><br><span class=\"line\"><span class=\"comment\"># 获取计数</span></span><br><span class=\"line\">CMS.QUERY api:<span class=\"built_in\">limit</span> /api/user/list</span><br></pre></td></tr></table></figure>\n<h2 id=\"CMS-vs-ZSET\">CMS vs ZSET</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能力边界对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>CMS</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>频次统计</td>\n<td>✔️ 近似</td>\n<td>✔️ 精确</td>\n</tr>\n<tr>\n<td>是否存元素</td>\n<td>❌ 不存</td>\n<td>✔️ 存</td>\n</tr>\n<tr>\n<td>是否可遍历元素</td>\n<td>❌ 不可</td>\n<td>✔️ 可</td>\n</tr>\n<tr>\n<td>TopK / 排行</td>\n<td>❌（需配合 TopK）</td>\n<td>✔️ 天然支持</td>\n</tr>\n<tr>\n<td>删除元素</td>\n<td>❌ 不支持</td>\n<td>✔️ 支持</td>\n</tr>\n<tr>\n<td>误判 / 误差</td>\n<td>✔️ 存在</td>\n<td>❌ 无</td>\n</tr>\n<tr>\n<td>是否可逆（查成员）</td>\n<td>❌ 不可逆</td>\n<td>✔️ 可逆</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>性能特征对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>CMS</th>\n<th>ZSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入 / 计数</td>\n<td>O(d)（常数级）</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>查询频次</td>\n<td>O(d)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>排名查询</td>\n<td>❌</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>批量写入</td>\n<td>极快</td>\n<td>中等</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 Count-Min Sketch Count-Min Sketch（CMS） 用于在极低内存占用下，对高频写入的计数型数据进行近似统计，非常适合流量、事件、关键词等“只关心频次规模、不要求精确值”的场景。 Count-Min Sketch 是一种基于哈希的概率型计数结构，用于估算元素出现次数，具有以下核心特征： 只会高估，不会低估（over-estimation） 固定内存，与元素种类数无关 O(1) 的更新与查询复杂度 不支持删除（或只能近似删除） 只能返回给定元素近似统计其频次，而无法返回全部元素的统计频次 基本工作原理（简化版） 1234561.初始化一个二维数组 counter[d][w]2.对每个元素 x： a. 通过 d 个哈希函数映射到 d 行中的 w 个位置 b. 对对应的 d 个计数器全部 +13.查询元素 x 的频次： a.取这 d 个计数器的 最小值(取最小值是为了尽量抵消哈希冲突带来的“多加”) 注意下图中的数组不是二进制的，每次映射都会+1 误差与空间复杂度 维度 说明 误差上界 ≤ ε × 总插入次数 错误概率 ≤ δ 空间复杂度 O(1 / ε × log(1 / δ)) 查询复杂度 O(d) 更新复杂度 O(d) 结论：数据量再大，内存不增长，代价是“精度换空间” RedisBloom 中 CMS 的核心命令 创建 CMS 1234567891011121314151617181920212223# 按底层维度初始化# CMS.INITBYDIM key width depth# 参数说明# width (w)：每一行的桶数（影响误差）# depth (d)：哈希函数数量（影响冲突概率）# 比如：CMS.INITBYDIM page:view 1000 10# 输出OK# 验证类型type page:view# 返回值CMSk-TYPE# 按误差+容量初始化# CMS.INITBYPROB page:view error probability# 参数说明# error (ε)：误差上界# probability (δ)：超过误差上界的概率，这个数字越接近零，每个项目的内存消耗就越大，每次操作的CPU使用就越多。# RedisBloom 会自动换算 w 和 d# 比如：CMS.INITBYPROB key 0.001 0.01 参数 数值 说明 error 0.001 最大相对误差 ε = 0.1% probability 0.01 只有 1% 的概率超过该误差 增加计数 123456# CMS.INCRBY key item1 count1 item2 count2 ...CMS.INCRBY page:view home 1 about 1 home 1# 输出1) (integer) 12) (integer) 13) (integer) 2 查询计数 123456# CMS.QUERY key item1 item2 ...CMS.QUERY page:view home about# 返回的是 估算值（可能偏大）# 输出1) (integer) 22) (integer) 1 合并 CMS 123456789# CMS.MERGE dest numkeys src1 src2 ... WEIGHTS w1 w2 ...# 参数说明# dest：目标 CMS，必须存在# numkeys：源 CMS 数量# src1 src2 ...：源 CMS，必须存在# WEIGHTS w1 w2 ...：源 CMS 权重CMS.MERGE page:view 2 page:view:1 page:view:2 WEIGHTS 1 1# 输出OK 获取 CMS 的信息 123456789# CMS.INFO keyCMS.INFO page:view# 输出1) width # 每一行桶数 w2) (integer) 10003) depth # 哈希函数数量 d4) (integer) 105) count # 当前已插入的元素数量6) (integer) 3 CMS 的使用场景 场景1：网站PV统计 需求：统计网站 PV，即页面被访问的次数，允许0.1%的误差 12345678# 初始化 CMSCMS.INITBYPROB page:pv 0.001 0.01# 添加计数CMS.INCRBY page:pv /home 1 /about 1CMS.INCRBY page:pv /home 1# 查询计数CMS.QUERY page:pv /home 场景2：接口调用频次限流前置统计 需求：统计接口调用次数，为限流提供已经，不需要精准计数，允许0.1%的误差 123456# 创建 CMSCMS.INITBYPROB api:limit 0.001 0.01# 添加计数CMS.INCRBY api:limit /api/user/list 1# 获取计数CMS.QUERY api:limit /api/user/list CMS vs ZSET 能力边界对比 能力 CMS ZSet 频次统计 ✔️ 近似 ✔️ 精确 是否存元素 ❌ 不存 ✔️ 存 是否可遍历元素 ❌ 不可 ✔️ 可 TopK / 排行 ❌（需配合 TopK） ✔️ 天然支持 删除元素 ❌ 不支持 ✔️ 支持 误判 / 误差 ✔️ 存在 ❌ 无 是否可逆（查成员） ❌ 不可逆 ✔️ 可逆 性能特征对比 操作 CMS ZSet 插入 / 计数 O(d)（常数级） O(log N) 查询频次 O(d) O(1) 排名查询 ❌ O(log N) 批量写入 极快 中等","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Count-Min Sketch 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法","date_published":"2025-12-23T06:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","title":"Redis 命令及数据类型 -- CF(Cuckoo Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a></li>\n<li class=\"lvl-2\">示例代码：<a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/redis-demo/data-type-demo\">GitHub</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Cuckoo-Filter（布谷鸟过滤器）\">Cuckoo Filter（布谷鸟过滤器）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Cuckoo Filter 是 Bloom Filter 的改进版，支持 动态添加和删除元素，仍能提供比布隆过滤器更高的查询性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</p>\n</li>\n<li class=\"lvl-2\">\n<p>优点：低误判率 + 高负载率，基于相同的集合和误报率，Cuckoo Filter通常占用空间更少。相对的，算法实现也就更复杂。</p>\n</li>\n<li class=\"lvl-2\">\n<p>缺点：与Bloom Filter一样，有可能将一个不在集合中的元素错误的判断成在集合中</p>\n</li>\n<li class=\"lvl-2\">\n<p>Bloom Filter 的误报率通过调整<code>位数组的大小</code>和<code>哈希函数数量</code>来控制，而 Cuckoo Filter 的误报率受<code>指纹大小</code>和<code>桶大小</code>控制。</p>\n</li>\n</ul>\n<h3 id=\"布谷哈希算法\">布谷哈希算法</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://baike.baidu.com/item/Cockoo%20hash/3022855\">百度百科对布谷哈希算法的描述</a>]</p>\n</li>\n<li class=\"lvl-2\">\n<p>算法使用两个不同哈希函数计算对应 key 的位置。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<ol>\n<li class=\"lvl-9\">当两个哈希任意位置为空，则随机选择一个位置插入</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"2\">\n<li class=\"lvl-9\">当两个哈希有位置为空时，则插入到空位置</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"3\">\n<li class=\"lvl-9\">当两个哈希位置均不为空时，随机选择一个位置插入并踢出原key，原key会再次经过计算获得新的位置，转至1执行，反复直到成功或者达到最大迭代次数。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Cuckoo-Filter-的实现原理\">Cuckoo Filter 的实现原理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>布谷过滤器 是在<code>布谷哈希算法</code>的算法基础上扩充来的，但是它所提供的概念不是表，而是提供了多个数据桶(Bucket)</p>\n</li>\n<li class=\"lvl-2\">\n<p>每一个数据桶都是个<code>一维数组</code>，每个数组的保存内容为<code>条目(Entry)</code>，每一个条目里面可以保存一个<code>指纹数据</code>(指纹数据就是原始数据经过哈希计算得到的一个n位的数据标记)，除了指纹数据之外，还会同时得出一个<code>保存位置P1标记</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当两个数据计算得到的指纹数据相同时，就会发生冲突，冲突操作的解决思路是使用<code>布谷哈希算法</code>，简单说就是新的数据会将原有数据<code>踢出</code>，而被踢出的数据会被重新计算得到新的指纹数据和保存位置标记。</p>\n</li>\n<li class=\"lvl-2\">\n<p>布谷过滤器里面需要进行各种数据的<code>踢出</code>操作，这个踢出的方式就是使用<code>P1标志位</code>和<code>指纹数据</code>进行<code>异或计算</code>得出来的<code>P2标志位</code>，按照同样的思路(前提:一直都有冲突操作)一直计算新的P2位，直到冲突解决或者达到最大迭代次数，就会失败。</p>\n</li>\n<li class=\"lvl-2\">\n<p>指纹数据里面包含有<code>唯一性</code>，所以可以实现数据的删除，当然，不同的数据计算是有可能得到相同指纹的，那么一旦删除数据之后，有可能造成数据的&quot;假删除&quot;，所以布谷过滤器本身也是存在有误差的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Cuckoo Filter 中的 <code>BUSKETSIZE</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">BUSKETSIZE，表示每个桶(Busket)中存放的元素个数，即桶大小。</li>\n<li class=\"lvl-6\">Cuckoo Filter的数组里存的不是位，而是桶(busket)，每个桶里可以存放多个数据。</li>\n<li class=\"lvl-6\">同一个桶中存放的数据越多，空间利用率更高，相应的误判率也就越高，性能也更慢。</li>\n<li class=\"lvl-6\">Redis的CuckooFilter实现中，BUSKETSIZE应该是一个在1到255之间的整数，默认的 BUSKETSIZE 是 <code>2</code>。</li>\n<li class=\"lvl-6\">桶(Busket)中并不实际保存数据本身，而是保存数据的指纹(fingerprint)。指纹越小，HASH冲突造成误判的几率就越小。这个参数的调整比较复杂，Redis的CuckooFilter中不支持调整这个参数。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CF-命令说明\">CF 命令说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>CF.xxx</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CF.RESERVE</strong></td>\n<td>显式创建 Cuckoo Filter</td>\n<td>是</td>\n<td><code>capacity</code>：容量(必填)<br><code>BUCKETSIZE</code>：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)<br><code>MAXITERATIONS</code>：重排次数，越大成功率越高<br><code>EXPANSION</code>：扩容倍数，默认 1（不扩容）</td>\n<td>OK</td>\n<td><code>CF.RESERVE user:cf 100000</code></td>\n<td>✅ <strong>生产推荐</strong><br>支持删除与计数</td>\n</tr>\n<tr>\n<td><strong>CF.ADD</strong></td>\n<td>添加一个元素，不去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code>：元素</td>\n<td>OK</td>\n<td><code>CF.ADD user:cf user_1</code></td>\n<td>若满可能失败</td>\n</tr>\n<tr>\n<td><strong>CF.ADDNX</strong></td>\n<td>元素不存在时才添加，去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code></td>\n<td><code>1</code> 新增<br><code>0</code> 已存在</td>\n<td><code>CF.ADDNX user:cf user_1</code></td>\n<td>幂等写入首选</td>\n</tr>\n<tr>\n<td><strong>CF.INSERT</strong></td>\n<td>批量插入</td>\n<td>是（不存在则创建）</td>\n<td><code>ITEMS</code>：元素列表</td>\n<td>OK</td>\n<td><code>CF.INSERT user:cf ITEMS u1 u2</code></td>\n<td>默认配置</td>\n</tr>\n<tr>\n<td><strong>CF.INSERTNX</strong></td>\n<td>批量插入（不存在才加）</td>\n<td>是</td>\n<td><code>ITEMS</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.INSERTNX user:cf ITEMS u1 u2</code></td>\n<td>幂等 + 批量</td>\n</tr>\n<tr>\n<td><strong>CF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 可能存在<br><code>0</code> 不存在</td>\n<td><code>CF.EXISTS user:cf user_1</code></td>\n<td>仍有误判</td>\n</tr>\n<tr>\n<td><strong>CF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.MEXISTS user:cf u1 u9</code></td>\n<td>高并发推荐</td>\n</tr>\n<tr>\n<td><strong>CF.COUNT</strong></td>\n<td>返回元素出现次数</td>\n<td>否</td>\n<td><code>item</code></td>\n<td>整数</td>\n<td><code>CF.COUNT user:cf user_1</code></td>\n<td>⭐ Bloom 没有的能力</td>\n</tr>\n<tr>\n<td><strong>CF.DEL</strong></td>\n<td>删除一个元素</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 删除成功<br><code>0</code> 不存在</td>\n<td><code>CF.DEL user:cf user_1</code></td>\n<td>⭐ Bloom 不支持</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://CF.INFO\">CF.INFO</a></strong></td>\n<td>查看 Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>CF.INFO user:cf</code></td>\n<td>运维分析</td>\n</tr>\n<tr>\n<td><strong>CF.SCANDUMP</strong></td>\n<td>分块导出 Filter</td>\n<td>否</td>\n<td><code>iterator</code></td>\n<td><code>iterator + data</code></td>\n<td><code>CF.SCANDUMP user:cf 0</code></td>\n<td>迁移 / 备份</td>\n</tr>\n<tr>\n<td><strong>CF.LOADCHUNK</strong></td>\n<td>从 dump 恢复 Filter</td>\n<td>是</td>\n<td><code>iterator + data</code></td>\n<td>OK</td>\n<td><code>CF.LOADCHUNK user:cf 1 &quot;xxx&quot;</code></td>\n<td>与 SCANDUMP 配合</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Bloom-vs-Cuckoo\">Bloom vs Cuckoo</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Bloom Filter</th>\n<th>Cuckoo Filter</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查询复杂度</td>\n<td>O(k)（k 个哈希函数）</td>\n<td>O(1)（2–4 次 bucket 访问）</td>\n</tr>\n<tr>\n<td>插入复杂度</td>\n<td>O(k)</td>\n<td>平均 O(1)，最坏可能触发重排</td>\n</tr>\n<tr>\n<td>删除支持</td>\n<td>❌ 原生不支持</td>\n<td>✅ 原生支持</td>\n</tr>\n<tr>\n<td>误判率（False Positive）</td>\n<td>可配置，稳定</td>\n<td>可配置，通常更低</td>\n</tr>\n<tr>\n<td>漏判（False Negative）</td>\n<td>❌ 理论上不会</td>\n<td>❌ 理论上不会</td>\n</tr>\n<tr>\n<td>空间利用率</td>\n<td>高（但受 k 影响）</td>\n<td>通常更高（特别是低误判率）</td>\n</tr>\n<tr>\n<td>扩容成本</td>\n<td>高（需重建）</td>\n<td>中等（支持扩展策略）</td>\n</tr>\n<tr>\n<td>实现复杂度</td>\n<td>低</td>\n<td>较高</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>RedisBloom Cuckoo Filter 不支持设置 <code>误判率</code>，通常 容量 越大，误判率越低。</p>\n</blockquote>\n<h2 id=\"CF-命令示例\">CF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Cuckoo Filter</span></span><br><span class=\"line\"><span class=\"comment\">## 容量1000，这个是必填参数。后面几个都是可选参数。</span></span><br><span class=\"line\"><span class=\"comment\">## BUSKETSIZE越大，空间利用率更高，但是误判率也更高，性能更差，默认2</span></span><br><span class=\"line\"><span class=\"comment\">## MAXITARATIONS越小，性能越好。如果设置越大，空间利用率就越好。默认20</span></span><br><span class=\"line\"><span class=\"comment\">## EXPANSION 是指空间扩容的比例。默认1，不扩容</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 可以重复添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回元素出现次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.EXISTS user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 删除元素，一次只删除一个</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 因为user_1有两个，所以才是还是能查询出 user_1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 再次删除</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 同名元素已全部删除，查询不到</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元素不存在时才添加，幂等</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Filter 元信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INFO user:cf</span><br><span class=\"line\"> 1) Size                      <span class=\"comment\"># 当前 Cuckoo Filter 实际占用的内存大小（字节）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1080</span><br><span class=\"line\"> 3) Number of buckets         <span class=\"comment\"># 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2)</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\"> 5) Number of filters         <span class=\"comment\"># 内部 子 Cuckoo Filter 的数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 成功插入的元素总数（近似）</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"> 9) Number of items deleted   <span class=\"comment\"># 已删除元素的累计次数</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">11) Bucket size               <span class=\"comment\"># 每个 bucket 可容纳的 fingerprint 数，默认为 2</span></span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">13) Expansion rate            <span class=\"comment\"># 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）</span></span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">15) Max iterations            <span class=\"comment\"># Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升</span></span><br><span class=\"line\">16) (<span class=\"built_in\">integer</span>) 500</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量添加，key不存在则创建</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order2</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 幂等，元素不存在时才添加</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> order:cf</span><br><span class=\"line\">MBbloomCF</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisCuckooFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 CuckooFilter 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCuckooFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCuckooFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key      Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity 预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter（高级参数）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key           Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity      预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bucketSize    每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxIterations 重排次数，越大成功率越高</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expansion     扩容倍数，默认 1（不扩容）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">int</span> bucketSize, <span class=\"type\">int</span> maxIterations, <span class=\"type\">int</span> expansion)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> String.format(</span><br><span class=\"line\">                <span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;</span>,</span><br><span class=\"line\">                capacity, bucketSize, maxIterations, expansion</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisCuckooFilterTool reserve error:&quot;</span>,e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（不去重）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（仅当不存在时）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 表示成功插入，false 表示已存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addNx</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应的结果，1 表示存在，0 表示不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回元素出现次数（近似）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">count</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除元素</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 删除成功，false 表示不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">delete</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，不去重</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，去重</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 每个元素对应插入结果，1 插入成功，0 插入失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">insertNx</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Cuckoo Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Long&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Long&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> (Long) result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字节数组转字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * info 返回的 List</span></span><br><span class=\"line\"><span class=\"comment\">     * [</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Size&quot;),                  Long(1080),</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Number of buckets&quot;),     Long(512),</span></span><br><span class=\"line\"><span class=\"comment\">     * byte[](&quot;Number of filters&quot;),     Long(1),</span></span><br><span class=\"line\"><span class=\"comment\">     * ...</span></span><br><span class=\"line\"><span class=\"comment\">     * ]</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 示例代码：GitHub Cuckoo Filter（布谷鸟过滤器） Cuckoo Filter 是 Bloom Filter 的改进版，支持 动态添加和删除元素，仍能提供比布隆过滤器更高的查询性能。 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 优点：低误判率 + 高负载率，基于相同的集合和误报率，Cuckoo Filter通常占用空间更少。相对的，算法实现也就更复杂。 缺点：与Bloom Filter一样，有可能将一个不在集合中的元素错误的判断成在集合中 Bloom Filter 的误报率通过调整位数组的大小和哈希函数数量来控制，而 Cuckoo Filter 的误报率受指纹大小和桶大小控制。 布谷哈希算法 百度百科对布谷哈希算法的描述] 算法使用两个不同哈希函数计算对应 key 的位置。 当两个哈希任意位置为空，则随机选择一个位置插入 当两个哈希有位置为空时，则插入到空位置 当两个哈希位置均不为空时，随机选择一个位置插入并踢出原key，原key会再次经过计算获得新的位置，转至1执行，反复直到成功或者达到最大迭代次数。 Cuckoo Filter 的实现原理 布谷过滤器 是在布谷哈希算法的算法基础上扩充来的，但是它所提供的概念不是表，而是提供了多个数据桶(Bucket) 每一个数据桶都是个一维数组，每个数组的保存内容为条目(Entry)，每一个条目里面可以保存一个指纹数据(指纹数据就是原始数据经过哈希计算得到的一个n位的数据标记)，除了指纹数据之外，还会同时得出一个保存位置P1标记。 当两个数据计算得到的指纹数据相同时，就会发生冲突，冲突操作的解决思路是使用布谷哈希算法，简单说就是新的数据会将原有数据踢出，而被踢出的数据会被重新计算得到新的指纹数据和保存位置标记。 布谷过滤器里面需要进行各种数据的踢出操作，这个踢出的方式就是使用P1标志位和指纹数据进行异或计算得出来的P2标志位，按照同样的思路(前提:一直都有冲突操作)一直计算新的P2位，直到冲突解决或者达到最大迭代次数，就会失败。 指纹数据里面包含有唯一性，所以可以实现数据的删除，当然，不同的数据计算是有可能得到相同指纹的，那么一旦删除数据之后，有可能造成数据的&quot;假删除&quot;，所以布谷过滤器本身也是存在有误差的。 Cuckoo Filter 中的 BUSKETSIZE BUSKETSIZE，表示每个桶(Busket)中存放的元素个数，即桶大小。 Cuckoo Filter的数组里存的不是位，而是桶(busket)，每个桶里可以存放多个数据。 同一个桶中存放的数据越多，空间利用率更高，相应的误判率也就越高，性能也更慢。 Redis的CuckooFilter实现中，BUSKETSIZE应该是一个在1到255之间的整数，默认的 BUSKETSIZE 是 2。 桶(Busket)中并不实际保存数据本身，而是保存数据的指纹(fingerprint)。指纹越小，HASH冲突造成误判的几率就越小。这个参数的调整比较复杂，Redis的CuckooFilter中不支持调整这个参数。 CF 命令说明 对应Redis命令： CF.xxx 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 CF.RESERVE 显式创建 Cuckoo Filter 是 capacity：容量(必填)BUCKETSIZE：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)MAXITERATIONS：重排次数，越大成功率越高EXPANSION：扩容倍数，默认 1（不扩容） OK CF.RESERVE user:cf 100000 ✅ 生产推荐支持删除与计数 CF.ADD 添加一个元素，不去重 是 （不存在则创建） item：元素 OK CF.ADD user:cf user_1 若满可能失败 CF.ADDNX 元素不存在时才添加，去重 是 （不存在则创建） item 1 新增0 已存在 CF.ADDNX user:cf user_1 幂等写入首选 CF.INSERT 批量插入 是（不存在则创建） ITEMS：元素列表 OK CF.INSERT user:cf ITEMS u1 u2 默认配置 CF.INSERTNX 批量插入（不存在才加） 是 ITEMS 0/1 列表 CF.INSERTNX user:cf ITEMS u1 u2 幂等 + 批量 CF.EXISTS 判断单个元素是否存在 否 item 1 可能存在0 不存在 CF.EXISTS user:cf user_1 仍有误判 CF.MEXISTS 批量判断是否存在 否 item... 0/1 列表 CF.MEXISTS user:cf u1 u9 高并发推荐 CF.COUNT 返回元素出现次数 否 item 整数 CF.COUNT user:cf user_1 ⭐ Bloom 没有的能力 CF.DEL 删除一个元素 否 item 1 删除成功0 不存在 CF.DEL user:cf user_1 ⭐ Bloom 不支持 CF.INFO 查看 Filter 元信息 否 无 KV 列表 CF.INFO user:cf 运维分析 CF.SCANDUMP 分块导出 Filter 否 iterator iterator + data CF.SCANDUMP user:cf 0 迁移 / 备份 CF.LOADCHUNK 从 dump 恢复 Filter 是 iterator + data OK CF.LOADCHUNK user:cf 1 &quot;xxx&quot; 与 SCANDUMP 配合 Bloom vs Cuckoo 维度 Bloom Filter Cuckoo Filter 查询复杂度 O(k)（k 个哈希函数） O(1)（2–4 次 bucket 访问） 插入复杂度 O(k) 平均 O(1)，最坏可能触发重排 删除支持 ❌ 原生不支持 ✅ 原生支持 误判率（False Positive） 可配置，稳定 可配置，通常更低 漏判（False Negative） ❌ 理论上不会 ❌ 理论上不会 空间利用率 高（但受 k 影响） 通常更高（特别是低误判率） 扩容成本 高（需重建） 中等（支持扩展策略） 实现复杂度 低 较高 RedisBloom Cuckoo Filter 不支持设置 误判率，通常 容量 越大，误判率越低。 CF 命令示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 创建 Cuckoo Filter## 容量1000，这个是必填参数。后面几个都是可选参数。## BUSKETSIZE越大，空间利用率更高，但是误判率也更高，性能更差，默认2## MAXITARATIONS越小，性能越好。如果设置越大，空间利用率就越好。默认20## EXPANSION 是指空间扩容的比例。默认1，不扩容127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2OK# 添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1127.0.0.1:6379&gt; CF.ADD user:cf user_2(integer) 1# 可以重复添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1# 返回元素出现次数127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 2# 判断元素是否存在127.0.0.1:6379&gt; CF.EXISTS user:cf user_1(integer) 1# 批量判断元素是否存在127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_1001) (integer) 12) (integer) 13) (integer) 0# 删除元素，一次只删除一个127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 因为user_1有两个，所以才是还是能查询出 user_1127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 1# 再次删除127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 同名元素已全部删除，查询不到127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 0# 元素不存在时才添加，幂等127.0.0.1:6379&gt; CF.ADDNX user:cf user_2(integer) 0127.0.0.1:6379&gt; CF.ADDNX user:cf user_3(integer) 1# 查看 Filter 元信息127.0.0.1:6379&gt; CF.INFO user:cf 1) Size # 当前 Cuckoo Filter 实际占用的内存大小（字节） 2) (integer) 1080 3) Number of buckets # 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2) 4) (integer) 512 5) Number of filters # 内部 子 Cuckoo Filter 的数量 6) (integer) 1 7) Number of items inserted # 成功插入的元素总数（近似） 8) (integer) 2 9) Number of items deleted # 已删除元素的累计次数10) (integer) 211) Bucket size # 每个 bucket 可容纳的 fingerprint 数，默认为 212) (integer) 213) Expansion rate # 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）14) (integer) 215) Max iterations # Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升16) (integer) 500# 批量添加，key不存在则创建127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order21) (integer) 12) (integer) 1# 幂等，元素不存在时才添加127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order1001) (integer) 02) (integer) 03) (integer) 1# 查看类型127.0.0.1:6379&gt; type order:cfMBbloomCF SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisCuckooFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240package com.example.redisbloom;/** * 基于 RedisBloom 插件的 CuckooFilter 实现 * https://github.com/RedisBloom/RedisBloom/releases */import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;@Component@Slf4jpublic class RedisCuckooFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisCuckooFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 Cuckoo Filter * &lt;p&gt; * 不能重复创建 * * @param key Filter 名称 * @param capacity 预计容量 */ public boolean reserve(String key, long capacity) &#123; String script = &quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot; + capacity + &quot;)&quot;; try&#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisCuckooFilterTool reserve error:&quot;,e); return false; &#125; &#125; /** * 初始化 Cuckoo Filter（高级参数） * * 不能重复创建 * * @param key Filter 名称 * @param capacity 预计容量 * @param bucketSize 每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解) * @param maxIterations 重排次数，越大成功率越高 * @param expansion 扩容倍数，默认 1（不扩容） */ public boolean reserve(String key, long capacity, int bucketSize, int maxIterations, int expansion) &#123; String script = String.format( &quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot; + &quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;, capacity, bucketSize, maxIterations, expansion ); try&#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisCuckooFilterTool reserve error:&quot;,e); return false; &#125; &#125; /** * 添加元素（不去重） */ public boolean add(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 添加元素（仅当不存在时） * * @return true 表示成功插入，false 表示已存在 */ public boolean addNx(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量判断是否存在 * @return 每个元素对应的结果，1 表示存在，0 表示不存在 */ public List&lt;Long&gt; mexists(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 返回元素出现次数（近似） */ public Long count(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key), value ); &#125; /** * 删除元素 * * @return true 删除成功，false 表示不存在 */ public boolean delete(String key, String value) &#123; String script = &quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;; final Long execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量插入，不去重 * @return 每个元素对应插入结果，1 插入成功，0 插入失败 */ public List&lt;Long&gt; insert(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 批量插入，去重 * @return 每个元素对应插入结果，1 插入成功，0 插入失败 */ public List&lt;Boolean&gt; insertNx(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 获取 Cuckoo Filter 元信息 */ public Map&lt;String, Long&gt; info(String key) &#123; String script = &quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;; List&lt;Object&gt; result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Long&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Long value = (Long) result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; /** * 字节数组转字符串 * info 返回的 List * [ * byte[](&quot;Size&quot;), Long(1080), * byte[](&quot;Number of buckets&quot;), Long(512), * byte[](&quot;Number of filters&quot;), Long(1), * ... * ] */ private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125;","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 示例代码：GitHub","date_published":"2025-12-22T06:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","title":"Redis 命令及数据类型 -- BF(Bloom Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom 的安装方法\">Redis 扩展模块 -- RedisBloom 的安装方法</a></li>\n<li class=\"lvl-2\">示例代码：<a href=\"https://github.com/hanqunfeng/springbootchapter/tree/master/springboot3-demo/redis-demo/data-type-demo\">GitHub</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bloom-Filter-布隆过滤器\">Bloom Filter(布隆过滤器)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>布隆过滤器是一种用于快速判断元素是否存在的 probabilistic data structure（概率数据结构），非常适合海量数据且不要求绝对精确的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>布隆过滤器使用一个很长的二进制位数组和一系列哈希函数来保存元素。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">优点: 非常节省空间、查询快</li>\n<li class=\"lvl-6\">缺点: 有一定的误判概率、无法删除元素、无法给元素计数</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>布隆过滤器判断一个元素不在集合中，那么这个元素肯定不在集合中。但是，布隆过滤器判断一个元素在集合中，那么这个元素有可能不在集合中。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/l7rGDM.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>位数组（Bit Array）：布隆过滤器使用一个长度固定的位数组来存储数据。每个位置只占用一个比特（0或1），初始时所有位都设置为0。位数组的长度和哈希函数的数量决定了过滤器的误报率和容量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>哈希函数集合：布隆过滤器使用多个哈希函数，每个函数都会将输入数据映射到位数组的一个不同位置。哈希函数的选择对过滤器的性能有很大影响，理想的哈希函数应该具有良好的散列性，使得不同的输入尽可能均匀地映射到位数组的不同位置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如何降低误判率？</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">更大的位数组</li>\n<li class=\"lvl-6\">更多的哈希函数</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>很多人都是用过Google开源的Guava的布隆过滤器，但其是JVM层的布隆过滤器，若需要分布式布隆过滤器，就可以使用RedisBloom提供的BF(Bloom Filter)。</p>\n</li>\n</ul>\n<h2 id=\"BF-命令说明\">BF 命令说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>BF.xxx</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>BF.RESERVE</strong></td>\n<td>显式创建 Bloom Filter</td>\n<td>是（已存在则报错）</td>\n<td><code>error_rate</code>：误判率<br><code>capacity</code>：预计元素数<br><code>EXPANSION</code>：扩容倍率</td>\n<td>OK</td>\n<td><code>BF.RESERVE user:bf 0.001 1000000</code></td>\n<td>✅ <strong>生产推荐</strong><br>显式规划容量与误判率，避免隐式创建</td>\n</tr>\n<tr>\n<td><strong>BF.ADD</strong></td>\n<td>添加单个元素</td>\n<td>是（不存在则创建）</td>\n<td>无</td>\n<td><code>1</code> 新增<br><code>0</code> 可能已存在</td>\n<td><code>BF.ADD user:bf user_1</code></td>\n<td>Key 必须已存在，否则报错</td>\n</tr>\n<tr>\n<td><strong>BF.MADD</strong></td>\n<td>批量添加元素</td>\n<td>是（不存在则创建）</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MADD user:bf u1 u2 u3</code></td>\n<td>⚠ 使用默认配置，不建议生产</td>\n</tr>\n<tr>\n<td><strong>BF.INSERT</strong></td>\n<td>批量插入（可控参数）</td>\n<td>是</td>\n<td><code>CAPACITY</code>：容量<br><code>ERROR</code>：误判率<br><code>NOCREATE</code>:不自动创建过滤器<br><code>NONSCALING</code>: 不扩容，达到capacity时，过滤器返回错误<br><code>EXPANSION expansion</code>:扩容时，新建子过滤器的容量增长倍率，默认2 <br><code>ITEMS</code>：元素列表</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2</code></td>\n<td>✅ <strong>最推荐的写入方式</strong><br>支持初始化 + 插入</td>\n</tr>\n<tr>\n<td><strong>BF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code>：待判断元素</td>\n<td><code>1</code> 可能存在<br><code>0</code> 一定不存在</td>\n<td><code>BF.EXISTS user:bf user_1</code></td>\n<td>不存在结果 <strong>绝对可靠</strong></td>\n</tr>\n<tr>\n<td><strong>BF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MEXISTS user:bf u1 u9</code></td>\n<td>高并发批量查询首选</td>\n</tr>\n<tr>\n<td><strong>BF.CARD</strong></td>\n<td>返回插入元素数量（近似）</td>\n<td>否</td>\n<td>无</td>\n<td>整数</td>\n<td><code>BF.CARD user:bf</code></td>\n<td>用于容量监控，非精确</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://BF.INFO\">BF.INFO</a></strong></td>\n<td>返回 Bloom Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>BF.INFO user:bf</code></td>\n<td>运维、容量与内存分析必备</td>\n</tr>\n<tr>\n<td><strong>BF.SCANDUMP</strong></td>\n<td>分块导出 Bloom Filter</td>\n<td>否</td>\n<td><code>iterator</code>：游标</td>\n<td><code>iterator + data</code></td>\n<td><code>BF.SCANDUMP user:bf 0</code></td>\n<td>用于迁移、备份</td>\n</tr>\n<tr>\n<td><strong>BF.LOADCHUNK</strong></td>\n<td>从 dump 数据恢复 Filter</td>\n<td>是</td>\n<td><code>iterator</code><br><code>data</code></td>\n<td>OK</td>\n<td><code>BF.LOADCHUNK user:bf 1 &quot;xxx&quot;</code></td>\n<td>必须与 SCANDUMP 配合使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"BF-命令示例\">BF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化一个BloomFilter，错误率0.01，元素数量1000</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.RESERVE <span class=\"built_in\">test</span> 0.01 1000</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">MBbloom--</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MADD <span class=\"built_in\">test</span> user3 user4 user5</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回Bloom过滤器的基数，即添加的元素数量(存在误差)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.CARD <span class=\"built_in\">test</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 批量查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MEXISTS <span class=\"built_in\">test</span> user1 user2 user6</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.INFO <span class=\"built_in\">test</span></span><br><span class=\"line\"> 1) Capacity       <span class=\"comment\"># 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\"> 3) Size           <span class=\"comment\"># 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 1480</span><br><span class=\"line\"> 5) Number of filters <span class=\"comment\"># 当前 key 内部包含的 Bloom Filter 数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 已调用 BF.ADD / BF.MADD 插入的元素总数</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"> 9) Expansion rate     <span class=\"comment\"># Bloom Filter 扩容时，新建子过滤器的容量增长倍率</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisBloomFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 BloomFilter 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 不想安装插件也可以使用 Redission 的 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisBloomFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisBloomFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率，比如为0.01，即 1%</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量，比如为1000</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">double</span> errorRate, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot;</span> + errorRate + <span class=\"string\">&quot;, &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, String.class),</span><br><span class=\"line\">                    Collections.singletonList(key)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;RedisBloomFilterTool reserve error:&quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 RedisModule 提供的 BF.ADD 命令</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">execute</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                value</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(execute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">addBatch</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> items     要添加的元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 添加结果列表，成功 1，失败 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">double</span> errorRate, String... items)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], &#x27;CAPACITY&#x27;, ARGV[1], &#x27;ERROR&#x27;, ARGV[2], &#x27;ITEMS&#x27;, unpack(ARGV, 3))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Object&gt; args = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        args.add(String.valueOf(capacity));</span><br><span class=\"line\">        args.add(String.valueOf(errorRate));</span><br><span class=\"line\">        Collections.addAll(args, items);   <span class=\"comment\">// ✅ 关键点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.INSERT 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                args.toArray()</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 存在 1，不存在 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Long&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key),</span><br><span class=\"line\">                items</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取元素数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">card</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 RedisModule 提供的 BF.CARD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Bloom Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Long&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, List.class),</span><br><span class=\"line\">                Collections.singletonList(key)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Long&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> (Long) result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-与-Redisson-集成之-BloomFilter-的使用方法\">SpringBoot 与 Redisson 集成之 BloomFilter 的使用方法</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.52.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">……………………………………………………………………………………………………………………………………………………………………………………………………………………</span><br><span class=\"line\">RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(<span class=\"string\">&quot;bloomFilter&quot;</span>);</span><br><span class=\"line\">bloomFilter.tryInit(<span class=\"number\">1000000</span>, <span class=\"number\">0.01</span>); <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">bloomFilter.add(<span class=\"string\">&quot;test&quot;</span>); <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">System.out.println(bloomFilter.contains(<span class=\"string\">&quot;test&quot;</span>)); <span class=\"comment\">// 判断是否存在</span></span><br><span class=\"line\">System.out.println(bloomFilter.count()); <span class=\"comment\">// 获取当前布隆过滤器中已添加的元素个数</span></span><br><span class=\"line\">System.out.println(bloomFilter.getSize()); <span class=\"comment\">// 获取当前布隆过滤器占用内存的大小，单位bit</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 示例代码：GitHub Bloom Filter(布隆过滤器) 布隆过滤器是一种用于快速判断元素是否存在的 probabilistic data structure（概率数据结构），非常适合海量数据且不要求绝对精确的场景。 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 布隆过滤器使用一个很长的二进制位数组和一系列哈希函数来保存元素。 优点: 非常节省空间、查询快 缺点: 有一定的误判概率、无法删除元素、无法给元素计数 布隆过滤器判断一个元素不在集合中，那么这个元素肯定不在集合中。但是，布隆过滤器判断一个元素在集合中，那么这个元素有可能不在集合中。 位数组（Bit Array）：布隆过滤器使用一个长度固定的位数组来存储数据。每个位置只占用一个比特（0或1），初始时所有位都设置为0。位数组的长度和哈希函数的数量决定了过滤器的误报率和容量。 哈希函数集合：布隆过滤器使用多个哈希函数，每个函数都会将输入数据映射到位数组的一个不同位置。哈希函数的选择对过滤器的性能有很大影响，理想的哈希函数应该具有良好的散列性，使得不同的输入尽可能均匀地映射到位数组的不同位置。 如何降低误判率？ 更大的位数组 更多的哈希函数 很多人都是用过Google开源的Guava的布隆过滤器，但其是JVM层的布隆过滤器，若需要分布式布隆过滤器，就可以使用RedisBloom提供的BF(Bloom Filter)。 BF 命令说明 对应Redis命令： BF.xxx 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 BF.RESERVE 显式创建 Bloom Filter 是（已存在则报错） error_rate：误判率capacity：预计元素数EXPANSION：扩容倍率 OK BF.RESERVE user:bf 0.001 1000000 ✅ 生产推荐显式规划容量与误判率，避免隐式创建 BF.ADD 添加单个元素 是（不存在则创建） 无 1 新增0 可能已存在 BF.ADD user:bf user_1 Key 必须已存在，否则报错 BF.MADD 批量添加元素 是（不存在则创建） item...：多个元素 0/1 列表 BF.MADD user:bf u1 u2 u3 ⚠ 使用默认配置，不建议生产 BF.INSERT 批量插入（可控参数） 是 CAPACITY：容量ERROR：误判率NOCREATE:不自动创建过滤器NONSCALING: 不扩容，达到capacity时，过滤器返回错误EXPANSION expansion:扩容时，新建子过滤器的容量增长倍率，默认2 ITEMS：元素列表 0/1 列表 BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2 ✅ 最推荐的写入方式支持初始化 + 插入 BF.EXISTS 判断单个元素是否存在 否 item：待判断元素 1 可能存在0 一定不存在 BF.EXISTS user:bf user_1 不存在结果 绝对可靠 BF.MEXISTS 批量判断是否存在 否 item...：多个元素 0/1 列表 BF.MEXISTS user:bf u1 u9 高并发批量查询首选 BF.CARD 返回插入元素数量（近似） 否 无 整数 BF.CARD user:bf 用于容量监控，非精确 BF.INFO 返回 Bloom Filter 元信息 否 无 KV 列表 BF.INFO user:bf 运维、容量与内存分析必备 BF.SCANDUMP 分块导出 Bloom Filter 否 iterator：游标 iterator + data BF.SCANDUMP user:bf 0 用于迁移、备份 BF.LOADCHUNK 从 dump 数据恢复 Filter 是 iteratordata OK BF.LOADCHUNK user:bf 1 &quot;xxx&quot; 必须与 SCANDUMP 配合使用 BF 命令示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 初始化一个BloomFilter，错误率0.01，元素数量1000127.0.0.1:6379&gt; BF.RESERVE test 0.01 1000OK# 查看类型127.0.0.1:6379&gt; type testMBbloom--# 添加元素127.0.0.1:6379&gt; BF.ADD test user1(integer) 1127.0.0.1:6379&gt; BF.ADD test user2(integer) 1# 批量添加元素127.0.0.1:6379&gt; BF.MADD test user3 user4 user51) (integer) 12) (integer) 13) (integer) 1# 返回Bloom过滤器的基数，即添加的元素数量(存在误差)127.0.0.1:6379&gt; BF.CARD test(integer) 5# 查询元素是否存在127.0.0.1:6379&gt; BF.EXISTS test user2(integer) 1127.0.0.1:6379&gt; BF.EXISTS test user6(integer) 0# 批量查询元素是否存在127.0.0.1:6379&gt; BF.MEXISTS test user1 user2 user61) (integer) 12) (integer) 13) (integer) 0# 获取信息127.0.0.1:6379&gt; BF.INFO test 1) Capacity # 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter） 2) (integer) 1000 3) Size # 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少 4) (integer) 1480 5) Number of filters # 当前 key 内部包含的 Bloom Filter 数量 6) (integer) 1 7) Number of items inserted # 已调用 BF.ADD / BF.MADD 插入的元素总数 8) (integer) 5 9) Expansion rate # Bloom Filter 扩容时，新建子过滤器的容量增长倍率10) (integer) 2 SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisBloomFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.example.redisbloom;/** * 基于 RedisBloom 插件的 BloomFilter 实现 * https://github.com/RedisBloom/RedisBloom/releases * &lt;p&gt; * 不想安装插件也可以使用 Redission 的 BloomFilter */import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.*;@Component@Slf4jpublic class RedisBloomFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisBloomFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 BloomFilter * &lt;p&gt; * 不能重复创建 * * @param key BloomFilter 名称 * @param errorRate 错误率，比如为0.01，即 1% * @param capacity 容量，比如为1000 */ public boolean reserve(String key, double errorRate, long capacity) &#123; String script = &quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot; + errorRate + &quot;, &quot; + capacity + &quot;)&quot;; try &#123; redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, String.class), Collections.singletonList(key) ); return true; &#125; catch (Exception e) &#123; log.error(&quot;RedisBloomFilterTool reserve error:&quot;, e); return false; &#125; &#125; /** * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建 */ public boolean add(String key, String value) &#123; // 使用 RedisModule 提供的 BF.ADD 命令 String script = &quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; String script = &quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;; final Boolean execute = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Boolean.class), Collections.singletonList(key), value ); return Boolean.TRUE.equals(execute); &#125; /** * 批量添加 * @return 添加结果列表，成功 1，失败 0 */ public List&lt;Long&gt; addBatch(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 调用 BF.MADD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate * * @param key BloomFilter 名称 * @param capacity 容量 * @param errorRate 错误率 * @param items 要添加的元素 * @return 添加结果列表，成功 1，失败 0 */ public List&lt;Long&gt; insert(String key, long capacity, double errorRate, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], &#x27;CAPACITY&#x27;, ARGV[1], &#x27;ERROR&#x27;, ARGV[2], &#x27;ITEMS&#x27;, unpack(ARGV, 3))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; List&lt;Object&gt; args = new ArrayList&lt;&gt;(); args.add(String.valueOf(capacity)); args.add(String.valueOf(errorRate)); Collections.addAll(args, items); // ✅ 关键点 // 调用 BF.INSERT 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), args.toArray() ); &#125; /** * 批量判断元素是否存在 * @return 存在 1，不存在 0 */ public List&lt;Long&gt; mexists(String key, String... items) &#123; String script = &quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 调用 BF.MADD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key), items ); &#125; /** * 获取元素数量 */ public Long card(String key) &#123; String script = &quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;; // 使用 RedisModule 提供的 BF.CARD 命令 return redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, Long.class), Collections.singletonList(key) ); &#125; /** * 获取 Bloom Filter 元信息 */ public Map&lt;String, Long&gt; info(String key) &#123; String script = &quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;; List&lt;Object&gt; result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(script, List.class), Collections.singletonList(key) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Long&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Long value = (Long) result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125; SpringBoot 与 Redisson 集成之 BloomFilter 的使用方法 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.52.0&lt;/version&gt;&lt;/dependency&gt; 12345678910@Autowiredprivate RedissonClient redissonClient;……………………………………………………………………………………………………………………………………………………………………………………………………………………RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(&quot;bloomFilter&quot;);bloomFilter.tryInit(1000000, 0.01); // 初始化bloomFilter.add(&quot;test&quot;); // 添加元素System.out.println(bloomFilter.contains(&quot;test&quot;)); // 判断是否存在System.out.println(bloomFilter.count()); // 获取当前布隆过滤器中已添加的元素个数System.out.println(bloomFilter.getSize()); // 获取当前布隆过滤器占用内存的大小，单位bit","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom 的安装方法 示例代码：GitHub","date_published":"2025-12-22T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","url":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","title":"Redis 扩展模块 -- RedisBloom 的安装方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisBloom 的安装方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">操作系统：<code>Amazon Linux 2023(内核 6.1)</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisBloom-简介\">RedisBloom 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisBloom/RedisBloom\">RedisBloom</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisBloom 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。</p>\n</li>\n</ul>\n<h2 id=\"RedisBloom-提供的核心数据结构\">RedisBloom 提供的核心数据结构</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装好RedisBloom后，我们可以通过如下方式查看RedisBloom 支持的命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上所有 Stack Module Commands都是通过如下命令查看，因为我们这里只安装了 RedisBloom，所以此时仅可以看到 RedisBloom 模块的命令</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">help</span> @module</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过输出我们可以看到-RedisBloom-模块支持的命令大致分为-5-类\">通过输出我们可以看到 RedisBloom 模块支持的命令大致分为 5 类</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Bloom Filter（布隆过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></li>\n<li class=\"lvl-6\">生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></li>\n<li class=\"lvl-6\">对应Redis命令： <code>BF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-11-BF/\" title=\"Redis 命令及数据类型 -- BF(Bloom Filter)\">Redis 命令及数据类型 -- BF(Bloom Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>2️⃣ Cuckoo Filter（布谷鸟过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Bloom Filter 的增强版，支持 删除元素</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></li>\n<li class=\"lvl-6\">在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</li>\n<li class=\"lvl-6\">低误判率 + 高负载率场景，Cuckoo Filter 更省内存。</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-12-CF/\" title=\"Redis 命令及数据类型 -- CF(Cuckoo Filter)\">Redis 命令及数据类型 -- CF(Cuckoo Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3️⃣ Count-Min Sketch（CMS）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">近似统计元素出现频率</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CMS.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-13-CMS/\" title=\"Redis 命令及数据类型 -- CMS(Count-Min Sketch)\">Redis 命令及数据类型 -- CMS(Count-Min Sketch)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>4️⃣ Top-K</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">统计访问频率最高的 K 个元素</li>\n<li class=\"lvl-6\">对应Redis命令： <code>TOPK.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-14-TopK/\" title=\"Redis 命令及数据类型 -- TopK\">Redis 命令及数据类型 -- TopK</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>5️⃣ TDigest</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">统计数字的分布</li>\n<li class=\"lvl-6\">对应Redis命令： <code>TDIGEST.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/23/redis7-datatype-15-TDigest/\" title=\"Redis 命令及数据类型 -- TDigest\">Redis 命令及数据类型 -- TDigest</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装-RedisBloom\">安装 RedisBloom</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是从<a href=\"https://cloud.redis.io\">Redis Cloud</a>的<code>Download Center</code>中进行下载，其提供了所有Redis模块编译后的<code>.so</code>文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/rguEIA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>源码编译</p>\n</li>\n</ul>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisbloom.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install -y \\</span><br><span class=\"line\">  gcc \\</span><br><span class=\"line\">  gcc-c++ \\</span><br><span class=\"line\">  make \\</span><br><span class=\"line\">  cmake \\</span><br><span class=\"line\">  autoconf \\</span><br><span class=\"line\">  automake \\</span><br><span class=\"line\">  libtool \\</span><br><span class=\"line\">  pkgconfig \\</span><br><span class=\"line\">  openssl-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编译RedisBloom</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisBloom</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.8.17</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: 7fc8e62</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y git jq</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --modern</span><br><span class=\"line\">dnf install -q -y valgrind</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/sbin/get-fbinfer</span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r tests/flow/requirements.txt</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  pudb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...</span><br><span class=\"line\"></span><br><span class=\"line\">Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...</span><br><span class=\"line\">-- The C compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- The CXX compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- Detecting C compiler ABI info</span><br><span class=\"line\">-- Detecting C compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working C compiler: /usr/bin/gcc - skipped</span><br><span class=\"line\">-- Detecting C compile features</span><br><span class=\"line\">-- Detecting C compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Detecting CXX compiler ABI info</span><br><span class=\"line\">-- Detecting CXX compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working CXX compiler: /usr/bin/g++ - skipped</span><br><span class=\"line\">-- Detecting CXX compile features</span><br><span class=\"line\">-- Detecting CXX compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Setting build <span class=\"built_in\">type</span> to <span class=\"string\">&#x27;Release&#x27;</span> as none was specified.</span><br><span class=\"line\">-- Configuring <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Generating <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c</span><br><span class=\"line\"></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...</span><br><span class=\"line\">[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o</span><br><span class=\"line\">[100%] Linking C static library libtdigest_static.a</span><br><span class=\"line\">[100%] Built target tdigest_static</span><br><span class=\"line\">Compiling deps/bloom/bloom.c...</span><br><span class=\"line\">Compiling deps/murmur2/MurmurHash2.c...</span><br><span class=\"line\">Compiling deps/rmutil/util.c...</span><br><span class=\"line\">Compiling src/rebloom.c...</span><br><span class=\"line\">Compiling src/sb.c...</span><br><span class=\"line\">Compiling src/cf.c...</span><br><span class=\"line\">Compiling src/rm_topk.c...</span><br><span class=\"line\">Compiling src/rm_tdigest.c...</span><br><span class=\"line\">Compiling src/topk.c...</span><br><span class=\"line\">Compiling src/rm_cms.c...</span><br><span class=\"line\">Compiling src/cms.c...</span><br><span class=\"line\">Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so...</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，类似于CentOS 9，第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">……</span><br><span class=\"line\">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\">Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:</span><br><span class=\"line\">346      \t\t<span class=\"comment\"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class=\"line\">347      \t<span class=\"keyword\">fi</span></span><br><span class=\"line\">348</span><br><span class=\"line\">349  &gt;&gt;&gt; \tinstall_raven</span><br><span class=\"line\">350      \tinstall_remi</span><br><span class=\"line\">351      \t<span class=\"comment\"># install_centos_stream_repos</span></span><br><span class=\"line\">352</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/sbin/setup:</span><br><span class=\"line\">16       \tpython3 -m pip list</span><br><span class=\"line\">17       <span class=\"keyword\">fi</span></span><br><span class=\"line\">18</span><br><span class=\"line\">19   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py</span><br><span class=\"line\">20       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">21       \tpython3 -m pip list</span><br><span class=\"line\">22       <span class=\"keyword\">fi</span> 编译安装时报错</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 错误分析与解决方法</span></span><br><span class=\"line\">问题原因：</span><br><span class=\"line\">    你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。</span><br><span class=\"line\">readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。</span><br><span class=\"line\">    这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。</span><br><span class=\"line\">    RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel</span><br><span class=\"line\">    这个脚本用于：</span><br><span class=\"line\">        安装 EPEL</span><br><span class=\"line\">        安装 Raven Repo（EL9 特有）</span><br><span class=\"line\">        安装 Remi Repo</span><br><span class=\"line\">    但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。</span><br><span class=\"line\">    你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm</span><br><span class=\"line\">    说明你使用的可能是如下系统中的一个：</span><br><span class=\"line\">        RHEL 9</span><br><span class=\"line\">        Rocky Linux 9</span><br><span class=\"line\">        AlmaLinux 9</span><br><span class=\"line\">        CentOS Stream 9</span><br><span class=\"line\"></span><br><span class=\"line\">推荐解决方案:</span><br><span class=\"line\">   Raven Repo 并非是 ReidsBloom 的必要依赖，所以直接修改 getepel 脚本，禁用 install_raven</span><br><span class=\"line\">   vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <code>redisbloom.so</code> 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意 .so 文件需要具有可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 启用模块有三种方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 2.也可以通过如下方式加载模块</span></span><br><span class=\"line\">redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 3.不需要重启redis</span></span><br><span class=\"line\">redis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>加载方式</th>\n<th>是否持久</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MODULE LOAD</code>（redis-cli）</td>\n<td>❌ 仅当前进程</td>\n</tr>\n<tr>\n<td>命令行 <code>redis-server --loadmodule</code></td>\n<td>❌ 仅本次启动</td>\n</tr>\n<tr>\n<td><code>redis.conf</code> 中 <code>loadmodule</code></td>\n<td>✅ <strong>永久生效</strong> （推荐/生产）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; info Modules</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 简介 RedisBloom 是 Redis 官方维护的一个扩展模块，隶属于 Redis Stack，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。 它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisBloom 已经内置在 Redis 中，可以在安装redis同时安装全部 Stack 模块。 RedisBloom 提供的核心数据结构 安装好RedisBloom后，我们可以通过如下方式查看RedisBloom 支持的命令 12# 实际上所有 Stack Module Commands都是通过如下命令查看，因为我们这里只安装了 RedisBloom，所以此时仅可以看到 RedisBloom 模块的命令&gt; help @module 通过输出我们可以看到 RedisBloom 模块支持的命令大致分为 5 类 1️⃣ Bloom Filter（布隆过滤器） 判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 对应Redis命令： BF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- BF(Bloom Filter) 2️⃣ Cuckoo Filter（布谷鸟过滤器） Bloom Filter 的增强版，支持 删除元素 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 低误判率 + 高负载率场景，Cuckoo Filter 更省内存。 对应Redis命令： CF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- CF(Cuckoo Filter) 3️⃣ Count-Min Sketch（CMS） 近似统计元素出现频率 对应Redis命令： CMS.xxx，详细的使用方法参见 Redis 命令及数据类型 -- CMS(Count-Min Sketch) 4️⃣ Top-K 统计访问频率最高的 K 个元素 对应Redis命令： TOPK.xxx，详细的使用方法参见 Redis 命令及数据类型 -- TopK 5️⃣ TDigest 统计数字的分布 对应Redis命令： TDIGEST.xxx，详细的使用方法参见 Redis 命令及数据类型 -- TDigest 安装 RedisBloom 最简单的方式就是从Redis Cloud的Download Center中进行下载，其提供了所有Redis模块编译后的.so文件，可以优先进行尝试，但是并不保证一定兼容，所以最稳妥的方式是通过源码自己编译。 源码编译 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redisbloom.so上传到国内服务器即可。 安装依赖 12345678910sudo dnf install -y \\ gcc \\ gcc-c++ \\ make \\ cmake \\ autoconf \\ automake \\ libtool \\ pkgconfig \\ openssl-devel 编译RedisBloom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom# 推荐切换到稳定的release版本git checkout v2.8.17# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: 7fc8e62dnf install -q -y ca-certificatesdnf install -q -y wget unzip/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8dnf install -q -y git jqdnf install -q -y which/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --moderndnf install -q -y valgrind/usr/local/soft/modules/RedisBloom/sbin/get-fbinferdnf install -q -y lcov/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr/usr/bin/python3 -m pip install --disable-pip-version-check --user -r tests/flow/requirements.txt/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws/usr/bin/python3 -m pip install --disable-pip-version-check --user pudb# 编译make# 输出Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...-- The C compiler identification is GNU 11.5.0-- The CXX compiler identification is GNU 11.5.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/gcc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/g++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Setting build type to &#x27;Release&#x27; as none was specified.-- Configuring done-- Generating done-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-cBuilding /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o[100%] Linking C static library libtdigest_static.a[100%] Built target tdigest_staticCompiling deps/bloom/bloom.c...Compiling deps/murmur2/MurmurHash2.c...Compiling deps/rmutil/util.c...Compiling src/rebloom.c...Compiling src/sb.c...Compiling src/cf.c...Compiling src/rm_topk.c...Compiling src/rm_tdigest.c...Compiling src/topk.c...Compiling src/rm_cms.c...Compiling src/cms.c...Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so... ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，类似于CentOS 9，第一次运行会报错，大致报错信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647./sbin/setup## 错误信息……[FAILED] raven-release.el9.noarch.rpm: Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:346 # xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm347 fi348349 &gt;&gt;&gt; install_raven350 install_remi351 # install_centos_stream_repos352command failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepelIn /usr/local/soft/modules/RedisBloom/sbin/setup:16 python3 -m pip list17 fi1819 &gt;&gt;&gt; $ROOT/sbin/system-setup.py20 if [[ $VERBOSE == 1 ]]; then21 python3 -m pip list22 fi 编译安装时报错## 错误分析与解决方法问题原因： 你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。 这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。 RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel 这个脚本用于： 安装 EPEL 安装 Raven Repo（EL9 特有） 安装 Remi Repo 但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。 你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm 说明你使用的可能是如下系统中的一个： RHEL 9 Rocky Linux 9 AlmaLinux 9 CentOS Stream 9推荐解决方案: Raven Repo 并非是 ReidsBloom 的必要依赖，所以直接修改 getepel 脚本，禁用 install_raven vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可 Redis 启用模块 将生成的 redisbloom.so 拷贝到 redis 的 modules 目录下（非必须），目录不存在则创建 12# 注意 .so 文件需要具有可执行权限cp bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so Redis 启用模块有三种方法 123456# 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 2.也可以通过如下方式加载模块redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 3.不需要重启redisredis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so 加载方式 是否持久 MODULE LOAD（redis-cli） ❌ 仅当前进程 命令行 redis-server --loadmodule ❌ 仅本次启动 redis.conf 中 loadmodule ✅ 永久生效 （推荐/生产） 本文采用 loadmodule 加载模块 123456789101112131415161718192021222324# 将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; info Modules## 输出# Modulesmodule:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的安装方法 本文基于redis-7.4.7，springboot-3.5.8 操作系统：Amazon Linux 2023(内核 6.1) Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-21T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","url":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","title":"Redis 命令及数据类型 -- Stream","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Stream 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Stream-核心详解\">Stream 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的<code>消息队列</code>，底层用<code>基数树+链表</code>实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。</p>\n</li>\n<li class=\"lvl-2\">\n<p>建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Stream 与传统的MQ 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Redis Stream</th>\n<th>RabbitMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据模型</strong></td>\n<td>类似日志的有序 KV 消息流（ID → field/value）</td>\n<td>队列（FIFO）</td>\n<td>日志分区（Partitioned Append-Only Log）</td>\n</tr>\n<tr>\n<td><strong>消息持久化</strong></td>\n<td>可选持久化（AOF / RDB），默认内存优先</td>\n<td>可持久化到磁盘</td>\n<td>持久化到磁盘，顺序写入，效率高</td>\n</tr>\n<tr>\n<td><strong>消息确认</strong></td>\n<td>XACK 对单条消息确认，支持 Pending 消息管理</td>\n<td>ACK / NACK</td>\n<td>Offset 控制，Consumer 自行提交</td>\n</tr>\n<tr>\n<td><strong>消费模式</strong></td>\n<td>支持 Consumer Group，多消费者共享 Pending 消息</td>\n<td>Queue 绑定 Consumer，多消费者抢占</td>\n<td>Consumer Group，多消费者平行消费</td>\n</tr>\n<tr>\n<td><strong>重复消费</strong></td>\n<td>默认可能重复，需要应用端幂等</td>\n<td>可通过 ACK/NACK 控制</td>\n<td>默认可能重复，Consumer 需幂等处理</td>\n</tr>\n<tr>\n<td><strong>消息顺序</strong></td>\n<td>按 Stream ID 顺序，可保证分组内顺序</td>\n<td>队列顺序保证</td>\n<td>Partition 内顺序保证</td>\n</tr>\n<tr>\n<td><strong>消息保留策略</strong></td>\n<td>可配置 maxlen / minid，按时间或长度裁剪</td>\n<td>队列长度 / TTL 控制</td>\n<td>基于时间或大小保留（Retention Policy）</td>\n</tr>\n<tr>\n<td><strong>延时/定时消费</strong></td>\n<td>原生不支持延时队列，需要应用端处理</td>\n<td>支持插件或 TTL</td>\n<td>原生不支持，需要应用端处理或 Kafka Streams</td>\n</tr>\n<tr>\n<td><strong>事务与原子操作</strong></td>\n<td>事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项</td>\n<td>原生事务支持（事务 / confirm 模式）</td>\n<td>不支持事务，依赖幂等生产者</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>内存级高吞吐，持久化会有开销</td>\n<td>中等，受磁盘和网络限制</td>\n<td>高吞吐，顺序写入磁盘效率极高</td>\n</tr>\n<tr>\n<td><strong>典型使用场景</strong></td>\n<td>事件日志、轻量 MQ、内部异步流水线</td>\n<td>企业级消息、任务调度、RPC</td>\n<td>大数据管道、日志收集、流处理</td>\n</tr>\n<tr>\n<td><strong>多语言支持</strong></td>\n<td>客户端支持多种语言（Java、Python、Go 等）</td>\n<td>客户端丰富</td>\n<td>客户端丰富</td>\n</tr>\n<tr>\n<td><strong>易运维性</strong></td>\n<td>单节点即可使用，但持久化需关注内存</td>\n<td>集群较复杂，需要 RabbitMQ 集群</td>\n<td>集群复杂度高，需要 ZooKeeper 或 KRaft</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"底层核心实现\">底层核心实现</h3>\n<ol>\n<li class=\"lvl-3\">\n<p>存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。</p>\n</li>\n<li class=\"lvl-3\">\n<p>持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。</p>\n</li>\n<li class=\"lvl-3\">\n<p>核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。</p>\n</li>\n</ol>\n<h2 id=\"Stream-核心基础操作（必用）\">Stream 核心基础操作（必用）</h2>\n<h3 id=\"1-生产消息（XADD）：写入队列\">1. 生产消息（XADD）：写入队列</h3>\n<p>• 核心命令：<code>XADD key ID 字段1 值1 字段2 值2 ...</code>，ID 写*表示自动生成（生产首选）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XADD key</span><br><span class=\"line\">     [NOMKSTREAM]</span><br><span class=\"line\">     [MAXLEN | MINID [= | ~] threshold [LIMIT count]]</span><br><span class=\"line\">     * | <span class=\"built_in\">id</span></span><br><span class=\"line\">     field value [field value ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称</span></span><br><span class=\"line\"><span class=\"comment\"># NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败</span></span><br><span class=\"line\"><span class=\"comment\"># MAXLEN threshold —— 按长度裁剪</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高</span></span><br><span class=\"line\"><span class=\"comment\"># LIMIT count —— 每次最多裁剪多少条</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程</span></span><br><span class=\"line\"><span class=\"comment\"># MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）</span></span><br><span class=\"line\"><span class=\"comment\">#   MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略</span></span><br><span class=\"line\"><span class=\"comment\"># * | id —— 消息 ID</span></span><br><span class=\"line\"><span class=\"comment\">#   *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理</span></span><br><span class=\"line\"><span class=\"comment\">#   id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败</span></span><br><span class=\"line\"><span class=\"comment\"># field value —— 消息体（Payload）</span></span><br><span class=\"line\"><span class=\"comment\">#   至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改</span></span><br></pre></td></tr></table></figure>\n<p>• 示例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向订单队列写入1条消息，自动生成消息ID</span></span><br><span class=\"line\">XADD order_stream * uid 1001 order_no ORD20251220 price 299</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保留某个时间点之后的日志</span></span><br><span class=\"line\">XADD <span class=\"built_in\">log</span> MINID ~ 1689900000000-0 * level INFO msg <span class=\"string\">&quot;startup&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-消费消息（2种核心模式）\">2. 消费消息（2种核心模式）</h3>\n<h4 id=\"（1）-独立消费（无消费组）：一对一消费，适合简单场景\">（1） 独立消费（无消费组）：一对一消费，适合简单场景</h4>\n<p>• XREAD：主动拉取消息，支持阻塞/非阻塞</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREAD</span><br><span class=\"line\">  [COUNT count]</span><br><span class=\"line\">  [BLOCK milliseconds]</span><br><span class=\"line\">  STREAMS key [key ...]</span><br><span class=\"line\">          <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count —— 单次最多读取多少条，是“上限”，不是保证值</span></span><br><span class=\"line\"><span class=\"comment\"># BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil</span></span><br><span class=\"line\"><span class=\"comment\">#   BLOCK 0: 无限阻塞，直到有新消息</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身</span></span><br><span class=\"line\"><span class=\"comment\">#   普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0</span></span><br><span class=\"line\"><span class=\"comment\">#   $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $</span></span><br></pre></td></tr></table></figure>\n<p>• 示例1（非阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从开头拉5条消息</span></span><br><span class=\"line\">XREAD COUNT 5 STREAMS order_stream 0-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span>          <span class=\"comment\"># Stream名称</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span>          <span class=\"comment\"># 消息体 键值对</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br></pre></td></tr></table></figure>\n<p>• 示例2（阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。</span></span><br><span class=\"line\">XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $</span><br></pre></td></tr></table></figure>\n<h4 id=\"（2）-消费组消费（XGROUP）：一对多消费，核心生产模式\">（2） 消费组消费（XGROUP）：一对多消费，核心生产模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。</p>\n</li>\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">先创建消费组<code>XGROUP CREATE</code></li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE key group <span class=\"built_in\">id</span>|$</span><br><span class=\"line\">       [MKSTREAM]</span><br><span class=\"line\">       [ENTRIESREAD entries-read]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key：Stream 名称，为指定的Stream创建消费组</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group</span></span><br><span class=\"line\"><span class=\"comment\"># id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。</span></span><br><span class=\"line\"><span class=\"comment\"># [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用</span></span><br><span class=\"line\"><span class=\"comment\"># [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：创建group1消费组，从最新订单消息开始消费</span></span><br><span class=\"line\">XGROUP CREATE order_stream group1 $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>消费者拉取消息<code>XREADGROUP</code></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREADGROUP GROUP group consumer</span><br><span class=\"line\">           [COUNT count]</span><br><span class=\"line\">           [BLOCK milliseconds]</span><br><span class=\"line\">           [NOACK]</span><br><span class=\"line\">           STREAMS key [key ...]</span><br><span class=\"line\">                   <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># GROUP group consumer: 指定消费者组名：group，消费者名：consumer</span></span><br><span class=\"line\"><span class=\"comment\">#    同一个 group 下，不同 consumer 不会收到重复消息</span></span><br><span class=\"line\"><span class=\"comment\"># [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证</span></span><br><span class=\"line\"><span class=\"comment\"># [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒</span></span><br><span class=\"line\"><span class=\"comment\">#    BLOCK 0 → 永久阻塞</span></span><br><span class=\"line\"><span class=\"comment\"># [NOACK] —— 不进入 Pending（⚠️ 谨慎）</span></span><br><span class=\"line\"><span class=\"comment\">#    消息 不会进入 Pending，不需要 XACK，消费后即认为完成</span></span><br><span class=\"line\"><span class=\"comment\">#    风险：消费者崩溃 → 消息直接丢失，不可重投递</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 决定“读什么”的关键</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息</span></span><br><span class=\"line\"><span class=\"comment\">#    多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。</span></span><br><span class=\"line\">XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;</span><br><span class=\"line\"><span class=\"comment\">## 此时在5秒内创建新的消息，就会有类似如下输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\">(1.50s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-消息确认（XACK）\">3. 消息确认（XACK）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费完成后必须确认，否则会被标记为「未确认消息」</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XACK key 消费组名 消息ID1 消息ID2 ...。</span></span><br><span class=\"line\">XACK key group <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记</span></span><br><span class=\"line\">XACK order_stream group1 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-消息重试\">4. 消息重试</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>未确认的消息，会被存入消费组的<code>「PEL（Pending Entries List）」</code>，可通过<code>XPENDING key 消费组名</code>查看，支持<code>XCLAIM</code>将<code>PEL</code>中的消息转移给其他消费者处理，避免单点故障导致消息堆积。</p>\n</li>\n<li class=\"lvl-2\">\n<p>XPENDING：查看未被确认的消息情况</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XPENDING key group</span><br><span class=\"line\">        [[IDLE min-idle-time]</span><br><span class=\"line\">         start end count</span><br><span class=\"line\">         [consumer]]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息</span></span><br><span class=\"line\"><span class=\"comment\">#    min-idle-time(空闲时间) = 从上次投递 / claim到现在</span></span><br><span class=\"line\"><span class=\"comment\"># start end —— ID 范围</span></span><br><span class=\"line\"><span class=\"comment\">#    -: 最小ID</span></span><br><span class=\"line\"><span class=\"comment\">#    +: 最大ID</span></span><br><span class=\"line\"><span class=\"comment\"># count —— 返回条数上限</span></span><br><span class=\"line\"><span class=\"comment\"># [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部</span></span><br><span class=\"line\"><span class=\"comment\"># 只返回 元数据，不返回消息内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例1: 查看是否有消息积压</span></span><br><span class=\"line\">XPENDING order_stream group1</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1      <span class=\"comment\"># 积压消息数，未确认消息数量</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最小 ID</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最大 ID</span></span><br><span class=\"line\">4) 1) 1) <span class=\"string\">&quot;consumerA&quot;</span> <span class=\"comment\"># 按 consumer 统计的 Pending 数量</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条</span></span><br><span class=\"line\">XPENDING order_stream group1 IDLE 60000 - + 10</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># 消息 ID</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;consumerA&quot;</span>       <span class=\"comment\"># 当前持有该消息的 consumer</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 255581  <span class=\"comment\"># idle 时间（毫秒）</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 2       <span class=\"comment\"># delivery count（投递次数）,该消息至少被投递过 2 次</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例3: 只查看 consumerA 的 Pending，最多返回20条</span></span><br><span class=\"line\">XPENDING order_stream group1 - + 20 consumerA</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>XCLAIM: 转移投递</p>\n</li>\n</ul>\n<blockquote>\n<p>将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。<br>\n一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XCLAIM key group consumer min-idle-time <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\">       [IDLE ms]</span><br><span class=\"line\">       [TIME unix-time-milliseconds]</span><br><span class=\"line\">       [RETRYCOUNT count]</span><br><span class=\"line\">       [FORCE]</span><br><span class=\"line\">       [JUSTID]</span><br><span class=\"line\">       [LASTID lastid]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream Key，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer</span></span><br><span class=\"line\"><span class=\"comment\"># min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...]: 指定要 claim 的消息 ID，ID必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态</span></span><br><span class=\"line\"><span class=\"comment\"># [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码</span></span><br><span class=\"line\"><span class=\"comment\"># [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”</span></span><br><span class=\"line\"><span class=\"comment\"># [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险</span></span><br><span class=\"line\"><span class=\"comment\"># [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销</span></span><br><span class=\"line\"><span class=\"comment\"># [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为</span></span><br><span class=\"line\"><span class=\"comment\">#    ⚠️ 高级特性，一般不建议业务代码使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：</span></span><br><span class=\"line\"><span class=\"comment\"># 1️⃣ 抢占 idle 超过 60s 的消息</span></span><br><span class=\"line\">XCLAIM order_stream group1 consumerB 60000 1766215642763-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">   2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">      5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2️⃣ 抢占并标记为第 3 次重试</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3</span><br><span class=\"line\"><span class=\"comment\"># 3️⃣ 只返回 ID（配合批处理）</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级特性（生产必备）\">高级特性（生产必备）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息回溯与遍历</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）</span></span><br><span class=\"line\">XRANGE key start end [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）</span></span><br><span class=\"line\">XREVRANGE key end start [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。</span></span><br><span class=\"line\">XRANGE order_stream 0-0 + COUNT 10</span><br><span class=\"line\">XRANGE order_stream - + COUNT 10</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>队列信息查询</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查消息总数</span></span><br><span class=\"line\">XLEN key</span><br><span class=\"line\"><span class=\"comment\"># 查Stream完整元数据（最新ID、消费组数量、消息总数等）</span></span><br><span class=\"line\"></span><br><span class=\"line\">XINFO STREAM key [FULL [COUNT count]]</span><br><span class=\"line\"><span class=\"comment\">## FULL: 完整模式</span></span><br><span class=\"line\">    <span class=\"comment\"># 👉 返回：</span></span><br><span class=\"line\">    <span class=\"comment\">#     Stream 元信息</span></span><br><span class=\"line\">    <span class=\"comment\">#     所有 Consumer Group</span></span><br><span class=\"line\">    <span class=\"comment\">#     每个 Group 的 Consumer</span></span><br><span class=\"line\">    <span class=\"comment\">#     Pending Entries List（PEL）</span></span><br><span class=\"line\">    <span class=\"comment\">#     部分历史 entries</span></span><br><span class=\"line\">    <span class=\"comment\"># ⚠️ 开销很大，慎用于生产环境。</span></span><br><span class=\"line\"><span class=\"comment\">## COUNT count（FULL 模式的限制参数）</span></span><br><span class=\"line\">    <span class=\"comment\">#   XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查所有消费组信息</span></span><br><span class=\"line\">XINFO GROUPS key</span><br><span class=\"line\"><span class=\"comment\"># 查该组下所有消费者</span></span><br><span class=\"line\">XINFO CONSUMERS key 消费组名</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费组管理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除消费组</span></span><br><span class=\"line\">XGROUP DESTROY key 消费组名</span><br><span class=\"line\"><span class=\"comment\"># 删除消费者</span></span><br><span class=\"line\">XGROUP DELCONSUMER key 消费组名 消费者名</span><br><span class=\"line\"><span class=\"comment\"># 重置消费组起始ID</span></span><br><span class=\"line\">XGROUP SETID key 消费组名 新ID</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。</p>\n</li>\n</ol>\n<h2 id=\"生产环境核心痛点与解决方案\">生产环境核心痛点与解决方案</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息丢失：3重保障</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性）</li>\n<li class=\"lvl-6\">生产者写入后确认返回值（确保写入成功）</li>\n<li class=\"lvl-6\">消费者消费后必须<code>XACK</code>确认。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>消息堆积：2种处理</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">① 写入时用<code>MAXLEN</code>设置上限，淘汰旧消息；</li>\n<li class=\"lvl-6\">② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>重复消费</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL）</li>\n<li class=\"lvl-6\">解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。</p>\n</li>\n</ol>\n<h2 id=\"典型应用场景\">典型应用场景</h2>\n<h3 id=\"分布式业务解耦（订单-库存-支付-物流解耦）\">分布式业务解耦（订单-库存-支付-物流解耦）</h3>\n<blockquote>\n<p>核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（订单服务）：写入订单完成消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）</span></span><br><span class=\"line\">XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建3个独立消费组（库存/支付/物流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存消费组：从最新消息开始消费，队列不存在则自动创建</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_stock $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 支付消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_pay $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 物流消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_logistics $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>各消费组消费者拉取+确认消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒</span></span><br><span class=\"line\">XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 库存处理完成后确认消息（替换为实际拉取到的消息ID）</span></span><br><span class=\"line\">XACK order_core_stream group_stock 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支付服务消费者（consumer_pay1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_pay 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 物流服务消费者（consumer_log1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步任务处理（用户注册-邮件-短信-积分异步执行）\">异步任务处理（用户注册-邮件/短信/积分异步执行）</h3>\n<blockquote>\n<p>核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（注册服务）：用户注册成功后写入消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息</span></span><br><span class=\"line\">XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建单个消费组（统一处理注册后续任务）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 短信发送消费者（consumer_sms）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 邮件发送消费者（consumer_email）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 积分发放消费者（consumer_score）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志收集（系统实时日志-分析-告警）\">日志收集（系统实时日志-分析/告警）</h3>\n<blockquote>\n<p>核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）</span></span><br><span class=\"line\">XADD sys_log_stream * module order_service level ERROR content <span class=\"string\">&quot;库存扣减失败，订单号ORD20251220001&quot;</span> log_time 1734567910</span><br><span class=\"line\">XADD sys_log_stream * module pay_service level INFO content <span class=\"string\">&quot;支付成功，uid1001，金额299&quot;</span> log_time 1734567912</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建2个消费组（日志分析+实时告警）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>对应消费者拉取处理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费者（批量拉取，非阻塞，适合离线处理）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;</span><br><span class=\"line\">XACK sys_log_stream group_log_analysis 批量消息ID...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt;  <span class=\"comment\"># BLOCK 0 永久阻塞，有消息立即返回</span></span><br><span class=\"line\">XACK sys_log_stream group_log_alert 告警消息ID</span><br></pre></td></tr></table></figure>\n<h3 id=\"限流削峰（秒杀场景-请求削峰填谷）\">限流削峰（秒杀场景-请求削峰填谷）</h3>\n<blockquote>\n<p>核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中”</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）</span></span><br><span class=\"line\">XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建消费组（单消费组+多消费者，控制总处理速率）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE seckill_stream group_seckill $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）</span></span><br><span class=\"line\">XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）</span></span><br><span class=\"line\">XACK seckill_stream group_seckill 秒杀请求消息ID...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。</p>\n</blockquote>\n<h2 id=\"与其他-Redis-队列方案对比（核心优势）\">与其他 Redis 队列方案对比（核心优势）</h2>\n<p>• 对比 List<br>\n- List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列；<br>\n- Stream 支持多播+消费组+确认机制，适合复杂分布式场景。</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Stream</th>\n<th>List</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消费者组</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>ACK</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>重试</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>阻塞</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>顺序性</td>\n<td>强</td>\n<td>强</td>\n</tr>\n</tbody>\n</table>\n<p>• 对比 Pub/Sub<br>\n- Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息；<br>\n- Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。</p>\n<h2 id=\"Stream-命令\">Stream 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForStream()</code> 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里不一定要用 <code>StringRedisTemplate</code> 来操作 Stream，但是用 <code>StringRedisTemplate</code> 可以保证可读性。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心能力划分：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">消息写入（XADD）</span><br><span class=\"line\">消息确认（XACK）</span><br><span class=\"line\">消息读取（XRANGE / XREAD / XREADGROUP）</span><br><span class=\"line\">Pending 消息管理（XPENDING / XCLAIM）</span><br><span class=\"line\">消费者组管理（XGROUP）</span><br><span class=\"line\">Stream 元信息（XINFO）</span><br><span class=\"line\">Stream 裁剪与删除（XTRIM / XDEL）</span><br><span class=\"line\">对象映射（MapRecord / ObjectRecord）</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息写入（XADD）\">消息写入（XADD）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基础写入</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>opsForStream().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 Map</td>\n<td><code>add(K key, Map&lt;HK,HV&gt;)</code></td>\n<td><code>XADD key * field value</code></td>\n<td>自动生成 ID</td>\n</tr>\n<tr>\n<td>写入 Record</td>\n<td><code>add(Record&lt;K, ?&gt; record)</code></td>\n<td><code>XADD</code></td>\n<td>支持 ObjectRecord</td>\n</tr>\n<tr>\n<td>写入 MapRecord</td>\n<td><code>add(MapRecord&lt;K,HK,HV&gt;)</code></td>\n<td><code>XADD</code></td>\n<td>Map 形式</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 带参数写入（推荐）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 + 选项</td>\n<td><code>add(record, XAddOptions)</code></td>\n<td><code>XADD ...</code></td>\n<td>支持 MAXLEN / NOMKSTREAM</td>\n</tr>\n<tr>\n<td>Map + 选项</td>\n<td><code>add(key, map, XAddOptions)</code></td>\n<td><code>XADD</code></td>\n<td>Redis ≥ 6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消息确认（XACK）\">消息确认（XACK）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>确认消息</td>\n<td><code>acknowledge(key, group, recordIds…)</code></td>\n<td><code>XACK</code></td>\n<td>标记已消费</td>\n</tr>\n<tr>\n<td>Record 确认</td>\n<td><code>acknowledge(group, record)</code></td>\n<td><code>XACK</code></td>\n<td>常用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 只对 Consumer Group 生效</p>\n</blockquote>\n<h3 id=\"消息读取（无消费者组）\">消息读取（无消费者组）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按 Range 读取（历史数据）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正序读取</td>\n<td><code>range(key, range)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>限制条数</td>\n<td><code>range(key, range, limit)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>反序读取</td>\n<td><code>reverseRange(key, range)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n<tr>\n<td>反序 + limit</td>\n<td><code>reverseRange(key, range, limit)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 实时读取（XREAD）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td><code>read(StreamOffset…)</code></td>\n<td><code>XREAD</code></td>\n<td>不支持 ACK</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(options, offsets…)</code></td>\n<td><code>XREAD</code></td>\n<td>BLOCK / COUNT</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, …)</code></td>\n<td><code>XREAD</code></td>\n<td>自动反序列化</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组读取（XREADGROUP）\">消费者组读取（XREADGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组内读取</td>\n<td><code>read(Consumer, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>MQ 核心</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(Consumer, options, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>BLOCK</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, Consumer, …)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Pending-消息管理（XPENDING-XCLAIM）\">Pending 消息管理（XPENDING / XCLAIM）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Pending 查询</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pending 汇总</td>\n<td><code>pending(key, group)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>指定消费者</td>\n<td><code>pending(key, consumer)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>范围查询</td>\n<td><code>pending(key, group, range, count)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 消息重新分配（XCLAIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重新分配</td>\n<td><code>claim(key, group, newOwner, minIdle, ids…)</code></td>\n<td><code>XCLAIM</code></td>\n<td>超时接管</td>\n</tr>\n<tr>\n<td>高级配置</td>\n<td><code>claim(key, group, newOwner, XClaimOptions)</code></td>\n<td><code>XCLAIM</code></td>\n<td>force / retry</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组管理（XGROUP）\">消费者组管理（XGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建组</td>\n<td><code>createGroup(key, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>从 <code>$</code> 开始</td>\n</tr>\n<tr>\n<td>指定 offset</td>\n<td><code>createGroup(key, offset, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>常用 <code>0-0</code></td>\n</tr>\n<tr>\n<td>删除消费者</td>\n<td><code>deleteConsumer(key, consumer)</code></td>\n<td><code>XGROUP DELCONSUMER</code></td>\n<td></td>\n</tr>\n<tr>\n<td>销毁组</td>\n<td><code>destroyGroup(key, group)</code></td>\n<td><code>XGROUP DESTROY</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-元信息（XINFO）\">Stream 元信息（XINFO）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Stream 信息</td>\n<td><code>info(key)</code></td>\n<td><code>XINFO STREAM</code></td>\n</tr>\n<tr>\n<td>组信息</td>\n<td><code>groups(key)</code></td>\n<td><code>XINFO GROUPS</code></td>\n</tr>\n<tr>\n<td>消费者信息</td>\n<td><code>consumers(key, group)</code></td>\n<td><code>XINFO CONSUMERS</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-删除-裁剪\">Stream 删除 / 裁剪</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 删除消息</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除消息</td>\n<td><code>delete(key, recordIds…)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n<tr>\n<td>删除 Record</td>\n<td><code>delete(record)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 裁剪 Stream（XTRIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>精确裁剪</td>\n<td><code>trim(key, count)</code></td>\n<td><code>XTRIM</code></td>\n<td></td>\n</tr>\n<tr>\n<td>近似裁剪</td>\n<td><code>trim(key, count, true)</code></td>\n<td><code>XTRIM ~</code></td>\n<td>性能更好</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对象映射能力（非常重要）\">对象映射能力（非常重要）</h3>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map → Object</td>\n<td><code>map(MapRecord, Class&lt;T&gt;)</code></td>\n<td>自动反序列化</td>\n</tr>\n<tr>\n<td>List 映射</td>\n<td><code>map(List&lt;MapRecord&gt;, Class&lt;T&gt;)</code></td>\n<td></td>\n</tr>\n<tr>\n<td>HashMapper</td>\n<td><code>getHashMapper(Class&lt;T&gt;)</code></td>\n<td>自定义映射</td>\n</tr>\n<tr>\n<td>反序列化</td>\n<td><code>deserializeRecord(ByteRecord)</code></td>\n<td>底层能力</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Stream 核心详解 Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的消息队列，底层用基数树+链表实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。 建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。 Stream 与传统的MQ 的对比 对比维度 Redis Stream RabbitMQ Kafka 数据模型 类似日志的有序 KV 消息流（ID → field/value） 队列（FIFO） 日志分区（Partitioned Append-Only Log） 消息持久化 可选持久化（AOF / RDB），默认内存优先 可持久化到磁盘 持久化到磁盘，顺序写入，效率高 消息确认 XACK 对单条消息确认，支持 Pending 消息管理 ACK / NACK Offset 控制，Consumer 自行提交 消费模式 支持 Consumer Group，多消费者共享 Pending 消息 Queue 绑定 Consumer，多消费者抢占 Consumer Group，多消费者平行消费 重复消费 默认可能重复，需要应用端幂等 可通过 ACK/NACK 控制 默认可能重复，Consumer 需幂等处理 消息顺序 按 Stream ID 顺序，可保证分组内顺序 队列顺序保证 Partition 内顺序保证 消息保留策略 可配置 maxlen / minid，按时间或长度裁剪 队列长度 / TTL 控制 基于时间或大小保留（Retention Policy） 延时/定时消费 原生不支持延时队列，需要应用端处理 支持插件或 TTL 原生不支持，需要应用端处理或 Kafka Streams 事务与原子操作 事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项 原生事务支持（事务 / confirm 模式） 不支持事务，依赖幂等生产者 性能 内存级高吞吐，持久化会有开销 中等，受磁盘和网络限制 高吞吐，顺序写入磁盘效率极高 典型使用场景 事件日志、轻量 MQ、内部异步流水线 企业级消息、任务调度、RPC 大数据管道、日志收集、流处理 多语言支持 客户端支持多种语言（Java、Python、Go 等） 客户端丰富 客户端丰富 易运维性 单节点即可使用，但持久化需关注内存 集群较复杂，需要 RabbitMQ 集群 集群复杂度高，需要 ZooKeeper 或 KRaft 底层核心实现 存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。 消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。 持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。 核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。 Stream 核心基础操作（必用） 1. 生产消息（XADD）：写入队列 • 核心命令：XADD key ID 字段1 值1 字段2 值2 ...，ID 写*表示自动生成（生产首选） 12345678910111213141516171819202122XADD key [NOMKSTREAM] [MAXLEN | MINID [= | ~] threshold [LIMIT count]] * | id field value [field value ...]# 参数解释# key: Stream 名称# NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败# MAXLEN threshold —— 按长度裁剪# MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）# MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大# MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高# LIMIT count —— 每次最多裁剪多少条# MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程# MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）# MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略# * | id —— 消息 ID# *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理# id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败# field value —— 消息体（Payload）# 至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改 • 示例 1234567# 向订单队列写入1条消息，自动生成消息IDXADD order_stream * uid 1001 order_no ORD20251220 price 299## 输出&quot;1766215406540-0&quot; # 消息ID# 保留某个时间点之后的日志XADD log MINID ~ 1689900000000-0 * level INFO msg &quot;startup&quot; 2. 消费消息（2种核心模式） （1） 独立消费（无消费组）：一对一消费，适合简单场景 • XREAD：主动拉取消息，支持阻塞/非阻塞 12345678910111213XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]# 参数解释# COUNT count —— 单次最多读取多少条，是“上限”，不是保证值# BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil# BLOCK 0: 无限阻塞，直到有新消息# STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应# id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身# 普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0# $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $ • 示例1（非阻塞） 1234567891011# 从开头拉5条消息XREAD COUNT 5 STREAMS order_stream 0-0# 输出1) 1) &quot;order_stream&quot; # Stream名称 2) 1) 1) &quot;1766215406540-0&quot; # 消息ID 2) 1) &quot;uid&quot; # 消息体 键值对 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot; • 示例2（阻塞） 12# $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $ （2） 消费组消费（XGROUP）：一对多消费，核心生产模式 Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。 先创建消费组XGROUP CREATE 1234567891011121314XGROUP CREATE key group id|$ [MKSTREAM] [ENTRIESREAD entries-read]# 参数解释# key：Stream 名称，为指定的Stream创建消费组# group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group# id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。# [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用# [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景# 示例：创建group1消费组，从最新订单消息开始消费XGROUP CREATE order_stream group1 $ MKSTREAM# 输出OK 消费者拉取消息XREADGROUP 123456789101112131415161718192021222324252627282930313233XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]# 参数解释# GROUP group consumer: 指定消费者组名：group，消费者名：consumer# 同一个 group 下，不同 consumer 不会收到重复消息# [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证# [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒# BLOCK 0 → 永久阻塞# [NOACK] —— 不进入 Pending（⚠️ 谨慎）# 消息 不会进入 Pending，不需要 XACK，消费后即认为完成# 风险：消费者崩溃 → 消息直接丢失，不可重投递# STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致# id [id ...] —— 决定“读什么”的关键# 使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息# 使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息# 多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id# 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;## 此时在5秒内创建新的消息，就会有类似如下输出1) 1) &quot;order_stream&quot; 2) 1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;(1.50s) 3. 消息确认（XACK） 消费完成后必须确认，否则会被标记为「未确认消息」 12345# XACK key 消费组名 消息ID1 消息ID2 ...。XACK key group id [id ...]# 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记XACK order_stream group1 1734567890000-0 1734567890001-0 4. 消息重试 未确认的消息，会被存入消费组的「PEL（Pending Entries List）」，可通过XPENDING key 消费组名查看，支持XCLAIM将PEL中的消息转移给其他消费者处理，避免单点故障导致消息堆积。 XPENDING：查看未被确认的消息情况 123456789101112131415161718192021222324252627282930313233343536XPENDING key group [[IDLE min-idle-time] start end count [consumer]]# 参数解释# key: Stream 名称，必须存在# group: 消费者组名称，必须存在# [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息# min-idle-time(空闲时间) = 从上次投递 / claim到现在# start end —— ID 范围# -: 最小ID# +: 最大ID# count —— 返回条数上限# [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部# 只返回 元数据，不返回消息内容# 示例1: 查看是否有消息积压XPENDING order_stream group1## 输出1) (integer) 1 # 积压消息数，未确认消息数量2) &quot;1766215642763-0&quot; # Pending 中最小 ID3) &quot;1766215642763-0&quot; # Pending 中最大 ID4) 1) 1) &quot;consumerA&quot; # 按 consumer 统计的 Pending 数量 2) &quot;1&quot;# 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条XPENDING order_stream group1 IDLE 60000 - + 10## 输出1) 1) &quot;1766215642763-0&quot; # 消息 ID 2) &quot;consumerA&quot; # 当前持有该消息的 consumer 3) (integer) 255581 # idle 时间（毫秒） 4) (integer) 2 # delivery count（投递次数）,该消息至少被投递过 2 次# 示例3: 只查看 consumerA 的 Pending，最多返回20条XPENDING order_stream group1 - + 20 consumerA XCLAIM: 转移投递 将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。 一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录 12345678910111213141516171819202122232425262728293031323334353637XCLAIM key group consumer min-idle-time id [id ...] [IDLE ms] [TIME unix-time-milliseconds] [RETRYCOUNT count] [FORCE] [JUSTID] [LASTID lastid]# 参数解释# key: Stream Key，必须存在# group: 消费者组名称，必须存在# consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer# min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim# id [id ...]: 指定要 claim 的消息 ID，ID必须存在# [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态# [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码# [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”# [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险# [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销# [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为# ⚠️ 高级特性，一般不建议业务代码使用# 示例：# 1️⃣ 抢占 idle 超过 60s 的消息XCLAIM order_stream group1 consumerB 60000 1766215642763-0# 输出1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;# 2️⃣ 抢占并标记为第 3 次重试XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3# 3️⃣ 只返回 ID（配合批处理）XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID 高级特性（生产必备） 消息回溯与遍历 1234567# XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）XRANGE key start end [COUNT count]# XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）XREVRANGE key end start [COUNT count]# 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。XRANGE order_stream 0-0 + COUNT 10XRANGE order_stream - + COUNT 10 队列信息查询 1234567891011121314151617181920# 查消息总数XLEN key# 查Stream完整元数据（最新ID、消费组数量、消息总数等）XINFO STREAM key [FULL [COUNT count]]## FULL: 完整模式 # 👉 返回： # Stream 元信息 # 所有 Consumer Group # 每个 Group 的 Consumer # Pending Entries List（PEL） # 部分历史 entries # ⚠️ 开销很大，慎用于生产环境。## COUNT count（FULL 模式的限制参数） # XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量# 查所有消费组信息XINFO GROUPS key# 查该组下所有消费者XINFO CONSUMERS key 消费组名 消费组管理 123456# 删除消费组XGROUP DESTROY key 消费组名# 删除消费者XGROUP DELCONSUMER key 消费组名 消费者名# 重置消费组起始IDXGROUP SETID key 消费组名 新ID 惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。 生产环境核心痛点与解决方案 消息丢失：3重保障 开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性） 生产者写入后确认返回值（确保写入成功） 消费者消费后必须XACK确认。 消息堆积：2种处理 ① 写入时用MAXLEN设置上限，淘汰旧消息； ② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。 重复消费 根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL） 解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。 阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。 典型应用场景 分布式业务解耦（订单-库存-支付-物流解耦） 核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。 生产者（订单服务）：写入订单完成消息 12# 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890 创建3个独立消费组（库存/支付/物流） 123456# 库存消费组：从最新消息开始消费，队列不存在则自动创建XGROUP CREATE order_core_stream group_stock $ MKSTREAM# 支付消费组XGROUP CREATE order_core_stream group_pay $ MKSTREAM# 物流消费组XGROUP CREATE order_core_stream group_logistics $ MKSTREAM 各消费组消费者拉取+确认消息 123456789101112# 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;# 库存处理完成后确认消息（替换为实际拉取到的消息ID）XACK order_core_stream group_stock 1734567890000-0 1734567890001-0# 支付服务消费者（consumer_pay1）同理XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_pay 1734567890000-0 1734567890001-0# 物流服务消费者（consumer_log1）同理XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0 异步任务处理（用户注册-邮件/短信/积分异步执行） 核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。 生产者（注册服务）：用户注册成功后写入消息 12# 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900 创建单个消费组（统一处理注册后续任务） 1XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM 多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容） 1234567891011# 短信发送消费者（consumer_sms）XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 邮件发送消费者（consumer_email）XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 积分发放消费者（consumer_score）XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2 日志收集（系统实时日志-分析/告警） 核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。 生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流） 123# 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）XADD sys_log_stream * module order_service level ERROR content &quot;库存扣减失败，订单号ORD20251220001&quot; log_time 1734567910XADD sys_log_stream * module pay_service level INFO content &quot;支付成功，uid1001，金额299&quot; log_time 1734567912 创建2个消费组（日志分析+实时告警） 1234# 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM# 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM 对应消费者拉取处理 1234567# 日志分析消费者（批量拉取，非阻塞，适合离线处理）XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;XACK sys_log_stream group_log_analysis 批量消息ID...# 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt; # BLOCK 0 永久阻塞，有消息立即返回XACK sys_log_stream group_log_alert 告警消息ID 限流削峰（秒杀场景-请求削峰填谷） 核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。 生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中” 12# 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000 创建消费组（单消费组+多消费者，控制总处理速率） 1XGROUP CREATE seckill_stream group_seckill $ MKSTREAM 消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条） 1234# 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;# 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）XACK seckill_stream group_seckill 秒杀请求消息ID... 关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。 与其他 Redis 队列方案对比（核心优势） • 对比 List - List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列； - Stream 支持多播+消费组+确认机制，适合复杂分布式场景。 对比项 Stream List 消费者组 ✅ ❌ ACK ✅ ❌ 重试 ✅ ❌ 阻塞 ✅ ✅ 顺序性 强 强 • 对比 Pub/Sub - Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息； - Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。 Stream 命令 SpringBoot 的 StringRedisTemplate.opsForStream() 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里不一定要用 StringRedisTemplate 来操作 Stream，但是用 StringRedisTemplate 可以保证可读性。 核心能力划分： 12345678消息写入（XADD）消息确认（XACK）消息读取（XRANGE / XREAD / XREADGROUP）Pending 消息管理（XPENDING / XCLAIM）消费者组管理（XGROUP）Stream 元信息（XINFO）Stream 裁剪与删除（XTRIM / XDEL）对象映射（MapRecord / ObjectRecord） 消息写入（XADD） 1️⃣ 基础写入 方法功能 方法 opsForStream().xxx() Redis 原始命令 说明 写入 Map add(K key, Map&lt;HK,HV&gt;) XADD key * field value 自动生成 ID 写入 Record add(Record&lt;K, ?&gt; record) XADD 支持 ObjectRecord 写入 MapRecord add(MapRecord&lt;K,HK,HV&gt;) XADD Map 形式 2️⃣ 带参数写入（推荐） 方法功能 方法 Redis 原始命令 备注 写入 + 选项 add(record, XAddOptions) XADD ... 支持 MAXLEN / NOMKSTREAM Map + 选项 add(key, map, XAddOptions) XADD Redis ≥ 6 消息确认（XACK） 方法功能 方法 Redis 原始命令 说明 确认消息 acknowledge(key, group, recordIds…) XACK 标记已消费 Record 确认 acknowledge(group, record) XACK 常用 ⚠️ 只对 Consumer Group 生效 消息读取（无消费者组） 1️⃣ 按 Range 读取（历史数据） 方法功能 方法 Redis 原始命令 正序读取 range(key, range) XRANGE 限制条数 range(key, range, limit) XRANGE 反序读取 reverseRange(key, range) XREVRANGE 反序 + limit reverseRange(key, range, limit) XREVRANGE 2️⃣ 实时读取（XREAD） 方法功能 方法 Redis 原始命令 说明 读取 read(StreamOffset…) XREAD 不支持 ACK 带参数 read(options, offsets…) XREAD BLOCK / COUNT 映射对象 read(Class&lt;T&gt;, …) XREAD 自动反序列化 消费者组读取（XREADGROUP） 方法功能 方法 Redis 原始命令 说明 组内读取 read(Consumer, offsets…) XREADGROUP MQ 核心 带参数 read(Consumer, options, offsets…) XREADGROUP BLOCK 映射对象 read(Class&lt;T&gt;, Consumer, …) XREADGROUP — Pending 消息管理（XPENDING / XCLAIM） 1️⃣ Pending 查询 方法功能 方法 Redis 原始命令 Pending 汇总 pending(key, group) XPENDING 指定消费者 pending(key, consumer) XPENDING 范围查询 pending(key, group, range, count) XPENDING 2️⃣ 消息重新分配（XCLAIM） 方法功能 方法 Redis 原始命令 说明 重新分配 claim(key, group, newOwner, minIdle, ids…) XCLAIM 超时接管 高级配置 claim(key, group, newOwner, XClaimOptions) XCLAIM force / retry 消费者组管理（XGROUP） 方法功能 方法 Redis 原始命令 说明 创建组 createGroup(key, group) XGROUP CREATE 从 $ 开始 指定 offset createGroup(key, offset, group) XGROUP CREATE 常用 0-0 删除消费者 deleteConsumer(key, consumer) XGROUP DELCONSUMER 销毁组 destroyGroup(key, group) XGROUP DESTROY Stream 元信息（XINFO） 方法功能 方法 Redis 原始命令 Stream 信息 info(key) XINFO STREAM 组信息 groups(key) XINFO GROUPS 消费者信息 consumers(key, group) XINFO CONSUMERS Stream 删除 / 裁剪 1️⃣ 删除消息 方法功能 方法 Redis 原始命令 删除消息 delete(key, recordIds…) XDEL 删除 Record delete(record) XDEL 2️⃣ 裁剪 Stream（XTRIM） 方法功能 方法 Redis 原始命令 说明 精确裁剪 trim(key, count) XTRIM 近似裁剪 trim(key, count, true) XTRIM ~ 性能更好 对象映射能力（非常重要） 能力 方法 说明 Map → Object map(MapRecord, Class&lt;T&gt;) 自动反序列化 List 映射 map(List&lt;MapRecord&gt;, Class&lt;T&gt;) HashMapper getHashMapper(Class&lt;T&gt;) 自定义映射 反序列化 deserializeRecord(ByteRecord) 底层能力","summary":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-20T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","title":"Redis 命令及数据类型 -- Geo","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Geo 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Geo-核心详解\">Geo 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Geo 是基于有序集合（<code>zset</code>） 实现的地理空间操作功能，底层用<code>geohash编码</code>存储<code>经纬度</code>，核心支持 6 个基础操作 + 2 个扩展操作，兼顾<code>精准存储</code>、<code>距离计算</code>、<code>范围筛选</code>等核心需求，直接对接实际场景（如附近门店、同城好友）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>有效经度(longitude)为 <code>-180 ~ 180</code>，有效纬度(latitude)为 <code>-85.05112878 ~ 85.05112878</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 内部实现中：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEO 数据 ≈ ZSET</span><br><span class=\"line\">score = GeoHash（52 位bit ≈ 11 个字符）</span><br><span class=\"line\">member = 实际成员名</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geohash-是什么\">Geohash 是什么?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将「位置」映射为「可排序的值」</span><br><span class=\"line\">相近的地理位置 → 前缀相同或接近</span><br><span class=\"line\">便于 范围查询、邻近查询、索引存储</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心思想</p>\n</li>\n</ul>\n<blockquote>\n<p>不断对经纬度区间进行二分，并交叉编码<br>\n编码顺序：经度 → 纬度 → 经度 → 纬度 → …</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每一步：</span><br><span class=\"line\">    1.取当前区间的中点</span><br><span class=\"line\">    2.大于中点记为 1</span><br><span class=\"line\">    3.小于中点记为 0</span><br><span class=\"line\">    4.缩小区间，继续下一位</span><br><span class=\"line\">最终得到一个 bit 序列。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 内部的 Geohash 字符 = <code>52bit</code>，即 经度 <code>26 bit</code>，纬度 <code>26 bit</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个字符 = 5 bit</span><br><span class=\"line\">内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bit</span><br><span class=\"line\"></span><br><span class=\"line\">Redis 默认在输出字符串时：</span><br><span class=\"line\">    会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0</span><br><span class=\"line\">    因此最终得到 11 个 Base32 字符</span><br></pre></td></tr></table></figure>\n<h3 id=\"Geohash-计算过程示例\">Geohash 计算过程示例</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longitude = 116.397128</span><br><span class=\"line\">latitude  = 39.916527</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了简化计算过程，我们这里固定一个常用精度：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>逐位计算（关键过程）<br>\n1️⃣ 经度 bit（13 位）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-180,180]</td>\n<td>0</td>\n<td>116 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,180]</td>\n<td>90</td>\n<td>116 ≥ 90</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[90,180]</td>\n<td>135</td>\n<td>116 &lt; 135</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[90,135]</td>\n<td>112.5</td>\n<td>116 ≥ 112.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[112.5,135]</td>\n<td>123.75</td>\n<td>116 &lt; 123.75</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[112.5,123.75]</td>\n<td>118.125</td>\n<td>116 &lt; 118.125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[112.5,118.125]</td>\n<td>115.3125</td>\n<td>116 ≥ 115.3125</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[115.3125,118.125]</td>\n<td>116.71875</td>\n<td>116 &lt; 116.71875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[115.3125,116.71875]</td>\n<td>116.015625</td>\n<td>116 ≥ 116.015625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[116.015625,116.71875]</td>\n<td>116.3671875</td>\n<td>116 ≥ 116.3671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[116.3671875,116.71875]</td>\n<td>116.54296875</td>\n<td>116 &lt; 116.54296875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[116.3671875,116.54296875]</td>\n<td>116.455078125</td>\n<td>116 &lt; 116.455078125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>13</td>\n<td>[116.3671875,116.455078125]</td>\n<td>116.4111328125</td>\n<td>116 &lt; 116.4111328125</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>经度 bit（13 位）：<code>1101001011000</code></p>\n</blockquote>\n<p>2️⃣ 纬度 bit（12 位）</p>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-90,90]</td>\n<td>0</td>\n<td>39 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,90]</td>\n<td>45</td>\n<td>39 &lt; 45</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[0,45]</td>\n<td>22.5</td>\n<td>39 ≥ 22.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[22.5,45]</td>\n<td>33.75</td>\n<td>39 ≥ 33.75</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[33.75,45]</td>\n<td>39.375</td>\n<td>39 &lt; 39.375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[33.75,39.375]</td>\n<td>36.5625</td>\n<td>39 ≥ 36.5625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[36.5625,39.375]</td>\n<td>37.96875</td>\n<td>39 ≥ 37.96875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[37.96875,39.375]</td>\n<td>38.671875</td>\n<td>39 ≥ 38.671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[38.671875,39.375]</td>\n<td>39.0234375</td>\n<td>39 &lt; 39.0234375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[38.671875,39.0234375]</td>\n<td>38.84765625</td>\n<td>39 ≥ 38.84765625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[38.84765625,39.0234375]</td>\n<td>38.935546875</td>\n<td>39 ≥ 38.935546875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[38.935546875,39.0234375]</td>\n<td>38.9794921875</td>\n<td>39 ≥ 38.9794921875</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>纬度 bit（12 位）：<code>101101110111</code></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>交叉合并（最终 bit 序列）</p>\n</li>\n</ul>\n<blockquote>\n<p>按规则：经度 → 纬度 → 经度 → 纬度 …</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经度: 1 1 0 1 0 0 1 0 1 1 0 0 0</span><br><span class=\"line\">纬度: 1 0 1 1 0 1 1 1 0 1 1 1</span><br><span class=\"line\"></span><br><span class=\"line\">交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01</span><br><span class=\"line\">合并为一行：1110011100011101101010101</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每 5 bit → 1 个 Base32 字符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从左到右，每 5 位一组：</span></span><br><span class=\"line\">11100 | 11100 | 01110 | 11010 | 10101</span><br><span class=\"line\"><span class=\"comment\"># 转10进制</span></span><br><span class=\"line\">28    | 28    | 14    | 26    | 21</span><br><span class=\"line\"><span class=\"comment\"># 转 Base32</span></span><br><span class=\"line\">w     | w    | f    | u    | p</span><br><span class=\"line\"><span class=\"comment\"># 最终结果：</span></span><br><span class=\"line\">wwfup</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）：</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Index:  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">Char :  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 10 11 12 13 14 15 16 17 18 19</span><br><span class=\"line\">Char :  b  c  d  e  f  g  h  j  k  m</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 20 21 22 23 24 25 26 27 28 29</span><br><span class=\"line\">Char :  n  p  q  r  s  t  u  v  w  x</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 30 31</span><br><span class=\"line\">Char :  y  z</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">Geohash Base32 字符集 为什么缺少 <code>a, i, l, o</code>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">为了避免在视觉上引起数字混淆</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 容易和 4 混淆</span><br><span class=\"line\">i 容易和 1 混淆</span><br><span class=\"line\">l 容易和 1 混淆</span><br><span class=\"line\">o 容易和 0 混淆</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">去掉 <code>a, i, l, o</code> 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"Geo-核心基础操作（必用）\">Geo 核心基础操作（必用）</h2>\n<h3 id=\"1-GEOADD：添加地理位置坐标（核心写入操作）\">1. GEOADD：添加地理位置坐标（核心写入操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># NX：如果已存在，则不执行写入操作</span></span><br><span class=\"line\"><span class=\"comment\"># XX: 如果不存在，则执行写入操作，与 NX 互斥</span></span><br><span class=\"line\"><span class=\"comment\"># CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度 (-180 ~ 180)</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度 (-85.05112878 ~ 85.05112878)</span></span><br><span class=\"line\"><span class=\"comment\"># member: 成员名称，位置唯一标识（字符串）</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给shop集合加王府井、西单2个门店的经纬度</span></span><br><span class=\"line\">GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<p>◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。</p>\n<h3 id=\"2-GEOPOS：获取指定成员的经纬度（精准查询坐标）\">2. GEOPOS：获取指定成员的经纬度（精准查询坐标）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOPOS key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的经纬度数组 [经度, 纬度]</span></span><br><span class=\"line\">GEOPOS shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。</p>\n<h3 id=\"3-GEODIST：计算两个成员之间的距离（核心计算操作）\">3. GEODIST：计算两个成员之间的距离（核心计算操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEODIST key member1 member2 [M|KM|FT|MI]</span><br><span class=\"line\"><span class=\"comment\"># [M|KM|FT|MI] : 距离单位</span></span><br><span class=\"line\"><span class=\"comment\"># M : 米，默认</span></span><br><span class=\"line\"><span class=\"comment\"># KM : 千米</span></span><br><span class=\"line\"><span class=\"comment\"># FT : 英尺</span></span><br><span class=\"line\"><span class=\"comment\"># MI : 英里</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井和西单之间的距离，单位为米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1468.0611&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算王府井到西单的距离，单位千米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan km</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。</p>\n<h3 id=\"4-GEOHASH：获取指定成员的geohash编码（底层编码查询）\">4. GEOHASH：获取指定成员的geohash编码（底层编码查询）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOHASH key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的geohash字符串，共11位</span></span><br><span class=\"line\">GEOHASH shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;wx4g0f6f2u0&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。</p>\n<h3 id=\"5-GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）\">5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCOORD: 返回经纬度</span></span><br><span class=\"line\"><span class=\"comment\"># WITHDIST: 带距离</span></span><br><span class=\"line\"><span class=\"comment\"># WITHHASH: 带geohash</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count: 限制返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ANY: 随机返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ASC/DESC: 按距离正/倒序</span></span><br><span class=\"line\"><span class=\"comment\"># STORE key: 存储结果到指定key</span></span><br><span class=\"line\"><span class=\"comment\"># STOREDIST key: 存储结果到指定key，结果为距离</span></span><br></pre></td></tr></table></figure>\n<p>◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序）</p>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离</span></span><br><span class=\"line\">GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）\">6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 语法说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># member: 已有成员名称</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数说明同 GEORADIUS</span></span><br></pre></td></tr></table></figure>\n<p>◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令）<br>\n◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-扩展操作（实战常用）\">Geo 扩展操作（实战常用）</h2>\n<h3 id=\"1-GEOSEARCH（Redis-6-2-新增，替代-GEORADIUS-GEORADIUSBYMEMBER）\">1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER）</h3>\n<p>◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>\n<p>◦ 语法1（按坐标中心）：<code>GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查天安门3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 语法2（按成员中心）：<code>GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 新增特性：支持 <code>BYBOX（按矩形范围查询）</code>，适配更多场景（如查询某片区内的门店）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店</span></span><br><span class=\"line\"><span class=\"comment\"># 西单距离王府井 1.4681 km，所以不在结果中</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-GEOSEARCHSTORE（Redis-6-2-新增）\">2. GEOSEARCHSTORE（Redis 6.2+ 新增）</h3>\n<p>◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序）<br>\n◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCHSTORE destination <span class=\"built_in\">source</span></span><br><span class=\"line\">  &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 把王府井3km内的门店，存到near_shop集合</span></span><br><span class=\"line\">GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km</span><br></pre></td></tr></table></figure>\n<h2 id=\"底层核心与实战注意事项\">底层核心与实战注意事项</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。</p>\n</li>\n<li class=\"lvl-3\">\n<p>性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。</p>\n</li>\n<li class=\"lvl-3\">\n<p>适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。</p>\n</li>\n</ol>\n<h2 id=\"典型实战场景示例\">典型实战场景示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 批量添加餐饮坐标</span></span><br><span class=\"line\">GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）</span></span><br><span class=\"line\">GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 删除某餐饮</span></span><br><span class=\"line\">ZREM restaurant aaa</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-命令\">Geo 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForGeo()</code> 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Geo</p>\n</blockquote>\n<h3 id=\"写入-删除类操作\">写入 / 删除类操作</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加单个坐标</td>\n<td><code>add(K key, Point point, M member)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td>返回 <strong>新增成员数量</strong>（已存在则返回 0）</td>\n</tr>\n<tr>\n<td>添加单个位置</td>\n<td><code>add(K key, GeoLocation&lt;M&gt; location)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td><code>GeoLocation</code> 内部封装了 <code>Point + member</code></td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Map&lt;M, Point&gt; map)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td><strong>推荐</strong>，一次网络 IO</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td>与 Map 方式等价</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>remove(K key, M... members)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>GEO 本质是 <strong>Sorted Set</strong></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, point, member);</span><br><span class=\"line\"></span><br><span class=\"line\">RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= <span class=\"keyword\">new</span> <span class=\"title class_\">RedisGeoCommands</span>.GeoLocation&lt;&gt;(member, point);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, geoLocation);</span><br></pre></td></tr></table></figure>\n<h3 id=\"距离-坐标-哈希查询\">距离 / 坐标 / 哈希查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>两点距离</td>\n<td><code>distance(K key, m1, m2)</code></td>\n<td><code>GEODIST key m1 m2</code></td>\n<td>默认单位米</td>\n</tr>\n<tr>\n<td>指定单位距离</td>\n<td><code>distance(K key, m1, m2, metric)</code></td>\n<td><code>GEODIST key m1 m2 unit</code></td>\n<td>m / km / mi / ft</td>\n</tr>\n<tr>\n<td>获取 GeoHash</td>\n<td><code>hash(K key, M... members)</code></td>\n<td><code>GEOHASH key member</code></td>\n<td>用于调试</td>\n</tr>\n<tr>\n<td>获取坐标</td>\n<td><code>position(K key, M... members)</code></td>\n<td><code>GEOPOS key member</code></td>\n<td>lon / lat</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"半径查询（旧接口，已不推荐）\">半径查询（旧接口，已不推荐）</h3>\n<blockquote>\n<p>Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基于坐标点</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, Circle within)</code></td>\n<td><code>GEORADIUS key lon lat radius</code></td>\n</tr>\n<tr>\n<td>半径 + 参数</td>\n<td><code>radius(K key, Circle within, args)</code></td>\n<td><code>GEORADIUS</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 基于成员</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, member, radius)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>指定单位</td>\n<td><code>radius(K key, member, Distance)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>radius(K key, member, Distance, args)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"搜索查询（推荐使用-GEOSEARCH）\">搜索查询（推荐使用 GEOSEARCH）</h3>\n<blockquote>\n<p>替代 GEORADIUS / GEORADIUSBYMEMBER</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按圆形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>圆形搜索</td>\n<td><code>search(K key, Circle within)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>新推荐接口</td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>search(K key, GeoReference, Distance)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>FROMMEMBER / FROMLONLAT</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, radius, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>支持排序、limit</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 按矩形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形搜索</td>\n<td><code>search(K key, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用搜索（底层能力）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>任意 GeoShape</td>\n<td><code>search(K key, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于给定的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, <span class=\"type\">double</span> longitude, <span class=\"type\">double</span> latitude, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 中心点</span></span><br><span class=\"line\">    <span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建圆形</span></span><br><span class=\"line\">    <span class=\"type\">Circle</span> <span class=\"variable\">circle</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(point, distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于成员的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, String member, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"搜索并存储（GEOSEARCHSTORE）\">搜索并存储（GEOSEARCHSTORE）</h3>\n<blockquote>\n<p>这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 圆形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索并存储</td>\n<td><code>searchAndStore(K key, destKey, Circle)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>searchAndStore(K key, destKey, reference, radius)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, radius, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 矩形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形存储</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ 通用 GeoShape 存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通用存储</td>\n<td><code>searchAndStore(K key, destKey, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Geo 核心详解 Redis Geo 是基于有序集合（zset） 实现的地理空间操作功能，底层用geohash编码存储经纬度，核心支持 6 个基础操作 + 2 个扩展操作，兼顾精准存储、距离计算、范围筛选等核心需求，直接对接实际场景（如附近门店、同城好友）。 有效经度(longitude)为 -180 ~ 180，有效纬度(latitude)为 -85.05112878 ~ 85.05112878。 Redis 内部实现中： 123GEO 数据 ≈ ZSETscore = GeoHash（52 位bit ≈ 11 个字符）member = 实际成员名 Geohash 是什么? Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是： 123将「位置」映射为「可排序的值」相近的地理位置 → 前缀相同或接近便于 范围查询、邻近查询、索引存储 核心思想 不断对经纬度区间进行二分，并交叉编码 编码顺序：经度 → 纬度 → 经度 → 纬度 → … 123456每一步： 1.取当前区间的中点 2.大于中点记为 1 3.小于中点记为 0 4.缩小区间，继续下一位最终得到一个 bit 序列。 Redis 内部的 Geohash 字符 = 52bit，即 经度 26 bit，纬度 26 bit 123456每个字符 = 5 bit内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bitRedis 默认在输出字符串时： 会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0 因此最终得到 11 个 Base32 字符 Geohash 计算过程示例 12longitude = 116.397128latitude = 39.916527 为了简化计算过程，我们这里固定一个常用精度： 精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度） 逐位计算（关键过程） 1️⃣ 经度 bit（13 位） 位次 区间 mid 判断 bit 1 [-180,180] 0 116 ≥ 0 1 2 [0,180] 90 116 ≥ 90 1 3 [90,180] 135 116 &lt; 135 0 4 [90,135] 112.5 116 ≥ 112.5 1 5 [112.5,135] 123.75 116 &lt; 123.75 0 6 [112.5,123.75] 118.125 116 &lt; 118.125 0 7 [112.5,118.125] 115.3125 116 ≥ 115.3125 1 8 [115.3125,118.125] 116.71875 116 &lt; 116.71875 0 9 [115.3125,116.71875] 116.015625 116 ≥ 116.015625 1 10 [116.015625,116.71875] 116.3671875 116 ≥ 116.3671875 1 11 [116.3671875,116.71875] 116.54296875 116 &lt; 116.54296875 0 12 [116.3671875,116.54296875] 116.455078125 116 &lt; 116.455078125 0 13 [116.3671875,116.455078125] 116.4111328125 116 &lt; 116.4111328125 0 经度 bit（13 位）：1101001011000 2️⃣ 纬度 bit（12 位） 位次 区间 mid 判断 bit 1 [-90,90] 0 39 ≥ 0 1 2 [0,90] 45 39 &lt; 45 0 3 [0,45] 22.5 39 ≥ 22.5 1 4 [22.5,45] 33.75 39 ≥ 33.75 1 5 [33.75,45] 39.375 39 &lt; 39.375 0 6 [33.75,39.375] 36.5625 39 ≥ 36.5625 1 7 [36.5625,39.375] 37.96875 39 ≥ 37.96875 1 8 [37.96875,39.375] 38.671875 39 ≥ 38.671875 1 9 [38.671875,39.375] 39.0234375 39 &lt; 39.0234375 0 10 [38.671875,39.0234375] 38.84765625 39 ≥ 38.84765625 1 11 [38.84765625,39.0234375] 38.935546875 39 ≥ 38.935546875 1 12 [38.935546875,39.0234375] 38.9794921875 39 ≥ 38.9794921875 1 纬度 bit（12 位）：101101110111 交叉合并（最终 bit 序列） 按规则：经度 → 纬度 → 经度 → 纬度 … 12345经度: 1 1 0 1 0 0 1 0 1 1 0 0 0纬度: 1 0 1 1 0 1 1 1 0 1 1 1交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01合并为一行：1110011100011101101010101 每 5 bit → 1 个 Base32 字符 12345678# 从左到右，每 5 位一组：11100 | 11100 | 01110 | 11010 | 10101# 转10进制28 | 28 | 14 | 26 | 21# 转 Base32w | w | f | u | p# 最终结果：wwfup Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）： 1234567891011Index: 0 1 2 3 4 5 6 7 8 9Char : 0 1 2 3 4 5 6 7 8 9Index: 10 11 12 13 14 15 16 17 18 19Char : b c d e f g h j k mIndex: 20 21 22 23 24 25 26 27 28 29Char : n p q r s t u v w xIndex: 30 31Char : y z Geohash Base32 字符集 为什么缺少 a, i, l, o 为了避免在视觉上引起数字混淆 1234a 容易和 4 混淆i 容易和 1 混淆l 容易和 1 混淆o 容易和 0 混淆 去掉 a, i, l, o 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度 Geo 核心基础操作（必用） 1. GEOADD：添加地理位置坐标（核心写入操作） ◦ 语法： 12345678910GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]# 参数说明：# key: key名称# NX：如果已存在，则不执行写入操作# XX: 如果不存在，则执行写入操作，与 NX 互斥# CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量# longitude: 经度 (-180 ~ 180)# latitude: 纬度 (-85.05112878 ~ 85.05112878)# member: 成员名称，位置唯一标识（字符串）# 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量 ◦ 示例： 1234# 给shop集合加王府井、西单2个门店的经纬度GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan# 输出(integer) 2 ◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。 2. GEOPOS：获取指定成员的经纬度（精准查询坐标） ◦ 语法： 1GEOPOS key [member [member ...]] ◦ 示例： 12345# 返回王府井的经纬度数组 [经度, 纬度]GEOPOS shop wangfujing# 输出1) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。 3. GEODIST：计算两个成员之间的距离（核心计算操作） ◦ 语法： 123456GEODIST key member1 member2 [M|KM|FT|MI]# [M|KM|FT|MI] : 距离单位# M : 米，默认# KM : 千米# FT : 英尺# MI : 英里 ◦ 示例： 123456789# 返回王府井和西单之间的距离，单位为米GEODIST shop wangfujing xidan# 输出&quot;1468.0611&quot;# 计算王府井到西单的距离，单位千米GEODIST shop wangfujing xidan km# 输出&quot;1.4681&quot; ◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。 4. GEOHASH：获取指定成员的geohash编码（底层编码查询） ◦ 语法： 1GEOHASH key [member [member ...]] ◦ 示例： 1234# 返回王府井的geohash字符串，共11位GEOHASH shop wangfujing# 输出1) &quot;wx4g0f6f2u0&quot; ◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。 5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 12345678910111213141516GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 参数说明# key: key名称# longitude: 经度# latitude: 纬度# radius: 半径# M|KM|FT|MI: 单位## 可选参数# WITHCOORD: 返回经纬度# WITHDIST: 带距离# WITHHASH: 带geohash# COUNT count: 限制返回数量# ANY: 随机返回数量# ASC/DESC: 按距离正/倒序# STORE key: 存储结果到指定key# STOREDIST key: 存储结果到指定key，结果为距离 ◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序） ◦ 示例： 1234567# 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 1234567GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 语法说明：# key: key名称# member: 已有成员名称# radius: 半径# M|KM|FT|MI: 单位## 可选参数说明同 GEORADIUS ◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令） ◦ 示例： 1234567# 查王府井3km内的门店，按距离排序GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; Geo 扩展操作（实战常用） 1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER） ◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法 123GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH] ◦ 语法1（按坐标中心）：GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查天安门3km内的门店，按距离排序GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 语法2（按成员中心）：GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查王府井3km内的门店，按距离排序GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot; ◦ 新增特性：支持 BYBOX（按矩形范围查询），适配更多场景（如查询某片区内的门店）。 123456789# 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店# 西单距离王府井 1.4681 km，所以不在结果中GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; 2. GEOSEARCHSTORE（Redis 6.2+ 新增） ◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序） ◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH） 1234GEOSEARCHSTORE destination source &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [STOREDIST] ◦ 示例： 12# 把王府井3km内的门店，存到near_shop集合GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km 底层核心与实战注意事项 底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。 精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。 性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。 适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。 典型实战场景示例 需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。 12345678# 1. 批量添加餐饮坐标GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc# 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC# 3. 删除某餐饮ZREM restaurant aaa Geo 命令 SpringBoot 的 StringRedisTemplate.opsForGeo() 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Geo 写入 / 删除类操作 方法功能 方法 Redis 原始命令 备注 添加单个坐标 add(K key, Point point, M member) GEOADD key longitude latitude member 返回 新增成员数量（已存在则返回 0） 添加单个位置 add(K key, GeoLocation&lt;M&gt; location) GEOADD key longitude latitude member GeoLocation 内部封装了 Point + member 批量添加 add(K key, Map&lt;M, Point&gt; map) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 推荐，一次网络 IO 批量添加 add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 与 Map 方式等价 删除成员 remove(K key, M... members) ZREM key member [member ...] GEO 本质是 Sorted Set 12345Point point = new Point(longitude, latitude);redisTemplate.opsForGeo().add(key, point, member);RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= new RedisGeoCommands.GeoLocation&lt;&gt;(member, point);redisTemplate.opsForGeo().add(key, geoLocation); 距离 / 坐标 / 哈希查询 方法功能 方法 Redis 原始命令 说明 两点距离 distance(K key, m1, m2) GEODIST key m1 m2 默认单位米 指定单位距离 distance(K key, m1, m2, metric) GEODIST key m1 m2 unit m / km / mi / ft 获取 GeoHash hash(K key, M... members) GEOHASH key member 用于调试 获取坐标 position(K key, M... members) GEOPOS key member lon / lat 半径查询（旧接口，已不推荐） Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。 1️⃣ 基于坐标点 方法功能 方法 Redis 原始命令 半径查询 radius(K key, Circle within) GEORADIUS key lon lat radius 半径 + 参数 radius(K key, Circle within, args) GEORADIUS 2️⃣ 基于成员 方法功能 方法 Redis 原始命令 半径查询 radius(K key, member, radius) GEORADIUSBYMEMBER 指定单位 radius(K key, member, Distance) GEORADIUSBYMEMBER 带参数 radius(K key, member, Distance, args) GEORADIUSBYMEMBER 搜索查询（推荐使用 GEOSEARCH） 替代 GEORADIUS / GEORADIUSBYMEMBER 1️⃣ 按圆形范围搜索 方法功能 方法 Redis 原始命令 说明 圆形搜索 search(K key, Circle within) GEOSEARCH 新推荐接口 指定参考点 search(K key, GeoReference, Distance) GEOSEARCH FROMMEMBER / FROMLONLAT 带参数 search(K key, reference, radius, args) GEOSEARCH 支持排序、limit 2️⃣ 按矩形范围搜索 方法功能 方法 Redis 原始命令 矩形搜索 search(K key, reference, BoundingBox) GEOSEARCH 带参数 search(K key, reference, BoundingBox, args) GEOSEARCH 通用搜索（底层能力） 方法功能 方法 Redis 原始命令 任意 GeoShape search(K key, reference, GeoShape, args) GEOSEARCH 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 基于给定的坐标搜索public void search(String key, double longitude, double latitude, double radius) &#123; // 中心点 Point point = new Point(longitude, latitude); // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建圆形 Circle circle = new Circle(point, distance); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125;// 基于成员的坐标搜索public void search(String key, String member, double radius) &#123; // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125; 搜索并存储（GEOSEARCHSTORE） 这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet 1️⃣ 圆形范围存储 方法功能 方法 Redis 原始命令 搜索并存储 searchAndStore(K key, destKey, Circle) GEOSEARCHSTORE 指定参考点 searchAndStore(K key, destKey, reference, radius) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, radius, args) GEOSEARCHSTORE 2️⃣ 矩形范围存储 方法功能 方法 Redis 原始命令 矩形存储 searchAndStore(K key, destKey, reference, BoundingBox) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, BoundingBox, args) GEOSEARCHSTORE 3️⃣ 通用 GeoShape 存储 方法功能 方法 Redis 原始命令 通用存储 searchAndStore(K key, destKey, reference, GeoShape, args) GEOSEARCHSTORE","summary":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","title":"Redis 命令及数据类型 -- Hyperloglog","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hyperloglog 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hyperloglog-核心详解\">Hyperloglog 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 <code>12KB</code>）就能统计海量数据的基数，误差率仅 <code>0.81%</code>，无需存储全部数据本身。</p>\n</li>\n</ul>\n<blockquote>\n<p>基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n</ul>\n<h2 id=\"核心使用方式（3个核心命令）\">核心使用方式（3个核心命令）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 命令极简，只有 3 个核心操作</p>\n</li>\n</ul>\n<h3 id=\"PFADD\">PFADD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFADD key [element [element ...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFCOUNT\">PFCOUNT</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFMERGE\">PFMERGE</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFMERGE destkey [sourcekey [sourcekey ...]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"实操示例\">实操示例</h2>\n<h3 id=\"示例1：单-key-基础统计（统计网站-UV）\">示例1：单 key 基础统计（统计网站 UV）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 模拟3个访客访问，其中用户A重复访问</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 统计当日UV（去重后是3，忽略重复的userA）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251218</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例2：-多-key-合并与汇总统计\">示例2： 多 key 合并与汇总统计</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 分别统计12.17和12.18的UV</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251217 userA userD</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 合并两日UV到 uv:20251217_18</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251217_18</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心应用场景（精准落地场景）\">核心应用场景（精准落地场景）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 只关注 <strong>“去重数量”</strong>，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案：</p>\n</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">\n<p>网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。</p>\n</li>\n<li class=\"lvl-3\">\n<p>业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。</p>\n</li>\n</ol>\n<h2 id=\"关键注意事项（避坑重点）\">关键注意事项（避坑重点）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。</p>\n</li>\n<li class=\"lvl-3\">\n<p>误差不可避免，可控不影响大部分场景：固定误差率 <code>0.81%</code>，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。</p>\n</li>\n<li class=\"lvl-3\">\n<p>内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 <code>12KB</code>，这是其核心优势，也是区别于 Set 的关键。</p>\n</li>\n<li class=\"lvl-3\">\n<p>元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 <code>EXPIRE key seconds</code> 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。</p>\n</li>\n</ol>\n<h2 id=\"与-Set-统计基数的对比（选型参考）\">与 Set 统计基数的对比（选型参考）</h2>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>HyperLogLog</th>\n<th>Set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据结构类型</td>\n<td>基数统计结构</td>\n<td>无序集合</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>固定约 <strong>12KB</strong>，与数据量无关</td>\n<td>随元素数量线性增长，海量数据内存占用极高</td>\n</tr>\n<tr>\n<td>统计结果精度</td>\n<td><strong>非精准</strong>，标准误差约 <strong>0.81%</strong></td>\n<td><strong>100% 精准</strong></td>\n</tr>\n<tr>\n<td>是否支持获取具体元素</td>\n<td>不支持</td>\n<td>支持（如 <code>SMEMBERS</code>）</td>\n</tr>\n<tr>\n<td>是否支持去重</td>\n<td>支持（基数去重）</td>\n<td>支持（元素级去重）</td>\n</tr>\n<tr>\n<td>统计性能</td>\n<td>极快（固定计算逻辑，O(1)）</td>\n<td>数据量越大，统计与遍历成本越高</td>\n</tr>\n<tr>\n<td>适合数据规模</td>\n<td>超大规模（百万 / 千万 / 亿级）</td>\n<td>中小规模集合</td>\n</tr>\n<tr>\n<td>常见使用场景</td>\n<td>UV / DAU 统计、独立 IP 数、访问用户数</td>\n<td>好友列表、标签集合、关注列表</td>\n</tr>\n<tr>\n<td>是否可做集合运算</td>\n<td>不支持</td>\n<td>支持（<code>SUNION</code> / <code>SINTER</code> / <code>SDIFF</code>）</td>\n</tr>\n<tr>\n<td>是否可序列化/持久化</td>\n<td>可（Redis 内部结构）</td>\n<td>可</td>\n</tr>\n<tr>\n<td>选型结论</td>\n<td><strong>低成本 + 海量数据 + 可接受误差的基数统计</strong></td>\n<td><strong>精准统计 + 需要元素明细的场景</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"HyperLogLog-命令\">HyperLogLog 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForHyperLogLog()</code> 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 HyperLogLog</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注 / 使用建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素</td>\n<td><code>Long add(K key, V... values)</code></td>\n<td><code>PFADD key element [element ...]</code></td>\n<td>返回 1 表示 HLL 结构发生变化</td>\n</tr>\n<tr>\n<td>获取基数（去重数）</td>\n<td><code>Long size(K... keys)</code></td>\n<td><code>PFCOUNT key [key ...]</code></td>\n<td>支持多 key 合并统计</td>\n</tr>\n<tr>\n<td>合并 HLL</td>\n<td><code>Long union(K destination, K... sourceKeys)</code></td>\n<td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td>\n<td>合并后写入 destkey</td>\n</tr>\n<tr>\n<td>删除 HLL</td>\n<td><code>void delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>直接删除整个 HLL</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hyperloglog 核心详解 Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 12KB）就能统计海量数据的基数，误差率仅 0.81%，无需存储全部数据本身。 基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。 Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展 核心使用方式（3个核心命令） HyperLogLog 命令极简，只有 3 个核心操作 PFADD 向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。 1PFADD key [element [element ...]] PFCOUNT 统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。 1PFCOUNT key [key ...] PFMERGE 将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。 1PFMERGE destkey [sourcekey [sourcekey ...]] 实操示例 示例1：单 key 基础统计（统计网站 UV） 123456789# 1. 模拟3个访客访问，其中用户A重复访问127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA(integer) 0# 2. 统计当日UV（去重后是3，忽略重复的userA）127.0.0.1:6379&gt; PFCOUNT uv:20251218(integer) 3 示例2： 多 key 合并与汇总统计 12345678910111213# 1. 分别统计12.17和12.18的UV127.0.0.1:6379&gt; PFADD uv:20251217 userA userD(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1# 2. 合并两日UV到 uv:20251217_18127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218OK# 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）127.0.0.1:6379&gt; PFCOUNT uv:20251217_18(integer) 4 核心应用场景（精准落地场景） HyperLogLog 只关注 “去重数量”，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案： 网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。 业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。 海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。 跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。 关键注意事项（避坑重点） 不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。 误差不可避免，可控不影响大部分场景：固定误差率 0.81%，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。 内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 12KB，这是其核心优势，也是区别于 Set 的关键。 元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。 过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 EXPIRE key seconds 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。 PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。 与 Set 统计基数的对比（选型参考） 对比维度 HyperLogLog Set 数据结构类型 基数统计结构 无序集合 内存占用 固定约 12KB，与数据量无关 随元素数量线性增长，海量数据内存占用极高 统计结果精度 非精准，标准误差约 0.81% 100% 精准 是否支持获取具体元素 不支持 支持（如 SMEMBERS） 是否支持去重 支持（基数去重） 支持（元素级去重） 统计性能 极快（固定计算逻辑，O(1)） 数据量越大，统计与遍历成本越高 适合数据规模 超大规模（百万 / 千万 / 亿级） 中小规模集合 常见使用场景 UV / DAU 统计、独立 IP 数、访问用户数 好友列表、标签集合、关注列表 是否可做集合运算 不支持 支持（SUNION / SINTER / SDIFF） 是否可序列化/持久化 可（Redis 内部结构） 可 选型结论 低成本 + 海量数据 + 可接受误差的基数统计 精准统计 + 需要元素明细的场景 HyperLogLog 命令 SpringBoot 的 StringRedisTemplate.opsForHyperLogLog() 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 HyperLogLog 方法功能 方法 Redis 原始命令 备注 / 使用建议 添加元素 Long add(K key, V... values) PFADD key element [element ...] 返回 1 表示 HLL 结构发生变化 获取基数（去重数） Long size(K... keys) PFCOUNT key [key ...] 支持多 key 合并统计 合并 HLL Long union(K destination, K... sourceKeys) PFMERGE destkey sourcekey [sourcekey ...] 合并后写入 destkey 删除 HLL void delete(K key) DEL key 直接删除整个 HLL","summary":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/","url":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitfield/","title":"Redis 命令及数据类型 -- Bitfield","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Bitfield 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bitfield-核心详解\">Bitfield 核心详解</h2>\n<p>• BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。<br>\n• 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。</p>\n<h2 id=\"Bitfield-命令\">Bitfield 命令</h2>\n<h3 id=\"1-BITFIELD-批量操作\">1. <code>BITFIELD</code> 批量操作</h3>\n<p>• BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  ...]]</span><br></pre></td></tr></table></figure>\n<p>• 参数说明（核心部分）</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>操作的 Redis 字符串键</td>\n</tr>\n<tr>\n<td><strong>GET encoding offset</strong></td>\n<td>从指定位偏移量读取一个整数</td>\n</tr>\n<tr>\n<td><strong>SET encoding offset value</strong></td>\n<td>在指定位置写入整数</td>\n</tr>\n<tr>\n<td><strong>INCRBY encoding offset increment</strong></td>\n<td>在指定位置对整数做增量操作</td>\n</tr>\n<tr>\n<td><strong>OVERFLOW WRAP/SAT/FAIL</strong></td>\n<td>配置随后的算数操作溢出行为</td>\n</tr>\n</tbody>\n</table>\n<p>• 数据类型（encoding）:用于指定整数的位宽和符号类型</p>\n<table>\n<thead>\n<tr>\n<th>前缀</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>u&lt;number&gt;</code></td>\n<td>无符号整数（unsigned），占位 bits = number</td>\n<td>u5 — 5 位无符号整数</td>\n</tr>\n<tr>\n<td><code>i&lt;number&gt;</code></td>\n<td>有符号整数（signed），占位 bits = number</td>\n<td>i10 — 10 位有符号整数</td>\n</tr>\n</tbody>\n</table>\n<p>• 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。</p>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>WRAP</strong></td>\n<td>环绕（默认）溢出按环形计数处理</td>\n</tr>\n<tr>\n<td><strong>SAT</strong></td>\n<td>饱和，在边界值保持最大/最小</td>\n</tr>\n<tr>\n<td><strong>FAIL</strong></td>\n<td>溢出时操作失败并返回错误</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。</span></span><br><span class=\"line\">BITFIELD key OVERFLOW SAT INCRBY u4 0 1</span><br></pre></td></tr></table></figure>\n<p>• 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-BITFIELD-RO-批量只读\">2. <code>BITFIELD_RO</code> 批量只读</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 6.0 新增的只读版本，用于批量只读</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD_RO key [GET encoding offset [GET encoding offset ...]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"综合示例\">综合示例</h2>\n<h3 id=\"示例-1-设置并读取简单整数\">示例 1. 设置并读取简单整数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET mykey <span class=\"string\">&quot;&quot;</span> <span class=\"comment\"># 此时mykey 的值是空字符串，长度为 0</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET u4 0 7 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># set命令的返回值，这里返回set前的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># get命令的返回值</span></span><br><span class=\"line\"><span class=\"comment\"># 设置有符号整数</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET i4 0 -2 GET i4 0</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># 返回set前的值，之前是7，即 0111，set后变为 -2，即 1110</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) -2 <span class=\"comment\"># get命令的返回值</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>负数的二进制表示</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">以 -2 为例，先写出 +2 的二进制，以8位为例，就是 <code>00000010</code>，4位就是 <code>0010</code></li>\n<li class=\"lvl-2\">按位取反（得到反码），例如 <code>00000010</code>，按位取反就是 <code>11111101</code></li>\n<li class=\"lvl-2\">加 1（得到补码），<code>11111101</code> + 1，得到 <code>11111110</code>，这就是 -2 的二进制表示</li>\n<li class=\"lvl-2\">如果是4位，则 -2 就是 <code>1110</code></li>\n</ul>\n</div>\n<h3 id=\"示例-2-自增计数器\">示例 2. 自增计数器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果 counter 之前为空，则视为 0</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5</span></span><br><span class=\"line\"><span class=\"comment\"># GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值</span></span><br><span class=\"line\">BITFIELD counter INCRBY u8 8 5 GET u8 8</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 5 <span class=\"comment\"># INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例-3-带溢出控制的操作\">示例 3. 带溢出控制的操作</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># OVERFLOW SAT: 设置溢出策略为 SAT（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 4 位无符号整数，即15</span></span><br><span class=\"line\">BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 15</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 15</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例-4-批量多个操作\">示例 4. 批量多个操作</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理</span></span><br><span class=\"line\"><span class=\"comment\"># 返回结果数组对应每个子命令顺序返回结果</span></span><br><span class=\"line\">BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 0000000000110000</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-操作-BitField\">SpringBoot 操作 BitField</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 BitField 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 BitField</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>位字段读/写/自增</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>位字段操作（读/写/自增）</td>\n<td><code>bitField(K key, BitFieldSubCommands subCommands)</code></td>\n<td><code>BITFIELD key ...</code></td>\n<td>原子执行多个子命令</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD limits</span><br><span class=\"line\">    OVERFLOW SAT</span><br><span class=\"line\">    SET u4 0 3</span><br><span class=\"line\">    INCRBY u4 0 20</span><br><span class=\"line\">    GET u4 0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SET u4 0 3</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldSet</span> <span class=\"variable\">bitFieldSet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// OVERFLOW SAT INCRBY u4 0 20</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldIncrBy</span> <span class=\"variable\">bitFieldIncrBy</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">20</span>, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);</span><br><span class=\"line\"><span class=\"comment\">// GET u4 0</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldGet</span> <span class=\"variable\">bitFieldGet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取结果，每个子操作返回一个结果</span></span><br><span class=\"line\">List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(<span class=\"string\">&quot;limits&quot;</span>, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis Bitfield 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Bitfield 核心详解 • BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。 • 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。 Bitfield 命令 1. BITFIELD 批量操作 • BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。 12345BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; ...]] • 参数说明（核心部分） 参数 含义 key 操作的 Redis 字符串键 GET encoding offset 从指定位偏移量读取一个整数 SET encoding offset value 在指定位置写入整数 INCRBY encoding offset increment 在指定位置对整数做增量操作 OVERFLOW WRAP/SAT/FAIL 配置随后的算数操作溢出行为 • 数据类型（encoding）:用于指定整数的位宽和符号类型 前缀 含义 示例 u&lt;number&gt; 无符号整数（unsigned），占位 bits = number u5 — 5 位无符号整数 i&lt;number&gt; 有符号整数（signed），占位 bits = number i10 — 10 位有符号整数 • 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。 策略 行为 WRAP 环绕（默认）溢出按环形计数处理 SAT 饱和，在边界值保持最大/最小 FAIL 溢出时操作失败并返回错误 12# 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。BITFIELD key OVERFLOW SAT INCRBY u4 0 1 • 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果 1234BITFIELD mykey INCRBY i5 100 1 GET u4 0# 输出1) (integer) 12) (integer) 0 2. BITFIELD_RO 批量只读 Redis 6.0 新增的只读版本，用于批量只读 1BITFIELD_RO key [GET encoding offset [GET encoding offset ...]] 综合示例 示例 1. 设置并读取简单整数 1234567891011&gt; SET mykey &quot;&quot; # 此时mykey 的值是空字符串，长度为 0# SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000# GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7&gt; BITFIELD mykey SET u4 0 7 GET u4 0# 输出1) (integer) 0 # set命令的返回值，这里返回set前的值2) (integer) 7 # get命令的返回值# 设置有符号整数&gt; BITFIELD mykey SET i4 0 -2 GET i4 01) (integer) 7 # 返回set前的值，之前是7，即 0111，set后变为 -2，即 11102) (integer) -2 # get命令的返回值 负数的二进制表示 以 -2 为例，先写出 +2 的二进制，以8位为例，就是 00000010，4位就是 0010 按位取反（得到反码），例如 00000010，按位取反就是 11111101 加 1（得到补码），11111101 + 1，得到 11111110，这就是 -2 的二进制表示 如果是4位，则 -2 就是 1110 示例 2. 自增计数器 1234567# 如果 counter 之前为空，则视为 0# INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5# GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值BITFIELD counter INCRBY u8 8 5 GET u8 8# 输出1) (integer) 5 # INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值2) (integer) 5 示例 3. 带溢出控制的操作 1234567# OVERFLOW SAT: 设置溢出策略为 SAT（饱和）# INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）# GET u4 0：读取 4 位无符号整数，即15BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0# 输出1) (integer) 152) (integer) 15 示例 4. 批量多个操作 123456789# GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数# SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理# 返回结果数组对应每个子命令顺序返回结果BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1# 输出1) (integer) 0 # events原先为空，所以这里返回02) (integer) 0 # events原先为空，所以这里返回03) (integer) 0 # events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 00000000001100004) (integer) 1 # 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节 SpringBoot 操作 BitField SpringBoot 的 StringRedisTemplate.opsForValue() 中 BitField 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 BitField 位字段读/写/自增 方法功能 方法 Redis 原始命令 备注 位字段操作（读/写/自增） bitField(K key, BitFieldSubCommands subCommands) BITFIELD key ... 原子执行多个子命令 示例 12345BITFIELD limits OVERFLOW SAT SET u4 0 3 INCRBY u4 0 20 GET u4 0 123456789// SET u4 0 3BitFieldSubCommands.BitFieldSet bitFieldSet = BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 3);// OVERFLOW SAT INCRBY u4 0 20BitFieldSubCommands.BitFieldIncrBy bitFieldIncrBy = BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 20, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);// GET u4 0BitFieldSubCommands.BitFieldGet bitFieldGet = BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0));// 获取结果，每个子操作返回一个结果List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(&quot;limits&quot;, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));","summary":"摘要 本文介绍 Redis Bitfield 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-18T13:30:06.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","url":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","title":"Redis 命令及数据类型 -- Bitmap","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Bitmap 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bitmap-核心详解\">Bitmap 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n<li class=\"lvl-2\">\n<p>String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值）</p>\n</li>\n</ul>\n<h2 id=\"Bitmap-命令使用方式\">Bitmap 命令使用方式</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础</p>\n</li>\n</ul>\n<h3 id=\"1-位设置：SETBIT-key-offset-value\">1. 位设置：<code>SETBIT key offset value</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容）</p>\n</li>\n<li class=\"lvl-2\">\n<p>offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT bitkey 1 1 <span class=\"comment\"># 实际的bit为 01000000</span></span><br><span class=\"line\">SETBIT bitkey 10 1 <span class=\"comment\"># 实际的bit为 0100000000100000</span></span><br><span class=\"line\"><span class=\"comment\"># 操作 String</span></span><br><span class=\"line\">SET k1 v1 <span class=\"comment\"># 实际的bit为 0111011000110001</span></span><br><span class=\"line\">SETBIT k1 1 0 <span class=\"comment\"># 实际bit为 0011011000110001</span></span><br><span class=\"line\">GET k1 <span class=\"comment\"># 输出 61</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bitmap 实际上是 string</span></span><br><span class=\"line\">TYPE bitkey <span class=\"comment\"># 输出 string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-位查询：GETBIT-key-offset\">2. 位查询：<code>GETBIT key offset</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查询指定偏移量的位值，不存在的 offset 默认返回 0</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GETBIT bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-位统计：BITCOUNT-key-start-end\">3. 位统计：<code>BITCOUNT key [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITCOUNT bitkey</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITCOUNT bitkey 0 -1</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-位运算：BITOP-op-destkey-key1-key2\">4. 位运算：<code>BITOP op destkey key1 key2...</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将key1 与 key2 做按位与运算，结果存入 destkey</span></span><br><span class=\"line\">BITOP AND destkey key1 key2</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-位查找：BITPOS-key-value-start-end\">5. 位查找：<code>BITPOS key value [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查找第一个值为 0/1 的 bit 偏移量，快速定位目标位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITPOS bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITPOS bitkey 1 0 -1</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心使用场景-实操举例（贴合开发实战）\">核心使用场景 + 实操举例（贴合开发实战）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景</p>\n</li>\n</ul>\n<h3 id=\"场景1：-用户签到-打卡（最经典场景）\">场景1： 用户签到/打卡（最经典场景）</h3>\n<p>• 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数<br>\n• 设计：key 格式 <code>user:sign:uid:202512</code>（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>12月1号签到：<code>SETBIT user:sign:uid:202512 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询12月1号是否签到：<code>GETBIT user:sign:uid:202512 0</code>（返回1=签到）</p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月总签到次数：<code>BITCOUNT user:sign:uid:202512</code></p>\n</li>\n</ol>\n<p>• 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景2：-日活-周活-月活（DAU-WAU-MAU）统计（高并发场景首选）\">场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选）</h3>\n<p>• 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计<br>\n• 设计：按日期建 Bitmap，key 格式 <code>active:user:20251217</code>（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>用户ID 10086 12月17日访问：<code>SETBIT active:user:20251217 10086 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月17日日活：<code>BITCOUNT active:user:20251217</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日3天内活跃的用户数：<code>BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日每天都登录的用户数：<code>BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n</ol>\n<p>• 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景3：-功能开关-状态标记（多维度轻量标记）\">场景3： 功能开关/状态标记（多维度轻量标记）</h3>\n<p>• 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key<br>\n• 设计：1个key对应1个用户，key 格式 <code>user:status:10086</code>，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>给用户10086绑定手机：<code>SETBIT user:status:10086 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>开通会员：<code>SETBIT user:status:10086 1 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询是否是会员：<code>GETBIT user:status:10086 1</code></p>\n</li>\n</ol>\n<p>• 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景4：-布隆过滤器底层实现（核心依赖Bitmap）\">场景4： 布隆过滤器底层实现（核心依赖Bitmap）</h3>\n<p>• 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判<br>\n• 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在<br>\n• 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。<br>\n• 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：布隆过滤器虽然有极小误判率，但不允许删除。</p>\n</li>\n</ul>\n<h2 id=\"注意事项（避坑关键）\">注意事项（避坑关键）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩）</p>\n</li>\n<li class=\"lvl-3\">\n<p>避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长</p>\n</li>\n<li class=\"lvl-3\">\n<p>注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置</p>\n</li>\n</ol>\n<h2 id=\"Bitmap-命令\">Bitmap 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Bitmap</p>\n</blockquote>\n<h3 id=\"写操作（位修改）\">写操作（位修改）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置指定偏移量的位</td>\n<td><code>setBit(K key, long offset, boolean value)</code></td>\n<td><code>SETBIT key offset value</code></td>\n<td>返回旧值（0 / 1），offset 从 0 开始</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>offset 表示 第几位（bit），不是字节</p>\n</blockquote>\n<h3 id=\"读操作（位查询）\">读操作（位查询）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定偏移量的位</td>\n<td><code>getBit(K key, long offset)</code></td>\n<td><code>GETBIT key offset</code></td>\n<td>返回 0 / 1，不会修改数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Bitmap-常用但-Spring-未直接封装的命令\">Bitmap 常用但 Spring 未直接封装的命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Redis 命令</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>BITCOUNT key [start end]</code></td>\n<td>统计 bit=1 的数量</td>\n<td>常用于活跃用户统计</td>\n</tr>\n<tr>\n<td><code>BITPOS key bit [start end]</code></td>\n<td>查找第一个 0/1 的位置</td>\n<td>常用于分配位</td>\n</tr>\n<tr>\n<td><code>BITOP AND/OR/XOR/NOT</code></td>\n<td>位运算</td>\n<td>多 bitmap 计算</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo.bitmap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.demo.CommonUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.domain.Range;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BitmapUtil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITCOUNT key [start end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 统计 bit=1 的数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(), start, end)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITPOS key bit [start] [end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = false → 查找第一个 0</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = true → 查找第一个 1</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回值是 bit 索引（不是 byte）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITOP operation destKey key [key ...]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * operation: AND\\OR\\XOR\\NOT</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 运算结果保存在 destKey 中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitOp</span><span class=\"params\">(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[][] keys = Arrays.stream(sourceKeys)</span><br><span class=\"line\">                    .map(String::getBytes)</span><br><span class=\"line\">                    .toArray(<span class=\"type\">byte</span>[][]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.stringCommands().bitOp(</span><br><span class=\"line\">                    operation,</span><br><span class=\"line\">                    destKey.getBytes(),</span><br><span class=\"line\">                    keys</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Bitmap 核心详解 Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展 String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值） Bitmap 命令使用方式 核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础 1. 位设置：SETBIT key offset value 给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容） offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte 123456789SETBIT bitkey 1 1 # 实际的bit为 01000000SETBIT bitkey 10 1 # 实际的bit为 0100000000100000# 操作 StringSET k1 v1 # 实际的bit为 0111011000110001SETBIT k1 1 0 # 实际bit为 0011011000110001GET k1 # 输出 61# bitmap 实际上是 stringTYPE bitkey # 输出 string 2. 位查询：GETBIT key offset 查询指定偏移量的位值，不存在的 offset 默认返回 0 123GETBIT bitkey 1# 输出(integer) 1 3. 位统计：BITCOUNT key [start end] 统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选 123BITCOUNT bitkey# 等价于BITCOUNT bitkey 0 -1 4. 位运算：BITOP op destkey key1 key2... 对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey 12# 将key1 与 key2 做按位与运算，结果存入 destkeyBITOP AND destkey key1 key2 5. 位查找：BITPOS key value [start end] 查找第一个值为 0/1 的 bit 偏移量，快速定位目标位 123BITPOS bitkey 1# 等价于BITPOS bitkey 1 0 -1 核心使用场景 + 实操举例（贴合开发实战） Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景 场景1： 用户签到/打卡（最经典场景） • 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数 • 设计：key 格式 user:sign:uid:202512（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0 • 实操命令： 12月1号签到：SETBIT user:sign:uid:202512 0 1 查询12月1号是否签到：GETBIT user:sign:uid:202512 0（返回1=签到） 统计12月总签到次数：BITCOUNT user:sign:uid:202512 • 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。 劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选） • 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计 • 设计：按日期建 Bitmap，key 格式 active:user:20251217（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1 • 实操命令： 用户ID 10086 12月17日访问：SETBIT active:user:20251217 10086 1 统计12月17日日活：BITCOUNT active:user:20251217 统计12月15-17日3天内活跃的用户数：BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 统计12月15-17日每天都登录的用户数：BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 • 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。 劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景3： 功能开关/状态标记（多维度轻量标记） • 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key • 设计：1个key对应1个用户，key 格式 user:status:10086，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否 • 实操命令： 给用户10086绑定手机：SETBIT user:status:10086 0 1 开通会员：SETBIT user:status:10086 1 1 查询是否是会员：GETBIT user:status:10086 1 • 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。 劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景4： 布隆过滤器底层实现（核心依赖Bitmap） • 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判 • 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在 • 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。 • 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。 劣势：布隆过滤器虽然有极小误判率，但不允许删除。 注意事项（避坑关键） offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩） 避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长 注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置 Bitmap 命令 SpringBoot 的 StringRedisTemplate.opsForValue() 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Bitmap 写操作（位修改） 方法功能 方法 Redis 原始命令 备注 设置指定偏移量的位 setBit(K key, long offset, boolean value) SETBIT key offset value 返回旧值（0 / 1），offset 从 0 开始 offset 表示 第几位（bit），不是字节 读操作（位查询） 方法功能 方法 Redis 原始命令 备注 获取指定偏移量的位 getBit(K key, long offset) GETBIT key offset 返回 0 / 1，不会修改数据 Bitmap 常用但 Spring 未直接封装的命令 Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。 Redis 命令 功能 说明 BITCOUNT key [start end] 统计 bit=1 的数量 常用于活跃用户统计 BITPOS key bit [start end] 查找第一个 0/1 的位置 常用于分配位 BITOP AND/OR/XOR/NOT 位运算 多 bitmap 计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.demo.bitmap;import com.example.demo.CommonUtil;import org.springframework.data.domain.Range;import org.springframework.data.redis.connection.RedisStringCommands;import org.springframework.data.redis.core.RedisCallback;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;import java.util.Arrays;@Componentpublic class BitmapUtil &#123; @Autowired protected StringRedisTemplate redisTemplate; /** * BITCOUNT key [start end] * &lt;p&gt; * 统计 bit=1 的数量 */ public Long bitCount(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8)) ); &#125; public Long bitCount(String key, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(), start, end) ); &#125; /** * BITPOS key bit [start] [end] * &lt;p&gt; * bit = false → 查找第一个 0 * bit = true → 查找第一个 1 * &lt;p&gt; * 返回值是 bit 索引（不是 byte） */ public Long bitPos(String key, boolean bit) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit) ); &#125; public Long bitPos(String key, boolean bit, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end)) ); &#125; /** * BITOP operation destKey key [key ...] * &lt;p&gt; * operation: AND\\OR\\XOR\\NOT * &lt;p&gt; * 运算结果保存在 destKey 中 */ public Long bitOp(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123; byte[][] keys = Arrays.stream(sourceKeys) .map(String::getBytes) .toArray(byte[][]::new); return connection.stringCommands().bitOp( operation, destKey.getBytes(), keys ); &#125;); &#125;&#125;","summary":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-18T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","url":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","title":"一个基于 Redis 的可重入分布式锁的实现","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 一个基于 Redis 的可重入分布式锁的实现方案</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">本文仅为学习原理，生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/locks-and-synchronizers/\">Redisson 分布式锁</a> 吧。</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"设计目标与关键约束\">设计目标与关键约束</h2>\n<h3 id=\"设计目标\">设计目标</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>互斥性：同一时间只有一个持有者</p>\n</li>\n<li class=\"lvl-2\">\n<p>可重入：同一线程 / 请求可多次加锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>安全释放：只能释放自己持有的锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>自动过期：防止死锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>续期能力（Watch Dog）：业务时间不确定时依然安全</p>\n</li>\n<li class=\"lvl-2\">\n<p>高性能：单 Redis Key，Lua 保证原子性</p>\n</li>\n</ul>\n<h3 id=\"技术选型\">技术选型</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Boot</p>\n</li>\n<li class=\"lvl-2\">\n<p>Spring Data Redis（Lettuce）</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis Lua Script</p>\n</li>\n</ul>\n<blockquote>\n<p>Redis 是唯一依赖组件：Redis<br>\nSpring Boot 作为运行框架：Spring Boot</p>\n</blockquote>\n<h3 id=\"锁的核心数据结构设计（关键）\">锁的核心数据结构设计（关键）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Key 结构(String)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># lock:前缀</span></span><br><span class=\"line\">lock:order:123</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Value 结构（Hash）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;uuid:threadId&quot;</span> : 重入次数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同一线程重入 → count +1，不同线程 → 拒绝</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用<code>StringRedisTemplate</code>，因其序列化器是<code>StringRedisSerializer</code>，可以保证 Lua 脚本能够正常执行。</p>\n</li>\n</ul>\n<blockquote>\n<p>基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer</p>\n</blockquote>\n<h3 id=\"Lua-脚本（原子性保障）\">Lua 脚本（原子性保障）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加锁脚本（支持可重入）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[2] expireMillis</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;exists&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hset&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解锁脚本（防误删）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> count = redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hdel&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hlen&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">        redis.call(<span class=\"string\">&#x27;del&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java-实现（核心代码）\">Java 实现（核心代码）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>WatchDog，实现锁自动续期</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisLockWatchDog</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * WatchDog的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 拥有者是当前线程就续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">WATCHDOG_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单线程足够（Redisson 也是）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">scheduler</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                t.setName(<span class=\"string\">&quot;redis-lock-watch-dog&quot;</span>);</span><br><span class=\"line\">                t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每个 lockKey 对应一个续期任务</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisLockWatchDog</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动续期</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey     Redis 锁 key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ownerId     uuid:threadId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseMillis 锁过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startRenew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 防止重复启动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (renewTasks.containsKey(lockKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 间隔多久续期一次</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">period</span> <span class=\"operator\">=</span> leaseMillis / <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                renew(lockKey, ownerId, leaseMillis);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生产环境建议接日志</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        renewTasks.put(lockKey, future);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取消续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stopRenew</span><span class=\"params\">(String lockKey)</span> &#123;</span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (future != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            future.cancel(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实际续期逻辑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">renew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId,</span><br><span class=\"line\">                String.valueOf(leaseMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 锁已不属于当前线程，停止 Watch Dog</span></span><br><span class=\"line\">            stopRenew(lockKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 应用关闭时释放资源（可选）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shutdown</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        scheduler.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> waitTime  尝试获取锁的最大等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 不等待立即返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 只要获取到锁就返回，否则一直自旋获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit 时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁实现类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的key前缀</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.key 不存在时创建锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.key 存在时判断锁的拥有者是否为当前线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">UNLOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 0</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)</span></span><br><span class=\"line\"><span class=\"string\">            if (count &gt; 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            else</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1])</span></span><br><span class=\"line\"><span class=\"string\">                if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                    redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">                end</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedisLockWatchDog watchDog;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisReentrantLock</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">        watchDog = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisLockWatchDog</span>(redisTemplate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前线程的 ownerId</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">ownerId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uuid + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expireMillis</span> <span class=\"operator\">=</span> unit.toMillis(leaseTime);</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(LOCK_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId(),</span><br><span class=\"line\">                String.valueOf(expireMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Boolean.TRUE.equals(success)) &#123;<span class=\"comment\">//防止NullPointerException</span></span><br><span class=\"line\">            <span class=\"comment\">// 启动 Watch Dog（只有在 leaseTime 不确定时）</span></span><br><span class=\"line\">            watchDog.startRenew(</span><br><span class=\"line\">                    lockKey,</span><br><span class=\"line\">                    ownerId(),</span><br><span class=\"line\">                    expireMillis</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">deadline</span> <span class=\"operator\">=</span> System.currentTimeMillis() + unit.toMillis(waitTime);</span><br><span class=\"line\">        <span class=\"comment\">// 使用带条件的循环，避免重复赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; deadline) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用无限循环，语义更清晰</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"comment\">// 先停续期</span></span><br><span class=\"line\">        watchDog.stopRenew(lockKey);</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(UNLOCK_SCRIPT, Long.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId()</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.lock.RedisReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockTests</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisReentrantLock redisReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;order:123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">5</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">                doBusiness();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 测试可重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBusiness</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (redisReentrantLock.lock(lockKey, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能</span></span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;结束执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试多线程同时获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demoMultiThread</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">threadCount</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(threadCount);</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">successCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 每个线程都尝试获取同一个锁</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">10</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            successCount.incrementAndGet();</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁成功，开始执行业务&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 模拟业务执行时间</span></span><br><span class=\"line\">                            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 业务执行完成&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 释放锁&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁失败&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    latch.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待所有线程执行完成</span></span><br><span class=\"line\">        latch.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;成功获取锁的线程数: &quot;</span> + successCount.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-与-Redisson-集成之锁的使用方法\">SpringBoot 与 Redisson 集成之锁的使用方法</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.52.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">……………………………………………………………………………………………………………………………………………………………………………………………………………………</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;myLock&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传统锁定方式，阻塞等待获取锁</span></span><br><span class=\"line\"><span class=\"comment\">// lock.lock();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者，获取锁并在10秒后自动解锁</span></span><br><span class=\"line\"><span class=\"comment\">// lock.lock(10, TimeUnit.SECONDS);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或等，尝试在 100 秒内获取锁，获得后在 10 秒后自动解锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">100</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取锁成功&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。 设计目标与关键约束 设计目标 互斥性：同一时间只有一个持有者 可重入：同一线程 / 请求可多次加锁 安全释放：只能释放自己持有的锁 自动过期：防止死锁 续期能力（Watch Dog）：业务时间不确定时依然安全 高性能：单 Redis Key，Lua 保证原子性 技术选型 Spring Boot Spring Data Redis（Lettuce） Redis Lua Script Redis 是唯一依赖组件：Redis Spring Boot 作为运行框架：Spring Boot 锁的核心数据结构设计（关键） Redis Key 结构(String) 12# lock:前缀lock:order:123 Value 结构（Hash） 123&#123; &quot;uuid:threadId&quot; : 重入次数&#125; 同一线程重入 → count +1，不同线程 → 拒绝 使用StringRedisTemplate，因其序列化器是StringRedisSerializer，可以保证 Lua 脚本能够正常执行。 基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer Lua 脚本（原子性保障） 加锁脚本（支持可重入） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerId (uuid:threadId)-- ARGV[2] expireMillisif (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endreturn 0 解锁脚本（防误删） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerIdif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0endlocal count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)if (count &gt; 0) then return 1else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1end Java 实现（核心代码） WatchDog，实现锁自动续期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import java.util.Collections;import java.util.Map;import java.util.concurrent.*;public class RedisLockWatchDog &#123; /** * WatchDog的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 拥有者是当前线程就续期 */ private static final String WATCHDOG_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; /** * 单线程足够（Redisson 也是） */ private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;redis-lock-watch-dog&quot;); t.setDaemon(true); return t; &#125;); /** * 每个 lockKey 对应一个续期任务 */ private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = new ConcurrentHashMap&lt;&gt;(); public RedisLockWatchDog(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 启动续期 * * @param lockKey Redis 锁 key * @param ownerId uuid:threadId * @param leaseMillis 锁过期时间 */ public void startRenew(String lockKey, String ownerId, long leaseMillis) &#123; // 防止重复启动 if (renewTasks.containsKey(lockKey)) &#123; return; &#125; // 间隔多久续期一次 long period = leaseMillis / 3; ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123; try &#123; renew(lockKey, ownerId, leaseMillis); &#125; catch (Exception e) &#123; // 生产环境建议接日志 &#125; &#125;, period, period, TimeUnit.MILLISECONDS); renewTasks.put(lockKey, future); &#125; /** * 取消续期 */ public void stopRenew(String lockKey) &#123; ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey); if (future != null) &#123; future.cancel(false); &#125; &#125; /** * 实际续期逻辑 */ private void renew(String lockKey, String ownerId, long leaseMillis) &#123; Boolean result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId, String.valueOf(leaseMillis) ); if (!result) &#123; // 锁已不属于当前线程，停止 Watch Dog stopRenew(lockKey); &#125; &#125; /** * 应用关闭时释放资源（可选） */ public void shutdown() &#123; scheduler.shutdown(); &#125;&#125; 锁接口 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.lock;import java.util.concurrent.TimeUnit;public interface DistributedLock &#123; /** * 尝试获取锁 * * @param key 锁的key * @param waitTime 尝试获取锁的最大等待时间 * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit); /** * 尝试获取锁 * 不等待立即返回 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long leaseTime, TimeUnit unit); /** * 获取锁 * 只要获取到锁就返回，否则一直自旋获取锁 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean lock(String key, long leaseTime, TimeUnit unit); /** * 释放锁 * * @param key 锁的key */ void unlock(String key);&#125; 锁实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.UUID;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.LockSupport;@Componentpublic class RedisReentrantLock implements DistributedLock &#123; /** * 锁的key前缀 */ private static final String LOCK_PREFIX = &quot;lock:&quot;; /** * 锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 1.key 不存在时创建锁 * 2.key 存在时判断锁的拥有者是否为当前线程 */ private static final String LOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; /** * 释放锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) */ private static final String UNLOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0 end local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) if (count &gt; 0) then return 1 else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1 end &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; private final RedisLockWatchDog watchDog; private final String uuid = UUID.randomUUID().toString(); public RedisReentrantLock(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; watchDog = new RedisLockWatchDog(redisTemplate); &#125; /** * 获取当前线程的 ownerId * * @return */ private String ownerId() &#123; return uuid + &quot;:&quot; + Thread.currentThread().getId(); &#125; @Override public boolean tryLock(String key, long leaseTime, TimeUnit unit) &#123; String lockKey = LOCK_PREFIX + key; long expireMillis = unit.toMillis(leaseTime); Boolean success = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(LOCK_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId(), String.valueOf(expireMillis) ); if (Boolean.TRUE.equals(success)) &#123;//防止NullPointerException // 启动 Watch Dog（只有在 leaseTime 不确定时） watchDog.startRenew( lockKey, ownerId(), expireMillis ); return true; &#125; return false; &#125; @Override public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) &#123; long deadline = System.currentTimeMillis() + unit.toMillis(waitTime); // 使用带条件的循环，避免重复赋值 while (System.currentTimeMillis() &lt; deadline) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; return false; &#125; @Override public boolean lock(String key, long leaseTime, TimeUnit unit) &#123; // 使用无限循环，语义更清晰 while (true) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; &#125; @Override public void unlock(String key) &#123; String lockKey = LOCK_PREFIX + key; // 先停续期 watchDog.stopRenew(lockKey); // 释放锁 redisTemplate.execute( new DefaultRedisScript&lt;&gt;(UNLOCK_SCRIPT, Long.class), Collections.singletonList(lockKey), ownerId() ); &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example;import com.example.lock.RedisReentrantLock;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;@SpringBootTestpublic class LockTests &#123; @Autowired RedisReentrantLock redisReentrantLock; String lockKey = &quot;order:123&quot;; // 测试获取锁 @Test void demo() &#123; if (redisReentrantLock.tryLock(lockKey, 5, 30, TimeUnit.SECONDS)) &#123; try &#123; // 业务逻辑 doBusiness(); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; // 测试可重入锁 private void doBusiness() &#123; try &#123; if (redisReentrantLock.lock(lockKey, 30, TimeUnit.SECONDS)) &#123; try &#123; System.out.println(&quot;开始执行业务逻辑&quot;); // 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能 TimeUnit.SECONDS.sleep(200); System.out.println(&quot;结束执行业务逻辑&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; // 测试多线程同时获取锁 @Test void demoMultiThread() throws InterruptedException &#123; int threadCount = 5; CountDownLatch latch = new CountDownLatch(threadCount); AtomicInteger successCount = new AtomicInteger(0); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadId = i; new Thread(() -&gt; &#123; try &#123; // 每个线程都尝试获取同一个锁 if (redisReentrantLock.tryLock(lockKey, 10, 30, TimeUnit.SECONDS)) &#123; try &#123; successCount.incrementAndGet(); System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁成功，开始执行业务&quot;); // 模拟业务执行时间 TimeUnit.SECONDS.sleep(3); System.out.println(&quot;线程 &quot; + threadId + &quot; 业务执行完成&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); System.out.println(&quot;线程 &quot; + threadId + &quot; 释放锁&quot;); &#125; &#125; else &#123; System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁失败&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); &#125; &#125;).start(); &#125; // 等待所有线程执行完成 latch.await(); System.out.println(&quot;成功获取锁的线程数: &quot; + successCount.get()); &#125;&#125; SpringBoot 与 Redisson 集成之锁的使用方法 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.52.0&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324@Autowiredprivate RedissonClient redissonClient;……………………………………………………………………………………………………………………………………………………………………………………………………………………```javaRLock lock = redissonClient.getLock(&quot;myLock&quot;);// 传统锁定方式，阻塞等待获取锁// lock.lock();// 或者，获取锁并在10秒后自动解锁// lock.lock(10, TimeUnit.SECONDS);// 或等，尝试在 100 秒内获取锁，获得后在 10 秒后自动解锁boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);if (res) &#123; try &#123; System.out.println(&quot;获取锁成功&quot;); System.out.println(&quot;开始执行业务逻辑&quot;); TimeUnit.SECONDS.sleep(5); &#125; finally &#123; lock.unlock(); &#125;&#125;","summary":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。","date_published":"2025-12-17T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","title":"Redis 命令及数据类型 -- ZSet","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis ZSet 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ZSet-核心详解\">ZSet 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; &#123; member -&gt; score &#125;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">member：唯一，不可重复（String，二进制安全）</span><br><span class=\"line\">score：double 类型，用于排序</span><br><span class=\"line\">集合按 score 从小到大 排序</span><br><span class=\"line\">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSet = Set（去重） + 排序能力</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素唯一</span><br><span class=\"line\">天然有序</span><br><span class=\"line\">支持范围查询</span><br><span class=\"line\">支持排名（rank）</span><br><span class=\"line\">支持按 score 增量更新</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Zset集合操作实现新闻点击排行榜</span></span><br><span class=\"line\">1）点击新闻</span><br><span class=\"line\">ZINCRBY hotNews:20251201 1 news1 <span class=\"comment\"># 点击一次分数 +1</span></span><br><span class=\"line\">2）展示当日点击排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201 0 9 WITHSCORES <span class=\"comment\"># 倒序</span></span><br><span class=\"line\">3）七日搜索榜单计算</span><br><span class=\"line\">ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 <span class=\"comment\"># 合并</span></span><br><span class=\"line\">4）展示七日排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSet 适合 排序 + 查询</span><br><span class=\"line\">score 设计要稳定、可扩展</span><br><span class=\"line\">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class=\"line\">大 ZSet 避免全量遍历</span><br><span class=\"line\">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSet-命令\">ZSet 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForZSet()</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"基础写入-删除-计数\">基础写入 / 删除 / 计数</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素（含 score）</td>\n<td><code>Boolean add(K key, V value, double score)</code></td>\n<td><code>ZADD key score member</code></td>\n<td>新增返回 <code>true</code></td>\n</tr>\n<tr>\n<td>添加元素（仅不存在时）</td>\n<td><code>Boolean addIfAbsent(K key, V value, double score)</code></td>\n<td><code>ZADD key NX score member</code></td>\n<td>Redis ≥ 3.0</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key score member [score member ...]</code></td>\n<td>返回新增数量</td>\n</tr>\n<tr>\n<td>批量添加（仅不存在）</td>\n<td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key NX ...</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>Long remove(K key, Object... values)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>递增 score</td>\n<td><code>Double incrementScore(K key, V value, double delta)</code></td>\n<td><code>ZINCRBY key delta member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小</td>\n<td><code>Long size(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小（同义）</td>\n<td><code>Long zCard(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>API 别名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问\">随机访问</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机获取成员</td>\n<td><code>V randomMember(K key)</code></td>\n<td><code>ZRANDMEMBER key</code></td>\n<td>不返回 score</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n<tr>\n<td>随机获取成员及 score</td>\n<td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td>\n<td><code>ZRANDMEMBER key WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机获取不重复成员及 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>随机获取可重复成员及 score</td>\n<td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"排名-score-查询\">排名 / score 查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取正序排名</td>\n<td><code>Long rank(K key, Object o)</code></td>\n<td><code>ZRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取倒序排名</td>\n<td><code>Long reverseRank(K key, Object o)</code></td>\n<td><code>ZREVRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取 score</td>\n<td><code>Double score(K key, Object o)</code></td>\n<td><code>ZSCORE key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量获取 score</td>\n<td><code>List&lt;Double&gt; score(K key, Object... o)</code></td>\n<td><code>ZMScore key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>score 区间计数</td>\n<td><code>Long count(K key, double min, double max)</code></td>\n<td><code>ZCOUNT key min max</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间查询（rank-score）\">区间查询（rank / score）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 查询</td>\n<td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end</code></td>\n<td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td>\n</tr>\n<tr>\n<td>按 rank 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td>\n<td>按 score 升序分页，返回 member + score</td>\n</tr>\n<tr>\n<td>倒序 rank 查询</td>\n<td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end</code></td>\n<td>按 rank 倒序（高 → 低）</td>\n</tr>\n<tr>\n<td>倒序 rank（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end WITHSCORES</code></td>\n<td>倒序 rank，返回 score</td>\n</tr>\n<tr>\n<td>倒序 score 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min</code></td>\n<td>注意：<strong>max 在前，min 在后</strong></td>\n</tr>\n<tr>\n<td>倒序 score（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td>\n<td>倒序 score，返回 score</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"弹出元素（队列-TopN-场景）\">弹出元素（队列 / TopN 场景）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td>\n<td><code>ZPOPMIN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最小 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td>\n<td><code>ZPOPMIN key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td>\n<td><code>BZPOPMIN key timeout</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td>\n<td><code>ZPOPMAX key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最大 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td>\n<td><code>ZPOPMAX key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td>\n<td><code>BZPOPMAX key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间删除\">区间删除</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 删除</td>\n<td><code>Long removeRange(K key, long start, long end)</code></td>\n<td><code>ZREMRANGEBYRANK key start end</code></td>\n</tr>\n<tr>\n<td>按 score 删除</td>\n<td><code>Long removeRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREMRANGEBYSCORE key min max</code></td>\n</tr>\n<tr>\n<td>按 lex 删除</td>\n<td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td>\n<td><code>ZREMRANGEBYLEX key min max</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合运算（ZSet-特有）\">集合运算（ZSet 特有）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差集</td>\n<td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集</td>\n<td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZINTERSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Lex（字典序，仅-score-相同）\">Lex（字典序，仅 score 相同）</h3>\n<blockquote>\n<p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>\n只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>\n如果 score 不同，Redis 文档明确说明：结果不可预测</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 lex 查询</td>\n<td><code>Set&lt;V&gt; rangeByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td>\n<td>score 必须相同</td>\n</tr>\n<tr>\n<td>倒序 lex 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td>\n<td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>lex 范围存储</td>\n<td><code>Long rangeAndStoreByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>score 范围存储</td>\n<td><code>Long rangeAndStoreByScore(...)</code></td>\n<td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Lex 范围写法规则</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[a</code></td>\n<td>≥ a（包含）</td>\n</tr>\n<tr>\n<td><code>(a</code></td>\n<td>&gt; a（不包含）</td>\n</tr>\n<tr>\n<td><code>[z</code></td>\n<td>≤ z</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>正无穷</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>负无穷</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a ≤ member &lt; d</span></span><br><span class=\"line\">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历\">遍历</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描</td>\n<td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td>\n<td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td>\n<td>推荐替代全量查询</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ ZSet 核心详解 Redis ZSet 是一种 带权重的有序集合，本质结构为： 123456key -&gt; &#123; member -&gt; score &#125;# 说明member：唯一，不可重复（String，二进制安全）score：double 类型，用于排序集合按 score 从小到大 排序score 相同则按 member 的字典序(Lex)排序 ZSet = Set（去重） + 排序能力 ZSet 的核心特性 12345元素唯一天然有序支持范围查询支持排名（rank）支持按 score 增量更新 Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。 ZSet 的应用场景 123456789# Zset集合操作实现新闻点击排行榜1）点击新闻ZINCRBY hotNews:20251201 1 news1 # 点击一次分数 +12）展示当日点击排行前十ZREVRANGE hotNews:20251201 0 9 WITHSCORES # 倒序3）七日搜索榜单计算ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 # 合并4）展示七日排行前十ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES 生产环境建议 12345ZSet 适合 排序 + 查询score 设计要稳定、可扩展定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）大 ZSet 避免全量遍历删除大 ZSet 使用 UNLINK ZSet 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForZSet() 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 基础写入 / 删除 / 计数 方法功能 方法 Redis 原始命令 命令备注 / 推荐替代 添加元素（含 score） Boolean add(K key, V value, double score) ZADD key score member 新增返回 true 添加元素（仅不存在时） Boolean addIfAbsent(K key, V value, double score) ZADD key NX score member Redis ≥ 3.0 批量添加 Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key score member [score member ...] 返回新增数量 批量添加（仅不存在） Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key NX ... — 删除成员 Long remove(K key, Object... values) ZREM key member [member ...] 返回删除数量 递增 score Double incrementScore(K key, V value, double delta) ZINCRBY key delta member — 获取集合大小 Long size(K key) ZCARD key — 获取集合大小（同义） Long zCard(K key) ZCARD key API 别名 随机访问 方法功能 方法 Redis 原始命令 命令备注 随机获取成员 V randomMember(K key) ZRANDMEMBER key 不返回 score 随机获取不重复成员 Set&lt;V&gt; distinctRandomMembers(K key, long count) ZRANDMEMBER key count count &gt; 0 随机获取可重复成员 List&lt;V&gt; randomMembers(K key, long count) ZRANDMEMBER key -count count &lt; 0 随机获取成员及 score TypedTuple&lt;V&gt; randomMemberWithScore(K key) ZRANDMEMBER key WITHSCORES Redis ≥ 6.2 随机获取不重复成员及 score Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count) ZRANDMEMBER key count WITHSCORES — 随机获取可重复成员及 score List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count) ZRANDMEMBER key -count WITHSCORES — 排名 / score 查询 方法功能 方法 Redis 原始命令 备注 获取正序排名 Long rank(K key, Object o) ZRANK key member 从 0 开始 获取倒序排名 Long reverseRank(K key, Object o) ZREVRANK key member 从 0 开始 获取 score Double score(K key, Object o) ZSCORE key member — 批量获取 score List&lt;Double&gt; score(K key, Object... o) ZMScore key member [member ...] Redis ≥ 6.2 score 区间计数 Long count(K key, double min, double max) ZCOUNT key min max — 区间查询（rank / score） 方法功能 方法 Redis 原始命令 备注 按 rank 查询 Set&lt;V&gt; range(K key, long start, long end) ZRANGE key start end 正序rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始） 按 rank 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end) ZRANGE key start end WITHSCORES — 按 score 查询 Set&lt;V&gt; rangeByScore(K key, double min, double max) ZRANGEBYSCORE key min max — 按 score 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max) ZRANGEBYSCORE key min max WITHSCORES — score 分页 Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max LIMIT offset count — score 分页（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count 按 score 升序分页，返回 member + score 倒序 rank 查询 Set&lt;V&gt; reverseRange(K key, long start, long end) ZREVRANGE key start end 按 rank 倒序（高 → 低） 倒序 rank（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end) ZREVRANGE key start end WITHSCORES 倒序 rank，返回 score 倒序 score 查询 Set&lt;V&gt; reverseRangeByScore(K key, double min, double max) ZREVRANGEBYSCORE key max min 注意：max 在前，min 在后 倒序 score（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max) ZREVRANGEBYSCORE key max min WITHSCORES 倒序 score，返回 score 弹出元素（队列 / TopN 场景） 方法功能 方法 Redis 原始命令 备注 弹出最小 score TypedTuple&lt;V&gt; popMin(K key) ZPOPMIN key — 批量弹出最小 score Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count) ZPOPMIN key count — 阻塞弹出最小 score TypedTuple&lt;V&gt; popMin(K key, timeout) BZPOPMIN key timeout — 弹出最大 score TypedTuple&lt;V&gt; popMax(K key) ZPOPMAX key — 批量弹出最大 score Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count) ZPOPMAX key count — 阻塞弹出最大 score TypedTuple&lt;V&gt; popMax(K key, timeout) BZPOPMAX key timeout — 区间删除 方法功能 方法 Redis 原始命令（完整） 按 rank 删除 Long removeRange(K key, long start, long end) ZREMRANGEBYRANK key start end 按 score 删除 Long removeRangeByScore(K key, double min, double max) ZREMRANGEBYSCORE key min max 按 lex 删除 Long removeRangeByLex(K key, Range&lt;String&gt; range) ZREMRANGEBYLEX key min max 集合运算（ZSet 特有） 方法功能 方法 Redis 原始命令（完整） 备注 差集 Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] Redis ≥ 6.2 差集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 差集并存储 Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZDIFFSTORE destination numkeys key [otherKey ...] Redis ≥ 6.2 交集 Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] Redis ≥ 6.2 交集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 并集 Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] Redis ≥ 6.2 并集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 交集并存储 Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZINTERSTORE destination numkeys key [key ...] 并集并存储 Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZUNIONSTORE destination numkeys key [key ...] Lex（字典序，仅 score 相同） Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。 只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义 如果 score 不同，Redis 文档明确说明：结果不可预测 方法功能 方法 Redis 原始命令（完整） 备注 按 lex 查询 Set&lt;V&gt; rangeByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] score 必须相同 倒序 lex 查询 Set&lt;V&gt; reverseRangeByLex(...) ZREVRANGEBYLEX key max min [LIMIT offset count] — lex 范围存储 Long rangeAndStoreByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey Spring 封装 score 范围存储 Long rangeAndStoreByScore(...) ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey Spring 封装 Lex 范围写法规则 写法 含义 [a ≥ a（包含） (a &gt; a（不包含） [z ≤ z + 正无穷 - 负无穷 示例 12# a ≤ member &lt; dZRANGEBYLEX my:zset [a (d 遍历 方法功能 方法 Redis 原始命令（完整） 备注 游标扫描 Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options) ZSCAN key cursor [MATCH pattern] [COUNT count] 推荐替代全量查询","summary":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","title":"Redis 命令及数据类型 -- Set","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Set 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Set-核心详解\">Set 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 是一个无序、不重复元素集合，本质上是：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Set&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素唯一（自动去重）</span><br><span class=\"line\">无顺序（不保证插入顺序）</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Set 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动去重</span><br><span class=\"line\">高效成员判断</span><br><span class=\"line\">支持集合运算</span><br><span class=\"line\">操作原子性强</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Set 应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 微信抽奖小程序</span></span><br><span class=\"line\">1）点击参与抽奖加入集合</span><br><span class=\"line\">SADD key &#123;userlD&#125;</span><br><span class=\"line\">2）查看参与抽奖所有用户</span><br><span class=\"line\">SMEMBERS key</span><br><span class=\"line\">3）抽取count名中奖者</span><br><span class=\"line\">SRANDMEMBER key [count] / SPOP key [count]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信微博点赞，收藏，标签</span></span><br><span class=\"line\">1) 点赞</span><br><span class=\"line\">SADD like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">2) 取消点赞</span><br><span class=\"line\">SREM like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">3) 检查用户是否点过赞</span><br><span class=\"line\">SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">4) 获取点赞的用户列表</span><br><span class=\"line\">SMEMBERS like:&#123;消息ID&#125;</span><br><span class=\"line\">5) 获取点赞用户数</span><br><span class=\"line\">SCARD like:&#123;消息ID&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集合操作</span></span><br><span class=\"line\"><span class=\"comment\"># 交集：多个集合中同时存在的元素</span></span><br><span class=\"line\">SINTER set1 set2 set3 -&gt; &#123; c &#125; <span class=\"comment\"># 交集，共同关注 / 共同好友 / 共同兴趣</span></span><br><span class=\"line\"><span class=\"comment\"># 并集：存在于任意一个集合中的元素</span></span><br><span class=\"line\">SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; <span class=\"comment\"># 多来源合并后的用户全集</span></span><br><span class=\"line\"><span class=\"comment\"># 差集：只存在于第一个集合中的元素</span></span><br><span class=\"line\">SDIFF set1 set2 set3 -&gt; &#123;a&#125; <span class=\"comment\"># 差集，推荐好友</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 适合 成员资格判断</span><br><span class=\"line\">始终控制成员规模</span><br><span class=\"line\">大 Set 遍历使用 SSCAN</span><br><span class=\"line\">集合运算放在离线或低频场景</span><br><span class=\"line\">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"Set-命令\">Set 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForSet()</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"写操作（增-删-移动）\">写操作（增 / 删 / 移动）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>向集合添加元素</td>\n<td><code>add(K key, V... values)</code></td>\n<td><code>SADD key member [member ...]</code></td>\n<td>返回新增成员数量</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"移除-弹出成员\">移除 / 弹出成员</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从集合移除元素</td>\n<td><code>remove(K key, Object... values)</code></td>\n<td><code>SREM key member [member ...]</code></td>\n<td>返回移除成员数量</td>\n</tr>\n<tr>\n<td>随机弹出一个元素</td>\n<td><code>pop(K key)</code></td>\n<td><code>SPOP key</code></td>\n<td>随机且删除</td>\n</tr>\n<tr>\n<td>随机弹出多个元素</td>\n<td><code>pop(K key, long count)</code></td>\n<td><code>SPOP key count</code></td>\n<td>Redis ≥ 3.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员移动（原子）\">成员移动（原子）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>将成员移动到其他集合</td>\n<td><code>move(K key, V value, K destKey)</code></td>\n<td><code>SMOVE source dest member</code></td>\n<td>原子操作</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合大小\">集合大小</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取集合大小</td>\n<td><code>size(K key)</code></td>\n<td><code>SCARD key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员存在性判断\">成员存在性判断</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>判断是否是成员</td>\n<td><code>isMember(K key, Object o)</code></td>\n<td><code>SISMEMBER key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量判断成员是否存在</td>\n<td><code>isMember(K key, Object... objects)</code></td>\n<td><code>SMISMEMBER key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"交集（Intersection）\">交集（Intersection）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, K otherKey)</code></td>\n<td><code>SINTER key key</code></td>\n<td>O(N × M)</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(Collection&lt;K&gt; keys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SINTERSTORE dest key key</code></td>\n<td>返回结果数量</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"并集（Union）\">并集（Union）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, K otherKey)</code></td>\n<td><code>SUNION key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(Collection&lt;K&gt; keys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"差集（Difference）\">差集（Difference）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, K otherKey)</code></td>\n<td><code>SDIFF key key</code></td>\n<td>key 顺序影响结果</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(Collection&lt;K&gt; keys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全量-随机读取\">全量 / 随机读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取所有成员</td>\n<td><code>members(K key)</code></td>\n<td><code>SMEMBERS key</code></td>\n<td>大集合慎用</td>\n</tr>\n<tr>\n<td>随机获取一个成员</td>\n<td><code>randomMember(K key)</code></td>\n<td><code>SRANDMEMBER key</code></td>\n<td>不删除</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>distinctRandomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>randomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"游标扫描（大集合推荐）\">游标扫描（大集合推荐）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描成员</td>\n<td><code>scan(K key, ScanOptions options)</code></td>\n<td><code>SSCAN key cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>SMEMBERS</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Set 核心详解 Redis Set 是一个无序、不重复元素集合，本质上是： 12345key -&gt; Set&lt;String&gt;# 说明元素唯一（自动去重）无顺序（不保证插入顺序）元素类型为 String（二进制安全） Set 的核心特性 1234自动去重高效成员判断支持集合运算操作原子性强 Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Set 应用场景 12345678910111213141516171819202122232425262728# 微信抽奖小程序1）点击参与抽奖加入集合SADD key &#123;userlD&#125;2）查看参与抽奖所有用户SMEMBERS key3）抽取count名中奖者SRANDMEMBER key [count] / SPOP key [count]# 微信微博点赞，收藏，标签1) 点赞SADD like:&#123;消息ID&#125; &#123;用户ID&#125;2) 取消点赞SREM like:&#123;消息ID&#125; &#123;用户ID&#125;3) 检查用户是否点过赞SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;4) 获取点赞的用户列表SMEMBERS like:&#123;消息ID&#125;5) 获取点赞用户数SCARD like:&#123;消息ID&#125;# 集合操作# 交集：多个集合中同时存在的元素SINTER set1 set2 set3 -&gt; &#123; c &#125; # 交集，共同关注 / 共同好友 / 共同兴趣# 并集：存在于任意一个集合中的元素SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; # 多来源合并后的用户全集# 差集：只存在于第一个集合中的元素SDIFF set1 set2 set3 -&gt; &#123;a&#125; # 差集，推荐好友 生产环境建议 12345Set 适合 成员资格判断始终控制成员规模大 Set 遍历使用 SSCAN集合运算放在离线或低频场景删除大 Set 使用 UNLINK Set 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForSet() 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 写操作（增 / 删 / 移动） 方法功能 方法 Redis 原始命令 备注 向集合添加元素 add(K key, V... values) SADD key member [member ...] 返回新增成员数量 移除 / 弹出成员 方法功能 方法 Redis 原始命令 备注 从集合移除元素 remove(K key, Object... values) SREM key member [member ...] 返回移除成员数量 随机弹出一个元素 pop(K key) SPOP key 随机且删除 随机弹出多个元素 pop(K key, long count) SPOP key count Redis ≥ 3.2 成员移动（原子） 方法功能 方法 Redis 原始命令 备注 将成员移动到其他集合 move(K key, V value, K destKey) SMOVE source dest member 原子操作 集合大小 方法功能 方法 Redis 原始命令 备注 获取集合大小 size(K key) SCARD key — 成员存在性判断 方法功能 方法 Redis 原始命令 备注 判断是否是成员 isMember(K key, Object o) SISMEMBER key member — 批量判断成员是否存在 isMember(K key, Object... objects) SMISMEMBER key member [member ...] Redis ≥ 6.2 交集（Intersection） 方法功能 方法 Redis 原始命令 备注 计算交集 intersect(K key, K otherKey) SINTER key key O(N × M) 计算交集 intersect(K key, Collection&lt;K&gt; otherKeys) SINTER key [key ...] — 计算交集 intersect(Collection&lt;K&gt; keys) SINTER key [key ...] — 交集并存储 intersectAndStore(K key, K otherKey, K destKey) SINTERSTORE dest key key 返回结果数量 交集并存储 intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SINTERSTORE dest key [key ...] — 交集并存储 intersectAndStore(Collection&lt;K&gt; keys, K destKey) SINTERSTORE dest key [key ...] — 并集（Union） 方法功能 方法 Redis 原始命令 备注 计算并集 union(K key, K otherKey) SUNION key key — 计算并集 union(K key, Collection&lt;K&gt; otherKeys) SUNION key [key ...] — 计算并集 union(Collection&lt;K&gt; keys) SUNION key [key ...] — 并集并存储 unionAndStore(K key, K otherKey, K destKey) SUNIONSTORE dest key key — 并集并存储 unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SUNIONSTORE dest key [key ...] — 并集并存储 unionAndStore(Collection&lt;K&gt; keys, K destKey) SUNIONSTORE dest key [key ...] — 差集（Difference） 方法功能 方法 Redis 原始命令 备注 计算差集 difference(K key, K otherKey) SDIFF key key key 顺序影响结果 计算差集 difference(K key, Collection&lt;K&gt; otherKeys) SDIFF key [key ...] — 计算差集 difference(Collection&lt;K&gt; keys) SDIFF key [key ...] — 差集并存储 differenceAndStore(K key, K otherKey, K destKey) SDIFFSTORE dest key key — 差集并存储 differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SDIFFSTORE dest key [key ...] — 差集并存储 differenceAndStore(Collection&lt;K&gt; keys, K destKey) SDIFFSTORE dest key [key ...] — 全量 / 随机读取 方法功能 方法 Redis 原始命令 备注 获取所有成员 members(K key) SMEMBERS key 大集合慎用 随机获取一个成员 randomMember(K key) SRANDMEMBER key 不删除 随机获取不重复成员 distinctRandomMembers(K key, long count) SRANDMEMBER key count count &gt; 0 随机获取可重复成员 randomMembers(K key, long count) SRANDMEMBER key -count count &lt; 0 游标扫描（大集合推荐） 方法功能 方法 Redis 原始命令 备注 游标扫描成员 scan(K key, ScanOptions options) SSCAN key cursor [MATCH] [COUNT] 推荐替代 SMEMBERS","summary":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:38:05.000Z","tags":["技术","redis","redis"]}]}